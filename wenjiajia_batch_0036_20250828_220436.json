{
  "metadata": {
    "batch_number": 36,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.291195",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "278/B",
      "title": "B. New Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 30) — the number of titles you've got to consider. Then follow n problem titles, one per line. Each title only consists of lowercase English letters (specifically, it doesn't contain any spaces) and has the length from 1 to 20, inclusive.",
      "output_spec": "OutputPrint a string, consisting of lowercase English letters — the lexicographically minimum shortest original title.",
      "sample_tests": "ExamplesInputCopy5threehorsesgoodsubstringssecretprimematrixbeautifulyearOutputCopyjInputCopy4aabdefghijklmnopqrstuvwxyzcOutputCopyab",
      "description": "B. New Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 30) — the number of titles you've got to consider. Then follow n problem titles, one per line. Each title only consists of lowercase English letters (specifically, it doesn't contain any spaces) and has the length from 1 to 20, inclusive.\n\nOutputPrint a string, consisting of lowercase English letters — the lexicographically minimum shortest original title.\n\nInputCopy5threehorsesgoodsubstringssecretprimematrixbeautifulyearOutputCopyjInputCopy4aabdefghijklmnopqrstuvwxyzcOutputCopyab\n\nInputCopy5threehorsesgoodsubstringssecretprimematrixbeautifulyear\n\nOutputCopyj\n\nInputCopy4aabdefghijklmnopqrstuvwxyzc\n\nOutputCopyab\n\nNoteIn the first sample the first 9 letters of the English alphabet (a, b, c, d, e, f, g, h, i) occur in the problem titles, so the answer is letter j.In the second sample the titles contain 26 English letters, so the shortest original title cannot have length 1. Title aa occurs as a substring in the first title.",
      "solutions": [
        {
          "title": "Codeforces Round #170 - Codeforces",
          "content": "Hi everyone!Codeforces Round #170 begins soon, and I'll be the problem setter. I hope many people will be happy to solve all the problems.UPD: The scoring is dynamic. The problems are sorted by increasing of estimated difficulty.And the standard part: thanks to Gerald for his help with the problems, Seyaua and sdya for testing the contest, Delinur for translations, MikeMirzayanov for building the Codeforces platform.Good luck!UPD: Tutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6806",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 443
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces",
          "content": "278B - New ProblemThe total number of different strings of 2 letters is 262 = 676, but the total length of the input strings is no more than 600. It means that the length of answer is no more than 2. So just check all the strings of length 1 and 2.277A - Learning LanguagesBuild bipartite graph with n nodes for employees and m nodes for languages. If an employee initially knows a language, than there will be an edge between corresponding nodes. Now the problem is simple: add the minimal number of edges in such a way, that all the n employees will be in the same connected component. Obviously, this number equals to the number of initially connected components, containing at least one employee, minus one. But there is one exception (pretest #4): if initially everyone knows no languages, we'll have to add n edges, because we can't add the edges between employees (remember that the graph is bipartite).277B - Set of PointsFor m = 3, n = 5 and m = 3, n = 6 there is no solution.Let's learn how to construct the solution for n = 2m, where m ≥ 5 and is odd. Set up m points on a circle of sufficiently large radius. This will be the inner polygon. The outer polygon will be the inner polygon multiplied by 2. More precisely (1 ≤ i ≤ m):If m is even, construct the solution for m + 1 and then delete one point from each polygon. If n < 2m, delete 2m - n points from the inner polygon.Unfortunately, this solution doesn't work for m = 4, n = 7 and m = 4, n = 8.Another approach is to set up m points on a convex function (for example, y = x2 + 107), and set up the rest n - m points on a concave function (for example, y =  - x2 - 107). Take a look at rng_58's solution — 3210150.277C - GameAt first, notice that horizontal and vertical cuts are independent. Consider a single horizontal line. It contains m unit segments. And in any game state it's always possible to decrease the number of uncut units as the player wants. Imagine, that she starts growing a segment from a border, increasing it's length by 1 at a time. Each time the total uncut length decreases by either 0 or 1. In the end it obviously reaches 0.The same holds for vertical lines as well. So if there are no initial cuts, the game is a nim with n - 1 piles of m stones and m - 1 piles of n stones. Could be solved with simple formula.Initial k cuts should be just a technical difficulty. For any vertical/horizontal line, which contains at least one of the cuts, it's pile size should be decreased by the total length of all segments on this line.How to make a first move in nim: let res is the result of state (grundy function), and ai is the size of the i-th pile. Then the result of the game without i-th pile is . We want to replace ai with some x, so that . Obviously, the only possible . The resulting solution: find a pile for which , and decrease it downto .277D - Google Code JamSuppose we have fixed set of inputs that we have to solve. Let's learn how to determine the optimal order. Obviously, Small inputs (and Large inputs with probFail = 0) won't fail in any case. It means that our penalty time is no less than submission time of last such ``safe'' inputs. So we will solve such inputs before all the others. Inputs with probFail = 1 are just a waste of time, we won't solve such inputs. Now we have only inputs with 0 < probFail < 1. Let i and j be two problems that we are going to solve consecutively at some moment. Let's check, if it is optimal to solve them in order i, j, or in reversed order. We can discard all the other inputs, because they don't affect on the relative order of these two.(timeLargei + timeLargej)(1 - probFailj) + timeLargei(1 - probFaili)probFailj < (timeLargei + timeLargej)(1 - probFaili) + timeLargej(1 - probFailj)probFaili - probFailj·timeLargej - timeLargei·probFailj·probFaili <  - probFaili·timeLargei - timeLargej·probFaili·probFailjtimeLargei·probFaili(1 - probFailj) < timeLargej·probFailj(1 - probFaili)timeLargei·probFaili / (1 - probFaili) < timeLargej·probFailj / (1 - probFailj)Now we've got a comparator for sort, which will give us the optimal order. Note, that inputs with probFail = 0, 1 will be sorted by the comparator correctly as well, so it's not a corner case.Let's return to the initial problem. First of all, sort problems with the optimal comparator (it's clear that any other order won't be optimal by time, and the score doesn't depend on the order). Calculate the DP: z[i][j] = pair of maximal expected total score and minimal expected penalty time with this score, if we've already decided what to do with the first i problems, and we've spent j real minutes from the contest's start. There are 3 options for the i-the problem: skip: update z[i + 1][j] with the same expected values solve the Small input: update z[i + 1][j + timeSmalli], the expected total score increases by scoreSmalli, and the expected penalty time increases by timeSmalli (we assume that this input is solved in the very beggining of the contest) solve both inputs: update z[i + 1][j + timeSmalli + timeLargei], the expected total score increases by scoreSmalli + (1 - probFaili)scoreLargei, and the expected penalty time becomes timeSmalli + (1 - probFaili)(j + timeLargei) + probFaili·penaltyTime(z[i][j]), where penaltyTime(z[i][j]) is the expected penalty time from DP The resulting answer is the best of z[n][i], (0 ≤ i ≤ t).The expected total score could be a number around 1012 with 6 digits after decimal point. So it can't be precisely stored in double. And any (even small) error in calculating score may lead to completely wrong expected time (pretest #7). For example, you can multiply all the probabilities by 106 and store the expected score as integer number to avoid this error.277E - Binary Tree on PlaneIf there is no \"binary\" restriction, the solution is simple greedy. Each node of the tree (except the root) must have exactly 1 parent, and each node could be parent for any number of nodes.Let's assign for each node i (except the root) such a node pi as a parent, so that ypi > yi and distance between i and pi is minimal possible. Renumerate all the nodes in order of non-increasing of y. Now it's clear that pi < i (2 ≤ i ≤ n). So we've just built a directed tree with all the arcs going downwards. And it has minimal possible length. Let's recall the \"binary\" restriction. And realize that it doesn't really change anything: greedy transforms to min-cost-max-flow on the same distance matrix as edge's costs, but each node must have no more than 2 incoming flow units.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 278\\s*B"
          },
          "content_length": 6517
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #170 - Codeforces - Code 1",
          "code": "5 2\n0\n0\n0\n0\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 2",
          "code": "5 2\n0\n0\n0\n0\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 3",
          "code": "100 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 4",
          "code": "const int N = 1009, M = 2009, P = 1000000;\n\npair<LL, DB> dp[M];\nint n, t;\n\nstruct rec{\n    LL t1, t2, s1, s2, pf;\n    LL ps()const{return P - pf;}\n    bool operator < (const rec& r) const{\n        return t2*pf*r.ps() < r.t2*r.pf*ps();\n    }\n    void input(){\n        RD(s1, s2, t1, t2), pf = RF() * P + 0.5, s1 *= P;\n    }\n    void update(){\n        DWN(i, t, 0){\n            if (i + t1 <= t) checkMax(dp[i+t1], MP(dp[i].fi+s1, dp[i].se));\n            if (i + t1 + t2 <= t) checkMax(dp[i+t1+t2], MP(dp[i].fi+s1+s2*ps(), (dp[i].se+t2)*pf/P));\n        }\n    }\n} A[N];\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    RD(n, t); REP(i, n) A[i].input();\n    sort(A, A+n); REP(i, n) A[i].update();\n\n    LL a = 0; DB b = 0; REP_1(i, t){\n        if (dp[i].fi > a || dp[i].fi == a && i-dp[i].se < b){\n            a = dp[i].fi, b = i-dp[i].se;\n        }\n    }\n    printf(\"%.9lf %.9lf\\n\", (DB) a/P, b);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 5",
          "code": "const int N = 1009, M = 2009, P = 1000000;\n\npair<LL, DB> dp[M];\nint n, t;\n\nstruct rec{\n    LL t1, t2, s1, s2, pf;\n    LL ps()const{return P - pf;}\n    bool operator < (const rec& r) const{\n        return t2*pf*r.ps() < r.t2*r.pf*ps();\n    }\n    void input(){\n        RD(s1, s2, t1, t2), pf = RF() * P + 0.5, s1 *= P;\n    }\n    void update(){\n        DWN(i, t, 0){\n            if (i + t1 <= t) checkMax(dp[i+t1], MP(dp[i].fi+s1, dp[i].se));\n            if (i + t1 + t2 <= t) checkMax(dp[i+t1+t2], MP(dp[i].fi+s1+s2*ps(), (dp[i].se+t2)*pf/P));\n        }\n    }\n} A[N];\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    RD(n, t); REP(i, n) A[i].input();\n    sort(A, A+n); REP(i, n) A[i].update();\n\n    LL a = 0; DB b = 0; REP_1(i, t){\n        if (dp[i].fi > a || dp[i].fi == a && i-dp[i].se < b){\n            a = dp[i].fi, b = i-dp[i].se;\n        }\n    }\n    printf(\"%.9lf %.9lf\\n\", (DB) a/P, b);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 6",
          "code": "void add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    if(root[toindex].c[s[strindex]] == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,root[toindex].c[s[strindex]],++strindex);\n    }\n}\n\nvoid add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    int ind = root[toindex].c[s[strindex]];\n    if(ind == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,ind,++strindex);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 7",
          "code": "void add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    if(root[toindex].c[s[strindex]] == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,root[toindex].c[s[strindex]],++strindex);\n    }\n}\n\nvoid add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    int ind = root[toindex].c[s[strindex]];\n    if(ind == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,ind,++strindex);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 8",
          "code": "add(s,root[toindex].c[s[strindex]],++strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 9",
          "code": "add(s,root[toindex].c[s[strindex]],++strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 10",
          "code": "++strindex,add(s,root[toindex].c[s[strindex]],strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 11",
          "code": "add(s,root[toindex].c[s[strindex]],strindex),++strindex,;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 1",
          "code": "probability      penalty\ni WA, j WA    pi*pj            0\ni AC, j WA    (1-pi)pj         ti\ni WA, j AC    pi(1-pj)         ti+tj\ni AC, j AC    (1-pi)(1-pj)     ti+(ti+tj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 2",
          "code": "probability      penalty\ni WA, j WA    pi*pj            0\ni AC, j WA    (1-pi)pj         ti\ni WA, j AC    pi(1-pj)         ti+tj\ni AC, j AC    (1-pi)(1-pj)     ti+(ti+tj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 3",
          "code": "By the Google Code Jam rules the time penalty is the time when the last correct solution was submitted.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; ++i){\n        string s = inf.readLine(\"[a-z]{1,20}\", \"title\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; ++i){\n        string s = inf.readLine(\"[a-z]{1,20}\", \"title\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; ++i){\n        string s = inf.readLine(\"[a-z]{1,20}\", \"title\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> titles(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 20);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            titles[i] = s;\n        }\n    } else if (type == \"all_letters\") {\n        // Generate titles that include all letters from 'a' to 'z'\n        vector<char> letters;\n        for(char c = 'a'; c <= 'z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        int letters_per_title = (26 + n - 1) / n; // Ceiling division\n        int idx = 0;\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < letters_per_title && idx < 26; ++j, ++idx) {\n                s += letters[idx];\n            }\n            if (s.empty()) {\n                // Generate random letters if we've run out\n                int len = rnd.next(1, 20);\n                for(int j = 0; j < len; ++j) {\n                    char c = 'a' + rnd.next(26);\n                    s += c;\n                }\n            }\n            titles[i] = s;\n        }\n    } else if (type == \"full_substrings_len1\") {\n        // Generate titles that include all letters from 'a' to 'z'\n        vector<char> letters;\n        for(char c = 'a'; c <= 'z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        int letters_per_title = (26 + n - 1) / n; // Ceiling division\n        int idx = 0;\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < letters_per_title && idx < 26; ++j, ++idx) {\n                s += letters[idx];\n            }\n            if (s.empty()) {\n                s += 'a';\n            }\n            titles[i] = s;\n        }\n    } else if(type == \"max_length\") {\n        // Generate titles of length 20\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < 20; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            titles[i] = s;\n        }\n    } else if(type == \"edge_n1\") {\n        // n = 1\n        n = 1;\n        titles.resize(n);\n        int len = rnd.next(1, 20);\n        string s;\n        for(int j = 0; j < len; ++j) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n        titles[0] = s;\n    } else if(type == \"single_letter\") {\n        // All titles are single letters\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            string s(1, c);\n            titles[i] = s;\n        }\n    } else if(type == \"full_substrings_len2\") {\n        // Try to cover as many substrings of length 2 as possible\n        vector<string> substrings;\n        for(char c1 = 'a'; c1 <= 'z'; ++c1) {\n            for(char c2 = 'a'; c2 <= 'z'; ++c2) {\n                string s = \"\";\n                s += c1;\n                s += c2;\n                substrings.push_back(s);\n            }\n        }\n        shuffle(substrings.begin(), substrings.end());\n        vector<string> temp_titles(n);\n        for(int i = 0; i < substrings.size(); ++i) {\n            int idx = i % n;\n            temp_titles[idx] += substrings[i];\n        }\n        for(int i = 0; i < n; ++i) {\n            if (temp_titles[i].length() > 20) {\n                titles[i] = temp_titles[i].substr(0, 20);\n            } else if (temp_titles[i].empty()) {\n                titles[i] = \"a\";\n            } else {\n                titles[i] = temp_titles[i];\n            }\n        }\n    } // You can add more types here if needed\n\n    // Output the titles\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%s\\n\", titles[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> titles(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 20);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            titles[i] = s;\n        }\n    } else if (type == \"all_letters\") {\n        // Generate titles that include all letters from 'a' to 'z'\n        vector<char> letters;\n        for(char c = 'a'; c <= 'z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        int letters_per_title = (26 + n - 1) / n; // Ceiling division\n        int idx = 0;\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < letters_per_title && idx < 26; ++j, ++idx) {\n                s += letters[idx];\n            }\n            if (s.empty()) {\n                // Generate random letters if we've run out\n                int len = rnd.next(1, 20);\n                for(int j = 0; j < len; ++j) {\n                    char c = 'a' + rnd.next(26);\n                    s += c;\n                }\n            }\n            titles[i] = s;\n        }\n    } else if (type == \"full_substrings_len1\") {\n        // Generate titles that include all letters from 'a' to 'z'\n        vector<char> letters;\n        for(char c = 'a'; c <= 'z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        int letters_per_title = (26 + n - 1) / n; // Ceiling division\n        int idx = 0;\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < letters_per_title && idx < 26; ++j, ++idx) {\n                s += letters[idx];\n            }\n            if (s.empty()) {\n                s += 'a';\n            }\n            titles[i] = s;\n        }\n    } else if(type == \"max_length\") {\n        // Generate titles of length 20\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < 20; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            titles[i] = s;\n        }\n    } else if(type == \"edge_n1\") {\n        // n = 1\n        n = 1;\n        titles.resize(n);\n        int len = rnd.next(1, 20);\n        string s;\n        for(int j = 0; j < len; ++j) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n        titles[0] = s;\n    } else if(type == \"single_letter\") {\n        // All titles are single letters\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            string s(1, c);\n            titles[i] = s;\n        }\n    } else if(type == \"full_substrings_len2\") {\n        // Try to cover as many substrings of length 2 as possible\n        vector<string> substrings;\n        for(char c1 = 'a'; c1 <= 'z'; ++c1) {\n            for(char c2 = 'a'; c2 <= 'z'; ++c2) {\n                string s = \"\";\n                s += c1;\n                s += c2;\n                substrings.push_back(s);\n            }\n        }\n        shuffle(substrings.begin(), substrings.end());\n        vector<string> temp_titles(n);\n        for(int i = 0; i < substrings.size(); ++i) {\n            int idx = i % n;\n            temp_titles[idx] += substrings[i];\n        }\n        for(int i = 0; i < n; ++i) {\n            if (temp_titles[i].length() > 20) {\n                titles[i] = temp_titles[i].substr(0, 20);\n            } else if (temp_titles[i].empty()) {\n                titles[i] = \"a\";\n            } else {\n                titles[i] = temp_titles[i];\n            }\n        }\n    } // You can add more types here if needed\n\n    // Output the titles\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%s\\n\", titles[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 15 -type random\n./gen -n 20 -type random\n./gen -n 25 -type random\n./gen -n 30 -type random\n\n./gen -n 1 -type all_letters\n./gen -n 5 -type all_letters\n./gen -n 10 -type all_letters\n./gen -n 26 -type all_letters\n\n./gen -n 1 -type full_substrings_len1\n./gen -n 2 -type full_substrings_len1\n./gen -n 13 -type full_substrings_len1\n./gen -n 26 -type full_substrings_len1\n\n./gen -n 1 -type max_length\n./gen -n 15 -type max_length\n./gen -n 30 -type max_length\n\n./gen -n 1 -type edge_n1\n\n./gen -n 1 -type single_letter\n./gen -n 5 -type single_letter\n./gen -n 13 -type single_letter\n./gen -n 26 -type single_letter\n./gen -n 30 -type single_letter\n\n./gen -n 10 -type full_substrings_len2\n./gen -n 15 -type full_substrings_len2\n./gen -n 30 -type full_substrings_len2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:00:56.792256",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "278/C",
      "title": "C. Learning Languages",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n, m ≤ 100) — the number of employees and the number of languages.Then n lines follow — each employee's language list. At the beginning of the i-th line is integer ki (0 ≤ ki ≤ m) — the number of languages the i-th employee knows. Next, the i-th line contains ki integers — aij (1 ≤ aij ≤ m) — the identifiers of languages the i-th employee knows. It is guaranteed that all the identifiers in one list are distinct. Note that an employee may know zero languages.The numbers in the lines are separated by single spaces.",
      "output_spec": "OutputPrint a single integer — the minimum amount of money to pay so that in the end every employee could write a letter to every other one (other employees can help out translating).",
      "sample_tests": "ExamplesInputCopy5 51 22 2 32 3 42 4 51 5OutputCopy0InputCopy8 703 1 2 31 12 5 42 6 71 32 7 41 1OutputCopy2InputCopy2 21 20OutputCopy1",
      "description": "C. Learning Languages\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n, m ≤ 100) — the number of employees and the number of languages.Then n lines follow — each employee's language list. At the beginning of the i-th line is integer ki (0 ≤ ki ≤ m) — the number of languages the i-th employee knows. Next, the i-th line contains ki integers — aij (1 ≤ aij ≤ m) — the identifiers of languages the i-th employee knows. It is guaranteed that all the identifiers in one list are distinct. Note that an employee may know zero languages.The numbers in the lines are separated by single spaces.\n\nOutputPrint a single integer — the minimum amount of money to pay so that in the end every employee could write a letter to every other one (other employees can help out translating).\n\nInputCopy5 51 22 2 32 3 42 4 51 5OutputCopy0InputCopy8 703 1 2 31 12 5 42 6 71 32 7 41 1OutputCopy2InputCopy2 21 20OutputCopy1\n\nInputCopy5 51 22 2 32 3 42 4 51 5\n\nOutputCopy0\n\nInputCopy8 703 1 2 31 12 5 42 6 71 32 7 41 1\n\nOutputCopy2\n\nInputCopy2 21 20\n\nOutputCopy1\n\nNoteIn the second sample the employee 1 can learn language 2, and employee 8 can learn language 4.In the third sample employee 2 must learn language 2.",
      "solutions": [
        {
          "title": "Codeforces Round #170 - Codeforces",
          "content": "Hi everyone!Codeforces Round #170 begins soon, and I'll be the problem setter. I hope many people will be happy to solve all the problems.UPD: The scoring is dynamic. The problems are sorted by increasing of estimated difficulty.And the standard part: thanks to Gerald for his help with the problems, Seyaua and sdya for testing the contest, Delinur for translations, MikeMirzayanov for building the Codeforces platform.Good luck!UPD: Tutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6806",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 443
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces",
          "content": "278B - New ProblemThe total number of different strings of 2 letters is 262 = 676, but the total length of the input strings is no more than 600. It means that the length of answer is no more than 2. So just check all the strings of length 1 and 2.277A - Learning LanguagesBuild bipartite graph with n nodes for employees and m nodes for languages. If an employee initially knows a language, than there will be an edge between corresponding nodes. Now the problem is simple: add the minimal number of edges in such a way, that all the n employees will be in the same connected component. Obviously, this number equals to the number of initially connected components, containing at least one employee, minus one. But there is one exception (pretest #4): if initially everyone knows no languages, we'll have to add n edges, because we can't add the edges between employees (remember that the graph is bipartite).277B - Set of PointsFor m = 3, n = 5 and m = 3, n = 6 there is no solution.Let's learn how to construct the solution for n = 2m, where m ≥ 5 and is odd. Set up m points on a circle of sufficiently large radius. This will be the inner polygon. The outer polygon will be the inner polygon multiplied by 2. More precisely (1 ≤ i ≤ m):If m is even, construct the solution for m + 1 and then delete one point from each polygon. If n < 2m, delete 2m - n points from the inner polygon.Unfortunately, this solution doesn't work for m = 4, n = 7 and m = 4, n = 8.Another approach is to set up m points on a convex function (for example, y = x2 + 107), and set up the rest n - m points on a concave function (for example, y =  - x2 - 107). Take a look at rng_58's solution — 3210150.277C - GameAt first, notice that horizontal and vertical cuts are independent. Consider a single horizontal line. It contains m unit segments. And in any game state it's always possible to decrease the number of uncut units as the player wants. Imagine, that she starts growing a segment from a border, increasing it's length by 1 at a time. Each time the total uncut length decreases by either 0 or 1. In the end it obviously reaches 0.The same holds for vertical lines as well. So if there are no initial cuts, the game is a nim with n - 1 piles of m stones and m - 1 piles of n stones. Could be solved with simple formula.Initial k cuts should be just a technical difficulty. For any vertical/horizontal line, which contains at least one of the cuts, it's pile size should be decreased by the total length of all segments on this line.How to make a first move in nim: let res is the result of state (grundy function), and ai is the size of the i-th pile. Then the result of the game without i-th pile is . We want to replace ai with some x, so that . Obviously, the only possible . The resulting solution: find a pile for which , and decrease it downto .277D - Google Code JamSuppose we have fixed set of inputs that we have to solve. Let's learn how to determine the optimal order. Obviously, Small inputs (and Large inputs with probFail = 0) won't fail in any case. It means that our penalty time is no less than submission time of last such ``safe'' inputs. So we will solve such inputs before all the others. Inputs with probFail = 1 are just a waste of time, we won't solve such inputs. Now we have only inputs with 0 < probFail < 1. Let i and j be two problems that we are going to solve consecutively at some moment. Let's check, if it is optimal to solve them in order i, j, or in reversed order. We can discard all the other inputs, because they don't affect on the relative order of these two.(timeLargei + timeLargej)(1 - probFailj) + timeLargei(1 - probFaili)probFailj < (timeLargei + timeLargej)(1 - probFaili) + timeLargej(1 - probFailj)probFaili - probFailj·timeLargej - timeLargei·probFailj·probFaili <  - probFaili·timeLargei - timeLargej·probFaili·probFailjtimeLargei·probFaili(1 - probFailj) < timeLargej·probFailj(1 - probFaili)timeLargei·probFaili / (1 - probFaili) < timeLargej·probFailj / (1 - probFailj)Now we've got a comparator for sort, which will give us the optimal order. Note, that inputs with probFail = 0, 1 will be sorted by the comparator correctly as well, so it's not a corner case.Let's return to the initial problem. First of all, sort problems with the optimal comparator (it's clear that any other order won't be optimal by time, and the score doesn't depend on the order). Calculate the DP: z[i][j] = pair of maximal expected total score and minimal expected penalty time with this score, if we've already decided what to do with the first i problems, and we've spent j real minutes from the contest's start. There are 3 options for the i-the problem: skip: update z[i + 1][j] with the same expected values solve the Small input: update z[i + 1][j + timeSmalli], the expected total score increases by scoreSmalli, and the expected penalty time increases by timeSmalli (we assume that this input is solved in the very beggining of the contest) solve both inputs: update z[i + 1][j + timeSmalli + timeLargei], the expected total score increases by scoreSmalli + (1 - probFaili)scoreLargei, and the expected penalty time becomes timeSmalli + (1 - probFaili)(j + timeLargei) + probFaili·penaltyTime(z[i][j]), where penaltyTime(z[i][j]) is the expected penalty time from DP The resulting answer is the best of z[n][i], (0 ≤ i ≤ t).The expected total score could be a number around 1012 with 6 digits after decimal point. So it can't be precisely stored in double. And any (even small) error in calculating score may lead to completely wrong expected time (pretest #7). For example, you can multiply all the probabilities by 106 and store the expected score as integer number to avoid this error.277E - Binary Tree on PlaneIf there is no \"binary\" restriction, the solution is simple greedy. Each node of the tree (except the root) must have exactly 1 parent, and each node could be parent for any number of nodes.Let's assign for each node i (except the root) such a node pi as a parent, so that ypi > yi and distance between i and pi is minimal possible. Renumerate all the nodes in order of non-increasing of y. Now it's clear that pi < i (2 ≤ i ≤ n). So we've just built a directed tree with all the arcs going downwards. And it has minimal possible length. Let's recall the \"binary\" restriction. And realize that it doesn't really change anything: greedy transforms to min-cost-max-flow on the same distance matrix as edge's costs, but each node must have no more than 2 incoming flow units.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 278"
          },
          "content_length": 6517
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #170 - Codeforces - Code 1",
          "code": "5 2\n0\n0\n0\n0\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 2",
          "code": "5 2\n0\n0\n0\n0\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 3",
          "code": "100 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 4",
          "code": "const int N = 1009, M = 2009, P = 1000000;\n\npair<LL, DB> dp[M];\nint n, t;\n\nstruct rec{\n    LL t1, t2, s1, s2, pf;\n    LL ps()const{return P - pf;}\n    bool operator < (const rec& r) const{\n        return t2*pf*r.ps() < r.t2*r.pf*ps();\n    }\n    void input(){\n        RD(s1, s2, t1, t2), pf = RF() * P + 0.5, s1 *= P;\n    }\n    void update(){\n        DWN(i, t, 0){\n            if (i + t1 <= t) checkMax(dp[i+t1], MP(dp[i].fi+s1, dp[i].se));\n            if (i + t1 + t2 <= t) checkMax(dp[i+t1+t2], MP(dp[i].fi+s1+s2*ps(), (dp[i].se+t2)*pf/P));\n        }\n    }\n} A[N];\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    RD(n, t); REP(i, n) A[i].input();\n    sort(A, A+n); REP(i, n) A[i].update();\n\n    LL a = 0; DB b = 0; REP_1(i, t){\n        if (dp[i].fi > a || dp[i].fi == a && i-dp[i].se < b){\n            a = dp[i].fi, b = i-dp[i].se;\n        }\n    }\n    printf(\"%.9lf %.9lf\\n\", (DB) a/P, b);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 5",
          "code": "const int N = 1009, M = 2009, P = 1000000;\n\npair<LL, DB> dp[M];\nint n, t;\n\nstruct rec{\n    LL t1, t2, s1, s2, pf;\n    LL ps()const{return P - pf;}\n    bool operator < (const rec& r) const{\n        return t2*pf*r.ps() < r.t2*r.pf*ps();\n    }\n    void input(){\n        RD(s1, s2, t1, t2), pf = RF() * P + 0.5, s1 *= P;\n    }\n    void update(){\n        DWN(i, t, 0){\n            if (i + t1 <= t) checkMax(dp[i+t1], MP(dp[i].fi+s1, dp[i].se));\n            if (i + t1 + t2 <= t) checkMax(dp[i+t1+t2], MP(dp[i].fi+s1+s2*ps(), (dp[i].se+t2)*pf/P));\n        }\n    }\n} A[N];\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    RD(n, t); REP(i, n) A[i].input();\n    sort(A, A+n); REP(i, n) A[i].update();\n\n    LL a = 0; DB b = 0; REP_1(i, t){\n        if (dp[i].fi > a || dp[i].fi == a && i-dp[i].se < b){\n            a = dp[i].fi, b = i-dp[i].se;\n        }\n    }\n    printf(\"%.9lf %.9lf\\n\", (DB) a/P, b);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 6",
          "code": "void add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    if(root[toindex].c[s[strindex]] == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,root[toindex].c[s[strindex]],++strindex);\n    }\n}\n\nvoid add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    int ind = root[toindex].c[s[strindex]];\n    if(ind == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,ind,++strindex);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 7",
          "code": "void add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    if(root[toindex].c[s[strindex]] == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,root[toindex].c[s[strindex]],++strindex);\n    }\n}\n\nvoid add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    int ind = root[toindex].c[s[strindex]];\n    if(ind == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,ind,++strindex);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 8",
          "code": "add(s,root[toindex].c[s[strindex]],++strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 9",
          "code": "add(s,root[toindex].c[s[strindex]],++strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 10",
          "code": "++strindex,add(s,root[toindex].c[s[strindex]],strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 11",
          "code": "add(s,root[toindex].c[s[strindex]],strindex),++strindex,;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 1",
          "code": "probability      penalty\ni WA, j WA    pi*pj            0\ni AC, j WA    (1-pi)pj         ti\ni WA, j AC    pi(1-pj)         ti+tj\ni AC, j AC    (1-pi)(1-pj)     ti+(ti+tj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 2",
          "code": "probability      penalty\ni WA, j WA    pi*pj            0\ni AC, j WA    (1-pi)pj         ti\ni WA, j AC    pi(1-pj)         ti+tj\ni AC, j AC    (1-pi)(1-pj)     ti+(ti+tj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 3",
          "code": "By the Google Code Jam rules the time penalty is the time when the last correct solution was submitted.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int ki = inf.readInt(0, m, \"ki\");\n        vector<int> langs;\n\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < ki; j++) {\n                inf.readSpace();\n                int aij = inf.readInt(1, m, \"aij\");\n                langs.push_back(aij);\n            }\n            inf.readEoln();\n\n            sort(langs.begin(), langs.end());\n            for (int j = 1; j < langs.size(); j++) {\n                ensuref(langs[j] != langs[j-1],\n                        \"Languages in employee %d's list must be distinct\", i);\n            }\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int ki = inf.readInt(0, m, \"ki\");\n        vector<int> langs;\n\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < ki; j++) {\n                inf.readSpace();\n                int aij = inf.readInt(1, m, \"aij\");\n                langs.push_back(aij);\n            }\n            inf.readEoln();\n\n            sort(langs.begin(), langs.end());\n            for (int j = 1; j < langs.size(); j++) {\n                ensuref(langs[j] != langs[j-1],\n                        \"Languages in employee %d's list must be distinct\", i);\n            }\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int ki = inf.readInt(0, m, \"ki\");\n        vector<int> langs;\n\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < ki; j++) {\n                inf.readSpace();\n                int aij = inf.readInt(1, m, \"aij\");\n                langs.push_back(aij);\n            }\n            inf.readEoln();\n\n            sort(langs.begin(), langs.end());\n            for (int j = 1; j < langs.size(); j++) {\n                ensuref(langs[j] != langs[j-1],\n                        \"Languages in employee %d's list must be distinct\", i);\n            }\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1); // For disjoint_groups, the number of groups.\n\n    vector<vector<int>> languages(n);\n\n    if (type == \"all_zero_languages\") {\n        // All employees know zero languages\n        languages.assign(n, vector<int>());\n    } else if (type == \"all_know_all_languages\") {\n        // All employees know all languages\n        vector<int> all_languages(m);\n        for (int i = 0; i < m; ++i) {\n            all_languages[i] = i + 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            languages[i] = all_languages;\n        }\n    } else if (type == \"one_employee_knows_all\") {\n        // One employee knows all languages, others know zero\n        vector<int> all_languages(m);\n        for (int i = 0; i < m; ++i) {\n            all_languages[i] = i + 1;\n        }\n        languages.assign(n, vector<int>());\n        languages[0] = all_languages;\n    } else if (type == \"disjoint_groups\") {\n        // Employees are divided into k disjoint groups\n        // Each group knows different languages\n        if (k > n) k = n;\n        int group_size = n / k;\n        int extra = n % k;\n        int lang_per_group = m / k;\n        if (lang_per_group == 0) lang_per_group = 1;\n        int language_idx = 1;\n        int employee_idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int current_group_size = group_size + (i < extra ? 1 : 0);\n            int languages_in_group = lang_per_group;\n            if (i == k - 1) {\n                languages_in_group = m - (lang_per_group * (k - 1));\n                if (languages_in_group <= 0) languages_in_group = lang_per_group;\n            }\n            vector<int> group_languages;\n            for (int j = 0; j < languages_in_group && language_idx <= m; ++j) {\n                group_languages.push_back(language_idx++);\n            }\n            if (group_languages.empty()) group_languages.push_back(rnd.next(1, m));\n            for (int j = 0; j < current_group_size && employee_idx < n; ++j) {\n                languages[employee_idx++] = group_languages;\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly assign languages to employees\n        for (int i = 0; i < n; ++i) {\n            int ki = rnd.next(0, m);\n            set<int> langs;\n            while ((int)langs.size() < ki) {\n                int lang = rnd.next(1, m);\n                langs.insert(lang);\n            }\n            languages[i] = vector<int>(langs.begin(), langs.end());\n        }\n    } else if (type == \"max_languages\") {\n        // Each employee knows m languages\n        for (int i = 0; i < n; ++i) {\n            vector<int> employee_langs(m);\n            for (int j = 0; j < m; ++j) {\n                employee_langs[j] = j + 1;\n            }\n            languages[i] = employee_langs;\n        }\n    } else if (type == \"max_employees\") {\n        // n is maximum, m can be any value\n        // Let's assign random languages\n        for (int i = 0; i < n; ++i) {\n            int ki = rnd.next(0, m);\n            set<int> langs;\n            while ((int)langs.size() < ki) {\n                int lang = rnd.next(1, m);\n                langs.insert(lang);\n            }\n            languages[i] = vector<int>(langs.begin(), langs.end());\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", (int)languages[i].size());\n        for (int lang : languages[i]) {\n            printf(\" %d\", lang);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1); // For disjoint_groups, the number of groups.\n\n    vector<vector<int>> languages(n);\n\n    if (type == \"all_zero_languages\") {\n        // All employees know zero languages\n        languages.assign(n, vector<int>());\n    } else if (type == \"all_know_all_languages\") {\n        // All employees know all languages\n        vector<int> all_languages(m);\n        for (int i = 0; i < m; ++i) {\n            all_languages[i] = i + 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            languages[i] = all_languages;\n        }\n    } else if (type == \"one_employee_knows_all\") {\n        // One employee knows all languages, others know zero\n        vector<int> all_languages(m);\n        for (int i = 0; i < m; ++i) {\n            all_languages[i] = i + 1;\n        }\n        languages.assign(n, vector<int>());\n        languages[0] = all_languages;\n    } else if (type == \"disjoint_groups\") {\n        // Employees are divided into k disjoint groups\n        // Each group knows different languages\n        if (k > n) k = n;\n        int group_size = n / k;\n        int extra = n % k;\n        int lang_per_group = m / k;\n        if (lang_per_group == 0) lang_per_group = 1;\n        int language_idx = 1;\n        int employee_idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int current_group_size = group_size + (i < extra ? 1 : 0);\n            int languages_in_group = lang_per_group;\n            if (i == k - 1) {\n                languages_in_group = m - (lang_per_group * (k - 1));\n                if (languages_in_group <= 0) languages_in_group = lang_per_group;\n            }\n            vector<int> group_languages;\n            for (int j = 0; j < languages_in_group && language_idx <= m; ++j) {\n                group_languages.push_back(language_idx++);\n            }\n            if (group_languages.empty()) group_languages.push_back(rnd.next(1, m));\n            for (int j = 0; j < current_group_size && employee_idx < n; ++j) {\n                languages[employee_idx++] = group_languages;\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly assign languages to employees\n        for (int i = 0; i < n; ++i) {\n            int ki = rnd.next(0, m);\n            set<int> langs;\n            while ((int)langs.size() < ki) {\n                int lang = rnd.next(1, m);\n                langs.insert(lang);\n            }\n            languages[i] = vector<int>(langs.begin(), langs.end());\n        }\n    } else if (type == \"max_languages\") {\n        // Each employee knows m languages\n        for (int i = 0; i < n; ++i) {\n            vector<int> employee_langs(m);\n            for (int j = 0; j < m; ++j) {\n                employee_langs[j] = j + 1;\n            }\n            languages[i] = employee_langs;\n        }\n    } else if (type == \"max_employees\") {\n        // n is maximum, m can be any value\n        // Let's assign random languages\n        for (int i = 0; i < n; ++i) {\n            int ki = rnd.next(0, m);\n            set<int> langs;\n            while ((int)langs.size() < ki) {\n                int lang = rnd.next(1, m);\n                langs.insert(lang);\n            }\n            languages[i] = vector<int>(langs.begin(), langs.end());\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", (int)languages[i].size());\n        for (int lang : languages[i]) {\n            printf(\" %d\", lang);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m, test various types\n./gen -n 2 -m 2 -type all_zero_languages\n./gen -n 2 -m 2 -type all_know_all_languages\n./gen -n 2 -m 2 -type one_employee_knows_all\n./gen -n 2 -m 2 -type disjoint_groups -k 2\n./gen -n 2 -m 2 -type random\n\n# Medium n and m\n./gen -n 50 -m 50 -type all_zero_languages\n./gen -n 50 -m 50 -type all_know_all_languages\n./gen -n 50 -m 50 -type one_employee_knows_all\n./gen -n 50 -m 50 -type disjoint_groups -k 5\n./gen -n 50 -m 50 -type random\n\n# Maximum n and m\n./gen -n 100 -m 100 -type all_zero_languages\n./gen -n 100 -m 100 -type all_know_all_languages\n./gen -n 100 -m 100 -type one_employee_knows_all\n./gen -n 100 -m 100 -type disjoint_groups -k 10\n./gen -n 100 -m 100 -type random\n\n# Test with varying k in disjoint_groups\n./gen -n 100 -m 100 -type disjoint_groups -k 2\n./gen -n 100 -m 100 -type disjoint_groups -k 3\n./gen -n 100 -m 100 -type disjoint_groups -k 4\n./gen -n 100 -m 100 -type disjoint_groups -k 5\n\n# Edge cases: small m, employees know zero or one language\n./gen -n 50 -m 2 -type random\n./gen -n 50 -m 2 -type disjoint_groups -k 2\n./gen -n 100 -m 5 -type random\n./gen -n 100 -m 5 -type disjoint_groups -k 5\n\n# Random test cases with random n and m\n./gen -n 75 -m 80 -type random\n./gen -n 85 -m 90 -type random\n./gen -n 95 -m 100 -type random\n\n# Maximize number of languages per employee\n./gen -n 100 -m 100 -type max_languages\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:00:58.729564",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "278/D",
      "title": "D. Set of Points",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two integers n and m (3 ≤ m ≤ 100, m ≤ n ≤ 2m).",
      "output_spec": "OutputIf there is no solution, print \"-1\". Otherwise, print n pairs of integers — the coordinates of points of any set with the convexity of m. The coordinates shouldn't exceed 108 in their absolute value.",
      "sample_tests": "ExamplesInputCopy4 3OutputCopy0 03 00 31 1InputCopy6 3OutputCopy-1InputCopy6 6OutputCopy10 0-10 010 19 19 -10 -2InputCopy7 4OutputCopy176166 6377709276 539564654734 174109910147 434207790497 366519606663 21061859328 886001",
      "description": "D. Set of Points\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains two integers n and m (3 ≤ m ≤ 100, m ≤ n ≤ 2m).\n\nOutputIf there is no solution, print \"-1\". Otherwise, print n pairs of integers — the coordinates of points of any set with the convexity of m. The coordinates shouldn't exceed 108 in their absolute value.\n\nInputCopy4 3OutputCopy0 03 00 31 1InputCopy6 3OutputCopy-1InputCopy6 6OutputCopy10 0-10 010 19 19 -10 -2InputCopy7 4OutputCopy176166 6377709276 539564654734 174109910147 434207790497 366519606663 21061859328 886001\n\nInputCopy4 3\n\nOutputCopy0 03 00 31 1\n\nInputCopy6 3\n\nOutputCopy-1\n\nInputCopy6 6\n\nOutputCopy10 0-10 010 19 19 -10 -2\n\nInputCopy7 4\n\nOutputCopy176166 6377709276 539564654734 174109910147 434207790497 366519606663 21061859328 886001",
      "solutions": [
        {
          "title": "Codeforces Round #170 - Codeforces",
          "content": "Hi everyone!Codeforces Round #170 begins soon, and I'll be the problem setter. I hope many people will be happy to solve all the problems.UPD: The scoring is dynamic. The problems are sorted by increasing of estimated difficulty.And the standard part: thanks to Gerald for his help with the problems, Seyaua and sdya for testing the contest, Delinur for translations, MikeMirzayanov for building the Codeforces platform.Good luck!UPD: Tutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6806",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 443
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces",
          "content": "278B - New ProblemThe total number of different strings of 2 letters is 262 = 676, but the total length of the input strings is no more than 600. It means that the length of answer is no more than 2. So just check all the strings of length 1 and 2.277A - Learning LanguagesBuild bipartite graph with n nodes for employees and m nodes for languages. If an employee initially knows a language, than there will be an edge between corresponding nodes. Now the problem is simple: add the minimal number of edges in such a way, that all the n employees will be in the same connected component. Obviously, this number equals to the number of initially connected components, containing at least one employee, minus one. But there is one exception (pretest #4): if initially everyone knows no languages, we'll have to add n edges, because we can't add the edges between employees (remember that the graph is bipartite).277B - Set of PointsFor m = 3, n = 5 and m = 3, n = 6 there is no solution.Let's learn how to construct the solution for n = 2m, where m ≥ 5 and is odd. Set up m points on a circle of sufficiently large radius. This will be the inner polygon. The outer polygon will be the inner polygon multiplied by 2. More precisely (1 ≤ i ≤ m):If m is even, construct the solution for m + 1 and then delete one point from each polygon. If n < 2m, delete 2m - n points from the inner polygon.Unfortunately, this solution doesn't work for m = 4, n = 7 and m = 4, n = 8.Another approach is to set up m points on a convex function (for example, y = x2 + 107), and set up the rest n - m points on a concave function (for example, y =  - x2 - 107). Take a look at rng_58's solution — 3210150.277C - GameAt first, notice that horizontal and vertical cuts are independent. Consider a single horizontal line. It contains m unit segments. And in any game state it's always possible to decrease the number of uncut units as the player wants. Imagine, that she starts growing a segment from a border, increasing it's length by 1 at a time. Each time the total uncut length decreases by either 0 or 1. In the end it obviously reaches 0.The same holds for vertical lines as well. So if there are no initial cuts, the game is a nim with n - 1 piles of m stones and m - 1 piles of n stones. Could be solved with simple formula.Initial k cuts should be just a technical difficulty. For any vertical/horizontal line, which contains at least one of the cuts, it's pile size should be decreased by the total length of all segments on this line.How to make a first move in nim: let res is the result of state (grundy function), and ai is the size of the i-th pile. Then the result of the game without i-th pile is . We want to replace ai with some x, so that . Obviously, the only possible . The resulting solution: find a pile for which , and decrease it downto .277D - Google Code JamSuppose we have fixed set of inputs that we have to solve. Let's learn how to determine the optimal order. Obviously, Small inputs (and Large inputs with probFail = 0) won't fail in any case. It means that our penalty time is no less than submission time of last such ``safe'' inputs. So we will solve such inputs before all the others. Inputs with probFail = 1 are just a waste of time, we won't solve such inputs. Now we have only inputs with 0 < probFail < 1. Let i and j be two problems that we are going to solve consecutively at some moment. Let's check, if it is optimal to solve them in order i, j, or in reversed order. We can discard all the other inputs, because they don't affect on the relative order of these two.(timeLargei + timeLargej)(1 - probFailj) + timeLargei(1 - probFaili)probFailj < (timeLargei + timeLargej)(1 - probFaili) + timeLargej(1 - probFailj)probFaili - probFailj·timeLargej - timeLargei·probFailj·probFaili <  - probFaili·timeLargei - timeLargej·probFaili·probFailjtimeLargei·probFaili(1 - probFailj) < timeLargej·probFailj(1 - probFaili)timeLargei·probFaili / (1 - probFaili) < timeLargej·probFailj / (1 - probFailj)Now we've got a comparator for sort, which will give us the optimal order. Note, that inputs with probFail = 0, 1 will be sorted by the comparator correctly as well, so it's not a corner case.Let's return to the initial problem. First of all, sort problems with the optimal comparator (it's clear that any other order won't be optimal by time, and the score doesn't depend on the order). Calculate the DP: z[i][j] = pair of maximal expected total score and minimal expected penalty time with this score, if we've already decided what to do with the first i problems, and we've spent j real minutes from the contest's start. There are 3 options for the i-the problem: skip: update z[i + 1][j] with the same expected values solve the Small input: update z[i + 1][j + timeSmalli], the expected total score increases by scoreSmalli, and the expected penalty time increases by timeSmalli (we assume that this input is solved in the very beggining of the contest) solve both inputs: update z[i + 1][j + timeSmalli + timeLargei], the expected total score increases by scoreSmalli + (1 - probFaili)scoreLargei, and the expected penalty time becomes timeSmalli + (1 - probFaili)(j + timeLargei) + probFaili·penaltyTime(z[i][j]), where penaltyTime(z[i][j]) is the expected penalty time from DP The resulting answer is the best of z[n][i], (0 ≤ i ≤ t).The expected total score could be a number around 1012 with 6 digits after decimal point. So it can't be precisely stored in double. And any (even small) error in calculating score may lead to completely wrong expected time (pretest #7). For example, you can multiply all the probabilities by 106 and store the expected score as integer number to avoid this error.277E - Binary Tree on PlaneIf there is no \"binary\" restriction, the solution is simple greedy. Each node of the tree (except the root) must have exactly 1 parent, and each node could be parent for any number of nodes.Let's assign for each node i (except the root) such a node pi as a parent, so that ypi > yi and distance between i and pi is minimal possible. Renumerate all the nodes in order of non-increasing of y. Now it's clear that pi < i (2 ≤ i ≤ n). So we've just built a directed tree with all the arcs going downwards. And it has minimal possible length. Let's recall the \"binary\" restriction. And realize that it doesn't really change anything: greedy transforms to min-cost-max-flow on the same distance matrix as edge's costs, but each node must have no more than 2 incoming flow units.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 278"
          },
          "content_length": 6517
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #170 - Codeforces - Code 1",
          "code": "5 2\n0\n0\n0\n0\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 2",
          "code": "5 2\n0\n0\n0\n0\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 3",
          "code": "100 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 4",
          "code": "const int N = 1009, M = 2009, P = 1000000;\n\npair<LL, DB> dp[M];\nint n, t;\n\nstruct rec{\n    LL t1, t2, s1, s2, pf;\n    LL ps()const{return P - pf;}\n    bool operator < (const rec& r) const{\n        return t2*pf*r.ps() < r.t2*r.pf*ps();\n    }\n    void input(){\n        RD(s1, s2, t1, t2), pf = RF() * P + 0.5, s1 *= P;\n    }\n    void update(){\n        DWN(i, t, 0){\n            if (i + t1 <= t) checkMax(dp[i+t1], MP(dp[i].fi+s1, dp[i].se));\n            if (i + t1 + t2 <= t) checkMax(dp[i+t1+t2], MP(dp[i].fi+s1+s2*ps(), (dp[i].se+t2)*pf/P));\n        }\n    }\n} A[N];\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    RD(n, t); REP(i, n) A[i].input();\n    sort(A, A+n); REP(i, n) A[i].update();\n\n    LL a = 0; DB b = 0; REP_1(i, t){\n        if (dp[i].fi > a || dp[i].fi == a && i-dp[i].se < b){\n            a = dp[i].fi, b = i-dp[i].se;\n        }\n    }\n    printf(\"%.9lf %.9lf\\n\", (DB) a/P, b);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 5",
          "code": "const int N = 1009, M = 2009, P = 1000000;\n\npair<LL, DB> dp[M];\nint n, t;\n\nstruct rec{\n    LL t1, t2, s1, s2, pf;\n    LL ps()const{return P - pf;}\n    bool operator < (const rec& r) const{\n        return t2*pf*r.ps() < r.t2*r.pf*ps();\n    }\n    void input(){\n        RD(s1, s2, t1, t2), pf = RF() * P + 0.5, s1 *= P;\n    }\n    void update(){\n        DWN(i, t, 0){\n            if (i + t1 <= t) checkMax(dp[i+t1], MP(dp[i].fi+s1, dp[i].se));\n            if (i + t1 + t2 <= t) checkMax(dp[i+t1+t2], MP(dp[i].fi+s1+s2*ps(), (dp[i].se+t2)*pf/P));\n        }\n    }\n} A[N];\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    RD(n, t); REP(i, n) A[i].input();\n    sort(A, A+n); REP(i, n) A[i].update();\n\n    LL a = 0; DB b = 0; REP_1(i, t){\n        if (dp[i].fi > a || dp[i].fi == a && i-dp[i].se < b){\n            a = dp[i].fi, b = i-dp[i].se;\n        }\n    }\n    printf(\"%.9lf %.9lf\\n\", (DB) a/P, b);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 6",
          "code": "void add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    if(root[toindex].c[s[strindex]] == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,root[toindex].c[s[strindex]],++strindex);\n    }\n}\n\nvoid add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    int ind = root[toindex].c[s[strindex]];\n    if(ind == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,ind,++strindex);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 7",
          "code": "void add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    if(root[toindex].c[s[strindex]] == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,root[toindex].c[s[strindex]],++strindex);\n    }\n}\n\nvoid add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    int ind = root[toindex].c[s[strindex]];\n    if(ind == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,ind,++strindex);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 8",
          "code": "add(s,root[toindex].c[s[strindex]],++strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 9",
          "code": "add(s,root[toindex].c[s[strindex]],++strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 10",
          "code": "++strindex,add(s,root[toindex].c[s[strindex]],strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 11",
          "code": "add(s,root[toindex].c[s[strindex]],strindex),++strindex,;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 1",
          "code": "probability      penalty\ni WA, j WA    pi*pj            0\ni AC, j WA    (1-pi)pj         ti\ni WA, j AC    pi(1-pj)         ti+tj\ni AC, j AC    (1-pi)(1-pj)     ti+(ti+tj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 2",
          "code": "probability      penalty\ni WA, j WA    pi*pj            0\ni AC, j WA    (1-pi)pj         ti\ni WA, j AC    pi(1-pj)         ti+tj\ni AC, j AC    (1-pi)(1-pj)     ti+(ti+tj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 Tutorial - Codeforces - Code 3",
          "code": "By the Google Code Jam rules the time penalty is the time when the last correct solution was submitted.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= n && n <= 2 * m, \"n must be in [m, 2*m], but n=%d, m=%d\", n, m);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= n && n <= 2 * m, \"n must be in [m, 2*m], but n=%d, m=%d\", n, m);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= n && n <= 2 * m, \"n must be in [m, 2*m], but n=%d, m=%d\", n, m);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const long long COORD_LIMIT = 100000000LL;\n\n// Returns 2 * (area of the triangle p0->p1->p2).\n// > 0 if counter-clockwise, < 0 if clockwise, = 0 if collinear.\nlong long cross(\n    long long x0, long long y0,\n    long long x1, long long y1,\n    long long x2, long long y2)\n{\n    return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0);\n}\n\n// Build the convex hull using the standard Andrew's monotone chain algorithm\n// and return the indices of the hull (in terms of the original order in 'pts').\nvector<int> buildHull(const vector<pair<long long, long long>>& pts)\n{\n    int n = (int)pts.size();\n    // Pair up each point with its index\n    vector<pair<pair<long long, long long>, int>> arr(n);\n    for (int i = 0; i < n; i++)\n        arr[i] = {{pts[i].first, pts[i].second}, i};\n\n    // Sort by x, then by y\n    sort(arr.begin(), arr.end(), [](auto &a, auto &b) {\n        if (a.first.first != b.first.first)\n            return a.first.first < b.first.first;\n        return a.first.second < b.first.second;\n    });\n\n    // Build lower hull\n    vector<int> hull;\n    for (int i = 0; i < n; i++) {\n        while (hull.size() >= 2) {\n            auto &p1 = arr[hull[hull.size() - 2]].first;\n            auto &p2 = arr[hull[hull.size() - 1]].first;\n            auto &p3 = arr[i].first;\n            if (cross(p1.first, p1.second, p2.first, p2.second, p3.first, p3.second) <= 0)\n                hull.pop_back();\n            else\n                break;\n        }\n        hull.push_back(i);\n    }\n    // Build upper hull\n    int lowerSize = (int)hull.size();\n    for (int i = n - 2, t = lowerSize + 1; i >= 0; i--) {\n        while ((int)hull.size() >= t) {\n            auto &p1 = arr[hull[hull.size() - 2]].first;\n            auto &p2 = arr[hull[hull.size() - 1]].first;\n            auto &p3 = arr[i].first;\n            if (cross(p1.first, p1.second, p2.first, p2.second, p3.first, p3.second) <= 0)\n                hull.pop_back();\n            else\n                break;\n        }\n        hull.push_back(i);\n    }\n    hull.pop_back(); // Remove the duplicated starting point\n\n    // Convert from sorted-array indices back to original input indices\n    vector<int> result;\n    for (int idx : hull) {\n        result.push_back(arr[idx].second);\n    }\n    return result;\n}\n\n// Parse a string as a 64-bit integer within [minVal, maxVal] or quit with _wa if invalid.\nlong long parseLongLong(InStream &stream, const string &s, long long minVal, long long maxVal)\n{\n    // Quick check for valid integer characters\n    // (We allow leading '+' or '-' and digits.)\n    for (int i = 0; i < (int)s.size(); i++) {\n        char c = s[i];\n        if (!( (c >= '0' && c <= '9') || (c == '-' && i == 0) || (c == '+' && i == 0) )) {\n            stream.quitf(_wa, \"Expected an integer, got '%s'\", s.c_str());\n        }\n    }\n    long long val;\n    try {\n        val = stoll(s);\n    } catch (...) {\n        stream.quitf(_wa, \"Expected an integer, got '%s'\", s.c_str());\n    }\n    if (val < minVal || val > maxVal) {\n        stream.quitf(_wa, \"Integer '%s' out of range [%lld, %lld]\",\n                     s.c_str(), minVal, maxVal);\n    }\n    return val;\n}\n\n// Read and validate a solution from 'stream'. If it is \"-1\", hasSolution=false.\n// Otherwise, read n pairs and check no three collinear & hull size == m.\n// Return the points if a solution is given, or an empty vector if no solution.\nvector<pair<long long, long long>> readSolution(InStream &stream, int n, int m, bool &hasSolution)\n{\n    string firstToken = stream.readToken();\n    if (firstToken == \"-1\") {\n        // The stream claims no solution\n        hasSolution = false;\n        return {};\n    }\n\n    // Otherwise, firstToken should be x-coordinate of the first point\n    hasSolution = true;\n    long long firstX = parseLongLong(stream, firstToken, -COORD_LIMIT, COORD_LIMIT);\n    long long firstY = stream.readLong(-COORD_LIMIT, COORD_LIMIT, \"y\");\n\n    vector<pair<long long, long long>> pts;\n    pts.push_back({firstX, firstY});\n\n    // read the rest n-1 points\n    for (int i = 1; i < n; i++) {\n        long long x = stream.readLong(-COORD_LIMIT, COORD_LIMIT, \"x\");\n        long long y = stream.readLong(-COORD_LIMIT, COORD_LIMIT, \"y\");\n        pts.push_back({x, y});\n    }\n\n    // Check that no three points are collinear\n    // O(n^3) is fine for n <= 200 (given constraints: n <= 2m, m <= 100 => n <= 200)\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                long long c = cross(\n                    pts[i].first, pts[i].second,\n                    pts[j].first, pts[j].second,\n                    pts[k].first, pts[k].second\n                );\n                if (c == 0) {\n                    stream.quitf(_wa,\n                        \"Three collinear points found: indices %d, %d, %d\",\n                        i+1, j+1, k+1);\n                }\n            }\n        }\n    }\n\n    // Build convex hull and check its size\n    vector<int> hullIdx = buildHull(pts);\n    int hullSize = (int)hullIdx.size();\n    if (hullSize != m) {\n        stream.quitf(_wa, \"Convex hull size %d != m = %d\", hullSize, m);\n    }\n\n    return pts;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read n, m from input\n    int n = inf.readInt(3, 200, \"n\");\n    int m = inf.readInt(3, 100, \"m\");\n    // (Given constraints: m <= n <= 2m, etc.)\n\n    bool juryHasSolution = false, partHasSolution = false;\n    vector<pair<long long, long long>> juryPoints, partPoints;\n\n    // 1) Read the jury's answer\n    try {\n        juryPoints = readSolution(ans, n, m, juryHasSolution);\n    } catch (...) {\n        quitf(_fail, \"Unexpected error while reading jury's solution\");\n    }\n\n    // 2) Read the participant's answer\n    try {\n        partPoints = readSolution(ouf, n, m, partHasSolution);\n    } catch (...) {\n        // If there's an error, testlib will already have set WA for participant\n        return 0;\n    }\n\n    // Compare\n    if (!juryHasSolution && !partHasSolution) {\n        // Both say \"-1\"\n        quitf(_ok, \"Both claim no solution\");\n    }\n    else if (!juryHasSolution && partHasSolution) {\n        // Jury: no solution; Participant: found a solution => jury is wrong => fail\n        quitf(_fail, \"Jury claims no solution, but participant found one\");\n    }\n    else if (juryHasSolution && !partHasSolution) {\n        // Jury: has a solution; Participant: says -1 => WA\n        quitf(_wa, \"Participant claims no solution while jury provided one\");\n    }\n    else {\n        // Both have solutions => we have already validated correctness => OK\n        quitf(_ok, \"Both solutions are valid\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"possible\") {\n        // Generate n and m where a solution exists\n        if (n == -1 || m == -1) {\n            do {\n                m = rnd.next(3, 100);\n                n = rnd.next(m, 2*m);\n            } while (m == 3 && n >= 5);\n        } else {\n            if (m < 3 || m > 100 || n < m || n > 2*m) {\n                fprintf(stderr, \"Invalid parameters for possible case: n=%d m=%d\\n\", n, m);\n                return 1;\n            }\n            if (m == 3 && n >= 5) {\n                fprintf(stderr, \"Impossible case in possible type: n=%d m=%d\\n\", n, m);\n                return 1;\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Generate n and m where a solution doesn't exist\n        m = 3;\n        n = rnd.next(5, 6);\n    } else if (type == \"max\") {\n        m = 100;\n        n = 200;\n    } else if (type == \"min\") {\n        m = 3;\n        n = 3;\n    } else if (type == \"random\") {\n        // Generate random n and m within constraints\n        if (n == -1 || m == -1) {\n            m = rnd.next(3, 100);\n            n = rnd.next(m, 2*m);\n        } else {\n            if (m < 3 || m > 100 || n < m || n > 2*m) {\n                fprintf(stderr, \"Invalid parameters for random case: n=%d m=%d\\n\", n, m);\n                return 1;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"possible\") {\n        // Generate n and m where a solution exists\n        if (n == -1 || m == -1) {\n            do {\n                m = rnd.next(3, 100);\n                n = rnd.next(m, 2*m);\n            } while (m == 3 && n >= 5);\n        } else {\n            if (m < 3 || m > 100 || n < m || n > 2*m) {\n                fprintf(stderr, \"Invalid parameters for possible case: n=%d m=%d\\n\", n, m);\n                return 1;\n            }\n            if (m == 3 && n >= 5) {\n                fprintf(stderr, \"Impossible case in possible type: n=%d m=%d\\n\", n, m);\n                return 1;\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Generate n and m where a solution doesn't exist\n        m = 3;\n        n = rnd.next(5, 6);\n    } else if (type == \"max\") {\n        m = 100;\n        n = 200;\n    } else if (type == \"min\") {\n        m = 3;\n        n = 3;\n    } else if (type == \"random\") {\n        // Generate random n and m within constraints\n        if (n == -1 || m == -1) {\n            m = rnd.next(3, 100);\n            n = rnd.next(m, 2*m);\n        } else {\n            if (m < 3 || m > 100 || n < m || n > 2*m) {\n                fprintf(stderr, \"Invalid parameters for random case: n=%d m=%d\\n\", n, m);\n                return 1;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n# Test cases where solution is possible\n./gen -type possible\n./gen -type possible\n./gen -type possible\n./gen -n 3 -m 3 -type possible\n./gen -n 4 -m 3 -type possible\n./gen -n 50 -m 50 -type possible\n./gen -n 75 -m 50 -type possible\n./gen -n 100 -m 100 -type possible\n./gen -n 100 -m 51 -type possible\n./gen -n 150 -m 75 -type possible\n./gen -n 200 -m 100 -type possible\n\n# Test cases where solution is impossible\n./gen -type impossible\n./gen -type impossible\n./gen -n 5 -m 3 -type impossible\n./gen -n 6 -m 3 -type impossible\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases\n./gen -n 3 -m 3 -type random\n./gen -n 6 -m 3 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 2 -m 3 -type random     # Invalid, generator will handle\n./gen -n 5 -m 2 -type random     # Invalid, generator will handle\n./gen -n 200 -m 99 -type random  # Valid, n=200, m=99\n\n# Additional possible test cases\n./gen -n 7 -m 4 -type possible\n./gen -n 9 -m 5 -type possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:00.427421",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "278/E",
      "title": "E. Игра",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано три целых числа n, m, k (1 ≤ n, m ≤ 109, 0 ≤ k ≤ 105) — размеры листа бумаги и количество разрезов. Далее следует k строк по четыре целых числа в каждой xbi, ybi, xei, yei (0 ≤ xbi, xei ≤ n, 0 ≤ ybi, yei ≤ m) — координаты концов существующих разрезов. Гарантируется, что каждый разрез имеет ненулевую длину, является либо вертикальным, либо горизонтальным, и не проходит по границе листа.Разрезы могут пересекаться, накладываться и даже совпадать. То есть не гарантируется, что разрезы были получены в результате какой-то корректной игры.",
      "output_spec": "Выходные данныеЕсли выигрывает второй игрок, выведите «SECOND». Иначе в первой строке выведите «FIRST», а во второй строке — любой выигрышный ход первого игрока (координаты концов разреза в том же формате, что и во входных данных).",
      "sample_tests": "ПримерыВходные данныеСкопировать2 1 0Выходные данныеСкопироватьFIRST1 0 1 1Входные данныеСкопировать2 2 40 1 2 10 1 2 11 2 1 01 1 1 2Выходные данныеСкопироватьSECOND",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано три целых числа n, m, k (1 ≤ n, m ≤ 109, 0 ≤ k ≤ 105) — размеры листа бумаги и количество разрезов. Далее следует k строк по четыре целых числа в каждой xbi, ybi, xei, yei (0 ≤ xbi, xei ≤ n, 0 ≤ ybi, yei ≤ m) — координаты концов существующих разрезов. Гарантируется, что каждый разрез имеет ненулевую длину, является либо вертикальным, либо горизонтальным, и не проходит по границе листа.Разрезы могут пересекаться, накладываться и даже совпадать. То есть не гарантируется, что разрезы были получены в результате какой-то корректной игры.\n\nВходные данные\n\nВыходные данныеЕсли выигрывает второй игрок, выведите «SECOND». Иначе в первой строке выведите «FIRST», а во второй строке — любой выигрышный ход первого игрока (координаты концов разреза в том же формате, что и во входных данных).\n\nВыходные данные\n\nВходные данныеСкопировать2 1 0Выходные данныеСкопироватьFIRST1 0 1 1Входные данныеСкопировать2 2 40 1 2 10 1 2 11 2 1 01 1 1 2Выходные данныеСкопироватьSECOND\n\nВходные данныеСкопировать2 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьFIRST1 0 1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 40 1 2 10 1 2 11 2 1 01 1 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьSECOND\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #170 - Codeforces",
          "content": "Всем привет!Скоро начнется Codeforces Round #170, и его автором буду я. Надеюсь, многие будут рады решить все задачи.UPD: Разбалловка задач динамическая, задачи расположены в порядке возрастания предполагаемой сложности.И стандартная часть: спасибо Gerald за помощь в подготовке задач, Seyaua и sdya за тестирование, Delinur за переводы, MikeMirzayanov за создание платформы Codeforces.Удачи!UPD: Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6806",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 403
        },
        {
          "title": "Разбор Codeforces Round #170 - Codeforces",
          "content": "278B - Новая задачаКоличество различных строк длины 2: 262 = 676, а суммарная длина всех строк не превосходит 600. Это значит, что длина ответа не превосходит 2. Поэтому можно просто проверить все строки длины 1 и 2.277A - Изучение языковПостроим двудольный граф с n вершинами (для сотрудников) в одной доле, и m вершинами (для языков) в другой. Если сотрудник знает язык, значит должно быть ребро между соответствующими вершинами. Теперь задача выглядит понятнее: нужно добавить в граф минимальное количество ребер, чтобы появилась компонента связности, содержащая всех n сотрудников. Очевидно, что это число равно количеству компонент связности, включающих хотя бы одного сотрудника, минус 1. Но есть одно исключение (претест #4): если изначально вообще никто не знает ни один язык, то ответ равен n, так как мы не можем добавлять ребра напрямую между людьми.277B - Множество точекДля m = 3, n = 5 и m = 3, n = 6 решения не существует.Научимся строить ответ для n = 2m, где m ≥ 5 и нечетное. Расставим m точек на окружности достаточно большого радиуса — это будет внутренний многоугольник. Чтобы получить внешний многоугольник, умножим все координаты внутреннего на 2. Более точно (1 ≤ i ≤ m):Если m четное, построим решение для m + 1 и удалим по одной точке из каждого многоугольника. Если n < 2m, удалим 2m - n точек из внутреннего многоугольника.К сожалению, такое решение не работает для m = 4, n = 7 и m = 4, n = 8.Альтернативное решение — поставить m точек на выпуклой функции (например, y = x2 + 107), и n - m точек на вогнутой функции (например, y =  - x2 - 107). Так решал rng_58 — 3210150.277C - ИграЗаметим, что горизонтальные и вертикальные разрезы независимы. Рассмотрим любую горизонтальную линию: она содержит m единичных отрезков, и в любой ситуации всегда возможно уменьшить длину неразрезанной части так, как этого хочет игрок. Представим, что игрок наращивает отрезок от края поля, увеличивая его длину на 1 за раз. Каждый раз суммарная длина неразрезанной части уменьшается либо на 0, либо на 1. В конце, понятно, достигает 0.То же самое верно и для вертикальных линий. Значит, если бы не было начальных разрезов, игра превратилась бы в ним с n - 1 кучками по m камней и m - 1 кучками по n камней. Решается простой формулой.Начальные k разрезов добавляют только техническую сложность. Для каждой вертикальной/горизонтальной линии, содержащей хотя бы один разрез, размер соответствующей кучки нужно уменьшить на суммарную длину всех разрезов на этой линии.Как делать первый ход в ниме: пусть res — результат игры, а ai — размер i-ой кучки. Тогда результат игры без i-ой кучки — . Мы хотим заменить ai на какое-то x, чтобы . Понятно, что единственное подходящее значение . Итоговое решение: находим такую кучку, что , и уменьшаем ai до .277D - Google Code JamПусть зафиксирован набор подзадач, которые мы будем решать. Давайте определим, в каком порядке их нужно решать. Понятно, что легкие подзадачи (и сложные подзадачи с probFail = 0) в любом случае не упадут. То есть наше штрафное время не меньше времени отправки последней такой <<надежной>> подзадачи. Значит, в первую очередь нужно решить все такие подзадачи. Подзадачи с probFail = 1 вообще не имеет смысла решать. Рассмотрим подзадачи с 0 < probFail < 1. Пусть есть две подзадачи i и j, которые мы решаем подряд. Посмотрим, в каком случае выгодно их решать в порядке i, j, а не наоборот. Мы не учитываем остальные задачи, так как они ни на что не влияют.(timeLargei + timeLargej)(1 - probFailj) + timeLargei(1 - probFaili)probFailj < (timeLargei + timeLargej)(1 - probFaili) + timeLargej(1 - probFailj)probFaili - probFailj·timeLargej - timeLargei·probFailj·probFaili <  - probFaili·timeLargei - timeLargej·probFaili·probFailjtimeLargei·probFaili(1 - probFailj) < timeLargej·probFailj(1 - probFaili)timeLargei·probFaili / (1 - probFaili) < timeLargej·probFailj / (1 - probFailj)Получается, что если отсортировать подзадачи по данному компаратору, будет оптимальный порядок решения. Заметим, что подзадачи probFail = 0, 1 тоже отсортируются правильно, то есть не являются частными случаями.Вернемся к исходной задаче. Первым делом отсортируем все задачи полученным компаратором — ясно, что в другом порядке решать никогда не выгодно по времени, а количество очков от порядка не зависит. Посчитаем такую динамику: z[i][j] = пара из максимального матожидания суммы очков и минимального штрафного времени при данной сумме очков, если мы рассмотрели первые i задач, и прошло j реальных минут контеста. Возможно 3 перехода: либо мы не трогаем i-ую задачу: переходим в z[i + 1][j] с такими же матожиданиями либо мы решаем только легкую подзадачу: переходим в z[i + 1][j + timeSmalli], при этом очки увеличиваются на scoreSmalli, и штрафное время — на timeSmalli (мы как бы считаем, что будем решать i-ую задачу в самом начале контеста) либо мы решаем обе подзадачи: переходим в z[i + 1][j + timeSmalli + timeLargei], при этом очки увеличиваются на scoreSmalli + (1 - probFaili)scoreLargei, и штрафное время становится равным timeSmalli + (1 - probFaili)(j + timeLargei) + probFaili·penaltyTime(z[i][j]), где penaltyTime(z[i][j]) — значение матожидания штрафного времени из динамики Итоговый ответ — наилучшее из значений z[n][i], (0 ≤ i ≤ t).Матожидание очков может быть числом порядка 1012 с 6 знаками после точки, то есть его нельзя хранить в типе double абсолютно точно, а любая погрешность в вычислении матожидания очков может привести к ошибке в матожидании времени (претест #7). Чтобы этого избежать, можно, например, домножить все вероятности на 106, и считать первое матожидание в целых числах.277E - Бинарное дерево на плоскостиЕсли бы не было ограничения на \"бинарность\", задача бы решалась простой жадностью. Каждая вершина дерева (за исключением корня) должна иметь ровно одного предка. При этом каждая вершина может быть родителем для любого количества вершин. Назначим каждой вершине i (исключая корень) в качестве предка такую вершину pi, что ypi > yi и при этом pi — ближайшая к i. Перенумеруем все вершина в порядке невозрастания y. Очевидно, что pi < i (2 ≤ i ≤ n). То есть мы таким образом задали корневое дерево, в котором все дуги идут вниз, и оно минимально по длине.Теперь вспомним про \"бинарность\". Но она на самом деле мало чего меняет: жадность превращается в min-cost-max-flow на той же матрице расстояний, но только теперь в каждую вершину должно приходить не более 2 единиц потока.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 278"
          },
          "content_length": 6383
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #170 - Codeforces - Code 1",
          "code": ">проблемсет далеко не идеальный",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 2",
          "code": "5 2\n0\n0\n0\n0\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 3",
          "code": "5 2\n0\n0\n0\n0\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 4",
          "code": "100 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 5",
          "code": "const int N = 1009, M = 2009, P = 1000000;\n\npair<LL, DB> dp[M];\nint n, t;\n\nstruct rec{\n    LL t1, t2, s1, s2, pf;\n    LL ps()const{return P - pf;}\n    bool operator < (const rec& r) const{\n        return t2*pf*r.ps() < r.t2*r.pf*ps();\n    }\n    void input(){\n        RD(s1, s2, t1, t2), pf = RF() * P + 0.5, s1 *= P;\n    }\n    void update(){\n        DWN(i, t, 0){\n            if (i + t1 <= t) checkMax(dp[i+t1], MP(dp[i].fi+s1, dp[i].se));\n            if (i + t1 + t2 <= t) checkMax(dp[i+t1+t2], MP(dp[i].fi+s1+s2*ps(), (dp[i].se+t2)*pf/P));\n        }\n    }\n} A[N];\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    RD(n, t); REP(i, n) A[i].input();\n    sort(A, A+n); REP(i, n) A[i].update();\n\n    LL a = 0; DB b = 0; REP_1(i, t){\n        if (dp[i].fi > a || dp[i].fi == a && i-dp[i].se < b){\n            a = dp[i].fi, b = i-dp[i].se;\n        }\n    }\n    printf(\"%.9lf %.9lf\\n\", (DB) a/P, b);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 6",
          "code": "const int N = 1009, M = 2009, P = 1000000;\n\npair<LL, DB> dp[M];\nint n, t;\n\nstruct rec{\n    LL t1, t2, s1, s2, pf;\n    LL ps()const{return P - pf;}\n    bool operator < (const rec& r) const{\n        return t2*pf*r.ps() < r.t2*r.pf*ps();\n    }\n    void input(){\n        RD(s1, s2, t1, t2), pf = RF() * P + 0.5, s1 *= P;\n    }\n    void update(){\n        DWN(i, t, 0){\n            if (i + t1 <= t) checkMax(dp[i+t1], MP(dp[i].fi+s1, dp[i].se));\n            if (i + t1 + t2 <= t) checkMax(dp[i+t1+t2], MP(dp[i].fi+s1+s2*ps(), (dp[i].se+t2)*pf/P));\n        }\n    }\n} A[N];\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    RD(n, t); REP(i, n) A[i].input();\n    sort(A, A+n); REP(i, n) A[i].update();\n\n    LL a = 0; DB b = 0; REP_1(i, t){\n        if (dp[i].fi > a || dp[i].fi == a && i-dp[i].se < b){\n            a = dp[i].fi, b = i-dp[i].se;\n        }\n    }\n    printf(\"%.9lf %.9lf\\n\", (DB) a/P, b);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 7",
          "code": "void add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    if(root[toindex].c[s[strindex]] == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,root[toindex].c[s[strindex]],++strindex);\n    }\n}\n\nvoid add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    int ind = root[toindex].c[s[strindex]];\n    if(ind == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,ind,++strindex);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 8",
          "code": "void add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    if(root[toindex].c[s[strindex]] == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,root[toindex].c[s[strindex]],++strindex);\n    }\n}\n\nvoid add(string &s,int toindex,int strindex) {\n    if(s.length() <= strindex)\n        return;\n    int ind = root[toindex].c[s[strindex]];\n    if(ind == 0) {\n         root[toindex].c[s[strindex]] = ++cindex;\n         add(s,cindex,++strindex);\n    }else {\n        add(s,ind,++strindex);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 9",
          "code": "add(s,root[toindex].c[s[strindex]],++strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 10",
          "code": "add(s,root[toindex].c[s[strindex]],++strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 11",
          "code": "++strindex,add(s,root[toindex].c[s[strindex]],strindex);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #170 - Codeforces - Code 12",
          "code": "add(s,root[toindex].c[s[strindex]],strindex),++strindex,;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6806",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #170 - Codeforces - Code 1",
          "code": "probability      penalty\ni WA, j WA    pi*pj            0\ni AC, j WA    (1-pi)pj         ti\ni WA, j AC    pi(1-pj)         ti+tj\ni AC, j AC    (1-pi)(1-pj)     ti+(ti+tj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #170 - Codeforces - Code 2",
          "code": "probability      penalty\ni WA, j WA    pi*pj            0\ni AC, j WA    (1-pi)pj         ti\ni WA, j AC    pi(1-pj)         ti+tj\ni AC, j AC    (1-pi)(1-pj)     ti+(ti+tj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #170 - Codeforces - Code 3",
          "code": "By the Google Code Jam rules the time penalty is the time when the last correct solution was submitted.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6815",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int x_bi = inf.readInt(0, n, \"x_bi\");\n        inf.readSpace();\n        int y_bi = inf.readInt(0, m, \"y_bi\");\n        inf.readSpace();\n        int x_ei = inf.readInt(0, n, \"x_ei\");\n        inf.readSpace();\n        int y_ei = inf.readInt(0, m, \"y_ei\");\n        inf.readEoln();\n\n        // Ensure that the cut has non-zero length\n        ensuref(x_bi != x_ei || y_bi != y_ei, \"Cut has zero length at cut %d\", i+1);\n\n        // Ensure that the cut is either horizontal or vertical\n        ensuref(x_bi == x_ei || y_bi == y_ei, \"Cut is not horizontal or vertical at cut %d\", i+1);\n\n        // Ensure that the cut does not go along the sheet border\n        if (x_bi == x_ei) {\n            // Vertical cut\n            ensuref(x_bi != 0 && x_bi != n, \"Vertical cut along the border at cut %d\", i+1);\n        }\n        if (y_bi == y_ei) {\n            // Horizontal cut\n            ensuref(y_bi != 0 && y_bi != m, \"Horizontal cut along the border at cut %d\", i+1);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int x_bi = inf.readInt(0, n, \"x_bi\");\n        inf.readSpace();\n        int y_bi = inf.readInt(0, m, \"y_bi\");\n        inf.readSpace();\n        int x_ei = inf.readInt(0, n, \"x_ei\");\n        inf.readSpace();\n        int y_ei = inf.readInt(0, m, \"y_ei\");\n        inf.readEoln();\n\n        // Ensure that the cut has non-zero length\n        ensuref(x_bi != x_ei || y_bi != y_ei, \"Cut has zero length at cut %d\", i+1);\n\n        // Ensure that the cut is either horizontal or vertical\n        ensuref(x_bi == x_ei || y_bi == y_ei, \"Cut is not horizontal or vertical at cut %d\", i+1);\n\n        // Ensure that the cut does not go along the sheet border\n        if (x_bi == x_ei) {\n            // Vertical cut\n            ensuref(x_bi != 0 && x_bi != n, \"Vertical cut along the border at cut %d\", i+1);\n        }\n        if (y_bi == y_ei) {\n            // Horizontal cut\n            ensuref(y_bi != 0 && y_bi != m, \"Horizontal cut along the border at cut %d\", i+1);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int x_bi = inf.readInt(0, n, \"x_bi\");\n        inf.readSpace();\n        int y_bi = inf.readInt(0, m, \"y_bi\");\n        inf.readSpace();\n        int x_ei = inf.readInt(0, n, \"x_ei\");\n        inf.readSpace();\n        int y_ei = inf.readInt(0, m, \"y_ei\");\n        inf.readEoln();\n\n        // Ensure that the cut has non-zero length\n        ensuref(x_bi != x_ei || y_bi != y_ei, \"Cut has zero length at cut %d\", i+1);\n\n        // Ensure that the cut is either horizontal or vertical\n        ensuref(x_bi == x_ei || y_bi == y_ei, \"Cut is not horizontal or vertical at cut %d\", i+1);\n\n        // Ensure that the cut does not go along the sheet border\n        if (x_bi == x_ei) {\n            // Vertical cut\n            ensuref(x_bi != 0 && x_bi != n, \"Vertical cut along the border at cut %d\", i+1);\n        }\n        if (y_bi == y_ei) {\n            // Horizontal cut\n            ensuref(y_bi != 0 && y_bi != m, \"Horizontal cut along the border at cut %d\", i+1);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from inf (input file)\n    long long n = inf.readLong(1, (long long)1e9, \"n\");\n    long long m = inf.readLong(1, (long long)1e9, \"m\");\n    int k = inf.readInt(0, (int)1e5, \"k\");\n\n    // Read the existing cuts\n    vector<tuple<long long, long long, long long, long long>> cuts;\n    for (int i = 0; i < k; ++i) {\n        long long xb = inf.readLong(0, n, \"xb\");\n        long long yb = inf.readLong(0, m, \"yb\");\n        long long xe = inf.readLong(0, n, \"xe\");\n        long long ye = inf.readLong(0, m, \"ye\");\n        cuts.emplace_back(xb, yb, xe, ye);\n    }\n\n    // Read judge's answer from ans\n    string jans = ans.readToken();\n    if (jans != \"FIRST\" && jans != \"SECOND\") {\n        quitf(_fail, \"Judge's answer is neither 'FIRST' nor 'SECOND'\");\n    }\n\n    // Read participant's answer from ouf\n    string pans = ouf.readToken();\n    if (pans != \"FIRST\" && pans != \"SECOND\") {\n        quitf(_wa, \"Participant's answer is neither 'FIRST' nor 'SECOND', got '%s'\", pans.c_str());\n    }\n\n    // Compare answers\n    if (pans != jans) {\n        quitf(_wa, \"Participant's answer doesn't match judge's answer: participant '%s', judge '%s'\", pans.c_str(), jans.c_str());\n    }\n\n    if (jans == \"SECOND\") {\n        // Both outputs are 'SECOND', accept\n        if (!ouf.seekEof()) {\n            quitf(_wa, \"Extra output after 'SECOND'\");\n        }\n        quitf(_ok, \"Correct answer: SECOND\");\n    } else {\n        // Both outputs are 'FIRST', need to check participant's move\n        // Read participant's move\n        long long xb = ouf.readLong(0, n, \"xb\");\n        long long yb = ouf.readLong(0, m, \"yb\");\n        long long xe = ouf.readLong(0, n, \"xe\");\n        long long ye = ouf.readLong(0, m, \"ye\");\n\n        if (xb == xe && yb == ye) {\n            quitf(_wa, \"Cut must have positive length, got zero length cut\");\n        }\n\n        if (!((xb == xe && yb != ye) || (yb == ye && xb != xe))) {\n            quitf(_wa, \"Cut must be along grid line, either horizontal or vertical\");\n        }\n\n        if (xb == 0 && xe == 0 || xb == n && xe == n || yb == 0 && ye == 0 || yb == m && ye == m) {\n            quitf(_wa, \"Cut cannot go along the border\");\n        }\n\n        // We accept any valid move that follows the problem's rules\n\n        if (!ouf.seekEof()) {\n            quitf(_wa, \"Extra output after move\");\n        }\n\n        quitf(_ok, \"Correct answer: FIRST with a valid move\");\n    }\n}\n\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Cut {\n    long long xbi, ybi, xei, yei;\n};\n\nbool generate_random_cut(long long n, long long m, Cut &c) {\n    bool vertical_possible = n > 2;\n    bool horizontal_possible = m > 2;\n    int dir; // 0: vertical, 1: horizontal\n\n    if (vertical_possible && horizontal_possible) {\n        dir = rnd.next(2); // 0 or 1\n    } else if (vertical_possible) {\n        dir = 0;\n    } else if (horizontal_possible) {\n        dir = 1;\n    } else {\n        // Neither vertical nor horizontal possible\n        // Cannot generate any valid cuts\n        return false;\n    }\n\n    if (dir == 0) {\n        // Vertical cut\n        c.xbi = c.xei = rnd.next(1LL, n - 1LL);\n        do {\n            c.ybi = rnd.next(0LL, m);\n            c.yei = rnd.next(0LL, m);\n        } while (c.ybi == c.yei);\n    } else {\n        // Horizontal cut\n        c.ybi = c.yei = rnd.next(1LL, m - 1LL);\n        do {\n            c.xbi = rnd.next(0LL, n);\n            c.xei = rnd.next(0LL, n);\n        } while (c.xbi == c.xei);\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    long long m = opt<long long>(\"m\");\n    long long k = opt<long long>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Cut> cuts;\n\n    if (type == \"random\") {\n        for(long long i = 0; i < k; ++i) {\n            Cut c;\n            if(!generate_random_cut(n, m, c)) {\n                break;\n            }\n            cuts.push_back(c);\n        }\n    } else if (type == \"overlapping\") {\n        Cut c;\n        if (!generate_random_cut(n, m, c)) {\n            // Cannot generate any valid cuts\n        } else {\n            for(long long i = 0; i < k; ++i) {\n                cuts.push_back(c);\n            }\n        }\n    } else if (type == \"edge_cases\") {\n        for(long long i = 0; i < k; ++i) {\n            Cut c;\n            bool vertical_possible = n > 2;\n            bool horizontal_possible = m > 2;\n            int dir;\n            if (vertical_possible && horizontal_possible) {\n                dir = rnd.next(2);\n            } else if (vertical_possible) {\n                dir = 0;\n            } else if (horizontal_possible) {\n                dir = 1;\n            } else {\n                break;\n            }\n            if (dir == 0) { // Vertical cut near borders\n                c.xbi = c.xei = rnd.next(1LL, 2LL);\n                do {\n                    c.ybi = rnd.next(0LL, m);\n                    c.yei = rnd.next(0LL, m);\n                } while (c.ybi == c.yei);\n            } else {\n                c.ybi = c.yei = rnd.next(1LL, 2LL);\n                do {\n                    c.xbi = rnd.next(0LL, n);\n                    c.xei = rnd.next(0LL, n);\n                } while (c.xbi == c.xei);\n            }\n            cuts.push_back(c);\n        }\n    } else if (type == \"full_cover\") {\n        long long max_k = opt<long long>(\"k\", 100000LL);\n        long long count = 0;\n        if (n > 2) {\n            for(long long x = 1; x < n && count < max_k; ++x) {\n                Cut c;\n                c.xbi = c.xei = x;\n                c.ybi = 0LL;\n                c.yei = m;\n                cuts.push_back(c);\n                ++count;\n            }\n        }\n        if (m > 2 && count < max_k) {\n            for(long long y = 1; y < m && count < max_k; ++y) {\n                Cut c;\n                c.ybi = c.yei = y;\n                c.xbi = 0LL;\n                c.xei = n;\n                cuts.push_back(c);\n                ++count;\n            }\n        }\n    } else {\n        // Default to random cuts\n        for(long long i = 0; i < k; ++i) {\n            Cut c;\n            if(!generate_random_cut(n, m, c)) {\n                break;\n            }\n            cuts.push_back(c);\n        }\n    }\n    // Output n m k\n    printf(\"%lld %lld %lld\\n\", n, m, (long long)cuts.size());\n    // Output cuts\n    for(const auto& cut : cuts) {\n        printf(\"%lld %lld %lld %lld\\n\", cut.xbi, cut.ybi, cut.xei, cut.yei);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Cut {\n    long long xbi, ybi, xei, yei;\n};\n\nbool generate_random_cut(long long n, long long m, Cut &c) {\n    bool vertical_possible = n > 2;\n    bool horizontal_possible = m > 2;\n    int dir; // 0: vertical, 1: horizontal\n\n    if (vertical_possible && horizontal_possible) {\n        dir = rnd.next(2); // 0 or 1\n    } else if (vertical_possible) {\n        dir = 0;\n    } else if (horizontal_possible) {\n        dir = 1;\n    } else {\n        // Neither vertical nor horizontal possible\n        // Cannot generate any valid cuts\n        return false;\n    }\n\n    if (dir == 0) {\n        // Vertical cut\n        c.xbi = c.xei = rnd.next(1LL, n - 1LL);\n        do {\n            c.ybi = rnd.next(0LL, m);\n            c.yei = rnd.next(0LL, m);\n        } while (c.ybi == c.yei);\n    } else {\n        // Horizontal cut\n        c.ybi = c.yei = rnd.next(1LL, m - 1LL);\n        do {\n            c.xbi = rnd.next(0LL, n);\n            c.xei = rnd.next(0LL, n);\n        } while (c.xbi == c.xei);\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    long long m = opt<long long>(\"m\");\n    long long k = opt<long long>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Cut> cuts;\n\n    if (type == \"random\") {\n        for(long long i = 0; i < k; ++i) {\n            Cut c;\n            if(!generate_random_cut(n, m, c)) {\n                break;\n            }\n            cuts.push_back(c);\n        }\n    } else if (type == \"overlapping\") {\n        Cut c;\n        if (!generate_random_cut(n, m, c)) {\n            // Cannot generate any valid cuts\n        } else {\n            for(long long i = 0; i < k; ++i) {\n                cuts.push_back(c);\n            }\n        }\n    } else if (type == \"edge_cases\") {\n        for(long long i = 0; i < k; ++i) {\n            Cut c;\n            bool vertical_possible = n > 2;\n            bool horizontal_possible = m > 2;\n            int dir;\n            if (vertical_possible && horizontal_possible) {\n                dir = rnd.next(2);\n            } else if (vertical_possible) {\n                dir = 0;\n            } else if (horizontal_possible) {\n                dir = 1;\n            } else {\n                break;\n            }\n            if (dir == 0) { // Vertical cut near borders\n                c.xbi = c.xei = rnd.next(1LL, 2LL);\n                do {\n                    c.ybi = rnd.next(0LL, m);\n                    c.yei = rnd.next(0LL, m);\n                } while (c.ybi == c.yei);\n            } else {\n                c.ybi = c.yei = rnd.next(1LL, 2LL);\n                do {\n                    c.xbi = rnd.next(0LL, n);\n                    c.xei = rnd.next(0LL, n);\n                } while (c.xbi == c.xei);\n            }\n            cuts.push_back(c);\n        }\n    } else if (type == \"full_cover\") {\n        long long max_k = opt<long long>(\"k\", 100000LL);\n        long long count = 0;\n        if (n > 2) {\n            for(long long x = 1; x < n && count < max_k; ++x) {\n                Cut c;\n                c.xbi = c.xei = x;\n                c.ybi = 0LL;\n                c.yei = m;\n                cuts.push_back(c);\n                ++count;\n            }\n        }\n        if (m > 2 && count < max_k) {\n            for(long long y = 1; y < m && count < max_k; ++y) {\n                Cut c;\n                c.ybi = c.yei = y;\n                c.xbi = 0LL;\n                c.xei = n;\n                cuts.push_back(c);\n                ++count;\n            }\n        }\n    } else {\n        // Default to random cuts\n        for(long long i = 0; i < k; ++i) {\n            Cut c;\n            if(!generate_random_cut(n, m, c)) {\n                break;\n            }\n            cuts.push_back(c);\n        }\n    }\n    // Output n m k\n    printf(\"%lld %lld %lld\\n\", n, m, (long long)cuts.size());\n    // Output cuts\n    for(const auto& cut : cuts) {\n        printf(\"%lld %lld %lld %lld\\n\", cut.xbi, cut.ybi, cut.xei, cut.yei);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal cases\n./gen -n 1 -m 1 -k 0 -type random\n./gen -n 2 -m 2 -k 0 -type random\n\n# Small n and m, no cuts\n./gen -n 5 -m 5 -k 0 -type random\n\n# Small n and m, few random cuts\n./gen -n 5 -m 5 -k 3 -type random\n\n# Small n and m, maximum cuts\n./gen -n 5 -m 5 -k 10 -type random\n\n# Random cuts with overlapping positions\n./gen -n 10 -m 10 -k 5 -type overlapping\n\n# Edge cases, cuts near the borders\n./gen -n 10 -m 10 -k 10 -type edge_cases\n\n# Max k, random cuts\n./gen -n 1000 -m 1000 -k 100000 -type random\n\n# Max k, overlapping cuts\n./gen -n 1000 -m 1000 -k 100000 -type overlapping\n\n# Full cover, cuts covering the entire grid\n./gen -n 50000 -m 50000 -k 100000 -type full_cover\n\n# Large n and m, no cuts\n./gen -n 1000000000 -m 1000000000 -k 0 -type random\n\n# Large n and m, few random cuts\n./gen -n 1000000000 -m 1000000000 -k 10 -type random\n\n# Large n and m, max k random cuts\n./gen -n 1000000000 -m 1000000000 -k 100000 -type random\n\n# Edge cases, large n and m\n./gen -n 1000000000 -m 1000000000 -k 100000 -type edge_cases\n\n# One dimension is minimal\n./gen -n 1 -m 1000000000 -k 0 -type random\n./gen -n 1000000000 -m 1 -k 0 -type random\n\n# One dimension is minimal, with cuts\n./gen -n 1 -m 1000000000 -k 10 -type random\n./gen -n 1000000000 -m 1 -k 10 -type random\n\n# Maximal k with minimal dimensions\n./gen -n 2 -m 2 -k 100000 -type random\n\n# Maximal k with overlapping cuts, small grid\n./gen -n 2 -m 2 -k 100000 -type overlapping\n\n# Random cuts on small grid\n./gen -n 10 -m 10 -k 1000 -type random\n\n# Maximal cuts on small grid\n./gen -n 10 -m 10 -k 100000 -type random\n\n# Testing cuts that cannot be generated (invalid cuts)\n./gen -n 1 -m 1 -k 10 -type random\n./gen -n 1 -m 1 -k 10 -type overlapping\n\n# Cuts that cover all inner grid lines\n./gen -n 1000 -m 1000 -k 100000 -type full_cover\n./gen -n 100000 -m 100000 -k 100000 -type full_cover\n\n# Mixed types with specified k\n./gen -n 500 -m 500 -k 5000 -type random\n./gen -n 2000 -m 1000 -k 5000 -type overlapping\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:02.026222",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "279/A",
      "title": "A. Point on Spiral",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers x and y (|x|, |y| ≤ 100).",
      "output_spec": "OutputPrint a single integer, showing how many times Valera has to turn.",
      "sample_tests": "ExamplesInputCopy0 0OutputCopy0InputCopy1 0OutputCopy0InputCopy0 1OutputCopy2InputCopy-1 -1OutputCopy3",
      "description": "A. Point on Spiral\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers x and y (|x|, |y| ≤ 100).\n\nOutputPrint a single integer, showing how many times Valera has to turn.\n\nInputCopy0 0OutputCopy0InputCopy1 0OutputCopy0InputCopy0 1OutputCopy2InputCopy-1 -1OutputCopy3\n\nInputCopy0 0\n\nOutputCopy0\n\nInputCopy1 0\n\nOutputCopy0\n\nInputCopy0 1\n\nOutputCopy2\n\nInputCopy-1 -1\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Hello, friends)Soon is coming regular Codeforces round #171 for Div.2 participants. Traditionally Div.1 participants can take part out of the competition.Again and again the problems were prepared by the familiar group of authors: Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: score distribution will be not standard a little bit: 500, 1000, 1500, 2000, 2000.We wish everyone good luck, successful hacks, high rating and good mood)UPD2: the contest is over, we hope you enjoy it)Congratulations to winners:1) study_english2) ipip20053) rng_502164) bfrcns1975) csavky103 UPD3: the editorial will be published soon",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6856",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 835
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Continuing with the theme of absent editorials for old rounds, here is an editorial for Codeforces Round 171 (Div. 2). Even though there is an official editorial, it is only in russian and doesn't have solution for the last problem.A Editorial279A - Point on SpiralSince constraints are small, you can just simulate the whole process, but I'll explain an O(1)O(1) solution. Let's look at the pathNow it's easy to see that the plane can be divided into four partsAnd then we can calculate answer for each part separately, just be careful with borders. For example, for the right part the answer is 4x−34x−3. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int x, y;\n cin >> x >> y;\n if (x == 0 && y == 0) {\n cout << 0 << '\\n';\n } else if (-x + 1 < y && y <= x) {\n cout << 1 + (x - 1) * 4 << '\\n';\n } else if (-y <= x && x < y) {\n cout << 2 + (y - 1) * 4 << '\\n';\n } else if (x <= y && y < -x) {\n cout << 3 + (-x - 1) * 4 << '\\n';\n } else {\n cout << 4 + (-y - 1) * 4 << '\\n';\n }\n\n return 0;\n}B Editorial279B - BooksThe problem can be written in the following way: for each index ii denote riri as the largest index such that ai+…+ari⩽tai+…+ari⩽t. The problem is to find max(ri−i+1)max(ri−i+1).One can see that riri are nondecreasing, so the problem can be solved with two pointers: iterate over ii and keep a pointer to corresponding riri. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, t;\n cin >> n >> t;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n int r = 0;\n int sm = 0;\n int ans = 0;\n for (int i = 0; i < n; ++i) {\n while (r < n && sm + a[r] <= t) {\n sm += a[r];\n ++r;\n }\n ans = max(ans, r - i);\n sm -= a[i];\n }\n\n cout << ans << '\\n';\n\n return 0;\n}C Editorial279C - LadderLet's calculate two arrays before answering queries. tol[i]tol[i] is the smallest index such that [btol[i],…,bi][btol[i],…,bi] is nonincreasing, and tor[i]tor[i] is the largest index such that [bi,…,btor[i]][bi,…,btor[i]] is nondecreasing. Then for each query we can take tor[l]tor[l] and tol[r]tol[r] and compare them. The answer is \"Yes\" iff tor[l]⩾tol[r]tor[l]⩾tol[r]. In other words, we are checking if the largest nondecreasing segment from ll and largest nonincreasing segment from rr are intersecting.To calculate tol[i]tol[i], go over ii from 11 to nn and maintain largest nonincreasing suffix. For tortor do the same in reverse. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, m;\n cin >> n >> m;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n vector<int> tor(n), tol(n);\n iota(tol.begin(), tol.end(), 0);\n iota(tor.begin(), tor.end(), 0);\n\n tol[0] = 0;\n for (int i = 1; i < n; ++i)\n if (a[i - 1] >= a[i])\n tol[i] = tol[i - 1];\n\n tor[n - 1] = n - 1;\n for (int i = n - 2; i >= 0; --i)\n if (a[i] <= a[i + 1])\n tor[i] = tor[i + 1];\n\n while (m--) {\n int l, r;\n cin >> l >> r;\n --l; --r;\n cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n }\n\n return 0;\n}D Editorial279D - The Minimum Number of VariablesYou can notice that when we want to perform some operation, we are only interested in a subset of current values of variables (including zeros). So let's create dp[i][mask]=booldp[i][mask]=bool, which is 11 if we can perform first ii operations and end up with the values from maskmask. Here kk-bit in the mask corresponds to the value vals[k]vals[k], where array valsvals stores all numbers in aa and a zero, and kk-th bit is set iff the value of one of the variables is vals[k]vals[k].To make transition from dp[i][mask]dp[i][mask] to dp[i+1][new_mask]dp[i+1][new_mask], let's look at the operation. We have to find two values in the maskmask such that their sum is a[i+1]a[i+1]. Then to calculate new_masknew_mask we have to set kk-th bit in the maskmask, where kk is such that vals[k]=a[i+1]vals[k]=a[i+1]. Also, while writing new variable we can overwrite any existing variable, so we have an option to disable any bit in the maskmask.Now it looks like we have O(2nn)O(2nn) states and nn transitions from each state (disabling each bit). But actually if we only make transition from dp[i][mask]=1dp[i][mask]=1, the complexity will be O(2nn)O(2nn), because for each ii there are at most 2i+12i+1 masks that we can achieve, since there are only ii distinct numbers on the current prefix plus an additional zero. And ∑ni=12i+1⋅n=O(2nn)∑i=1n2i+1⋅n=O(2nn).The only problem left is to check if we can build some number yy from valsvals using numbers from maskmask. This can be precomputed in O(2nn)O(2nn): let's calculate array possible[mask]=xpossible[mask]=x, where ii-th bit in xx is set iff we can get number vals[i]vals[i] from mask on the next step. To calculate it, first for each maskmask with at most 22 bits just calculate all possible xx with any straightforward approach, since there are only O(n2)O(n2) such masks. For any other mask notice that we can get yy iff sum of some two values equals to yy. So we can iterate over all submasks such that they differ from maskmask in exactly one bit and update possible[mask]possible[mask] with possible[submask]possible[submask]. And since maskmask has at least 33 bits, if there is a pair which sums up to yy, this pair will be included into at least one of the submasks. One can even notice that we only need any 33 such submasks to cover every pair of bits.The answer is minimum number of bits over all masks such that dp[n][mask]=1dp[n][mask]=1. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n;\n cin >> n;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n auto vals = a;\n vals.push_back(0);\n sort(vals.begin(), vals.end());\n vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n vector<int> pos(n);\n for (int i = 0; i < n; ++i) {\n pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n }\n\n vector<int> possible(1 << vals.size(), 0);\n for (int i = 1; i < possible.size(); ++i) {\n int k = 0;\n for (int j = 0; j < vals.size() && k < 3; ++j) {\n if ((i >> j) & 1) {\n possible[i] |= possible[i ^ (1 << j)];\n ++k;\n }\n }\n if (__builtin_popcount(i) <= 2) {\n for (int j = 0; j < vals.size(); ++j) {\n if (!((i >> j) & 1)) continue;\n for (int k = 0; k < vals.size(); ++k) {\n if (!((i >> k) & 1)) continue;\n int val = vals[j] + vals[k];\n int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n if (ind < vals.size() && vals[ind] == val)\n possible[i] |= (1 << ind);\n }\n }\n }\n }\n\n vector<char> dp_cur(1 << vals.size(), 0);\n dp_cur[1 << pos[0]] = 1;\n dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n auto can_sum = [&](int mask, int pos) {\n return (possible[mask] >> pos) & 1;\n };\n\n vector<char> dp_next;\n for (int i = 1; i < n; ++i) {\n dp_next.assign(dp_cur.size(), false);\n for (int j = 0; j < dp_cur.size(); ++j) {\n if (dp_cur[j] && can_sum(j, pos[i])) {\n int mask = j;\n mask |= (1 << pos[i]);\n dp_next[mask] = 1;\n for (int k = 0; k < vals.size(); ++k)\n if (((mask >> k) & 1) && vals[k] != a[i])\n dp_next[mask ^ (1 << k)] = 1;\n }\n }\n swap(dp_cur, dp_next);\n }\n\n int ans = -1;\n for (int i = 0; i < dp_cur.size(); ++i) {\n if (!dp_cur[i]) continue;\n int sz = __builtin_popcount(i);\n if (ans == -1 || ans > sz)\n ans = sz;\n }\n cout << ans << '\\n';\n\n return 0;\n}E Editorial279E - Beautiful DecompositionFirst of all it's easy to notice that we will use each power of 22 at most once.Let's look at the highest bit in the current number, suppose it's 2k2k. Since the sum of all powers of 22 below kk is less than 2k2k, we will have to add at least one power of two 2x2x with x⩾kx⩾k. One can see that adding 2k+22k+2 is not optimal, since then we will have to subtract at least 2k+12k+1 and 2k+2−2k+12k+2−2k+1 can be replaced with 2k+12k+1. So the only choices are 2k2k or 2k+12k+1. If we add 2k2k, we have to solve a problem for remaining number, which is a suffix or our current binary string. Otherwise, 2k+12k+1 is larger than our current number, so we just need the answer for m=2k+1−nm=2k+1−n. Let's call such mm a complement for a number nn (notice that we don't need kk in the definition because kk is defined as largest bit in nn)Now let's look at mm. To calculate it, we have to flip all bits in nn and add 11 to the result. Now it's easy to see that if mm is a complement for nn, then for any suffix of nn (in binary form), the corresponding suffix of mm is a complement for it. Also, nn is a complement for mm.So during our calculations we will only deal with nn, mm, suffixes of nn and suffixes of mm. And this leads to a following dp solution: let v[1]=nv[1]=n, v[2]=mv[2]=m. Then dp[ind][suf]dp[ind][suf] is the smallest answer for a binary number represented by a suffix of number v[ind]v[ind] starting from index sufsuf. We can calculate this dpdp starting from dp[…][n]dp[…][n] and the answer will be dp[1][1]dp[1][1]. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n string n;\n cin >> n;\n string m = n;\n {\n for (char& c : m) {\n c ^= '1' ^ '0';\n }\n int ind = m.size() - 1;\n while (ind >= 0 && m[ind] == '1') {\n m[ind] = '0';\n --ind;\n }\n if (ind == -1) {\n m.insert(m.begin(), '1');\n n.insert(n.begin(), '0');\n } else {\n m[ind] = '1';\n }\n }\n\n int sz = n.size();\n\n vector<string> v = {n, m};\n vector<array<int, 2>> dp(sz);\n\n dp[sz - 1][0] = (v[0].back() == '1');\n dp[sz - 1][1] = (v[1].back() == '1');\n\n for (int i = sz - 2; i >= 0; --i) {\n for (int b = 0; b < 2; ++b) {\n if (v[b][i] == '0') {\n dp[i][b] = dp[i + 1][b];\n } else {\n dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n }\n }\n }\n\n cout << dp[0][0] << '\\n';\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/95148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*A"
          },
          "content_length": 9416
        },
        {
          "title": "Codeforces Round #171 (Div. 2) Разбор Задач - Codeforces",
          "content": "279A - Point on SpiralИз-за небольших ограничений в данной задаче можно было просто промоделировать шаги коня. Удобнее всего это делать, храня текущее направление движения и счетчик со значением, сколько шагов в эту сторону осталось. Заметим, что конь движется по спирали по следующему шаблону: 1 шаг вперед, поворот, 1 шаг вперед, поворот, 2 шага, поворот, 2 шага, поворот, 3 шага, поворот, 3 шага, поворот, 4 шага и так далее.279B - BooksПри решении этой задачи проще всего было воспользоваться методом двух указателей: левый указатель означает начало отрезка, правый — конец. При передвижении левого указателя на единицу вправо, правый надо двигать до тех пор, пока сумма ai внутри отрезка меньше или равна t. Так мы сможем для каждого левого конца найти максимально удаленный правый, а ответ на задачу — это максимальная длина из этих отрезков.279C - LadderДавайте перед выполнением запросов выпишем в массив down отдельно все позиции i, для которых ai > ai + 1, и в массив up такие позиции i, такие что ai < ai + 1. Теперь заметим важный факт для решения: отрезок [l, r] является лесенкой тогда, когда все позиции i, где ai < ai + 1 левее всех позиций j, в которых aj > aj + 1 (l ≤ i, j < r).Для того, чтобы проверить это условие, давайте воспользуемся массивами up и down, в них с помощью бинарного поиска можно надо найти наибольший индекс i в отрезке, где происходит возрастание, и наименьший индекс j в отрезке, где происходит убывание, и если i < j, то отрезок — это лесенка. Отдельно необходимо рассмотреть случаи, когда числа в отрезке образуют невозрастающую или неубывающую последовательность.279D - The Minimum Number of VariablesДавайте решать задачу методом динамического программирования по бинарной маске. Пусть текущее состояние — это mask. Через count(mask) обозначим количество единичных битов в маске, а через b1, b2, ..., bcount(mask) их индексы (здесь и далее будем использовать 0-нумерацию). Наше состояние означает, что в данный момент у нас имеется count(mask) переменных, которые равны ab1, ab2, ..., abcount(mask). Будем считать, что дойдя до такого состояния, мы уже сумели произвести count(mask) операций, а значит, сейчас нам надо получить x = abcount(mask) + 1.Если это число x не представимо в виде x = bi + bj, то тогда точно следующее значение мы получить не можем, и это состояние тупиковое, а иначе даже неважно какие именно значения i, j мы возьмем, главное — убедиться, что такие существуют. Итак, мы получаем число x на текущей операции. Теперь важно понять, куда мы можем его записать: а именно мы либо записываем в какую-либо из уже использованных переменных (старое значение стирается), либо в новую переменную (это будет стоить нам 1).В терминах масок первая операция выглядит как выкидывание одного из битов bk, и добавление нового бита, а вторая — просто добавление нового бита.Начальное состояние в нашей динамике — это mask = 1, конечное — любая маска, в которой есть единичный бит на позиции n - 1 (в 0-нумерации).При аккуратной реализации такое решение будет работать за O(2n·n). В частности, следующий хитрый прием поможет добиться этого: когда нам требуется проверить, что в маске есть такие два бита bi и bj, что acount(mask) = abi + abj, то будем использовать предподсчитанный массив diff[q][p], в котором будет записан индекс такого элемента массива a, который равен разности aq–ap. Это позволит нам при проверке перебирать лишь значение bi.279E - Beautiful DecompositionБудет опубликовано чуть позже…",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6864",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*A"
          },
          "content_length": 3458
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 5",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 6",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 7",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 8",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 9",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 10",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(-100, 100, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-100, 100, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(-100, 100, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-100, 100, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(-100, 100, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-100, 100, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    // \"type\" controls how we pick (x,y).\n    // \"range\" (default = 100) sets the range for random generation.\n    // \"x\" and \"y\" (default = 0) are used if type = \"manual\".\n    string type = opt<string>(\"type\", \"manual\");\n    int range = opt<int>(\"range\", 100);\n    int X = opt<int>(\"x\", 0);\n    int Y = opt<int>(\"y\", 0);\n\n    // Adjust (X, Y) according to \"type\"\n    if (type == \"zero\") {\n        // Always output (0,0)\n        X = 0;\n        Y = 0;\n    }\n    else if (type == \"corner\") {\n        // Choose from corners: (100,100), (100,-100), (-100,100), (-100,-100)\n        // If \"range\" is not 100, still use ±range\n        vector<pair<int,int>> corners = {\n            {range, range}, {range, -range}, {-range, range}, {-range, -range}\n        };\n        auto c = corners[rnd.next(0, (int)corners.size() - 1)];\n        X = c.first;\n        Y = c.second;\n    }\n    else if (type == \"random\") {\n        // Choose random x,y from [-range, range]\n        X = rnd.next(-range, range);\n        Y = rnd.next(-range, range);\n    }\n    else if (type == \"manual\") {\n        // Just use the provided x,y\n        // (already read into X and Y)\n    }\n    // else: fallback to manual or treat any unknown type as manual\n\n    // Ensure constraints: |X| <= 100, |Y| <= 100\n    // If the user gave a custom range, let's clamp them to ±100 for safety.\n    X = max(-100, min(100, X));\n    Y = max(-100, min(100, Y));\n\n    // Output the single test: x, y\n    cout << X << \" \" << Y << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    // \"type\" controls how we pick (x,y).\n    // \"range\" (default = 100) sets the range for random generation.\n    // \"x\" and \"y\" (default = 0) are used if type = \"manual\".\n    string type = opt<string>(\"type\", \"manual\");\n    int range = opt<int>(\"range\", 100);\n    int X = opt<int>(\"x\", 0);\n    int Y = opt<int>(\"y\", 0);\n\n    // Adjust (X, Y) according to \"type\"\n    if (type == \"zero\") {\n        // Always output (0,0)\n        X = 0;\n        Y = 0;\n    }\n    else if (type == \"corner\") {\n        // Choose from corners: (100,100), (100,-100), (-100,100), (-100,-100)\n        // If \"range\" is not 100, still use ±range\n        vector<pair<int,int>> corners = {\n            {range, range}, {range, -range}, {-range, range}, {-range, -range}\n        };\n        auto c = corners[rnd.next(0, (int)corners.size() - 1)];\n        X = c.first;\n        Y = c.second;\n    }\n    else if (type == \"random\") {\n        // Choose random x,y from [-range, range]\n        X = rnd.next(-range, range);\n        Y = rnd.next(-range, range);\n    }\n    else if (type == \"manual\") {\n        // Just use the provided x,y\n        // (already read into X and Y)\n    }\n    // else: fallback to manual or treat any unknown type as manual\n\n    // Ensure constraints: |X| <= 100, |Y| <= 100\n    // If the user gave a custom range, let's clamp them to ±100 for safety.\n    X = max(-100, min(100, X));\n    Y = max(-100, min(100, Y));\n\n    // Output the single test: x, y\n    cout << X << \" \" << Y << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1) Zero case\n./gen -type zero\n\n# 2) Manually specified small corner\n./gen -type manual -x 0 -y 1\n\n# 3) Manually specified small corner\n./gen -type manual -x 1 -y 0\n\n# 4) Manually specified small corner\n./gen -type manual -x 1 -y 1\n\n# 5) Manually specified negative\n./gen -type manual -x -1 -y 0\n\n# 6) Manually specified negative\n./gen -type manual -x 0 -y -1\n\n# 7) Maximum positive corner\n./gen -type manual -x 100 -y 100\n\n# 8) Mixed corner\n./gen -type manual -x 100 -y -100\n\n# 9) Mixed corner\n./gen -type manual -x -100 -y 100\n\n# 10) Maximum negative corner\n./gen -type manual -x -100 -y -100\n\n# 11) Random (range = 100 by default)\n./gen -type random\n\n# 12) Another random\n./gen -type random\n\n# 13) Corner using \"corner\" type (defaults to ±100)\n./gen -type corner\n\n# 14) Another corner\n./gen -type corner\n\n# 15) Random with smaller range to get smaller coords\n./gen -type random -range 5\n\n# 16) Another random with smaller range\n./gen -type random -range 5\n\n# 17) Slightly bigger range random\n./gen -type random -range 50\n\n# 18) Another bigger range random\n./gen -type random -range 80\n\n# 19) Manually specified (some mid-range)\n./gen -type manual -x 10 -y -10\n\n# 20) Manually specified (some mid-range)\n./gen -type manual -x -10 -y 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:03.874747",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "279/B",
      "title": "B. Books",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and t (1 ≤ n ≤ 105; 1 ≤ t ≤ 109) — the number of books and the number of free minutes Valera's got. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 104), where number ai shows the number of minutes that the boy needs to read the i-th book.",
      "output_spec": "OutputPrint a single integer — the maximum number of books Valera can read.",
      "sample_tests": "ExamplesInputCopy4 53 1 2 1OutputCopy3InputCopy3 32 2 3OutputCopy1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and t (1 ≤ n ≤ 105; 1 ≤ t ≤ 109) — the number of books and the number of free minutes Valera's got. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 104), where number ai shows the number of minutes that the boy needs to read the i-th book.\n\nOutputPrint a single integer — the maximum number of books Valera can read.\n\nInputCopy4 53 1 2 1OutputCopy3InputCopy3 32 2 3OutputCopy1\n\nInputCopy4 53 1 2 1\n\nOutputCopy3\n\nInputCopy3 32 2 3\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Hello, friends)Soon is coming regular Codeforces round #171 for Div.2 participants. Traditionally Div.1 participants can take part out of the competition.Again and again the problems were prepared by the familiar group of authors: Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: score distribution will be not standard a little bit: 500, 1000, 1500, 2000, 2000.We wish everyone good luck, successful hacks, high rating and good mood)UPD2: the contest is over, we hope you enjoy it)Congratulations to winners:1) study_english2) ipip20053) rng_502164) bfrcns1975) csavky103 UPD3: the editorial will be published soon",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6856",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 835
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Continuing with the theme of absent editorials for old rounds, here is an editorial for Codeforces Round 171 (Div. 2). Even though there is an official editorial, it is only in russian and doesn't have solution for the last problem.A Editorial279A - Point on SpiralSince constraints are small, you can just simulate the whole process, but I'll explain an O(1)O(1) solution. Let's look at the pathNow it's easy to see that the plane can be divided into four partsAnd then we can calculate answer for each part separately, just be careful with borders. For example, for the right part the answer is 4x−34x−3. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int x, y;\n cin >> x >> y;\n if (x == 0 && y == 0) {\n cout << 0 << '\\n';\n } else if (-x + 1 < y && y <= x) {\n cout << 1 + (x - 1) * 4 << '\\n';\n } else if (-y <= x && x < y) {\n cout << 2 + (y - 1) * 4 << '\\n';\n } else if (x <= y && y < -x) {\n cout << 3 + (-x - 1) * 4 << '\\n';\n } else {\n cout << 4 + (-y - 1) * 4 << '\\n';\n }\n\n return 0;\n}B Editorial279B - BooksThe problem can be written in the following way: for each index ii denote riri as the largest index such that ai+…+ari⩽tai+…+ari⩽t. The problem is to find max(ri−i+1)max(ri−i+1).One can see that riri are nondecreasing, so the problem can be solved with two pointers: iterate over ii and keep a pointer to corresponding riri. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, t;\n cin >> n >> t;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n int r = 0;\n int sm = 0;\n int ans = 0;\n for (int i = 0; i < n; ++i) {\n while (r < n && sm + a[r] <= t) {\n sm += a[r];\n ++r;\n }\n ans = max(ans, r - i);\n sm -= a[i];\n }\n\n cout << ans << '\\n';\n\n return 0;\n}C Editorial279C - LadderLet's calculate two arrays before answering queries. tol[i]tol[i] is the smallest index such that [btol[i],…,bi][btol[i],…,bi] is nonincreasing, and tor[i]tor[i] is the largest index such that [bi,…,btor[i]][bi,…,btor[i]] is nondecreasing. Then for each query we can take tor[l]tor[l] and tol[r]tol[r] and compare them. The answer is \"Yes\" iff tor[l]⩾tol[r]tor[l]⩾tol[r]. In other words, we are checking if the largest nondecreasing segment from ll and largest nonincreasing segment from rr are intersecting.To calculate tol[i]tol[i], go over ii from 11 to nn and maintain largest nonincreasing suffix. For tortor do the same in reverse. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, m;\n cin >> n >> m;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n vector<int> tor(n), tol(n);\n iota(tol.begin(), tol.end(), 0);\n iota(tor.begin(), tor.end(), 0);\n\n tol[0] = 0;\n for (int i = 1; i < n; ++i)\n if (a[i - 1] >= a[i])\n tol[i] = tol[i - 1];\n\n tor[n - 1] = n - 1;\n for (int i = n - 2; i >= 0; --i)\n if (a[i] <= a[i + 1])\n tor[i] = tor[i + 1];\n\n while (m--) {\n int l, r;\n cin >> l >> r;\n --l; --r;\n cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n }\n\n return 0;\n}D Editorial279D - The Minimum Number of VariablesYou can notice that when we want to perform some operation, we are only interested in a subset of current values of variables (including zeros). So let's create dp[i][mask]=booldp[i][mask]=bool, which is 11 if we can perform first ii operations and end up with the values from maskmask. Here kk-bit in the mask corresponds to the value vals[k]vals[k], where array valsvals stores all numbers in aa and a zero, and kk-th bit is set iff the value of one of the variables is vals[k]vals[k].To make transition from dp[i][mask]dp[i][mask] to dp[i+1][new_mask]dp[i+1][new_mask], let's look at the operation. We have to find two values in the maskmask such that their sum is a[i+1]a[i+1]. Then to calculate new_masknew_mask we have to set kk-th bit in the maskmask, where kk is such that vals[k]=a[i+1]vals[k]=a[i+1]. Also, while writing new variable we can overwrite any existing variable, so we have an option to disable any bit in the maskmask.Now it looks like we have O(2nn)O(2nn) states and nn transitions from each state (disabling each bit). But actually if we only make transition from dp[i][mask]=1dp[i][mask]=1, the complexity will be O(2nn)O(2nn), because for each ii there are at most 2i+12i+1 masks that we can achieve, since there are only ii distinct numbers on the current prefix plus an additional zero. And ∑ni=12i+1⋅n=O(2nn)∑i=1n2i+1⋅n=O(2nn).The only problem left is to check if we can build some number yy from valsvals using numbers from maskmask. This can be precomputed in O(2nn)O(2nn): let's calculate array possible[mask]=xpossible[mask]=x, where ii-th bit in xx is set iff we can get number vals[i]vals[i] from mask on the next step. To calculate it, first for each maskmask with at most 22 bits just calculate all possible xx with any straightforward approach, since there are only O(n2)O(n2) such masks. For any other mask notice that we can get yy iff sum of some two values equals to yy. So we can iterate over all submasks such that they differ from maskmask in exactly one bit and update possible[mask]possible[mask] with possible[submask]possible[submask]. And since maskmask has at least 33 bits, if there is a pair which sums up to yy, this pair will be included into at least one of the submasks. One can even notice that we only need any 33 such submasks to cover every pair of bits.The answer is minimum number of bits over all masks such that dp[n][mask]=1dp[n][mask]=1. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n;\n cin >> n;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n auto vals = a;\n vals.push_back(0);\n sort(vals.begin(), vals.end());\n vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n vector<int> pos(n);\n for (int i = 0; i < n; ++i) {\n pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n }\n\n vector<int> possible(1 << vals.size(), 0);\n for (int i = 1; i < possible.size(); ++i) {\n int k = 0;\n for (int j = 0; j < vals.size() && k < 3; ++j) {\n if ((i >> j) & 1) {\n possible[i] |= possible[i ^ (1 << j)];\n ++k;\n }\n }\n if (__builtin_popcount(i) <= 2) {\n for (int j = 0; j < vals.size(); ++j) {\n if (!((i >> j) & 1)) continue;\n for (int k = 0; k < vals.size(); ++k) {\n if (!((i >> k) & 1)) continue;\n int val = vals[j] + vals[k];\n int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n if (ind < vals.size() && vals[ind] == val)\n possible[i] |= (1 << ind);\n }\n }\n }\n }\n\n vector<char> dp_cur(1 << vals.size(), 0);\n dp_cur[1 << pos[0]] = 1;\n dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n auto can_sum = [&](int mask, int pos) {\n return (possible[mask] >> pos) & 1;\n };\n\n vector<char> dp_next;\n for (int i = 1; i < n; ++i) {\n dp_next.assign(dp_cur.size(), false);\n for (int j = 0; j < dp_cur.size(); ++j) {\n if (dp_cur[j] && can_sum(j, pos[i])) {\n int mask = j;\n mask |= (1 << pos[i]);\n dp_next[mask] = 1;\n for (int k = 0; k < vals.size(); ++k)\n if (((mask >> k) & 1) && vals[k] != a[i])\n dp_next[mask ^ (1 << k)] = 1;\n }\n }\n swap(dp_cur, dp_next);\n }\n\n int ans = -1;\n for (int i = 0; i < dp_cur.size(); ++i) {\n if (!dp_cur[i]) continue;\n int sz = __builtin_popcount(i);\n if (ans == -1 || ans > sz)\n ans = sz;\n }\n cout << ans << '\\n';\n\n return 0;\n}E Editorial279E - Beautiful DecompositionFirst of all it's easy to notice that we will use each power of 22 at most once.Let's look at the highest bit in the current number, suppose it's 2k2k. Since the sum of all powers of 22 below kk is less than 2k2k, we will have to add at least one power of two 2x2x with x⩾kx⩾k. One can see that adding 2k+22k+2 is not optimal, since then we will have to subtract at least 2k+12k+1 and 2k+2−2k+12k+2−2k+1 can be replaced with 2k+12k+1. So the only choices are 2k2k or 2k+12k+1. If we add 2k2k, we have to solve a problem for remaining number, which is a suffix or our current binary string. Otherwise, 2k+12k+1 is larger than our current number, so we just need the answer for m=2k+1−nm=2k+1−n. Let's call such mm a complement for a number nn (notice that we don't need kk in the definition because kk is defined as largest bit in nn)Now let's look at mm. To calculate it, we have to flip all bits in nn and add 11 to the result. Now it's easy to see that if mm is a complement for nn, then for any suffix of nn (in binary form), the corresponding suffix of mm is a complement for it. Also, nn is a complement for mm.So during our calculations we will only deal with nn, mm, suffixes of nn and suffixes of mm. And this leads to a following dp solution: let v[1]=nv[1]=n, v[2]=mv[2]=m. Then dp[ind][suf]dp[ind][suf] is the smallest answer for a binary number represented by a suffix of number v[ind]v[ind] starting from index sufsuf. We can calculate this dpdp starting from dp[…][n]dp[…][n] and the answer will be dp[1][1]dp[1][1]. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n string n;\n cin >> n;\n string m = n;\n {\n for (char& c : m) {\n c ^= '1' ^ '0';\n }\n int ind = m.size() - 1;\n while (ind >= 0 && m[ind] == '1') {\n m[ind] = '0';\n --ind;\n }\n if (ind == -1) {\n m.insert(m.begin(), '1');\n n.insert(n.begin(), '0');\n } else {\n m[ind] = '1';\n }\n }\n\n int sz = n.size();\n\n vector<string> v = {n, m};\n vector<array<int, 2>> dp(sz);\n\n dp[sz - 1][0] = (v[0].back() == '1');\n dp[sz - 1][1] = (v[1].back() == '1');\n\n for (int i = sz - 2; i >= 0; --i) {\n for (int b = 0; b < 2; ++b) {\n if (v[b][i] == '0') {\n dp[i][b] = dp[i + 1][b];\n } else {\n dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n }\n }\n }\n\n cout << dp[0][0] << '\\n';\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/95148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*B"
          },
          "content_length": 9416
        },
        {
          "title": "Codeforces Round #171 (Div. 2) Разбор Задач - Codeforces",
          "content": "279A - Point on SpiralИз-за небольших ограничений в данной задаче можно было просто промоделировать шаги коня. Удобнее всего это делать, храня текущее направление движения и счетчик со значением, сколько шагов в эту сторону осталось. Заметим, что конь движется по спирали по следующему шаблону: 1 шаг вперед, поворот, 1 шаг вперед, поворот, 2 шага, поворот, 2 шага, поворот, 3 шага, поворот, 3 шага, поворот, 4 шага и так далее.279B - BooksПри решении этой задачи проще всего было воспользоваться методом двух указателей: левый указатель означает начало отрезка, правый — конец. При передвижении левого указателя на единицу вправо, правый надо двигать до тех пор, пока сумма ai внутри отрезка меньше или равна t. Так мы сможем для каждого левого конца найти максимально удаленный правый, а ответ на задачу — это максимальная длина из этих отрезков.279C - LadderДавайте перед выполнением запросов выпишем в массив down отдельно все позиции i, для которых ai > ai + 1, и в массив up такие позиции i, такие что ai < ai + 1. Теперь заметим важный факт для решения: отрезок [l, r] является лесенкой тогда, когда все позиции i, где ai < ai + 1 левее всех позиций j, в которых aj > aj + 1 (l ≤ i, j < r).Для того, чтобы проверить это условие, давайте воспользуемся массивами up и down, в них с помощью бинарного поиска можно надо найти наибольший индекс i в отрезке, где происходит возрастание, и наименьший индекс j в отрезке, где происходит убывание, и если i < j, то отрезок — это лесенка. Отдельно необходимо рассмотреть случаи, когда числа в отрезке образуют невозрастающую или неубывающую последовательность.279D - The Minimum Number of VariablesДавайте решать задачу методом динамического программирования по бинарной маске. Пусть текущее состояние — это mask. Через count(mask) обозначим количество единичных битов в маске, а через b1, b2, ..., bcount(mask) их индексы (здесь и далее будем использовать 0-нумерацию). Наше состояние означает, что в данный момент у нас имеется count(mask) переменных, которые равны ab1, ab2, ..., abcount(mask). Будем считать, что дойдя до такого состояния, мы уже сумели произвести count(mask) операций, а значит, сейчас нам надо получить x = abcount(mask) + 1.Если это число x не представимо в виде x = bi + bj, то тогда точно следующее значение мы получить не можем, и это состояние тупиковое, а иначе даже неважно какие именно значения i, j мы возьмем, главное — убедиться, что такие существуют. Итак, мы получаем число x на текущей операции. Теперь важно понять, куда мы можем его записать: а именно мы либо записываем в какую-либо из уже использованных переменных (старое значение стирается), либо в новую переменную (это будет стоить нам 1).В терминах масок первая операция выглядит как выкидывание одного из битов bk, и добавление нового бита, а вторая — просто добавление нового бита.Начальное состояние в нашей динамике — это mask = 1, конечное — любая маска, в которой есть единичный бит на позиции n - 1 (в 0-нумерации).При аккуратной реализации такое решение будет работать за O(2n·n). В частности, следующий хитрый прием поможет добиться этого: когда нам требуется проверить, что в маске есть такие два бита bi и bj, что acount(mask) = abi + abj, то будем использовать предподсчитанный массив diff[q][p], в котором будет записан индекс такого элемента массива a, который равен разности aq–ap. Это позволит нам при проверке перебирать лишь значение bi.279E - Beautiful DecompositionБудет опубликовано чуть позже…",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6864",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*B"
          },
          "content_length": 3458
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 5",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 6",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 7",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 8",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 9",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 10",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long t = opt<long long>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"min\") {\n        /* All ai are 1 */\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"max\") {\n        /* All ai are 10000 */\n        for (int i = 0; i < n; ++i)\n            ai[i] = 10000;\n    } else if (type == \"uniform\") {\n        /* All ai are the same specified value */\n        int a = opt<int>(\"a\");\n        ensure(1 <= a && a <= 10000);\n        for (int i = 0; i < n; ++i)\n            ai[i] = a;\n    } else if (type == \"random\") {\n        /* ai are random between 1 and 10000 */\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 10000);\n    } else if (type == \"ascending\") {\n        /* ai are ascending from min_a to max_a */\n        int min_a = opt<int>(\"min_a\", 1);\n        int max_a = opt<int>(\"max_a\", 10000);\n        ensure(1 <= min_a && min_a <= max_a && max_a <= 10000);\n        if (n == 1) {\n            ai[0] = min_a;\n        } else {\n            for (int i = 0; i < n; ++i)\n                ai[i] = min_a + (max_a - min_a) * i / (n - 1);\n        }\n    } else if (type == \"descending\") {\n        /* ai are descending from max_a to min_a */\n        int min_a = opt<int>(\"min_a\", 1);\n        int max_a = opt<int>(\"max_a\", 10000);\n        ensure(1 <= min_a && min_a <= max_a && max_a <= 10000);\n        if (n == 1) {\n            ai[0] = max_a;\n        } else {\n            for (int i = 0; i < n; ++i)\n                ai[i] = max_a - (max_a - min_a) * i / (n - 1);\n        }\n    } else if (type == \"special_hard\") {\n        /* Special hard test case */\n        int half = n / 2;\n        for (int i = 0; i < half; ++i)\n            ai[i] = 10000;\n        for (int i = half; i < n; ++i)\n            ai[i] = 1;\n    } else {\n        /* Unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    /* Output n and t */\n    printf(\"%d %lld\\n\", n, t);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long t = opt<long long>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"min\") {\n        /* All ai are 1 */\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"max\") {\n        /* All ai are 10000 */\n        for (int i = 0; i < n; ++i)\n            ai[i] = 10000;\n    } else if (type == \"uniform\") {\n        /* All ai are the same specified value */\n        int a = opt<int>(\"a\");\n        ensure(1 <= a && a <= 10000);\n        for (int i = 0; i < n; ++i)\n            ai[i] = a;\n    } else if (type == \"random\") {\n        /* ai are random between 1 and 10000 */\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 10000);\n    } else if (type == \"ascending\") {\n        /* ai are ascending from min_a to max_a */\n        int min_a = opt<int>(\"min_a\", 1);\n        int max_a = opt<int>(\"max_a\", 10000);\n        ensure(1 <= min_a && min_a <= max_a && max_a <= 10000);\n        if (n == 1) {\n            ai[0] = min_a;\n        } else {\n            for (int i = 0; i < n; ++i)\n                ai[i] = min_a + (max_a - min_a) * i / (n - 1);\n        }\n    } else if (type == \"descending\") {\n        /* ai are descending from max_a to min_a */\n        int min_a = opt<int>(\"min_a\", 1);\n        int max_a = opt<int>(\"max_a\", 10000);\n        ensure(1 <= min_a && min_a <= max_a && max_a <= 10000);\n        if (n == 1) {\n            ai[0] = max_a;\n        } else {\n            for (int i = 0; i < n; ++i)\n                ai[i] = max_a - (max_a - min_a) * i / (n - 1);\n        }\n    } else if (type == \"special_hard\") {\n        /* Special hard test case */\n        int half = n / 2;\n        for (int i = 0; i < half; ++i)\n            ai[i] = 10000;\n        for (int i = half; i < n; ++i)\n            ai[i] = 1;\n    } else {\n        /* Unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    /* Output n and t */\n    printf(\"%d %lld\\n\", n, t);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -t 1 -type min\n./gen -n 1 -t 1 -type max\n./gen -n 1 -t 5000 -type uniform -a 5000\n./gen -n 1 -t 10000 -type uniform -a 10000\n\n./gen -n 10 -t 55 -type ascending -min_a 1 -max_a 10\n./gen -n 10 -t 55 -type descending -min_a 1 -max_a 10\n./gen -n 10 -t 30 -type random\n\n./gen -n 100 -t 1000 -type min\n./gen -n 100 -t 1000000 -type max\n./gen -n 100 -t 5000 -type random\n./gen -n 100 -t 5000 -type uniform -a 50\n\n./gen -n 1000 -t 1000000 -type ascending -min_a 1 -max_a 1000\n./gen -n 1000 -t 1000000 -type descending -min_a 1 -max_a 1000\n./gen -n 1000 -t 10000000 -type random\n\n./gen -n 100000 -t 1000000000 -type min\n./gen -n 100000 -t 1 -type max\n./gen -n 100000 -t 500000000 -type random\n./gen -n 100000 -t 1000000000 -type ascending -min_a 1 -max_a 10000\n./gen -n 100000 -t 1000000000 -type descending -min_a 1 -max_a 10000\n\n# Special hard test case\n./gen -n 100000 -t 50000 -type special_hard\n\n# Edge cases\n./gen -n 50000 -t 0 -type random\n./gen -n 50000 -t 1 -type min\n./gen -n 50000 -t 1 -type max\n\n# Max t, random ai\n./gen -n 100000 -t 1000000000 -type random\n\n# Uniform ai, t less than sum of ai\n./gen -n 100000 -t 1000000 -type uniform -a 10\n\n# t equal to sum of ai\n./gen -n 100000 -t 1000000 -type uniform -a 10\n\n# t greater than sum of ai\n./gen -n 100000 -t 2000000 -type uniform -a 10\n\n# t less than any ai (can't read any book)\n./gen -n 1000 -t 1 -type uniform -a 2\n\n# t equals to minimal ai\n./gen -n 1000 -t 1 -type min\n\n# n = 1, t = 0\n./gen -n 1 -t 0 -type min\n\n# n = 100000, t = 0\n./gen -n 100000 -t 0 -type min\n\n# t is just enough to read one book\n./gen -n 100000 -t 1 -type min\n\n# t is large enough to read all books (ai = 1)\n./gen -n 100000 -t 1000000000 -type min\n\n# t is large enough to read all books (ai = 10000)\n./gen -n 100000 -t 1000000000 -type max\n\n# Randomly generated ai, t in middle range\n./gen -n 100000 -t 500000000 -type random\n\n# Ai at max, t small\n./gen -n 100000 -t 10000 -type max\n\n# All ai mid-range\n./gen -n 100000 -t 500000000 -type uniform -a 5000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:06.149831",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "279/C",
      "title": "C. Ladder",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 105) — the number of array elements and the number of queries. The second line contains the sequence of integers a1, a2, ..., an (1 ≤ ai ≤ 109), where number ai stands for the i-th array element.The following m lines contain the description of the queries. The i-th line contains the description of the i-th query, consisting of two integers li, ri (1 ≤ li ≤ ri ≤ n) — the boundaries of the subsegment of the initial array.The numbers in the lines are separated by single spaces.",
      "output_spec": "OutputPrint m lines, in the i-th line print word \"Yes\" (without the quotes), if the subsegment that corresponds to the i-th query is the ladder, or word \"No\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy8 61 2 1 3 3 5 2 11 32 32 48 81 45 8OutputCopyYesYesNoYesNoYes",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 105) — the number of array elements and the number of queries. The second line contains the sequence of integers a1, a2, ..., an (1 ≤ ai ≤ 109), where number ai stands for the i-th array element.The following m lines contain the description of the queries. The i-th line contains the description of the i-th query, consisting of two integers li, ri (1 ≤ li ≤ ri ≤ n) — the boundaries of the subsegment of the initial array.The numbers in the lines are separated by single spaces.\n\nOutputPrint m lines, in the i-th line print word \"Yes\" (without the quotes), if the subsegment that corresponds to the i-th query is the ladder, or word \"No\" (without the quotes) otherwise.\n\nInputCopy8 61 2 1 3 3 5 2 11 32 32 48 81 45 8OutputCopyYesYesNoYesNoYes\n\nInputCopy8 61 2 1 3 3 5 2 11 32 32 48 81 45 8\n\nOutputCopyYesYesNoYesNoYes",
      "solutions": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Hello, friends)Soon is coming regular Codeforces round #171 for Div.2 participants. Traditionally Div.1 participants can take part out of the competition.Again and again the problems were prepared by the familiar group of authors: Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: score distribution will be not standard a little bit: 500, 1000, 1500, 2000, 2000.We wish everyone good luck, successful hacks, high rating and good mood)UPD2: the contest is over, we hope you enjoy it)Congratulations to winners:1) study_english2) ipip20053) rng_502164) bfrcns1975) csavky103 UPD3: the editorial will be published soon",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6856",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 835
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Continuing with the theme of absent editorials for old rounds, here is an editorial for Codeforces Round 171 (Div. 2). Even though there is an official editorial, it is only in russian and doesn't have solution for the last problem.A Editorial279A - Point on SpiralSince constraints are small, you can just simulate the whole process, but I'll explain an O(1)O(1) solution. Let's look at the pathNow it's easy to see that the plane can be divided into four partsAnd then we can calculate answer for each part separately, just be careful with borders. For example, for the right part the answer is 4x−34x−3. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int x, y;\n cin >> x >> y;\n if (x == 0 && y == 0) {\n cout << 0 << '\\n';\n } else if (-x + 1 < y && y <= x) {\n cout << 1 + (x - 1) * 4 << '\\n';\n } else if (-y <= x && x < y) {\n cout << 2 + (y - 1) * 4 << '\\n';\n } else if (x <= y && y < -x) {\n cout << 3 + (-x - 1) * 4 << '\\n';\n } else {\n cout << 4 + (-y - 1) * 4 << '\\n';\n }\n\n return 0;\n}B Editorial279B - BooksThe problem can be written in the following way: for each index ii denote riri as the largest index such that ai+…+ari⩽tai+…+ari⩽t. The problem is to find max(ri−i+1)max(ri−i+1).One can see that riri are nondecreasing, so the problem can be solved with two pointers: iterate over ii and keep a pointer to corresponding riri. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, t;\n cin >> n >> t;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n int r = 0;\n int sm = 0;\n int ans = 0;\n for (int i = 0; i < n; ++i) {\n while (r < n && sm + a[r] <= t) {\n sm += a[r];\n ++r;\n }\n ans = max(ans, r - i);\n sm -= a[i];\n }\n\n cout << ans << '\\n';\n\n return 0;\n}C Editorial279C - LadderLet's calculate two arrays before answering queries. tol[i]tol[i] is the smallest index such that [btol[i],…,bi][btol[i],…,bi] is nonincreasing, and tor[i]tor[i] is the largest index such that [bi,…,btor[i]][bi,…,btor[i]] is nondecreasing. Then for each query we can take tor[l]tor[l] and tol[r]tol[r] and compare them. The answer is \"Yes\" iff tor[l]⩾tol[r]tor[l]⩾tol[r]. In other words, we are checking if the largest nondecreasing segment from ll and largest nonincreasing segment from rr are intersecting.To calculate tol[i]tol[i], go over ii from 11 to nn and maintain largest nonincreasing suffix. For tortor do the same in reverse. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, m;\n cin >> n >> m;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n vector<int> tor(n), tol(n);\n iota(tol.begin(), tol.end(), 0);\n iota(tor.begin(), tor.end(), 0);\n\n tol[0] = 0;\n for (int i = 1; i < n; ++i)\n if (a[i - 1] >= a[i])\n tol[i] = tol[i - 1];\n\n tor[n - 1] = n - 1;\n for (int i = n - 2; i >= 0; --i)\n if (a[i] <= a[i + 1])\n tor[i] = tor[i + 1];\n\n while (m--) {\n int l, r;\n cin >> l >> r;\n --l; --r;\n cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n }\n\n return 0;\n}D Editorial279D - The Minimum Number of VariablesYou can notice that when we want to perform some operation, we are only interested in a subset of current values of variables (including zeros). So let's create dp[i][mask]=booldp[i][mask]=bool, which is 11 if we can perform first ii operations and end up with the values from maskmask. Here kk-bit in the mask corresponds to the value vals[k]vals[k], where array valsvals stores all numbers in aa and a zero, and kk-th bit is set iff the value of one of the variables is vals[k]vals[k].To make transition from dp[i][mask]dp[i][mask] to dp[i+1][new_mask]dp[i+1][new_mask], let's look at the operation. We have to find two values in the maskmask such that their sum is a[i+1]a[i+1]. Then to calculate new_masknew_mask we have to set kk-th bit in the maskmask, where kk is such that vals[k]=a[i+1]vals[k]=a[i+1]. Also, while writing new variable we can overwrite any existing variable, so we have an option to disable any bit in the maskmask.Now it looks like we have O(2nn)O(2nn) states and nn transitions from each state (disabling each bit). But actually if we only make transition from dp[i][mask]=1dp[i][mask]=1, the complexity will be O(2nn)O(2nn), because for each ii there are at most 2i+12i+1 masks that we can achieve, since there are only ii distinct numbers on the current prefix plus an additional zero. And ∑ni=12i+1⋅n=O(2nn)∑i=1n2i+1⋅n=O(2nn).The only problem left is to check if we can build some number yy from valsvals using numbers from maskmask. This can be precomputed in O(2nn)O(2nn): let's calculate array possible[mask]=xpossible[mask]=x, where ii-th bit in xx is set iff we can get number vals[i]vals[i] from mask on the next step. To calculate it, first for each maskmask with at most 22 bits just calculate all possible xx with any straightforward approach, since there are only O(n2)O(n2) such masks. For any other mask notice that we can get yy iff sum of some two values equals to yy. So we can iterate over all submasks such that they differ from maskmask in exactly one bit and update possible[mask]possible[mask] with possible[submask]possible[submask]. And since maskmask has at least 33 bits, if there is a pair which sums up to yy, this pair will be included into at least one of the submasks. One can even notice that we only need any 33 such submasks to cover every pair of bits.The answer is minimum number of bits over all masks such that dp[n][mask]=1dp[n][mask]=1. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n;\n cin >> n;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n auto vals = a;\n vals.push_back(0);\n sort(vals.begin(), vals.end());\n vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n vector<int> pos(n);\n for (int i = 0; i < n; ++i) {\n pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n }\n\n vector<int> possible(1 << vals.size(), 0);\n for (int i = 1; i < possible.size(); ++i) {\n int k = 0;\n for (int j = 0; j < vals.size() && k < 3; ++j) {\n if ((i >> j) & 1) {\n possible[i] |= possible[i ^ (1 << j)];\n ++k;\n }\n }\n if (__builtin_popcount(i) <= 2) {\n for (int j = 0; j < vals.size(); ++j) {\n if (!((i >> j) & 1)) continue;\n for (int k = 0; k < vals.size(); ++k) {\n if (!((i >> k) & 1)) continue;\n int val = vals[j] + vals[k];\n int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n if (ind < vals.size() && vals[ind] == val)\n possible[i] |= (1 << ind);\n }\n }\n }\n }\n\n vector<char> dp_cur(1 << vals.size(), 0);\n dp_cur[1 << pos[0]] = 1;\n dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n auto can_sum = [&](int mask, int pos) {\n return (possible[mask] >> pos) & 1;\n };\n\n vector<char> dp_next;\n for (int i = 1; i < n; ++i) {\n dp_next.assign(dp_cur.size(), false);\n for (int j = 0; j < dp_cur.size(); ++j) {\n if (dp_cur[j] && can_sum(j, pos[i])) {\n int mask = j;\n mask |= (1 << pos[i]);\n dp_next[mask] = 1;\n for (int k = 0; k < vals.size(); ++k)\n if (((mask >> k) & 1) && vals[k] != a[i])\n dp_next[mask ^ (1 << k)] = 1;\n }\n }\n swap(dp_cur, dp_next);\n }\n\n int ans = -1;\n for (int i = 0; i < dp_cur.size(); ++i) {\n if (!dp_cur[i]) continue;\n int sz = __builtin_popcount(i);\n if (ans == -1 || ans > sz)\n ans = sz;\n }\n cout << ans << '\\n';\n\n return 0;\n}E Editorial279E - Beautiful DecompositionFirst of all it's easy to notice that we will use each power of 22 at most once.Let's look at the highest bit in the current number, suppose it's 2k2k. Since the sum of all powers of 22 below kk is less than 2k2k, we will have to add at least one power of two 2x2x with x⩾kx⩾k. One can see that adding 2k+22k+2 is not optimal, since then we will have to subtract at least 2k+12k+1 and 2k+2−2k+12k+2−2k+1 can be replaced with 2k+12k+1. So the only choices are 2k2k or 2k+12k+1. If we add 2k2k, we have to solve a problem for remaining number, which is a suffix or our current binary string. Otherwise, 2k+12k+1 is larger than our current number, so we just need the answer for m=2k+1−nm=2k+1−n. Let's call such mm a complement for a number nn (notice that we don't need kk in the definition because kk is defined as largest bit in nn)Now let's look at mm. To calculate it, we have to flip all bits in nn and add 11 to the result. Now it's easy to see that if mm is a complement for nn, then for any suffix of nn (in binary form), the corresponding suffix of mm is a complement for it. Also, nn is a complement for mm.So during our calculations we will only deal with nn, mm, suffixes of nn and suffixes of mm. And this leads to a following dp solution: let v[1]=nv[1]=n, v[2]=mv[2]=m. Then dp[ind][suf]dp[ind][suf] is the smallest answer for a binary number represented by a suffix of number v[ind]v[ind] starting from index sufsuf. We can calculate this dpdp starting from dp[…][n]dp[…][n] and the answer will be dp[1][1]dp[1][1]. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n string n;\n cin >> n;\n string m = n;\n {\n for (char& c : m) {\n c ^= '1' ^ '0';\n }\n int ind = m.size() - 1;\n while (ind >= 0 && m[ind] == '1') {\n m[ind] = '0';\n --ind;\n }\n if (ind == -1) {\n m.insert(m.begin(), '1');\n n.insert(n.begin(), '0');\n } else {\n m[ind] = '1';\n }\n }\n\n int sz = n.size();\n\n vector<string> v = {n, m};\n vector<array<int, 2>> dp(sz);\n\n dp[sz - 1][0] = (v[0].back() == '1');\n dp[sz - 1][1] = (v[1].back() == '1');\n\n for (int i = sz - 2; i >= 0; --i) {\n for (int b = 0; b < 2; ++b) {\n if (v[b][i] == '0') {\n dp[i][b] = dp[i + 1][b];\n } else {\n dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n }\n }\n }\n\n cout << dp[0][0] << '\\n';\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/95148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*C"
          },
          "content_length": 9416
        },
        {
          "title": "Codeforces Round #171 (Div. 2) Разбор Задач - Codeforces",
          "content": "279A - Point on SpiralИз-за небольших ограничений в данной задаче можно было просто промоделировать шаги коня. Удобнее всего это делать, храня текущее направление движения и счетчик со значением, сколько шагов в эту сторону осталось. Заметим, что конь движется по спирали по следующему шаблону: 1 шаг вперед, поворот, 1 шаг вперед, поворот, 2 шага, поворот, 2 шага, поворот, 3 шага, поворот, 3 шага, поворот, 4 шага и так далее.279B - BooksПри решении этой задачи проще всего было воспользоваться методом двух указателей: левый указатель означает начало отрезка, правый — конец. При передвижении левого указателя на единицу вправо, правый надо двигать до тех пор, пока сумма ai внутри отрезка меньше или равна t. Так мы сможем для каждого левого конца найти максимально удаленный правый, а ответ на задачу — это максимальная длина из этих отрезков.279C - LadderДавайте перед выполнением запросов выпишем в массив down отдельно все позиции i, для которых ai > ai + 1, и в массив up такие позиции i, такие что ai < ai + 1. Теперь заметим важный факт для решения: отрезок [l, r] является лесенкой тогда, когда все позиции i, где ai < ai + 1 левее всех позиций j, в которых aj > aj + 1 (l ≤ i, j < r).Для того, чтобы проверить это условие, давайте воспользуемся массивами up и down, в них с помощью бинарного поиска можно надо найти наибольший индекс i в отрезке, где происходит возрастание, и наименьший индекс j в отрезке, где происходит убывание, и если i < j, то отрезок — это лесенка. Отдельно необходимо рассмотреть случаи, когда числа в отрезке образуют невозрастающую или неубывающую последовательность.279D - The Minimum Number of VariablesДавайте решать задачу методом динамического программирования по бинарной маске. Пусть текущее состояние — это mask. Через count(mask) обозначим количество единичных битов в маске, а через b1, b2, ..., bcount(mask) их индексы (здесь и далее будем использовать 0-нумерацию). Наше состояние означает, что в данный момент у нас имеется count(mask) переменных, которые равны ab1, ab2, ..., abcount(mask). Будем считать, что дойдя до такого состояния, мы уже сумели произвести count(mask) операций, а значит, сейчас нам надо получить x = abcount(mask) + 1.Если это число x не представимо в виде x = bi + bj, то тогда точно следующее значение мы получить не можем, и это состояние тупиковое, а иначе даже неважно какие именно значения i, j мы возьмем, главное — убедиться, что такие существуют. Итак, мы получаем число x на текущей операции. Теперь важно понять, куда мы можем его записать: а именно мы либо записываем в какую-либо из уже использованных переменных (старое значение стирается), либо в новую переменную (это будет стоить нам 1).В терминах масок первая операция выглядит как выкидывание одного из битов bk, и добавление нового бита, а вторая — просто добавление нового бита.Начальное состояние в нашей динамике — это mask = 1, конечное — любая маска, в которой есть единичный бит на позиции n - 1 (в 0-нумерации).При аккуратной реализации такое решение будет работать за O(2n·n). В частности, следующий хитрый прием поможет добиться этого: когда нам требуется проверить, что в маске есть такие два бита bi и bj, что acount(mask) = abi + abj, то будем использовать предподсчитанный массив diff[q][p], в котором будет записан индекс такого элемента массива a, который равен разности aq–ap. Это позволит нам при проверке перебирать лишь значение bi.279E - Beautiful DecompositionБудет опубликовано чуть позже…",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6864",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*C"
          },
          "content_length": 3458
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 5",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 6",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 7",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 8",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 9",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 10",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        inf.readInt(1, 1000000000, format(\"a[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, format(\"l_%d\", i + 1));\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, format(\"r_%d\", i + 1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        inf.readInt(1, 1000000000, format(\"a[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, format(\"l_%d\", i + 1));\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, format(\"r_%d\", i + 1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        inf.readInt(1, 1000000000, format(\"a[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, format(\"l_%d\", i + 1));\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, format(\"r_%d\", i + 1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1); // Must be included\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // Default m = n\n    string type = opt<string>(\"type\", \"random\");\n    int c = opt<int>(\"value\", -1); // Used in 'constant' type\n\n    vector<int> a(n);\n\n    if (type == \"all_increasing\") {\n        a[0] = rnd.next(1, int(1e9) - n * 10);\n        for(int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 10);\n            a[i] = a[i-1] + delta;\n            if (a[i] > int(1e9)) a[i] = int(1e9);\n        }\n    }\n    else if (type == \"all_decreasing\") {\n        a[0] = rnd.next(n * 10, int(1e9));\n        for(int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 10);\n            a[i] = a[i-1] - delta;\n            if (a[i] < 1) a[i] = 1;\n        }\n    }\n    else if (type == \"constant\") {\n        if (c == -1) c = rnd.next(1, int(1e9));\n        for(int i = 0; i < n; ++i) {\n            a[i] = c;\n        }\n    }\n    else if (type == \"single_peak\") {\n        int x = rnd.next(1, n); // Peak position\n        a[0] = rnd.next(1, int(1e9) - n * 10);\n        for(int i = 1; i < x; ++i) {\n            int delta = rnd.next(0, 10);\n            a[i] = a[i-1] + delta;\n            if (a[i] > int(1e9)) a[i] = int(1e9);\n        }\n        if (x < n) {\n            a[x] = a[x-1];\n            for(int i = x+1; i < n; ++i) {\n                int delta = rnd.next(0, 10);\n                a[i] = a[i-1] - delta;\n                if (a[i] < 1) a[i] = 1;\n            }\n        }\n    }\n    else if (type == \"multiple_peaks\") {\n        int curr = rnd.next(1, int(1e9));\n        a[0] = curr;\n        int dir = 1; // 1 for increasing, -1 for decreasing\n\n        for(int i = 1; i < n; ++i) {\n            if (i > 1 && rnd.next(0, 5) == 0) dir *= -1; // Randomly change direction\n            int delta = rnd.next(0, 10);\n            curr += dir * delta;\n            if (curr < 1) curr = 1;\n            if (curr > int(1e9)) curr = int(1e9);\n            a[i] = curr;\n        }\n    }\n    else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    }\n    else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    }\n\n    // Generate m queries\n    vector<pair<int,int>> queries(m);\n    for(int i = 0; i < m; ++i) {\n        int l = rnd.next(1, n);\n        int r = rnd.next(1, n);\n        if (l > r) swap(l, r);\n        queries[i] = make_pair(l, r);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the array elements\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n    }\n\n    // Output the queries\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1); // Must be included\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // Default m = n\n    string type = opt<string>(\"type\", \"random\");\n    int c = opt<int>(\"value\", -1); // Used in 'constant' type\n\n    vector<int> a(n);\n\n    if (type == \"all_increasing\") {\n        a[0] = rnd.next(1, int(1e9) - n * 10);\n        for(int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 10);\n            a[i] = a[i-1] + delta;\n            if (a[i] > int(1e9)) a[i] = int(1e9);\n        }\n    }\n    else if (type == \"all_decreasing\") {\n        a[0] = rnd.next(n * 10, int(1e9));\n        for(int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 10);\n            a[i] = a[i-1] - delta;\n            if (a[i] < 1) a[i] = 1;\n        }\n    }\n    else if (type == \"constant\") {\n        if (c == -1) c = rnd.next(1, int(1e9));\n        for(int i = 0; i < n; ++i) {\n            a[i] = c;\n        }\n    }\n    else if (type == \"single_peak\") {\n        int x = rnd.next(1, n); // Peak position\n        a[0] = rnd.next(1, int(1e9) - n * 10);\n        for(int i = 1; i < x; ++i) {\n            int delta = rnd.next(0, 10);\n            a[i] = a[i-1] + delta;\n            if (a[i] > int(1e9)) a[i] = int(1e9);\n        }\n        if (x < n) {\n            a[x] = a[x-1];\n            for(int i = x+1; i < n; ++i) {\n                int delta = rnd.next(0, 10);\n                a[i] = a[i-1] - delta;\n                if (a[i] < 1) a[i] = 1;\n            }\n        }\n    }\n    else if (type == \"multiple_peaks\") {\n        int curr = rnd.next(1, int(1e9));\n        a[0] = curr;\n        int dir = 1; // 1 for increasing, -1 for decreasing\n\n        for(int i = 1; i < n; ++i) {\n            if (i > 1 && rnd.next(0, 5) == 0) dir *= -1; // Randomly change direction\n            int delta = rnd.next(0, 10);\n            curr += dir * delta;\n            if (curr < 1) curr = 1;\n            if (curr > int(1e9)) curr = int(1e9);\n            a[i] = curr;\n        }\n    }\n    else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    }\n    else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    }\n\n    // Generate m queries\n    vector<pair<int,int>> queries(m);\n    for(int i = 0; i < m; ++i) {\n        int l = rnd.next(1, n);\n        int r = rnd.next(1, n);\n        if (l > r) swap(l, r);\n        queries[i] = make_pair(l, r);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the array elements\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n    }\n\n    // Output the queries\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -type all_increasing\n./gen -n 5 -m 3 -type all_decreasing\n./gen -n 5 -m 3 -type constant\n./gen -n 5 -m 3 -type single_peak\n./gen -n 5 -m 3 -type multiple_peaks\n./gen -n 5 -m 3 -type random\n\n./gen -n 1000 -m 500 -type all_increasing\n./gen -n 1000 -m 500 -type all_decreasing\n./gen -n 1000 -m 500 -type constant\n./gen -n 1000 -m 500 -type single_peak\n./gen -n 1000 -m 500 -type multiple_peaks\n./gen -n 1000 -m 500 -type random\n\n./gen -n 100000 -m 100000 -type all_increasing\n./gen -n 100000 -m 100000 -type all_decreasing\n./gen -n 100000 -m 100000 -type constant\n./gen -n 100000 -m 100000 -type single_peak\n./gen -n 100000 -m 100000 -type multiple_peaks\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 1 -m 1 -type constant\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 100000 -type constant\n./gen -n 1 -m 100000 -type random\n./gen -n 100000 -m 1 -type random\n./gen -n 100000 -m 1 -type all_increasing\n\n./gen -n 100000 -m 100000 -type constant -value 1\n./gen -n 100000 -m 100000 -type constant -value 1000000000\n./gen -n 100000 -m 100000 -type single_peak\n./gen -n 99999 -m 100000 -type multiple_peaks\n\n./gen -n 1000 -m 500 -type constant -value 1\n./gen -n 1000 -m 500 -type constant -value 1000000000\n./gen -n 1 -m 1 -type constant -value 1\n./gen -n 1 -m 1 -type constant -value 1000000000\n\n./gen -n 50000 -m 50000 -type single_peak\n./gen -n 50000 -m 50000 -type multiple_peaks\n\n./gen -n 5 -m 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:08.364884",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "279/D",
      "title": "D. The Minimum Number of Variables",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 23). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ak ≤ 109).It is guaranteed that all numbers in the sequence are distinct.",
      "output_spec": "OutputIn a single line print a single number — the minimum number of variables m, such that those variables can help you perform the described sequence of operations.If you cannot perform the sequence of operations at any m, print -1.",
      "sample_tests": "ExamplesInputCopy51 2 3 6 8OutputCopy2InputCopy33 6 5OutputCopy-1InputCopy62 4 8 6 10 18OutputCopy3",
      "description": "D. The Minimum Number of Variables\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 23). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ak ≤ 109).It is guaranteed that all numbers in the sequence are distinct.\n\nOutputIn a single line print a single number — the minimum number of variables m, such that those variables can help you perform the described sequence of operations.If you cannot perform the sequence of operations at any m, print -1.\n\nInputCopy51 2 3 6 8OutputCopy2InputCopy33 6 5OutputCopy-1InputCopy62 4 8 6 10 18OutputCopy3\n\nInputCopy51 2 3 6 8\n\nOutputCopy2\n\nInputCopy33 6 5\n\nOutputCopy-1\n\nInputCopy62 4 8 6 10 18\n\nOutputCopy3\n\nNoteIn the first sample, you can use two variables b1 and b2 to perform the following sequence of operations.  b1 := 1;  b2 := b1 + b1;  b1 := b1 + b2;  b1 := b1 + b1;  b1 := b1 + b2.",
      "solutions": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Hello, friends)Soon is coming regular Codeforces round #171 for Div.2 participants. Traditionally Div.1 participants can take part out of the competition.Again and again the problems were prepared by the familiar group of authors: Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: score distribution will be not standard a little bit: 500, 1000, 1500, 2000, 2000.We wish everyone good luck, successful hacks, high rating and good mood)UPD2: the contest is over, we hope you enjoy it)Congratulations to winners:1) study_english2) ipip20053) rng_502164) bfrcns1975) csavky103 UPD3: the editorial will be published soon",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/6856",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 835
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Continuing with the theme of absent editorials for old rounds, here is an editorial for Codeforces Round 171 (Div. 2). Even though there is an official editorial, it is only in russian and doesn't have solution for the last problem.A Editorial279A - Point on SpiralSince constraints are small, you can just simulate the whole process, but I'll explain an O(1)O(1) solution. Let's look at the pathNow it's easy to see that the plane can be divided into four partsAnd then we can calculate answer for each part separately, just be careful with borders. For example, for the right part the answer is 4x−34x−3. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int x, y;\n cin >> x >> y;\n if (x == 0 && y == 0) {\n cout << 0 << '\\n';\n } else if (-x + 1 < y && y <= x) {\n cout << 1 + (x - 1) * 4 << '\\n';\n } else if (-y <= x && x < y) {\n cout << 2 + (y - 1) * 4 << '\\n';\n } else if (x <= y && y < -x) {\n cout << 3 + (-x - 1) * 4 << '\\n';\n } else {\n cout << 4 + (-y - 1) * 4 << '\\n';\n }\n\n return 0;\n}B Editorial279B - BooksThe problem can be written in the following way: for each index ii denote riri as the largest index such that ai+…+ari⩽tai+…+ari⩽t. The problem is to find max(ri−i+1)max(ri−i+1).One can see that riri are nondecreasing, so the problem can be solved with two pointers: iterate over ii and keep a pointer to corresponding riri. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, t;\n cin >> n >> t;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n int r = 0;\n int sm = 0;\n int ans = 0;\n for (int i = 0; i < n; ++i) {\n while (r < n && sm + a[r] <= t) {\n sm += a[r];\n ++r;\n }\n ans = max(ans, r - i);\n sm -= a[i];\n }\n\n cout << ans << '\\n';\n\n return 0;\n}C Editorial279C - LadderLet's calculate two arrays before answering queries. tol[i]tol[i] is the smallest index such that [btol[i],…,bi][btol[i],…,bi] is nonincreasing, and tor[i]tor[i] is the largest index such that [bi,…,btor[i]][bi,…,btor[i]] is nondecreasing. Then for each query we can take tor[l]tor[l] and tol[r]tol[r] and compare them. The answer is \"Yes\" iff tor[l]⩾tol[r]tor[l]⩾tol[r]. In other words, we are checking if the largest nondecreasing segment from ll and largest nonincreasing segment from rr are intersecting.To calculate tol[i]tol[i], go over ii from 11 to nn and maintain largest nonincreasing suffix. For tortor do the same in reverse. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, m;\n cin >> n >> m;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n vector<int> tor(n), tol(n);\n iota(tol.begin(), tol.end(), 0);\n iota(tor.begin(), tor.end(), 0);\n\n tol[0] = 0;\n for (int i = 1; i < n; ++i)\n if (a[i - 1] >= a[i])\n tol[i] = tol[i - 1];\n\n tor[n - 1] = n - 1;\n for (int i = n - 2; i >= 0; --i)\n if (a[i] <= a[i + 1])\n tor[i] = tor[i + 1];\n\n while (m--) {\n int l, r;\n cin >> l >> r;\n --l; --r;\n cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n }\n\n return 0;\n}D Editorial279D - The Minimum Number of VariablesYou can notice that when we want to perform some operation, we are only interested in a subset of current values of variables (including zeros). So let's create dp[i][mask]=booldp[i][mask]=bool, which is 11 if we can perform first ii operations and end up with the values from maskmask. Here kk-bit in the mask corresponds to the value vals[k]vals[k], where array valsvals stores all numbers in aa and a zero, and kk-th bit is set iff the value of one of the variables is vals[k]vals[k].To make transition from dp[i][mask]dp[i][mask] to dp[i+1][new_mask]dp[i+1][new_mask], let's look at the operation. We have to find two values in the maskmask such that their sum is a[i+1]a[i+1]. Then to calculate new_masknew_mask we have to set kk-th bit in the maskmask, where kk is such that vals[k]=a[i+1]vals[k]=a[i+1]. Also, while writing new variable we can overwrite any existing variable, so we have an option to disable any bit in the maskmask.Now it looks like we have O(2nn)O(2nn) states and nn transitions from each state (disabling each bit). But actually if we only make transition from dp[i][mask]=1dp[i][mask]=1, the complexity will be O(2nn)O(2nn), because for each ii there are at most 2i+12i+1 masks that we can achieve, since there are only ii distinct numbers on the current prefix plus an additional zero. And ∑ni=12i+1⋅n=O(2nn)∑i=1n2i+1⋅n=O(2nn).The only problem left is to check if we can build some number yy from valsvals using numbers from maskmask. This can be precomputed in O(2nn)O(2nn): let's calculate array possible[mask]=xpossible[mask]=x, where ii-th bit in xx is set iff we can get number vals[i]vals[i] from mask on the next step. To calculate it, first for each maskmask with at most 22 bits just calculate all possible xx with any straightforward approach, since there are only O(n2)O(n2) such masks. For any other mask notice that we can get yy iff sum of some two values equals to yy. So we can iterate over all submasks such that they differ from maskmask in exactly one bit and update possible[mask]possible[mask] with possible[submask]possible[submask]. And since maskmask has at least 33 bits, if there is a pair which sums up to yy, this pair will be included into at least one of the submasks. One can even notice that we only need any 33 such submasks to cover every pair of bits.The answer is minimum number of bits over all masks such that dp[n][mask]=1dp[n][mask]=1. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n;\n cin >> n;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n auto vals = a;\n vals.push_back(0);\n sort(vals.begin(), vals.end());\n vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n vector<int> pos(n);\n for (int i = 0; i < n; ++i) {\n pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n }\n\n vector<int> possible(1 << vals.size(), 0);\n for (int i = 1; i < possible.size(); ++i) {\n int k = 0;\n for (int j = 0; j < vals.size() && k < 3; ++j) {\n if ((i >> j) & 1) {\n possible[i] |= possible[i ^ (1 << j)];\n ++k;\n }\n }\n if (__builtin_popcount(i) <= 2) {\n for (int j = 0; j < vals.size(); ++j) {\n if (!((i >> j) & 1)) continue;\n for (int k = 0; k < vals.size(); ++k) {\n if (!((i >> k) & 1)) continue;\n int val = vals[j] + vals[k];\n int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n if (ind < vals.size() && vals[ind] == val)\n possible[i] |= (1 << ind);\n }\n }\n }\n }\n\n vector<char> dp_cur(1 << vals.size(), 0);\n dp_cur[1 << pos[0]] = 1;\n dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n auto can_sum = [&](int mask, int pos) {\n return (possible[mask] >> pos) & 1;\n };\n\n vector<char> dp_next;\n for (int i = 1; i < n; ++i) {\n dp_next.assign(dp_cur.size(), false);\n for (int j = 0; j < dp_cur.size(); ++j) {\n if (dp_cur[j] && can_sum(j, pos[i])) {\n int mask = j;\n mask |= (1 << pos[i]);\n dp_next[mask] = 1;\n for (int k = 0; k < vals.size(); ++k)\n if (((mask >> k) & 1) && vals[k] != a[i])\n dp_next[mask ^ (1 << k)] = 1;\n }\n }\n swap(dp_cur, dp_next);\n }\n\n int ans = -1;\n for (int i = 0; i < dp_cur.size(); ++i) {\n if (!dp_cur[i]) continue;\n int sz = __builtin_popcount(i);\n if (ans == -1 || ans > sz)\n ans = sz;\n }\n cout << ans << '\\n';\n\n return 0;\n}E Editorial279E - Beautiful DecompositionFirst of all it's easy to notice that we will use each power of 22 at most once.Let's look at the highest bit in the current number, suppose it's 2k2k. Since the sum of all powers of 22 below kk is less than 2k2k, we will have to add at least one power of two 2x2x with x⩾kx⩾k. One can see that adding 2k+22k+2 is not optimal, since then we will have to subtract at least 2k+12k+1 and 2k+2−2k+12k+2−2k+1 can be replaced with 2k+12k+1. So the only choices are 2k2k or 2k+12k+1. If we add 2k2k, we have to solve a problem for remaining number, which is a suffix or our current binary string. Otherwise, 2k+12k+1 is larger than our current number, so we just need the answer for m=2k+1−nm=2k+1−n. Let's call such mm a complement for a number nn (notice that we don't need kk in the definition because kk is defined as largest bit in nn)Now let's look at mm. To calculate it, we have to flip all bits in nn and add 11 to the result. Now it's easy to see that if mm is a complement for nn, then for any suffix of nn (in binary form), the corresponding suffix of mm is a complement for it. Also, nn is a complement for mm.So during our calculations we will only deal with nn, mm, suffixes of nn and suffixes of mm. And this leads to a following dp solution: let v[1]=nv[1]=n, v[2]=mv[2]=m. Then dp[ind][suf]dp[ind][suf] is the smallest answer for a binary number represented by a suffix of number v[ind]v[ind] starting from index sufsuf. We can calculate this dpdp starting from dp[…][n]dp[…][n] and the answer will be dp[1][1]dp[1][1]. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n string n;\n cin >> n;\n string m = n;\n {\n for (char& c : m) {\n c ^= '1' ^ '0';\n }\n int ind = m.size() - 1;\n while (ind >= 0 && m[ind] == '1') {\n m[ind] = '0';\n --ind;\n }\n if (ind == -1) {\n m.insert(m.begin(), '1');\n n.insert(n.begin(), '0');\n } else {\n m[ind] = '1';\n }\n }\n\n int sz = n.size();\n\n vector<string> v = {n, m};\n vector<array<int, 2>> dp(sz);\n\n dp[sz - 1][0] = (v[0].back() == '1');\n dp[sz - 1][1] = (v[1].back() == '1');\n\n for (int i = sz - 2; i >= 0; --i) {\n for (int b = 0; b < 2; ++b) {\n if (v[b][i] == '0') {\n dp[i][b] = dp[i + 1][b];\n } else {\n dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n }\n }\n }\n\n cout << dp[0][0] << '\\n';\n\n return 0;\n}",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/95148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*D"
          },
          "content_length": 9416
        },
        {
          "title": "Codeforces Round #171 (Div. 2) Разбор Задач - Codeforces",
          "content": "279A - Point on SpiralИз-за небольших ограничений в данной задаче можно было просто промоделировать шаги коня. Удобнее всего это делать, храня текущее направление движения и счетчик со значением, сколько шагов в эту сторону осталось. Заметим, что конь движется по спирали по следующему шаблону: 1 шаг вперед, поворот, 1 шаг вперед, поворот, 2 шага, поворот, 2 шага, поворот, 3 шага, поворот, 3 шага, поворот, 4 шага и так далее.279B - BooksПри решении этой задачи проще всего было воспользоваться методом двух указателей: левый указатель означает начало отрезка, правый — конец. При передвижении левого указателя на единицу вправо, правый надо двигать до тех пор, пока сумма ai внутри отрезка меньше или равна t. Так мы сможем для каждого левого конца найти максимально удаленный правый, а ответ на задачу — это максимальная длина из этих отрезков.279C - LadderДавайте перед выполнением запросов выпишем в массив down отдельно все позиции i, для которых ai > ai + 1, и в массив up такие позиции i, такие что ai < ai + 1. Теперь заметим важный факт для решения: отрезок [l, r] является лесенкой тогда, когда все позиции i, где ai < ai + 1 левее всех позиций j, в которых aj > aj + 1 (l ≤ i, j < r).Для того, чтобы проверить это условие, давайте воспользуемся массивами up и down, в них с помощью бинарного поиска можно надо найти наибольший индекс i в отрезке, где происходит возрастание, и наименьший индекс j в отрезке, где происходит убывание, и если i < j, то отрезок — это лесенка. Отдельно необходимо рассмотреть случаи, когда числа в отрезке образуют невозрастающую или неубывающую последовательность.279D - The Minimum Number of VariablesДавайте решать задачу методом динамического программирования по бинарной маске. Пусть текущее состояние — это mask. Через count(mask) обозначим количество единичных битов в маске, а через b1, b2, ..., bcount(mask) их индексы (здесь и далее будем использовать 0-нумерацию). Наше состояние означает, что в данный момент у нас имеется count(mask) переменных, которые равны ab1, ab2, ..., abcount(mask). Будем считать, что дойдя до такого состояния, мы уже сумели произвести count(mask) операций, а значит, сейчас нам надо получить x = abcount(mask) + 1.Если это число x не представимо в виде x = bi + bj, то тогда точно следующее значение мы получить не можем, и это состояние тупиковое, а иначе даже неважно какие именно значения i, j мы возьмем, главное — убедиться, что такие существуют. Итак, мы получаем число x на текущей операции. Теперь важно понять, куда мы можем его записать: а именно мы либо записываем в какую-либо из уже использованных переменных (старое значение стирается), либо в новую переменную (это будет стоить нам 1).В терминах масок первая операция выглядит как выкидывание одного из битов bk, и добавление нового бита, а вторая — просто добавление нового бита.Начальное состояние в нашей динамике — это mask = 1, конечное — любая маска, в которой есть единичный бит на позиции n - 1 (в 0-нумерации).При аккуратной реализации такое решение будет работать за O(2n·n). В частности, следующий хитрый прием поможет добиться этого: когда нам требуется проверить, что в маске есть такие два бита bi и bj, что acount(mask) = abi + abj, то будем использовать предподсчитанный массив diff[q][p], в котором будет записан индекс такого элемента массива a, который равен разности aq–ap. Это позволит нам при проверке перебирать лишь значение bi.279E - Beautiful DecompositionБудет опубликовано чуть позже…",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/6864",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*D"
          },
          "content_length": 3458
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 5",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 6",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 7",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 8",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 9",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 10",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 23, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that all numbers are distinct\n    ensuref(int(set<int>(a.begin(), a.end()).size()) == n, \"All numbers in the sequence are distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 23, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that all numbers are distinct\n    ensuref(int(set<int>(a.begin(), a.end()).size()) == n, \"All numbers in the sequence are distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 23, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that all numbers are distinct\n    ensuref(int(set<int>(a.begin(), a.end()).size()) == n, \"All numbers in the sequence are distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxa = opt<int>(\"maxa\", (int)1e9);\n\n    if (n < 1 || n > 23) {\n        fprintf(stderr, \"n out of bounds\\n\");\n        return 1;\n    }\n\n    set<int> used;\n    vector<int> a;\n\n    if (type == \"random\") {\n        // Generate n distinct random integers between 1 and maxa.\n        for (int i = 0; i < n; ++i) {\n            int num;\n            do {\n                num = rnd.next(1, maxa);\n            } while (used.count(num));\n            used.insert(num);\n            a.push_back(num);\n        }\n    } else if (type == \"increasing\") {\n        int num = rnd.next(1, maxa / (n + 1));\n        for (int i = 0; i < n; ++i) {\n            num += rnd.next(1, maxa / (n + 1));\n            if (num > maxa) num = maxa;\n            a.push_back(num);\n        }\n    } else if (type == \"decreasing\") {\n        int num = maxa - rnd.next(0, maxa / (n + 1));\n        for (int i = 0; i < n; ++i) {\n            num -= rnd.next(1, maxa / (n + 1));\n            if (num <= 0) num = 1;\n            a.push_back(num);\n        }\n    } else if (type == \"impossible\") {\n        // Generate an impossible sequence\n        if (n == 3) {\n            a = {3, 6, 5}; // Sample input with answer -1\n        } else {\n            a.push_back(2);\n            for (int i = 1; i < n; ++i) {\n                int num = a.back() + rnd.next(2, 10);\n                while (used.count(num)) {\n                    num += rnd.next(1, 10);\n                }\n                a.push_back(num);\n                used.insert(num);\n            }\n            // Shuffle to make it more challenging\n            shuffle(a.begin(), a.end());\n        }\n    } else if (type == \"powers\") {\n        int base = rnd.next(2, 5);\n        long long num = base;\n        for (int i = 0; i < n; ++i) {\n            if (num > maxa) break;\n            a.push_back((int)num);\n            num *= base;\n        }\n        // If we have fewer than n numbers, fill the rest with increments\n        while ((int)a.size() < n) {\n            int new_num = a.back() + rnd.next(1, maxa / n);\n            if (new_num > maxa) new_num = maxa;\n            a.push_back(new_num);\n        }\n        a.resize(n);\n    } else {\n        // Invalid type\n        fprintf(stderr, \"Invalid type\\n\");\n        return 1;\n    }\n\n    // Ensure that we have exactly n numbers\n    if ((int)a.size() != n) {\n        fprintf(stderr, \"Size mismatch: expected %d numbers, got %zu\\n\", n, a.size());\n        return 1;\n    }\n\n    // Ensure that all numbers are positive, <= maxa, and distinct\n    set<int> check_distinct(a.begin(), a.end());\n    if ((int)check_distinct.size() != n) {\n        fprintf(stderr, \"Numbers are not distinct\\n\");\n        return 1;\n    }\n    for (int x : a) {\n        if (x < 1 || x > maxa) {\n            fprintf(stderr, \"Number %d out of bounds\\n\", x);\n            return 1;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a1 a2 ... an\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i == n -1]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxa = opt<int>(\"maxa\", (int)1e9);\n\n    if (n < 1 || n > 23) {\n        fprintf(stderr, \"n out of bounds\\n\");\n        return 1;\n    }\n\n    set<int> used;\n    vector<int> a;\n\n    if (type == \"random\") {\n        // Generate n distinct random integers between 1 and maxa.\n        for (int i = 0; i < n; ++i) {\n            int num;\n            do {\n                num = rnd.next(1, maxa);\n            } while (used.count(num));\n            used.insert(num);\n            a.push_back(num);\n        }\n    } else if (type == \"increasing\") {\n        int num = rnd.next(1, maxa / (n + 1));\n        for (int i = 0; i < n; ++i) {\n            num += rnd.next(1, maxa / (n + 1));\n            if (num > maxa) num = maxa;\n            a.push_back(num);\n        }\n    } else if (type == \"decreasing\") {\n        int num = maxa - rnd.next(0, maxa / (n + 1));\n        for (int i = 0; i < n; ++i) {\n            num -= rnd.next(1, maxa / (n + 1));\n            if (num <= 0) num = 1;\n            a.push_back(num);\n        }\n    } else if (type == \"impossible\") {\n        // Generate an impossible sequence\n        if (n == 3) {\n            a = {3, 6, 5}; // Sample input with answer -1\n        } else {\n            a.push_back(2);\n            for (int i = 1; i < n; ++i) {\n                int num = a.back() + rnd.next(2, 10);\n                while (used.count(num)) {\n                    num += rnd.next(1, 10);\n                }\n                a.push_back(num);\n                used.insert(num);\n            }\n            // Shuffle to make it more challenging\n            shuffle(a.begin(), a.end());\n        }\n    } else if (type == \"powers\") {\n        int base = rnd.next(2, 5);\n        long long num = base;\n        for (int i = 0; i < n; ++i) {\n            if (num > maxa) break;\n            a.push_back((int)num);\n            num *= base;\n        }\n        // If we have fewer than n numbers, fill the rest with increments\n        while ((int)a.size() < n) {\n            int new_num = a.back() + rnd.next(1, maxa / n);\n            if (new_num > maxa) new_num = maxa;\n            a.push_back(new_num);\n        }\n        a.resize(n);\n    } else {\n        // Invalid type\n        fprintf(stderr, \"Invalid type\\n\");\n        return 1;\n    }\n\n    // Ensure that we have exactly n numbers\n    if ((int)a.size() != n) {\n        fprintf(stderr, \"Size mismatch: expected %d numbers, got %zu\\n\", n, a.size());\n        return 1;\n    }\n\n    // Ensure that all numbers are positive, <= maxa, and distinct\n    set<int> check_distinct(a.begin(), a.end());\n    if ((int)check_distinct.size() != n) {\n        fprintf(stderr, \"Numbers are not distinct\\n\");\n        return 1;\n    }\n    for (int x : a) {\n        if (x < 1 || x > maxa) {\n            fprintf(stderr, \"Number %d out of bounds\\n\", x);\n            return 1;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a1 a2 ... an\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i == n -1]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type impossible\n\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type impossible\n\n./gen -n 3 -type random\n./gen -n 3 -type impossible\n./gen -n 3 -type powers\n\n./gen -n 5 -type random\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n./gen -n 5 -type impossible\n./gen -n 5 -type powers\n\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type impossible\n./gen -n 10 -type powers\n\n./gen -n 15 -type random\n./gen -n 15 -type impossible\n./gen -n 15 -type powers\n\n./gen -n 20 -type random\n./gen -n 20 -type impossible\n./gen -n 20 -type powers\n\n./gen -n 23 -type random\n./gen -n 23 -type increasing\n./gen -n 23 -type decreasing\n./gen -n 23 -type impossible\n./gen -n 23 -type powers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:10.076184",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "279/E",
      "title": "E. Beautiful Decomposition",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains string s (1 ≤ |s| ≤ 106), that is the binary representation of number n without leading zeroes (n > 0).",
      "output_spec": "OutputPrint a single integer — the minimum amount of beautiful numbers that give a total of n.",
      "sample_tests": "ExamplesInputCopy10OutputCopy1InputCopy111OutputCopy2InputCopy1101101OutputCopy4",
      "description": "E. Beautiful Decomposition\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains string s (1 ≤ |s| ≤ 106), that is the binary representation of number n without leading zeroes (n > 0).\n\nOutputPrint a single integer — the minimum amount of beautiful numbers that give a total of n.\n\nInputCopy10OutputCopy1InputCopy111OutputCopy2InputCopy1101101OutputCopy4\n\nInputCopy10\n\nOutputCopy1\n\nInputCopy111\n\nOutputCopy2\n\nInputCopy1101101\n\nOutputCopy4\n\nNoteIn the first sample n = 2 is a beautiful number.In the second sample n = 7 and Valera can decompose it into sum 23 + ( - 20).In the third sample n = 109 can be decomposed into the sum of four summands as follows: 27 + ( - 24) + ( - 22) + 20.",
      "solutions": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Hello, friends)Soon is coming regular Codeforces round #171 for Div.2 participants. Traditionally Div.1 participants can take part out of the competition.Again and again the problems were prepared by the familiar group of authors: Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: score distribution will be not standard a little bit: 500, 1000, 1500, 2000, 2000.We wish everyone good luck, successful hacks, high rating and good mood)UPD2: the contest is over, we hope you enjoy it)Congratulations to winners:1) study_english2) ipip20053) rng_502164) bfrcns1975) csavky103 UPD3: the editorial will be published soon",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6856",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 835
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces",
          "content": "Continuing with the theme of absent editorials for old rounds, here is an editorial for Codeforces Round 171 (Div. 2). Even though there is an official editorial, it is only in russian and doesn't have solution for the last problem.A Editorial279A - Point on SpiralSince constraints are small, you can just simulate the whole process, but I'll explain an O(1)O(1) solution. Let's look at the pathNow it's easy to see that the plane can be divided into four partsAnd then we can calculate answer for each part separately, just be careful with borders. For example, for the right part the answer is 4x−34x−3. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int x, y;\n cin >> x >> y;\n if (x == 0 && y == 0) {\n cout << 0 << '\\n';\n } else if (-x + 1 < y && y <= x) {\n cout << 1 + (x - 1) * 4 << '\\n';\n } else if (-y <= x && x < y) {\n cout << 2 + (y - 1) * 4 << '\\n';\n } else if (x <= y && y < -x) {\n cout << 3 + (-x - 1) * 4 << '\\n';\n } else {\n cout << 4 + (-y - 1) * 4 << '\\n';\n }\n\n return 0;\n}B Editorial279B - BooksThe problem can be written in the following way: for each index ii denote riri as the largest index such that ai+…+ari⩽tai+…+ari⩽t. The problem is to find max(ri−i+1)max(ri−i+1).One can see that riri are nondecreasing, so the problem can be solved with two pointers: iterate over ii and keep a pointer to corresponding riri. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, t;\n cin >> n >> t;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n int r = 0;\n int sm = 0;\n int ans = 0;\n for (int i = 0; i < n; ++i) {\n while (r < n && sm + a[r] <= t) {\n sm += a[r];\n ++r;\n }\n ans = max(ans, r - i);\n sm -= a[i];\n }\n\n cout << ans << '\\n';\n\n return 0;\n}C Editorial279C - LadderLet's calculate two arrays before answering queries. tol[i]tol[i] is the smallest index such that [btol[i],…,bi][btol[i],…,bi] is nonincreasing, and tor[i]tor[i] is the largest index such that [bi,…,btor[i]][bi,…,btor[i]] is nondecreasing. Then for each query we can take tor[l]tor[l] and tol[r]tol[r] and compare them. The answer is \"Yes\" iff tor[l]⩾tol[r]tor[l]⩾tol[r]. In other words, we are checking if the largest nondecreasing segment from ll and largest nonincreasing segment from rr are intersecting.To calculate tol[i]tol[i], go over ii from 11 to nn and maintain largest nonincreasing suffix. For tortor do the same in reverse. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n, m;\n cin >> n >> m;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n vector<int> tor(n), tol(n);\n iota(tol.begin(), tol.end(), 0);\n iota(tor.begin(), tor.end(), 0);\n\n tol[0] = 0;\n for (int i = 1; i < n; ++i)\n if (a[i - 1] >= a[i])\n tol[i] = tol[i - 1];\n\n tor[n - 1] = n - 1;\n for (int i = n - 2; i >= 0; --i)\n if (a[i] <= a[i + 1])\n tor[i] = tor[i + 1];\n\n while (m--) {\n int l, r;\n cin >> l >> r;\n --l; --r;\n cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n }\n\n return 0;\n}D Editorial279D - The Minimum Number of VariablesYou can notice that when we want to perform some operation, we are only interested in a subset of current values of variables (including zeros). So let's create dp[i][mask]=booldp[i][mask]=bool, which is 11 if we can perform first ii operations and end up with the values from maskmask. Here kk-bit in the mask corresponds to the value vals[k]vals[k], where array valsvals stores all numbers in aa and a zero, and kk-th bit is set iff the value of one of the variables is vals[k]vals[k].To make transition from dp[i][mask]dp[i][mask] to dp[i+1][new_mask]dp[i+1][new_mask], let's look at the operation. We have to find two values in the maskmask such that their sum is a[i+1]a[i+1]. Then to calculate new_masknew_mask we have to set kk-th bit in the maskmask, where kk is such that vals[k]=a[i+1]vals[k]=a[i+1]. Also, while writing new variable we can overwrite any existing variable, so we have an option to disable any bit in the maskmask.Now it looks like we have O(2nn)O(2nn) states and nn transitions from each state (disabling each bit). But actually if we only make transition from dp[i][mask]=1dp[i][mask]=1, the complexity will be O(2nn)O(2nn), because for each ii there are at most 2i+12i+1 masks that we can achieve, since there are only ii distinct numbers on the current prefix plus an additional zero. And ∑ni=12i+1⋅n=O(2nn)∑i=1n2i+1⋅n=O(2nn).The only problem left is to check if we can build some number yy from valsvals using numbers from maskmask. This can be precomputed in O(2nn)O(2nn): let's calculate array possible[mask]=xpossible[mask]=x, where ii-th bit in xx is set iff we can get number vals[i]vals[i] from mask on the next step. To calculate it, first for each maskmask with at most 22 bits just calculate all possible xx with any straightforward approach, since there are only O(n2)O(n2) such masks. For any other mask notice that we can get yy iff sum of some two values equals to yy. So we can iterate over all submasks such that they differ from maskmask in exactly one bit and update possible[mask]possible[mask] with possible[submask]possible[submask]. And since maskmask has at least 33 bits, if there is a pair which sums up to yy, this pair will be included into at least one of the submasks. One can even notice that we only need any 33 such submasks to cover every pair of bits.The answer is minimum number of bits over all masks such that dp[n][mask]=1dp[n][mask]=1. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n int n;\n cin >> n;\n vector<int> a(n);\n for (int& k : a)\n cin >> k;\n\n auto vals = a;\n vals.push_back(0);\n sort(vals.begin(), vals.end());\n vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n vector<int> pos(n);\n for (int i = 0; i < n; ++i) {\n pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n }\n\n vector<int> possible(1 << vals.size(), 0);\n for (int i = 1; i < possible.size(); ++i) {\n int k = 0;\n for (int j = 0; j < vals.size() && k < 3; ++j) {\n if ((i >> j) & 1) {\n possible[i] |= possible[i ^ (1 << j)];\n ++k;\n }\n }\n if (__builtin_popcount(i) <= 2) {\n for (int j = 0; j < vals.size(); ++j) {\n if (!((i >> j) & 1)) continue;\n for (int k = 0; k < vals.size(); ++k) {\n if (!((i >> k) & 1)) continue;\n int val = vals[j] + vals[k];\n int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n if (ind < vals.size() && vals[ind] == val)\n possible[i] |= (1 << ind);\n }\n }\n }\n }\n\n vector<char> dp_cur(1 << vals.size(), 0);\n dp_cur[1 << pos[0]] = 1;\n dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n auto can_sum = [&](int mask, int pos) {\n return (possible[mask] >> pos) & 1;\n };\n\n vector<char> dp_next;\n for (int i = 1; i < n; ++i) {\n dp_next.assign(dp_cur.size(), false);\n for (int j = 0; j < dp_cur.size(); ++j) {\n if (dp_cur[j] && can_sum(j, pos[i])) {\n int mask = j;\n mask |= (1 << pos[i]);\n dp_next[mask] = 1;\n for (int k = 0; k < vals.size(); ++k)\n if (((mask >> k) & 1) && vals[k] != a[i])\n dp_next[mask ^ (1 << k)] = 1;\n }\n }\n swap(dp_cur, dp_next);\n }\n\n int ans = -1;\n for (int i = 0; i < dp_cur.size(); ++i) {\n if (!dp_cur[i]) continue;\n int sz = __builtin_popcount(i);\n if (ans == -1 || ans > sz)\n ans = sz;\n }\n cout << ans << '\\n';\n\n return 0;\n}E Editorial279E - Beautiful DecompositionFirst of all it's easy to notice that we will use each power of 22 at most once.Let's look at the highest bit in the current number, suppose it's 2k2k. Since the sum of all powers of 22 below kk is less than 2k2k, we will have to add at least one power of two 2x2x with x⩾kx⩾k. One can see that adding 2k+22k+2 is not optimal, since then we will have to subtract at least 2k+12k+1 and 2k+2−2k+12k+2−2k+1 can be replaced with 2k+12k+1. So the only choices are 2k2k or 2k+12k+1. If we add 2k2k, we have to solve a problem for remaining number, which is a suffix or our current binary string. Otherwise, 2k+12k+1 is larger than our current number, so we just need the answer for m=2k+1−nm=2k+1−n. Let's call such mm a complement for a number nn (notice that we don't need kk in the definition because kk is defined as largest bit in nn)Now let's look at mm. To calculate it, we have to flip all bits in nn and add 11 to the result. Now it's easy to see that if mm is a complement for nn, then for any suffix of nn (in binary form), the corresponding suffix of mm is a complement for it. Also, nn is a complement for mm.So during our calculations we will only deal with nn, mm, suffixes of nn and suffixes of mm. And this leads to a following dp solution: let v[1]=nv[1]=n, v[2]=mv[2]=m. Then dp[ind][suf]dp[ind][suf] is the smallest answer for a binary number represented by a suffix of number v[ind]v[ind] starting from index sufsuf. We can calculate this dpdp starting from dp[…][n]dp[…][n] and the answer will be dp[1][1]dp[1][1]. Code#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n string n;\n cin >> n;\n string m = n;\n {\n for (char& c : m) {\n c ^= '1' ^ '0';\n }\n int ind = m.size() - 1;\n while (ind >= 0 && m[ind] == '1') {\n m[ind] = '0';\n --ind;\n }\n if (ind == -1) {\n m.insert(m.begin(), '1');\n n.insert(n.begin(), '0');\n } else {\n m[ind] = '1';\n }\n }\n\n int sz = n.size();\n\n vector<string> v = {n, m};\n vector<array<int, 2>> dp(sz);\n\n dp[sz - 1][0] = (v[0].back() == '1');\n dp[sz - 1][1] = (v[1].back() == '1');\n\n for (int i = sz - 2; i >= 0; --i) {\n for (int b = 0; b < 2; ++b) {\n if (v[b][i] == '0') {\n dp[i][b] = dp[i + 1][b];\n } else {\n dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n }\n }\n }\n\n cout << dp[0][0] << '\\n';\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/95148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*E"
          },
          "content_length": 9416
        },
        {
          "title": "Codeforces Round #171 (Div. 2) Разбор Задач - Codeforces",
          "content": "279A - Point on SpiralИз-за небольших ограничений в данной задаче можно было просто промоделировать шаги коня. Удобнее всего это делать, храня текущее направление движения и счетчик со значением, сколько шагов в эту сторону осталось. Заметим, что конь движется по спирали по следующему шаблону: 1 шаг вперед, поворот, 1 шаг вперед, поворот, 2 шага, поворот, 2 шага, поворот, 3 шага, поворот, 3 шага, поворот, 4 шага и так далее.279B - BooksПри решении этой задачи проще всего было воспользоваться методом двух указателей: левый указатель означает начало отрезка, правый — конец. При передвижении левого указателя на единицу вправо, правый надо двигать до тех пор, пока сумма ai внутри отрезка меньше или равна t. Так мы сможем для каждого левого конца найти максимально удаленный правый, а ответ на задачу — это максимальная длина из этих отрезков.279C - LadderДавайте перед выполнением запросов выпишем в массив down отдельно все позиции i, для которых ai > ai + 1, и в массив up такие позиции i, такие что ai < ai + 1. Теперь заметим важный факт для решения: отрезок [l, r] является лесенкой тогда, когда все позиции i, где ai < ai + 1 левее всех позиций j, в которых aj > aj + 1 (l ≤ i, j < r).Для того, чтобы проверить это условие, давайте воспользуемся массивами up и down, в них с помощью бинарного поиска можно надо найти наибольший индекс i в отрезке, где происходит возрастание, и наименьший индекс j в отрезке, где происходит убывание, и если i < j, то отрезок — это лесенка. Отдельно необходимо рассмотреть случаи, когда числа в отрезке образуют невозрастающую или неубывающую последовательность.279D - The Minimum Number of VariablesДавайте решать задачу методом динамического программирования по бинарной маске. Пусть текущее состояние — это mask. Через count(mask) обозначим количество единичных битов в маске, а через b1, b2, ..., bcount(mask) их индексы (здесь и далее будем использовать 0-нумерацию). Наше состояние означает, что в данный момент у нас имеется count(mask) переменных, которые равны ab1, ab2, ..., abcount(mask). Будем считать, что дойдя до такого состояния, мы уже сумели произвести count(mask) операций, а значит, сейчас нам надо получить x = abcount(mask) + 1.Если это число x не представимо в виде x = bi + bj, то тогда точно следующее значение мы получить не можем, и это состояние тупиковое, а иначе даже неважно какие именно значения i, j мы возьмем, главное — убедиться, что такие существуют. Итак, мы получаем число x на текущей операции. Теперь важно понять, куда мы можем его записать: а именно мы либо записываем в какую-либо из уже использованных переменных (старое значение стирается), либо в новую переменную (это будет стоить нам 1).В терминах масок первая операция выглядит как выкидывание одного из битов bk, и добавление нового бита, а вторая — просто добавление нового бита.Начальное состояние в нашей динамике — это mask = 1, конечное — любая маска, в которой есть единичный бит на позиции n - 1 (в 0-нумерации).При аккуратной реализации такое решение будет работать за O(2n·n). В частности, следующий хитрый прием поможет добиться этого: когда нам требуется проверить, что в маске есть такие два бита bi и bj, что acount(mask) = abi + abj, то будем использовать предподсчитанный массив diff[q][p], в котором будет записан индекс такого элемента массива a, который равен разности aq–ap. Это позволит нам при проверке перебирать лишь значение bi.279E - Beautiful DecompositionБудет опубликовано чуть позже…",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6864",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 279\\s*E"
          },
          "content_length": 3458
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "10 1\n1 1 1 1 2 3 4 5 2 1\n1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "7 3\n4 2 2 2 2 2 10\n2 7\n2 6\n5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6856",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 1",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 2",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) {\n        cout << 0 << '\\n';\n    } else if (-x + 1 < y && y <= x) {\n        cout << 1 + (x - 1) * 4 << '\\n';\n    } else if (-y <= x && x < y) {\n        cout << 2 + (y - 1) * 4 << '\\n';\n    } else if (x <= y && y < -x) {\n        cout << 3 + (-x - 1) * 4 << '\\n';\n    } else {\n        cout << 4 + (-y - 1) * 4 << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 3",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 4",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    int r = 0;\n    int sm = 0;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        while (r < n && sm + a[r] <= t) {\n            sm += a[r];\n            ++r;\n        }\n        ans = max(ans, r - i);\n        sm -= a[i];\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 5",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 6",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    vector<int> tor(n), tol(n);\n    iota(tol.begin(), tol.end(), 0);\n    iota(tor.begin(), tor.end(), 0);\n\n    tol[0] = 0;\n    for (int i = 1; i < n; ++i)\n        if (a[i - 1] >= a[i])\n            tol[i] = tol[i - 1];\n\n    tor[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i)\n        if (a[i] <= a[i + 1])\n            tor[i] = tor[i + 1];\n\n    while (m--) {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        cout << (tol[r] <= tor[l] ? \"Yes\" : \"No\") << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 7",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 8",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& k : a)\n        cin >> k;\n\n    auto vals = a;\n    vals.push_back(0);\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n\n    vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin();\n    }\n\n    vector<int> possible(1 << vals.size(), 0);\n    for (int i = 1; i < possible.size(); ++i) {\n        int k = 0;\n        for (int j = 0; j < vals.size() && k < 3; ++j) {\n            if ((i >> j) & 1) {\n                possible[i] |= possible[i ^ (1 << j)];\n                ++k;\n            }\n        }\n        if (__builtin_popcount(i) <= 2) {\n            for (int j = 0; j < vals.size(); ++j) {\n                if (!((i >> j) & 1)) continue;\n                for (int k = 0; k < vals.size(); ++k) {\n                    if (!((i >> k) & 1)) continue;\n                    int val = vals[j] + vals[k];\n                    int ind = lower_bound(vals.begin(), vals.end(), val) - vals.begin();\n                    if (ind < vals.size() && vals[ind] == val)\n                        possible[i] |= (1 << ind);\n                }\n            }\n        }\n    }\n\n    vector<char> dp_cur(1 << vals.size(), 0);\n    dp_cur[1 << pos[0]] = 1;\n    dp_cur[(1 << pos[0]) | (1 << 0)] = 1;\n\n    auto can_sum = [&](int mask, int pos) {\n        return (possible[mask] >> pos) & 1;\n    };\n\n    vector<char> dp_next;\n    for (int i = 1; i < n; ++i) {\n        dp_next.assign(dp_cur.size(), false);\n        for (int j = 0; j < dp_cur.size(); ++j) {\n            if (dp_cur[j] && can_sum(j, pos[i])) {\n                int mask = j;\n                mask |= (1 << pos[i]);\n                dp_next[mask] = 1;\n                for (int k = 0; k < vals.size(); ++k)\n                    if (((mask >> k) & 1) && vals[k] != a[i])\n                        dp_next[mask ^ (1 << k)] = 1;\n            }\n        }\n        swap(dp_cur, dp_next);\n    }\n\n    int ans = -1;\n    for (int i = 0; i < dp_cur.size(); ++i) {\n        if (!dp_cur[i]) continue;\n        int sz = __builtin_popcount(i);\n        if (ans == -1 || ans > sz)\n            ans = sz;\n    }\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 9",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #171 (Div. 2) - Codeforces - Code 10",
          "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    string n;\n    cin >> n;\n    string m = n;\n    {\n        for (char& c : m) {\n            c ^= '1' ^ '0';\n        }\n        int ind = m.size() - 1;\n        while (ind >= 0 && m[ind] == '1') {\n            m[ind] = '0';\n            --ind;\n        }\n        if (ind == -1) {\n            m.insert(m.begin(), '1');\n            n.insert(n.begin(), '0');\n        } else {\n            m[ind] = '1';\n        }\n    }\n\n    int sz = n.size();\n\n    vector<string> v = {n, m};\n    vector<array<int, 2>> dp(sz);\n\n    dp[sz - 1][0] = (v[0].back() == '1');\n    dp[sz - 1][1] = (v[1].back() == '1');\n\n    for (int i = sz - 2; i >= 0; --i) {\n        for (int b = 0; b < 2; ++b) {\n            if (v[b][i] == '0') {\n                dp[i][b] = dp[i + 1][b];\n            } else {\n                dp[i][b] = min(dp[i + 1][b] + 1, dp[i + 1][b ^ 1] + 1);\n            }\n        }\n    }\n\n    cout << dp[0][0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/95148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"1[01]{0,999999}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"1[01]{0,999999}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"1[01]{0,999999}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    if (type == \"all_ones\") {\n        s = string(n, '1');\n    } else if (type == \"alternating\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? '1' : '0';\n    } else if (type == \"single_one_high\") {\n        s = '1' + string(n - 1, '0'); // '1' followed by zeros\n    } else if (type == \"single_one_low\") {\n        s = string(n - 1, '0') + '1';  // zeros followed by '1'\n    } else if (type == \"random\") {\n        s.resize(n);\n        s[0] = '1'; // No leading zeros\n        for (int i = 1; i < n; ++i)\n            s[i] = rnd.next(2) + '0';\n    } else if (type == \"long_run_ones\") {\n        int run_length = opt<int>(\"run_length\", n);\n        s = string(run_length, '1') + string(n - run_length, '0');\n    } else if (type == \"random_sparse\") {\n        s.resize(n);\n        s[0] = '1'; // No leading zeros\n        for (int i = 1; i < n; ++i)\n            s[i] = (rnd.next(1000) == 0) ? '1' : '0'; // Sparse ones\n    } else if (type == \"random_dense\") {\n        s.resize(n);\n        s[0] = '1'; // No leading zeros\n        for (int i = 1; i < n; ++i)\n            s[i] = (rnd.next(1000) < 900) ? '1' : '0'; // Dense ones\n    } else if (type == \"max_value\") {\n        s = string(n, '1');\n    } else {\n        s = string(n, '1'); // default to all ones\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    if (type == \"all_ones\") {\n        s = string(n, '1');\n    } else if (type == \"alternating\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? '1' : '0';\n    } else if (type == \"single_one_high\") {\n        s = '1' + string(n - 1, '0'); // '1' followed by zeros\n    } else if (type == \"single_one_low\") {\n        s = string(n - 1, '0') + '1';  // zeros followed by '1'\n    } else if (type == \"random\") {\n        s.resize(n);\n        s[0] = '1'; // No leading zeros\n        for (int i = 1; i < n; ++i)\n            s[i] = rnd.next(2) + '0';\n    } else if (type == \"long_run_ones\") {\n        int run_length = opt<int>(\"run_length\", n);\n        s = string(run_length, '1') + string(n - run_length, '0');\n    } else if (type == \"random_sparse\") {\n        s.resize(n);\n        s[0] = '1'; // No leading zeros\n        for (int i = 1; i < n; ++i)\n            s[i] = (rnd.next(1000) == 0) ? '1' : '0'; // Sparse ones\n    } else if (type == \"random_dense\") {\n        s.resize(n);\n        s[0] = '1'; // No leading zeros\n        for (int i = 1; i < n; ++i)\n            s[i] = (rnd.next(1000) < 900) ? '1' : '0'; // Dense ones\n    } else if (type == \"max_value\") {\n        s = string(n, '1');\n    } else {\n        s = string(n, '1'); // default to all ones\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small values\n./gen -n 1 -type min_value\n./gen -n 1 -type single_one_high\n./gen -n 2 -type all_ones\n./gen -n 3 -type alternating\n./gen -n 5 -type single_one_low\n./gen -n 5 -type long_run_ones -run_length 3\n./gen -n 5 -type random\n./gen -n 10 -type random_sparse\n./gen -n 10 -type random_dense\n\n# Medium values\n./gen -n 100 -type all_ones\n./gen -n 100 -type alternating\n./gen -n 100 -type random\n./gen -n 100 -type random_sparse\n./gen -n 100 -type random_dense\n./gen -n 100 -type long_run_ones -run_length 50\n\n# Edge cases\n./gen -n 1000 -type max_value\n./gen -n 1000 -type single_one_high\n./gen -n 1000 -type single_one_low\n./gen -n 1000 -type random\n\n./gen -n 100000 -type all_ones\n./gen -n 100000 -type random\n./gen -n 100000 -type random_sparse\n./gen -n 100000 -type random_dense\n\n# Very large values\n./gen -n 1000000 -type max_value\n./gen -n 1000000 -type random\n./gen -n 1000000 -type random_sparse\n./gen -n 1000000 -type random_dense\n\n# Special cases\n./gen -n 1000000 -type single_one_high\n./gen -n 1000000 -type single_one_low\n./gen -n 1000000 -type alternating\n./gen -n 1000000 -type long_run_ones -run_length 999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:12.194997",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "28/A",
      "title": "A. Задача Бендера",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке даны два натуральных числа n и m (4 ≤ n ≤ 500, 2 ≤ m ≤ 500, n четно) — количество гвоздей и прутьев соответственно. В следующих n строках даны координаты гвоздей в том порядке, в котором они соединяются ломаной. В (n + 2)-ой строке заданы m чисел — длины прутьев. Все координаты — целые числа, не превосходящие по модулю 104. Длины прутьев — целые числа от 1 до 200 000. Никакой прут нельзя использовать дважды. Гарантируется, что все отрезки заданной ломаной параллельны осям координат и никакие 3 подряд идущих гвоздя не лежат на одной прямой.",
      "output_spec": "Выходные данныеЕсли задача Бендера неразрешима, выведите NO. Иначе в первой строке выведите YES, а во второй строке выведите n чисел — i-ое число — номер прута, место сгиба которого прикреплена к i-ому гвоздю, или -1, если нет такого прута.Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 20 00 22 22 04 4Выходные данныеСкопироватьYES1 -1 2 -1 Входные данныеСкопировать6 30 01 01 12 12 20 23 2 3Выходные данныеСкопироватьYES1 -1 2 -1 3 -1 Входные данныеСкопировать6 30 01 01 12 12 20 22 2 3Выходные данныеСкопироватьNO",
      "description": "A. Задача Бендера\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке даны два натуральных числа n и m (4 ≤ n ≤ 500, 2 ≤ m ≤ 500, n четно) — количество гвоздей и прутьев соответственно. В следующих n строках даны координаты гвоздей в том порядке, в котором они соединяются ломаной. В (n + 2)-ой строке заданы m чисел — длины прутьев. Все координаты — целые числа, не превосходящие по модулю 104. Длины прутьев — целые числа от 1 до 200 000. Никакой прут нельзя использовать дважды. Гарантируется, что все отрезки заданной ломаной параллельны осям координат и никакие 3 подряд идущих гвоздя не лежат на одной прямой.\n\nВходные данные\n\nВыходные данныеЕсли задача Бендера неразрешима, выведите NO. Иначе в первой строке выведите YES, а во второй строке выведите n чисел — i-ое число — номер прута, место сгиба которого прикреплена к i-ому гвоздю, или -1, если нет такого прута.Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать4 20 00 22 22 04 4Выходные данныеСкопироватьYES1 -1 2 -1 Входные данныеСкопировать6 30 01 01 12 12 20 23 2 3Выходные данныеСкопироватьYES1 -1 2 -1 3 -1 Входные данныеСкопировать6 30 01 01 12 12 20 22 2 3Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать4 20 00 22 22 04 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1 -1 2 -1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 30 01 01 12 12 20 23 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1 -1 2 -1 3 -1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 30 01 01 12 12 20 22 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #28 (Codeforces format) - Codeforces",
          "content": "Внимание-внимание!!!Сегодня команда Saratov SU #1 (Gerald, Polichka, Fefer) приглашает всех желающих на  Codeforces Beta Round #28. Олимпиадным программированием мы начали заниматься еще в школе, а потом продолжили в университете. Мы прошли нелегкий путь от команды SU #7 до Saratov SU #1, и теперь стараемся оправдывать этот номер. Мы предлагаем вам 5 занимательных задач. Вам предстоит помочь нескольким хорошим людям разобраться со своими проблемами, решить некоторые задачи администрации, поиграть в интересные игры, а также спасти мир.Спасибо всем, кто помогал нам готовить этот раунд.Желаем всем удачных взломов и быстрых accepted-ов!    UPD: Рейтинги обновленыUPD:ЗадачиРезультатыПобедитель: dzhulgakovРазбор A, B, C, D, E",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/674",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 28 和字母"
          },
          "content_length": 729
        },
        {
          "title": "Codeforces Round 28 - tutorial - Codeforces",
          "content": "A. Bender Problem Solution by Polichka Let's look at the first nail. If it is occupied by the fold place, then Bender will put next fold place on the third nail, then on fifth and so on. Else, is the first nail occupied by end, than second, fourth, sixth and so on nail will be occupied by the fold places. Let's see, if we can complete our polyline with the first nail, occupied by rhe fold place. It means we should check, if we have an unused pod with length dist(nails[n], nails[1]) + dist(nails[1], nails[2]). Then check the third nail and so on. If we have completed the polyline, then we have an answer. Else repeat previous procedure, but starting from the second nail. B. pSort Solution by Polichka Let's consider a graph. Vertexes will correspond to place of the permutation. Places will be connected by an edge if and only if we can swap theirs values. Our problem has a solution when for every i, vertex p[i] can be reached from vertex i. C. Bath Queue Solution by Fefer This problem is solved by dynamic programming Consider the following dynamics: d[i][j][k]. i --- number of not yet processed students, j --- number of not yet processed rooms, k --- maximum queue in the previous rooms. The value we need is in state d[n][m][0]. Let's conside some state (i, j, k) and search through all c from 0 to i. If c students will go to jth room, than a probability of such event consists of factors: Cci --- which students will go to jth room. (1 / j)c· ((j - 1) / j)i - c --- probability, that c students will go to jth room,and the rest of them will go to the rooms from first to j - 1th. Sum for all ñ from 0 to i values of (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx]. Do not forget to update maximum queue value and get the accepted. D. Do not fear, DravDe is kind Solution by RAD Let's split all trucks into different classes by the sum of li + ci + ri. Answer sequence consists of trucks from only one class, so let's solve problem for different classes independently. Let's loop through trucks from fixed class in the order, then follow in the motorcade and update values in dynamics z[k] - maximum profit we can get, if last truck has ri = k. Truck with number i can update two values: it can update value z[ri] with value z[ri + ci] + vi. It means this truck continued some motorcade, started from some previous truck. if li = 0 it can update value z[ri] with vi. It means this truck started motorcade. Answer will be in z[0] To restore the trucks included in the answer, we can keep with the maximal sum in z the index of last truck that updated this sum. Also we store the ancestor p for each truck that updated something in z. This ancestor is calculated when we consider i-th truck and doesn't change further: p[i] = -1 if truck i became beginning of the motorcade, otherwise p[i] = last truck that updated z[ri + ci]. We start restore of the answer from last truck updated z[0]. After that we restore everything using only p. E. DravDe saves the world Solution by Gerald Problem by RAD Let's look at geometrical locus where DravDe can land. It can be eigher an angle or a line(half-line). 1. Locus is an angle if and only if projection of vector v and vector u on Oxy plane is not collinear. This angle is easy to calculate. Angular vertex is DravDe starting point and one of half-lines is collinear with place speed vector projection. Second half-line is easy to calculate: Az + Vz· tv + Uz· tu = 0 Ax + Vx· tv + Ux· tu = Bx Ay + Vy· tv + Uy· tu = By where A - starting point, B - landing point. Consider tv equal to 1 and calculate tu from first equation. From second and third calculate point B. This point lies on the second half-line of the angle. 2. If plane speed projection and wind speed projection is collinear, locus is half-line or line, depending on the difference between this two speeds. If the answer exist, than polygon and locus have at least onecommon point. And t1 and t2 is minimal on edge points. So now let's cross all segments with locus, calculate t1 and t2 for each intersection point and select minimal answer.Thank you for your participation. Good luck with upsolving and incoming contests. Luck - is very useful and it is good to have it. With best regards, Ivan.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/685",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4223
        },
        {
          "title": "Codeforces Beta Round #28 - разбор задачи C - Codeforces",
          "content": "Поначалу каждый из нас выложит разбор своих задач. После соберем их в один пост. C. Очереди к умывальникам Задача решалась с помощью динамического программирования. Рассмотрим такую динамику: d[i][j][k]. i --- количестов еще не обработанных человек, j --- количестов еще не обработанных комнат, k --- максимальная очередь в предведущих комнатах. Наш ответ находиться в состоянии d[n][m][0]. Так же, когда j равно 1, ответ равен максимуму из очереди в последней комнате и наибольшей очереди из предведущих. Теперь рассмотрим какое-то промежуточное состояние. Переберем количество человек, которое пойдет в j-ю комнату. Пусть из i человек пойдет c. Тогда вероятность такого перехода состоит из 2-х сомножителей: Cci --- какие именно студенты пойдут в j-ю комнату. (1 / j)c· ((j - 1) / j)i - c --- вероятность того, что c студентов пойдут в j-ю комнату, а остальные в комнаты с 1-й по (j - 1)-ю. Сумма по всем с от 0 до i значений вида (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx] и даст ответ. Не забудте пересчитать максимум и тогда задача пройдет.Спасибо за участие. Удачи на дорешивании и на предстоящих соревнованиях. Ведь без неё никуда. С уважением, Иван.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/676",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1169
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readEoln();\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-10000, 10000, \"x_i\");\n        inf.readSpace();\n        y[i] = inf.readInt(-10000, 10000, \"y_i\");\n        inf.readEoln();\n    }\n    for (int i = 0; i < n; ++i) {\n        int next = (i + 1) % n;\n        ensuref(x[i] == x[next] || y[i] == y[next], \"Segment %d - %d is not axis-aligned\", i + 1, next + 1);\n    }\n    for (int i = 0; i < n; ++i) {\n        int prev = (i - 1 + n) % n;\n        int next = (i + 1) % n;\n        ensuref(!(x[prev] == x[i] && x[i] == x[next]), \"Three consecutive nails %d, %d, %d lie on a vertical line\", prev + 1, i + 1, next + 1);\n        ensuref(!(y[prev] == y[i] && y[i] == y[next]), \"Three consecutive nails %d, %d, %d lie on a horizontal line\", prev + 1, i + 1, next + 1);\n    }\n    vector<int> rods = inf.readInts(m, 1, 200000, \"rod_lengths\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readEoln();\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-10000, 10000, \"x_i\");\n        inf.readSpace();\n        y[i] = inf.readInt(-10000, 10000, \"y_i\");\n        inf.readEoln();\n    }\n    for (int i = 0; i < n; ++i) {\n        int next = (i + 1) % n;\n        ensuref(x[i] == x[next] || y[i] == y[next], \"Segment %d - %d is not axis-aligned\", i + 1, next + 1);\n    }\n    for (int i = 0; i < n; ++i) {\n        int prev = (i - 1 + n) % n;\n        int next = (i + 1) % n;\n        ensuref(!(x[prev] == x[i] && x[i] == x[next]), \"Three consecutive nails %d, %d, %d lie on a vertical line\", prev + 1, i + 1, next + 1);\n        ensuref(!(y[prev] == y[i] && y[i] == y[next]), \"Three consecutive nails %d, %d, %d lie on a horizontal line\", prev + 1, i + 1, next + 1);\n    }\n    vector<int> rods = inf.readInts(m, 1, 200000, \"rod_lengths\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readEoln();\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-10000, 10000, \"x_i\");\n        inf.readSpace();\n        y[i] = inf.readInt(-10000, 10000, \"y_i\");\n        inf.readEoln();\n    }\n    for (int i = 0; i < n; ++i) {\n        int next = (i + 1) % n;\n        ensuref(x[i] == x[next] || y[i] == y[next], \"Segment %d - %d is not axis-aligned\", i + 1, next + 1);\n    }\n    for (int i = 0; i < n; ++i) {\n        int prev = (i - 1 + n) % n;\n        int next = (i + 1) % n;\n        ensuref(!(x[prev] == x[i] && x[i] == x[next]), \"Three consecutive nails %d, %d, %d lie on a vertical line\", prev + 1, i + 1, next + 1);\n        ensuref(!(y[prev] == y[i] && y[i] == y[next]), \"Three consecutive nails %d, %d, %d lie on a horizontal line\", prev + 1, i + 1, next + 1);\n    }\n    vector<int> rods = inf.readInts(m, 1, 200000, \"rod_lengths\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from the test (inf)\n    int n = inf.readInt();\n    int m = inf.readInt();\n    vector<pair<int,int>> nails(n);\n    for(int i = 0; i < n; i++){\n        int x = inf.readInt();\n        int y = inf.readInt();\n        nails[i] = {x, y};\n    }\n    vector<long long> rods(m);\n    for(int i = 0; i < m; i++){\n        rods[i] = inf.readLong();\n    }\n\n    // Read the jury (official) answer (ans)\n    string juryFirstToken = ans.readToken();\n    bool jurySaysYes = false;\n    if (juryFirstToken == \"YES\") {\n        jurySaysYes = true;\n        // Read the jury's rod assignment, but we do not strictly validate it here.\n        // We trust the jury's solution is consistent with the test data.\n        for(int i = 0; i < n; i++){\n            ans.readInt(-1, m);\n        }\n    }\n    else if (juryFirstToken != \"NO\") {\n        ans.quitf(_fail, \"Jury output must be either YES or NO\");\n    }\n\n    // Read the participant's answer (ouf)\n    string partFirstToken = ouf.readToken();\n    if (jurySaysYes)\n    {\n        // If the jury says YES (there is a solution):\n        if (partFirstToken == \"NO\") {\n            quitf(_wa, \"Participant claims NO, but jury found a solution\");\n        }\n        if (partFirstToken != \"YES\") {\n            ouf.quitf(_wa, \"Participant output must be either YES or NO\");\n        }\n\n        // Now read the participant's rod assignment\n        vector<int> rodsUsed(n);\n        for(int i = 0; i < n; i++){\n            rodsUsed[i] = ouf.readInt(-1, m, (\"rodFoldAtNail#\" + to_string(i+1)).c_str());\n        }\n\n        // A helper to compute Manhattan distance\n        auto distMan = [&](int a, int b){\n            return (long long)abs(nails[a].first - nails[b].first)\n                 + (long long)abs(nails[a].second - nails[b].second);\n        };\n\n        // 1) Check that each rod index is used at most once for folding\n        vector<bool> usedRod(m, false);\n        for(int i = 0; i < n; i++){\n            if (rodsUsed[i] != -1) {\n                int rIdx = rodsUsed[i] - 1; // zero-based\n                if (rIdx < 0 || rIdx >= m)\n                    ouf.quitf(_wa, \"Fold rod index %d out of valid range [1..%d]\", rodsUsed[i], m);\n                if (usedRod[rIdx])\n                    ouf.quitf(_wa, \"Rod %d is folded at more than one nail\", rodsUsed[i]);\n                usedRod[rIdx] = true;\n            }\n        }\n\n        // 2) Check that each edge (i -> i+1 mod n) is covered exactly once\n        //    An edge is covered if it is adjacent to a nail where a rod is folded.\n        for(int i = 0; i < n; i++){\n            int nxt = (i + 1) % n;\n            bool coveredByI = (rodsUsed[i] != -1);\n            bool coveredByNext = (rodsUsed[nxt] != -1);\n\n            if (!coveredByI && !coveredByNext) {\n                ouf.quitf(_wa, \"Edge (%d -> %d) is not covered by any folded rod\", i+1, nxt+1);\n            }\n            if (coveredByI && coveredByNext) {\n                ouf.quitf(_wa, \"Edge (%d -> %d) is covered by two folded rods\", i+1, nxt+1);\n            }\n        }\n\n        // 3) Check rod length correctness: \n        //    If rodsUsed[i] = r != -1, then rods[r-1] must equal\n        //    distance(i, i-1) + distance(i, i+1) (Manhattan distances).\n        for(int i = 0; i < n; i++){\n            if (rodsUsed[i] != -1) {\n                long long needed = distMan(i, (i - 1 + n) % n) + distMan(i, (i + 1) % n);\n                long long actual = rods[rodsUsed[i] - 1];\n                if (needed != actual) {\n                    ouf.quitf(_wa, \n                        \"Rod %d folded at nail %d has length %lld, but needed %lld\",\n                        rodsUsed[i], i+1, actual, needed\n                    );\n                }\n            }\n        }\n\n        quitf(_ok, \"Correct solution\");\n    }\n    else\n    {\n        // Jury says NO\n        if (partFirstToken == \"NO\") {\n            // Both say NO\n            quitf(_ok, \"Both jury and participant say NO\");\n        }\n        else if (partFirstToken == \"YES\") {\n            // Participant found a solution while jury says NO => contradiction with the jury's data\n            quitf(_fail, \"Participant found a solution while jury claims none exists\");\n        }\n        else {\n            ouf.quitf(_wa, \"Participant output must be either YES or NO\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 4 || n > 500 || n % 2 != 0) {\n        cerr << \"Invalid n: \" << n << endl;\n        exit(1);\n    }\n    if (m < 2 || m > 500) {\n        cerr << \"Invalid m: \" << m << endl;\n        exit(1);\n    }\n\n    vector<pair<int,int>> nails(n);\n\n    if (type == \"line\") {\n        // Generate a zig-zag line\n        int x = 0, y = 0;\n        int last_dir = -1; // 0 for x, 1 for y\n        for (int i = 0; i < n - 1; ++i) {\n            int dir = (last_dir == -1) ? rnd.next(2) : 1 - last_dir;\n            int move = rnd.next(1, 1000);\n            int sign = rnd.next(2) ? 1 : -1;\n            if (dir == 0) {\n                x += sign * move;\n            } else {\n                y += sign * move;\n            }\n            nails[i] = {x, y};\n            last_dir = dir;\n        }\n        // Close the polyline\n        // Adjust last point to connect back to first in axis-aligned way\n        int dir = 1 - last_dir;\n        if (dir == 0) {\n            nails[n - 1] = {nails[0].first, y};\n        } else {\n            nails[n -1] = {x, nails[0].second};\n        }\n    } else if (type == \"square\") {\n        // Generate nails forming a square\n        int L = rnd.next(1, 10000);\n        vector<pair<int, int>> points = {{0, 0}, {L, 0}, {L, L}, {0, L}};\n        // Add extra points to reach n\n        int extra_points = n - 4;\n        for (int i = 0; i < extra_points; ++i) {\n            int side = i % 4;\n            int pos = rnd.next(1, L - 1);\n            if (side == 0)\n                points.insert(points.begin() + 1, {pos, 0});\n            else if (side == 1)\n                points.insert(points.begin() + 2, {L, pos});\n            else if (side == 2)\n                points.insert(points.begin() + 3, {L - pos, L});\n            else\n                points.insert(points.begin() + 4, {0, L - pos});\n        }\n        nails = points;\n    } else if (type == \"maxn\") {\n        // Generate maximum n\n        n = 500;\n        nails[0] = {0, 0};\n        int x = 0, y = 0;\n        int last_dir = -1; // 0 for x, 1 for y\n        for (int i = 1; i < n; ++i) {\n            int dir = (last_dir == -1) ? rnd.next(2) : 1 - last_dir;\n            int move = rnd.next(1, 1000);\n            int sign = rnd.next(2) ? 1 : -1;\n            if (dir == 0) {\n                x += sign * move;\n            } else {\n                y += sign * move;\n            }\n            nails[i] = {x, y};\n            last_dir = dir;\n        }\n    } else if (type == \"maxm\") {\n        // m at maximum\n        m = 500;\n        // Generate random nails\n        nails[0] = {0, 0};\n        int x = 0, y = 0;\n        int last_dir = -1;\n        for (int i = 1; i < n; ++i) {\n            int dir = (last_dir == -1) ? rnd.next(2) : 1 - last_dir;\n            int move = rnd.next(1, 1000);\n            if (dir == 0) {\n                x += move;\n            } else {\n                y += move;\n            }\n            nails[i] = {x, y};\n            last_dir = dir;\n        }\n    } else if (type == \"impossible\") {\n        // Generate an impossible case (though we cannot guarantee it's impossible)\n        nails[0] = {0, 0};\n        for (int i = 1; i < n; ++i) {\n            nails[i] = {0, i};\n        }\n    } else { // random or other types\n        // Generate random nails\n        nails[0] = {0, 0};\n        int x = 0, y = 0;\n        int last_dir = -1; // 0 for x, 1 for y\n        for (int i = 1; i < n - 1; ++i) {\n            int dir = (last_dir == -1) ? rnd.next(2) : 1 - last_dir;\n            int move = rnd.next(1, 1000);\n            int sign = rnd.next(2) ? 1 : -1;\n            if (dir == 0) {\n                x += sign * move;\n            } else {\n                y += sign * move;\n            }\n            nails[i] = {x, y};\n            last_dir = dir;\n        }\n        // Close the polyline\n        int dir = 1 - last_dir;\n        if (dir == 0) {\n            nails[n - 1] = {nails[0].first, y};\n        } else {\n            nails[n -1] = {x, nails[0].second};\n        }\n    }\n\n    // Now generate m rod lengths\n    vector<int> rods(m);\n    for (int i = 0; i < m; ++i) {\n        rods[i] = rnd.next(1, 200000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", nails[i].first, nails[i].second);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", rods[i], i + 1 == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 4 || n > 500 || n % 2 != 0) {\n        cerr << \"Invalid n: \" << n << endl;\n        exit(1);\n    }\n    if (m < 2 || m > 500) {\n        cerr << \"Invalid m: \" << m << endl;\n        exit(1);\n    }\n\n    vector<pair<int,int>> nails(n);\n\n    if (type == \"line\") {\n        // Generate a zig-zag line\n        int x = 0, y = 0;\n        int last_dir = -1; // 0 for x, 1 for y\n        for (int i = 0; i < n - 1; ++i) {\n            int dir = (last_dir == -1) ? rnd.next(2) : 1 - last_dir;\n            int move = rnd.next(1, 1000);\n            int sign = rnd.next(2) ? 1 : -1;\n            if (dir == 0) {\n                x += sign * move;\n            } else {\n                y += sign * move;\n            }\n            nails[i] = {x, y};\n            last_dir = dir;\n        }\n        // Close the polyline\n        // Adjust last point to connect back to first in axis-aligned way\n        int dir = 1 - last_dir;\n        if (dir == 0) {\n            nails[n - 1] = {nails[0].first, y};\n        } else {\n            nails[n -1] = {x, nails[0].second};\n        }\n    } else if (type == \"square\") {\n        // Generate nails forming a square\n        int L = rnd.next(1, 10000);\n        vector<pair<int, int>> points = {{0, 0}, {L, 0}, {L, L}, {0, L}};\n        // Add extra points to reach n\n        int extra_points = n - 4;\n        for (int i = 0; i < extra_points; ++i) {\n            int side = i % 4;\n            int pos = rnd.next(1, L - 1);\n            if (side == 0)\n                points.insert(points.begin() + 1, {pos, 0});\n            else if (side == 1)\n                points.insert(points.begin() + 2, {L, pos});\n            else if (side == 2)\n                points.insert(points.begin() + 3, {L - pos, L});\n            else\n                points.insert(points.begin() + 4, {0, L - pos});\n        }\n        nails = points;\n    } else if (type == \"maxn\") {\n        // Generate maximum n\n        n = 500;\n        nails[0] = {0, 0};\n        int x = 0, y = 0;\n        int last_dir = -1; // 0 for x, 1 for y\n        for (int i = 1; i < n; ++i) {\n            int dir = (last_dir == -1) ? rnd.next(2) : 1 - last_dir;\n            int move = rnd.next(1, 1000);\n            int sign = rnd.next(2) ? 1 : -1;\n            if (dir == 0) {\n                x += sign * move;\n            } else {\n                y += sign * move;\n            }\n            nails[i] = {x, y};\n            last_dir = dir;\n        }\n    } else if (type == \"maxm\") {\n        // m at maximum\n        m = 500;\n        // Generate random nails\n        nails[0] = {0, 0};\n        int x = 0, y = 0;\n        int last_dir = -1;\n        for (int i = 1; i < n; ++i) {\n            int dir = (last_dir == -1) ? rnd.next(2) : 1 - last_dir;\n            int move = rnd.next(1, 1000);\n            if (dir == 0) {\n                x += move;\n            } else {\n                y += move;\n            }\n            nails[i] = {x, y};\n            last_dir = dir;\n        }\n    } else if (type == \"impossible\") {\n        // Generate an impossible case (though we cannot guarantee it's impossible)\n        nails[0] = {0, 0};\n        for (int i = 1; i < n; ++i) {\n            nails[i] = {0, i};\n        }\n    } else { // random or other types\n        // Generate random nails\n        nails[0] = {0, 0};\n        int x = 0, y = 0;\n        int last_dir = -1; // 0 for x, 1 for y\n        for (int i = 1; i < n - 1; ++i) {\n            int dir = (last_dir == -1) ? rnd.next(2) : 1 - last_dir;\n            int move = rnd.next(1, 1000);\n            int sign = rnd.next(2) ? 1 : -1;\n            if (dir == 0) {\n                x += sign * move;\n            } else {\n                y += sign * move;\n            }\n            nails[i] = {x, y};\n            last_dir = dir;\n        }\n        // Close the polyline\n        int dir = 1 - last_dir;\n        if (dir == 0) {\n            nails[n - 1] = {nails[0].first, y};\n        } else {\n            nails[n -1] = {x, nails[0].second};\n        }\n    }\n\n    // Now generate m rod lengths\n    vector<int> rods(m);\n    for (int i = 0; i < m; ++i) {\n        rods[i] = rnd.next(1, 200000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", nails[i].first, nails[i].second);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", rods[i], i + 1 == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m, line type\n./gen -n 4 -m 2 -type line\n./gen -n 6 -m 3 -type line\n\n# Square type, small n\n./gen -n 8 -m 4 -type square\n\n# Random type\n./gen -n 10 -m 5 -type random\n\n# Maximum n and m\n./gen -n 500 -m 500 -type maxn\n\n# Maximum m, small n\n./gen -n 4 -m 500 -type maxm\n\n# Random type with maximum n\n./gen -n 500 -m 10 -type random\n\n# Possible impossible case\n./gen -n 6 -m 2 -type impossible\n\n# Additional cases with line type\n./gen -n 50 -m 25 -type line\n./gen -n 100 -m 50 -type line\n\n# Additional cases with square type\n./gen -n 12 -m 6 -type square\n./gen -n 16 -m 8 -type square\n\n# Random type with various n and m\n./gen -n 100 -m 100 -type random\n./gen -n 200 -m 100 -type random\n./gen -n 300 -m 150 -type random\n./gen -n 400 -m 200 -type random\n\n# Edge cases with minimal n and m\n./gen -n 4 -m 2 -type random\n./gen -n 4 -m 2 -type line\n\n# Edge cases with maximum n and minimal m\n./gen -n 500 -m 2 -type random\n./gen -n 500 -m 2 -type line\n\n# Random tests with maximal rod lengths\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 50 -type random\n\n# Random tests with minimal rod lengths\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 50 -type random\n\n# Multiple random tests\n./gen -n 150 -m 75 -type random\n./gen -n 200 -m 100 -type random\n./gen -n 250 -m 125 -type random\n./gen -n 300 -m 150 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:14.248867",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "28/B",
      "title": "B. pSort",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке дано натуральное число n (1 ≤ n ≤ 100) — количество ячеек в массиве. Во второй строке задано n различных целых чисел от 1 до n — заданная перестановка. В третьей строке задано n целых чисел от 1 до n — любимые числа ячеек.",
      "output_spec": "Выходные данныеЕсли игра могла зайти в заданное положение выведите YES, иначе выведите NO.",
      "sample_tests": "ПримерыВходные данныеСкопировать55 4 3 2 11 1 1 1 1Выходные данныеСкопироватьYESВходные данныеСкопировать74 3 5 1 2 7 64 6 6 1 6 6 1Выходные данныеСкопироватьNOВходные данныеСкопировать74 2 5 1 3 7 64 6 6 1 6 6 1Выходные данныеСкопироватьYES",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке дано натуральное число n (1 ≤ n ≤ 100) — количество ячеек в массиве. Во второй строке задано n различных целых чисел от 1 до n — заданная перестановка. В третьей строке задано n целых чисел от 1 до n — любимые числа ячеек.\n\nВходные данные\n\nВыходные данныеЕсли игра могла зайти в заданное положение выведите YES, иначе выведите NO.\n\nВыходные данные\n\nВходные данныеСкопировать55 4 3 2 11 1 1 1 1Выходные данныеСкопироватьYESВходные данныеСкопировать74 3 5 1 2 7 64 6 6 1 6 6 1Выходные данныеСкопироватьNOВходные данныеСкопировать74 2 5 1 3 7 64 6 6 1 6 6 1Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать55 4 3 2 11 1 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать74 3 5 1 2 7 64 6 6 1 6 6 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать74 2 5 1 3 7 64 6 6 1 6 6 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #28 (Codeforces format) - Codeforces",
          "content": "Внимание-внимание!!!Сегодня команда Saratov SU #1 (Gerald, Polichka, Fefer) приглашает всех желающих на  Codeforces Beta Round #28. Олимпиадным программированием мы начали заниматься еще в школе, а потом продолжили в университете. Мы прошли нелегкий путь от команды SU #7 до Saratov SU #1, и теперь стараемся оправдывать этот номер. Мы предлагаем вам 5 занимательных задач. Вам предстоит помочь нескольким хорошим людям разобраться со своими проблемами, решить некоторые задачи администрации, поиграть в интересные игры, а также спасти мир.Спасибо всем, кто помогал нам готовить этот раунд.Желаем всем удачных взломов и быстрых accepted-ов!    UPD: Рейтинги обновленыUPD:ЗадачиРезультатыПобедитель: dzhulgakovРазбор A, B, C, D, E",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/674",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 28 和字母"
          },
          "content_length": 729
        },
        {
          "title": "Codeforces Round 28 - tutorial - Codeforces",
          "content": "A. Bender Problem Solution by Polichka Let's look at the first nail. If it is occupied by the fold place, then Bender will put next fold place on the third nail, then on fifth and so on. Else, is the first nail occupied by end, than second, fourth, sixth and so on nail will be occupied by the fold places. Let's see, if we can complete our polyline with the first nail, occupied by rhe fold place. It means we should check, if we have an unused pod with length dist(nails[n], nails[1]) + dist(nails[1], nails[2]). Then check the third nail and so on. If we have completed the polyline, then we have an answer. Else repeat previous procedure, but starting from the second nail. B. pSort Solution by Polichka Let's consider a graph. Vertexes will correspond to place of the permutation. Places will be connected by an edge if and only if we can swap theirs values. Our problem has a solution when for every i, vertex p[i] can be reached from vertex i. C. Bath Queue Solution by Fefer This problem is solved by dynamic programming Consider the following dynamics: d[i][j][k]. i --- number of not yet processed students, j --- number of not yet processed rooms, k --- maximum queue in the previous rooms. The value we need is in state d[n][m][0]. Let's conside some state (i, j, k) and search through all c from 0 to i. If c students will go to jth room, than a probability of such event consists of factors: Cci --- which students will go to jth room. (1 / j)c· ((j - 1) / j)i - c --- probability, that c students will go to jth room,and the rest of them will go to the rooms from first to j - 1th. Sum for all ñ from 0 to i values of (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx]. Do not forget to update maximum queue value and get the accepted. D. Do not fear, DravDe is kind Solution by RAD Let's split all trucks into different classes by the sum of li + ci + ri. Answer sequence consists of trucks from only one class, so let's solve problem for different classes independently. Let's loop through trucks from fixed class in the order, then follow in the motorcade and update values in dynamics z[k] - maximum profit we can get, if last truck has ri = k. Truck with number i can update two values: it can update value z[ri] with value z[ri + ci] + vi. It means this truck continued some motorcade, started from some previous truck. if li = 0 it can update value z[ri] with vi. It means this truck started motorcade. Answer will be in z[0] To restore the trucks included in the answer, we can keep with the maximal sum in z the index of last truck that updated this sum. Also we store the ancestor p for each truck that updated something in z. This ancestor is calculated when we consider i-th truck and doesn't change further: p[i] = -1 if truck i became beginning of the motorcade, otherwise p[i] = last truck that updated z[ri + ci]. We start restore of the answer from last truck updated z[0]. After that we restore everything using only p. E. DravDe saves the world Solution by Gerald Problem by RAD Let's look at geometrical locus where DravDe can land. It can be eigher an angle or a line(half-line). 1. Locus is an angle if and only if projection of vector v and vector u on Oxy plane is not collinear. This angle is easy to calculate. Angular vertex is DravDe starting point and one of half-lines is collinear with place speed vector projection. Second half-line is easy to calculate: Az + Vz· tv + Uz· tu = 0 Ax + Vx· tv + Ux· tu = Bx Ay + Vy· tv + Uy· tu = By where A - starting point, B - landing point. Consider tv equal to 1 and calculate tu from first equation. From second and third calculate point B. This point lies on the second half-line of the angle. 2. If plane speed projection and wind speed projection is collinear, locus is half-line or line, depending on the difference between this two speeds. If the answer exist, than polygon and locus have at least onecommon point. And t1 and t2 is minimal on edge points. So now let's cross all segments with locus, calculate t1 and t2 for each intersection point and select minimal answer.Thank you for your participation. Good luck with upsolving and incoming contests. Luck - is very useful and it is good to have it. With best regards, Ivan.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/685",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4223
        },
        {
          "title": "Codeforces Beta Round #28 - разбор задачи C - Codeforces",
          "content": "Поначалу каждый из нас выложит разбор своих задач. После соберем их в один пост. C. Очереди к умывальникам Задача решалась с помощью динамического программирования. Рассмотрим такую динамику: d[i][j][k]. i --- количестов еще не обработанных человек, j --- количестов еще не обработанных комнат, k --- максимальная очередь в предведущих комнатах. Наш ответ находиться в состоянии d[n][m][0]. Так же, когда j равно 1, ответ равен максимуму из очереди в последней комнате и наибольшей очереди из предведущих. Теперь рассмотрим какое-то промежуточное состояние. Переберем количество человек, которое пойдет в j-ю комнату. Пусть из i человек пойдет c. Тогда вероятность такого перехода состоит из 2-х сомножителей: Cci --- какие именно студенты пойдут в j-ю комнату. (1 / j)c· ((j - 1) / j)i - c --- вероятность того, что c студентов пойдут в j-ю комнату, а остальные в комнаты с 1-й по (j - 1)-ю. Сумма по всем с от 0 до i значений вида (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx] и даст ответ. Не забудте пересчитать максимум и тогда задача пройдет.Спасибо за участие. Удачи на дорешивании и на предстоящих соревнованиях. Ведь без неё никуда. С уважением, Иван.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/676",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1169
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\"); // read n\n    inf.readEoln();\n    \n    // Read the permutation\n    vector<int> perm = inf.readInts(n, 1, n, \"perm\");\n    inf.readEoln();\n    \n    // Check that perm is a permutation of 1..n\n    vector<int> check_perm = perm;\n    sort(check_perm.begin(), check_perm.end());\n    for(int i = 0; i < n; ++i) {\n        ensuref(check_perm[i] == i+1, \"Permutation must contain numbers from 1 to n. At position %d, expected %d, found %d\", i+1, i+1, check_perm[i]);\n    }\n    \n    // Read the favorite numbers\n    vector<int> fav = inf.readInts(n, 1, n, \"fav\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\"); // read n\n    inf.readEoln();\n    \n    // Read the permutation\n    vector<int> perm = inf.readInts(n, 1, n, \"perm\");\n    inf.readEoln();\n    \n    // Check that perm is a permutation of 1..n\n    vector<int> check_perm = perm;\n    sort(check_perm.begin(), check_perm.end());\n    for(int i = 0; i < n; ++i) {\n        ensuref(check_perm[i] == i+1, \"Permutation must contain numbers from 1 to n. At position %d, expected %d, found %d\", i+1, i+1, check_perm[i]);\n    }\n    \n    // Read the favorite numbers\n    vector<int> fav = inf.readInts(n, 1, n, \"fav\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\"); // read n\n    inf.readEoln();\n    \n    // Read the permutation\n    vector<int> perm = inf.readInts(n, 1, n, \"perm\");\n    inf.readEoln();\n    \n    // Check that perm is a permutation of 1..n\n    vector<int> check_perm = perm;\n    sort(check_perm.begin(), check_perm.end());\n    for(int i = 0; i < n; ++i) {\n        ensuref(check_perm[i] == i+1, \"Permutation must contain numbers from 1 to n. At position %d, expected %d, found %d\", i+1, i+1, check_perm[i]);\n    }\n    \n    // Read the favorite numbers\n    vector<int> fav = inf.readInts(n, 1, n, \"fav\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string perm_type = opt<string>(\"perm_type\", \"random\"); // options: identity, reversed, random\n    string fav_type = opt<string>(\"fav_type\", \"random\");   // options: ones, max, random, none\n\n    vector<int> perm(n);\n\n    if (perm_type == \"identity\") {\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n    } else if (perm_type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            perm[i] = n - i;\n    } else if (perm_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n    } else {\n        cerr << \"Unknown perm_type: \" << perm_type << endl;\n        return 1;\n    }\n\n    vector<int> fav(n);\n    \n    if (fav_type == \"ones\") {\n        for (int i = 0; i < n; ++i)\n            fav[i] = 1;\n    } else if (fav_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            fav[i] = n - 1;\n    } else if (fav_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            fav[i] = rnd.next(1, n - 1);\n    } else if (fav_type == \"none\") {\n        for (int i = 0; i < n; ++i)\n            fav[i] = n;\n    } else {\n        cerr << \"Unknown fav_type: \" << fav_type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", perm[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", fav[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string perm_type = opt<string>(\"perm_type\", \"random\"); // options: identity, reversed, random\n    string fav_type = opt<string>(\"fav_type\", \"random\");   // options: ones, max, random, none\n\n    vector<int> perm(n);\n\n    if (perm_type == \"identity\") {\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n    } else if (perm_type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            perm[i] = n - i;\n    } else if (perm_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n    } else {\n        cerr << \"Unknown perm_type: \" << perm_type << endl;\n        return 1;\n    }\n\n    vector<int> fav(n);\n    \n    if (fav_type == \"ones\") {\n        for (int i = 0; i < n; ++i)\n            fav[i] = 1;\n    } else if (fav_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            fav[i] = n - 1;\n    } else if (fav_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            fav[i] = rnd.next(1, n - 1);\n    } else if (fav_type == \"none\") {\n        for (int i = 0; i < n; ++i)\n            fav[i] = n;\n    } else {\n        cerr << \"Unknown fav_type: \" << fav_type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", perm[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", fav[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -perm_type identity -fav_type ones\n\n./gen -n 2 -perm_type identity -fav_type ones\n./gen -n 2 -perm_type reversed -fav_type ones\n./gen -n 2 -perm_type random -fav_type random\n\n./gen -n 5 -perm_type identity -fav_type ones\n./gen -n 5 -perm_type reversed -fav_type ones\n./gen -n 5 -perm_type random -fav_type ones\n./gen -n 5 -perm_type random -fav_type random\n./gen -n 5 -perm_type random -fav_type max\n\n./gen -n 10 -perm_type identity -fav_type ones\n./gen -n 10 -perm_type reversed -fav_type ones\n./gen -n 10 -perm_type random -fav_type ones\n./gen -n 10 -perm_type random -fav_type random\n./gen -n 10 -perm_type random -fav_type max\n\n./gen -n 20 -perm_type identity -fav_type ones\n./gen -n 20 -perm_type reversed -fav_type ones\n./gen -n 20 -perm_type random -fav_type ones\n./gen -n 20 -perm_type random -fav_type random\n./gen -n 20 -perm_type random -fav_type max\n\n./gen -n 50 -perm_type identity -fav_type ones\n./gen -n 50 -perm_type reversed -fav_type ones\n./gen -n 50 -perm_type random -fav_type ones\n./gen -n 50 -perm_type random -fav_type random\n./gen -n 50 -perm_type random -fav_type max\n\n./gen -n 100 -perm_type identity -fav_type ones\n./gen -n 100 -perm_type reversed -fav_type ones\n./gen -n 100 -perm_type random -fav_type ones\n./gen -n 100 -perm_type random -fav_type random\n./gen -n 100 -perm_type random -fav_type max\n./gen -n 100 -perm_type identity -fav_type none\n./gen -n 100 -perm_type random -fav_type none\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:16.305411",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "28/C",
      "title": "C. Очереди к умывальникам",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке заданы два целых положительных числа n и m (1 ≤ n, m ≤ 50) — количество студентов и комнат с умывальниками соответственно. Во второй строке задано m чисел: a1, a2, ... , am (1 ≤ ai ≤ 50). i-ое число означает количество умывальников в i-ой комнате.",
      "output_spec": "Выходные данныеВыведите единственное число: математическое ожидание длины максимальной очереди. Ваш ответ должен иметь относительную или абсолютную погрешность меньше чем 10 - 9.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 12Выходные данныеСкопировать1.00000000000000000000Входные данныеСкопировать2 21 1Выходные данныеСкопировать1.50000000000000000000Входные данныеСкопировать2 31 1 1Выходные данныеСкопировать1.33333333333333350000Входные данныеСкопировать7 51 1 2 3 1Выходные данныеСкопировать2.50216960000000070000",
      "description": "C. Очереди к умывальникам\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы два целых положительных числа n и m (1 ≤ n, m ≤ 50) — количество студентов и комнат с умывальниками соответственно. Во второй строке задано m чисел: a1, a2, ... , am (1 ≤ ai ≤ 50). i-ое число означает количество умывальников в i-ой комнате.\n\nВходные данные\n\nВыходные данныеВыведите единственное число: математическое ожидание длины максимальной очереди. Ваш ответ должен иметь относительную или абсолютную погрешность меньше чем 10 - 9.\n\nВыходные данные\n\nВходные данныеСкопировать1 12Выходные данныеСкопировать1.00000000000000000000Входные данныеСкопировать2 21 1Выходные данныеСкопировать1.50000000000000000000Входные данныеСкопировать2 31 1 1Выходные данныеСкопировать1.33333333333333350000Входные данныеСкопировать7 51 1 2 3 1Выходные данныеСкопировать2.50216960000000070000\n\nВходные данныеСкопировать1 12\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.00000000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 21 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.50000000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 31 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.33333333333333350000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 51 1 2 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.50216960000000070000\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #28 (Codeforces format) - Codeforces",
          "content": "Внимание-внимание!!!Сегодня команда Saratov SU #1 (Gerald, Polichka, Fefer) приглашает всех желающих на  Codeforces Beta Round #28. Олимпиадным программированием мы начали заниматься еще в школе, а потом продолжили в университете. Мы прошли нелегкий путь от команды SU #7 до Saratov SU #1, и теперь стараемся оправдывать этот номер. Мы предлагаем вам 5 занимательных задач. Вам предстоит помочь нескольким хорошим людям разобраться со своими проблемами, решить некоторые задачи администрации, поиграть в интересные игры, а также спасти мир.Спасибо всем, кто помогал нам готовить этот раунд.Желаем всем удачных взломов и быстрых accepted-ов!    UPD: Рейтинги обновленыUPD:ЗадачиРезультатыПобедитель: dzhulgakovРазбор A, B, C, D, E",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/674",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 28 和字母"
          },
          "content_length": 729
        },
        {
          "title": "Codeforces Round 28 - tutorial - Codeforces",
          "content": "A. Bender Problem Solution by Polichka Let's look at the first nail. If it is occupied by the fold place, then Bender will put next fold place on the third nail, then on fifth and so on. Else, is the first nail occupied by end, than second, fourth, sixth and so on nail will be occupied by the fold places. Let's see, if we can complete our polyline with the first nail, occupied by rhe fold place. It means we should check, if we have an unused pod with length dist(nails[n], nails[1]) + dist(nails[1], nails[2]). Then check the third nail and so on. If we have completed the polyline, then we have an answer. Else repeat previous procedure, but starting from the second nail. B. pSort Solution by Polichka Let's consider a graph. Vertexes will correspond to place of the permutation. Places will be connected by an edge if and only if we can swap theirs values. Our problem has a solution when for every i, vertex p[i] can be reached from vertex i. C. Bath Queue Solution by Fefer This problem is solved by dynamic programming Consider the following dynamics: d[i][j][k]. i --- number of not yet processed students, j --- number of not yet processed rooms, k --- maximum queue in the previous rooms. The value we need is in state d[n][m][0]. Let's conside some state (i, j, k) and search through all c from 0 to i. If c students will go to jth room, than a probability of such event consists of factors: Cci --- which students will go to jth room. (1 / j)c· ((j - 1) / j)i - c --- probability, that c students will go to jth room,and the rest of them will go to the rooms from first to j - 1th. Sum for all ñ from 0 to i values of (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx]. Do not forget to update maximum queue value and get the accepted. D. Do not fear, DravDe is kind Solution by RAD Let's split all trucks into different classes by the sum of li + ci + ri. Answer sequence consists of trucks from only one class, so let's solve problem for different classes independently. Let's loop through trucks from fixed class in the order, then follow in the motorcade and update values in dynamics z[k] - maximum profit we can get, if last truck has ri = k. Truck with number i can update two values: it can update value z[ri] with value z[ri + ci] + vi. It means this truck continued some motorcade, started from some previous truck. if li = 0 it can update value z[ri] with vi. It means this truck started motorcade. Answer will be in z[0] To restore the trucks included in the answer, we can keep with the maximal sum in z the index of last truck that updated this sum. Also we store the ancestor p for each truck that updated something in z. This ancestor is calculated when we consider i-th truck and doesn't change further: p[i] = -1 if truck i became beginning of the motorcade, otherwise p[i] = last truck that updated z[ri + ci]. We start restore of the answer from last truck updated z[0]. After that we restore everything using only p. E. DravDe saves the world Solution by Gerald Problem by RAD Let's look at geometrical locus where DravDe can land. It can be eigher an angle or a line(half-line). 1. Locus is an angle if and only if projection of vector v and vector u on Oxy plane is not collinear. This angle is easy to calculate. Angular vertex is DravDe starting point and one of half-lines is collinear with place speed vector projection. Second half-line is easy to calculate: Az + Vz· tv + Uz· tu = 0 Ax + Vx· tv + Ux· tu = Bx Ay + Vy· tv + Uy· tu = By where A - starting point, B - landing point. Consider tv equal to 1 and calculate tu from first equation. From second and third calculate point B. This point lies on the second half-line of the angle. 2. If plane speed projection and wind speed projection is collinear, locus is half-line or line, depending on the difference between this two speeds. If the answer exist, than polygon and locus have at least onecommon point. And t1 and t2 is minimal on edge points. So now let's cross all segments with locus, calculate t1 and t2 for each intersection point and select minimal answer.Thank you for your participation. Good luck with upsolving and incoming contests. Luck - is very useful and it is good to have it. With best regards, Ivan.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/685",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4223
        },
        {
          "title": "Codeforces Beta Round #28 - разбор задачи C - Codeforces",
          "content": "Поначалу каждый из нас выложит разбор своих задач. После соберем их в один пост. C. Очереди к умывальникам Задача решалась с помощью динамического программирования. Рассмотрим такую динамику: d[i][j][k]. i --- количестов еще не обработанных человек, j --- количестов еще не обработанных комнат, k --- максимальная очередь в предведущих комнатах. Наш ответ находиться в состоянии d[n][m][0]. Так же, когда j равно 1, ответ равен максимуму из очереди в последней комнате и наибольшей очереди из предведущих. Теперь рассмотрим какое-то промежуточное состояние. Переберем количество человек, которое пойдет в j-ю комнату. Пусть из i человек пойдет c. Тогда вероятность такого перехода состоит из 2-х сомножителей: Cci --- какие именно студенты пойдут в j-ю комнату. (1 / j)c· ((j - 1) / j)i - c --- вероятность того, что c студентов пойдут в j-ю комнату, а остальные в комнаты с 1-й по (j - 1)-ю. Сумма по всем с от 0 до i значений вида (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx] и даст ответ. Не забудте пересчитать максимум и тогда задача пройдет.Спасибо за участие. Удачи на дорешивании и на предстоящих соревнованиях. Ведь без неё никуда. С уважением, Иван.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/676",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1169
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 1, 50, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 1, 50, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 1, 50, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // default -1 means not specified\n\n    vector<int> a(m);\n    \n    if (type == \"random\") {\n        // ai's are random integers between 1 and 50\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, 50);\n        }\n    } else if (type == \"uniform\") {\n        // ai's are all equal to k\n        if (k == -1) k = 1; // default k=1 if not specified\n        for (int i = 0; i < m; ++i) {\n            a[i] = k;\n        }\n    } else if (type == \"maxai\") {\n        // ai's are maximum (50)\n        for (int i = 0; i < m; ++i) {\n            a[i] = 50;\n        }\n    } else if (type == \"minai\") {\n        // ai's are minimum (1)\n        for (int i = 0; i < m; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"skewed\") {\n        // First room has ai=50, others have ai=1\n        a[0] = 50;\n        for (int i = 1; i < m; ++i) {\n            a[i] = 1;\n        }\n    } else {\n        // Handle error\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output ai's\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", a[i], i == m-1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // default -1 means not specified\n\n    vector<int> a(m);\n    \n    if (type == \"random\") {\n        // ai's are random integers between 1 and 50\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, 50);\n        }\n    } else if (type == \"uniform\") {\n        // ai's are all equal to k\n        if (k == -1) k = 1; // default k=1 if not specified\n        for (int i = 0; i < m; ++i) {\n            a[i] = k;\n        }\n    } else if (type == \"maxai\") {\n        // ai's are maximum (50)\n        for (int i = 0; i < m; ++i) {\n            a[i] = 50;\n        }\n    } else if (type == \"minai\") {\n        // ai's are minimum (1)\n        for (int i = 0; i < m; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"skewed\") {\n        // First room has ai=50, others have ai=1\n        a[0] = 50;\n        for (int i = 1; i < m; ++i) {\n            a[i] = 1;\n        }\n    } else {\n        // Handle error\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output ai's\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", a[i], i == m-1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type minai\n./gen -n 1 -m 1 -type maxai\n\n./gen -n 1 -m 50 -type minai\n./gen -n 1 -m 50 -type maxai\n\n./gen -n 50 -m 1 -type minai\n./gen -n 50 -m 1 -type maxai\n\n./gen -n 50 -m 50 -type minai\n./gen -n 50 -m 50 -type maxai\n\n./gen -n 25 -m 25 -type random\n./gen -n 10 -m 5 -type random\n\n./gen -n 10 -m 5 -type uniform -k 5\n./gen -n 20 -m 10 -type uniform -k 10\n\n./gen -n 50 -m 10 -type skewed\n./gen -n 30 -m 10 -type skewed\n./gen -n 20 -m 5 -type skewed\n\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 15 -m 10 -type random\n./gen -n 30 -m 25 -type random\n./gen -n 25 -m 15 -type random\n\n./gen -n 50 -m 20 -type skewed\n./gen -n 20 -m 50 -type skewed\n\n./gen -n 50 -m 50 -type minai\n./gen -n 25 -m 25 -type minai\n./gen -n 30 -m 30 -type maxai\n./gen -n 10 -m 50 -type random\n./gen -n 50 -m 10 -type random\n\n./gen -n 49 -m 49 -type uniform -k 49\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:18.645050",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "28/D",
      "title": "D. Don't fear, DravDe is kind",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer number n (1 ≤ n ≤ 105) — amount of trucks in the motorcade. The following n lines contain four integers each. Numbers in the i-th line: vi, ci, li, ri (1 ≤ vi ≤ 104, 1 ≤ ci ≤ 105, 0 ≤ li, ri ≤ 105) — describe the i-th truck. The trucks are numbered from 1, counting from the front of the motorcade.",
      "output_spec": "OutputIn the first line output number k — amount of trucks that will drive into the tunnel. In the second line output k numbers — indexes of these trucks in ascending order. Don't forget please that you are not allowed to change the order of trucks. If the answer is not unique, output any.",
      "sample_tests": "ExamplesInputCopy51 1 0 31 1 1 21 1 2 11 1 3 02 1 3 0OutputCopy41 2 3 5 InputCopy51 1 0 310 1 2 12 2 1 110 1 1 23 1 3 0OutputCopy31 3 5",
      "description": "D. Don't fear, DravDe is kind\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer number n (1 ≤ n ≤ 105) — amount of trucks in the motorcade. The following n lines contain four integers each. Numbers in the i-th line: vi, ci, li, ri (1 ≤ vi ≤ 104, 1 ≤ ci ≤ 105, 0 ≤ li, ri ≤ 105) — describe the i-th truck. The trucks are numbered from 1, counting from the front of the motorcade.\n\nOutputIn the first line output number k — amount of trucks that will drive into the tunnel. In the second line output k numbers — indexes of these trucks in ascending order. Don't forget please that you are not allowed to change the order of trucks. If the answer is not unique, output any.\n\nInputCopy51 1 0 31 1 1 21 1 2 11 1 3 02 1 3 0OutputCopy41 2 3 5 InputCopy51 1 0 310 1 2 12 2 1 110 1 1 23 1 3 0OutputCopy31 3 5\n\nInputCopy51 1 0 31 1 1 21 1 2 11 1 3 02 1 3 0\n\nOutputCopy41 2 3 5\n\nInputCopy51 1 0 310 1 2 12 2 1 110 1 1 23 1 3 0\n\nOutputCopy31 3 5",
      "solutions": [
        {
          "title": "Codeforces Beta Round #28 (Codeforces format) - Codeforces",
          "content": "Attention-Attention!!!Today Saratov SU #1 (Gerald, Polichka, Fefer) team invites all of you to take part in Codeforces Beta Round #28. We began studing sport-programming in school. But when we entered the Saratov State University we took it seriously and made our way from SU #7 to Saratov SU #1. Now our first-grade ambition is to justify this number.We are going to offer you 5 interesting problems. You will be helping some good people to deal with their problems, will be solving some administrative tasks, will be playing some interesting games and also will be saving the World.Thanks to everyone for their help in preparing this round. Successful hacks and fast accepteds!With best regards, Saratov SU #1.UPD: Ratings have been updated.UPD:ProblemsStandingsWinner: dzhulgakovTutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/674",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 28"
          },
          "content_length": 790
        },
        {
          "title": "Codeforces Round 28 - tutorial - Codeforces",
          "content": "A. Bender Problem Solution by Polichka Let's look at the first nail. If it is occupied by the fold place, then Bender will put next fold place on the third nail, then on fifth and so on. Else, is the first nail occupied by end, than second, fourth, sixth and so on nail will be occupied by the fold places. Let's see, if we can complete our polyline with the first nail, occupied by rhe fold place. It means we should check, if we have an unused pod with length dist(nails[n], nails[1]) + dist(nails[1], nails[2]). Then check the third nail and so on. If we have completed the polyline, then we have an answer. Else repeat previous procedure, but starting from the second nail. B. pSort Solution by Polichka Let's consider a graph. Vertexes will correspond to place of the permutation. Places will be connected by an edge if and only if we can swap theirs values. Our problem has a solution when for every i, vertex p[i] can be reached from vertex i. C. Bath Queue Solution by Fefer This problem is solved by dynamic programming Consider the following dynamics: d[i][j][k]. i --- number of not yet processed students, j --- number of not yet processed rooms, k --- maximum queue in the previous rooms. The value we need is in state d[n][m][0]. Let's conside some state (i, j, k) and search through all c from 0 to i. If c students will go to jth room, than a probability of such event consists of factors: Cci --- which students will go to jth room. (1 / j)c· ((j - 1) / j)i - c --- probability, that c students will go to jth room,and the rest of them will go to the rooms from first to j - 1th. Sum for all ñ from 0 to i values of (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx]. Do not forget to update maximum queue value and get the accepted. D. Do not fear, DravDe is kind Solution by RAD Let's split all trucks into different classes by the sum of li + ci + ri. Answer sequence consists of trucks from only one class, so let's solve problem for different classes independently. Let's loop through trucks from fixed class in the order, then follow in the motorcade and update values in dynamics z[k] - maximum profit we can get, if last truck has ri = k. Truck with number i can update two values: it can update value z[ri] with value z[ri + ci] + vi. It means this truck continued some motorcade, started from some previous truck. if li = 0 it can update value z[ri] with vi. It means this truck started motorcade. Answer will be in z[0] To restore the trucks included in the answer, we can keep with the maximal sum in z the index of last truck that updated this sum. Also we store the ancestor p for each truck that updated something in z. This ancestor is calculated when we consider i-th truck and doesn't change further: p[i] = -1 if truck i became beginning of the motorcade, otherwise p[i] = last truck that updated z[ri + ci]. We start restore of the answer from last truck updated z[0]. After that we restore everything using only p. E. DravDe saves the world Solution by Gerald Problem by RAD Let's look at geometrical locus where DravDe can land. It can be eigher an angle or a line(half-line). 1. Locus is an angle if and only if projection of vector v and vector u on Oxy plane is not collinear. This angle is easy to calculate. Angular vertex is DravDe starting point and one of half-lines is collinear with place speed vector projection. Second half-line is easy to calculate: Az + Vz· tv + Uz· tu = 0 Ax + Vx· tv + Ux· tu = Bx Ay + Vy· tv + Uy· tu = By where A - starting point, B - landing point. Consider tv equal to 1 and calculate tu from first equation. From second and third calculate point B. This point lies on the second half-line of the angle. 2. If plane speed projection and wind speed projection is collinear, locus is half-line or line, depending on the difference between this two speeds. If the answer exist, than polygon and locus have at least onecommon point. And t1 and t2 is minimal on edge points. So now let's cross all segments with locus, calculate t1 and t2 for each intersection point and select minimal answer. Thank you for your participation. Good luck with upsolving and incoming contests. Luck - is very useful and it is good to have it. With best regards, Ivan.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/685",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4224
        },
        {
          "title": "Codeforces Beta Round #28 - problem C tutorial - Codeforces",
          "content": "For the first time, our team will write tutorials separetly, but we will unite the in one post after everything will be ready. C. Bath Queue This problem is solved by dynamic programming Consider the following dynamics: d[i][j][k]. i --- number of not yet processed students, j --- number of not yet processed rooms, k --- maximum queue in the previous rooms. The value we need is in state d[n][m][0]. Let's conside some state (i, j, k) and search through all c from 0 to i. If c students will go to jth room, than a probability of such event consists of factors: Cci --- which students will go to jth room. (1 / j)c· ((j - 1) / j)i - c --- probability, that c students will go to jth room,and the rest of them will go to the rooms from first to j - 1th. Sum for all с from 0 to i values of (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx]. Do not forget to update maximum queue value and get the accepted. Thank you for your participation. Good luck with upsolving and incoming contests. Luck - is very useful and it is good to have it. With best regards, Ivan.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/676",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int v = inf.readInt(1, 10000, \"v\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100000, \"c\");\n        inf.readSpace();\n        int l = inf.readInt(0, 100000, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(0, 100000, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int v = inf.readInt(1, 10000, \"v\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100000, \"c\");\n        inf.readSpace();\n        int l = inf.readInt(0, 100000, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(0, 100000, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int v = inf.readInt(1, 10000, \"v\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100000, \"c\");\n        inf.readSpace();\n        int l = inf.readInt(0, 100000, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(0, 100000, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> vi, ci, li, ri;\n\n// This function reads and validates an answer from the given stream.\n// It checks that the sequence of trucks is valid according to the problem constraints\n// and computes the total value of the selected trucks.\n// If the answer is invalid, it reports an appropriate verdict.\nvoid readAns(InStream& stream, vector<int>& trucks, long long& total_value) {\n    total_value = 0;\n    int k = stream.readInt(0, n, \"k\");\n    vector<int> indices;\n    if (k > 0)\n        indices = stream.readInts(k, 1, n, \"indices\");\n    else\n        indices = vector<int>();\n\n    trucks.resize(k);\n    vector<long long> cumulative_cis(k + 1, 0);\n    for (int i = 0; i < k; ++i) {\n        int idx = indices[i] - 1; // zero-based index\n        if (i > 0 && idx <= indices[i - 1] - 1) {\n            stream.quitf(_wa, \"Indices are not strictly increasing at position %d: %d >= %d\", i + 1, indices[i - 1], indices[i]);\n        }\n        trucks[i] = idx;\n        total_value += vi[idx];\n        cumulative_cis[i + 1] = cumulative_cis[i] + ci[idx];\n    }\n    for (int i = 0; i < k; ++i) {\n        int idx = trucks[i];\n        long long total_people_before = cumulative_cis[i];\n        long long total_people_after = cumulative_cis[k] - cumulative_cis[i + 1];\n        if (total_people_before < li[idx]) {\n            stream.quitf(_wa, \"Truck %d: total people before %lld < required %d\", idx + 1, total_people_before, li[idx]);\n        }\n        if (total_people_after < ri[idx]) {\n            stream.quitf(_wa, \"Truck %d: total people after %lld < required %d\", idx + 1, total_people_after, ri[idx]);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(1, 100000, \"n\");\n    vi.resize(n);\n    ci.resize(n);\n    li.resize(n);\n    ri.resize(n);\n    for (int i = 0; i < n; ++i) {\n        vi[i] = inf.readInt(1, 10000, \"vi\");\n        ci[i] = inf.readInt(1, 100000, \"ci\");\n        li[i] = inf.readInt(0, 100000, \"li\");\n        ri[i] = inf.readInt(0, 100000, \"ri\");\n    }\n    \n    vector<int> trucks_jury;\n    long long total_jury_value;\n    readAns(ans, trucks_jury, total_jury_value);\n    \n    vector<int> trucks_contestant;\n    long long total_contestant_value;\n    readAns(ouf, trucks_contestant, total_contestant_value);\n    \n    if (total_contestant_value < total_jury_value) {\n        quitf(_wa, \"Participant's total value %lld is less than the maximum possible %lld\", total_contestant_value, total_jury_value);\n    } else if (total_contestant_value == total_jury_value) {\n        quitf(_ok, \"Total value = %lld\", total_contestant_value);\n    } else { // total_contestant_value > total_jury_value\n        quitf(_fail, \"Participant's total value %lld exceeds the jury's maximum %lld\", total_contestant_value, total_jury_value);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> vi(n), ci(n), li(n), ri(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, 100000);\n            li[i] = rnd.next(0, 100000);\n            ri[i] = rnd.next(0, 100000);\n        }\n    } else if (type == \"maximum\") {\n        // vi and ci maximum, li and ri maximum\n        for(int i = 0; i < n; ++i) {\n            vi[i] = 10000;\n            ci[i] = 100000;\n            li[i] = 100000;\n            ri[i] = 100000;\n        }\n    } else if (type == \"minimum\") {\n        // vi and ci minimum, li and ri zero\n        for(int i = 0; i < n; ++i) {\n            vi[i] = 1;\n            ci[i] = 1;\n            li[i] = 0;\n            ri[i] = 0;\n        }\n    } else if (type == \"zero_fear\") {\n        // li = 0, ri = 0\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, 100000);\n            li[i] = 0;\n            ri[i] = 0;\n        }\n    } else if (type == \"li_large\") {\n        // li large, ri small\n        int max_ci = 100;\n        long long total_ci = 0;\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, max_ci);  // ci[i] up to max_ci\n            total_ci += ci[i];\n        }\n        long long sum_ci = 0;\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            sum_ci += ci[i];\n            int li_max = min<long long>(100000, sum_ci - ci[i]);\n            if (li_max < 0) li_max = 0;\n            li[i] = rnd.next(li_max / 2, li_max);\n            ri[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"ri_large\") {\n        // ri large, li small\n        int max_ci = 100;\n        long long total_ci = 0;\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, max_ci);  // ci[i] up to max_ci\n            total_ci += ci[i];\n        }\n        long long sum_ci = total_ci;\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            sum_ci -= ci[i];\n            int ri_max = min<long long>(100000, sum_ci);\n            if (ri_max < 0) ri_max = 0;\n            ri[i] = rnd.next(ri_max / 2, ri_max);\n            li[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"all_or_none\") {\n        // li and ri set so that either all trucks are selected or none\n        int max_ci = 100;\n        vector<int> ci_temp(n);\n        long long total_ci = 0;\n        for(int i = 0; i < n; ++i) {\n            ci_temp[i] = rnd.next(1, max_ci); // ci[i] up to max_ci\n            total_ci += ci_temp[i];\n        }\n\n        if (total_ci > 100000) {\n            // Scale ci[i] to reduce total_ci within 100000\n            double scale = 100000.0 / total_ci;\n            for(int i = 0; i < n; ++i) {\n                ci[i] = max(1, int(ci_temp[i] * scale));\n            }\n        } else {\n            for(int i = 0; i < n; ++i) {\n                ci[i] = ci_temp[i];\n            }\n        }\n\n        long long sum_ci_before = 0;\n        long long sum_ci_after = 0;\n        for(int i = 0; i < n; ++i) {\n            sum_ci_after += ci[i];\n        }\n\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            sum_ci_after -= ci[i];\n            li[i] = sum_ci_before <= 100000 ? sum_ci_before : 100000;\n            ri[i] = sum_ci_after <= 100000 ? sum_ci_after : 100000;\n            sum_ci_before += ci[i];\n        }\n    } else if (type == \"alternating\") {\n        // Alternate high and low ci\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            if (i % 2 == 0) {\n                ci[i] = 1;\n            } else {\n                ci[i] = 100000;\n            }\n            li[i] = rnd.next(0, 100000);\n            ri[i] = rnd.next(0, 100000);\n        }\n    } else if (type == \"li_ri_max\") {\n        // li and ri maximum\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, 100000);\n            li[i] = 100000;\n            ri[i] = 100000;\n        }\n    } else if (type == \"chain\") {\n        // Setting li so that trucks can be selected only if previous ones are selected\n        int max_ci = 100;\n        ci[0] = rnd.next(1, max_ci);\n        vi[0] = rnd.next(1, 10000);\n        li[0] = 0;\n        ri[0] = rnd.next(0, 100000);\n        long long sum_ci_before = ci[0];\n        for(int i = 1; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, max_ci);\n            li[i] = sum_ci_before <= 100000 ? sum_ci_before : 100000;\n            ri[i] = rnd.next(0, 100000);\n            sum_ci_before += ci[i];\n        }\n    } else if (type == \"ci_max\") {\n        // ci maximum to test integer overflow issues\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = 100000;\n            li[i] = rnd.next(0, 100000);\n            ri[i] = rnd.next(0, 100000);\n        }\n    } else if (type == \"single_truck\") {\n        // n = 1\n        n = 1;\n        vi.resize(1);\n        ci.resize(1);\n        li.resize(1);\n        ri.resize(1);\n        vi[0] = rnd.next(1, 10000);\n        ci[0] = rnd.next(1, 100000);\n        li[0] = rnd.next(0, 100000);\n        ri[0] = rnd.next(0, 100000);\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, 100000);\n            li[i] = rnd.next(0, 100000);\n            ri[i] = rnd.next(0, 100000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the trucks\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", vi[i], ci[i], li[i], ri[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> vi(n), ci(n), li(n), ri(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, 100000);\n            li[i] = rnd.next(0, 100000);\n            ri[i] = rnd.next(0, 100000);\n        }\n    } else if (type == \"maximum\") {\n        // vi and ci maximum, li and ri maximum\n        for(int i = 0; i < n; ++i) {\n            vi[i] = 10000;\n            ci[i] = 100000;\n            li[i] = 100000;\n            ri[i] = 100000;\n        }\n    } else if (type == \"minimum\") {\n        // vi and ci minimum, li and ri zero\n        for(int i = 0; i < n; ++i) {\n            vi[i] = 1;\n            ci[i] = 1;\n            li[i] = 0;\n            ri[i] = 0;\n        }\n    } else if (type == \"zero_fear\") {\n        // li = 0, ri = 0\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, 100000);\n            li[i] = 0;\n            ri[i] = 0;\n        }\n    } else if (type == \"li_large\") {\n        // li large, ri small\n        int max_ci = 100;\n        long long total_ci = 0;\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, max_ci);  // ci[i] up to max_ci\n            total_ci += ci[i];\n        }\n        long long sum_ci = 0;\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            sum_ci += ci[i];\n            int li_max = min<long long>(100000, sum_ci - ci[i]);\n            if (li_max < 0) li_max = 0;\n            li[i] = rnd.next(li_max / 2, li_max);\n            ri[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"ri_large\") {\n        // ri large, li small\n        int max_ci = 100;\n        long long total_ci = 0;\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, max_ci);  // ci[i] up to max_ci\n            total_ci += ci[i];\n        }\n        long long sum_ci = total_ci;\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            sum_ci -= ci[i];\n            int ri_max = min<long long>(100000, sum_ci);\n            if (ri_max < 0) ri_max = 0;\n            ri[i] = rnd.next(ri_max / 2, ri_max);\n            li[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"all_or_none\") {\n        // li and ri set so that either all trucks are selected or none\n        int max_ci = 100;\n        vector<int> ci_temp(n);\n        long long total_ci = 0;\n        for(int i = 0; i < n; ++i) {\n            ci_temp[i] = rnd.next(1, max_ci); // ci[i] up to max_ci\n            total_ci += ci_temp[i];\n        }\n\n        if (total_ci > 100000) {\n            // Scale ci[i] to reduce total_ci within 100000\n            double scale = 100000.0 / total_ci;\n            for(int i = 0; i < n; ++i) {\n                ci[i] = max(1, int(ci_temp[i] * scale));\n            }\n        } else {\n            for(int i = 0; i < n; ++i) {\n                ci[i] = ci_temp[i];\n            }\n        }\n\n        long long sum_ci_before = 0;\n        long long sum_ci_after = 0;\n        for(int i = 0; i < n; ++i) {\n            sum_ci_after += ci[i];\n        }\n\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            sum_ci_after -= ci[i];\n            li[i] = sum_ci_before <= 100000 ? sum_ci_before : 100000;\n            ri[i] = sum_ci_after <= 100000 ? sum_ci_after : 100000;\n            sum_ci_before += ci[i];\n        }\n    } else if (type == \"alternating\") {\n        // Alternate high and low ci\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            if (i % 2 == 0) {\n                ci[i] = 1;\n            } else {\n                ci[i] = 100000;\n            }\n            li[i] = rnd.next(0, 100000);\n            ri[i] = rnd.next(0, 100000);\n        }\n    } else if (type == \"li_ri_max\") {\n        // li and ri maximum\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, 100000);\n            li[i] = 100000;\n            ri[i] = 100000;\n        }\n    } else if (type == \"chain\") {\n        // Setting li so that trucks can be selected only if previous ones are selected\n        int max_ci = 100;\n        ci[0] = rnd.next(1, max_ci);\n        vi[0] = rnd.next(1, 10000);\n        li[0] = 0;\n        ri[0] = rnd.next(0, 100000);\n        long long sum_ci_before = ci[0];\n        for(int i = 1; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, max_ci);\n            li[i] = sum_ci_before <= 100000 ? sum_ci_before : 100000;\n            ri[i] = rnd.next(0, 100000);\n            sum_ci_before += ci[i];\n        }\n    } else if (type == \"ci_max\") {\n        // ci maximum to test integer overflow issues\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = 100000;\n            li[i] = rnd.next(0, 100000);\n            ri[i] = rnd.next(0, 100000);\n        }\n    } else if (type == \"single_truck\") {\n        // n = 1\n        n = 1;\n        vi.resize(1);\n        ci.resize(1);\n        li.resize(1);\n        ri.resize(1);\n        vi[0] = rnd.next(1, 10000);\n        ci[0] = rnd.next(1, 100000);\n        li[0] = rnd.next(0, 100000);\n        ri[0] = rnd.next(0, 100000);\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10000);\n            ci[i] = rnd.next(1, 100000);\n            li[i] = rnd.next(0, 100000);\n            ri[i] = rnd.next(0, 100000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the trucks\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", vi[i], ci[i], li[i], ri[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_truck\n\n./gen -n 5 -type minimum\n./gen -n 5 -type maximum\n./gen -n 5 -type random\n./gen -n 5 -type chain\n./gen -n 5 -type zero_fear\n\n./gen -n 10 -type random\n./gen -n 10 -type li_large\n./gen -n 10 -type ri_large\n./gen -n 10 -type all_or_none\n\n./gen -n 100 -type random\n./gen -n 100 -type chain\n./gen -n 100 -type alternating\n./gen -n 100 -type ci_max\n\n./gen -n 1000 -type random\n./gen -n 1000 -type li_ri_max\n./gen -n 1000 -type chain\n./gen -n 1000 -type ci_max\n\n./gen -n 10000 -type random\n./gen -n 10000 -type li_large\n./gen -n 10000 -type ri_large\n./gen -n 10000 -type alternating\n\n./gen -n 50000 -type random\n./gen -n 50000 -type all_or_none\n./gen -n 50000 -type zero_fear\n\n./gen -n 100000 -type random\n./gen -n 100000 -type ci_max\n./gen -n 100000 -type chain\n./gen -n 100000 -type minimum\n./gen -n 100000 -type maximum\n./gen -n 100000 -type li_ri_max\n./gen -n 100000 -type alternating\n./gen -n 100000 -type zero_fear\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:20.257736",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "28/E",
      "title": "E. DravDe saves the world",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the number n (3 ≤ n ≤ 104) — the amount of vertices of the fence. Then there follow n lines containing the coordinates of these vertices (two integer numbers xi, yi) in clockwise or counter-clockwise order. It's guaranteed, that the fence does not contain self-intersections.The following four lines contain coordinates of point A(xa, ya), speeds V(xv, yv, zv), Fdown and speed U(xu, yu, zu). All the input numbers are integer. All the coordinates don't exceed 104 in absolute value. It's guaranteed, that zv > 0 and Fdown, zu < 0, and point A is strictly outside the incubator's territory.",
      "output_spec": "OutputIn the first line output two numbers t1, t2 such, that if DravDe air drops at time t1 (counting from the beginning of the flight), he lands on the incubator's territory (landing on the border is regarder as landing on the territory). If DravDe doesn't open his parachute, the second number should be equal to the duration of DravDe's falling down. If it's impossible for DravDe to get to the incubator's territory, output -1 -1. If the answer is not unique, output the answer with the minimum t1. If the answers are still multiple, output the answer with the minimum t2. Your answer must have an absolute or relative error less than 10 - 6.",
      "sample_tests": "ExamplesInputCopy40 01 01 10 10 -11 0 1-10 1 -1OutputCopy1.00000000 0.00000000InputCopy40 00 11 11 00 -1-1 -1 1-10 1 -1OutputCopy-1.00000000 -1.00000000InputCopy40 01 01 10 10 -11 1 1-11 1 -1OutputCopy0.50000000 0.00000000",
      "description": "E. DravDe saves the world\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the number n (3 ≤ n ≤ 104) — the amount of vertices of the fence. Then there follow n lines containing the coordinates of these vertices (two integer numbers xi, yi) in clockwise or counter-clockwise order. It's guaranteed, that the fence does not contain self-intersections.The following four lines contain coordinates of point A(xa, ya), speeds V(xv, yv, zv), Fdown and speed U(xu, yu, zu). All the input numbers are integer. All the coordinates don't exceed 104 in absolute value. It's guaranteed, that zv > 0 and Fdown, zu < 0, and point A is strictly outside the incubator's territory.\n\nOutputIn the first line output two numbers t1, t2 such, that if DravDe air drops at time t1 (counting from the beginning of the flight), he lands on the incubator's territory (landing on the border is regarder as landing on the territory). If DravDe doesn't open his parachute, the second number should be equal to the duration of DravDe's falling down. If it's impossible for DravDe to get to the incubator's territory, output -1 -1. If the answer is not unique, output the answer with the minimum t1. If the answers are still multiple, output the answer with the minimum t2. Your answer must have an absolute or relative error less than 10 - 6.\n\nInputCopy40 01 01 10 10 -11 0 1-10 1 -1OutputCopy1.00000000 0.00000000InputCopy40 00 11 11 00 -1-1 -1 1-10 1 -1OutputCopy-1.00000000 -1.00000000InputCopy40 01 01 10 10 -11 1 1-11 1 -1OutputCopy0.50000000 0.00000000\n\nInputCopy40 01 01 10 10 -11 0 1-10 1 -1\n\nOutputCopy1.00000000 0.00000000\n\nInputCopy40 00 11 11 00 -1-1 -1 1-10 1 -1\n\nOutputCopy-1.00000000 -1.00000000\n\nInputCopy40 01 01 10 10 -11 1 1-11 1 -1\n\nOutputCopy0.50000000 0.00000000",
      "solutions": [
        {
          "title": "Codeforces Beta Round #28 (Codeforces format) - Codeforces",
          "content": "Attention-Attention!!!Today Saratov SU #1 (Gerald, Polichka, Fefer) team invites all of you to take part in Codeforces Beta Round #28. We began studing sport-programming in school. But when we entered the Saratov State University we took it seriously and made our way from SU #7 to Saratov SU #1. Now our first-grade ambition is to justify this number.We are going to offer you 5 interesting problems. You will be helping some good people to deal with their problems, will be solving some administrative tasks, will be playing some interesting games and also will be saving the World.Thanks to everyone for their help in preparing this round. Successful hacks and fast accepteds!With best regards, Saratov SU #1.UPD: Ratings have been updated.UPD:ProblemsStandingsWinner: dzhulgakovTutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/674",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 28"
          },
          "content_length": 790
        },
        {
          "title": "Codeforces Round 28 - tutorial - Codeforces",
          "content": "A. Bender Problem Solution by Polichka Let's look at the first nail. If it is occupied by the fold place, then Bender will put next fold place on the third nail, then on fifth and so on. Else, is the first nail occupied by end, than second, fourth, sixth and so on nail will be occupied by the fold places. Let's see, if we can complete our polyline with the first nail, occupied by rhe fold place. It means we should check, if we have an unused pod with length dist(nails[n], nails[1]) + dist(nails[1], nails[2]). Then check the third nail and so on. If we have completed the polyline, then we have an answer. Else repeat previous procedure, but starting from the second nail. B. pSort Solution by Polichka Let's consider a graph. Vertexes will correspond to place of the permutation. Places will be connected by an edge if and only if we can swap theirs values. Our problem has a solution when for every i, vertex p[i] can be reached from vertex i. C. Bath Queue Solution by Fefer This problem is solved by dynamic programming Consider the following dynamics: d[i][j][k]. i --- number of not yet processed students, j --- number of not yet processed rooms, k --- maximum queue in the previous rooms. The value we need is in state d[n][m][0]. Let's conside some state (i, j, k) and search through all c from 0 to i. If c students will go to jth room, than a probability of such event consists of factors: Cci --- which students will go to jth room. (1 / j)c· ((j - 1) / j)i - c --- probability, that c students will go to jth room,and the rest of them will go to the rooms from first to j - 1th. Sum for all ñ from 0 to i values of (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx]. Do not forget to update maximum queue value and get the accepted. D. Do not fear, DravDe is kind Solution by RAD Let's split all trucks into different classes by the sum of li + ci + ri. Answer sequence consists of trucks from only one class, so let's solve problem for different classes independently. Let's loop through trucks from fixed class in the order, then follow in the motorcade and update values in dynamics z[k] - maximum profit we can get, if last truck has ri = k. Truck with number i can update two values: it can update value z[ri] with value z[ri + ci] + vi. It means this truck continued some motorcade, started from some previous truck. if li = 0 it can update value z[ri] with vi. It means this truck started motorcade. Answer will be in z[0] To restore the trucks included in the answer, we can keep with the maximal sum in z the index of last truck that updated this sum. Also we store the ancestor p for each truck that updated something in z. This ancestor is calculated when we consider i-th truck and doesn't change further: p[i] = -1 if truck i became beginning of the motorcade, otherwise p[i] = last truck that updated z[ri + ci]. We start restore of the answer from last truck updated z[0]. After that we restore everything using only p. E. DravDe saves the world Solution by Gerald Problem by RAD Let's look at geometrical locus where DravDe can land. It can be eigher an angle or a line(half-line). 1. Locus is an angle if and only if projection of vector v and vector u on Oxy plane is not collinear. This angle is easy to calculate. Angular vertex is DravDe starting point and one of half-lines is collinear with place speed vector projection. Second half-line is easy to calculate: Az + Vz· tv + Uz· tu = 0 Ax + Vx· tv + Ux· tu = Bx Ay + Vy· tv + Uy· tu = By where A - starting point, B - landing point. Consider tv equal to 1 and calculate tu from first equation. From second and third calculate point B. This point lies on the second half-line of the angle. 2. If plane speed projection and wind speed projection is collinear, locus is half-line or line, depending on the difference between this two speeds. If the answer exist, than polygon and locus have at least onecommon point. And t1 and t2 is minimal on edge points. So now let's cross all segments with locus, calculate t1 and t2 for each intersection point and select minimal answer. Thank you for your participation. Good luck with upsolving and incoming contests. Luck - is very useful and it is good to have it. With best regards, Ivan.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/685",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4224
        },
        {
          "title": "Codeforces Beta Round #28 - problem C tutorial - Codeforces",
          "content": "For the first time, our team will write tutorials separetly, but we will unite the in one post after everything will be ready. C. Bath Queue This problem is solved by dynamic programming Consider the following dynamics: d[i][j][k]. i --- number of not yet processed students, j --- number of not yet processed rooms, k --- maximum queue in the previous rooms. The value we need is in state d[n][m][0]. Let's conside some state (i, j, k) and search through all c from 0 to i. If c students will go to jth room, than a probability of such event consists of factors: Cci --- which students will go to jth room. (1 / j)c· ((j - 1) / j)i - c --- probability, that c students will go to jth room,and the rest of them will go to the rooms from first to j - 1th. Sum for all с from 0 to i values of (1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx]. Do not forget to update maximum queue value and get the accepted. Thank you for your participation. Good luck with upsolving and incoming contests. Luck - is very useful and it is good to have it. With best regards, Ivan.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/676",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n// Structure to represent a point\nstruct Point {\n    ll x, y;\n    Point(ll x=0, ll y=0): x(x), y(y) {}\n    Point operator-(const Point &b) const {\n        return Point(x - b.x, y - b.y);\n    }\n};\n\n// Cross product of two vectors\nll cross(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Returns 0 if colinear, 1 if clockwise, 2 if counterclockwise\nint orientation(const Point &a, const Point &b, const Point &c) {\n    ll val = cross(b - a, c - a);\n    if (val == 0) return 0; // colinear\n    return (val > 0) ? 1 : 2; // clockwise or counterclockwise\n}\n\n// Returns true if point q lies on segment pr\nbool onSegment(const Point &p, const Point &q, const Point &r) {\n    return min(p.x, r.x) <= q.x && q.x <= max(p.x, r.x) &&\n           min(p.y, r.y) <= q.y && q.y <= max(p.y, r.y);\n}\n\n// Checks if two line segments intersect\nbool segmentsIntersect(const Point &p1, const Point &p2, const Point &q1, const Point &q2) {\n    int o1 = orientation(p1, p2, q1);\n    int o2 = orientation(p1, p2, q2);\n    int o3 = orientation(q1, q2, p1);\n    int o4 = orientation(q1, q2, p2);\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n    // Special Cases\n    if (o1 == 0 && onSegment(p1, q1, p2)) return true;\n    if (o2 == 0 && onSegment(p1, q2, p2)) return true;\n    if (o3 == 0 && onSegment(q1, p1, q2)) return true;\n    if (o4 == 0 && onSegment(q1, p2, q2)) return true;\n    return false; // No intersection\n}\n\n// Winding number algorithm to check if point is inside polygon\nint windingNumber(const Point &p, const vector<Point> &polygon) {\n    int n = polygon.size();\n    int wn = 0;\n    for (int i = 0; i < n; i++) {\n        Point a = polygon[i];\n        Point b = polygon[(i + 1) % n];\n        if (orientation(a, b, p) == 0 && onSegment(a, p, b)) {\n            return -1; // On edge\n        }\n        if (a.y <= p.y) {\n            if (b.y > p.y && cross(b - a, p - a) > 0)\n                wn++;\n        } else {\n            if (b.y <= p.y && cross(b - a, p - a) < 0)\n                wn--;\n        }\n    }\n    return wn;\n}\n\n// Returns true if point p is inside or on the boundary of the polygon\nbool isPointInsidePolygon(const Point &p, const vector<Point> &polygon) {\n    int wn = windingNumber(p, polygon);\n    if (wn == 0) {\n        return false; // Outside\n    } else if (wn == -1) {\n        return true; // On edge\n    } else {\n        return true; // Inside\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(3, 10000, \"n\");\n    inf.readEoln();\n\n    vector<Point> points(n);\n\n    // Read n points\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n        points[i] = Point(xi, yi);\n    }\n\n    // Check that the polygon is simple\n    for (int i = 0; i < n; i++) {\n        int ip1 = (i + 1) % n;\n        for (int j = i + 1; j < n; j++) {\n            int jp1 = (j + 1) % n;\n            // Ignore adjacent edges\n            if (ip1 == j || jp1 == i) continue;\n            if (segmentsIntersect(points[i], points[ip1], points[j], points[jp1])) {\n                quitf(_fail, \"Polygon is not simple: edges %d-%d and %d-%d intersect\", i, ip1, j, jp1);\n            }\n        }\n    }\n\n    // Read point A(xa, ya)\n    int xa = inf.readInt(-10000, 10000, \"xa\");\n    inf.readSpace();\n    int ya = inf.readInt(-10000, 10000, \"ya\");\n    inf.readEoln();\n    Point A(xa, ya);\n\n    // Check that A is strictly outside the polygon\n    if (isPointInsidePolygon(A, points)) {\n        quitf(_fail, \"Point A is not strictly outside the polygon\");\n    }\n\n    // Read V(xv, yv, zv)\n    int xv = inf.readInt(-10000, 10000, \"xv\");\n    inf.readSpace();\n    int yv = inf.readInt(-10000, 10000, \"yv\");\n    inf.readSpace();\n    int zv = inf.readInt(1, 10000, \"zv\"); // zv > 0\n    inf.readEoln();\n\n    // Read Fdown\n    int Fdown = inf.readInt(-10000, -1, \"Fdown\"); // Fdown < 0\n    inf.readEoln();\n\n    // Read U(xu, yu, zu)\n    int xu = inf.readInt(-10000, 10000, \"xu\");\n    inf.readSpace();\n    int yu = inf.readInt(-10000, 10000, \"yu\");\n    inf.readSpace();\n    int zu = inf.readInt(-10000, -1, \"zu\"); // zu < 0\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n// Structure to represent a point\nstruct Point {\n    ll x, y;\n    Point(ll x=0, ll y=0): x(x), y(y) {}\n    Point operator-(const Point &b) const {\n        return Point(x - b.x, y - b.y);\n    }\n};\n\n// Cross product of two vectors\nll cross(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Returns 0 if colinear, 1 if clockwise, 2 if counterclockwise\nint orientation(const Point &a, const Point &b, const Point &c) {\n    ll val = cross(b - a, c - a);\n    if (val == 0) return 0; // colinear\n    return (val > 0) ? 1 : 2; // clockwise or counterclockwise\n}\n\n// Returns true if point q lies on segment pr\nbool onSegment(const Point &p, const Point &q, const Point &r) {\n    return min(p.x, r.x) <= q.x && q.x <= max(p.x, r.x) &&\n           min(p.y, r.y) <= q.y && q.y <= max(p.y, r.y);\n}\n\n// Checks if two line segments intersect\nbool segmentsIntersect(const Point &p1, const Point &p2, const Point &q1, const Point &q2) {\n    int o1 = orientation(p1, p2, q1);\n    int o2 = orientation(p1, p2, q2);\n    int o3 = orientation(q1, q2, p1);\n    int o4 = orientation(q1, q2, p2);\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n    // Special Cases\n    if (o1 == 0 && onSegment(p1, q1, p2)) return true;\n    if (o2 == 0 && onSegment(p1, q2, p2)) return true;\n    if (o3 == 0 && onSegment(q1, p1, q2)) return true;\n    if (o4 == 0 && onSegment(q1, p2, q2)) return true;\n    return false; // No intersection\n}\n\n// Winding number algorithm to check if point is inside polygon\nint windingNumber(const Point &p, const vector<Point> &polygon) {\n    int n = polygon.size();\n    int wn = 0;\n    for (int i = 0; i < n; i++) {\n        Point a = polygon[i];\n        Point b = polygon[(i + 1) % n];\n        if (orientation(a, b, p) == 0 && onSegment(a, p, b)) {\n            return -1; // On edge\n        }\n        if (a.y <= p.y) {\n            if (b.y > p.y && cross(b - a, p - a) > 0)\n                wn++;\n        } else {\n            if (b.y <= p.y && cross(b - a, p - a) < 0)\n                wn--;\n        }\n    }\n    return wn;\n}\n\n// Returns true if point p is inside or on the boundary of the polygon\nbool isPointInsidePolygon(const Point &p, const vector<Point> &polygon) {\n    int wn = windingNumber(p, polygon);\n    if (wn == 0) {\n        return false; // Outside\n    } else if (wn == -1) {\n        return true; // On edge\n    } else {\n        return true; // Inside\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(3, 10000, \"n\");\n    inf.readEoln();\n\n    vector<Point> points(n);\n\n    // Read n points\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n        points[i] = Point(xi, yi);\n    }\n\n    // Check that the polygon is simple\n    for (int i = 0; i < n; i++) {\n        int ip1 = (i + 1) % n;\n        for (int j = i + 1; j < n; j++) {\n            int jp1 = (j + 1) % n;\n            // Ignore adjacent edges\n            if (ip1 == j || jp1 == i) continue;\n            if (segmentsIntersect(points[i], points[ip1], points[j], points[jp1])) {\n                quitf(_fail, \"Polygon is not simple: edges %d-%d and %d-%d intersect\", i, ip1, j, jp1);\n            }\n        }\n    }\n\n    // Read point A(xa, ya)\n    int xa = inf.readInt(-10000, 10000, \"xa\");\n    inf.readSpace();\n    int ya = inf.readInt(-10000, 10000, \"ya\");\n    inf.readEoln();\n    Point A(xa, ya);\n\n    // Check that A is strictly outside the polygon\n    if (isPointInsidePolygon(A, points)) {\n        quitf(_fail, \"Point A is not strictly outside the polygon\");\n    }\n\n    // Read V(xv, yv, zv)\n    int xv = inf.readInt(-10000, 10000, \"xv\");\n    inf.readSpace();\n    int yv = inf.readInt(-10000, 10000, \"yv\");\n    inf.readSpace();\n    int zv = inf.readInt(1, 10000, \"zv\"); // zv > 0\n    inf.readEoln();\n\n    // Read Fdown\n    int Fdown = inf.readInt(-10000, -1, \"Fdown\"); // Fdown < 0\n    inf.readEoln();\n\n    // Read U(xu, yu, zu)\n    int xu = inf.readInt(-10000, 10000, \"xu\");\n    inf.readSpace();\n    int yu = inf.readInt(-10000, 10000, \"yu\");\n    inf.readSpace();\n    int zu = inf.readInt(-10000, -1, \"zu\"); // zu < 0\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n// Structure to represent a point\nstruct Point {\n    ll x, y;\n    Point(ll x=0, ll y=0): x(x), y(y) {}\n    Point operator-(const Point &b) const {\n        return Point(x - b.x, y - b.y);\n    }\n};\n\n// Cross product of two vectors\nll cross(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Returns 0 if colinear, 1 if clockwise, 2 if counterclockwise\nint orientation(const Point &a, const Point &b, const Point &c) {\n    ll val = cross(b - a, c - a);\n    if (val == 0) return 0; // colinear\n    return (val > 0) ? 1 : 2; // clockwise or counterclockwise\n}\n\n// Returns true if point q lies on segment pr\nbool onSegment(const Point &p, const Point &q, const Point &r) {\n    return min(p.x, r.x) <= q.x && q.x <= max(p.x, r.x) &&\n           min(p.y, r.y) <= q.y && q.y <= max(p.y, r.y);\n}\n\n// Checks if two line segments intersect\nbool segmentsIntersect(const Point &p1, const Point &p2, const Point &q1, const Point &q2) {\n    int o1 = orientation(p1, p2, q1);\n    int o2 = orientation(p1, p2, q2);\n    int o3 = orientation(q1, q2, p1);\n    int o4 = orientation(q1, q2, p2);\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n    // Special Cases\n    if (o1 == 0 && onSegment(p1, q1, p2)) return true;\n    if (o2 == 0 && onSegment(p1, q2, p2)) return true;\n    if (o3 == 0 && onSegment(q1, p1, q2)) return true;\n    if (o4 == 0 && onSegment(q1, p2, q2)) return true;\n    return false; // No intersection\n}\n\n// Winding number algorithm to check if point is inside polygon\nint windingNumber(const Point &p, const vector<Point> &polygon) {\n    int n = polygon.size();\n    int wn = 0;\n    for (int i = 0; i < n; i++) {\n        Point a = polygon[i];\n        Point b = polygon[(i + 1) % n];\n        if (orientation(a, b, p) == 0 && onSegment(a, p, b)) {\n            return -1; // On edge\n        }\n        if (a.y <= p.y) {\n            if (b.y > p.y && cross(b - a, p - a) > 0)\n                wn++;\n        } else {\n            if (b.y <= p.y && cross(b - a, p - a) < 0)\n                wn--;\n        }\n    }\n    return wn;\n}\n\n// Returns true if point p is inside or on the boundary of the polygon\nbool isPointInsidePolygon(const Point &p, const vector<Point> &polygon) {\n    int wn = windingNumber(p, polygon);\n    if (wn == 0) {\n        return false; // Outside\n    } else if (wn == -1) {\n        return true; // On edge\n    } else {\n        return true; // Inside\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(3, 10000, \"n\");\n    inf.readEoln();\n\n    vector<Point> points(n);\n\n    // Read n points\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n        points[i] = Point(xi, yi);\n    }\n\n    // Check that the polygon is simple\n    for (int i = 0; i < n; i++) {\n        int ip1 = (i + 1) % n;\n        for (int j = i + 1; j < n; j++) {\n            int jp1 = (j + 1) % n;\n            // Ignore adjacent edges\n            if (ip1 == j || jp1 == i) continue;\n            if (segmentsIntersect(points[i], points[ip1], points[j], points[jp1])) {\n                quitf(_fail, \"Polygon is not simple: edges %d-%d and %d-%d intersect\", i, ip1, j, jp1);\n            }\n        }\n    }\n\n    // Read point A(xa, ya)\n    int xa = inf.readInt(-10000, 10000, \"xa\");\n    inf.readSpace();\n    int ya = inf.readInt(-10000, 10000, \"ya\");\n    inf.readEoln();\n    Point A(xa, ya);\n\n    // Check that A is strictly outside the polygon\n    if (isPointInsidePolygon(A, points)) {\n        quitf(_fail, \"Point A is not strictly outside the polygon\");\n    }\n\n    // Read V(xv, yv, zv)\n    int xv = inf.readInt(-10000, 10000, \"xv\");\n    inf.readSpace();\n    int yv = inf.readInt(-10000, 10000, \"yv\");\n    inf.readSpace();\n    int zv = inf.readInt(1, 10000, \"zv\"); // zv > 0\n    inf.readEoln();\n\n    // Read Fdown\n    int Fdown = inf.readInt(-10000, -1, \"Fdown\"); // Fdown < 0\n    inf.readEoln();\n\n    // Read U(xu, yu, zu)\n    int xu = inf.readInt(-10000, 10000, \"xu\");\n    inf.readSpace();\n    int yu = inf.readInt(-10000, 10000, \"yu\");\n    inf.readSpace();\n    int zu = inf.readInt(-10000, -1, \"zu\"); // zu < 0\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const double EPS = 1e-7;\n\n// Structure to hold an answer (either noSolution or the two times)\nstruct Answer {\n    bool noSolution;\n    double t1, t2;\n};\n\n// Safely attempt to read a token from \"stream\".  \n// If we cannot read (EOF or any error), return an empty string and ok=false.  \n// Otherwise, ok=true.  \nstring safeReadToken(InStream &stream, bool &ok) {\n    // If there's nothing left to read, reading a token would throw an error:\n    if (stream.eof()) {\n        ok = false;\n        return \"\";\n    }\n    string token;\n    try {\n        token = stream.readToken(); \n    } catch (...) {\n        // Any failure => signal no token\n        ok = false;\n        return \"\";\n    }\n    ok = true;\n    return token;\n}\n\n// Attempt to parse string s into double val with std::stod().  \nbool tryParseDouble(const string &s, double &val) {\n    try {\n        size_t idx;\n        val = stod(s, &idx);\n        if (idx != s.size()) {\n            // leftover characters => parse failure\n            return false;\n        }\n    } catch (...) {\n        return false;\n    }\n    return true;\n}\n\n// Compare doubles with a small epsilon.  \n//   return -1 if a < b beyond EPS,\n//   return  0 if |a-b| <= EPS,\n//   return +1 if a > b beyond EPS.\nint cmpDouble(double a, double b) {\n    if (a + EPS < b) return -1;\n    if (b + EPS < a) return +1;\n    return 0;\n}\n\n/*\n  Reads exactly two tokens for the answer:\n   1) If the first token is missing => treat as \"no solution\" => -1 -1.\n   2) If the first token cannot parse => likewise no solution.\n   3) If the second token is missing => fail/wa.\n   4) If parse fails => fail/wa.\n   5) If (t1, t2) ~ (-1, -1), => noSolution=true.\n*/\nAnswer readAnswer(InStream &stream, bool isJury) {\n    Answer ans;\n    ans.noSolution = false;\n    ans.t1 = ans.t2 = 0.0;\n\n    // Read the FIRST token\n    bool okFirst;\n    string s1 = safeReadToken(stream, okFirst);\n    if (!okFirst) {\n        // No token => noSolution => (-1, -1)\n        ans.noSolution = true;\n        ans.t1 = ans.t2 = -1.0;\n        return ans;\n    }\n    double d1;\n    if (!tryParseDouble(s1, d1)) {\n        // parse fail => noSolution\n        ans.noSolution = true;\n        ans.t1 = ans.t2 = -1.0;\n        return ans;\n    }\n    ans.t1 = d1;\n\n    // Read the SECOND token\n    bool okSecond;\n    string s2 = safeReadToken(stream, okSecond);\n    if (!okSecond) {\n        // No second token => incomplete => error\n        stream.quitf(isJury ? _fail : _wa,\n                     \"Expected second double but none is provided\");\n    }\n    double d2;\n    if (!tryParseDouble(s2, d2)) {\n        // parse fail => error\n        stream.quitf(isJury ? _fail : _wa,\n                     \"Invalid second double: '%s'\", s2.c_str());\n    }\n    ans.t2 = d2;\n\n    // If (t1, t2) ~ (-1, -1), interpret as noSolution\n    if (fabs(ans.t1 + 1.0) < EPS && fabs(ans.t2 + 1.0) < EPS) {\n        ans.noSolution = true;\n    }\n    return ans;\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // (1) Read problem input using readInt(), to avoid partial line reads\n    int n = inf.readInt(); // number of polygon vertices\n    for (int i = 0; i < n; i++) {\n        inf.readInt(); // x_i\n        inf.readInt(); // y_i\n    }\n    // A(xa, ya)\n    inf.readInt(); inf.readInt();\n    // V(xv, yv, zv)\n    inf.readInt(); inf.readInt(); inf.readInt();\n    // Fdown\n    inf.readInt();\n    // U(xu, yu, zu)\n    inf.readInt(); inf.readInt(); inf.readInt();\n\n    // (2) Read the jury's official answer\n    Answer jury = readAnswer(ans, /*isJury=*/true);\n\n    // (3) Read the participant's answer\n    Answer part = readAnswer(ouf, /*isJury=*/false);\n\n    // (4) Compare them according to multi-answer logic\n    if (jury.noSolution) {\n        if (part.noSolution) {\n            // Both say no solution => OK\n            quitf(_ok, \"both solutions say no solution\");\n        } else {\n            // Jury says no solution, participant found one => participant is better => FAIL\n            quitf(_fail, \"jury says no solution, participant found a solution\");\n        }\n    } else {\n        // Jury has a solution\n        if (part.noSolution) {\n            // Participant says no => worse => WA\n            quitf(_wa, \"jury has a solution, participant says no solution\");\n        } else {\n            // Compare (t1, t2) lexicographically\n            int c1 = cmpDouble(part.t1, jury.t1);\n            if (c1 < 0) {\n                // participant has smaller t1 => \"better\" => FAIL\n                quitf(_fail, \"participant's t1=%.9f < jury's t1=%.9f\", part.t1, jury.t1);\n            } else if (c1 > 0) {\n                // participant has bigger t1 => \"worse\" => WA\n                quitf(_wa, \"participant's t1=%.9f > jury's t1=%.9f\", part.t1, jury.t1);\n            } else {\n                // t1 is equal => compare t2\n                int c2 = cmpDouble(part.t2, jury.t2);\n                if (c2 < 0) {\n                    quitf(_fail, \"participant's t2=%.9f < jury's t2=%.9f\", part.t2, jury.t2);\n                } else if (c2 > 0) {\n                    quitf(_wa, \"participant's t2=%.9f > jury's t2=%.9f\", part.t2, jury.t2);\n                } else {\n                    // exactly the same\n                    quitf(_ok, \"both solutions have the same (t1, t2)\");\n                }\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nint minX, maxX, minY, maxY;\nvector<pair<int, int>> polygon;\n\nlong long cross(const pair<int, int>& O, const pair<int, int>& A, const pair<int, int>& B) {\n    return (long long)(A.first - O.first) * (B.second - O.second) - (long long)(A.second - O.second) * (B.first - O.first);\n}\n\nvoid generate_square() {\n    int size = rnd.next(1000, 10000);\n    polygon.clear();\n\n    polygon.push_back(make_pair(-size, -size));\n    polygon.push_back(make_pair(size, -size));\n    polygon.push_back(make_pair(size, size));\n    polygon.push_back(make_pair(-size, size));\n}\n\nvoid generate_regular_polygon(int n) {\n    int R = rnd.next(1000, 10000);\n    polygon.clear();\n    double angle_increment = 2 * PI / n;\n    double shift = rnd.next(0.0, 2 * PI);\n\n    for (int i = 0; i < n; ++i) {\n        double angle = shift + i * angle_increment;\n        int x = (int)(R * cos(angle));\n        int y = (int)(R * sin(angle));\n        polygon.push_back(make_pair(x, y));\n    }\n}\n\nvoid generate_convex_polygon(int n) {\n    set<pair<int, int>> points_set;\n    while ((int)points_set.size() < n) {\n        int x = rnd.next(-10000, 10000);\n        int y = rnd.next(-10000, 10000);\n        points_set.insert(make_pair(x, y));\n    }\n    vector<pair<int,int>> points(points_set.begin(), points_set.end());\n\n    // Convex Hull using Graham scan\n    sort(points.begin(), points.end());\n    vector<pair<int, int>> lower, upper;\n\n    for (auto& p : points) {\n        while (lower.size() >= 2 && cross(lower[lower.size()-2], lower[lower.size()-1], p) <= 0)\n            lower.pop_back();\n        lower.push_back(p);\n    }\n\n    for (int i = (int)points.size() - 1; i >= 0; i--) {\n        auto& p = points[i];\n        while (upper.size() >= 2 && cross(upper[upper.size()-2], upper[upper.size()-1], p) <= 0)\n            upper.pop_back();\n        upper.push_back(p);\n    }\n\n    polygon = lower;\n    if (upper.size() > 2)\n        polygon.insert(polygon.end(), upper.begin() + 1, upper.end() -1);\n}\n\nvoid compute_bounding_box() {\n    minX = maxX = polygon[0].first;\n    minY = maxY = polygon[0].second;\n    for (auto& p : polygon) {\n        minX = min(minX, p.first);\n        maxX = max(maxX, p.first);\n        minY = min(minY, p.second);\n        maxY = max(maxY, p.second);\n    }\n}\n\npair<int, int> generate_point_A(string A_position) {\n    int margin = 10;\n    int xa, ya;\n    if (A_position == \"above\") {\n        xa = rnd.next(minX, maxX);\n        ya = maxY + rnd.next(1, 1000);\n    } else if (A_position == \"below\") {\n        xa = rnd.next(minX, maxX);\n        ya = minY - rnd.next(1, 1000);\n    } else if (A_position == \"left\") {\n        xa = minX - rnd.next(1, 1000);\n        ya = rnd.next(minY, maxY);\n    } else if (A_position == \"right\") {\n        xa = maxX + rnd.next(1, 1000);\n        ya = rnd.next(minY, maxY);\n    } else if (A_position == \"far\") {\n        xa = rnd.next(-10000, 10000);\n        ya = rnd.next(-10000, 10000);\n        while (xa >= minX - margin && xa <= maxX + margin && ya >= minY - margin && ya <= maxY + margin) {\n            xa = rnd.next(-10000, 10000);\n            ya = rnd.next(-10000, 10000);\n        }\n    } else if (A_position == \"near\") {\n        int side = rnd.next(4);\n        if (side == 0) { // above\n            xa = rnd.next(minX, maxX);\n            ya = maxY + rnd.next(1, 10);\n        } else if (side == 1) { // below\n            xa = rnd.next(minX, maxX);\n            ya = minY - rnd.next(1, 10);\n        } else if (side == 2) { // left\n            xa = minX - rnd.next(1, 10);\n            ya = rnd.next(minY, maxY);\n        } else { // right\n            xa = maxX + rnd.next(1, 10);\n            ya = rnd.next(minY, maxY);\n        }\n    } else { // random\n        xa = rnd.next(-10000, 10000);\n        ya = rnd.next(-10000, 10000);\n        while (xa >= minX && xa <= maxX && ya >= minY && ya <= maxY) {\n            xa = rnd.next(-10000, 10000);\n            ya = rnd.next(-10000, 10000);\n        }\n    }\n    return make_pair(xa, ya);\n}\n\nvoid output_polygon() {\n    int n = polygon.size();\n    printf(\"%d\\n\", n);\n    for (auto& v : polygon) {\n        printf(\"%d %d\\n\", v.first, v.second);\n    }\n}\n\nvoid generate_speeds(string speed_type, int& xv, int& yv, int& zv, int& Fdown, int& xu, int& yu, int& zu) {\n    if (speed_type == \"random\") {\n        // Plane speeds\n        xv = rnd.next(-1000, 1000);\n        yv = rnd.next(-1000, 1000);\n        zv = rnd.next(1, 1000); // zv > 0\n\n        // Falling speed before opening parachute\n        Fdown = rnd.next(-1000, -1); // Fdown < 0\n\n        // Wind speeds after opening parachute\n        xu = rnd.next(-1000, 1000);\n        yu = rnd.next(-1000, 1000);\n        zu = rnd.next(-1000, -1); // zu < 0\n    } else if (speed_type == \"zero_wind\") {\n        // Plane speeds\n        xv = rnd.next(-1000, 1000);\n        yv = rnd.next(-1000, 1000);\n        zv = rnd.next(1, 1000); // zv > 0\n\n        // Falling speed before opening parachute\n        Fdown = rnd.next(-1000, -1); // Fdown < 0\n\n        // Wind speeds after opening parachute\n        xu = 0;\n        yu = 0;\n        zu = rnd.next(-1000, -1); // zu < 0\n    } else if (speed_type == \"impossible\") {\n        // Speeds such that DravDe cannot reach the polygon\n        xv = yv = 0;\n        zv = rnd.next(1, 1000); // zv > 0\n\n        Fdown = rnd.next(-1000, -1); // Fdown < 0\n\n        xu = yu = 0;\n        zu = rnd.next(-1000, -1); // zu < 0\n    } else { // default random\n        xv = rnd.next(-1000, 1000);\n        yv = rnd.next(-1000, 1000);\n        zv = rnd.next(1, 1000); // zv > 0\n\n        Fdown = rnd.next(-1000, -1); // Fdown < 0\n\n        xu = rnd.next(-1000, 1000);\n        yu = rnd.next(-1000, 1000);\n        zu = rnd.next(-1000, -1); // zu < 0\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string polygon_type = opt<string>(\"polygon_type\", \"convex\");\n    string A_position = opt<string>(\"A_position\", \"random\");\n    string speed_type = opt<string>(\"speed_type\", \"random\");\n\n    if (polygon_type == \"square\") {\n        generate_square();\n    } else if (polygon_type == \"regular\") {\n        generate_regular_polygon(n);\n    } else { // default to convex polygon\n        generate_convex_polygon(n);\n    }\n\n    compute_bounding_box();\n    output_polygon();\n\n    pair<int, int> A = generate_point_A(A_position);\n    int xa = A.first;\n    int ya = A.second;\n\n    int xv, yv, zv, Fdown, xu, yu, zu;\n    generate_speeds(speed_type, xv, yv, zv, Fdown, xu, yu, zu);\n\n    printf(\"%d %d\\n\", xa, ya);\n    printf(\"%d %d %d\\n\", xv, yv, zv);\n    printf(\"%d\\n\", Fdown);\n    printf(\"%d %d %d\\n\", xu, yu, zu);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nint minX, maxX, minY, maxY;\nvector<pair<int, int>> polygon;\n\nlong long cross(const pair<int, int>& O, const pair<int, int>& A, const pair<int, int>& B) {\n    return (long long)(A.first - O.first) * (B.second - O.second) - (long long)(A.second - O.second) * (B.first - O.first);\n}\n\nvoid generate_square() {\n    int size = rnd.next(1000, 10000);\n    polygon.clear();\n\n    polygon.push_back(make_pair(-size, -size));\n    polygon.push_back(make_pair(size, -size));\n    polygon.push_back(make_pair(size, size));\n    polygon.push_back(make_pair(-size, size));\n}\n\nvoid generate_regular_polygon(int n) {\n    int R = rnd.next(1000, 10000);\n    polygon.clear();\n    double angle_increment = 2 * PI / n;\n    double shift = rnd.next(0.0, 2 * PI);\n\n    for (int i = 0; i < n; ++i) {\n        double angle = shift + i * angle_increment;\n        int x = (int)(R * cos(angle));\n        int y = (int)(R * sin(angle));\n        polygon.push_back(make_pair(x, y));\n    }\n}\n\nvoid generate_convex_polygon(int n) {\n    set<pair<int, int>> points_set;\n    while ((int)points_set.size() < n) {\n        int x = rnd.next(-10000, 10000);\n        int y = rnd.next(-10000, 10000);\n        points_set.insert(make_pair(x, y));\n    }\n    vector<pair<int,int>> points(points_set.begin(), points_set.end());\n\n    // Convex Hull using Graham scan\n    sort(points.begin(), points.end());\n    vector<pair<int, int>> lower, upper;\n\n    for (auto& p : points) {\n        while (lower.size() >= 2 && cross(lower[lower.size()-2], lower[lower.size()-1], p) <= 0)\n            lower.pop_back();\n        lower.push_back(p);\n    }\n\n    for (int i = (int)points.size() - 1; i >= 0; i--) {\n        auto& p = points[i];\n        while (upper.size() >= 2 && cross(upper[upper.size()-2], upper[upper.size()-1], p) <= 0)\n            upper.pop_back();\n        upper.push_back(p);\n    }\n\n    polygon = lower;\n    if (upper.size() > 2)\n        polygon.insert(polygon.end(), upper.begin() + 1, upper.end() -1);\n}\n\nvoid compute_bounding_box() {\n    minX = maxX = polygon[0].first;\n    minY = maxY = polygon[0].second;\n    for (auto& p : polygon) {\n        minX = min(minX, p.first);\n        maxX = max(maxX, p.first);\n        minY = min(minY, p.second);\n        maxY = max(maxY, p.second);\n    }\n}\n\npair<int, int> generate_point_A(string A_position) {\n    int margin = 10;\n    int xa, ya;\n    if (A_position == \"above\") {\n        xa = rnd.next(minX, maxX);\n        ya = maxY + rnd.next(1, 1000);\n    } else if (A_position == \"below\") {\n        xa = rnd.next(minX, maxX);\n        ya = minY - rnd.next(1, 1000);\n    } else if (A_position == \"left\") {\n        xa = minX - rnd.next(1, 1000);\n        ya = rnd.next(minY, maxY);\n    } else if (A_position == \"right\") {\n        xa = maxX + rnd.next(1, 1000);\n        ya = rnd.next(minY, maxY);\n    } else if (A_position == \"far\") {\n        xa = rnd.next(-10000, 10000);\n        ya = rnd.next(-10000, 10000);\n        while (xa >= minX - margin && xa <= maxX + margin && ya >= minY - margin && ya <= maxY + margin) {\n            xa = rnd.next(-10000, 10000);\n            ya = rnd.next(-10000, 10000);\n        }\n    } else if (A_position == \"near\") {\n        int side = rnd.next(4);\n        if (side == 0) { // above\n            xa = rnd.next(minX, maxX);\n            ya = maxY + rnd.next(1, 10);\n        } else if (side == 1) { // below\n            xa = rnd.next(minX, maxX);\n            ya = minY - rnd.next(1, 10);\n        } else if (side == 2) { // left\n            xa = minX - rnd.next(1, 10);\n            ya = rnd.next(minY, maxY);\n        } else { // right\n            xa = maxX + rnd.next(1, 10);\n            ya = rnd.next(minY, maxY);\n        }\n    } else { // random\n        xa = rnd.next(-10000, 10000);\n        ya = rnd.next(-10000, 10000);\n        while (xa >= minX && xa <= maxX && ya >= minY && ya <= maxY) {\n            xa = rnd.next(-10000, 10000);\n            ya = rnd.next(-10000, 10000);\n        }\n    }\n    return make_pair(xa, ya);\n}\n\nvoid output_polygon() {\n    int n = polygon.size();\n    printf(\"%d\\n\", n);\n    for (auto& v : polygon) {\n        printf(\"%d %d\\n\", v.first, v.second);\n    }\n}\n\nvoid generate_speeds(string speed_type, int& xv, int& yv, int& zv, int& Fdown, int& xu, int& yu, int& zu) {\n    if (speed_type == \"random\") {\n        // Plane speeds\n        xv = rnd.next(-1000, 1000);\n        yv = rnd.next(-1000, 1000);\n        zv = rnd.next(1, 1000); // zv > 0\n\n        // Falling speed before opening parachute\n        Fdown = rnd.next(-1000, -1); // Fdown < 0\n\n        // Wind speeds after opening parachute\n        xu = rnd.next(-1000, 1000);\n        yu = rnd.next(-1000, 1000);\n        zu = rnd.next(-1000, -1); // zu < 0\n    } else if (speed_type == \"zero_wind\") {\n        // Plane speeds\n        xv = rnd.next(-1000, 1000);\n        yv = rnd.next(-1000, 1000);\n        zv = rnd.next(1, 1000); // zv > 0\n\n        // Falling speed before opening parachute\n        Fdown = rnd.next(-1000, -1); // Fdown < 0\n\n        // Wind speeds after opening parachute\n        xu = 0;\n        yu = 0;\n        zu = rnd.next(-1000, -1); // zu < 0\n    } else if (speed_type == \"impossible\") {\n        // Speeds such that DravDe cannot reach the polygon\n        xv = yv = 0;\n        zv = rnd.next(1, 1000); // zv > 0\n\n        Fdown = rnd.next(-1000, -1); // Fdown < 0\n\n        xu = yu = 0;\n        zu = rnd.next(-1000, -1); // zu < 0\n    } else { // default random\n        xv = rnd.next(-1000, 1000);\n        yv = rnd.next(-1000, 1000);\n        zv = rnd.next(1, 1000); // zv > 0\n\n        Fdown = rnd.next(-1000, -1); // Fdown < 0\n\n        xu = rnd.next(-1000, 1000);\n        yu = rnd.next(-1000, 1000);\n        zu = rnd.next(-1000, -1); // zu < 0\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string polygon_type = opt<string>(\"polygon_type\", \"convex\");\n    string A_position = opt<string>(\"A_position\", \"random\");\n    string speed_type = opt<string>(\"speed_type\", \"random\");\n\n    if (polygon_type == \"square\") {\n        generate_square();\n    } else if (polygon_type == \"regular\") {\n        generate_regular_polygon(n);\n    } else { // default to convex polygon\n        generate_convex_polygon(n);\n    }\n\n    compute_bounding_box();\n    output_polygon();\n\n    pair<int, int> A = generate_point_A(A_position);\n    int xa = A.first;\n    int ya = A.second;\n\n    int xv, yv, zv, Fdown, xu, yu, zu;\n    generate_speeds(speed_type, xv, yv, zv, Fdown, xu, yu, zu);\n\n    printf(\"%d %d\\n\", xa, ya);\n    printf(\"%d %d %d\\n\", xv, yv, zv);\n    printf(\"%d\\n\", Fdown);\n    printf(\"%d %d %d\\n\", xu, yu, zu);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -polygon_type square -A_position above -speed_type random\n./gen -n 3 -polygon_type regular -A_position below -speed_type random\n./gen -n 3 -polygon_type convex -A_position left -speed_type random\n\n./gen -n 4 -polygon_type square -A_position right -speed_type random\n./gen -n 4 -polygon_type regular -A_position near -speed_type random\n./gen -n 4 -polygon_type convex -A_position far -speed_type random\n\n./gen -n 5 -polygon_type regular -A_position random -speed_type zero_wind\n./gen -n 5 -polygon_type convex -A_position above -speed_type impossible\n\n./gen -n 10 -polygon_type regular -A_position below -speed_type random\n./gen -n 10 -polygon_type convex -A_position left -speed_type random\n\n./gen -n 100 -polygon_type convex -A_position right -speed_type random\n./gen -n 100 -polygon_type regular -A_position above -speed_type random\n\n./gen -n 500 -polygon_type convex -A_position below -speed_type random\n./gen -n 500 -polygon_type regular -A_position random -speed_type random\n\n./gen -n 1000 -polygon_type convex -A_position near -speed_type random\n./gen -n 1000 -polygon_type square -A_position far -speed_type random\n\n./gen -n 5000 -polygon_type convex -A_position random -speed_type random\n./gen -n 5000 -polygon_type regular -A_position left -speed_type random\n\n./gen -n 10000 -polygon_type convex -A_position right -speed_type random\n./gen -n 10000 -polygon_type regular -A_position above -speed_type random\n\n./gen -n 3 -polygon_type square -A_position above -speed_type zero_wind\n./gen -n 3 -polygon_type square -A_position below -speed_type impossible\n\n./gen -n 3 -polygon_type square -A_position near -speed_type random\n./gen -n 3 -polygon_type square -A_position far -speed_type random\n\n./gen -n 3 -polygon_type regular -A_position left -speed_type zero_wind\n./gen -n 3 -polygon_type regular -A_position right -speed_type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:22.577067",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "280/A",
      "title": "A. Rectangle Puzzle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers w, h, α (1 ≤ w, h ≤ 106; 0 ≤ α ≤ 180). Angle α is given in degrees.",
      "output_spec": "OutputIn a single line print a real number — the area of the region which belongs to both given rectangles.The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy1 1 45OutputCopy0.828427125InputCopy6 4 30OutputCopy19.668384925",
      "description": "A. Rectangle Puzzle\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers w, h, α (1 ≤ w, h ≤ 106; 0 ≤ α ≤ 180). Angle α is given in degrees.\n\nOutputIn a single line print a real number — the area of the region which belongs to both given rectangles.The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.\n\nInputCopy1 1 45OutputCopy0.828427125InputCopy6 4 30OutputCopy19.668384925\n\nInputCopy1 1 45\n\nOutputCopy0.828427125\n\nInputCopy6 4 30\n\nOutputCopy19.668384925\n\nNoteThe second sample has been drawn on the picture above.",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Hello there!Codeforces Round #172 will take place on Sunday, March 10th at 19:30 MSK(23:30 CST).This is my second time participating in prepration a Codeforces Round. Last time assist with YuukaKazami is an unforgettable experience. This time, the hardest problems were created by Jiatai Huang(CMHJT) and others by me and Yuping Luo(roosephu).Testers are sevenkplus, YuukaKazami, pashka and Seter.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Here let me express my personal thanks to the Codeforces community, which has given me so much gleamy idea in the past two years.Believe it or not, Codeforces has kept her feet in China's ACM community since last year. AFAIK, some of the hardest problems have been used as this year's Winter Camp homework for our National Olympiad in Informatics.Also thanks to watashi, ftiasch and xlk. Discussing problem with all of you, has inspired me a lot. 500 — 1000 — 1500 — 2000 — 2500.We are going to use a standard score distribution in both divisions.The problemset is a little bit easier than last time, but we still believe, getting all of those five problems accepeted will be a challenging mission even for an seasoned International Grandmaster. The problemset has been marriaged with variety flavor. Take a glance over all five problems before going to coding might be a wise strategy. UPD: The contest is over, congratulations to the winners:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Congratulation to tclsm2012, who also solve the problem D!We feel so pity to al13n, your last optimization for problem D is wrong. Problem D has a O(mklogn) algorithm. And we are extremely sorry to Jacob, your solution for problem E can pass most of the random tests but actually is wrong. Jacob... can you explain your solution for us :)We need collect some feedback about this round .. So the editorial will appear after a period of time. UPD:I used to hate those guys who set problems, but didn't write editorial at all! But when things turn to myself, I found it is really difficult to cover all cases. Anyway, it has been done.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2312
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 280 和字母"
          },
          "content_length": 6693
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces",
          "content": "This problem is hard because it might be impossible to consider a dynamic programming solution carefully and finally find the mystery.Let dp[i][j]=(the minimum transformation price to the moment if y1... yi have been determined and yi = j).It's easy to find that:dp[1][p] = (p - x1)2f[i][p] = min(dp[i - 1][q] | p - b ≤ q ≤ p - a)dp[i][p] = (p - xi)2 + f[i][p]Solutions using this idea straight can't pass because it needs very huge amount of memory and time(in fact it's infinite). So we should consider the problem more accurately.Here comes the magic: let dp[i] be a function for p.First of all, we'll use the monotonicity of its derivative dp[i]' and mathematical induction to prove that dp[i] is a strictly unimodal function. More strongly, we can prove dp[i]' is a strictly increasing function.dp[1]'(p) = 2(p - x[1]). Obviously so it is.If we have proved that dp[i]' is a strictly increasing function, and min dp[i] = dp[i](k). In addition, dp[i]'(k) = 0.For f[i + 1] at this moment: Notice that for the derivative, actually what we do is to cut dp[i]' at the place p = k, and then the left part (p ≤ k) moves to the right a units while the right part (p ≥ k) moves to the right b units. After this operation, the gap (k + a... k + b) is filled by 0 so that it's still a continuous function.We can find f[i + 1]' is also a increasing function but not strictly. Then dp[i + 1]'(p) = 2(p - xi + 1) + f[i + 1]'(p), now it's absolutely a strictly increasing function.Since we have proved any dp[i] is a strictly unimodal function, we can push xi one by one and calculate the function dp[i] immediately.Let's focus on the operation to dp[i]':Step 1. Determine k for dp[i]'(k) = 0.Step 2. Cutting, translation, and filling 0.Step 3. Add a linear function 2(p - xi).Because of step 2, the derivative is in reality a piecewise function, and any part of this function is a linear function. Besides, there are at most O(n) parts.Finally, We can use a simple array to hold all the endpoints. Since we should maintain at most O(n) endpoints for n times, the time complexity is O(n2).Hint 1.If you read the solution in earnest, you may have some questions.Q: Why can't I use ternary search for every k?Or even binary search?A: It's obviously right, but the time complexity is O(n2s) where s is times for the search. Either it will get TLE or the precision is not enough.Just like this :) Questions are welcomed.Hint 2.Can we go beyond O(n2)?Yes of course, by using some advanced data structures like a balanced tree with lazy tags. It's time for you to aftertaste and think more.UPDATEFigures from CMHJT for the input(not the sample input): 3 6 1 2\n1 4 6dp[1]:dp[1]':dp[2]:dp[2]':dp[3]:dp[3]':You can visually see that the minimum price is when",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6952",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2738
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 1",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 2",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 3",
          "code": "Danny Sleator <sleator@cs.cmu.edu>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int alpha = inf.readInt(0, 180);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int alpha = inf.readInt(0, 180);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int alpha = inf.readInt(0, 180);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int w = opt<int>(\"w\", -1); // default -1 indicates not provided\n    int h = opt<int>(\"h\", -1);\n    int angle = opt<int>(\"angle\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random w, h, angle within constraints, if not provided\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"zero_angle\") {\n        // Generate a test case with angle = 0\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 0;\n    } else if (type == \"ninety_angle\") {\n        // Generate a test case with angle = 90\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 90;\n    } else if (type == \"one_eighty_angle\") {\n        // Generate a test case with angle = 180\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 180;\n    } else if (type == \"max_w_h\") {\n        // Generate a test case with w and h at max values\n        w = 1000000;\n        h = 1000000;\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"min_w_h\") {\n        // Generate a test case with w and h at min values\n        w = 1;\n        h = 1;\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"square\") {\n        // Set w = h\n        if (w == -1 && h == -1) {\n            w = h = rnd.next(1, 1000000);\n        } else if (w == -1) {\n            w = h;\n        } else if (h == -1) {\n            h = w;\n        } else {\n            w = h = min(w, h);\n        }\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"rectangle\") {\n        // Set w != h\n        if (w == -1 && h == -1) {\n            w = rnd.next(1, 1000000);\n            do {\n                h = rnd.next(1, 1000000);\n            } while (h == w);\n        } else if (w == -1) {\n            do {\n                w = rnd.next(1, 1000000);\n            } while (w == h);\n        } else if (h == -1) {\n            do {\n                h = rnd.next(1, 1000000);\n            } while (h == w);\n        }\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"max_area\") {\n        // To get maximum overlapping area, angle should be 0 or 180\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 0;\n    } else if (type == \"min_area\") {\n        // To get minimal overlapping area, when angle is 90\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 90;\n    } else if (type == \"acute_angle\") {\n        // Angle between 1 and 89 degrees\n        if (angle == -1)\n            angle = rnd.next(1, 89);\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n    } else if (type == \"obtuse_angle\") {\n        // Angle between 91 and 179 degrees\n        if (angle == -1)\n            angle = rnd.next(91, 179);\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n    } else {\n        // Default: random case\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    }\n\n    // Ensure that w and h are within [1, 1e6]\n    w = max(1, min(w, 1000000));\n    h = max(1, min(h, 1000000));\n\n    // Ensure that angle is within [0,180]\n    angle = max(0, min(angle, 180));\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", w, h, angle);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int w = opt<int>(\"w\", -1); // default -1 indicates not provided\n    int h = opt<int>(\"h\", -1);\n    int angle = opt<int>(\"angle\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random w, h, angle within constraints, if not provided\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"zero_angle\") {\n        // Generate a test case with angle = 0\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 0;\n    } else if (type == \"ninety_angle\") {\n        // Generate a test case with angle = 90\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 90;\n    } else if (type == \"one_eighty_angle\") {\n        // Generate a test case with angle = 180\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 180;\n    } else if (type == \"max_w_h\") {\n        // Generate a test case with w and h at max values\n        w = 1000000;\n        h = 1000000;\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"min_w_h\") {\n        // Generate a test case with w and h at min values\n        w = 1;\n        h = 1;\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"square\") {\n        // Set w = h\n        if (w == -1 && h == -1) {\n            w = h = rnd.next(1, 1000000);\n        } else if (w == -1) {\n            w = h;\n        } else if (h == -1) {\n            h = w;\n        } else {\n            w = h = min(w, h);\n        }\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"rectangle\") {\n        // Set w != h\n        if (w == -1 && h == -1) {\n            w = rnd.next(1, 1000000);\n            do {\n                h = rnd.next(1, 1000000);\n            } while (h == w);\n        } else if (w == -1) {\n            do {\n                w = rnd.next(1, 1000000);\n            } while (w == h);\n        } else if (h == -1) {\n            do {\n                h = rnd.next(1, 1000000);\n            } while (h == w);\n        }\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    } else if (type == \"max_area\") {\n        // To get maximum overlapping area, angle should be 0 or 180\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 0;\n    } else if (type == \"min_area\") {\n        // To get minimal overlapping area, when angle is 90\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        angle = 90;\n    } else if (type == \"acute_angle\") {\n        // Angle between 1 and 89 degrees\n        if (angle == -1)\n            angle = rnd.next(1, 89);\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n    } else if (type == \"obtuse_angle\") {\n        // Angle between 91 and 179 degrees\n        if (angle == -1)\n            angle = rnd.next(91, 179);\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n    } else {\n        // Default: random case\n        if (w == -1)\n            w = rnd.next(1, 1000000);\n        if (h == -1)\n            h = rnd.next(1, 1000000);\n        if (angle == -1)\n            angle = rnd.next(0, 180);\n    }\n\n    // Ensure that w and h are within [1, 1e6]\n    w = max(1, min(w, 1000000));\n    h = max(1, min(h, 1000000));\n\n    // Ensure that angle is within [0,180]\n    angle = max(0, min(angle, 180));\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", w, h, angle);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type zero_angle\n./gen -type ninety_angle\n./gen -type one_eighty_angle\n./gen -type max_w_h\n./gen -type min_w_h\n./gen -type square\n./gen -type rectangle\n\n./gen -type max_area\n./gen -type min_area\n\n./gen -type acute_angle\n./gen -type obtuse_angle\n\n./gen -w 1 -h 1 -angle 0\n./gen -w 1 -h 1 -angle 90\n\n./gen -w 1000000 -h 1000000 -angle 0\n./gen -w 1000000 -h 1000000 -angle 90\n./gen -w 1000000 -h 1 -angle 0\n./gen -w 1000000 -h 1 -angle 90\n./gen -w 1 -h 1000000 -angle 0\n./gen -w 1 -h 1000000 -angle 90\n\n./gen -w 1000 -h 1000 -angle 45\n./gen -w 500000 -h 500000 -angle 45\n\n./gen -w 1 -h 1 -angle 180\n./gen -w 1 -h 1 -angle 179\n./gen -w 1 -h 1 -angle 1\n\n./gen -type random -w 123456 -h 654321 -angle 0\n./gen -type random -w 123456 -h 654321 -angle 90\n./gen -type random -w 123456 -h 654321 -angle 180\n./gen -type random -w 1000000 -h 999999 -angle 60\n./gen -type random -w 1000000 -h 888888 -angle 120\n\n./gen -type random -w 1 -h 1 -angle 45\n./gen -type random -w 1 -h 1000000 -angle 45\n./gen -type random -w 1000000 -h 1 -angle 45\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:24.261478",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "280/B",
      "title": "B. Maximum Xor Secondary",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 < n ≤ 105). The second line contains n distinct integers s1, s2, ..., sn (1 ≤ si ≤ 109).",
      "output_spec": "OutputPrint a single integer — the maximum lucky number among all lucky numbers of sequences s[l..r].",
      "sample_tests": "ExamplesInputCopy55 2 1 4 3OutputCopy7InputCopy59 8 3 5 7OutputCopy15",
      "description": "B. Maximum Xor Secondary\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 < n ≤ 105). The second line contains n distinct integers s1, s2, ..., sn (1 ≤ si ≤ 109).\n\nOutputPrint a single integer — the maximum lucky number among all lucky numbers of sequences s[l..r].\n\nInputCopy55 2 1 4 3OutputCopy7InputCopy59 8 3 5 7OutputCopy15\n\nInputCopy55 2 1 4 3\n\nOutputCopy7\n\nInputCopy59 8 3 5 7\n\nOutputCopy15\n\nNoteFor the first sample you can choose s[4..5] = {4, 3} and its lucky number is (4 xor 3) = 7. You can also choose s[1..2].For the second sample you must choose s[2..5] = {8, 3, 5, 7}.",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Hello there!Codeforces Round #172 will take place on Sunday, March 10th at 19:30 MSK(23:30 CST).This is my second time participating in prepration a Codeforces Round. Last time assist with YuukaKazami is an unforgettable experience. This time, the hardest problems were created by Jiatai Huang(CMHJT) and others by me and Yuping Luo(roosephu).Testers are sevenkplus, YuukaKazami, pashka and Seter.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Here let me express my personal thanks to the Codeforces community, which has given me so much gleamy idea in the past two years.Believe it or not, Codeforces has kept her feet in China's ACM community since last year. AFAIK, some of the hardest problems have been used as this year's Winter Camp homework for our National Olympiad in Informatics.Also thanks to watashi, ftiasch and xlk. Discussing problem with all of you, has inspired me a lot. 500 — 1000 — 1500 — 2000 — 2500.We are going to use a standard score distribution in both divisions.The problemset is a little bit easier than last time, but we still believe, getting all of those five problems accepeted will be a challenging mission even for an seasoned International Grandmaster. The problemset has been marriaged with variety flavor. Take a glance over all five problems before going to coding might be a wise strategy. UPD: The contest is over, congratulations to the winners:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Congratulation to tclsm2012, who also solve the problem D!We feel so pity to al13n, your last optimization for problem D is wrong. Problem D has a O(mklogn) algorithm. And we are extremely sorry to Jacob, your solution for problem E can pass most of the random tests but actually is wrong. Jacob... can you explain your solution for us :)We need collect some feedback about this round .. So the editorial will appear after a period of time. UPD:I used to hate those guys who set problems, but didn't write editorial at all! But when things turn to myself, I found it is really difficult to cover all cases. Anyway, it has been done.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2312
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 280 和字母"
          },
          "content_length": 6693
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces",
          "content": "This problem is hard because it might be impossible to consider a dynamic programming solution carefully and finally find the mystery.Let dp[i][j]=(the minimum transformation price to the moment if y1... yi have been determined and yi = j).It's easy to find that:dp[1][p] = (p - x1)2f[i][p] = min(dp[i - 1][q] | p - b ≤ q ≤ p - a)dp[i][p] = (p - xi)2 + f[i][p]Solutions using this idea straight can't pass because it needs very huge amount of memory and time(in fact it's infinite). So we should consider the problem more accurately.Here comes the magic: let dp[i] be a function for p.First of all, we'll use the monotonicity of its derivative dp[i]' and mathematical induction to prove that dp[i] is a strictly unimodal function. More strongly, we can prove dp[i]' is a strictly increasing function.dp[1]'(p) = 2(p - x[1]). Obviously so it is.If we have proved that dp[i]' is a strictly increasing function, and min dp[i] = dp[i](k). In addition, dp[i]'(k) = 0.For f[i + 1] at this moment: Notice that for the derivative, actually what we do is to cut dp[i]' at the place p = k, and then the left part (p ≤ k) moves to the right a units while the right part (p ≥ k) moves to the right b units. After this operation, the gap (k + a... k + b) is filled by 0 so that it's still a continuous function.We can find f[i + 1]' is also a increasing function but not strictly. Then dp[i + 1]'(p) = 2(p - xi + 1) + f[i + 1]'(p), now it's absolutely a strictly increasing function.Since we have proved any dp[i] is a strictly unimodal function, we can push xi one by one and calculate the function dp[i] immediately.Let's focus on the operation to dp[i]':Step 1. Determine k for dp[i]'(k) = 0.Step 2. Cutting, translation, and filling 0.Step 3. Add a linear function 2(p - xi).Because of step 2, the derivative is in reality a piecewise function, and any part of this function is a linear function. Besides, there are at most O(n) parts.Finally, We can use a simple array to hold all the endpoints. Since we should maintain at most O(n) endpoints for n times, the time complexity is O(n2).Hint 1.If you read the solution in earnest, you may have some questions.Q: Why can't I use ternary search for every k?Or even binary search?A: It's obviously right, but the time complexity is O(n2s) where s is times for the search. Either it will get TLE or the precision is not enough.Just like this :) Questions are welcomed.Hint 2.Can we go beyond O(n2)?Yes of course, by using some advanced data structures like a balanced tree with lazy tags. It's time for you to aftertaste and think more.UPDATEFigures from CMHJT for the input(not the sample input): 3 6 1 2\n1 4 6dp[1]:dp[1]':dp[2]:dp[2]':dp[3]:dp[3]':You can visually see that the minimum price is when",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/6952",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2738
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "Qingyu"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 1",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "Qingyu"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 2",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "Qingyu"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 3",
          "code": "Danny Sleator <sleator@cs.cmu.edu>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> s = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    \n    set<int> unique_s(s.begin(), s.end());\n    ensuref(int(unique_s.size()) == n, \"All numbers in s must be distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> s = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    \n    set<int> unique_s(s.begin(), s.end());\n    ensuref(int(unique_s.size()) == n, \"All numbers in s must be distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> s = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    \n    set<int> unique_s(s.begin(), s.end());\n    ensuref(int(unique_s.size()) == n, \"All numbers in s must be distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random numbers between 1 and 1e9\n        set<int> used;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"ascending\") {\n        int start = 1;\n        for(int i = 0; i < n; ++i) {\n            s[i] = start;\n            // Ensure that we do not exceed the maximum value\n            int max_increment = (1000000000 - start - (n - i - 1));\n            int increment = rnd.next(1, min(100000, max_increment));\n            start += increment;\n        }\n    } else if (type == \"descending\") {\n        int start = 1000000000;\n        for(int i = 0; i < n; ++i) {\n            s[i] = start;\n            // Ensure that we do not go below 1\n            int max_decrement = (start - 1 - (n - i - 1));\n            int decrement = rnd.next(1, min(100000, max_decrement));\n            start -= decrement;\n        }\n    } else if (type == \"adjacent_maxes\") {\n        // Generate sequence where maximum and second maximum are adjacent\n        int max1 = rnd.next(1, 1000000000);\n        int max2;\n        do {\n            max2 = rnd.next(1, 1000000000);\n        } while (max2 == max1);\n        if (max2 > max1) swap(max1, max2); // Ensure max1 > max2\n        int pos = rnd.next(0, n-2); // Position for max1 and max2\n        s[pos] = max1;\n        s[pos+1] = max2;\n\n        set<int> used;\n        used.insert(max1);\n        used.insert(max2);\n        for(int i = 0; i < n; ++i) {\n            if (i == pos || i == pos+1) continue;\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"distant_maxes\") {\n        // Place max and second max at the ends\n        int max1 = rnd.next(1, 1000000000);\n        int max2;\n        do {\n            max2 = rnd.next(1, 1000000000);\n        } while (max2 == max1);\n        if (max2 > max1) swap(max1, max2); // Ensure max1 > max2\n        s[0] = max1;\n        s[n-1] = max2;\n        set<int> used;\n        used.insert(max1);\n        used.insert(max2);\n        for(int i = 1; i < n-1; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"maxlucky\") {\n        // Generate numbers to maximize the lucky number\n        int max1 = 1000000000; // Maximum allowed value\n        int max2 = 536870911; // A number to maximize the XOR result\n        s[0] = max1;\n        s[1] = max2;\n        set<int> used;\n        used.insert(max1);\n        used.insert(max2);\n        for(int i = 2; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n        shuffle(s.begin(), s.end());\n    } else {\n        // Default: generate n distinct random numbers\n        set<int> used;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    }\n\n    // Output n and the sequence\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", s[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random numbers between 1 and 1e9\n        set<int> used;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"ascending\") {\n        int start = 1;\n        for(int i = 0; i < n; ++i) {\n            s[i] = start;\n            // Ensure that we do not exceed the maximum value\n            int max_increment = (1000000000 - start - (n - i - 1));\n            int increment = rnd.next(1, min(100000, max_increment));\n            start += increment;\n        }\n    } else if (type == \"descending\") {\n        int start = 1000000000;\n        for(int i = 0; i < n; ++i) {\n            s[i] = start;\n            // Ensure that we do not go below 1\n            int max_decrement = (start - 1 - (n - i - 1));\n            int decrement = rnd.next(1, min(100000, max_decrement));\n            start -= decrement;\n        }\n    } else if (type == \"adjacent_maxes\") {\n        // Generate sequence where maximum and second maximum are adjacent\n        int max1 = rnd.next(1, 1000000000);\n        int max2;\n        do {\n            max2 = rnd.next(1, 1000000000);\n        } while (max2 == max1);\n        if (max2 > max1) swap(max1, max2); // Ensure max1 > max2\n        int pos = rnd.next(0, n-2); // Position for max1 and max2\n        s[pos] = max1;\n        s[pos+1] = max2;\n\n        set<int> used;\n        used.insert(max1);\n        used.insert(max2);\n        for(int i = 0; i < n; ++i) {\n            if (i == pos || i == pos+1) continue;\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"distant_maxes\") {\n        // Place max and second max at the ends\n        int max1 = rnd.next(1, 1000000000);\n        int max2;\n        do {\n            max2 = rnd.next(1, 1000000000);\n        } while (max2 == max1);\n        if (max2 > max1) swap(max1, max2); // Ensure max1 > max2\n        s[0] = max1;\n        s[n-1] = max2;\n        set<int> used;\n        used.insert(max1);\n        used.insert(max2);\n        for(int i = 1; i < n-1; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"maxlucky\") {\n        // Generate numbers to maximize the lucky number\n        int max1 = 1000000000; // Maximum allowed value\n        int max2 = 536870911; // A number to maximize the XOR result\n        s[0] = max1;\n        s[1] = max2;\n        set<int> used;\n        used.insert(max1);\n        used.insert(max2);\n        for(int i = 2; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n        shuffle(s.begin(), s.end());\n    } else {\n        // Default: generate n distinct random numbers\n        set<int> used;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    }\n\n    // Output n and the sequence\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", s[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type ascending\n./gen -n 2 -type descending\n./gen -n 2 -type adjacent_maxes\n./gen -n 2 -type distant_maxes\n./gen -n 2 -type maxlucky\n\n./gen -n 10 -type random\n./gen -n 10 -type ascending\n./gen -n 10 -type descending\n./gen -n 10 -type adjacent_maxes\n./gen -n 10 -type distant_maxes\n./gen -n 10 -type maxlucky\n\n./gen -n 100 -type random\n./gen -n 100 -type ascending\n./gen -n 100 -type descending\n./gen -n 100 -type adjacent_maxes\n./gen -n 100 -type distant_maxes\n./gen -n 100 -type maxlucky\n\n./gen -n 1000 -type random\n./gen -n 1000 -type ascending\n./gen -n 1000 -type descending\n./gen -n 1000 -type adjacent_maxes\n./gen -n 1000 -type distant_maxes\n./gen -n 1000 -type maxlucky\n\n./gen -n 100000 -type random\n./gen -n 100000 -type ascending\n./gen -n 100000 -type descending\n./gen -n 100000 -type adjacent_maxes\n./gen -n 100000 -type distant_maxes\n./gen -n 100000 -type maxlucky\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:25.958697",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "280/C",
      "title": "C. Игра на дереве",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество вершин дерева. В следующих n - 1 строках заданы ребра дерева. В i-той строке записаны целые числа ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — номера вершин, которые соединены i-тым ребром.Гарантируется, что заданный граф является деревом.",
      "output_spec": "Выходные данныеВыведите единственное вещественное число — математическое ожидание количества шагов в описанной игре.Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать21 2Выходные данныеСкопировать1.50000000000000000000Входные данныеСкопировать31 21 3Выходные данныеСкопировать2.00000000000000000000",
      "description": "C. Игра на дереве\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество вершин дерева. В следующих n - 1 строках заданы ребра дерева. В i-той строке записаны целые числа ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — номера вершин, которые соединены i-тым ребром.Гарантируется, что заданный граф является деревом.\n\nВходные данные\n\nВыходные данныеВыведите единственное вещественное число — математическое ожидание количества шагов в описанной игре.Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать21 2Выходные данныеСкопировать1.50000000000000000000Входные данныеСкопировать31 21 3Выходные данныеСкопировать2.00000000000000000000\n\nВходные данныеСкопировать21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.50000000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 21 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.00000000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере возможны два случая. Первый — это сразу удалить корень, второй — удалить корень после одного шага. Таким образом, математическое ожидание количества шагов равно: 1 × (1 / 2) + 2 × (1 / 2) = 1.5Второй пример более сложный. Два случая из трех приводят нас к задаче, эквивалентной первому тестовому примеру, третий случай — удалить корень на первом шаге. Таким образом, математическое ожидание количества шагов равно: 1 × (1 / 3) + (1 + 1.5) × (2 / 3) = (1 / 3) + (5 / 3) = 2",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Всем привет!Раунд Codeforces #172 состоится в воскресенье, 10 марта, в 19.30 по московскому времени (23.30 по центральному поясному времени).Это мой второй раунд на Codeforces. До этого я готовил раунд вместе с YuukaKazami. В этот раз самые сложные задачи приготовил Jiatai Huang(CMHJT), другие приготовили я с Yuping Luo (roosephu).Наши тестеры — sevenkplus, YuukaKazami, OpalDshawn и pashka.Сердечно благодарим Геральда Агапова Gerald Agapov(Gerald) за помощь и советы по задачам, Delinur за помощь в переводе условий на русский и MikeMirzayanov, разработавшего такую мощную платформу.Я хотел бы лично поблагодарить сообщество Codeforces, вдохновлявшее меня на самые плодотворные идеи последние два года. Хотите – верьте, хотите – нет, но позиция Codeforces в китайском сообществе ACM укрепилась по сравнению с прошлым годом. Насколько мне известно, самые сложные задачи вошли в домашнее задание зимнего лагеря по подготовке к нашей национальной олимпиаде по информатике в этом году.Также благодарим watashi, ftiasch и xlk. Ваши предложения и замечания очень меня вдохновили. 500 — 1000 — 1500 — 2000 — 2500.Распределение баллов по задачам будет стандартным в обоих дивизионах.Эти задачи немного полегче, чем в прошлый раз, но мы все же верим, что расправиться со всеми пятью задачами будет непросто даже закаленному международному гроссмейстеру. Задачи будут самые разнообразные. Советую просмотреть все пять задач перед тем, как реализовывать.UPD: Соревнование закончилось, поздравления победителям:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Поздравления tclsm2012, кто решил задачу D!Нам очень жаль al13n, в вашем коде задачи D есть ошибка ... и Jacob, ваше решение задачи E проходит большую часть тестов, но на самом деле оно не правильное. Расскажите нам свое решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1850
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 280 和字母"
          },
          "content_length": 6693
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces",
          "content": "This problem is hard because it might be impossible to consider a dynamic programming solution carefully and finally find the mystery.Let dp[i][j]=(the minimum transformation price to the moment if y1... yi have been determined and yi = j).It's easy to find that:dp[1][p] = (p - x1)2f[i][p] = min(dp[i - 1][q] | p - b ≤ q ≤ p - a)dp[i][p] = (p - xi)2 + f[i][p]Solutions using this idea straight can't pass because it needs very huge amount of memory and time(in fact it's infinite). So we should consider the problem more accurately.Here comes the magic: let dp[i] be a function for p.First of all, we'll use the monotonicity of its derivative dp[i]' and mathematical induction to prove that dp[i] is a strictly unimodal function. More strongly, we can prove dp[i]' is a strictly increasing function.dp[1]'(p) = 2(p - x[1]). Obviously so it is.If we have proved that dp[i]' is a strictly increasing function, and min dp[i] = dp[i](k). In addition, dp[i]'(k) = 0.For f[i + 1] at this moment: Notice that for the derivative, actually what we do is to cut dp[i]' at the place p = k, and then the left part (p ≤ k) moves to the right a units while the right part (p ≥ k) moves to the right b units. After this operation, the gap (k + a... k + b) is filled by 0 so that it's still a continuous function.We can find f[i + 1]' is also a increasing function but not strictly. Then dp[i + 1]'(p) = 2(p - xi + 1) + f[i + 1]'(p), now it's absolutely a strictly increasing function.Since we have proved any dp[i] is a strictly unimodal function, we can push xi one by one and calculate the function dp[i] immediately.Let's focus on the operation to dp[i]':Step 1. Determine k for dp[i]'(k) = 0.Step 2. Cutting, translation, and filling 0.Step 3. Add a linear function 2(p - xi).Because of step 2, the derivative is in reality a piecewise function, and any part of this function is a linear function. Besides, there are at most O(n) parts.Finally, We can use a simple array to hold all the endpoints. Since we should maintain at most O(n) endpoints for n times, the time complexity is O(n2).Hint 1.If you read the solution in earnest, you may have some questions.Q: Why can't I use ternary search for every k?Or even binary search?A: It's obviously right, but the time complexity is O(n2s) where s is times for the search. Either it will get TLE or the precision is not enough.Just like this :) Questions are welcomed.Hint 2.Can we go beyond O(n2)?Yes of course, by using some advanced data structures like a balanced tree with lazy tags. It's time for you to aftertaste and think more.UPDATEFigures from CMHJT for the input(not the sample input): 3 6 1 2\n1 4 6dp[1]:dp[1]':dp[2]:dp[2]':dp[3]:dp[3]':You can visually see that the minimum price is when",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6952",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2738
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "if(a==0||a==180)\n{\n    printf(\"%.8f\", w*h);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": "if(a==0||a==180)\n{\n    printf(\"%.8f\", w*h);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 15",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 16",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 1",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 2",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 3",
          "code": "Danny Sleator <sleator@cs.cmu.edu>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\n\nint par[MAXN];\n\nint find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) {\n        ensuref(false, \"Cycle detected when adding edge between %d and %d\", a, b);\n    }\n    par[a] = b;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) par[i] = i;\n    int components = n;\n    for (int i = 1; i <= n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.ensuref(a != b, \"Self-loop detected at edge %d: node %d\", i, a);\n        inf.readEoln();\n        unite(a, b);\n        --components;\n    }\n    ensuref(components == 1, \"The graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\n\nint par[MAXN];\n\nint find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) {\n        ensuref(false, \"Cycle detected when adding edge between %d and %d\", a, b);\n    }\n    par[a] = b;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) par[i] = i;\n    int components = n;\n    for (int i = 1; i <= n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.ensuref(a != b, \"Self-loop detected at edge %d: node %d\", i, a);\n        inf.readEoln();\n        unite(a, b);\n        --components;\n    }\n    ensuref(components == 1, \"The graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\n\nint par[MAXN];\n\nint find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) {\n        ensuref(false, \"Cycle detected when adding edge between %d and %d\", a, b);\n    }\n    par[a] = b;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) par[i] = i;\n    int components = n;\n    for (int i = 1; i <= n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.ensuref(a != b, \"Self-loop detected at edge %d: node %d\", i, a);\n        inf.readEoln();\n        unite(a, b);\n        --components;\n    }\n    ensuref(components == 1, \"The graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid print_edges(const vector<pair<int,int>> &edges) {\n    for(const auto &e : edges){\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        // Chain tree: each node connects to the previous node\n        for(int i = 2; i <= n; ++i){\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Star tree: all nodes connect directly to the root\n        for(int i = 2; i <= n; ++i){\n            edges.push_back({1, i});\n        }\n    } else if (type == \"skewed\") {\n        // Skewed tree: a long chain with leaves connected to the last node\n        int m = n / 2;\n        for(int i = 2; i <= m; ++i){\n            edges.push_back({i - 1, i});\n        }\n        for(int i = m + 1; i <= n; ++i){\n            edges.push_back({m, i});\n        }\n    } else if (type == \"balanced\") {\n        // Balanced binary tree\n        queue<int> q;\n        q.push(1);\n        int node = 2;\n        while(node <= n && !q.empty()){\n            int parent = q.front(); q.pop();\n            for(int i = 0; i < 2 && node <= n; ++i){\n                edges.push_back({parent, node});\n                q.push(node);\n                ++node;\n            }\n        }\n    } else if (type == \"caterpillar\") {\n        // Caterpillar tree\n        int backbone_length = max(1, n / 3);\n        for(int i = 2; i <= backbone_length; ++i){\n            edges.push_back({i - 1, i});\n        }\n        for(int i = backbone_length + 1; i <= n; ++i){\n            int attach_point = rnd.next(1, backbone_length);\n            edges.push_back({attach_point, i});\n        }\n    } else if (type == \"two_paths\") {\n        // Two long paths connected at the root\n        int half = (n - 1) / 2;\n        for(int i = 2; i <= half + 1; ++i){\n            edges.push_back({i - 1, i});\n        }\n        for(int i = half + 2; i <= n; ++i){\n            edges.push_back({i - 1, i});\n        }\n        edges.push_back({1, half + 2});  // Connect the second path to the root\n    } else {\n        // Random tree\n        for(int i = 2; i <= n; ++i){\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for(const auto &e : edges){\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid print_edges(const vector<pair<int,int>> &edges) {\n    for(const auto &e : edges){\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        // Chain tree: each node connects to the previous node\n        for(int i = 2; i <= n; ++i){\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Star tree: all nodes connect directly to the root\n        for(int i = 2; i <= n; ++i){\n            edges.push_back({1, i});\n        }\n    } else if (type == \"skewed\") {\n        // Skewed tree: a long chain with leaves connected to the last node\n        int m = n / 2;\n        for(int i = 2; i <= m; ++i){\n            edges.push_back({i - 1, i});\n        }\n        for(int i = m + 1; i <= n; ++i){\n            edges.push_back({m, i});\n        }\n    } else if (type == \"balanced\") {\n        // Balanced binary tree\n        queue<int> q;\n        q.push(1);\n        int node = 2;\n        while(node <= n && !q.empty()){\n            int parent = q.front(); q.pop();\n            for(int i = 0; i < 2 && node <= n; ++i){\n                edges.push_back({parent, node});\n                q.push(node);\n                ++node;\n            }\n        }\n    } else if (type == \"caterpillar\") {\n        // Caterpillar tree\n        int backbone_length = max(1, n / 3);\n        for(int i = 2; i <= backbone_length; ++i){\n            edges.push_back({i - 1, i});\n        }\n        for(int i = backbone_length + 1; i <= n; ++i){\n            int attach_point = rnd.next(1, backbone_length);\n            edges.push_back({attach_point, i});\n        }\n    } else if (type == \"two_paths\") {\n        // Two long paths connected at the root\n        int half = (n - 1) / 2;\n        for(int i = 2; i <= half + 1; ++i){\n            edges.push_back({i - 1, i});\n        }\n        for(int i = half + 2; i <= n; ++i){\n            edges.push_back({i - 1, i});\n        }\n        edges.push_back({1, half + 2});  // Connect the second path to the root\n    } else {\n        // Random tree\n        for(int i = 2; i <= n; ++i){\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for(const auto &e : edges){\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n./gen -n 1 -type star\n./gen -n 1 -type random\n\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type random\n\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random\n./gen -n 10 -type skewed\n./gen -n 10 -type balanced\n./gen -n 10 -type caterpillar\n./gen -n 10 -type two_paths\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type random\n./gen -n 1000 -type skewed\n./gen -n 1000 -type balanced\n./gen -n 1000 -type caterpillar\n./gen -n 1000 -type two_paths\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type random\n./gen -n 100000 -type skewed\n./gen -n 100000 -type balanced\n./gen -n 100000 -type caterpillar\n./gen -n 100000 -type two_paths\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:27.792680",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "280/D",
      "title": "D. k-Maximum Subsequence Sum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105), showing how many numbers the sequence has. The next line contains n integers a1, a2, ..., an (|ai| ≤ 500). The third line contains integer m (1 ≤ m ≤ 105) — the number of queries. The next m lines contain the queries in the format, given in the statement.All changing queries fit into limits: 1 ≤ i ≤ n, |val| ≤ 500.All queries to count the maximum sum of at most k non-intersecting subsegments fit into limits: 1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ 20. It is guaranteed that the number of the queries to count the maximum sum of at most k non-intersecting subsegments doesn't exceed 10000.",
      "output_spec": "OutputFor each query to count the maximum sum of at most k non-intersecting subsegments print the reply — the maximum sum. Print the answers to the queries in the order, in which the queries follow in the input.",
      "sample_tests": "ExamplesInputCopy99 -8 9 -1 -1 -1 9 -8 931 1 9 11 1 9 21 4 6 3OutputCopy17250InputCopy15-4 8 -3 -10 10 4 -7 -7 0 -6 3 8 -10 7 2151 3 9 21 6 12 10 6 50 10 -71 4 9 11 7 9 10 10 -31 4 10 21 3 13 21 4 11 20 15 -90 13 -90 11 -101 5 14 21 6 12 1OutputCopy1411150152618238",
      "description": "D. k-Maximum Subsequence Sum\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105), showing how many numbers the sequence has. The next line contains n integers a1, a2, ..., an (|ai| ≤ 500). The third line contains integer m (1 ≤ m ≤ 105) — the number of queries. The next m lines contain the queries in the format, given in the statement.All changing queries fit into limits: 1 ≤ i ≤ n, |val| ≤ 500.All queries to count the maximum sum of at most k non-intersecting subsegments fit into limits: 1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ 20. It is guaranteed that the number of the queries to count the maximum sum of at most k non-intersecting subsegments doesn't exceed 10000.\n\nOutputFor each query to count the maximum sum of at most k non-intersecting subsegments print the reply — the maximum sum. Print the answers to the queries in the order, in which the queries follow in the input.\n\nInputCopy99 -8 9 -1 -1 -1 9 -8 931 1 9 11 1 9 21 4 6 3OutputCopy17250InputCopy15-4 8 -3 -10 10 4 -7 -7 0 -6 3 8 -10 7 2151 3 9 21 6 12 10 6 50 10 -71 4 9 11 7 9 10 10 -31 4 10 21 3 13 21 4 11 20 15 -90 13 -90 11 -101 5 14 21 6 12 1OutputCopy1411150152618238\n\nInputCopy99 -8 9 -1 -1 -1 9 -8 931 1 9 11 1 9 21 4 6 3\n\nOutputCopy17250\n\nInputCopy15-4 8 -3 -10 10 4 -7 -7 0 -6 3 8 -10 7 2151 3 9 21 6 12 10 6 50 10 -71 4 9 11 7 9 10 10 -31 4 10 21 3 13 21 4 11 20 15 -90 13 -90 11 -101 5 14 21 6 12 1\n\nOutputCopy1411150152618238\n\nNoteIn the first query of the first example you can select a single pair (1, 9). So the described sum will be 17.Look at the second query of the first example. How to choose two subsegments? (1, 3) and (7, 9)? Definitely not, the sum we could get from (1, 3) and (7, 9) is 20, against the optimal configuration (1, 7) and (9, 9) with 25.The answer to the third query is 0, we prefer select nothing if all of the numbers in the given interval are negative.",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Hello there!Codeforces Round #172 will take place on Sunday, March 10th at 19:30 MSK(23:30 CST).This is my second time participating in prepration a Codeforces Round. Last time assist with YuukaKazami is an unforgettable experience. This time, the hardest problems were created by Jiatai Huang(CMHJT) and others by me and Yuping Luo(roosephu).Testers are sevenkplus, YuukaKazami, pashka and Seter.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Here let me express my personal thanks to the Codeforces community, which has given me so much gleamy idea in the past two years.Believe it or not, Codeforces has kept her feet in China's ACM community since last year. AFAIK, some of the hardest problems have been used as this year's Winter Camp homework for our National Olympiad in Informatics.Also thanks to watashi, ftiasch and xlk. Discussing problem with all of you, has inspired me a lot. 500 — 1000 — 1500 — 2000 — 2500.We are going to use a standard score distribution in both divisions.The problemset is a little bit easier than last time, but we still believe, getting all of those five problems accepeted will be a challenging mission even for an seasoned International Grandmaster. The problemset has been marriaged with variety flavor. Take a glance over all five problems before going to coding might be a wise strategy. UPD: The contest is over, congratulations to the winners:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Congratulation to tclsm2012, who also solve the problem D!We feel so pity to al13n, your last optimization for problem D is wrong. Problem D has a O(mklogn) algorithm. And we are extremely sorry to Jacob, your solution for problem E can pass most of the random tests but actually is wrong. Jacob... can you explain your solution for us :)We need collect some feedback about this round .. So the editorial will appear after a period of time. UPD:I used to hate those guys who set problems, but didn't write editorial at all! But when things turn to myself, I found it is really difficult to cover all cases. Anyway, it has been done.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2312
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 280 和字母"
          },
          "content_length": 6693
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces",
          "content": "This problem is hard because it might be impossible to consider a dynamic programming solution carefully and finally find the mystery.Let dp[i][j]=(the minimum transformation price to the moment if y1... yi have been determined and yi = j).It's easy to find that:dp[1][p] = (p - x1)2f[i][p] = min(dp[i - 1][q] | p - b ≤ q ≤ p - a)dp[i][p] = (p - xi)2 + f[i][p]Solutions using this idea straight can't pass because it needs very huge amount of memory and time(in fact it's infinite). So we should consider the problem more accurately.Here comes the magic: let dp[i] be a function for p.First of all, we'll use the monotonicity of its derivative dp[i]' and mathematical induction to prove that dp[i] is a strictly unimodal function. More strongly, we can prove dp[i]' is a strictly increasing function.dp[1]'(p) = 2(p - x[1]). Obviously so it is.If we have proved that dp[i]' is a strictly increasing function, and min dp[i] = dp[i](k). In addition, dp[i]'(k) = 0.For f[i + 1] at this moment: Notice that for the derivative, actually what we do is to cut dp[i]' at the place p = k, and then the left part (p ≤ k) moves to the right a units while the right part (p ≥ k) moves to the right b units. After this operation, the gap (k + a... k + b) is filled by 0 so that it's still a continuous function.We can find f[i + 1]' is also a increasing function but not strictly. Then dp[i + 1]'(p) = 2(p - xi + 1) + f[i + 1]'(p), now it's absolutely a strictly increasing function.Since we have proved any dp[i] is a strictly unimodal function, we can push xi one by one and calculate the function dp[i] immediately.Let's focus on the operation to dp[i]':Step 1. Determine k for dp[i]'(k) = 0.Step 2. Cutting, translation, and filling 0.Step 3. Add a linear function 2(p - xi).Because of step 2, the derivative is in reality a piecewise function, and any part of this function is a linear function. Besides, there are at most O(n) parts.Finally, We can use a simple array to hold all the endpoints. Since we should maintain at most O(n) endpoints for n times, the time complexity is O(n2).Hint 1.If you read the solution in earnest, you may have some questions.Q: Why can't I use ternary search for every k?Or even binary search?A: It's obviously right, but the time complexity is O(n2s) where s is times for the search. Either it will get TLE or the precision is not enough.Just like this :) Questions are welcomed.Hint 2.Can we go beyond O(n2)?Yes of course, by using some advanced data structures like a balanced tree with lazy tags. It's time for you to aftertaste and think more.UPDATEFigures from CMHJT for the input(not the sample input): 3 6 1 2\n1 4 6dp[1]:dp[1]':dp[2]:dp[2]':dp[3]:dp[3]':You can visually see that the minimum price is when",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6952",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2738
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 1",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 2",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 3",
          "code": "Danny Sleator <sleator@cs.cmu.edu>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -500, 500, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int type1_queries = 0;\n\n    for(int i = 0; i < m; i++) {\n        int t = inf.readInt(0, 1, \"t\");\n        inf.readSpace();\n        if(t == 0) {\n            int idx = inf.readInt(1, n, \"i\");\n            inf.readSpace();\n            int val = inf.readInt(-500, 500, \"val\");\n            inf.readEoln();\n        } else {\n            type1_queries++;\n            ensuref(type1_queries <= 10000, \"Number of type 1 queries can't exceed 10000\");\n\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(1, 20, \"k\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -500, 500, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int type1_queries = 0;\n\n    for(int i = 0; i < m; i++) {\n        int t = inf.readInt(0, 1, \"t\");\n        inf.readSpace();\n        if(t == 0) {\n            int idx = inf.readInt(1, n, \"i\");\n            inf.readSpace();\n            int val = inf.readInt(-500, 500, \"val\");\n            inf.readEoln();\n        } else {\n            type1_queries++;\n            ensuref(type1_queries <= 10000, \"Number of type 1 queries can't exceed 10000\");\n\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(1, 20, \"k\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -500, 500, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int type1_queries = 0;\n\n    for(int i = 0; i < m; i++) {\n        int t = inf.readInt(0, 1, \"t\");\n        inf.readSpace();\n        if(t == 0) {\n            int idx = inf.readInt(1, n, \"i\");\n            inf.readSpace();\n            int val = inf.readInt(-500, 500, \"val\");\n            inf.readEoln();\n        } else {\n            type1_queries++;\n            ensuref(type1_queries <= 10000, \"Number of type 1 queries can't exceed 10000\");\n\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(1, 20, \"k\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string arr_type = opt<string>(\"arr_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n    int k_value = opt<int>(\"k\", -1);  // -1 means random k between 1 and 20\n    int num_type1_queries = opt<int>(\"num_type1\", -1);\n    \n    vector<int> a(n);\n    if (arr_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-500, 500);\n        }\n    } else if (arr_type == \"all_positive\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500);\n        }\n    } else if (arr_type == \"all_negative\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-500, -1);\n        }\n    } else if (arr_type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = rnd.next(1, 500);\n            } else {\n                a[i] = rnd.next(-500, -1);\n            }\n        }\n    } else if (arr_type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (arr_type == \"max_abs\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1) ? 500 : -500;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-500, 500);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Determine the number of type 1 queries\n    int max_type1_queries = min(10000, m);\n    if (num_type1_queries == -1 || num_type1_queries > max_type1_queries) {\n        num_type1_queries = max_type1_queries;\n    }\n    if (query_type == \"updates_only\") {\n        num_type1_queries = 0;\n    } else if (query_type == \"queries_only\") {\n        num_type1_queries = min(10000, m);\n    }\n\n    int num_type0_queries = m - num_type1_queries;\n\n    vector<string> type1_queries;\n    vector<string> type0_queries;\n\n    // Generate type 1 queries\n    for (int i = 0; i < num_type1_queries; ++i) {\n        int l, r;\n        if (query_type == \"edge_cases\") {\n            if (i % 3 == 0) {\n                l = 1;\n                r = n;\n            } else if (i % 3 == 1) {\n                l = rnd.next(1, n);\n                r = l;\n            } else {\n                l = rnd.next(1, n);\n                r = rnd.next(l, n);\n            }\n        } else {\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n        }\n\n        int k;\n        if (k_value >= 1 && k_value <= 20) {\n            k = k_value;\n        } else {\n            k = rnd.next(1, 20);\n        }\n\n        type1_queries.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(k));\n    }\n\n    // Generate type 0 queries\n    for (int i = 0; i < num_type0_queries; ++i) {\n        int pos = rnd.next(1, n);\n        int val = rnd.next(-500, 500); // Constraints: |val| ≤ 500\n        type0_queries.push_back(\"0 \" + to_string(pos) + \" \" + to_string(val));\n    }\n\n    // Combine and shuffle the queries\n    vector<string> queries;\n    queries.reserve(m);\n    queries.insert(queries.end(), type1_queries.begin(), type1_queries.end());\n    queries.insert(queries.end(), type0_queries.begin(), type0_queries.end());\n    shuffle(queries.begin(), queries.end());\n\n    printf(\"%d\\n\", m);\n    for (size_t i = 0; i < queries.size(); ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }   \n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string arr_type = opt<string>(\"arr_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n    int k_value = opt<int>(\"k\", -1);  // -1 means random k between 1 and 20\n    int num_type1_queries = opt<int>(\"num_type1\", -1);\n    \n    vector<int> a(n);\n    if (arr_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-500, 500);\n        }\n    } else if (arr_type == \"all_positive\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500);\n        }\n    } else if (arr_type == \"all_negative\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-500, -1);\n        }\n    } else if (arr_type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = rnd.next(1, 500);\n            } else {\n                a[i] = rnd.next(-500, -1);\n            }\n        }\n    } else if (arr_type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (arr_type == \"max_abs\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1) ? 500 : -500;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-500, 500);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Determine the number of type 1 queries\n    int max_type1_queries = min(10000, m);\n    if (num_type1_queries == -1 || num_type1_queries > max_type1_queries) {\n        num_type1_queries = max_type1_queries;\n    }\n    if (query_type == \"updates_only\") {\n        num_type1_queries = 0;\n    } else if (query_type == \"queries_only\") {\n        num_type1_queries = min(10000, m);\n    }\n\n    int num_type0_queries = m - num_type1_queries;\n\n    vector<string> type1_queries;\n    vector<string> type0_queries;\n\n    // Generate type 1 queries\n    for (int i = 0; i < num_type1_queries; ++i) {\n        int l, r;\n        if (query_type == \"edge_cases\") {\n            if (i % 3 == 0) {\n                l = 1;\n                r = n;\n            } else if (i % 3 == 1) {\n                l = rnd.next(1, n);\n                r = l;\n            } else {\n                l = rnd.next(1, n);\n                r = rnd.next(l, n);\n            }\n        } else {\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n        }\n\n        int k;\n        if (k_value >= 1 && k_value <= 20) {\n            k = k_value;\n        } else {\n            k = rnd.next(1, 20);\n        }\n\n        type1_queries.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(k));\n    }\n\n    // Generate type 0 queries\n    for (int i = 0; i < num_type0_queries; ++i) {\n        int pos = rnd.next(1, n);\n        int val = rnd.next(-500, 500); // Constraints: |val| ≤ 500\n        type0_queries.push_back(\"0 \" + to_string(pos) + \" \" + to_string(val));\n    }\n\n    // Combine and shuffle the queries\n    vector<string> queries;\n    queries.reserve(m);\n    queries.insert(queries.end(), type1_queries.begin(), type1_queries.end());\n    queries.insert(queries.end(), type0_queries.begin(), type0_queries.end());\n    shuffle(queries.begin(), queries.end());\n\n    printf(\"%d\\n\", m);\n    for (size_t i = 0; i < queries.size(); ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }   \n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -arr_type random -query_type random\n./gen -n 5 -m 5 -arr_type all_positive -query_type random\n./gen -n 5 -m 5 -arr_type all_negative -query_type random\n./gen -n 5 -m 5 -arr_type alternating -query_type random\n./gen -n 1 -m 1 -arr_type random -query_type random\n./gen -n 1 -m 1 -arr_type all_positive -query_type random\n./gen -n 10 -m 10 -arr_type zeros -query_type random\n./gen -n 100 -m 100 -arr_type random -query_type random\n./gen -n 100 -m 100 -arr_type max_abs -query_type random\n./gen -n 1000 -m 1000 -arr_type random -query_type updates_only\n./gen -n 1000 -m 1000 -arr_type random -query_type queries_only -num_type1 1000\n./gen -n 10000 -m 10000 -arr_type random -query_type edge_cases -num_type1 10000\n./gen -n 100000 -m 100000 -arr_type random -query_type random\n./gen -n 100000 -m 100000 -arr_type all_positive -query_type random\n./gen -n 100000 -m 100000 -arr_type all_negative -query_type random\n./gen -n 100000 -m 100000 -arr_type alternating -query_type random\n./gen -n 100000 -m 100000 -arr_type zeros -query_type random\n./gen -n 100000 -m 100000 -arr_type max_abs -query_type random\n./gen -n 100000 -m 100000 -arr_type random -query_type updates_only\n./gen -n 100000 -m 10000 -arr_type random -query_type queries_only -num_type1 10000\n./gen -n 100000 -m 100000 -arr_type random -query_type random -k 1 -num_type1 10000\n./gen -n 100000 -m 100000 -arr_type random -query_type random -k 20 -num_type1 10000\n./gen -n 100000 -m 100000 -arr_type max_abs -query_type random\n./gen -n 100000 -m 100000 -arr_type random -query_type edge_cases -num_type1 10000\n./gen -n 100000 -m 100000 -arr_type random -query_type updates_only\n./gen -n 2 -m 100000 -arr_type random -query_type random -k 1 -num_type1 10000\n./gen -n 2 -m 100000 -arr_type random -query_type random -k 20 -num_type1 10000\n./gen -n 100000 -m 100000 -arr_type zeros -query_type random -num_type1 10000\n./gen -n 100000 -m 100000 -arr_type zeros -query_type updates_only\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:29.784559",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "280/E",
      "title": "E. Sequence Transformation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers n, q, a, b (2 ≤ n ≤ 6000; 1 ≤ q, a, b ≤ 109; a·(n - 1) < q; a ≤ b).The second line contains a non-decreasing integer sequence x1, x2, ..., xn (1 ≤ x1 ≤ x2 ≤ ... ≤ xn ≤ q).",
      "output_spec": "OutputIn the first line print n real numbers — the sought sequence y1, y2, ..., yn (1 ≤ yi ≤ q; a ≤ yi + 1 - yi ≤ b). In the second line print the minimum transformation price, that is, .If there are multiple optimal answers you can print any of them.The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy3 6 2 21 4 6OutputCopy1.666667 3.666667 5.666667 0.666667InputCopy10 100000 8714 93443378 14705 17588 22672 32405 34309 37446 51327 81228 94982OutputCopy1.000000 8715.000000 17429.000000 26143.000000 34857.000000 43571.000000 52285.000000 61629.000000 70973.000000 80317.000000 797708674.000000",
      "description": "E. Sequence Transformation\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four integers n, q, a, b (2 ≤ n ≤ 6000; 1 ≤ q, a, b ≤ 109; a·(n - 1) < q; a ≤ b).The second line contains a non-decreasing integer sequence x1, x2, ..., xn (1 ≤ x1 ≤ x2 ≤ ... ≤ xn ≤ q).\n\nOutputIn the first line print n real numbers — the sought sequence y1, y2, ..., yn (1 ≤ yi ≤ q; a ≤ yi + 1 - yi ≤ b). In the second line print the minimum transformation price, that is, .If there are multiple optimal answers you can print any of them.The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.\n\nInputCopy3 6 2 21 4 6OutputCopy1.666667 3.666667 5.666667 0.666667InputCopy10 100000 8714 93443378 14705 17588 22672 32405 34309 37446 51327 81228 94982OutputCopy1.000000 8715.000000 17429.000000 26143.000000 34857.000000 43571.000000 52285.000000 61629.000000 70973.000000 80317.000000 797708674.000000\n\nInputCopy3 6 2 21 4 6\n\nOutputCopy1.666667 3.666667 5.666667 0.666667\n\nInputCopy10 100000 8714 93443378 14705 17588 22672 32405 34309 37446 51327 81228 94982\n\nOutputCopy1.000000 8715.000000 17429.000000 26143.000000 34857.000000 43571.000000 52285.000000 61629.000000 70973.000000 80317.000000 797708674.000000",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Hello there!Codeforces Round #172 will take place on Sunday, March 10th at 19:30 MSK(23:30 CST).This is my second time participating in prepration a Codeforces Round. Last time assist with YuukaKazami is an unforgettable experience. This time, the hardest problems were created by Jiatai Huang(CMHJT) and others by me and Yuping Luo(roosephu).Testers are sevenkplus, YuukaKazami, pashka and Seter.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Here let me express my personal thanks to the Codeforces community, which has given me so much gleamy idea in the past two years.Believe it or not, Codeforces has kept her feet in China's ACM community since last year. AFAIK, some of the hardest problems have been used as this year's Winter Camp homework for our National Olympiad in Informatics.Also thanks to watashi, ftiasch and xlk. Discussing problem with all of you, has inspired me a lot. 500 — 1000 — 1500 — 2000 — 2500.We are going to use a standard score distribution in both divisions.The problemset is a little bit easier than last time, but we still believe, getting all of those five problems accepeted will be a challenging mission even for an seasoned International Grandmaster. The problemset has been marriaged with variety flavor. Take a glance over all five problems before going to coding might be a wise strategy. UPD: The contest is over, congratulations to the winners:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Congratulation to tclsm2012, who also solve the problem D!We feel so pity to al13n, your last optimization for problem D is wrong. Problem D has a O(mklogn) algorithm. And we are extremely sorry to Jacob, your solution for problem E can pass most of the random tests but actually is wrong. Jacob... can you explain your solution for us :)We need collect some feedback about this round .. So the editorial will appear after a period of time. UPD:I used to hate those guys who set problems, but didn't write editorial at all! But when things turn to myself, I found it is really difficult to cover all cases. Anyway, it has been done.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2312
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 280 和字母"
          },
          "content_length": 6693
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces",
          "content": "This problem is hard because it might be impossible to consider a dynamic programming solution carefully and finally find the mystery.Let dp[i][j]=(the minimum transformation price to the moment if y1... yi have been determined and yi = j).It's easy to find that:dp[1][p] = (p - x1)2f[i][p] = min(dp[i - 1][q] | p - b ≤ q ≤ p - a)dp[i][p] = (p - xi)2 + f[i][p]Solutions using this idea straight can't pass because it needs very huge amount of memory and time(in fact it's infinite). So we should consider the problem more accurately.Here comes the magic: let dp[i] be a function for p.First of all, we'll use the monotonicity of its derivative dp[i]' and mathematical induction to prove that dp[i] is a strictly unimodal function. More strongly, we can prove dp[i]' is a strictly increasing function.dp[1]'(p) = 2(p - x[1]). Obviously so it is.If we have proved that dp[i]' is a strictly increasing function, and min dp[i] = dp[i](k). In addition, dp[i]'(k) = 0.For f[i + 1] at this moment: Notice that for the derivative, actually what we do is to cut dp[i]' at the place p = k, and then the left part (p ≤ k) moves to the right a units while the right part (p ≥ k) moves to the right b units. After this operation, the gap (k + a... k + b) is filled by 0 so that it's still a continuous function.We can find f[i + 1]' is also a increasing function but not strictly. Then dp[i + 1]'(p) = 2(p - xi + 1) + f[i + 1]'(p), now it's absolutely a strictly increasing function.Since we have proved any dp[i] is a strictly unimodal function, we can push xi one by one and calculate the function dp[i] immediately.Let's focus on the operation to dp[i]':Step 1. Determine k for dp[i]'(k) = 0.Step 2. Cutting, translation, and filling 0.Step 3. Add a linear function 2(p - xi).Because of step 2, the derivative is in reality a piecewise function, and any part of this function is a linear function. Besides, there are at most O(n) parts.Finally, We can use a simple array to hold all the endpoints. Since we should maintain at most O(n) endpoints for n times, the time complexity is O(n2).Hint 1.If you read the solution in earnest, you may have some questions.Q: Why can't I use ternary search for every k?Or even binary search?A: It's obviously right, but the time complexity is O(n2s) where s is times for the search. Either it will get TLE or the precision is not enough.Just like this :) Questions are welcomed.Hint 2.Can we go beyond O(n2)?Yes of course, by using some advanced data structures like a balanced tree with lazy tags. It's time for you to aftertaste and think more.UPDATEFigures from CMHJT for the input(not the sample input): 3 6 1 2\n1 4 6dp[1]:dp[1]':dp[2]:dp[2]':dp[3]:dp[3]':You can visually see that the minimum price is when",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6952",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2738
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 1",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 2",
          "code": "3 6 1 2\n1 4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        },
        {
          "title": "CF #172 Div1 E Editorial - Codeforces - Code 3",
          "code": "Danny Sleator <sleator@cs.cmu.edu>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6952",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 6000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000000000, \"q\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    ensuref(1LL * a * (n - 1) < q, \"Constraint a*(n-1) < q violated: a=%d, n=%d, q=%d\", a, n, q);\n    ensuref(a <= b, \"Constraint a <= b violated: a=%d, b=%d\", a, b);\n\n    vector<int> x = inf.readInts(n, 1, q, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(x[i] <= x[i + 1], \"Sequence x is not non-decreasing at position %d: x[%d]=%d > x[%d]=%d\", i + 1, i + 1, x[i], i + 2, x[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 6000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000000000, \"q\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    ensuref(1LL * a * (n - 1) < q, \"Constraint a*(n-1) < q violated: a=%d, n=%d, q=%d\", a, n, q);\n    ensuref(a <= b, \"Constraint a <= b violated: a=%d, b=%d\", a, b);\n\n    vector<int> x = inf.readInts(n, 1, q, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(x[i] <= x[i + 1], \"Sequence x is not non-decreasing at position %d: x[%d]=%d > x[%d]=%d\", i + 1, i + 1, x[i], i + 2, x[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 6000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000000000, \"q\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    ensuref(1LL * a * (n - 1) < q, \"Constraint a*(n-1) < q violated: a=%d, n=%d, q=%d\", a, n, q);\n    ensuref(a <= b, \"Constraint a <= b violated: a=%d, b=%d\", a, b);\n\n    vector<int> x = inf.readInts(n, 1, q, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(x[i] <= x[i + 1], \"Sequence x is not non-decreasing at position %d: x[%d]=%d > x[%d]=%d\", i + 1, i + 1, x[i], i + 2, x[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1E-8;\nconst double MAX_DOUBLE_ERROR = 1E-6;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(2, 6000, \"n\");\n    long long q = inf.readLong(1, 1000000000LL, \"q\");\n    long long a = inf.readLong(1, 1000000000LL, \"a\");\n    long long b = inf.readLong(a, 1000000000LL, \"b\");\n    if (a * (n - 1) >= q)\n        quitf(_fail, \"Invalid input: a * (n - 1) >= q\");\n\n    vector<double> x(n);\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, int(q), format(\"x[%d]\", i + 1).c_str());\n        x[i] = (double)xi;\n        if (i > 0 && x[i] < x[i - 1]) {\n            quitf(_fail, \"Input sequence x is not non-decreasing at position %d\", i + 1);\n        }\n    }\n\n    vector<double> y(n);\n    for (int i = 0; i < n; ++i) {\n        y[i] = ouf.readDouble(1.0 - EPS, (double)q + EPS, format(\"y[%d]\", i + 1).c_str());\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        double diff = y[i + 1] - y[i];\n        if (diff + EPS < a) {\n            quitf(_wa, \"Difference y[%d] - y[%d] = %.10f is less than a = %lld\", i + 2, i + 1, diff, a);\n        }\n        if (diff - EPS > b) {\n            quitf(_wa, \"Difference y[%d] - y[%d] = %.10f is greater than b = %lld\", i + 2, i + 1, diff, b);\n        }\n    }\n\n    double s = 0.0;\n    for (int i = 0; i < n; ++i) {\n        double diff = y[i] - x[i];\n        s += diff * diff;\n    }\n\n    double z = ouf.readDouble(0.0, 1E30, \"total price\");\n\n    if (!doubleCompare(s, z, MAX_DOUBLE_ERROR))\n        quitf(_wa, \"Total price is incorrect: expected %.10f, found %.10f\", s, z);\n\n    quitf(_ok, \"Total price = %.10f\", s);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse input parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int a = opt<int>(\"a\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure the constraints are satisfied\n    ensure(2 <= n && n <= 6000);\n    ensure(1 <= q && q <= 1000000000);\n    ensure(1 <= a && a <= b && b <= 1000000000);\n    ensure(1LL * a * (n - 1) < q);\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        // Generate a random non-decreasing sequence\n        for (int i = 0; i < n; ++i)\n            x[i] = rnd.next(1, q);\n        sort(x.begin(), x.end());\n    }\n    else if (type == \"same\") {\n        // All elements are the same\n        int c = rnd.next(1, q);\n        for (int i = 0; i < n; ++i)\n            x[i] = c;\n    }\n    else if (type == \"sequential\") {\n        // Elements increase sequentially\n        int max_c = q - n + 1;\n        int c = rnd.next(1, max_c);\n        for (int i = 0; i < n; ++i)\n            x[i] = c + i;\n    }\n    else if (type == \"big_jumps\") {\n        // Elements increase by large amounts\n        x[0] = rnd.next(1, std::max(1, q / n));\n        for (int i = 1; i < n; ++i) {\n            int remain = q - x[i - 1] - (n - i);\n            int min_incr = std::max(1, remain / (n - i + 1));\n            int max_incr = remain / (n - i);\n            int incr = rnd.next(min_incr, max_incr);\n            x[i] = x[i - 1] + incr;\n        }\n    }\n    else if (type == \"min_x\") {\n        // All elements are at minimum value\n        for (int i = 0; i < n; ++i)\n            x[i] = 1;\n    }\n    else if (type == \"max_x\") {\n        // All elements are at maximum value\n        for (int i = 0; i < n; ++i)\n            x[i] = q;\n    }\n    else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            x[i] = rnd.next(1, q);\n        sort(x.begin(), x.end());\n    }\n\n    // Output n, q, a, b\n    printf(\"%d %d %d %d\\n\", n, q, a, b);\n\n    // Output the sequence x1, x2, ..., xn\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse input parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int a = opt<int>(\"a\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure the constraints are satisfied\n    ensure(2 <= n && n <= 6000);\n    ensure(1 <= q && q <= 1000000000);\n    ensure(1 <= a && a <= b && b <= 1000000000);\n    ensure(1LL * a * (n - 1) < q);\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        // Generate a random non-decreasing sequence\n        for (int i = 0; i < n; ++i)\n            x[i] = rnd.next(1, q);\n        sort(x.begin(), x.end());\n    }\n    else if (type == \"same\") {\n        // All elements are the same\n        int c = rnd.next(1, q);\n        for (int i = 0; i < n; ++i)\n            x[i] = c;\n    }\n    else if (type == \"sequential\") {\n        // Elements increase sequentially\n        int max_c = q - n + 1;\n        int c = rnd.next(1, max_c);\n        for (int i = 0; i < n; ++i)\n            x[i] = c + i;\n    }\n    else if (type == \"big_jumps\") {\n        // Elements increase by large amounts\n        x[0] = rnd.next(1, std::max(1, q / n));\n        for (int i = 1; i < n; ++i) {\n            int remain = q - x[i - 1] - (n - i);\n            int min_incr = std::max(1, remain / (n - i + 1));\n            int max_incr = remain / (n - i);\n            int incr = rnd.next(min_incr, max_incr);\n            x[i] = x[i - 1] + incr;\n        }\n    }\n    else if (type == \"min_x\") {\n        // All elements are at minimum value\n        for (int i = 0; i < n; ++i)\n            x[i] = 1;\n    }\n    else if (type == \"max_x\") {\n        // All elements are at maximum value\n        for (int i = 0; i < n; ++i)\n            x[i] = q;\n    }\n    else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            x[i] = rnd.next(1, q);\n        sort(x.begin(), x.end());\n    }\n\n    // Output n, q, a, b\n    printf(\"%d %d %d %d\\n\", n, q, a, b);\n\n    // Output the sequence x1, x2, ..., xn\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, minimal values\n./gen -n 2 -q 10 -a 1 -b 1 -type min_x\n./gen -n 2 -q 10 -a 1 -b 1 -type max_x\n./gen -n 2 -q 10 -a 1 -b 1 -type same\n./gen -n 2 -q 10 -a 1 -b 1 -type sequential\n./gen -n 2 -q 10 -a 1 -b 1 -type random\n\n# Medium n, minimal a and b\n./gen -n 10 -q 100 -a 1 -b 1 -type min_x\n./gen -n 10 -q 100 -a 1 -b 1 -type max_x\n./gen -n 10 -q 100 -a 1 -b 1 -type same\n./gen -n 10 -q 100 -a 1 -b 1 -type sequential\n./gen -n 10 -q 100 -a 1 -b 1 -type random\n\n# Larger n, varying a and b\n./gen -n 100 -q 1000 -a 1 -b 1 -type min_x\n./gen -n 100 -q 1000 -a 1 -b 1 -type max_x\n./gen -n 100 -q 1000 -a 1 -b 1 -type same\n./gen -n 100 -q 1000 -a 1 -b 1 -type sequential\n./gen -n 100 -q 1000 -a 1 -b 1 -type random\n\n# Large n, larger a and b\n./gen -n 1000 -q 1000000 -a 1 -b 10000 -type random\n./gen -n 1000 -q 1000000 -a 5000 -b 10000 -type big_jumps\n./gen -n 1000 -q 1000000000 -a 1000000 -b 1000000 -type sequential\n\n# Maximum n, maximum q\n./gen -n 6000 -q 1000000000 -a 1 -b 1000000 -type random\n./gen -n 6000 -q 1000000000 -a 1000000 -b 1000000 -type sequential\n\n# Edge cases with minimum x values\n./gen -n 6000 -q 6000 -a 1 -b 1 -type min_x\n./gen -n 6000 -q 6000 -a 1 -b 1 -type sequential\n\n# Edge cases with maximum x values\n./gen -n 6000 -q 1000000000 -a 1 -b 1 -type max_x\n./gen -n 6000 -q 1000000000 -a 1 -b 1 -type big_jumps\n\n# Edge case where a(n - 1) is close to q\n./gen -n 6000 -q 1000000000 -a 166666 -b 166666 -type random\n\n# Edge case with a = b = q / (n - 1)\n./gen -n 6000 -q 1000000000 -a 166666 -b 166666 -type sequential\n\n# Random tests with varied a and b\n./gen -n 5000 -q 800000000 -a 10000 -b 20000 -type random\n./gen -n 4000 -q 700000000 -a 5000 -b 10000 -type big_jumps\n\n# Tests with a = b = 1\n./gen -n 6000 -q 6000 -a 1 -b 1 -type random\n./gen -n 6000 -q 6000 -a 1 -b 1 -type same\n\n# Tests with maximum possible a and b\n./gen -n 3000 -q 1000000000 -a 333333 -b 333333 -type random\n./gen -n 3000 -q 1000000000 -a 333333 -b 333333 -type sequential\n\n# Random tests with small q\n./gen -n 5000 -q 50000 -a 1 -b 10 -type random\n\n# Sequential test with maximum increments\n./gen -n 6000 -q 1000000000 -a 166666 -b 166666 -type sequential\n\n# Random test cases\n./gen -n 6000 -q 999999999 -a 1 -b 100000000 -type random\n./gen -n 6000 -q 999999999 -a 50000 -b 100000000 -type big_jumps\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:31.718983",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "281/A",
      "title": "A. Word Capitalization",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.",
      "output_spec": "OutputOutput the given word after capitalization.",
      "sample_tests": "ExamplesInputCopyApPLeOutputCopyApPLeInputCopykonjacOutputCopyKonjac",
      "description": "A. Word Capitalization\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.\n\nOutputOutput the given word after capitalization.\n\nInputCopyApPLeOutputCopyApPLeInputCopykonjacOutputCopyKonjac\n\nInputCopyApPLe\n\nOutputCopyApPLe\n\nInputCopykonjac\n\nOutputCopyKonjac",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Hello there!Codeforces Round #172 will take place on Sunday, March 10th at 19:30 MSK(23:30 CST).This is my second time participating in prepration a Codeforces Round. Last time assist with YuukaKazami is an unforgettable experience. This time, the hardest problems were created by Jiatai Huang(CMHJT) and others by me and Yuping Luo(roosephu).Testers are sevenkplus, YuukaKazami, pashka and Seter.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Here let me express my personal thanks to the Codeforces community, which has given me so much gleamy idea in the past two years.Believe it or not, Codeforces has kept her feet in China's ACM community since last year. AFAIK, some of the hardest problems have been used as this year's Winter Camp homework for our National Olympiad in Informatics.Also thanks to watashi, ftiasch and xlk. Discussing problem with all of you, has inspired me a lot. 500 — 1000 — 1500 — 2000 — 2500.We are going to use a standard score distribution in both divisions.The problemset is a little bit easier than last time, but we still believe, getting all of those five problems accepeted will be a challenging mission even for an seasoned International Grandmaster. The problemset has been marriaged with variety flavor. Take a glance over all five problems before going to coding might be a wise strategy. UPD: The contest is over, congratulations to the winners:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Congratulation to tclsm2012, who also solve the problem D!We feel so pity to al13n, your last optimization for problem D is wrong. Problem D has a O(mklogn) algorithm. And we are extremely sorry to Jacob, your solution for problem E can pass most of the random tests but actually is wrong. Jacob... can you explain your solution for us :)We need collect some feedback about this round .. So the editorial will appear after a period of time. UPD:I used to hate those guys who set problems, but didn't write editorial at all! But when things turn to myself, I found it is really difficult to cover all cases. Anyway, it has been done.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2312
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 281 和字母"
          },
          "content_length": 6693
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-zA-Z]{1,1000}\", \"word\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-zA-Z]{1,1000}\", \"word\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-zA-Z]{1,1000}\", \"word\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within [1, 1000]\n    if (n < 1) n = 1;\n    if (n > 1000) n = 1000;\n\n    string word;\n\n    if (type == \"random\") {\n        // Generate random letters, random case\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26); // random lowercase letter\n            if (rnd.next(2)) {\n                c = toupper(c);\n            }\n            word += c;\n        }\n    } else if (type == \"all_lower\") {\n        // All lowercase letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"all_upper\") {\n        // All uppercase letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"first_upper\") {\n        // First letter uppercase, rest unchanged\n        if (n >= 1) {\n            char c = 'A' + rnd.next(26);\n            word += c;\n        }\n        for (int i = 1; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"first_lower\") {\n        // First letter lowercase, rest unchanged\n        if (n >= 1) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n        for (int i = 1; i < n; ++i) {\n            char c = 'A' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"mixed\") {\n        // Random letters with random case\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (rnd.next(2)) {\n                c = toupper(c);\n            }\n            word += c;\n        }\n    } else if (type == \"single_upper\") {\n        // Single uppercase character\n        n = 1;\n        char c = 'A' + rnd.next(26);\n        word += c;\n    } else if (type == \"single_lower\") {\n        // Single lowercase character\n        n = 1;\n        char c = 'a' + rnd.next(26);\n        word += c;\n    } else if (type == \"max_length\") {\n        // Maximum length (1000)\n        n = 1000;\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"min_length\") {\n        // Minimum length (1)\n        n = 1;\n        char c = 'a' + rnd.next(26);\n        word += c;\n    } else if (type == \"special1\") {\n        // All 'a's\n        for (int i = 0; i < n; ++i) {\n            word += 'a';\n        }\n    } else if (type == \"special2\") {\n        // All 'A's\n        for (int i = 0; i < n; ++i) {\n            word += 'A';\n        }\n    } else if (type == \"special3\") {\n        // Alternating 'a' and 'A'\n        for (int i = 0; i < n; ++i) {\n            char c = (i % 2 == 0) ? 'a' : 'A';\n            word += c;\n        }\n    } else if (type == \"edge_letters\") {\n        // Use letters 'a', 'z', 'A', 'Z'\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(4);\n            char c;\n            if (choice == 0)\n                c = 'a';\n            else if (choice == 1)\n                c = 'z';\n            else if (choice == 2)\n                c = 'A';\n            else\n                c = 'Z';\n            word += c;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (rnd.next(2)) {\n                c = toupper(c);\n            }\n            word += c;\n        }\n    }\n\n    // Output the word\n    printf(\"%s\\n\", word.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within [1, 1000]\n    if (n < 1) n = 1;\n    if (n > 1000) n = 1000;\n\n    string word;\n\n    if (type == \"random\") {\n        // Generate random letters, random case\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26); // random lowercase letter\n            if (rnd.next(2)) {\n                c = toupper(c);\n            }\n            word += c;\n        }\n    } else if (type == \"all_lower\") {\n        // All lowercase letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"all_upper\") {\n        // All uppercase letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"first_upper\") {\n        // First letter uppercase, rest unchanged\n        if (n >= 1) {\n            char c = 'A' + rnd.next(26);\n            word += c;\n        }\n        for (int i = 1; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"first_lower\") {\n        // First letter lowercase, rest unchanged\n        if (n >= 1) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n        for (int i = 1; i < n; ++i) {\n            char c = 'A' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"mixed\") {\n        // Random letters with random case\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (rnd.next(2)) {\n                c = toupper(c);\n            }\n            word += c;\n        }\n    } else if (type == \"single_upper\") {\n        // Single uppercase character\n        n = 1;\n        char c = 'A' + rnd.next(26);\n        word += c;\n    } else if (type == \"single_lower\") {\n        // Single lowercase character\n        n = 1;\n        char c = 'a' + rnd.next(26);\n        word += c;\n    } else if (type == \"max_length\") {\n        // Maximum length (1000)\n        n = 1000;\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"min_length\") {\n        // Minimum length (1)\n        n = 1;\n        char c = 'a' + rnd.next(26);\n        word += c;\n    } else if (type == \"special1\") {\n        // All 'a's\n        for (int i = 0; i < n; ++i) {\n            word += 'a';\n        }\n    } else if (type == \"special2\") {\n        // All 'A's\n        for (int i = 0; i < n; ++i) {\n            word += 'A';\n        }\n    } else if (type == \"special3\") {\n        // Alternating 'a' and 'A'\n        for (int i = 0; i < n; ++i) {\n            char c = (i % 2 == 0) ? 'a' : 'A';\n            word += c;\n        }\n    } else if (type == \"edge_letters\") {\n        // Use letters 'a', 'z', 'A', 'Z'\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(4);\n            char c;\n            if (choice == 0)\n                c = 'a';\n            else if (choice == 1)\n                c = 'z';\n            else if (choice == 2)\n                c = 'A';\n            else\n                c = 'Z';\n            word += c;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (rnd.next(2)) {\n                c = toupper(c);\n            }\n            word += c;\n        }\n    }\n\n    // Output the word\n    printf(\"%s\\n\", word.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_lower\n./gen -n 1 -type single_upper\n./gen -n 1 -type min_length\n./gen -n 1 -type max_length\n\n./gen -n 2 -type all_lower\n./gen -n 2 -type all_upper\n./gen -n 2 -type mixed\n./gen -n 2 -type first_upper\n./gen -n 2 -type first_lower\n\n./gen -n 10 -type random\n./gen -n 10 -type all_lower\n./gen -n 10 -type all_upper\n./gen -n 10 -type mixed\n./gen -n 10 -type first_upper\n./gen -n 10 -type first_lower\n./gen -n 10 -type edge_letters\n\n./gen -n 100 -type random\n./gen -n 100 -type all_lower\n./gen -n 100 -type all_upper\n./gen -n 100 -type mixed\n./gen -n 100 -type first_upper\n./gen -n 100 -type first_lower\n\n./gen -n 999 -type random\n./gen -n 999 -type all_lower\n./gen -n 999 -type all_upper\n./gen -n 999 -type mixed\n./gen -n 999 -type first_upper\n./gen -n 999 -type first_lower\n./gen -n 999 -type edge_letters\n\n./gen -n 1000 -type max_length\n./gen -n 1000 -type random\n./gen -n 1000 -type all_lower\n./gen -n 1000 -type all_upper\n./gen -n 1000 -type mixed\n./gen -n 1000 -type first_upper\n./gen -n 1000 -type first_lower\n./gen -n 1000 -type special1\n./gen -n 1000 -type special2\n./gen -n 1000 -type special3\n./gen -n 1000 -type edge_letters\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:33.414434",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "281/B",
      "title": "B. Nearest Fraction",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains three integers x, y, n (1 ≤ x, y, n ≤ 105).",
      "output_spec": "OutputPrint the required fraction in the format \"a/b\" (without quotes).",
      "sample_tests": "ExamplesInputCopy3 7 6OutputCopy2/5InputCopy7 2 4OutputCopy7/2",
      "description": "B. Nearest Fraction\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains three integers x, y, n (1 ≤ x, y, n ≤ 105).\n\nOutputPrint the required fraction in the format \"a/b\" (without quotes).\n\nInputCopy3 7 6OutputCopy2/5InputCopy7 2 4OutputCopy7/2\n\nInputCopy3 7 6\n\nOutputCopy2/5\n\nInputCopy7 2 4\n\nOutputCopy7/2",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Hello there!Codeforces Round #172 will take place on Sunday, March 10th at 19:30 MSK(23:30 CST).This is my second time participating in prepration a Codeforces Round. Last time assist with YuukaKazami is an unforgettable experience. This time, the hardest problems were created by Jiatai Huang(CMHJT) and others by me and Yuping Luo(roosephu).Testers are sevenkplus, YuukaKazami, pashka and Seter.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Here let me express my personal thanks to the Codeforces community, which has given me so much gleamy idea in the past two years.Believe it or not, Codeforces has kept her feet in China's ACM community since last year. AFAIK, some of the hardest problems have been used as this year's Winter Camp homework for our National Olympiad in Informatics.Also thanks to watashi, ftiasch and xlk. Discussing problem with all of you, has inspired me a lot. 500 — 1000 — 1500 — 2000 — 2500.We are going to use a standard score distribution in both divisions.The problemset is a little bit easier than last time, but we still believe, getting all of those five problems accepeted will be a challenging mission even for an seasoned International Grandmaster. The problemset has been marriaged with variety flavor. Take a glance over all five problems before going to coding might be a wise strategy. UPD: The contest is over, congratulations to the winners:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Congratulation to tclsm2012, who also solve the problem D!We feel so pity to al13n, your last optimization for problem D is wrong. Problem D has a O(mklogn) algorithm. And we are extremely sorry to Jacob, your solution for problem E can pass most of the random tests but actually is wrong. Jacob... can you explain your solution for us :)We need collect some feedback about this round .. So the editorial will appear after a period of time. UPD:I used to hate those guys who set problems, but didn't write editorial at all! But when things turn to myself, I found it is really difficult to cover all cases. Anyway, it has been done.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2312
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 281 和字母"
          },
          "content_length": 6693
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 100000, \"y\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 100000, \"y\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 100000, \"y\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Implement our own gcd function to ensure standard library usage\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int x = opt<int>(\"x\", 0);\n    int y = opt<int>(\"y\", 0);\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (x == 0 || y == 0 || n == 0)\n    {\n        if (type == \"random\") {\n            if (x == 0) x = rnd.next(1, 100000);\n            if (y == 0) y = rnd.next(1, 100000);\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"max_values\") {\n            if (x == 0) x = 100000;\n            if (y == 0) y = 100000;\n            if (n == 0) n = 100000;\n        } else if (type == \"min_values\") {\n            if (x == 0) x = 1;\n            if (y == 0) y = 1;\n            if (n == 0) n = 1;\n        } else if (type == \"x_eq_y\") { \n            if (x == 0) x = rnd.next(1, 100000);\n            y = x;\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"x_divides_y\") {\n            if (x == 0) x = rnd.next(1, 100000);\n            int k = rnd.next(1, 100000 / x);\n            y = x * k;\n            if (y > 100000) y = 100000;\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"y_divides_x\") {\n            if (y == 0) y = rnd.next(1, 100000);\n            int k = rnd.next(1, 100000 / y);\n            x = y * k;\n            if (x > 100000) x = 100000;\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"x_y_coprime\") {\n            if (x == 0 || y == 0) {\n                while (true) {\n                    x = rnd.next(1, 100000);\n                    y = rnd.next(1, 100000);\n                    if (gcd(x, y) == 1)\n                        break;\n                }\n            }\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"x_small_y_large\") {\n            if (x == 0) x = rnd.next(1, 10);\n            if (y == 0) y = rnd.next(90000, 100000);\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"y_large_n_small\") {\n            if (x == 0) x = rnd.next(1, 100000);\n            if (y == 0) y = rnd.next(90000, 100000);\n            if (n == 0) n = rnd.next(1, 10);\n        } else if (type == \"x_large_y_small\") {\n            if (x == 0) x = rnd.next(90000, 100000);\n            if (y == 0) y = rnd.next(1, 10);\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"fraction_near_integer\") {\n            if (x == 0 || y == 0) {\n                int integer_part = rnd.next(1, 100000);\n                if (x == 0) {\n                    y = rnd.next(1, 100000);\n                    x = integer_part * y + rnd.next(1, y - 1);\n                } else {\n                    y = (x + rnd.next(1, 100000)) / integer_part;\n                    if (y == 0) y = 1;\n                }\n            }\n            if (n == 0) n = rnd.next(1, 100000);\n        } else {\n            // Default to random\n            if (x == 0) x = rnd.next(1, 100000);\n            if (y == 0) y = rnd.next(1, 100000);\n            if (n == 0) n = rnd.next(1, 100000);\n        }\n    }\n\n    // Ensure x, y, n are within [1, 100000]\n    x = min(max(x, 1), 100000);\n    y = min(max(y, 1), 100000);\n    n = min(max(n, 1), 100000);\n\n    // Output x y n\n    printf(\"%d %d %d\\n\", x, y, n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Implement our own gcd function to ensure standard library usage\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int x = opt<int>(\"x\", 0);\n    int y = opt<int>(\"y\", 0);\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (x == 0 || y == 0 || n == 0)\n    {\n        if (type == \"random\") {\n            if (x == 0) x = rnd.next(1, 100000);\n            if (y == 0) y = rnd.next(1, 100000);\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"max_values\") {\n            if (x == 0) x = 100000;\n            if (y == 0) y = 100000;\n            if (n == 0) n = 100000;\n        } else if (type == \"min_values\") {\n            if (x == 0) x = 1;\n            if (y == 0) y = 1;\n            if (n == 0) n = 1;\n        } else if (type == \"x_eq_y\") { \n            if (x == 0) x = rnd.next(1, 100000);\n            y = x;\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"x_divides_y\") {\n            if (x == 0) x = rnd.next(1, 100000);\n            int k = rnd.next(1, 100000 / x);\n            y = x * k;\n            if (y > 100000) y = 100000;\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"y_divides_x\") {\n            if (y == 0) y = rnd.next(1, 100000);\n            int k = rnd.next(1, 100000 / y);\n            x = y * k;\n            if (x > 100000) x = 100000;\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"x_y_coprime\") {\n            if (x == 0 || y == 0) {\n                while (true) {\n                    x = rnd.next(1, 100000);\n                    y = rnd.next(1, 100000);\n                    if (gcd(x, y) == 1)\n                        break;\n                }\n            }\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"x_small_y_large\") {\n            if (x == 0) x = rnd.next(1, 10);\n            if (y == 0) y = rnd.next(90000, 100000);\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"y_large_n_small\") {\n            if (x == 0) x = rnd.next(1, 100000);\n            if (y == 0) y = rnd.next(90000, 100000);\n            if (n == 0) n = rnd.next(1, 10);\n        } else if (type == \"x_large_y_small\") {\n            if (x == 0) x = rnd.next(90000, 100000);\n            if (y == 0) y = rnd.next(1, 10);\n            if (n == 0) n = rnd.next(1, 100000);\n        } else if (type == \"fraction_near_integer\") {\n            if (x == 0 || y == 0) {\n                int integer_part = rnd.next(1, 100000);\n                if (x == 0) {\n                    y = rnd.next(1, 100000);\n                    x = integer_part * y + rnd.next(1, y - 1);\n                } else {\n                    y = (x + rnd.next(1, 100000)) / integer_part;\n                    if (y == 0) y = 1;\n                }\n            }\n            if (n == 0) n = rnd.next(1, 100000);\n        } else {\n            // Default to random\n            if (x == 0) x = rnd.next(1, 100000);\n            if (y == 0) y = rnd.next(1, 100000);\n            if (n == 0) n = rnd.next(1, 100000);\n        }\n    }\n\n    // Ensure x, y, n are within [1, 100000]\n    x = min(max(x, 1), 100000);\n    y = min(max(y, 1), 100000);\n    n = min(max(n, 1), 100000);\n\n    // Output x y n\n    printf(\"%d %d %d\\n\", x, y, n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Maximal values\n./gen -type max_values\n\n# Minimal values\n./gen -type min_values\n\n# x equals y\n./gen -type x_eq_y\n\n# x divides y\n./gen -type x_divides_y\n\n# y divides x\n./gen -type y_divides_x\n\n# x and y are coprime\n./gen -type x_y_coprime\n\n# x small, y large\n./gen -type x_small_y_large\n\n# x large, y small\n./gen -type x_large_y_small\n\n# y large, n small\n./gen -type y_large_n_small\n\n# Fraction near integer\n./gen -type fraction_near_integer\n\n# Specific values\n./gen -x 1 -y 1 -n 1\n./gen -x 100000 -y 100000 -n 100000\n./gen -x 1 -y 100000 -n 1\n./gen -x 100000 -y 1 -n 1\n./gen -x 50000 -y 50000 -n 1\n./gen -x 50000 -y 1 -n 100000\n./gen -x 1 -y 50000 -n 100000\n./gen -x 12345 -y 67890 -n 100000\n\n# x/y close to 0\n./gen -x 1 -y 100000 -n 100000\n./gen -x 2 -y 99999 -n 100000\n\n# x/y close to 1\n./gen -x 99999 -y 100000 -n 100000\n./gen -x 99998 -y 100000 -n 100000\n\n# x/y equals an integer\n./gen -x 100000 -y 1 -n 100000\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:35.720047",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "281/C",
      "title": "C. Головоломка в виде прямоугольника",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы три целых числа w, h, α (1 ≤ w, h ≤ 106; 0 ≤ α ≤ 180). Угол α задан в градусах.",
      "output_spec": "Выходные данныеВ единственной строке выведите вещественное число — площадь области, которая принадлежит обоим заданным прямоугольникам.Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1 45Выходные данныеСкопировать0.828427125Входные данныеСкопировать6 4 30Выходные данныеСкопировать19.668384925",
      "description": "C. Головоломка в виде прямоугольника\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы три целых числа w, h, α (1 ≤ w, h ≤ 106; 0 ≤ α ≤ 180). Угол α задан в градусах.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите вещественное число — площадь области, которая принадлежит обоим заданным прямоугольникам.Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать1 1 45Выходные данныеСкопировать0.828427125Входные данныеСкопировать6 4 30Выходные данныеСкопировать19.668384925\n\nВходные данныеСкопировать1 1 45\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.828427125\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 4 30\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать19.668384925\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВторой тестовый пример изображен на рисунке выше.",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Всем привет!Раунд Codeforces #172 состоится в воскресенье, 10 марта, в 19.30 по московскому времени (23.30 по центральному поясному времени).Это мой второй раунд на Codeforces. До этого я готовил раунд вместе с YuukaKazami. В этот раз самые сложные задачи приготовил Jiatai Huang(CMHJT), другие приготовили я с Yuping Luo (roosephu).Наши тестеры — sevenkplus, YuukaKazami, OpalDshawn и pashka.Сердечно благодарим Геральда Агапова Gerald Agapov(Gerald) за помощь и советы по задачам, Delinur за помощь в переводе условий на русский и MikeMirzayanov, разработавшего такую мощную платформу.Я хотел бы лично поблагодарить сообщество Codeforces, вдохновлявшее меня на самые плодотворные идеи последние два года. Хотите – верьте, хотите – нет, но позиция Codeforces в китайском сообществе ACM укрепилась по сравнению с прошлым годом. Насколько мне известно, самые сложные задачи вошли в домашнее задание зимнего лагеря по подготовке к нашей национальной олимпиаде по информатике в этом году.Также благодарим watashi, ftiasch и xlk. Ваши предложения и замечания очень меня вдохновили. 500 — 1000 — 1500 — 2000 — 2500.Распределение баллов по задачам будет стандартным в обоих дивизионах.Эти задачи немного полегче, чем в прошлый раз, но мы все же верим, что расправиться со всеми пятью задачами будет непросто даже закаленному международному гроссмейстеру. Задачи будут самые разнообразные. Советую просмотреть все пять задач перед тем, как реализовывать.UPD: Соревнование закончилось, поздравления победителям:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Поздравления tclsm2012, кто решил задачу D!Нам очень жаль al13n, в вашем коде задачи D есть ошибка ... и Jacob, ваше решение задачи E проходит большую часть тестов, но на самом деле оно не правильное. Расскажите нам свое решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1850
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 281 和字母"
          },
          "content_length": 6693
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "if(a==0||a==180)\n{\n    printf(\"%.8f\", w*h);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": "if(a==0||a==180)\n{\n    printf(\"%.8f\", w*h);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 15",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 16",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 1000000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000, \"h\");\n    inf.readSpace();\n    int alpha = inf.readInt(0, 180, \"alpha\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 1000000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000, \"h\");\n    inf.readSpace();\n    int alpha = inf.readInt(0, 180, \"alpha\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 1000000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000, \"h\");\n    inf.readSpace();\n    int alpha = inf.readInt(0, 180, \"alpha\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\", -1);\n    int h = opt<int>(\"h\", -1);\n    int angle = opt<int>(\"angle\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"zero_angle\") {\n        angle = 0;\n    } else if (type == \"ninety_angle\") {\n        angle = 90;\n    } else if (type == \"oneeighty_angle\") {\n        angle = 180;\n    } else if (type == \"small_angle\") {\n        angle = rnd.next(1, 10); // small angle between 1 and 10 degrees\n    } else if (type == \"large_angle\") {\n        angle = rnd.next(170, 179); // large angle between 170 and 179 degrees\n    } else if (type == \"special_angle\") {\n        // Specific angles like 30, 45, 60 degrees\n        int angles[] = {30, 45, 60, 120, 135, 150};\n        angle = angles[rnd.next(0, 5)];\n    } else if (type == \"random_angle\") {\n        angle = rnd.next(0, 180);\n    }\n\n    if (w == -1) {\n        w = rnd.next(1, 1000000);\n    }\n\n    if (h == -1) {\n        h = rnd.next(1, 1000000);\n    }\n\n    if (angle == -1) {\n        angle = rnd.next(0, 180);\n    }\n\n    ensure(1 <= w && w <= 1000000);\n    ensure(1 <= h && h <= 1000000);\n    ensure(0 <= angle && angle <= 180);\n\n    printf(\"%d %d %d\\n\", w, h, angle);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\", -1);\n    int h = opt<int>(\"h\", -1);\n    int angle = opt<int>(\"angle\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"zero_angle\") {\n        angle = 0;\n    } else if (type == \"ninety_angle\") {\n        angle = 90;\n    } else if (type == \"oneeighty_angle\") {\n        angle = 180;\n    } else if (type == \"small_angle\") {\n        angle = rnd.next(1, 10); // small angle between 1 and 10 degrees\n    } else if (type == \"large_angle\") {\n        angle = rnd.next(170, 179); // large angle between 170 and 179 degrees\n    } else if (type == \"special_angle\") {\n        // Specific angles like 30, 45, 60 degrees\n        int angles[] = {30, 45, 60, 120, 135, 150};\n        angle = angles[rnd.next(0, 5)];\n    } else if (type == \"random_angle\") {\n        angle = rnd.next(0, 180);\n    }\n\n    if (w == -1) {\n        w = rnd.next(1, 1000000);\n    }\n\n    if (h == -1) {\n        h = rnd.next(1, 1000000);\n    }\n\n    if (angle == -1) {\n        angle = rnd.next(0, 180);\n    }\n\n    ensure(1 <= w && w <= 1000000);\n    ensure(1 <= h && h <= 1000000);\n    ensure(0 <= angle && angle <= 180);\n\n    printf(\"%d %d %d\\n\", w, h, angle);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Small w, h, angle = 0 (zero rotation)\n./gen -w 1 -h 1 -type zero_angle\n\n# Test case 2: Max w, h, angle = 0\n./gen -w 1000000 -h 1000000 -type zero_angle\n\n# Test case 3: Small w, h, angle = 90\n./gen -w 1 -h 1 -type ninety_angle\n\n# Test case 4: Max w, h, angle = 90\n./gen -w 1000000 -h 1000000 -type ninety_angle\n\n# Test case 5: Small w, h, angle = 180\n./gen -w 1 -h 1 -type oneeighty_angle\n\n# Test case 6: Max w, h, angle = 180\n./gen -w 1000000 -h 1000000 -type oneeighty_angle\n\n# Test case 7: w != h, angle = 0\n./gen -w 500000 -h 1000000 -angle 0\n\n# Test case 8: w != h, angle = 45\n./gen -w 500000 -h 1000000 -angle 45\n\n# Test case 9: w == h (square), angle = 45\n./gen -w 1000000 -h 1000000 -angle 45\n\n# Test case 10: Max w, h, random angle\n./gen -w 1000000 -h 1000000 -type random_angle\n\n# Test case 11: w = h = 1, random angle\n./gen -w 1 -h 1 -type random_angle\n\n# Test case 12: w = h = 999999, random angle\n./gen -w 999999 -h 999999 -type random_angle\n\n# Test case 13: Small w, large h, small angle\n./gen -w 1 -h 1000000 -type small_angle\n\n# Test case 14: Large w, small h, small angle\n./gen -w 1000000 -h 1 -type small_angle\n\n# Test case 15: Random w, h, small angle\n./gen -type small_angle\n\n# Test case 16: Random w, h, large angle\n./gen -type large_angle\n\n# Test case 17: Random w, h, angle around 89 degrees\n./gen -angle 89\n\n# Test case 18: Random w, h, angle between 90 and 180 degrees\n./gen -angle 135\n\n# Test case 19: Random w, h, angle\n./gen -type random\n\n# Test case 20: Special angles (30, 45, 60 degrees)\n./gen -type special_angle\n\n# Test case 21: w and h are prime numbers, angle random\n./gen -w 999983 -h 999979 -type random_angle\n\n# Test case 22: w and h are the same, angle = 90\n./gen -w 500000 -h 500000 -type ninety_angle\n\n# Test case 23: w small, h large, angle = 90\n./gen -w 1 -h 1000000 -type ninety_angle\n\n# Test case 24: w large, h small, angle = 90\n./gen -w 1000000 -h 1 -type ninety_angle\n\n# Test case 25: w = 1, h random, angle random\n./gen -w 1 -type random\n\n# Test case 26: w random, h = 1, angle random\n./gen -h 1 -type random\n\n# Test case 27: w and h random, angle = 1 degree\n./gen -angle 1\n\n# Test case 28: w and h random, angle = 179 degrees\n./gen -angle 179\n\n# Test case 29: w and h are maximum, angle random\n./gen -w 1000000 -h 1000000 -type random_angle\n\n# Test case 30: w and h are minimum, angle random\n./gen -w 1 -h 1 -type random_angle\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:37.839644",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "281/D",
      "title": "D. Maximum Xor Secondary",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 < n ≤ 105). The second line contains n distinct integers s1, s2, ..., sn (1 ≤ si ≤ 109).",
      "output_spec": "OutputPrint a single integer — the maximum lucky number among all lucky numbers of sequences s[l..r].",
      "sample_tests": "ExamplesInputCopy55 2 1 4 3OutputCopy7InputCopy59 8 3 5 7OutputCopy15",
      "description": "D. Maximum Xor Secondary\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 < n ≤ 105). The second line contains n distinct integers s1, s2, ..., sn (1 ≤ si ≤ 109).\n\nOutputPrint a single integer — the maximum lucky number among all lucky numbers of sequences s[l..r].\n\nInputCopy55 2 1 4 3OutputCopy7InputCopy59 8 3 5 7OutputCopy15\n\nInputCopy55 2 1 4 3\n\nOutputCopy7\n\nInputCopy59 8 3 5 7\n\nOutputCopy15\n\nNoteFor the first sample you can choose s[4..5] = {4, 3} and its lucky number is (4 xor 3) = 7. You can also choose s[1..2].For the second sample you must choose s[2..5] = {8, 3, 5, 7}.",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Hello there!Codeforces Round #172 will take place on Sunday, March 10th at 19:30 MSK(23:30 CST).This is my second time participating in prepration a Codeforces Round. Last time assist with YuukaKazami is an unforgettable experience. This time, the hardest problems were created by Jiatai Huang(CMHJT) and others by me and Yuping Luo(roosephu).Testers are sevenkplus, YuukaKazami, pashka and Seter.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Here let me express my personal thanks to the Codeforces community, which has given me so much gleamy idea in the past two years.Believe it or not, Codeforces has kept her feet in China's ACM community since last year. AFAIK, some of the hardest problems have been used as this year's Winter Camp homework for our National Olympiad in Informatics.Also thanks to watashi, ftiasch and xlk. Discussing problem with all of you, has inspired me a lot. 500 — 1000 — 1500 — 2000 — 2500.We are going to use a standard score distribution in both divisions.The problemset is a little bit easier than last time, but we still believe, getting all of those five problems accepeted will be a challenging mission even for an seasoned International Grandmaster. The problemset has been marriaged with variety flavor. Take a glance over all five problems before going to coding might be a wise strategy. UPD: The contest is over, congratulations to the winners:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Congratulation to tclsm2012, who also solve the problem D!We feel so pity to al13n, your last optimization for problem D is wrong. Problem D has a O(mklogn) algorithm. And we are extremely sorry to Jacob, your solution for problem E can pass most of the random tests but actually is wrong. Jacob... can you explain your solution for us :)We need collect some feedback about this round .. So the editorial will appear after a period of time. UPD:I used to hate those guys who set problems, but didn't write editorial at all! But when things turn to myself, I found it is really difficult to cover all cases. Anyway, it has been done.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2312
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 281 和字母"
          },
          "content_length": 6693
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000000, \"s_i\");\n    inf.readEoln();\n\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"All s_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000000, \"s_i\");\n    inf.readEoln();\n\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"All s_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000000, \"s_i\");\n    inf.readEoln();\n\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"All s_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random numbers between 1 and 1e9\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, (int)1e9);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"increasing\") {\n        // Generate increasing sequence\n        int start = rnd.next(1, (int)(1e9 - n + 1));\n        for (int i = 0; i < n; ++i) {\n            s[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Generate decreasing sequence\n        int start = rnd.next(n, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            s[i] = start - i;\n        }\n    } else if (type == \"maxxor\") {\n        // Generate sequence designed to maximize lucky number\n        int max_num = (1 << 29) - 1; // 536870911\n        int second_num = (1 << 28); // 268435456\n\n        s[0] = max_num;\n        s[1] = second_num;\n\n        set<int> used;\n        used.insert(max_num);\n        used.insert(second_num);\n\n        for (int i = 2; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, (int)1e9);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"smallrange\") {\n        // Generate n distinct numbers in a small range, e.g., 1 to n*2\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, n * 2);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between high and low values\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            if (i % 2 == 0) {\n                do {\n                    x = rnd.next(1, (int)1e6);\n                } while (used.count(x));\n            } else {\n                do {\n                    x = rnd.next((int)(1e9 - n), (int)1e9);\n                } while (used.count(x));\n            }\n            used.insert(x);\n            s[i] = x;\n        }\n    } else {\n        // Default to random\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, (int)1e9);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    }\n\n    // Output the sequence\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", s[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random numbers between 1 and 1e9\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, (int)1e9);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"increasing\") {\n        // Generate increasing sequence\n        int start = rnd.next(1, (int)(1e9 - n + 1));\n        for (int i = 0; i < n; ++i) {\n            s[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Generate decreasing sequence\n        int start = rnd.next(n, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            s[i] = start - i;\n        }\n    } else if (type == \"maxxor\") {\n        // Generate sequence designed to maximize lucky number\n        int max_num = (1 << 29) - 1; // 536870911\n        int second_num = (1 << 28); // 268435456\n\n        s[0] = max_num;\n        s[1] = second_num;\n\n        set<int> used;\n        used.insert(max_num);\n        used.insert(second_num);\n\n        for (int i = 2; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, (int)1e9);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"smallrange\") {\n        // Generate n distinct numbers in a small range, e.g., 1 to n*2\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, n * 2);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between high and low values\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            if (i % 2 == 0) {\n                do {\n                    x = rnd.next(1, (int)1e6);\n                } while (used.count(x));\n            } else {\n                do {\n                    x = rnd.next((int)(1e9 - n), (int)1e9);\n                } while (used.count(x));\n            }\n            used.insert(x);\n            s[i] = x;\n        }\n    } else {\n        // Default to random\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, (int)1e9);\n            } while (used.count(x));\n            used.insert(x);\n            s[i] = x;\n        }\n    }\n\n    // Output the sequence\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", s[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type maxxor\n./gen -n 2 -type smallrange\n./gen -n 2 -type alternating\n\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type maxxor\n./gen -n 10 -type smallrange\n./gen -n 10 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type maxxor\n./gen -n 100 -type smallrange\n./gen -n 100 -type alternating\n\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type maxxor\n./gen -n 1000 -type smallrange\n./gen -n 1000 -type alternating\n\n./gen -n 10000 -type random\n./gen -n 10000 -type increasing\n./gen -n 10000 -type decreasing\n./gen -n 10000 -type maxxor\n./gen -n 10000 -type smallrange\n./gen -n 10000 -type alternating\n\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type maxxor\n./gen -n 100000 -type smallrange\n./gen -n 100000 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:39.517401",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "281/E",
      "title": "E. Игра на дереве",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество вершин дерева. В следующих n - 1 строках заданы ребра дерева. В i-той строке записаны целые числа ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — номера вершин, которые соединены i-тым ребром.Гарантируется, что заданный граф является деревом.",
      "output_spec": "Выходные данныеВыведите единственное вещественное число — математическое ожидание количества шагов в описанной игре.Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать21 2Выходные данныеСкопировать1.50000000000000000000Входные данныеСкопировать31 21 3Выходные данныеСкопировать2.00000000000000000000",
      "description": "E. Игра на дереве\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество вершин дерева. В следующих n - 1 строках заданы ребра дерева. В i-той строке записаны целые числа ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — номера вершин, которые соединены i-тым ребром.Гарантируется, что заданный граф является деревом.\n\nВходные данные\n\nВыходные данныеВыведите единственное вещественное число — математическое ожидание количества шагов в описанной игре.Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать21 2Выходные данныеСкопировать1.50000000000000000000Входные данныеСкопировать31 21 3Выходные данныеСкопировать2.00000000000000000000\n\nВходные данныеСкопировать21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.50000000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 21 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.00000000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере возможны два случая. Первый — это сразу удалить корень, второй — удалить корень после одного шага. Таким образом, математическое ожидание количества шагов равно: 1 × (1 / 2) + 2 × (1 / 2) = 1.5Второй пример более сложный. Два случая из трех приводят нас к задаче, эквивалентной первому тестовому примеру, третий случай — удалить корень на первом шаге. Таким образом, математическое ожидание количества шагов равно: 1 × (1 / 3) + (1 + 1.5) × (2 / 3) = (1 / 3) + (5 / 3) = 2",
      "solutions": [
        {
          "title": "Codeforces Round #172 - Codeforces",
          "content": "Всем привет!Раунд Codeforces #172 состоится в воскресенье, 10 марта, в 19.30 по московскому времени (23.30 по центральному поясному времени).Это мой второй раунд на Codeforces. До этого я готовил раунд вместе с YuukaKazami. В этот раз самые сложные задачи приготовил Jiatai Huang(CMHJT), другие приготовили я с Yuping Luo (roosephu).Наши тестеры — sevenkplus, YuukaKazami, OpalDshawn и pashka.Сердечно благодарим Геральда Агапова Gerald Agapov(Gerald) за помощь и советы по задачам, Delinur за помощь в переводе условий на русский и MikeMirzayanov, разработавшего такую мощную платформу.Я хотел бы лично поблагодарить сообщество Codeforces, вдохновлявшее меня на самые плодотворные идеи последние два года. Хотите – верьте, хотите – нет, но позиция Codeforces в китайском сообществе ACM укрепилась по сравнению с прошлым годом. Насколько мне известно, самые сложные задачи вошли в домашнее задание зимнего лагеря по подготовке к нашей национальной олимпиаде по информатике в этом году.Также благодарим watashi, ftiasch и xlk. Ваши предложения и замечания очень меня вдохновили. 500 — 1000 — 1500 — 2000 — 2500.Распределение баллов по задачам будет стандартным в обоих дивизионах.Эти задачи немного полегче, чем в прошлый раз, но мы все же верим, что расправиться со всеми пятью задачами будет непросто даже закаленному международному гроссмейстеру. Задачи будут самые разнообразные. Советую просмотреть все пять задач перед тем, как реализовывать.UPD: Соревнование закончилось, поздравления победителям:Div1: UESTC_Nocturne liouzhou_101 peter50216 Petr Shik Div2: antonio_junior kyuridenamida tsunayoshi ZJUT-Xixi bird5x Поздравления tclsm2012, кто решил задачу D!Нам очень жаль al13n, в вашем коде задачи D есть ошибка ... и Jacob, ваше решение задачи E проходит большую часть тестов, но на самом деле оно не правильное. Расскажите нам свое решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6870",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1850
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces",
          "content": "Overview ...In DIV 1, there are 3 normal tasks accompanied with 2 challenge tasks. About 40 competitors solve first three tasks during the contest and I believe there will be more if we extended the duration a little bit.Task D is a standard data-structure problem hidden behind a classical maximum cost flow model. This kind of problem are usually trick-less, but hard to implement especially under the pressure. Because of this, it becomes tonight's draw-breaker.Task E is a extended version on a classical DP && Math problem. There are many solutions to the original problem, one is giving a global view under the state transition, and using a data structure to handle it carefully. However, this one is even more harder, few people have ever tried it except Jacob. (Although is wrong.)As a seasoned competitor, Petr took the C-B-A order which proved to be the best choice through out the night. And after quickly solved C and B, he has sunk into problem A, it takes him about 45 minutes to cut-the-knot and got 2 Successful Hacking Attempt as a reward.On the other hand, peter50216 gave his response to Problem A straightly! It only took him about 15 minutes to write a code which is full of trigonometric function and if-else. And on top of this is another 15 minutes to solve the successors. After that, he gave 2 Successful Hacking Attempt on A and 1 Successful Hacking Attempt on B as the end.While we were marvelling at peter50216 for his solid skill in geometry, al13n gave the first attempt to problem D among the game. Unfortunately his solution get TLE on the pretests. This is a O(mk^2logn) algorithm, and we think it is hard to optimize it to pass the pretests even for our setter. And abandoned the O(mk^2logn) solution and totally reconstructed the O(mklogn) from the sketch now became more difficult and audacious.While we were praying to al13n, Jacob gave the first solution and the only solution for Problem E among the whole game! It cost all of his time and led him no time to solve others. It sounds like a miracle ..We were all sooooooo excited and opened his code and look carefully, but, actually I myself got quite confused by his solution, and didn't know why it can work at all.While all we setter and tester were checking the solution carefully. UESTC_Nocturne (XHXJ) gave the first correct solution among the game for problem D. It is a huge code more than 12kb, and perform as same as our std solution. Although he haven't solve A && B, this break-through has already establish his winner position.After the contest, I interview her to \"how can you solve this problem so quick\", and replied as “I have solved the simplified problem, and have thought about this method before.”At the same time, we found that Jacob's solution was wrong, we generated a few maximal random data, and it return WA about one-quarter of them. After some discussion we decided to add one of them into the tests.In both problem D and E, our pretests intended to be as strong as possible. How I wish to let Jacob know about his solution is wrong so he can quickly get out of the impasses and get Accepted in the end... .al13n also pass from the pretests after UESTC_Nocturne, we are relieved to hear about it at first, but found it is a O(mk^2logn) solution with a wrong optimization soon, this solution will definitely fail in system test, but he may didn't aware of it at the time.There are other three correct solutions for Problem D near the end of the game, among them FattyPenguin's solution is the fastest one, and he make it in ten minutes ago before the contest end and liouzhou_101's solution actually is a O(mk^2logn) one but with some dramatic optimizations. It is hard to block this kind of solution or it could cause some trouble for our Java Users.Tutorial ...http://assets.codeforces.com/statements/280-281/Tutorial.pdf Problem 2A. Word Capitalization Problem 2B. Nearest Fraction Problem A. Rectangle Puzzle Problem B. Maximum Xor Secondary Problem C. Game on Tree Problem D. k-Maximum Subsequence Sum Problem E. Sequence Transformation Backstage: The screencast of my screen during the contest, you can see what happened behind the scene if you are interested, just have fun ~. CMHJT's tutorial: Another tutorial written by one of the setters for C, D, E.(Chinese!) roosephu's tutorial for D: Tester's tutorial for Problem D. Seter's tutorial for E: Tester's tutorial for Problem E. ......: A brief overview release after the contest end.(Chinese!) Sidelights ... There are some disputes about the problem A, but personally I like it very much, this is a basic problem(surely it is evil), can be described in one picture, and all of us could solve it if they are careful. Some people say it is harder than A so it should be swap with Problem C, but I insist on put it at A, because, we all think Problem B && C needs some idea, but A needs only basic knowledge we learned in middle school. And it can be solved in a different style if you have a well-implemented Geometry Template. Some competitors are just good at this kind of problem while others are not. And after all, this is the only problem which has trick in this contest. :) In problem B, some people got confused in “bitwise excluding OR = XOR or OR?”, they are only familiar with \"XOR\" but get into confused with something like \"bitwise excluding OR\". Well, as a Non-English speaker, I can only expressed my understanding, we didn't intend to do that. In the original statement we write \"XOR\" but during the translate process it became \"bitwise excluding OR\", and I did not think it could cause such trouble. Here we can only recommend you read more English book, because such things will occur from now on and keep up. tourist lost his target (Rating above 3000) after the contest. But we all think he'll return soon. rng_58 didn't participate in the contest but took a virtual participation on the next day. He can't solve D && E and get Rank 5 along after Petr. tclsm2012 as a purple, also solve Problem D during the contest, but failed at A && C at the expense. Both the winner and the runner-up failed on problem A. UESTC_Nocturne's A solution was hacked by scottai1, the latter, also failed at the system test after a while. One of our setter ... came in the hospital after setting problems. We were adding tests against submitted solutions during the contest. Daniel Sleator (A professor at CMU who invented many data structures such as splay trees, link-cut trees, skew heap and discovered amortized analysis, see Wikipedia ...）participated in Div 2 and get promotion to Div 1 after the contest. And he checked our Div 1. E and write a miraculous DP solution1 2 in Ocaml which based on a conclusion.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6939",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 281 和字母"
          },
          "content_length": 6693
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #172 - Codeforces - Code 1",
          "code": "Micro Mezzo Macro Flation -- Overheated Economy",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 2",
          "code": "if(a==0||a==180)\n{\n    printf(\"%.8f\", w*h);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 3",
          "code": "if(a==0||a==180)\n{\n    printf(\"%.8f\", w*h);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 4",
          "code": "The problemset is a little bit easier than last time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 5",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 6",
          "code": ">>> fractions.Fraction(6/7)\nFraction(7720456504063707, 9007199254740992)\n>>> fractions.Fraction(6,7)\nFraction(6, 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 7",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 8",
          "code": "100000\n100001 99999 99997 ... 1 ... 99996 99998 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 9",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 10",
          "code": "2 24480023 3888 4569\n628100 637054",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 11",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 12",
          "code": "630292.500000 634861.500000\n9614112.500000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 13",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 14",
          "code": "3 24480023 3888 4569\n628100 637054 637264",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 15",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 - Codeforces - Code 16",
          "code": "630292.500000000 634861.500000000 639103.000000000\n12996033.500000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6870",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 1",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #172 Editorial - Codeforces - Code 2",
          "code": "dfs(node n, depth d)\n{\n    exp = 1/d\n    \n    for(every child k of n)\n        exp = exp + dfs(k, depth + 1)\n        \n    return exp\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6939",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loops are not allowed (edge %d connects node %d to itself)\", i + 1, a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges are not allowed between nodes %d and %d\", u, v);\n\n        edges.insert(edge);\n    }\n\n    // Union-Find to check for cycles and connectivity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (const auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n\n        int pu = find(u);\n        int pv = find(v);\n\n        ensuref(pu != pv, \"Cycle detected when processing edge between nodes %d and %d\", u, v);\n\n        parent[pu] = pv;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loops are not allowed (edge %d connects node %d to itself)\", i + 1, a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges are not allowed between nodes %d and %d\", u, v);\n\n        edges.insert(edge);\n    }\n\n    // Union-Find to check for cycles and connectivity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (const auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n\n        int pu = find(u);\n        int pv = find(v);\n\n        ensuref(pu != pv, \"Cycle detected when processing edge between nodes %d and %d\", u, v);\n\n        parent[pu] = pv;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loops are not allowed (edge %d connects node %d to itself)\", i + 1, a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges are not allowed between nodes %d and %d\", u, v);\n\n        edges.insert(edge);\n    }\n\n    // Union-Find to check for cycles and connectivity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (const auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n\n        int pu = find(u);\n        int pv = find(v);\n\n        ensuref(pu != pv, \"Cycle detected when processing edge between nodes %d and %d\", u, v);\n\n        parent[pu] = pv;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> edges;\n    \n    if (type == \"chain\") {\n        // Generate a chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Generate a star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Generate a complete binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else if (type == \"unbalanced\") {\n        // Generate an unbalanced tree\n        if (n < 3) {\n            // Not enough nodes for unbalanced tree, generate a chain instead\n            for (int i = 2; i <= n; ++i) {\n                edges.push_back({i - 1, i});\n            }\n        } else {\n            edges.push_back({1, 2});\n            edges.push_back({1, 3});\n            if (n >= 4) {\n                edges.push_back({2, 4});\n                for (int i = 5; i <= n; ++i) {\n                    edges.push_back({i - 1, i});\n                }\n            }\n        }\n    } else {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n    \n    // Shuffle node numbers except for node 1 to keep it as the root\n    vector<int> perm(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 2, perm.end());\n    \n    // Adjust edges with permuted node numbers\n    for (auto &edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n    \n    // Shuffle edges to prevent any specific order\n    shuffle(edges.begin(), edges.end());\n    \n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (const auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> edges;\n    \n    if (type == \"chain\") {\n        // Generate a chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Generate a star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Generate a complete binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else if (type == \"unbalanced\") {\n        // Generate an unbalanced tree\n        if (n < 3) {\n            // Not enough nodes for unbalanced tree, generate a chain instead\n            for (int i = 2; i <= n; ++i) {\n                edges.push_back({i - 1, i});\n            }\n        } else {\n            edges.push_back({1, 2});\n            edges.push_back({1, 3});\n            if (n >= 4) {\n                edges.push_back({2, 4});\n                for (int i = 5; i <= n; ++i) {\n                    edges.push_back({i - 1, i});\n                }\n            }\n        }\n    } else {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n    \n    // Shuffle node numbers except for node 1 to keep it as the root\n    vector<int> perm(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 2, perm.end());\n    \n    // Adjust edges with permuted node numbers\n    for (auto &edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n    \n    // Shuffle edges to prevent any specific order\n    shuffle(edges.begin(), edges.end());\n    \n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (const auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n./gen -n 1 -type star\n./gen -n 1 -type binary\n./gen -n 1 -type unbalanced\n./gen -n 1 -type random\n\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type binary\n./gen -n 2 -type unbalanced\n./gen -n 2 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type unbalanced\n./gen -n 10 -type random\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type binary\n./gen -n 100 -type unbalanced\n./gen -n 100 -type random\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type unbalanced\n./gen -n 1000 -type random\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type binary\n./gen -n 10000 -type unbalanced\n./gen -n 10000 -type random\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type unbalanced\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:41.448465",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "282/A",
      "title": "A. Bit++",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 150) — the number of statements in the programme.Next n lines contain a statement each. Each statement contains exactly one operation (++ or --) and exactly one variable x (denoted as letter «X»). Thus, there are no empty statements. The operation and the variable can be written in any order.",
      "output_spec": "OutputPrint a single integer — the final value of x.",
      "sample_tests": "ExamplesInputCopy1++XOutputCopy1InputCopy2X++--XOutputCopy0",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 150) — the number of statements in the programme.Next n lines contain a statement each. Each statement contains exactly one operation (++ or --) and exactly one variable x (denoted as letter «X»). Thus, there are no empty statements. The operation and the variable can be written in any order.\n\nOutputPrint a single integer — the final value of x.\n\nInputCopy1++XOutputCopy1InputCopy2X++--XOutputCopy0\n\nInputCopy1++X\n\nOutputCopy1\n\nInputCopy2X++--X\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces",
          "content": "Hi all! :{We're glad to invite you to participate in Codeforces Round #173 prepared by A.K.Goharshady, LGM and me (havaliza). I want to thank Gerald, MikeMirzayanov and Delinur who helped us to prepare the round on this platform. And thanks to dani1373, hhoomn, mruxim, MMJ and xorfire who tested the problems and helped us a lot.Today is LGM's birthday and yesterday was gpac's birthday. Happy birthday to you guys! ^.^Hope you enjoy today's round and have lots of fun. :)Update. The editorial is out!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6954",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 502
        },
        {
          "title": "Round #173 — Editorial - Codeforces",
          "content": "Hi, Here's the editorial.Please note that not all the codes presented below belong to me. (It's a combination of codes from our problemsetters and testers) -- And I borrowed AKGMA's account since I wasn't able to link to my own submissions somehow!Note: It seems that the Codeforces mark-up is not functioning. To see a submission go to: http://www.codeforces.com/contest/282/submission/submission-numberA: Bit++Just use a simple loop. (Take a look at the Python code)GNU C++: 3314442, 3314464GNU C: 3314471Python: 3314475B: Painting EggsThis one can be solved by a greedy algorithm. Start from the 1st egg and each time give the egg to A if and only if giving it to A doesn't make the difference > 500, otherwise give it to G.To prove the correctness, one can use induction. The base case is trivial. Suppose that we've assigned the first n - 1 eggs such that the total money given to A is Sa and total money given to G is Sg. We can assume Sa ≥ Sg. Now we must either add gn to Sg or add an to Sa. If we can't add gn to Sg, then Sg + gn > Sa + 500, so  - 500 > Sa - Sg - gn, adding 1000 to both sides gives us the inequality 500 > Sa + (1000 - gn) - Sg which is exactly what we need to make sure that we can add an = 1000 - gn to Sa.GNU C++: 3314480, 3314484GNU C: 3314488Python: 3314492C: XOR and ORFirst of all, check the length of the two strings to be equal. Then with a little try and guess, you can find out that the zero string (00...0) can't be converted to anything else and nothing else can be converted to zero. All other conversions are possible.GNU C++: 3314503, 3314504, 3314509, 3314512, 3314514D: Yet another Number GameFor n=1, everything is clear. If a1 = 0 then BitAryo wins, otherwise BitLGM is the winner.For n=2: define win[i][j] = (Whether i,j is a Winning position). It's easy to calculate win[i][j] for all i and j, using a loop (Checking all possible moves). This leads us to an O(n3) solution.For n=3: Everything is similar to NIM, With the same statement of proof as for NIM, i,j,k is a winning position if and only if (i xor j xor k)  ≠ 0.[Don't forget the parentheses in code :) ] Complexity: O(1)One can also solve this case using DP. We define lose[i][j]= (Least k, such that i,j,k is a losing position) ,lose2[i][j]=(Least k, such that k,k+i,k+i+j is a losing position) and win[i][j][k] just as the case with n=2. As in the codes below, one can calculate all these values in O(n3).Using the same DP strategy for n=2 and the O(1) algorithm for n=3 and n=1, leads us to a total complexity of O(n2) which was not necessary in this contest.GNU C++: 3314578, 3314580, 3314585, 3314588E: Sausage MaximizationCan be solved using a trie in O(n log (max{ai})).Start with a prefix of size n, and decrease the size of prefix in each step. For each new prefix calculate the XOR of elements in that prefix and add the XOR of the newly available suffix (which does not coincide with the new prefix) to the trie, then query the trie for the best possible match for the XOR of the new prefix. (Try to get 1 as the first digit if possible, otherwise put 0, then do the same thing for the second digit and so on). Get a maximum over all answers you've found, and it's all done. [By digit, I mean binary digit]GNU C++: 3314616, 3314619We hope you enjoyed the tasks.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6999",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 282 和字母"
          },
          "content_length": 3281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 1",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 2",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 3",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 4",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 5",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 6",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 1",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 2",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 3",
          "code": "for(int i = 0; i <= a[0]; i++) {\n    for(int j = 0; j <= a[1]; j++) {\n        if(win[i][j]) continue;\n        for(int k = 1; k <= 300; k++) {\n            win[i+k][j+k] = 1;\n            win[i][j+k] = 1;\n            win[i+k][j] = 1;\n        }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"^(\\\\+\\\\+X|X\\\\+\\\\+|--X|X--)$\", \"statement\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"^(\\\\+\\\\+X|X\\\\+\\\\+|--X|X--)$\", \"statement\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"^(\\\\+\\\\+X|X\\\\+\\\\+|--X|X--)$\", \"statement\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> statements;\n\n    if (type == \"all_inc\") {\n        // Generate all increment statements (++X or X++)\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"X++\");\n            }\n        }\n    } else if (type == \"all_dec\") {\n        // Generate all decrement statements (--X or X--)\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between increments and decrements\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Increment statement\n                if (rnd.next(2)) {\n                    statements.push_back(\"++X\");\n                } else {\n                    statements.push_back(\"X++\");\n                }\n            } else {\n                // Decrement statement\n                if (rnd.next(2)) {\n                    statements.push_back(\"--X\");\n                } else {\n                    statements.push_back(\"X--\");\n                }\n            }\n        }\n    } else if (type == \"net_zero\") {\n        // Generate statements such that net change is zero\n        int inc_count = n / 2;\n        int dec_count = n - inc_count;\n        for (int i = 0; i < inc_count; ++i) {\n            // Increment statements\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"X++\");\n            }\n        }\n        for (int i = 0; i < dec_count; ++i) {\n            // Decrement statements\n            if (rnd.next(2)) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n        // Shuffle the statements so they are not all increments followed by decrements\n        shuffle(statements.begin(), statements.end());\n    } else if (type == \"max_pos\") {\n        // All increment statements\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"X++\");\n            }\n        }\n    } else if (type == \"max_neg\") {\n        // All decrement statements\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n    } else if (type == \"pre_inc_only\") {\n        // Generate only ++X and --X\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"--X\");\n            }\n        }\n    } else if (type == \"post_inc_only\") {\n        // Generate only X++ and X--\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"X++\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n    } else if (type == \"complex_pattern\") {\n        // Create a complex pattern\n        int one_third = n / 3;\n        int i = 0;\n        for (; i < one_third; ++i) {\n            // Increment statements\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"X++\");\n            }\n        }\n        for (; i < 2 * one_third; ++i) {\n            // Decrement statements\n            if (rnd.next(2)) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n        for (; i < n; ++i) {\n            // Random statements\n            int t = rnd.next(4);\n            if (t == 0) {\n                statements.push_back(\"++X\");\n            } else if (t == 1) {\n                statements.push_back(\"X++\");\n            } else if (t == 2) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n        // Shuffle the statements\n        shuffle(statements.begin(), statements.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(4);\n            if (t == 0) {\n                statements.push_back(\"++X\");\n            } else if (t == 1) {\n                statements.push_back(\"X++\");\n            } else if (t == 2) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n    }\n\n    // Output n\n    cout << n << '\\n';\n    // Output the statements\n    for (const auto& s : statements) {\n        cout << s << '\\n';\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> statements;\n\n    if (type == \"all_inc\") {\n        // Generate all increment statements (++X or X++)\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"X++\");\n            }\n        }\n    } else if (type == \"all_dec\") {\n        // Generate all decrement statements (--X or X--)\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between increments and decrements\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Increment statement\n                if (rnd.next(2)) {\n                    statements.push_back(\"++X\");\n                } else {\n                    statements.push_back(\"X++\");\n                }\n            } else {\n                // Decrement statement\n                if (rnd.next(2)) {\n                    statements.push_back(\"--X\");\n                } else {\n                    statements.push_back(\"X--\");\n                }\n            }\n        }\n    } else if (type == \"net_zero\") {\n        // Generate statements such that net change is zero\n        int inc_count = n / 2;\n        int dec_count = n - inc_count;\n        for (int i = 0; i < inc_count; ++i) {\n            // Increment statements\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"X++\");\n            }\n        }\n        for (int i = 0; i < dec_count; ++i) {\n            // Decrement statements\n            if (rnd.next(2)) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n        // Shuffle the statements so they are not all increments followed by decrements\n        shuffle(statements.begin(), statements.end());\n    } else if (type == \"max_pos\") {\n        // All increment statements\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"X++\");\n            }\n        }\n    } else if (type == \"max_neg\") {\n        // All decrement statements\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n    } else if (type == \"pre_inc_only\") {\n        // Generate only ++X and --X\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"--X\");\n            }\n        }\n    } else if (type == \"post_inc_only\") {\n        // Generate only X++ and X--\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                statements.push_back(\"X++\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n    } else if (type == \"complex_pattern\") {\n        // Create a complex pattern\n        int one_third = n / 3;\n        int i = 0;\n        for (; i < one_third; ++i) {\n            // Increment statements\n            if (rnd.next(2)) {\n                statements.push_back(\"++X\");\n            } else {\n                statements.push_back(\"X++\");\n            }\n        }\n        for (; i < 2 * one_third; ++i) {\n            // Decrement statements\n            if (rnd.next(2)) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n        for (; i < n; ++i) {\n            // Random statements\n            int t = rnd.next(4);\n            if (t == 0) {\n                statements.push_back(\"++X\");\n            } else if (t == 1) {\n                statements.push_back(\"X++\");\n            } else if (t == 2) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n        // Shuffle the statements\n        shuffle(statements.begin(), statements.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(4);\n            if (t == 0) {\n                statements.push_back(\"++X\");\n            } else if (t == 1) {\n                statements.push_back(\"X++\");\n            } else if (t == 2) {\n                statements.push_back(\"--X\");\n            } else {\n                statements.push_back(\"X--\");\n            }\n        }\n    }\n\n    // Output n\n    cout << n << '\\n';\n    // Output the statements\n    for (const auto& s : statements) {\n        cout << s << '\\n';\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Edge cases for n = 1\n./gen -n 1 -type all_inc\n./gen -n 1 -type all_dec\n./gen -n 1 -type random\n\n# Small n\n./gen -n 2 -type all_inc\n./gen -n 2 -type net_zero\n\n./gen -n 3 -type alternate\n./gen -n 3 -type net_zero\n\n# Typical small n\n./gen -n 10 -type random\n./gen -n 10 -type all_inc\n./gen -n 10 -type all_dec\n./gen -n 10 -type net_zero\n./gen -n 10 -type alternate\n./gen -n 10 -type pre_inc_only\n./gen -n 10 -type post_inc_only\n./gen -n 10 -type complex_pattern\n\n# Medium n\n./gen -n 50 -type random\n./gen -n 50 -type net_zero\n./gen -n 50 -type pre_inc_only\n./gen -n 50 -type post_inc_only\n\n# Large n\n./gen -n 100 -type random\n./gen -n 100 -type max_pos\n./gen -n 100 -type max_neg\n./gen -n 100 -type net_zero\n./gen -n 100 -type complex_pattern\n\n# Maximum n\n./gen -n 150 -type random\n./gen -n 150 -type max_pos\n./gen -n 150 -type max_neg\n./gen -n 150 -type net_zero\n./gen -n 150 -type alternate\n./gen -n 150 -type pre_inc_only\n./gen -n 150 -type post_inc_only\n\n# Additional test cases\n./gen -n 149 -type net_zero\n./gen -n 148 -type net_zero\n./gen -n 150 -type complex_pattern\n./gen -n 150 -type all_inc\n./gen -n 150 -type all_dec\n\n# Additional random test cases\n./gen -n 150 -type random\n./gen -n 150 -type random\n./gen -n 150 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:43.116526",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "282/B",
      "title": "B. Painting Eggs",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106) — the number of eggs.Next n lines contain two integers ai and gi each (0 ≤ ai, gi ≤ 1000; ai + gi = 1000): ai is the price said by A. for the i-th egg and gi is the price said by G. for the i-th egg.",
      "output_spec": "OutputIf it is impossible to assign the painting, print \"-1\" (without quotes).Otherwise print a string, consisting of n letters \"G\" and \"A\". The i-th letter of this string should represent the child who will get the i-th egg in the required distribution. Letter \"A\" represents A. and letter \"G\" represents G. If we denote the money Uncle J. must pay A. for the painting as Sa, and the money Uncle J. must pay G. for the painting as Sg, then this inequality must hold: |Sa  -  Sg|  ≤  500. If there are several solutions, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy21 999999 1OutputCopyAGInputCopy3400 600400 600400 600OutputCopyAGA",
      "description": "B. Painting Eggs\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 106) — the number of eggs.Next n lines contain two integers ai and gi each (0 ≤ ai, gi ≤ 1000; ai + gi = 1000): ai is the price said by A. for the i-th egg and gi is the price said by G. for the i-th egg.\n\nOutputIf it is impossible to assign the painting, print \"-1\" (without quotes).Otherwise print a string, consisting of n letters \"G\" and \"A\". The i-th letter of this string should represent the child who will get the i-th egg in the required distribution. Letter \"A\" represents A. and letter \"G\" represents G. If we denote the money Uncle J. must pay A. for the painting as Sa, and the money Uncle J. must pay G. for the painting as Sg, then this inequality must hold: |Sa  -  Sg|  ≤  500. If there are several solutions, you are allowed to print any of them.\n\nInputCopy21 999999 1OutputCopyAGInputCopy3400 600400 600400 600OutputCopyAGA\n\nInputCopy21 999999 1\n\nOutputCopyAG\n\nInputCopy3400 600400 600400 600\n\nOutputCopyAGA",
      "solutions": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces",
          "content": "Hi all! :{We're glad to invite you to participate in Codeforces Round #173 prepared by A.K.Goharshady, LGM and me (havaliza). I want to thank Gerald, MikeMirzayanov and Delinur who helped us to prepare the round on this platform. And thanks to dani1373, hhoomn, mruxim, MMJ and xorfire who tested the problems and helped us a lot.Today is LGM's birthday and yesterday was gpac's birthday. Happy birthday to you guys! ^.^Hope you enjoy today's round and have lots of fun. :)Update. The editorial is out!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6954",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 502
        },
        {
          "title": "Round #173 — Editorial - Codeforces",
          "content": "Hi, Here's the editorial.Please note that not all the codes presented below belong to me. (It's a combination of codes from our problemsetters and testers) -- And I borrowed AKGMA's account since I wasn't able to link to my own submissions somehow!Note: It seems that the Codeforces mark-up is not functioning. To see a submission go to: http://www.codeforces.com/contest/282/submission/submission-numberA: Bit++Just use a simple loop. (Take a look at the Python code)GNU C++: 3314442, 3314464GNU C: 3314471Python: 3314475B: Painting EggsThis one can be solved by a greedy algorithm. Start from the 1st egg and each time give the egg to A if and only if giving it to A doesn't make the difference > 500, otherwise give it to G.To prove the correctness, one can use induction. The base case is trivial. Suppose that we've assigned the first n - 1 eggs such that the total money given to A is Sa and total money given to G is Sg. We can assume Sa ≥ Sg. Now we must either add gn to Sg or add an to Sa. If we can't add gn to Sg, then Sg + gn > Sa + 500, so  - 500 > Sa - Sg - gn, adding 1000 to both sides gives us the inequality 500 > Sa + (1000 - gn) - Sg which is exactly what we need to make sure that we can add an = 1000 - gn to Sa.GNU C++: 3314480, 3314484GNU C: 3314488Python: 3314492C: XOR and ORFirst of all, check the length of the two strings to be equal. Then with a little try and guess, you can find out that the zero string (00...0) can't be converted to anything else and nothing else can be converted to zero. All other conversions are possible.GNU C++: 3314503, 3314504, 3314509, 3314512, 3314514D: Yet another Number GameFor n=1, everything is clear. If a1 = 0 then BitAryo wins, otherwise BitLGM is the winner.For n=2: define win[i][j] = (Whether i,j is a Winning position). It's easy to calculate win[i][j] for all i and j, using a loop (Checking all possible moves). This leads us to an O(n3) solution.For n=3: Everything is similar to NIM, With the same statement of proof as for NIM, i,j,k is a winning position if and only if (i xor j xor k)  ≠ 0.[Don't forget the parentheses in code :) ] Complexity: O(1)One can also solve this case using DP. We define lose[i][j]= (Least k, such that i,j,k is a losing position) ,lose2[i][j]=(Least k, such that k,k+i,k+i+j is a losing position) and win[i][j][k] just as the case with n=2. As in the codes below, one can calculate all these values in O(n3).Using the same DP strategy for n=2 and the O(1) algorithm for n=3 and n=1, leads us to a total complexity of O(n2) which was not necessary in this contest.GNU C++: 3314578, 3314580, 3314585, 3314588E: Sausage MaximizationCan be solved using a trie in O(n log (max{ai})).Start with a prefix of size n, and decrease the size of prefix in each step. For each new prefix calculate the XOR of elements in that prefix and add the XOR of the newly available suffix (which does not coincide with the new prefix) to the trie, then query the trie for the best possible match for the XOR of the new prefix. (Try to get 1 as the first digit if possible, otherwise put 0, then do the same thing for the second digit and so on). Get a maximum over all answers you've found, and it's all done. [By digit, I mean binary digit]GNU C++: 3314616, 3314619We hope you enjoyed the tasks.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6999",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 282 和字母"
          },
          "content_length": 3281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 1",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 2",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 3",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 4",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 5",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 6",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 1",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 2",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 3",
          "code": "for(int i = 0; i <= a[0]; i++) {\n    for(int j = 0; j <= a[1]; j++) {\n        if(win[i][j]) continue;\n        for(int k = 1; k <= 300; k++) {\n            win[i+k][j+k] = 1;\n            win[i][j+k] = 1;\n            win[i+k][j] = 1;\n        }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(0, 1000, \"ai\");\n        inf.readSpace();\n        int gi = inf.readInt(0, 1000, \"gi\");\n        inf.readEoln();\n\n        ensuref(ai + gi == 1000, \"For egg %d, ai + gi (%d + %d) != 1000\", i+1, ai, gi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(0, 1000, \"ai\");\n        inf.readSpace();\n        int gi = inf.readInt(0, 1000, \"gi\");\n        inf.readEoln();\n\n        ensuref(ai + gi == 1000, \"For egg %d, ai + gi (%d + %d) != 1000\", i+1, ai, gi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(0, 1000, \"ai\");\n        inf.readSpace();\n        int gi = inf.readInt(0, 1000, \"gi\");\n        inf.readEoln();\n\n        ensuref(ai + gi == 1000, \"For egg %d, ai + gi (%d + %d) != 1000\", i+1, ai, gi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> a, g;\n\nbool readAns(InStream &stream, const char *name) {\n    string s = stream.readToken();\n    if (s == \"-1\") {\n        return false;\n    } else {\n        // Check that s.length() == n\n        if ((int)s.length() != n) {\n            stream.quitf(_pe, \"%s output length is %d, expected %d\", name, (int)s.length(), n);\n        }\n        long long Sa = 0, Sg = 0;\n        for (int i = 0; i < n; ++i) {\n            char ch = s[i];\n            if (ch == 'A') {\n                Sa += a[i];\n            } else if (ch == 'G') {\n                Sg += g[i];\n            } else {\n                stream.quitf(_pe, \"%s has invalid character '%c' at position %d, expected 'A' or 'G'\", name, ch, i + 1);\n            }\n        }\n        if (abs(Sa - Sg) > 500) {\n            stream.quitf(_wa, \"%s has Sa = %lld, Sg = %lld, |Sa - Sg| = %lld > 500\", name, Sa, Sg, abs(Sa - Sg));\n        }\n        return true;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    a.resize(n);\n    g.resize(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(0, 1000);\n        g[i] = inf.readInt(0, 1000);\n        if (a[i] + g[i] != 1000) {\n            quitf(_fail, \"Invalid input: a[%d] + g[%d] != 1000\", i + 1, i + 1);\n        }\n    }\n\n    bool juryPossible, participantPossible;\n    // Read jury's answer\n    juryPossible = readAns(ans, \"Jury\");\n\n    // Read participant's answer\n    participantPossible = readAns(ouf, \"Participant\");\n\n    if (!participantPossible) {\n        if (!juryPossible) {\n            quitf(_ok, \"Both outputs are '-1', impossible\");\n        } else {\n            quitf(_wa, \"Participant outputs impossible but jury has a valid assignment\");\n        }\n    } else {\n        if (!juryPossible) {\n            quitf(_fail, \"Participant found a valid assignment but jury says impossible\");\n        } else {\n            quitf(_ok, \"Participant outputs a valid assignment\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    vector<int> ai(n), gi(n);\n    long long sum_ai = 0;\n\n    if (type == \"possible\") {\n        // All ai = 500\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 500;\n            gi[i] = 500;\n            sum_ai += ai[i];\n        }\n    } else if (type == \"impossible_low\") {\n        // All ai = 0\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n            gi[i] = 1000;\n            sum_ai += ai[i];\n        }\n    } else if (type == \"impossible_high\") {\n        // All ai = 1000\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1000;\n            gi[i] = 0;\n            sum_ai += ai[i];\n        }\n    } else if (type == \"random_possible\") {\n        // Generate random ai's, adjust sum(ai)\n        long long min_sum_ai = n * 500 - 250;\n        long long max_sum_ai = n * 500 + 250;\n\n        sum_ai = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 1000);\n            gi[i] = 1000 - ai[i];\n            sum_ai += ai[i];\n        }\n\n        // Adjust sum_ai to be within acceptable range if necessary\n        if (sum_ai < min_sum_ai) {\n            // Increase ai's to reach min_sum_ai\n            long long increase_needed = min_sum_ai - sum_ai;\n            for (int i = 0; i < n && increase_needed > 0; ++i) {\n                int delta = min(1000 - ai[i], (int)increase_needed);\n                ai[i] += delta;\n                gi[i] -= delta;\n                sum_ai += delta;\n                increase_needed -= delta;\n            }\n            if (increase_needed > 0) {\n                // Cannot adjust to required sum, make impossible_low test case\n                for (int i = 0; i < n; ++i) {\n                    ai[i] = 0;\n                    gi[i] = 1000;\n                }\n            }\n        } else if (sum_ai > max_sum_ai) {\n            // Decrease ai's to reach max_sum_ai\n            long long decrease_needed = sum_ai - max_sum_ai;\n            for (int i = 0; i < n && decrease_needed > 0; ++i) {\n                int delta = min(ai[i], (int)decrease_needed);\n                ai[i] -= delta;\n                gi[i] += delta;\n                sum_ai -= delta;\n                decrease_needed -= delta;\n            }\n            if (decrease_needed > 0) {\n                // Cannot adjust to required sum, make impossible_high test case\n                for (int i = 0; i < n; ++i) {\n                    ai[i] = 1000;\n                    gi[i] = 0;\n                }\n            }\n        }\n    } else if (type == \"impossible_random\") {\n        // Generate random ai's such that sum(ai) is outside the acceptable range\n        long long min_sum_ai = n * 500 - 250;\n        long long max_sum_ai = n * 500 + 250;\n\n        do {\n            sum_ai = 0;\n            for (int i = 0; i < n; ++i) {\n                ai[i] = rnd.next(0, 1000);\n                gi[i] = 1000 - ai[i];\n                sum_ai += ai[i];\n            }\n        } while (sum_ai >= min_sum_ai && sum_ai <= max_sum_ai);\n    } else {\n        // Default: all ai = 500 (possible)\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 500;\n            gi[i] = 500;\n            sum_ai += ai[i];\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai and gi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ai[i], gi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    vector<int> ai(n), gi(n);\n    long long sum_ai = 0;\n\n    if (type == \"possible\") {\n        // All ai = 500\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 500;\n            gi[i] = 500;\n            sum_ai += ai[i];\n        }\n    } else if (type == \"impossible_low\") {\n        // All ai = 0\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n            gi[i] = 1000;\n            sum_ai += ai[i];\n        }\n    } else if (type == \"impossible_high\") {\n        // All ai = 1000\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1000;\n            gi[i] = 0;\n            sum_ai += ai[i];\n        }\n    } else if (type == \"random_possible\") {\n        // Generate random ai's, adjust sum(ai)\n        long long min_sum_ai = n * 500 - 250;\n        long long max_sum_ai = n * 500 + 250;\n\n        sum_ai = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 1000);\n            gi[i] = 1000 - ai[i];\n            sum_ai += ai[i];\n        }\n\n        // Adjust sum_ai to be within acceptable range if necessary\n        if (sum_ai < min_sum_ai) {\n            // Increase ai's to reach min_sum_ai\n            long long increase_needed = min_sum_ai - sum_ai;\n            for (int i = 0; i < n && increase_needed > 0; ++i) {\n                int delta = min(1000 - ai[i], (int)increase_needed);\n                ai[i] += delta;\n                gi[i] -= delta;\n                sum_ai += delta;\n                increase_needed -= delta;\n            }\n            if (increase_needed > 0) {\n                // Cannot adjust to required sum, make impossible_low test case\n                for (int i = 0; i < n; ++i) {\n                    ai[i] = 0;\n                    gi[i] = 1000;\n                }\n            }\n        } else if (sum_ai > max_sum_ai) {\n            // Decrease ai's to reach max_sum_ai\n            long long decrease_needed = sum_ai - max_sum_ai;\n            for (int i = 0; i < n && decrease_needed > 0; ++i) {\n                int delta = min(ai[i], (int)decrease_needed);\n                ai[i] -= delta;\n                gi[i] += delta;\n                sum_ai -= delta;\n                decrease_needed -= delta;\n            }\n            if (decrease_needed > 0) {\n                // Cannot adjust to required sum, make impossible_high test case\n                for (int i = 0; i < n; ++i) {\n                    ai[i] = 1000;\n                    gi[i] = 0;\n                }\n            }\n        }\n    } else if (type == \"impossible_random\") {\n        // Generate random ai's such that sum(ai) is outside the acceptable range\n        long long min_sum_ai = n * 500 - 250;\n        long long max_sum_ai = n * 500 + 250;\n\n        do {\n            sum_ai = 0;\n            for (int i = 0; i < n; ++i) {\n                ai[i] = rnd.next(0, 1000);\n                gi[i] = 1000 - ai[i];\n                sum_ai += ai[i];\n            }\n        } while (sum_ai >= min_sum_ai && sum_ai <= max_sum_ai);\n    } else {\n        // Default: all ai = 500 (possible)\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 500;\n            gi[i] = 500;\n            sum_ai += ai[i];\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai and gi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ai[i], gi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type possible\n./gen -n 2 -type impossible_low\n./gen -n 2 -type impossible_high\n./gen -n 2 -type random_possible\n./gen -n 2 -type impossible_random\n\n./gen -n 10 -type possible\n./gen -n 10 -type impossible_low\n./gen -n 10 -type impossible_high\n./gen -n 10 -type random_possible\n./gen -n 10 -type impossible_random\n\n./gen -n 100 -type possible\n./gen -n 100 -type impossible_low\n./gen -n 100 -type impossible_high\n./gen -n 100 -type random_possible\n./gen -n 100 -type impossible_random\n\n./gen -n 1000 -type possible\n./gen -n 1000 -type impossible_low\n./gen -n 1000 -type impossible_high\n./gen -n 1000 -type random_possible\n./gen -n 1000 -type impossible_random\n\n./gen -n 10000 -type possible\n./gen -n 10000 -type impossible_low\n./gen -n 10000 -type impossible_high\n./gen -n 10000 -type random_possible\n./gen -n 10000 -type impossible_random\n\n./gen -n 100000 -type possible\n./gen -n 100000 -type impossible_low\n./gen -n 100000 -type impossible_high\n./gen -n 100000 -type random_possible\n./gen -n 100000 -type impossible_random\n\n./gen -n 1000000 -type possible\n./gen -n 1000000 -type impossible_low\n./gen -n 1000000 -type impossible_high\n./gen -n 1000000 -type random_possible\n./gen -n 1000000 -type impossible_random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:45.147833",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "282/C",
      "title": "C. XOR and OR",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains Bitlandish string a, the second line contains Bitlandish string b. The strings can have different lengths.It is guaranteed that the given strings only consist of characters \"0\" and \"1\". The strings are not empty, their length doesn't exceed 106.",
      "output_spec": "OutputPrint \"YES\" if a can be transformed into b, otherwise print \"NO\". Please do not print the quotes.",
      "sample_tests": "ExamplesInputCopy1110OutputCopyYESInputCopy101OutputCopyNOInputCopy000101OutputCopyNO",
      "description": "C. XOR and OR\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains Bitlandish string a, the second line contains Bitlandish string b. The strings can have different lengths.It is guaranteed that the given strings only consist of characters \"0\" and \"1\". The strings are not empty, their length doesn't exceed 106.\n\nOutputPrint \"YES\" if a can be transformed into b, otherwise print \"NO\". Please do not print the quotes.\n\nInputCopy1110OutputCopyYESInputCopy101OutputCopyNOInputCopy000101OutputCopyNO\n\nInputCopy1110\n\nOutputCopyYES\n\nInputCopy101\n\nOutputCopyNO\n\nInputCopy000101\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces",
          "content": "Hi all! :{We're glad to invite you to participate in Codeforces Round #173 prepared by A.K.Goharshady, LGM and me (havaliza). I want to thank Gerald, MikeMirzayanov and Delinur who helped us to prepare the round on this platform. And thanks to dani1373, hhoomn, mruxim, MMJ and xorfire who tested the problems and helped us a lot.Today is LGM's birthday and yesterday was gpac's birthday. Happy birthday to you guys! ^.^Hope you enjoy today's round and have lots of fun. :)Update. The editorial is out!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6954",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 502
        },
        {
          "title": "Round #173 — Editorial - Codeforces",
          "content": "Hi, Here's the editorial.Please note that not all the codes presented below belong to me. (It's a combination of codes from our problemsetters and testers) -- And I borrowed AKGMA's account since I wasn't able to link to my own submissions somehow!Note: It seems that the Codeforces mark-up is not functioning. To see a submission go to: http://www.codeforces.com/contest/282/submission/submission-numberA: Bit++Just use a simple loop. (Take a look at the Python code)GNU C++: 3314442, 3314464GNU C: 3314471Python: 3314475B: Painting EggsThis one can be solved by a greedy algorithm. Start from the 1st egg and each time give the egg to A if and only if giving it to A doesn't make the difference > 500, otherwise give it to G.To prove the correctness, one can use induction. The base case is trivial. Suppose that we've assigned the first n - 1 eggs such that the total money given to A is Sa and total money given to G is Sg. We can assume Sa ≥ Sg. Now we must either add gn to Sg or add an to Sa. If we can't add gn to Sg, then Sg + gn > Sa + 500, so  - 500 > Sa - Sg - gn, adding 1000 to both sides gives us the inequality 500 > Sa + (1000 - gn) - Sg which is exactly what we need to make sure that we can add an = 1000 - gn to Sa.GNU C++: 3314480, 3314484GNU C: 3314488Python: 3314492C: XOR and ORFirst of all, check the length of the two strings to be equal. Then with a little try and guess, you can find out that the zero string (00...0) can't be converted to anything else and nothing else can be converted to zero. All other conversions are possible.GNU C++: 3314503, 3314504, 3314509, 3314512, 3314514D: Yet another Number GameFor n=1, everything is clear. If a1 = 0 then BitAryo wins, otherwise BitLGM is the winner.For n=2: define win[i][j] = (Whether i,j is a Winning position). It's easy to calculate win[i][j] for all i and j, using a loop (Checking all possible moves). This leads us to an O(n3) solution.For n=3: Everything is similar to NIM, With the same statement of proof as for NIM, i,j,k is a winning position if and only if (i xor j xor k)  ≠ 0.[Don't forget the parentheses in code :) ] Complexity: O(1)One can also solve this case using DP. We define lose[i][j]= (Least k, such that i,j,k is a losing position) ,lose2[i][j]=(Least k, such that k,k+i,k+i+j is a losing position) and win[i][j][k] just as the case with n=2. As in the codes below, one can calculate all these values in O(n3).Using the same DP strategy for n=2 and the O(1) algorithm for n=3 and n=1, leads us to a total complexity of O(n2) which was not necessary in this contest.GNU C++: 3314578, 3314580, 3314585, 3314588E: Sausage MaximizationCan be solved using a trie in O(n log (max{ai})).Start with a prefix of size n, and decrease the size of prefix in each step. For each new prefix calculate the XOR of elements in that prefix and add the XOR of the newly available suffix (which does not coincide with the new prefix) to the trie, then query the trie for the best possible match for the XOR of the new prefix. (Try to get 1 as the first digit if possible, otherwise put 0, then do the same thing for the second digit and so on). Get a maximum over all answers you've found, and it's all done. [By digit, I mean binary digit]GNU C++: 3314616, 3314619We hope you enjoyed the tasks.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6999",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 282 和字母"
          },
          "content_length": 3281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 1",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 2",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 3",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 4",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 5",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 6",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 1",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 2",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 3",
          "code": "for(int i = 0; i <= a[0]; i++) {\n    for(int j = 0; j <= a[1]; j++) {\n        if(win[i][j]) continue;\n        for(int k = 1; k <= 300; k++) {\n            win[i+k][j+k] = 1;\n            win[i][j+k] = 1;\n            win[i+k][j] = 1;\n        }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[01]{1,1000000}\", \"a\");\n    string b = inf.readLine(\"[01]{1,1000000}\", \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[01]{1,1000000}\", \"a\");\n    string b = inf.readLine(\"[01]{1,1000000}\", \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[01]{1,1000000}\", \"a\");\n    string b = inf.readLine(\"[01]{1,1000000}\", \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"random\");\n    string a, b;\n\n    if(type == \"different_length\") {\n        // Generate strings a and b of different lengths n and m\n        a.resize(n);\n        b.resize(m);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(2) + '0';\n        for(int i = 0; i < m; ++i)\n            b[i] = rnd.next(2) + '0';\n    } else if(type == \"a_all_zeros_b_all_ones\") {\n        // a consists of all '0's, b consists of all '1's\n        a = string(n, '0');\n        b = string(n, '1');\n    } else if(type == \"a_all_zeros_b_random\") {\n        // a consists of all '0's, b is random\n        a = string(n, '0');\n        b.resize(n);\n        for(int i = 0; i < n; ++i)\n            b[i] = rnd.next(2) + '0';\n    } else if(type == \"a_has_one_b_random\") {\n        // a consists of all '0's except one random position has '1', b is random\n        a = string(n, '0');\n        int pos = rnd.next(0, n - 1);\n        a[pos] = '1';\n        b.resize(n);\n        for(int i = 0; i < n; ++i)\n            b[i] = rnd.next(2) + '0';\n    } else if(type == \"identical_strings\") {\n        // a and b are identical random strings\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(2) + '0';\n        b = a;\n    } else if(type == \"a_has_ones_b_random\") {\n        // a is random with at least one '1', b is random\n        a.resize(n);\n        bool has_one = false;\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2) + '0';\n            if(a[i] == '1') has_one = true;\n        }\n        if(!has_one) {\n            int pos = rnd.next(0, n - 1);\n            a[pos] = '1';\n        }\n        b.resize(n);\n        for(int i = 0; i < n; ++i)\n            b[i] = rnd.next(2) + '0';\n    } else if(type == \"random\") {\n        // a and b are random strings\n        a.resize(n);\n        b.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2) + '0';\n            b[i] = rnd.next(2) + '0';\n        }\n    }\n\n    // Output strings a and b\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"random\");\n    string a, b;\n\n    if(type == \"different_length\") {\n        // Generate strings a and b of different lengths n and m\n        a.resize(n);\n        b.resize(m);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(2) + '0';\n        for(int i = 0; i < m; ++i)\n            b[i] = rnd.next(2) + '0';\n    } else if(type == \"a_all_zeros_b_all_ones\") {\n        // a consists of all '0's, b consists of all '1's\n        a = string(n, '0');\n        b = string(n, '1');\n    } else if(type == \"a_all_zeros_b_random\") {\n        // a consists of all '0's, b is random\n        a = string(n, '0');\n        b.resize(n);\n        for(int i = 0; i < n; ++i)\n            b[i] = rnd.next(2) + '0';\n    } else if(type == \"a_has_one_b_random\") {\n        // a consists of all '0's except one random position has '1', b is random\n        a = string(n, '0');\n        int pos = rnd.next(0, n - 1);\n        a[pos] = '1';\n        b.resize(n);\n        for(int i = 0; i < n; ++i)\n            b[i] = rnd.next(2) + '0';\n    } else if(type == \"identical_strings\") {\n        // a and b are identical random strings\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(2) + '0';\n        b = a;\n    } else if(type == \"a_has_ones_b_random\") {\n        // a is random with at least one '1', b is random\n        a.resize(n);\n        bool has_one = false;\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2) + '0';\n            if(a[i] == '1') has_one = true;\n        }\n        if(!has_one) {\n            int pos = rnd.next(0, n - 1);\n            a[pos] = '1';\n        }\n        b.resize(n);\n        for(int i = 0; i < n; ++i)\n            b[i] = rnd.next(2) + '0';\n    } else if(type == \"random\") {\n        // a and b are random strings\n        a.resize(n);\n        b.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2) + '0';\n            b[i] = rnd.next(2) + '0';\n        }\n    }\n\n    // Output strings a and b\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type a_all_zeros_b_all_ones\n./gen -n 1 -type a_all_zeros_b_random\n./gen -n 1 -type a_has_one_b_random\n./gen -n 1 -type a_has_ones_b_random\n./gen -n 1 -type identical_strings\n./gen -n 1 -type random\n./gen -n 1 -type different_length -m 2\n\n./gen -n 2 -type a_all_zeros_b_all_ones\n./gen -n 2 -type a_all_zeros_b_random\n./gen -n 2 -type a_has_one_b_random\n./gen -n 2 -type a_has_ones_b_random\n./gen -n 2 -type identical_strings\n./gen -n 2 -type random\n./gen -n 2 -type different_length -m 3\n\n./gen -n 10 -type a_all_zeros_b_all_ones\n./gen -n 10 -type a_all_zeros_b_random\n./gen -n 10 -type a_has_one_b_random\n./gen -n 10 -type a_has_ones_b_random\n./gen -n 10 -type identical_strings\n./gen -n 10 -type random\n\n./gen -n 100 -type a_all_zeros_b_all_ones\n./gen -n 100 -type a_all_zeros_b_random\n./gen -n 100 -type a_has_one_b_random\n./gen -n 100 -type a_has_ones_b_random\n./gen -n 100 -type identical_strings\n./gen -n 100 -type random\n\n./gen -n 1000 -type different_length -m 999\n\n./gen -n 10000 -type a_all_zeros_b_all_ones\n./gen -n 10000 -type a_all_zeros_b_random\n./gen -n 10000 -type different_length -m 10001\n./gen -n 10000 -type random\n\n./gen -n 100000 -type a_has_one_b_random\n./gen -n 100000 -type identical_strings\n./gen -n 100000 -type random\n\n./gen -n 1000000 -type a_all_zeros_b_all_ones\n./gen -n 1000000 -type a_all_zeros_b_random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:46.737125",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "282/D",
      "title": "D. Yet Another Number Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 3).The next line contains n integers a1, a2, ..., an (0 ≤ ai < 300).",
      "output_spec": "OutputWrite the name of the winner (provided that both players play optimally well). Either \"BitLGM\" or \"BitAryo\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy21 1OutputCopyBitLGMInputCopy21 2OutputCopyBitAryoInputCopy31 2 1OutputCopyBitLGM",
      "description": "D. Yet Another Number Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 3).The next line contains n integers a1, a2, ..., an (0 ≤ ai < 300).\n\nOutputWrite the name of the winner (provided that both players play optimally well). Either \"BitLGM\" or \"BitAryo\" (without the quotes).\n\nInputCopy21 1OutputCopyBitLGMInputCopy21 2OutputCopyBitAryoInputCopy31 2 1OutputCopyBitLGM\n\nInputCopy21 1\n\nOutputCopyBitLGM\n\nInputCopy21 2\n\nOutputCopyBitAryo\n\nInputCopy31 2 1\n\nOutputCopyBitLGM",
      "solutions": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces",
          "content": "Hi all! :{We're glad to invite you to participate in Codeforces Round #173 prepared by A.K.Goharshady, LGM and me (havaliza). I want to thank Gerald, MikeMirzayanov and Delinur who helped us to prepare the round on this platform. And thanks to dani1373, hhoomn, mruxim, MMJ and xorfire who tested the problems and helped us a lot.Today is LGM's birthday and yesterday was gpac's birthday. Happy birthday to you guys! ^.^Hope you enjoy today's round and have lots of fun. :)Update. The editorial is out!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6954",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 502
        },
        {
          "title": "Round #173 — Editorial - Codeforces",
          "content": "Hi, Here's the editorial.Please note that not all the codes presented below belong to me. (It's a combination of codes from our problemsetters and testers) -- And I borrowed AKGMA's account since I wasn't able to link to my own submissions somehow!Note: It seems that the Codeforces mark-up is not functioning. To see a submission go to: http://www.codeforces.com/contest/282/submission/submission-numberA: Bit++Just use a simple loop. (Take a look at the Python code)GNU C++: 3314442, 3314464GNU C: 3314471Python: 3314475B: Painting EggsThis one can be solved by a greedy algorithm. Start from the 1st egg and each time give the egg to A if and only if giving it to A doesn't make the difference > 500, otherwise give it to G.To prove the correctness, one can use induction. The base case is trivial. Suppose that we've assigned the first n - 1 eggs such that the total money given to A is Sa and total money given to G is Sg. We can assume Sa ≥ Sg. Now we must either add gn to Sg or add an to Sa. If we can't add gn to Sg, then Sg + gn > Sa + 500, so  - 500 > Sa - Sg - gn, adding 1000 to both sides gives us the inequality 500 > Sa + (1000 - gn) - Sg which is exactly what we need to make sure that we can add an = 1000 - gn to Sa.GNU C++: 3314480, 3314484GNU C: 3314488Python: 3314492C: XOR and ORFirst of all, check the length of the two strings to be equal. Then with a little try and guess, you can find out that the zero string (00...0) can't be converted to anything else and nothing else can be converted to zero. All other conversions are possible.GNU C++: 3314503, 3314504, 3314509, 3314512, 3314514D: Yet another Number GameFor n=1, everything is clear. If a1 = 0 then BitAryo wins, otherwise BitLGM is the winner.For n=2: define win[i][j] = (Whether i,j is a Winning position). It's easy to calculate win[i][j] for all i and j, using a loop (Checking all possible moves). This leads us to an O(n3) solution.For n=3: Everything is similar to NIM, With the same statement of proof as for NIM, i,j,k is a winning position if and only if (i xor j xor k)  ≠ 0.[Don't forget the parentheses in code :) ] Complexity: O(1)One can also solve this case using DP. We define lose[i][j]= (Least k, such that i,j,k is a losing position) ,lose2[i][j]=(Least k, such that k,k+i,k+i+j is a losing position) and win[i][j][k] just as the case with n=2. As in the codes below, one can calculate all these values in O(n3).Using the same DP strategy for n=2 and the O(1) algorithm for n=3 and n=1, leads us to a total complexity of O(n2) which was not necessary in this contest.GNU C++: 3314578, 3314580, 3314585, 3314588E: Sausage MaximizationCan be solved using a trie in O(n log (max{ai})).Start with a prefix of size n, and decrease the size of prefix in each step. For each new prefix calculate the XOR of elements in that prefix and add the XOR of the newly available suffix (which does not coincide with the new prefix) to the trie, then query the trie for the best possible match for the XOR of the new prefix. (Try to get 1 as the first digit if possible, otherwise put 0, then do the same thing for the second digit and so on). Get a maximum over all answers you've found, and it's all done. [By digit, I mean binary digit]GNU C++: 3314616, 3314619We hope you enjoyed the tasks.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6999",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 282 和字母"
          },
          "content_length": 3281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 1",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 2",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 3",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 4",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 5",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 6",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 1",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 2",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 3",
          "code": "for(int i = 0; i <= a[0]; i++) {\n    for(int j = 0; j <= a[1]; j++) {\n        if(win[i][j]) continue;\n        for(int k = 1; k <= 300; k++) {\n            win[i+k][j+k] = 1;\n            win[i][j+k] = 1;\n            win[i+k][j] = 1;\n        }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 299, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 299, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 299, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    if (type == \"zeros\") {\n        /* All zeros */\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"ones\") {\n        /* All ones */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max\") {\n        /* All maximum values (299) */\n        for(int i = 0; i < n; ++i)\n            a[i] = 299;\n    } else if (type == \"mixed\") {\n        /* Mix of zeros and maximums */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1) * 299;\n    } else if (type == \"increasing\") {\n        /* Increasing sequence */\n        int base = rnd.next(0, 100);\n        for(int i = 0; i < n; ++i) {\n            a[i] = base + i;\n            if (a[i] >= 300)\n                a[i] = 299;\n        }\n    } else if (type == \"decreasing\") {\n        /* Decreasing sequence */\n        int base = rnd.next(2, 299);\n        for(int i = 0; i < n; ++i) {\n            a[i] = base - i;\n            if (a[i] < 0)\n                a[i] = 0;\n        }\n    } else if (type == \"pattern\") {\n        /* Specific pattern */\n        if (n == 1) {\n            a[0] = 299;\n        } else if (n == 2) {\n            a[0] = 0;\n            a[1] = 299;\n        } else if (n == 3) {\n            a[0] = 1;\n            a[1] = 2;\n            a[2] = 3;\n        }\n    } else {\n        /* Random values */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 299);\n    }\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output the sequence */\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    if (type == \"zeros\") {\n        /* All zeros */\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"ones\") {\n        /* All ones */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max\") {\n        /* All maximum values (299) */\n        for(int i = 0; i < n; ++i)\n            a[i] = 299;\n    } else if (type == \"mixed\") {\n        /* Mix of zeros and maximums */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1) * 299;\n    } else if (type == \"increasing\") {\n        /* Increasing sequence */\n        int base = rnd.next(0, 100);\n        for(int i = 0; i < n; ++i) {\n            a[i] = base + i;\n            if (a[i] >= 300)\n                a[i] = 299;\n        }\n    } else if (type == \"decreasing\") {\n        /* Decreasing sequence */\n        int base = rnd.next(2, 299);\n        for(int i = 0; i < n; ++i) {\n            a[i] = base - i;\n            if (a[i] < 0)\n                a[i] = 0;\n        }\n    } else if (type == \"pattern\") {\n        /* Specific pattern */\n        if (n == 1) {\n            a[0] = 299;\n        } else if (n == 2) {\n            a[0] = 0;\n            a[1] = 299;\n        } else if (n == 3) {\n            a[0] = 1;\n            a[1] = 2;\n            a[2] = 3;\n        }\n    } else {\n        /* Random values */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 299);\n    }\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output the sequence */\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type ones\n./gen -n 1 -type max\n./gen -n 1 -type mixed\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n./gen -n 1 -type pattern\n./gen -n 1 -type random\n\n./gen -n 2 -type zeros\n./gen -n 2 -type ones\n./gen -n 2 -type max\n./gen -n 2 -type mixed\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type pattern\n./gen -n 2 -type random\n\n./gen -n 3 -type zeros\n./gen -n 3 -type ones\n./gen -n 3 -type max\n./gen -n 3 -type mixed\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type pattern\n./gen -n 3 -type random\n\n./gen -n 3 -type random\n./gen -n 3 -type random\n./gen -n 3 -type random\n./gen -n 2 -type random\n./gen -n 2 -type random\n./gen -n 2 -type random\n./gen -n 1 -type random\n./gen -n 1 -type random\n./gen -n 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:48.858595",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "282/E",
      "title": "E. Sausage Maximization",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105).The next line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 1012) — Mr. Bitkoch's sausage.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint a single integer — the maximum pleasure BitHaval and BitAryo can get from the dinner.",
      "sample_tests": "ExamplesInputCopy21 2OutputCopy3InputCopy31 2 3OutputCopy3InputCopy21000 1000OutputCopy1000",
      "description": "E. Sausage Maximization\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105).The next line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 1012) — Mr. Bitkoch's sausage.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint a single integer — the maximum pleasure BitHaval and BitAryo can get from the dinner.\n\nInputCopy21 2OutputCopy3InputCopy31 2 3OutputCopy3InputCopy21000 1000OutputCopy1000\n\nInputCopy21 2\n\nOutputCopy3\n\nInputCopy31 2 3\n\nOutputCopy3\n\nInputCopy21000 1000\n\nOutputCopy1000",
      "solutions": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces",
          "content": "Hi all! :{We're glad to invite you to participate in Codeforces Round #173 prepared by A.K.Goharshady, LGM and me (havaliza). I want to thank Gerald, MikeMirzayanov and Delinur who helped us to prepare the round on this platform. And thanks to dani1373, hhoomn, mruxim, MMJ and xorfire who tested the problems and helped us a lot.Today is LGM's birthday and yesterday was gpac's birthday. Happy birthday to you guys! ^.^Hope you enjoy today's round and have lots of fun. :)Update. The editorial is out!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6954",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 502
        },
        {
          "title": "Round #173 — Editorial - Codeforces",
          "content": "Hi, Here's the editorial.Please note that not all the codes presented below belong to me. (It's a combination of codes from our problemsetters and testers) -- And I borrowed AKGMA's account since I wasn't able to link to my own submissions somehow!Note: It seems that the Codeforces mark-up is not functioning. To see a submission go to: http://www.codeforces.com/contest/282/submission/submission-numberA: Bit++Just use a simple loop. (Take a look at the Python code)GNU C++: 3314442, 3314464GNU C: 3314471Python: 3314475B: Painting EggsThis one can be solved by a greedy algorithm. Start from the 1st egg and each time give the egg to A if and only if giving it to A doesn't make the difference > 500, otherwise give it to G.To prove the correctness, one can use induction. The base case is trivial. Suppose that we've assigned the first n - 1 eggs such that the total money given to A is Sa and total money given to G is Sg. We can assume Sa ≥ Sg. Now we must either add gn to Sg or add an to Sa. If we can't add gn to Sg, then Sg + gn > Sa + 500, so  - 500 > Sa - Sg - gn, adding 1000 to both sides gives us the inequality 500 > Sa + (1000 - gn) - Sg which is exactly what we need to make sure that we can add an = 1000 - gn to Sa.GNU C++: 3314480, 3314484GNU C: 3314488Python: 3314492C: XOR and ORFirst of all, check the length of the two strings to be equal. Then with a little try and guess, you can find out that the zero string (00...0) can't be converted to anything else and nothing else can be converted to zero. All other conversions are possible.GNU C++: 3314503, 3314504, 3314509, 3314512, 3314514D: Yet another Number GameFor n=1, everything is clear. If a1 = 0 then BitAryo wins, otherwise BitLGM is the winner.For n=2: define win[i][j] = (Whether i,j is a Winning position). It's easy to calculate win[i][j] for all i and j, using a loop (Checking all possible moves). This leads us to an O(n3) solution.For n=3: Everything is similar to NIM, With the same statement of proof as for NIM, i,j,k is a winning position if and only if (i xor j xor k)  ≠ 0.[Don't forget the parentheses in code :) ] Complexity: O(1)One can also solve this case using DP. We define lose[i][j]= (Least k, such that i,j,k is a losing position) ,lose2[i][j]=(Least k, such that k,k+i,k+i+j is a losing position) and win[i][j][k] just as the case with n=2. As in the codes below, one can calculate all these values in O(n3).Using the same DP strategy for n=2 and the O(1) algorithm for n=3 and n=1, leads us to a total complexity of O(n2) which was not necessary in this contest.GNU C++: 3314578, 3314580, 3314585, 3314588E: Sausage MaximizationCan be solved using a trie in O(n log (max{ai})).Start with a prefix of size n, and decrease the size of prefix in each step. For each new prefix calculate the XOR of elements in that prefix and add the XOR of the newly available suffix (which does not coincide with the new prefix) to the trie, then query the trie for the best possible match for the XOR of the new prefix. (Try to get 1 as the first digit if possible, otherwise put 0, then do the same thing for the second digit and so on). Get a maximum over all answers you've found, and it's all done. [By digit, I mean binary digit]GNU C++: 3314616, 3314619We hope you enjoyed the tasks.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6999",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 282 和字母"
          },
          "content_length": 3281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 1",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 2",
          "code": "6\n13 21 3 61 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 3",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 4",
          "code": "string a=\"\";\nfor (int i = 0; i < 1000000; ++i){\n  a+='1';\n}\ncout<<a<<endl;\ncout<<a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 5",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #173 (Div. 2) - Codeforces - Code 6",
          "code": "if ( yek1 >= ceil((float)yek2/(float)2) ){...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6954",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 1",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 2",
          "code": "X | Y | X^Y | X|Y\n0 | 0 |  0  |  0\n0 | 1 |  1  |  1\n1 | 0 |  1  |  1\n1 | 1 |  0  |  1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        },
        {
          "title": "Round #173 — Editorial - Codeforces - Code 3",
          "code": "for(int i = 0; i <= a[0]; i++) {\n    for(int j = 0; j <= a[1]; j++) {\n        if(win[i][j]) continue;\n        for(int k = 1; k <= 300; k++) {\n            win[i+k][j+k] = 1;\n            win[i][j+k] = 1;\n            win[i+k][j] = 1;\n        }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/6999",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 0, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 0, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 0, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"random\") {\n        /* Generate random values for a_i within the range [0, MAX_A] */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL); // Default MAX_A = 1e12\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n        }\n    } else if (type == \"all_zero\") {\n        /* All elements are zero */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"all_same\") {\n        /* All elements are the same value */\n        long long val = opt<long long>(\"value\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"alternating\") {\n        /* Elements alternate between two values x and y */\n        long long x = opt<long long>(\"x\", 0);\n        long long y = opt<long long>(\"y\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? x : y;\n        }\n    } else if (type == \"maximal_pleasure_at_p0\") {\n        /* Maximize pleasure when BitHaval's sausage is empty (p = 0) */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n        }\n    } else if (type == \"maximal_pleasure_at_pn\") {\n        /* Maximize pleasure when BitAryo's sausage is empty (p = n) */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n        }\n    } else if (type == \"max_zero_pleasure\") {\n        /* Construct a sequence where the total XOR is zero */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL);\n        long long cumulative_xor = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n            cumulative_xor ^= a[i];\n        }\n        a[n - 1] = cumulative_xor; // Set last element so that total XOR is zero\n    } else {\n        /* Default to random */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n        }\n    }\n\n    /* Output n */\n    cout << n << \"\\n\";\n\n    /* Output the array a */\n    for (int i = 0; i < n; ++i) {\n        cout << a[i];\n        if (i + 1 < n) cout << \" \";\n        else cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"random\") {\n        /* Generate random values for a_i within the range [0, MAX_A] */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL); // Default MAX_A = 1e12\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n        }\n    } else if (type == \"all_zero\") {\n        /* All elements are zero */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"all_same\") {\n        /* All elements are the same value */\n        long long val = opt<long long>(\"value\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"alternating\") {\n        /* Elements alternate between two values x and y */\n        long long x = opt<long long>(\"x\", 0);\n        long long y = opt<long long>(\"y\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? x : y;\n        }\n    } else if (type == \"maximal_pleasure_at_p0\") {\n        /* Maximize pleasure when BitHaval's sausage is empty (p = 0) */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n        }\n    } else if (type == \"maximal_pleasure_at_pn\") {\n        /* Maximize pleasure when BitAryo's sausage is empty (p = n) */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n        }\n    } else if (type == \"max_zero_pleasure\") {\n        /* Construct a sequence where the total XOR is zero */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL);\n        long long cumulative_xor = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n            cumulative_xor ^= a[i];\n        }\n        a[n - 1] = cumulative_xor; // Set last element so that total XOR is zero\n    } else {\n        /* Default to random */\n        long long MAX_A = opt<long long>(\"maxa\", 1000000000000LL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, MAX_A);\n        }\n    }\n\n    /* Output n */\n    cout << n << \"\\n\";\n\n    /* Output the array a */\n    for (int i = 0; i < n; ++i) {\n        cout << a[i];\n        if (i + 1 < n) cout << \" \";\n        else cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n tests\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n\n./gen -n 1 -type all_zero\n./gen -n 2 -type all_zero\n./gen -n 3 -type all_zero\n\n./gen -n 1 -type all_same -value 42\n./gen -n 2 -type all_same -value 42\n./gen -n 3 -type all_same -value 42\n\n./gen -n 4 -type alternating -x 1 -y 2\n./gen -n 5 -type alternating -x 1 -y 2\n./gen -n 6 -type alternating -x 1 -y 2\n\n./gen -n 5 -type max_zero_pleasure\n./gen -n 5 -type maximal_pleasure_at_p0\n./gen -n 5 -type maximal_pleasure_at_pn\n\n# Medium n tests\n./gen -n 1000 -type random\n./gen -n 1000 -type all_zero\n./gen -n 1000 -type all_same -value 999999999999\n./gen -n 1000 -type alternating -x 123456789012 -y 987654321098\n\n./gen -n 1000 -type max_zero_pleasure\n./gen -n 1000 -type maximal_pleasure_at_p0\n./gen -n 1000 -type maximal_pleasure_at_pn\n\n# Large n tests\n./gen -n 100000 -type random\n./gen -n 100000 -type all_zero\n./gen -n 100000 -type all_same -value 1000000000000\n./gen -n 100000 -type alternating -x 999999999999 -y 888888888888\n\n./gen -n 100000 -type max_zero_pleasure\n./gen -n 100000 -type maximal_pleasure_at_p0\n./gen -n 100000 -type maximal_pleasure_at_pn\n\n# Edge value tests\n./gen -n 100000 -type random -maxa 0\n./gen -n 100000 -type random -maxa 1\n./gen -n 100000 -type random -maxa 1000000000000\n\n./gen -n 10 -type random -maxa 1000000000000\n./gen -n 10 -type random -maxa 1\n\n# Additional tests\n./gen -n 99999 -type random\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:50.759892",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "283/A",
      "title": "Problem 283/A",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    int seq_size = 1;\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 3, \"ti\");\n        if (ti == 1) {\n            inf.readSpace();\n            int ai = inf.readInt(1, seq_size, \"ai\");\n            inf.readSpace();\n            int xi = inf.readInt(-1000, 1000, \"xi\");\n            inf.readEoln();\n        } else if (ti == 2) {\n            inf.readSpace();\n            int ki = inf.readInt(-1000, 1000, \"ki\");\n            seq_size +=1;\n            inf.readEoln();\n        } else if (ti == 3) {\n            inf.readEoln();\n            ensuref(seq_size >=2, \"Operation 3 cannot be performed when sequence size is less than 2 at operation %d\", i +1);\n            seq_size -=1;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    int seq_size = 1;\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 3, \"ti\");\n        if (ti == 1) {\n            inf.readSpace();\n            int ai = inf.readInt(1, seq_size, \"ai\");\n            inf.readSpace();\n            int xi = inf.readInt(-1000, 1000, \"xi\");\n            inf.readEoln();\n        } else if (ti == 2) {\n            inf.readSpace();\n            int ki = inf.readInt(-1000, 1000, \"ki\");\n            seq_size +=1;\n            inf.readEoln();\n        } else if (ti == 3) {\n            inf.readEoln();\n            ensuref(seq_size >=2, \"Operation 3 cannot be performed when sequence size is less than 2 at operation %d\", i +1);\n            seq_size -=1;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    int seq_size = 1;\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 3, \"ti\");\n        if (ti == 1) {\n            inf.readSpace();\n            int ai = inf.readInt(1, seq_size, \"ai\");\n            inf.readSpace();\n            int xi = inf.readInt(-1000, 1000, \"xi\");\n            inf.readEoln();\n        } else if (ti == 2) {\n            inf.readSpace();\n            int ki = inf.readInt(-1000, 1000, \"ki\");\n            seq_size +=1;\n            inf.readEoln();\n        } else if (ti == 3) {\n            inf.readEoln();\n            ensuref(seq_size >=2, \"Operation 3 cannot be performed when sequence size is less than 2 at operation %d\", i +1);\n            seq_size -=1;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_ABS_VALUE = 1000;\nconst int MAX_N = 200000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> ops_t;\n    vector<int> ops_a;\n    vector<int> ops_xi;\n    vector<int> ops_ki;\n\n    int seq_size = 1; // initial sequence has one element\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            vector<int> possible_ops;\n            possible_ops.push_back(1);\n            possible_ops.push_back(2);\n            if (seq_size >=2) {\n                possible_ops.push_back(3);\n            }\n            int t = possible_ops[rnd.next(possible_ops.size())];\n            ops_t.push_back(t);\n\n            if(t == 1) {\n                int ai = rnd.next(1, seq_size);\n                int xi = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                ops_a.push_back(ai);\n                ops_xi.push_back(xi);\n                ops_ki.push_back(0);\n            } else if(t == 2) {\n                int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                ops_ki.push_back(ki);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size++;\n            } else if(t == 3) {\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                ops_ki.push_back(0);\n                seq_size--;\n            }\n        }\n    } else if (type == \"max_sequence_size\") {\n        for(int i = 0; i < n; ++i) {\n            ops_t.push_back(2);\n            int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n            ops_ki.push_back(ki);\n            ops_a.push_back(0);\n            ops_xi.push_back(0);\n            seq_size++;\n        }\n    } else if (type == \"min_sequence_size\") {\n        // First, if n >=1, we need to ensure seq_size >=2 to perform removal\n        if (n == 0) {\n            // Do nothing\n        } else if (n == 1) {\n            // Only operation can be append\n            ops_t.push_back(2);\n            int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n            ops_ki.push_back(ki);\n            ops_a.push_back(0);\n            ops_xi.push_back(0);\n            seq_size++;\n        } else {\n            // Append once to have at least two elements\n            ops_t.push_back(2);\n            int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n            ops_ki.push_back(ki);\n            ops_a.push_back(0);\n            ops_xi.push_back(0);\n            seq_size++;\n            // Now we can proceed with remove operations\n            for(int i = 1; i < n; ++i) {\n                if(seq_size >= 2) {\n                    ops_t.push_back(3);\n                    ops_ki.push_back(0);\n                    ops_a.push_back(0);\n                    ops_xi.push_back(0);\n                    seq_size--;\n                } else {\n                    // Cannot remove, append to increase size\n                    ops_t.push_back(2);\n                    int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                    ops_ki.push_back(ki);\n                    ops_a.push_back(0);\n                    ops_xi.push_back(0);\n                    seq_size++;\n                }\n            }\n        }\n    } else if (type == \"alternating_ops\") {\n        for (int i = 0; i < n; ++i) {\n            int t = (i % 3) + 1;\n            if (t ==3 && seq_size < 2) {\n                // Cannot remove, so change to type 2\n                t = 2;\n            }\n            ops_t.push_back(t);\n            if (t == 1) {\n                int ai = rnd.next(1, seq_size);\n                int xi = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                ops_a.push_back(ai);\n                ops_xi.push_back(xi);\n                ops_ki.push_back(0);\n            } else if (t ==2) {\n                int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                ops_ki.push_back(ki);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size++;\n            } else if (t == 3) {\n                ops_ki.push_back(0);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size--;\n            }\n        }\n    } else if (type == \"extreme_values\") {\n        for (int i = 0; i < n; ++i) {\n            vector<int> possible_ops;\n            possible_ops.push_back(1);\n            possible_ops.push_back(2);\n            if (seq_size >= 2) {\n                possible_ops.push_back(3);\n            }\n            int t = possible_ops[rnd.next(possible_ops.size())];\n            ops_t.push_back(t);\n            if (t ==1) {\n                int ai = seq_size; // max possible ai\n                int xi = (rnd.next(2) ? MAX_ABS_VALUE : -MAX_ABS_VALUE);\n                ops_a.push_back(ai);\n                ops_xi.push_back(xi);\n                ops_ki.push_back(0);\n            } else if (t ==2) {\n                int ki = (rnd.next(2) ? MAX_ABS_VALUE : -MAX_ABS_VALUE);\n                ops_ki.push_back(ki);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size++;\n            } else if (t ==3) {\n                ops_ki.push_back(0);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size--;\n            }\n        }\n    } else {\n        // Handle unexpected type\n        for(int i = 0; i < n; ++i) {\n            ops_t.push_back(1);\n            ops_a.push_back(1);\n            ops_xi.push_back(0);\n            ops_ki.push_back(0);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", ops_t[i]);\n        if(ops_t[i] == 1) {\n            printf(\" %d %d\", ops_a[i], ops_xi[i]);\n        }\n        else if(ops_t[i] == 2) {\n            printf(\" %d\", ops_ki[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_ABS_VALUE = 1000;\nconst int MAX_N = 200000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> ops_t;\n    vector<int> ops_a;\n    vector<int> ops_xi;\n    vector<int> ops_ki;\n\n    int seq_size = 1; // initial sequence has one element\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            vector<int> possible_ops;\n            possible_ops.push_back(1);\n            possible_ops.push_back(2);\n            if (seq_size >=2) {\n                possible_ops.push_back(3);\n            }\n            int t = possible_ops[rnd.next(possible_ops.size())];\n            ops_t.push_back(t);\n\n            if(t == 1) {\n                int ai = rnd.next(1, seq_size);\n                int xi = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                ops_a.push_back(ai);\n                ops_xi.push_back(xi);\n                ops_ki.push_back(0);\n            } else if(t == 2) {\n                int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                ops_ki.push_back(ki);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size++;\n            } else if(t == 3) {\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                ops_ki.push_back(0);\n                seq_size--;\n            }\n        }\n    } else if (type == \"max_sequence_size\") {\n        for(int i = 0; i < n; ++i) {\n            ops_t.push_back(2);\n            int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n            ops_ki.push_back(ki);\n            ops_a.push_back(0);\n            ops_xi.push_back(0);\n            seq_size++;\n        }\n    } else if (type == \"min_sequence_size\") {\n        // First, if n >=1, we need to ensure seq_size >=2 to perform removal\n        if (n == 0) {\n            // Do nothing\n        } else if (n == 1) {\n            // Only operation can be append\n            ops_t.push_back(2);\n            int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n            ops_ki.push_back(ki);\n            ops_a.push_back(0);\n            ops_xi.push_back(0);\n            seq_size++;\n        } else {\n            // Append once to have at least two elements\n            ops_t.push_back(2);\n            int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n            ops_ki.push_back(ki);\n            ops_a.push_back(0);\n            ops_xi.push_back(0);\n            seq_size++;\n            // Now we can proceed with remove operations\n            for(int i = 1; i < n; ++i) {\n                if(seq_size >= 2) {\n                    ops_t.push_back(3);\n                    ops_ki.push_back(0);\n                    ops_a.push_back(0);\n                    ops_xi.push_back(0);\n                    seq_size--;\n                } else {\n                    // Cannot remove, append to increase size\n                    ops_t.push_back(2);\n                    int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                    ops_ki.push_back(ki);\n                    ops_a.push_back(0);\n                    ops_xi.push_back(0);\n                    seq_size++;\n                }\n            }\n        }\n    } else if (type == \"alternating_ops\") {\n        for (int i = 0; i < n; ++i) {\n            int t = (i % 3) + 1;\n            if (t ==3 && seq_size < 2) {\n                // Cannot remove, so change to type 2\n                t = 2;\n            }\n            ops_t.push_back(t);\n            if (t == 1) {\n                int ai = rnd.next(1, seq_size);\n                int xi = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                ops_a.push_back(ai);\n                ops_xi.push_back(xi);\n                ops_ki.push_back(0);\n            } else if (t ==2) {\n                int ki = rnd.next(-MAX_ABS_VALUE, MAX_ABS_VALUE);\n                ops_ki.push_back(ki);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size++;\n            } else if (t == 3) {\n                ops_ki.push_back(0);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size--;\n            }\n        }\n    } else if (type == \"extreme_values\") {\n        for (int i = 0; i < n; ++i) {\n            vector<int> possible_ops;\n            possible_ops.push_back(1);\n            possible_ops.push_back(2);\n            if (seq_size >= 2) {\n                possible_ops.push_back(3);\n            }\n            int t = possible_ops[rnd.next(possible_ops.size())];\n            ops_t.push_back(t);\n            if (t ==1) {\n                int ai = seq_size; // max possible ai\n                int xi = (rnd.next(2) ? MAX_ABS_VALUE : -MAX_ABS_VALUE);\n                ops_a.push_back(ai);\n                ops_xi.push_back(xi);\n                ops_ki.push_back(0);\n            } else if (t ==2) {\n                int ki = (rnd.next(2) ? MAX_ABS_VALUE : -MAX_ABS_VALUE);\n                ops_ki.push_back(ki);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size++;\n            } else if (t ==3) {\n                ops_ki.push_back(0);\n                ops_a.push_back(0);\n                ops_xi.push_back(0);\n                seq_size--;\n            }\n        }\n    } else {\n        // Handle unexpected type\n        for(int i = 0; i < n; ++i) {\n            ops_t.push_back(1);\n            ops_a.push_back(1);\n            ops_xi.push_back(0);\n            ops_ki.push_back(0);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", ops_t[i]);\n        if(ops_t[i] == 1) {\n            printf(\" %d %d\", ops_a[i], ops_xi[i]);\n        }\n        else if(ops_t[i] == 2) {\n            printf(\" %d\", ops_ki[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 200000 -type random\n\n./gen -n 5 -type max_sequence_size\n./gen -n 10 -type max_sequence_size\n./gen -n 100 -type max_sequence_size\n./gen -n 1000 -type max_sequence_size\n./gen -n 10000 -type max_sequence_size\n./gen -n 100000 -type max_sequence_size\n./gen -n 200000 -type max_sequence_size\n\n./gen -n 5 -type min_sequence_size\n./gen -n 10 -type min_sequence_size\n./gen -n 100 -type min_sequence_size\n./gen -n 1000 -type min_sequence_size\n./gen -n 10000 -type min_sequence_size\n./gen -n 100000 -type min_sequence_size\n\n./gen -n 5 -type alternating_ops\n./gen -n 10 -type alternating_ops\n./gen -n 100 -type alternating_ops\n./gen -n 1000 -type alternating_ops\n./gen -n 10000 -type alternating_ops\n\n./gen -n 5 -type extreme_values\n./gen -n 10 -type extreme_values\n./gen -n 100 -type extreme_values\n./gen -n 1000 -type extreme_values\n./gen -n 10000 -type extreme_values\n./gen -n 200000 -type extreme_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:52.944740",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "283/B",
      "title": "B. Коровки программируют",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит единственное целое число, n (2 ≤ n ≤ 2·105). Следующая строка содержит n - 1 целых чисел через пробел, a2, a3, ..., an (1 ≤ ai ≤ 109).",
      "output_spec": "Выходные данныеВыведите n - 1 строк. В i-ой строке выведите требуемое значение, когда программа запускается на последовательности i, a2, a3, ...an.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать42 4 1Выходные данныеСкопировать368Входные данныеСкопировать31 2Выходные данныеСкопировать-1-1",
      "description": "B. Коровки программируют\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит единственное целое число, n (2 ≤ n ≤ 2·105). Следующая строка содержит n - 1 целых чисел через пробел, a2, a3, ..., an (1 ≤ ai ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите n - 1 строк. В i-ой строке выведите требуемое значение, когда программа запускается на последовательности i, a2, a3, ...an.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать42 4 1Выходные данныеСкопировать368Входные данныеСкопировать31 2Выходные данныеСкопировать-1-1\n\nВходные данныеСкопировать42 4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать368\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере   Для i = 1,  x изменяется следующим образом: , y становится 1 + 2 = 3.  Для i = 2,  x изменяется следующим образом: , y становится 2 + 4 = 6.  Для i = 3,  x изменяется следующим образом: , y становится 3 + 1 + 4 = 8.",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Всем привет! Соревнование Codeforces Round 174 будет проводиться в обоих дивизионах в воскресенье, 17-го Марта в 19:30 MSK. Задачи готовили abacadaea и я (scott_wu). Традиционно мы благодарим Gerald за помощь в подготовке соревнования и Delinur за перевод задач. Большое спасибо MikeMirzayanov за создание такого отличного сайта. Мы очень взволнованы, ведь это наш первый Codeforces раунд.В этом раунде Вы будете помогать Фермеру Джону, Бесси, и коровкам. Мы надеемся, Вам понравятся задачи! :)Распределение баллов по задачам будет немного нестандартное:Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Удачи Вам и приятного кодинга! Как обычно, чтобы сделать раунд более захватывающим, мы советуем прочитать Вам условия всех задач!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 760
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 14",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 15",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 10",
          "code": "---------------------------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n - 1);\n\n    if (type == \"random\") {\n        /* Generate random values between 1 and 1e9 */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"min\") {\n        /* All values are 1 */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max\") {\n        /* All values are 1e9 */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"ones\") {\n        /* All values are 1 */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"loop\") {\n        /* Generate a sequence designed to cause infinite loops */\n        if (n >= 3) {\n            /* Set up a cycle between positions 1 and 2 */\n            a[0] = 1; // a[1] corresponds to a2 in problem statement\n            a[1] = 1;\n            for (int i = 2; i < n - 1; ++i)\n                a[i] = rnd.next(1, 1000000000);\n        } else {\n            /* For small n, default to ones */\n            for (int i = 0; i < n - 1; ++i)\n                a[i] = 1;\n        }\n    } else if (type == \"terminate\") {\n        /* Generate sequences where x moves out of bounds quickly */\n        a[0] = n; // a[1], when x = 1, x + a[x] > n\n        for (int i = 1; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output a2 to an */\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 2) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n - 1);\n\n    if (type == \"random\") {\n        /* Generate random values between 1 and 1e9 */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"min\") {\n        /* All values are 1 */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max\") {\n        /* All values are 1e9 */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"ones\") {\n        /* All values are 1 */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"loop\") {\n        /* Generate a sequence designed to cause infinite loops */\n        if (n >= 3) {\n            /* Set up a cycle between positions 1 and 2 */\n            a[0] = 1; // a[1] corresponds to a2 in problem statement\n            a[1] = 1;\n            for (int i = 2; i < n - 1; ++i)\n                a[i] = rnd.next(1, 1000000000);\n        } else {\n            /* For small n, default to ones */\n            for (int i = 0; i < n - 1; ++i)\n                a[i] = 1;\n        }\n    } else if (type == \"terminate\") {\n        /* Generate sequences where x moves out of bounds quickly */\n        a[0] = n; // a[1], when x = 1, x + a[x] > n\n        for (int i = 1; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output a2 to an */\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 2) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type min\n./gen -n 2 -type max\n./gen -n 2 -type ones\n./gen -n 2 -type loop\n./gen -n 2 -type terminate\n\n./gen -n 10 -type random\n./gen -n 10 -type min\n./gen -n 10 -type max\n./gen -n 10 -type ones\n./gen -n 10 -type loop\n./gen -n 10 -type terminate\n\n./gen -n 1000 -type random\n./gen -n 1000 -type min\n./gen -n 1000 -type max\n./gen -n 1000 -type ones\n./gen -n 1000 -type loop\n./gen -n 1000 -type terminate\n\n./gen -n 10000 -type random\n./gen -n 10000 -type min\n./gen -n 10000 -type max\n./gen -n 10000 -type ones\n./gen -n 10000 -type loop\n./gen -n 10000 -type terminate\n\n./gen -n 200000 -type random\n./gen -n 200000 -type min\n./gen -n 200000 -type max\n./gen -n 200000 -type ones\n./gen -n 200000 -type loop\n./gen -n 200000 -type terminate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:55.006105",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "283/C",
      "title": "C. Coin Troubles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers, n, q and t (1 ≤ n ≤ 300; 0 ≤ q ≤ n; 1 ≤ t ≤ 105). The second line contains n space separated integers, a1, a2, ..., an (1 ≤ ai ≤ 105). The next q lines each contain two distinct space-separated integers, bi and ci (1 ≤ bi, ci ≤ n; bi ≠ ci).It's guaranteed that all bi are distinct and all ci are distinct.",
      "output_spec": "OutputA single integer, the number of valid coin combinations that Bessie could have, modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy4 2 173 1 2 54 23 4OutputCopy3InputCopy3 2 63 1 11 22 3OutputCopy0InputCopy3 2 101 2 31 22 1OutputCopy0",
      "description": "C. Coin Troubles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers, n, q and t (1 ≤ n ≤ 300; 0 ≤ q ≤ n; 1 ≤ t ≤ 105). The second line contains n space separated integers, a1, a2, ..., an (1 ≤ ai ≤ 105). The next q lines each contain two distinct space-separated integers, bi and ci (1 ≤ bi, ci ≤ n; bi ≠ ci).It's guaranteed that all bi are distinct and all ci are distinct.\n\nOutputA single integer, the number of valid coin combinations that Bessie could have, modulo 1000000007 (109 + 7).\n\nInputCopy4 2 173 1 2 54 23 4OutputCopy3InputCopy3 2 63 1 11 22 3OutputCopy0InputCopy3 2 101 2 31 22 1OutputCopy0\n\nInputCopy4 2 173 1 2 54 23 4\n\nOutputCopy3\n\nInputCopy3 2 63 1 11 22 3\n\nOutputCopy0\n\nInputCopy3 2 101 2 31 22 1\n\nOutputCopy0\n\nNoteFor the first sample, the following 3 combinations give a total of 17 cents and satisfy the given conditions: {0 of type 1, 1 of type 2, 3 of type 3, 2 of type 4}, {0, 0, 6, 1}, {2, 0, 3, 1}.No other combinations exist. Note that even though 4 occurs in both bi and ci,  the problem conditions are still satisfied because all bi are distinct and all ci are distinct.",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Hello everyone! Codeforces Round 174 will be held for both divisions on Sunday, March 17th at 7:30 PM MSK. The problem setters are abacadaea and me (scott_wu). We would like to thank Gerald for his help in preparing the contest and Delinur for translating the problems. We also thank MikeMirzayanov for creating such an awesome site. We are very excited as this is our first Codeforces round.For this contest you’ll be helping Farmer John, Bessie, and the cows. We hope you enjoy the problems! :)The score distribution will be slightly nonstandard.Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Good luck and happy coding! As always, to make the round more exciting, we recommend that you take a look at all the problems!UPD: Our editorial can be found here. Thanks for participating!Congratulations to the winners:Div1 al13n rng_58 HELEN_KK wjmsbmr bmerry Div2 hockey_for_NOI Efremov_licesos Muali koratel lxfind",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 943
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, n, \"q\");\n    inf.readSpace();\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    set<int> bi_set, ci_set;\n    for (int i = 0; i < q; i++) {\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(bi != ci, \"bi and ci must be distinct at line %d\", i + 3);\n\n        ensuref(bi_set.insert(bi).second, \"bi %d occurs more than once\", bi);\n\n        ensuref(ci_set.insert(ci).second, \"ci %d occurs more than once\", ci);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, n, \"q\");\n    inf.readSpace();\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    set<int> bi_set, ci_set;\n    for (int i = 0; i < q; i++) {\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(bi != ci, \"bi and ci must be distinct at line %d\", i + 3);\n\n        ensuref(bi_set.insert(bi).second, \"bi %d occurs more than once\", bi);\n\n        ensuref(ci_set.insert(ci).second, \"ci %d occurs more than once\", ci);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, n, \"q\");\n    inf.readSpace();\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    set<int> bi_set, ci_set;\n    for (int i = 0; i < q; i++) {\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(bi != ci, \"bi and ci must be distinct at line %d\", i + 3);\n\n        ensuref(bi_set.insert(bi).second, \"bi %d occurs more than once\", bi);\n\n        ensuref(ci_set.insert(ci).second, \"ci %d occurs more than once\", ci);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int t = opt<int>(\"t\");\n\n    string type_ai = opt<string>(\"type_ai\", \"random\");\n    string type_constraints = opt<string>(\"type_constraints\", \"random\");\n\n    // Ensure q is not more than n\n    q = min(q, n);\n\n    // Generate ai according to type_ai\n    vector<int> ai(n);\n    if (type_ai == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100000);\n        }\n    } else if (type_ai == \"all_same\") {\n        int value = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = value;\n        }\n    } else if (type_ai == \"duplicates\") {\n        int m = rnd.next(1, n);\n        vector<int> values(m);\n        for (int i = 0; i < m; ++i) {\n            values[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < n; ++i) {\n            ai[i] = values[rnd.next(0, m - 1)];\n        }\n    } else if (type_ai == \"increasing\") {\n        ai[0] = rnd.next(1, 100000 - n + 1);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = ai[i - 1] + rnd.next(1, 1000);\n            if (ai[i] > 100000) ai[i] = 100000;\n        }\n    } else if (type_ai == \"decreasing\") {\n        ai[0] = rnd.next(n, 100000);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = ai[i - 1] - rnd.next(1, 1000);\n            if (ai[i] < 1) ai[i] = 1;\n        }\n    }\n\n    // Generate inequality constraints according to type_constraints\n    vector<int> bi(q), ci(q);\n    set<int> used_bi, used_ci;\n\n    if (type_constraints == \"random\" || type_constraints == \"none\") {\n        for (int i = 0; i < q; ++i) {\n            int b, c;\n            do {\n                b = rnd.next(1, n);\n            } while (used_bi.count(b));\n            used_bi.insert(b);\n\n            do {\n                c = rnd.next(1, n);\n            } while (used_ci.count(c) || c == b);\n            used_ci.insert(c);\n\n            bi[i] = b;\n            ci[i] = c;\n        }\n    } else if (type_constraints == \"chain\") {\n        q = min(q, n - 1);\n        bi.resize(q);\n        ci.resize(q);\n        for (int i = 0; i < q; ++i) {\n            bi[i] = i + 1;\n            ci[i] = i + 2;\n            used_bi.insert(bi[i]);\n            used_ci.insert(ci[i]);\n        }\n    } else if (type_constraints == \"cycle\") {\n        q = min(q, n);\n        bi.resize(q);\n        ci.resize(q);\n        for (int i = 0; i < q - 1; ++i) {\n            bi[i] = i + 1;\n            ci[i] = i + 2;\n            used_bi.insert(bi[i]);\n            used_ci.insert(ci[i]);\n        }\n        bi[q - 1] = n;\n        ci[q - 1] = 1;\n        used_bi.insert(bi[q - 1]);\n        used_ci.insert(ci[q - 1]);\n    } else if (type_constraints == \"contradict\") {\n        if (n >= 2) {\n            q = 2;\n            bi.resize(q);\n            ci.resize(q);\n\n            bi[0] = 1;\n            ci[0] = 2;\n            bi[1] = 2;\n            ci[1] = 1;\n\n            used_bi.insert(bi[0]);\n            used_bi.insert(bi[1]);\n            used_ci.insert(ci[0]);\n            used_ci.insert(ci[1]);\n        } else {\n            q = 0;\n            bi.clear();\n            ci.clear();\n        }\n    }\n\n    // Output n, q, t\n    printf(\"%d %d %d\\n\", n, q, t);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], \" \\n\"[i == n - 1]);\n    }\n\n    // Output inequalities\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", bi[i], ci[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int t = opt<int>(\"t\");\n\n    string type_ai = opt<string>(\"type_ai\", \"random\");\n    string type_constraints = opt<string>(\"type_constraints\", \"random\");\n\n    // Ensure q is not more than n\n    q = min(q, n);\n\n    // Generate ai according to type_ai\n    vector<int> ai(n);\n    if (type_ai == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100000);\n        }\n    } else if (type_ai == \"all_same\") {\n        int value = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = value;\n        }\n    } else if (type_ai == \"duplicates\") {\n        int m = rnd.next(1, n);\n        vector<int> values(m);\n        for (int i = 0; i < m; ++i) {\n            values[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < n; ++i) {\n            ai[i] = values[rnd.next(0, m - 1)];\n        }\n    } else if (type_ai == \"increasing\") {\n        ai[0] = rnd.next(1, 100000 - n + 1);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = ai[i - 1] + rnd.next(1, 1000);\n            if (ai[i] > 100000) ai[i] = 100000;\n        }\n    } else if (type_ai == \"decreasing\") {\n        ai[0] = rnd.next(n, 100000);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = ai[i - 1] - rnd.next(1, 1000);\n            if (ai[i] < 1) ai[i] = 1;\n        }\n    }\n\n    // Generate inequality constraints according to type_constraints\n    vector<int> bi(q), ci(q);\n    set<int> used_bi, used_ci;\n\n    if (type_constraints == \"random\" || type_constraints == \"none\") {\n        for (int i = 0; i < q; ++i) {\n            int b, c;\n            do {\n                b = rnd.next(1, n);\n            } while (used_bi.count(b));\n            used_bi.insert(b);\n\n            do {\n                c = rnd.next(1, n);\n            } while (used_ci.count(c) || c == b);\n            used_ci.insert(c);\n\n            bi[i] = b;\n            ci[i] = c;\n        }\n    } else if (type_constraints == \"chain\") {\n        q = min(q, n - 1);\n        bi.resize(q);\n        ci.resize(q);\n        for (int i = 0; i < q; ++i) {\n            bi[i] = i + 1;\n            ci[i] = i + 2;\n            used_bi.insert(bi[i]);\n            used_ci.insert(ci[i]);\n        }\n    } else if (type_constraints == \"cycle\") {\n        q = min(q, n);\n        bi.resize(q);\n        ci.resize(q);\n        for (int i = 0; i < q - 1; ++i) {\n            bi[i] = i + 1;\n            ci[i] = i + 2;\n            used_bi.insert(bi[i]);\n            used_ci.insert(ci[i]);\n        }\n        bi[q - 1] = n;\n        ci[q - 1] = 1;\n        used_bi.insert(bi[q - 1]);\n        used_ci.insert(ci[q - 1]);\n    } else if (type_constraints == \"contradict\") {\n        if (n >= 2) {\n            q = 2;\n            bi.resize(q);\n            ci.resize(q);\n\n            bi[0] = 1;\n            ci[0] = 2;\n            bi[1] = 2;\n            ci[1] = 1;\n\n            used_bi.insert(bi[0]);\n            used_bi.insert(bi[1]);\n            used_ci.insert(ci[0]);\n            used_ci.insert(ci[1]);\n        } else {\n            q = 0;\n            bi.clear();\n            ci.clear();\n        }\n    }\n\n    // Output n, q, t\n    printf(\"%d %d %d\\n\", n, q, t);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], \" \\n\"[i == n - 1]);\n    }\n\n    // Output inequalities\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", bi[i], ci[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 0 -t 1 -type_ai random -type_constraints none\n./gen -n 1 -q 0 -t 100000 -type_ai random -type_constraints none\n./gen -n 2 -q 1 -t 2 -type_ai all_same -type_constraints chain\n./gen -n 5 -q 3 -t 10 -type_ai duplicates -type_constraints random\n./gen -n 5 -q 5 -t 10 -type_ai duplicates -type_constraints chain\n./gen -n 5 -q 5 -t 10 -type_ai duplicates -type_constraints cycle\n./gen -n 3 -q 2 -t 6 -type_ai duplicates -type_constraints contradict\n./gen -n 10 -q 0 -t 100000 -type_ai increasing -type_constraints none\n./gen -n 10 -q 0 -t 1 -type_ai decreasing -type_constraints none\n./gen -n 50 -q 25 -t 50000 -type_ai random -type_constraints random\n./gen -n 100 -q 50 -t 80000 -type_ai random -type_constraints random\n./gen -n 200 -q 100 -t 100000 -type_ai duplicates -type_constraints random\n./gen -n 300 -q 0 -t 50000 -type_ai random -type_constraints none\n./gen -n 300 -q 299 -t 100000 -type_ai random -type_constraints chain\n./gen -n 300 -q 300 -t 100000 -type_ai increasing -type_constraints cycle\n./gen -n 300 -q 2 -t 50000 -type_ai random -type_constraints contradict\n./gen -n 300 -q 300 -t 100000 -type_ai duplicates -type_constraints random\n./gen -n 300 -q 300 -t 100000 -type_ai all_same -type_constraints random\n./gen -n 300 -q 150 -t 99999 -type_ai duplicates -type_constraints random\n./gen -n 300 -q 150 -t 1 -type_ai random -type_constraints random\n./gen -n 300 -q 150 -t 100000 -type_ai decreasing -type_constraints random\n./gen -n 300 -q 150 -t 100000 -type_ai increasing -type_constraints random\n./gen -n 2 -q 2 -t 2 -type_ai random -type_constraints contradict\n./gen -n 10 -q 9 -t 10 -type_ai random -type_constraints chain\n./gen -n 10 -q 10 -t 10 -type_ai random -type_constraints cycle\n./gen -n 3 -q 2 -t 6 -type_ai random -type_constraints contradict\n./gen -n 300 -q 0 -t 1 -type_ai random -type_constraints none\n./gen -n 300 -q 300 -t 100000 -type_ai duplicates -type_constraints random\n./gen -n 299 -q 299 -t 100000 -type_ai decreasing -type_constraints chain\n./gen -n 1 -q 0 -t 1 -type_ai random -type_constraints none\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:56.725051",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "283/D",
      "title": "D. Коровки и классные последовательности",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 5000). В следующей строке записаны через пробел n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 1015).Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите единственное целое число, минимальное количество ai, которое надо поменять, чтобы последовательность стала классной.",
      "sample_tests": "ПримерыВходные данныеСкопировать36 4 1Выходные данныеСкопировать0Входные данныеСкопировать420 6 3 4Выходные данныеСкопировать2",
      "description": "D. Коровки и классные последовательности\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 5000). В следующей строке записаны через пробел n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 1015).Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число, минимальное количество ai, которое надо поменять, чтобы последовательность стала классной.\n\nВыходные данные\n\nВходные данныеСкопировать36 4 1Выходные данныеСкопировать0Входные данныеСкопировать420 6 3 4Выходные данныеСкопировать2\n\nВходные данныеСкопировать36 4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать420 6 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере последовательность уже «классная», так что никаких элементов менять не надо.Во втором примере можно изменить a2 на 5, а a3 — на 10, чтобы получить (20, 5, 10, 4), являющуюся «классной». Итого, меняются 2 элемента.",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Всем привет! Соревнование Codeforces Round 174 будет проводиться в обоих дивизионах в воскресенье, 17-го Марта в 19:30 MSK. Задачи готовили abacadaea и я (scott_wu). Традиционно мы благодарим Gerald за помощь в подготовке соревнования и Delinur за перевод задач. Большое спасибо MikeMirzayanov за создание такого отличного сайта. Мы очень взволнованы, ведь это наш первый Codeforces раунд.В этом раунде Вы будете помогать Фермеру Джону, Бесси, и коровкам. Мы надеемся, Вам понравятся задачи! :)Распределение баллов по задачам будет немного нестандартное:Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Удачи Вам и приятного кодинга! Как обычно, чтобы сделать раунд более захватывающим, мы советуем прочитать Вам условия всех задач!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 760
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 14",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 15",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 10",
          "code": "---------------------------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 1, 1000000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 1, 1000000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 1, 1000000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if(type == \"random\") {\n        // Random values in [1, 1e15]\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000000000LL);\n        }\n    }\n    else if(type == \"max_values\") {\n        // Values close to 1e15\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000000000000LL - 1000000000LL, 1000000000000000LL);\n        }\n    }\n    else if(type == \"min_values\") {\n        // Values close to 1\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000LL);\n        }\n    }\n    else if(type == \"already_cool\") {\n        // Generate sequence where consecutive pairs are cool\n        a[n-1] = rnd.next(1LL, 1000000LL); // Set an to some small number\n        for(int i = n - 2; i >= 0; --i) {\n            long long y = a[i+1]; // ai+1\n            // Ensure that ai does not exceed 1e15\n            long long max_s0 = (1000000000000000LL - y*(y-1)/2) / y;\n            if (max_s0 <= 0) max_s0 = 1;\n            long long s0 = rnd.next(1LL, min(max_s0, 1000000000LL));\n            long long s = s0 * y;\n            a[i] = s + y*(y-1)/2;\n            if(a[i] > 1000000000000000LL) a[i] = 1000000000000000LL;\n        }\n    }\n    else if(type == \"not_cool\") {\n        // Generate sequence where consecutive pairs are NOT cool\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000000000LL);\n        }\n        // Adjust a[i] so that (a[i], a[i+1]) is not cool\n        for(int i = 0; i + 1 < n; ++i) {\n            long long x = a[i];\n            long long y = a[i+1];\n            long long s = x - y*(y -1)/2;\n            if(s % y == 0) {\n                if(x + 1 <= 1000000000000000LL) a[i]++;\n                else if(x -1 >= 1LL) a[i]--;\n                else a[i] = x + rnd.next(1LL, 1000LL);\n            }\n        }\n    }\n    else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000000000LL);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%lld\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if(type == \"random\") {\n        // Random values in [1, 1e15]\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000000000LL);\n        }\n    }\n    else if(type == \"max_values\") {\n        // Values close to 1e15\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000000000000LL - 1000000000LL, 1000000000000000LL);\n        }\n    }\n    else if(type == \"min_values\") {\n        // Values close to 1\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000LL);\n        }\n    }\n    else if(type == \"already_cool\") {\n        // Generate sequence where consecutive pairs are cool\n        a[n-1] = rnd.next(1LL, 1000000LL); // Set an to some small number\n        for(int i = n - 2; i >= 0; --i) {\n            long long y = a[i+1]; // ai+1\n            // Ensure that ai does not exceed 1e15\n            long long max_s0 = (1000000000000000LL - y*(y-1)/2) / y;\n            if (max_s0 <= 0) max_s0 = 1;\n            long long s0 = rnd.next(1LL, min(max_s0, 1000000000LL));\n            long long s = s0 * y;\n            a[i] = s + y*(y-1)/2;\n            if(a[i] > 1000000000000000LL) a[i] = 1000000000000000LL;\n        }\n    }\n    else if(type == \"not_cool\") {\n        // Generate sequence where consecutive pairs are NOT cool\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000000000LL);\n        }\n        // Adjust a[i] so that (a[i], a[i+1]) is not cool\n        for(int i = 0; i + 1 < n; ++i) {\n            long long x = a[i];\n            long long y = a[i+1];\n            long long s = x - y*(y -1)/2;\n            if(s % y == 0) {\n                if(x + 1 <= 1000000000000000LL) a[i]++;\n                else if(x -1 >= 1LL) a[i]--;\n                else a[i] = x + rnd.next(1LL, 1000LL);\n            }\n        }\n    }\n    else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000000000LL);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%lld\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type already_cool\n./gen -n 2 -type not_cool\n./gen -n 2 -type random\n./gen -n 2 -type min_values\n./gen -n 2 -type max_values\n\n./gen -n 100 -type already_cool\n./gen -n 100 -type not_cool\n./gen -n 100 -type random\n./gen -n 100 -type min_values\n./gen -n 100 -type max_values\n\n./gen -n 1000 -type already_cool\n./gen -n 1000 -type not_cool\n./gen -n 1000 -type random\n./gen -n 1000 -type min_values\n./gen -n 1000 -type max_values\n\n./gen -n 5000 -type already_cool\n./gen -n 5000 -type not_cool\n./gen -n 5000 -type random\n./gen -n 5000 -type min_values\n./gen -n 5000 -type max_values\n\n# Additional varied test cases\n./gen -n 4999 -type already_cool\n./gen -n 4998 -type not_cool\n./gen -n 4000 -type min_values\n./gen -n 4500 -type max_values\n\n./gen -n 2500 -type random\n./gen -n 2500 -type min_values\n./gen -n 2500 -type max_values\n\n./gen -n 500 -type already_cool\n./gen -n 500 -type not_cool\n./gen -n 500 -type random\n\n./gen -n 10 -type min_values\n./gen -n 15 -type max_values\n./gen -n 20 -type random\n\n# Repeat some random types for variety\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:01:58.753083",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "283/E",
      "title": "E. Cow Tennis Tournament",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputOn the first line are two space-separated integers, n and k (3 ≤ n ≤ 105; 0 ≤ k ≤ 105). On the next line are n space-separated distinct integers, s1, s2, ..., sn (1 ≤ si ≤ 109), denoting the skill levels of the cows. On the next k lines are two space separated integers, ai and bi (1 ≤ ai < bi ≤ 109) representing the changes Farmer John made to the scoreboard in the order he makes it.",
      "output_spec": "OutputA single integer, containing the number of triples of cows (p, q, r) for which the final leaderboard shows that cow p beats cow q, cow q beats cow r, and cow r beats cow p.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy3 21 2 31 22 3OutputCopy1InputCopy5 35 9 4 1 71 72 83 9OutputCopy3",
      "description": "E. Cow Tennis Tournament\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputOn the first line are two space-separated integers, n and k (3 ≤ n ≤ 105; 0 ≤ k ≤ 105). On the next line are n space-separated distinct integers, s1, s2, ..., sn (1 ≤ si ≤ 109), denoting the skill levels of the cows. On the next k lines are two space separated integers, ai and bi (1 ≤ ai < bi ≤ 109) representing the changes Farmer John made to the scoreboard in the order he makes it.\n\nOutputA single integer, containing the number of triples of cows (p, q, r) for which the final leaderboard shows that cow p beats cow q, cow q beats cow r, and cow r beats cow p.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy3 21 2 31 22 3OutputCopy1InputCopy5 35 9 4 1 71 72 83 9OutputCopy3\n\nInputCopy3 21 2 31 22 3\n\nOutputCopy1\n\nInputCopy5 35 9 4 1 71 72 83 9\n\nOutputCopy3\n\nNoteIn the first sample, cow 3 > cow 1, cow 3 > cow 2, and cow 2 > cow 1. However, the results between cows 1 and 2 and cows 2 and 3 are flipped, so now FJ's results show that cow 1 > cow 2, cow 2 > cow 3, and cow 3 > cow 1, so cows 1, 2, and 3 form a balanced triple.",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Hello everyone! Codeforces Round 174 will be held for both divisions on Sunday, March 17th at 7:30 PM MSK. The problem setters are abacadaea and me (scott_wu). We would like to thank Gerald for his help in preparing the contest and Delinur for translating the problems. We also thank MikeMirzayanov for creating such an awesome site. We are very excited as this is our first Codeforces round.For this contest you’ll be helping Farmer John, Bessie, and the cows. We hope you enjoy the problems! :)The score distribution will be slightly nonstandard.Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Good luck and happy coding! As always, to make the round more exciting, we recommend that you take a look at all the problems!UPD: Our editorial can be found here. Thanks for participating!Congratulations to the winners:Div1 al13n rng_58 HELEN_KK wjmsbmr bmerry Div2 hockey_for_NOI Efremov_licesos Muali koratel lxfind",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 943
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000000, \"s\");\n    inf.readEoln();\n\n    // Check that all s_i are distinct\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"All skill levels s_i must be distinct.\");\n\n    for (int i = 0; i < k; i++) {\n        int ai = inf.readInt(1, 1000000000 - 1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai + 1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000000, \"s\");\n    inf.readEoln();\n\n    // Check that all s_i are distinct\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"All skill levels s_i must be distinct.\");\n\n    for (int i = 0; i < k; i++) {\n        int ai = inf.readInt(1, 1000000000 - 1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai + 1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000000, \"s\");\n    inf.readEoln();\n\n    // Check that all s_i are distinct\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"All skill levels s_i must be distinct.\");\n\n    for (int i = 0; i < k; i++) {\n        int ai = inf.readInt(1, 1000000000 - 1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai + 1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_s = 1000000000;\n    \n    vector<int> s(n);\n\n    // Generate the skills s[i]\n    if (type == \"small_range\") {\n        // Skills in a small range, s[i] ∈ [1, n*2], potentially causing duplicates if not handled properly\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(1, n * 2);\n        // Ensure distinct\n        sort(s.begin(), s.end());\n        s.erase(unique(s.begin(), s.end()), s.end());\n        while ((int)s.size() < n) {\n            int si = rnd.next(1, n * 2);\n            if (!binary_search(s.begin(), s.end(), si))\n                s.push_back(si);\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"ordered_skills\") {\n        // Skills in increasing order\n        int start = rnd.next(1, max_s - n + 1);\n        for (int i = 0; i < n; ++i)\n            s[i] = start + i;\n    } else {\n        // Random skills in [1, max_s], distinct\n        if (n <= int(1e6)) {\n            set<int> used_skills;\n            for(int i = 0; i < n; ++i) {\n                int si;\n                do {\n                    si = rnd.next(1, max_s);\n                } while (used_skills.count(si));\n                used_skills.insert(si);\n                s[i] = si;\n            }\n        } else {\n            // For large n, generate a range and shuffle\n            int start = rnd.next(1, max_s - n + 1);\n            for (int i = 0; i < n; ++i)\n                s[i] = start + i;\n            shuffle(s.begin(), s.end());\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output skills\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", s[i], i == n - 1 ? '\\n' : ' ');\n\n    // Generate flips\n    vector<pair<int, int>> flips(k);\n\n    if (type == \"overlap_flips\") {\n        // Generate overlapping flips\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, max_s / 2);\n            int b = rnd.next(max_s / 2, max_s);\n            if (a >= b) swap(a, b);\n            flips[i] = make_pair(a, b);\n        }\n    } else if (type == \"full_flips\") {\n        // Flip over the entire range\n        for (int i = 0; i < k; ++i) {\n            flips[i] = make_pair(1, max_s);\n        }\n    } else if (type == \"no_effect_flips\") {\n        // Flips outside cow skills\n        for (int i = 0; i < k; ++i) {\n            int a = max_s + rnd.next(1, 1000);\n            int b = a + rnd.next(1, 1000);\n            flips[i] = make_pair(a, b);\n        }\n    } else if (type == \"repeat_flips\") {\n        // Flip the same interval multiple times\n        int a = rnd.next(1, max_s - 1000);\n        int b = a + rnd.next(1, 1000);\n        for (int i = 0; i < k; ++i) {\n            flips[i] = make_pair(a, b);\n        }\n    } else {\n        // Random flips\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, max_s - 1);\n            int b = rnd.next(a + 1, max_s);\n            flips[i] = make_pair(a, b);\n        }\n    }\n\n    // Output flips\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d %d\\n\", flips[i].first, flips[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_s = 1000000000;\n    \n    vector<int> s(n);\n\n    // Generate the skills s[i]\n    if (type == \"small_range\") {\n        // Skills in a small range, s[i] ∈ [1, n*2], potentially causing duplicates if not handled properly\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(1, n * 2);\n        // Ensure distinct\n        sort(s.begin(), s.end());\n        s.erase(unique(s.begin(), s.end()), s.end());\n        while ((int)s.size() < n) {\n            int si = rnd.next(1, n * 2);\n            if (!binary_search(s.begin(), s.end(), si))\n                s.push_back(si);\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"ordered_skills\") {\n        // Skills in increasing order\n        int start = rnd.next(1, max_s - n + 1);\n        for (int i = 0; i < n; ++i)\n            s[i] = start + i;\n    } else {\n        // Random skills in [1, max_s], distinct\n        if (n <= int(1e6)) {\n            set<int> used_skills;\n            for(int i = 0; i < n; ++i) {\n                int si;\n                do {\n                    si = rnd.next(1, max_s);\n                } while (used_skills.count(si));\n                used_skills.insert(si);\n                s[i] = si;\n            }\n        } else {\n            // For large n, generate a range and shuffle\n            int start = rnd.next(1, max_s - n + 1);\n            for (int i = 0; i < n; ++i)\n                s[i] = start + i;\n            shuffle(s.begin(), s.end());\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output skills\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", s[i], i == n - 1 ? '\\n' : ' ');\n\n    // Generate flips\n    vector<pair<int, int>> flips(k);\n\n    if (type == \"overlap_flips\") {\n        // Generate overlapping flips\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, max_s / 2);\n            int b = rnd.next(max_s / 2, max_s);\n            if (a >= b) swap(a, b);\n            flips[i] = make_pair(a, b);\n        }\n    } else if (type == \"full_flips\") {\n        // Flip over the entire range\n        for (int i = 0; i < k; ++i) {\n            flips[i] = make_pair(1, max_s);\n        }\n    } else if (type == \"no_effect_flips\") {\n        // Flips outside cow skills\n        for (int i = 0; i < k; ++i) {\n            int a = max_s + rnd.next(1, 1000);\n            int b = a + rnd.next(1, 1000);\n            flips[i] = make_pair(a, b);\n        }\n    } else if (type == \"repeat_flips\") {\n        // Flip the same interval multiple times\n        int a = rnd.next(1, max_s - 1000);\n        int b = a + rnd.next(1, 1000);\n        for (int i = 0; i < k; ++i) {\n            flips[i] = make_pair(a, b);\n        }\n    } else {\n        // Random flips\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, max_s - 1);\n            int b = rnd.next(a + 1, max_s);\n            flips[i] = make_pair(a, b);\n        }\n    }\n\n    // Output flips\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d %d\\n\", flips[i].first, flips[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, zero flips\n./gen -n 3 -k 0 -type random\n\n# Small n, maximum flips\n./gen -n 3 -k 3 -type random\n\n# n = 3, flips cover entire range\n./gen -n 3 -k 1 -type full_flips\n\n# n = 3, flips outside skill levels\n./gen -n 3 -k 2 -type no_effect_flips\n\n# Medium n, random flips, random skills\n./gen -n 1000 -k 1000 -type random\n\n# Medium n, overlapping flips\n./gen -n 1000 -k 1000 -type overlap_flips\n\n# Medium n, repeat flips\n./gen -n 1000 -k 500 -type repeat_flips\n\n# Max n, zero flips\n./gen -n 100000 -k 0 -type random\n\n# Max n, max k, random flips\n./gen -n 100000 -k 100000 -type random\n\n# Max n, overlapping flips\n./gen -n 100000 -k 100000 -type overlap_flips\n\n# Max n, repeat flips on same interval\n./gen -n 100000 -k 100000 -type repeat_flips\n\n# Max n, flips covering entire range\n./gen -n 100000 -k 100000 -type full_flips\n\n# Max n, flips outside skill levels\n./gen -n 100000 -k 100000 -type no_effect_flips\n\n# Skills in small range, testing potential duplicates in skills\n./gen -n 100000 -k 50000 -type small_range\n\n# Skills in large range, ordered without shuffling\n./gen -n 100000 -k 100000 -type ordered_skills\n\n# Random n and k, random flips\n./gen -n 77777 -k 88888 -type random\n\n# Random n and k, overlapping flips\n./gen -n 77777 -k 88888 -type overlap_flips\n\n# Random n, k = 0\n./gen -n 55555 -k 0 -type random\n\n# n = 3, k = 3, testing cumulative flips\n./gen -n 3 -k 3 -type repeat_flips\n\n# Max n, flips that have no effect\n./gen -n 100000 -k 100000 -type no_effect_flips\n\n# Max n, flips that reverse previous flips\n./gen -n 100000 -k 200000 -type repeat_flips\n\n# Max n, flips covering full range\n./gen -n 100000 -k 1 -type full_flips\n\n# Max n, flips that cover single cow ranges (minimal effect)\n./gen -n 100000 -k 50000 -type overlap_flips\n\n# Edge case: n = 3, k = 0, ordered skills\n./gen -n 3 -k 0 -type ordered_skills\n\n# Edge case: n = 3, k = 0, skills in small range\n./gen -n 3 -k 0 -type small_range\n\n# Edge case: n = 100000, k = 0, skills in small range\n./gen -n 100000 -k 0 -type small_range\n\n# Edge case: n = 100000, k = 100000, minimal flips\n./gen -n 100000 -k 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:00.976613",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "284/A",
      "title": "A. Cows and Primitive Roots",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains a single line containing an integer p (2 ≤ p < 2000). It is guaranteed that p is a prime.",
      "output_spec": "OutputOutput on a single line the number of primitive roots .",
      "sample_tests": "ExamplesInputCopy3OutputCopy1InputCopy5OutputCopy2",
      "description": "A. Cows and Primitive Roots\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains a single line containing an integer p (2 ≤ p < 2000). It is guaranteed that p is a prime.\n\nOutputOutput on a single line the number of primitive roots .\n\nInputCopy3OutputCopy1InputCopy5OutputCopy2\n\nOutputCopy1\n\nOutputCopy2\n\nNoteThe only primitive root  is 2.The primitive roots  are 2 and 3.",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Hello everyone! Codeforces Round 174 will be held for both divisions on Sunday, March 17th at 7:30 PM MSK. The problem setters are abacadaea and me (scott_wu). We would like to thank Gerald for his help in preparing the contest and Delinur for translating the problems. We also thank MikeMirzayanov for creating such an awesome site. We are very excited as this is our first Codeforces round.For this contest you’ll be helping Farmer John, Bessie, and the cows. We hope you enjoy the problems! :)The score distribution will be slightly nonstandard.Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Good luck and happy coding! As always, to make the round more exciting, we recommend that you take a look at all the problems!UPD: Our editorial can be found here. Thanks for participating!Congratulations to the winners:Div1 al13n rng_58 HELEN_KK wjmsbmr bmerry Div2 hockey_for_NOI Efremov_licesos Muali koratel lxfind",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 943
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(2, 1999, \"p\");\n    inf.readEoln();\n\n    // Check that p is prime\n    for (int i = 2; i * i <= p; ++i) {\n        if (p % i == 0) {\n            ensuref(false, \"p must be prime, but p=%d is divisible by %d\", p, i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(2, 1999, \"p\");\n    inf.readEoln();\n\n    // Check that p is prime\n    for (int i = 2; i * i <= p; ++i) {\n        if (p % i == 0) {\n            ensuref(false, \"p must be prime, but p=%d is divisible by %d\", p, i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(2, 1999, \"p\");\n    inf.readEoln();\n\n    // Check that p is prime\n    for (int i = 2; i * i <= p; ++i) {\n        if (p % i == 0) {\n            ensuref(false, \"p must be prime, but p=%d is divisible by %d\", p, i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> primes;\nvector<int> p_minus_1_prime_primes;\nvector<int> p_minus_1_power_of_two_primes;\n\nvoid generatePrimes() {\n    int MAX_P = 2000;\n    vector<bool> isPrime(MAX_P, true);\n    isPrime[0] = isPrime[1] = false;\n    for(int i=2; i<MAX_P; i++) {\n        if(isPrime[i]) {\n            primes.push_back(i);\n            if ((long long)i*i < MAX_P){\n                for(int j=i*i; j<MAX_P; j+=i) {\n                    isPrime[j]=false;\n                }\n            }\n        }\n    }\n    // Now generate p where p-1 is prime\n    for(int pr : primes) {\n        if (pr > 2 && binary_search(primes.begin(), primes.end(), pr-1)) {\n            p_minus_1_prime_primes.push_back(pr);\n        }\n    }\n    // Generate p where p-1 is power of two\n    for(int pr : primes) {\n        int x = pr - 1;\n        if ((x & (x - 1)) == 0) { // x is power of two\n            p_minus_1_power_of_two_primes.push_back(pr);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    generatePrimes();\n\n    string type = opt<string>(\"type\", \"random\");\n    int p = opt<int>(\"p\", -1); // default -1\n\n    int n = primes.size();\n\n    int selected_p;\n\n    if (type == \"specific\") {\n        // Use the specified p\n        ensure(p >= 2 && p < 2000);\n        // Check if p is prime\n        if (!binary_search(primes.begin(), primes.end(), p)) {\n            fprintf(stderr, \"Error: p=%d is not prime.\\n\", p);\n            exit(1);\n        }\n        selected_p = p;\n    } else if (type == \"p_minus_1_prime\") {\n        if (p_minus_1_prime_primes.empty()) {\n            fprintf(stderr, \"No primes where p-1 is prime found.\\n\");\n            exit(1);\n        }\n        selected_p = p_minus_1_prime_primes[rnd.next(int(p_minus_1_prime_primes.size()))];\n    } else if (type == \"p_minus_1_power_of_two\") {\n        if (p_minus_1_power_of_two_primes.empty()) {\n            fprintf(stderr, \"No primes where p-1 is power of two found.\\n\");\n            exit(1);\n        }\n        selected_p = p_minus_1_power_of_two_primes[rnd.next(int(p_minus_1_power_of_two_primes.size()))];\n    } else if (type == \"small\") {\n        // Select a small prime\n        vector<int> small_primes;\n        for (int pr : primes) {\n            if (pr <= 10)\n                small_primes.push_back(pr);\n        }\n        ensure(!small_primes.empty());\n        selected_p = small_primes[rnd.next(int(small_primes.size()))];\n    } else if (type == \"large\") {\n        // Select a large prime\n        vector<int> large_primes;\n        for (int pr : primes) {\n            if (pr >= 1900)\n                large_primes.push_back(pr);\n        }\n        ensure(!large_primes.empty());\n        selected_p = large_primes[rnd.next(int(large_primes.size()))];\n    } else if (type == \"random\") {\n        // Select a random prime\n        selected_p = primes[rnd.next(n)];\n    } else {\n        fprintf(stderr, \"Unrecognized type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output p\n    printf(\"%d\\n\", selected_p);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> primes;\nvector<int> p_minus_1_prime_primes;\nvector<int> p_minus_1_power_of_two_primes;\n\nvoid generatePrimes() {\n    int MAX_P = 2000;\n    vector<bool> isPrime(MAX_P, true);\n    isPrime[0] = isPrime[1] = false;\n    for(int i=2; i<MAX_P; i++) {\n        if(isPrime[i]) {\n            primes.push_back(i);\n            if ((long long)i*i < MAX_P){\n                for(int j=i*i; j<MAX_P; j+=i) {\n                    isPrime[j]=false;\n                }\n            }\n        }\n    }\n    // Now generate p where p-1 is prime\n    for(int pr : primes) {\n        if (pr > 2 && binary_search(primes.begin(), primes.end(), pr-1)) {\n            p_minus_1_prime_primes.push_back(pr);\n        }\n    }\n    // Generate p where p-1 is power of two\n    for(int pr : primes) {\n        int x = pr - 1;\n        if ((x & (x - 1)) == 0) { // x is power of two\n            p_minus_1_power_of_two_primes.push_back(pr);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    generatePrimes();\n\n    string type = opt<string>(\"type\", \"random\");\n    int p = opt<int>(\"p\", -1); // default -1\n\n    int n = primes.size();\n\n    int selected_p;\n\n    if (type == \"specific\") {\n        // Use the specified p\n        ensure(p >= 2 && p < 2000);\n        // Check if p is prime\n        if (!binary_search(primes.begin(), primes.end(), p)) {\n            fprintf(stderr, \"Error: p=%d is not prime.\\n\", p);\n            exit(1);\n        }\n        selected_p = p;\n    } else if (type == \"p_minus_1_prime\") {\n        if (p_minus_1_prime_primes.empty()) {\n            fprintf(stderr, \"No primes where p-1 is prime found.\\n\");\n            exit(1);\n        }\n        selected_p = p_minus_1_prime_primes[rnd.next(int(p_minus_1_prime_primes.size()))];\n    } else if (type == \"p_minus_1_power_of_two\") {\n        if (p_minus_1_power_of_two_primes.empty()) {\n            fprintf(stderr, \"No primes where p-1 is power of two found.\\n\");\n            exit(1);\n        }\n        selected_p = p_minus_1_power_of_two_primes[rnd.next(int(p_minus_1_power_of_two_primes.size()))];\n    } else if (type == \"small\") {\n        // Select a small prime\n        vector<int> small_primes;\n        for (int pr : primes) {\n            if (pr <= 10)\n                small_primes.push_back(pr);\n        }\n        ensure(!small_primes.empty());\n        selected_p = small_primes[rnd.next(int(small_primes.size()))];\n    } else if (type == \"large\") {\n        // Select a large prime\n        vector<int> large_primes;\n        for (int pr : primes) {\n            if (pr >= 1900)\n                large_primes.push_back(pr);\n        }\n        ensure(!large_primes.empty());\n        selected_p = large_primes[rnd.next(int(large_primes.size()))];\n    } else if (type == \"random\") {\n        // Select a random prime\n        selected_p = primes[rnd.next(n)];\n    } else {\n        fprintf(stderr, \"Unrecognized type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output p\n    printf(\"%d\\n\", selected_p);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Specific small primes\n./gen -type specific -p 2\n./gen -type specific -p 3\n./gen -type specific -p 5\n./gen -type specific -p 7\n./gen -type specific -p 11\n\n# Specific large primes\n./gen -type specific -p 1993\n./gen -type specific -p 1997\n./gen -type specific -p 1999\n\n# Random small primes\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Random large primes\n./gen -type large\n./gen -type large\n./gen -type large\n\n# Random primes\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Primes where p-1 is prime\n./gen -type p_minus_1_prime\n./gen -type p_minus_1_prime\n./gen -type p_minus_1_prime\n\n# Primes where p-1 is power of two\n./gen -type p_minus_1_power_of_two\n./gen -type p_minus_1_power_of_two\n./gen -type p_minus_1_power_of_two\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:03.249493",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "284/B",
      "title": "B. Коровки и игра в покер",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 2·105). Во второй строке записано n символов, каждый за них — «A», «I», или «F»: i-ый символ равен «A», если статус i-го игрока равен «ALLIN», «I» — если статус i-го игрока равен «IN», или «F» — если статус i-го игрока равен «FOLDED».",
      "output_spec": "Выходные данныеПервая строка должна содержать единственное целое число, обозначающее количество игроков, которые могут раскрыть карты в данный момент.",
      "sample_tests": "ПримерыВходные данныеСкопировать6AFFAAAВыходные данныеСкопировать4Входные данныеСкопировать3AFIВыходные данныеСкопировать1",
      "description": "B. Коровки и игра в покер\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 2·105). Во второй строке записано n символов, каждый за них — «A», «I», или «F»: i-ый символ равен «A», если статус i-го игрока равен «ALLIN», «I» — если статус i-го игрока равен «IN», или «F» — если статус i-го игрока равен «FOLDED».\n\nВходные данные\n\nВыходные данныеПервая строка должна содержать единственное целое число, обозначающее количество игроков, которые могут раскрыть карты в данный момент.\n\nВыходные данные\n\nВходные данныеСкопировать6AFFAAAВыходные данныеСкопировать4Входные данныеСкопировать3AFIВыходные данныеСкопировать1\n\nВходные данныеСкопировать6AFFAAA\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3AFI\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере коровки номер 1, 4, 5 и 6 могут раскрыть карты. Во втором примере только коровка номер 3 может раскрыть карты.",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Всем привет! Соревнование Codeforces Round 174 будет проводиться в обоих дивизионах в воскресенье, 17-го Марта в 19:30 MSK. Задачи готовили abacadaea и я (scott_wu). Традиционно мы благодарим Gerald за помощь в подготовке соревнования и Delinur за перевод задач. Большое спасибо MikeMirzayanov за создание такого отличного сайта. Мы очень взволнованы, ведь это наш первый Codeforces раунд.В этом раунде Вы будете помогать Фермеру Джону, Бесси, и коровкам. Мы надеемся, Вам понравятся задачи! :)Распределение баллов по задачам будет немного нестандартное:Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Удачи Вам и приятного кодинга! Как обычно, чтобы сделать раунд более захватывающим, мы советуем прочитать Вам условия всех задач!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 760
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 14",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 15",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 10",
          "code": "---------------------------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[AIF]{\" + to_string(n) + \"}\", \"status_line\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[AIF]{\" + to_string(n) + \"}\", \"status_line\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[AIF]{\" + to_string(n) + \"}\", \"status_line\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string pattern = opt<string>(\"pattern\", \"random\");\n\n    if (n < 2 || n > 200000) {\n        fprintf(stderr, \"Invalid n: must be between 2 and 200000\\n\");\n        return 1;\n    }\n\n    string status(n, ' ');\n\n    if (pattern == \"all_A\") {\n        status = string(n, 'A');\n    } else if (pattern == \"all_I\") {\n        status = string(n, 'I');\n    } else if (pattern == \"all_F\") {\n        status = string(n, 'F');\n    } else if (pattern == \"one_I_rest_A\") {\n        status = string(n, 'A');\n        int idx = rnd.next(n);\n        status[idx] = 'I';\n    } else if (pattern == \"one_F_rest_A\") {\n        status = string(n, 'A');\n        int idx = rnd.next(n);\n        status[idx] = 'F';\n    } else if (pattern == \"one_I_rest_F\") {\n        status = string(n, 'F');\n        int idx = rnd.next(n);\n        status[idx] = 'I';\n    } else if (pattern == \"one_F_rest_I\") {\n        status = string(n, 'I');\n        int idx = rnd.next(n);\n        status[idx] = 'F';\n    } else if (pattern == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            status[i] = (i % 2 == 0) ? 'A' : 'I';\n        }\n    } else if (pattern == \"random\") {\n        string choices = \"AIF\";\n        for (int i = 0; i < n; ++i) {\n            status[i] = choices[rnd.next(3)];\n        }\n    } else if (pattern == \"custom\") {\n        int a = opt<int>(\"a\", 0);\n        int i = opt<int>(\"i\", 0);\n        int f = opt<int>(\"f\", 0);\n        if (a + i + f != n) {\n            fprintf(stderr, \"Invalid counts: a + i + f must equal n\\n\");\n            return 1;\n        }\n        vector<char> statuses;\n        statuses.insert(statuses.end(), a, 'A');\n        statuses.insert(statuses.end(), i, 'I');\n        statuses.insert(statuses.end(), f, 'F');\n        shuffle(statuses.begin(), statuses.end());\n        status = string(statuses.begin(), statuses.end());\n    } else {\n        fprintf(stderr, \"Unknown pattern: %s\\n\", pattern.c_str());\n        return 1;\n    }\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", status.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string pattern = opt<string>(\"pattern\", \"random\");\n\n    if (n < 2 || n > 200000) {\n        fprintf(stderr, \"Invalid n: must be between 2 and 200000\\n\");\n        return 1;\n    }\n\n    string status(n, ' ');\n\n    if (pattern == \"all_A\") {\n        status = string(n, 'A');\n    } else if (pattern == \"all_I\") {\n        status = string(n, 'I');\n    } else if (pattern == \"all_F\") {\n        status = string(n, 'F');\n    } else if (pattern == \"one_I_rest_A\") {\n        status = string(n, 'A');\n        int idx = rnd.next(n);\n        status[idx] = 'I';\n    } else if (pattern == \"one_F_rest_A\") {\n        status = string(n, 'A');\n        int idx = rnd.next(n);\n        status[idx] = 'F';\n    } else if (pattern == \"one_I_rest_F\") {\n        status = string(n, 'F');\n        int idx = rnd.next(n);\n        status[idx] = 'I';\n    } else if (pattern == \"one_F_rest_I\") {\n        status = string(n, 'I');\n        int idx = rnd.next(n);\n        status[idx] = 'F';\n    } else if (pattern == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            status[i] = (i % 2 == 0) ? 'A' : 'I';\n        }\n    } else if (pattern == \"random\") {\n        string choices = \"AIF\";\n        for (int i = 0; i < n; ++i) {\n            status[i] = choices[rnd.next(3)];\n        }\n    } else if (pattern == \"custom\") {\n        int a = opt<int>(\"a\", 0);\n        int i = opt<int>(\"i\", 0);\n        int f = opt<int>(\"f\", 0);\n        if (a + i + f != n) {\n            fprintf(stderr, \"Invalid counts: a + i + f must equal n\\n\");\n            return 1;\n        }\n        vector<char> statuses;\n        statuses.insert(statuses.end(), a, 'A');\n        statuses.insert(statuses.end(), i, 'I');\n        statuses.insert(statuses.end(), f, 'F');\n        shuffle(statuses.begin(), statuses.end());\n        status = string(statuses.begin(), statuses.end());\n    } else {\n        fprintf(stderr, \"Unknown pattern: %s\\n\", pattern.c_str());\n        return 1;\n    }\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", status.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -pattern all_A\n./gen -n 2 -pattern all_I\n./gen -n 2 -pattern all_F\n./gen -n 2 -pattern one_I_rest_A\n./gen -n 2 -pattern one_F_rest_A\n./gen -n 2 -pattern one_I_rest_F\n./gen -n 2 -pattern one_F_rest_I\n./gen -n 2 -pattern alternating\n./gen -n 2 -pattern random\n\n./gen -n 3 -pattern all_A\n./gen -n 3 -pattern all_I\n./gen -n 3 -pattern one_I_rest_A\n./gen -n 3 -pattern one_F_rest_A\n./gen -n 3 -pattern one_I_rest_F\n./gen -n 3 -pattern one_F_rest_I\n\n./gen -n 10 -pattern all_A\n./gen -n 10 -pattern alternating\n./gen -n 10 -pattern random\n\n./gen -n 100 -pattern all_I\n./gen -n 100 -pattern random\n\n./gen -n 1000 -pattern all_A\n./gen -n 1000 -pattern one_I_rest_A\n./gen -n 1000 -pattern one_F_rest_I\n./gen -n 1000 -pattern random\n\n./gen -n 100000 -pattern all_A\n./gen -n 100000 -pattern all_I\n./gen -n 100000 -pattern one_I_rest_A\n./gen -n 100000 -pattern one_F_rest_I\n./gen -n 100000 -pattern random\n\n./gen -n 200000 -pattern all_A\n./gen -n 200000 -pattern alternating\n./gen -n 200000 -pattern random\n\n./gen -n 100000 -pattern custom -a 50000 -i 30000 -f 20000\n./gen -n 100000 -pattern custom -a 33333 -i 33334 -f 33333\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:05.155444",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "284/C",
      "title": "C. Cows and Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the number of operations. The next n lines describe the operations. Each line will start with an integer ti (1 ≤ ti ≤ 3), denoting the type of the operation (see above). If ti = 1, it will be followed by two integers ai, xi (|xi| ≤ 103; 1 ≤ ai). If ti = 2, it will be followed by a single integer ki (|ki| ≤ 103). If ti = 3, it will not be followed by anything.It is guaranteed that all operations are correct (don't touch nonexistent elements) and that there will always be at least one element in the sequence.",
      "output_spec": "OutputOutput n lines each containing the average of the numbers in the sequence after the corresponding operation.The answer will be considered correct if its absolute or relative error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy52 132 32 13OutputCopy0.5000000.0000001.5000001.3333331.500000InputCopy62 11 2 202 21 2 -333OutputCopy0.50000020.50000014.33333312.33333317.50000017.000000",
      "description": "C. Cows and Sequence\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the number of operations. The next n lines describe the operations. Each line will start with an integer ti (1 ≤ ti ≤ 3), denoting the type of the operation (see above). If ti = 1, it will be followed by two integers ai, xi (|xi| ≤ 103; 1 ≤ ai). If ti = 2, it will be followed by a single integer ki (|ki| ≤ 103). If ti = 3, it will not be followed by anything.It is guaranteed that all operations are correct (don't touch nonexistent elements) and that there will always be at least one element in the sequence.\n\nOutputOutput n lines each containing the average of the numbers in the sequence after the corresponding operation.The answer will be considered correct if its absolute or relative error doesn't exceed 10 - 6.\n\nInputCopy52 132 32 13OutputCopy0.5000000.0000001.5000001.3333331.500000InputCopy62 11 2 202 21 2 -333OutputCopy0.50000020.50000014.33333312.33333317.50000017.000000\n\nInputCopy52 132 32 13\n\nOutputCopy0.5000000.0000001.5000001.3333331.500000\n\nInputCopy62 11 2 202 21 2 -333\n\nOutputCopy0.50000020.50000014.33333312.33333317.50000017.000000\n\nNoteIn the second sample, the sequence becomes",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Hello everyone! Codeforces Round 174 will be held for both divisions on Sunday, March 17th at 7:30 PM MSK. The problem setters are abacadaea and me (scott_wu). We would like to thank Gerald for his help in preparing the contest and Delinur for translating the problems. We also thank MikeMirzayanov for creating such an awesome site. We are very excited as this is our first Codeforces round.For this contest you’ll be helping Farmer John, Bessie, and the cows. We hope you enjoy the problems! :)The score distribution will be slightly nonstandard.Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Good luck and happy coding! As always, to make the round more exciting, we recommend that you take a look at all the problems!UPD: Our editorial can be found here. Thanks for participating!Congratulations to the winners:Div1 al13n rng_58 HELEN_KK wjmsbmr bmerry Div2 hockey_for_NOI Efremov_licesos Muali koratel lxfind",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 943
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    int seq_size = 1; // Initially, sequence contains one element.\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(1, 3, \"ti\");\n\n        if (ti == 1) {\n            inf.readSpace();\n            int ai = inf.readInt(1, seq_size, \"ai\");\n            inf.readSpace();\n            int xi = inf.readInt(-1000, 1000, \"xi\");\n            inf.readEoln();\n            // Sequence size remains the same.\n        } else if (ti == 2) {\n            inf.readSpace();\n            int ki = inf.readInt(-1000, 1000, \"ki\");\n            inf.readEoln();\n            seq_size += 1; // Append an element.\n        } else if (ti == 3) {\n            inf.readEoln();\n            ensuref(seq_size >= 2, \"Cannot remove element when sequence size is less than 2 (current size = %d)\", seq_size);\n            seq_size -= 1; // Remove last element.\n        }\n\n        ensuref(seq_size >= 1, \"Sequence size must remain at least 1 (current size = %d after operation %d)\", seq_size, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    int seq_size = 1; // Initially, sequence contains one element.\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(1, 3, \"ti\");\n\n        if (ti == 1) {\n            inf.readSpace();\n            int ai = inf.readInt(1, seq_size, \"ai\");\n            inf.readSpace();\n            int xi = inf.readInt(-1000, 1000, \"xi\");\n            inf.readEoln();\n            // Sequence size remains the same.\n        } else if (ti == 2) {\n            inf.readSpace();\n            int ki = inf.readInt(-1000, 1000, \"ki\");\n            inf.readEoln();\n            seq_size += 1; // Append an element.\n        } else if (ti == 3) {\n            inf.readEoln();\n            ensuref(seq_size >= 2, \"Cannot remove element when sequence size is less than 2 (current size = %d)\", seq_size);\n            seq_size -= 1; // Remove last element.\n        }\n\n        ensuref(seq_size >= 1, \"Sequence size must remain at least 1 (current size = %d after operation %d)\", seq_size, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    int seq_size = 1; // Initially, sequence contains one element.\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(1, 3, \"ti\");\n\n        if (ti == 1) {\n            inf.readSpace();\n            int ai = inf.readInt(1, seq_size, \"ai\");\n            inf.readSpace();\n            int xi = inf.readInt(-1000, 1000, \"xi\");\n            inf.readEoln();\n            // Sequence size remains the same.\n        } else if (ti == 2) {\n            inf.readSpace();\n            int ki = inf.readInt(-1000, 1000, \"ki\");\n            inf.readEoln();\n            seq_size += 1; // Append an element.\n        } else if (ti == 3) {\n            inf.readEoln();\n            ensuref(seq_size >= 2, \"Cannot remove element when sequence size is less than 2 (current size = %d)\", seq_size);\n            seq_size -= 1; // Remove last element.\n        }\n\n        ensuref(seq_size >= 1, \"Sequence size must remain at least 1 (current size = %d after operation %d)\", seq_size, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_xi = opt<int>(\"max_xi\", 1000);\n\n    vector<int> ops_t; // Store operation types\n    vector<vector<int>> ops_params; // Store operation parameters\n\n    int seq_size = 1; // initialize sequence size to 1\n    for (int i = 0; i < n; i++) {\n        int ti = 0;\n        if (type == \"only_type1\") {\n            ti = 1;\n        } else if (type == \"only_type2\") {\n            ti = 2;\n        } else if (type == \"only_type3\") {\n            // Can only do remove when seq_size >= 2\n            if (seq_size >= 2) {\n                ti = 3;\n            } else {\n                // Since can't remove, default to type 2\n                ti = 2;\n            }\n        } else if (type == \"increase_sequence\") {\n            ti = 2; // Always append\n        } else if (type == \"decrease_sequence\") {\n            if (seq_size >= 2) {\n                ti = 3; // Remove if possible\n            } else {\n                ti = 2; // Append to increase size\n            }\n        } else if (type == \"alternating_types\") {\n            if (seq_size >= 2) {\n                ti = (i % 3) + 1; // Cycle through types 1, 2, 3\n            } else {\n                ti = (i % 2) + 1; // Types 1 and 2\n            }\n        } else {\n            // Random type\n            if (seq_size == 1) {\n                ti = rnd.next(1,2); // Can't remove when only one element\n            } else {\n                ti = rnd.next(1,3);\n            }\n        }\n\n        vector<int> params;\n        if (ti == 1) {\n            // Type 1: Add xi to ai elements\n            int ai;\n            if (type == \"max_ai\") {\n                ai = seq_size;\n            } else if (type == \"min_ai\") {\n                ai = 1;\n            } else {\n                ai = rnd.next(1, seq_size);\n            }\n            int xi;\n            if (type == \"positive_xi\") {\n                xi = rnd.next(1, max_xi);\n            } else if (type == \"negative_xi\") {\n                xi = rnd.next(-max_xi, -1);\n            } else {\n                xi = rnd.next(-max_xi, max_xi);\n            }\n            params.push_back(ai);\n            params.push_back(xi);\n        } else if (ti == 2) {\n            // Type 2: Append ki\n            int ki;\n            if (type == \"positive_ki\") {\n                ki = rnd.next(1, max_xi);\n            } else if (type == \"negative_ki\") {\n                ki = rnd.next(-max_xi, -1);\n            } else {\n                ki = rnd.next(-max_xi, max_xi);\n            }\n            params.push_back(ki);\n            seq_size++;\n        } else if (ti == 3) {\n            // Type 3: Remove last element\n            seq_size--;\n        }\n\n        ops_t.push_back(ti);\n        ops_params.push_back(params);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        int ti = ops_t[i];\n        printf(\"%d\", ti);\n        if (ti == 1) {\n            int ai = ops_params[i][0];\n            int xi = ops_params[i][1];\n            printf(\" %d %d\", ai, xi);\n        } else if (ti == 2) {\n            int ki = ops_params[i][0];\n            printf(\" %d\", ki);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_xi = opt<int>(\"max_xi\", 1000);\n\n    vector<int> ops_t; // Store operation types\n    vector<vector<int>> ops_params; // Store operation parameters\n\n    int seq_size = 1; // initialize sequence size to 1\n    for (int i = 0; i < n; i++) {\n        int ti = 0;\n        if (type == \"only_type1\") {\n            ti = 1;\n        } else if (type == \"only_type2\") {\n            ti = 2;\n        } else if (type == \"only_type3\") {\n            // Can only do remove when seq_size >= 2\n            if (seq_size >= 2) {\n                ti = 3;\n            } else {\n                // Since can't remove, default to type 2\n                ti = 2;\n            }\n        } else if (type == \"increase_sequence\") {\n            ti = 2; // Always append\n        } else if (type == \"decrease_sequence\") {\n            if (seq_size >= 2) {\n                ti = 3; // Remove if possible\n            } else {\n                ti = 2; // Append to increase size\n            }\n        } else if (type == \"alternating_types\") {\n            if (seq_size >= 2) {\n                ti = (i % 3) + 1; // Cycle through types 1, 2, 3\n            } else {\n                ti = (i % 2) + 1; // Types 1 and 2\n            }\n        } else {\n            // Random type\n            if (seq_size == 1) {\n                ti = rnd.next(1,2); // Can't remove when only one element\n            } else {\n                ti = rnd.next(1,3);\n            }\n        }\n\n        vector<int> params;\n        if (ti == 1) {\n            // Type 1: Add xi to ai elements\n            int ai;\n            if (type == \"max_ai\") {\n                ai = seq_size;\n            } else if (type == \"min_ai\") {\n                ai = 1;\n            } else {\n                ai = rnd.next(1, seq_size);\n            }\n            int xi;\n            if (type == \"positive_xi\") {\n                xi = rnd.next(1, max_xi);\n            } else if (type == \"negative_xi\") {\n                xi = rnd.next(-max_xi, -1);\n            } else {\n                xi = rnd.next(-max_xi, max_xi);\n            }\n            params.push_back(ai);\n            params.push_back(xi);\n        } else if (ti == 2) {\n            // Type 2: Append ki\n            int ki;\n            if (type == \"positive_ki\") {\n                ki = rnd.next(1, max_xi);\n            } else if (type == \"negative_ki\") {\n                ki = rnd.next(-max_xi, -1);\n            } else {\n                ki = rnd.next(-max_xi, max_xi);\n            }\n            params.push_back(ki);\n            seq_size++;\n        } else if (ti == 3) {\n            // Type 3: Remove last element\n            seq_size--;\n        }\n\n        ops_t.push_back(ti);\n        ops_params.push_back(params);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        int ti = ops_t[i];\n        printf(\"%d\", ti);\n        if (ti == 1) {\n            int ai = ops_params[i][0];\n            int xi = ops_params[i][1];\n            printf(\" %d %d\", ai, xi);\n        } else if (ti == 2) {\n            int ki = ops_params[i][0];\n            printf(\" %d\", ki);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 20 -type only_type1\n./gen -n 20 -type only_type2\n./gen -n 20 -type only_type3\n./gen -n 50 -type alternating_types\n./gen -n 100 -type increase_sequence\n./gen -n 100 -type decrease_sequence\n./gen -n 1000 -type max_ai\n./gen -n 1000 -type min_ai\n./gen -n 1000 -type positive_xi\n./gen -n 1000 -type negative_xi\n./gen -n 10000 -type random\n./gen -n 10000 -type increase_sequence\n./gen -n 10000 -type decrease_sequence\n./gen -n 200000 -type random\n./gen -n 200000 -type alternating_types\n./gen -n 200000 -type only_type1\n./gen -n 200000 -type only_type2\n./gen -n 200000 -type increase_sequence\n./gen -n 200000 -type decrease_sequence\n./gen -n 200000 -type max_ai\n./gen -n 200000 -type min_ai\n./gen -n 200000 -type positive_xi\n./gen -n 200000 -type negative_xi\n./gen -n 200000 -type random -max_xi 1000\n./gen -n 200000 -type random -max_xi 1\n./gen -n 200000 -type random -max_xi 1000\n./gen -n 200000 -type random -max_xi 1000\n./gen -n 200000 -type random -max_xi 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:06.924476",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "284/D",
      "title": "D. Коровки программируют",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит единственное целое число, n (2 ≤ n ≤ 2·105). Следующая строка содержит n - 1 целых чисел через пробел, a2, a3, ..., an (1 ≤ ai ≤ 109).",
      "output_spec": "Выходные данныеВыведите n - 1 строк. В i-ой строке выведите требуемое значение, когда программа запускается на последовательности i, a2, a3, ...an.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать42 4 1Выходные данныеСкопировать368Входные данныеСкопировать31 2Выходные данныеСкопировать-1-1",
      "description": "D. Коровки программируют\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит единственное целое число, n (2 ≤ n ≤ 2·105). Следующая строка содержит n - 1 целых чисел через пробел, a2, a3, ..., an (1 ≤ ai ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите n - 1 строк. В i-ой строке выведите требуемое значение, когда программа запускается на последовательности i, a2, a3, ...an.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать42 4 1Выходные данныеСкопировать368Входные данныеСкопировать31 2Выходные данныеСкопировать-1-1\n\nВходные данныеСкопировать42 4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать368\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере   Для i = 1,  x изменяется следующим образом: , y становится 1 + 2 = 3.  Для i = 2,  x изменяется следующим образом: , y становится 2 + 4 = 6.  Для i = 3,  x изменяется следующим образом: , y становится 3 + 1 + 4 = 8.",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Всем привет! Соревнование Codeforces Round 174 будет проводиться в обоих дивизионах в воскресенье, 17-го Марта в 19:30 MSK. Задачи готовили abacadaea и я (scott_wu). Традиционно мы благодарим Gerald за помощь в подготовке соревнования и Delinur за перевод задач. Большое спасибо MikeMirzayanov за создание такого отличного сайта. Мы очень взволнованы, ведь это наш первый Codeforces раунд.В этом раунде Вы будете помогать Фермеру Джону, Бесси, и коровкам. Мы надеемся, Вам понравятся задачи! :)Распределение баллов по задачам будет немного нестандартное:Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Удачи Вам и приятного кодинга! Как обычно, чтобы сделать раунд более захватывающим, мы советуем прочитать Вам условия всех задач!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 760
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 14",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 15",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 10",
          "code": "---------------------------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n-1);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1;\n    } else if (type == \"large\") {\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1000000000;\n    } else if (type == \"infinite_loop\") {\n        // Generate a sequence that causes infinite loop\n        int K = max(1, n / 2);\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1;\n        if (1 + K <= n) {\n            a[0] = K;        // a[1] = K\n            a[K - 1] = K;    // a[K] = K\n        }\n    } else if (type == \"immediate_terminate\") {\n        a[0] = 1000000000; // First ai large enough to cause immediate termination\n        for (int i = 1; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else {\n        // default to random if an unknown type is specified\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a2 to an\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 2) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n-1);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1;\n    } else if (type == \"large\") {\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1000000000;\n    } else if (type == \"infinite_loop\") {\n        // Generate a sequence that causes infinite loop\n        int K = max(1, n / 2);\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1;\n        if (1 + K <= n) {\n            a[0] = K;        // a[1] = K\n            a[K - 1] = K;    // a[K] = K\n        }\n    } else if (type == \"immediate_terminate\") {\n        a[0] = 1000000000; // First ai large enough to cause immediate termination\n        for (int i = 1; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else {\n        // default to random if an unknown type is specified\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a2 to an\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 2) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type ones\n./gen -n 2 -type large\n./gen -n 2 -type infinite_loop\n./gen -n 2 -type immediate_terminate\n\n./gen -n 3 -type random\n./gen -n 3 -type ones\n./gen -n 3 -type large\n./gen -n 3 -type infinite_loop\n./gen -n 3 -type immediate_terminate\n\n./gen -n 10 -type random\n./gen -n 10 -type ones\n./gen -n 10 -type large\n./gen -n 10 -type infinite_loop\n./gen -n 10 -type immediate_terminate\n\n./gen -n 1000 -type random\n./gen -n 1000 -type ones\n./gen -n 1000 -type large\n./gen -n 1000 -type infinite_loop\n./gen -n 1000 -type immediate_terminate\n\n./gen -n 100000 -type random\n./gen -n 100000 -type ones\n./gen -n 100000 -type large\n./gen -n 100000 -type infinite_loop\n./gen -n 100000 -type immediate_terminate\n\n./gen -n 200000 -type random\n./gen -n 200000 -type ones\n./gen -n 200000 -type large\n./gen -n 200000 -type infinite_loop\n./gen -n 200000 -type immediate_terminate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:08.707281",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "284/E",
      "title": "E. Проблемы с монетками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит три целых числа через пробел, n, q и t (1 ≤ n ≤ 300; 0 ≤ q ≤ n; 1 ≤ t ≤ 105). Вторая строка содержит n целых чисел через пробел, a1, a2, ..., an (1 ≤ ai ≤ 105). Следующие q строк содержат по два различных целых числа через пробел, bi и ci (1 ≤ bi, ci ≤ n; bi ≠ ci).Гарантируется, что все bi различны и что все ci различны.",
      "output_spec": "Выходные данныеЕдинственное целое число, количество подходящих комбинаций монет, которые могут быть у Бесси, по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать4 2 173 1 2 54 23 4Выходные данныеСкопировать3Входные данныеСкопировать3 2 63 1 11 22 3Выходные данныеСкопировать0Входные данныеСкопировать3 2 101 2 31 22 1Выходные данныеСкопировать0",
      "description": "E. Проблемы с монетками\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит три целых числа через пробел, n, q и t (1 ≤ n ≤ 300; 0 ≤ q ≤ n; 1 ≤ t ≤ 105). Вторая строка содержит n целых чисел через пробел, a1, a2, ..., an (1 ≤ ai ≤ 105). Следующие q строк содержат по два различных целых числа через пробел, bi и ci (1 ≤ bi, ci ≤ n; bi ≠ ci).Гарантируется, что все bi различны и что все ci различны.\n\nВходные данные\n\nВыходные данныеЕдинственное целое число, количество подходящих комбинаций монет, которые могут быть у Бесси, по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать4 2 173 1 2 54 23 4Выходные данныеСкопировать3Входные данныеСкопировать3 2 63 1 11 22 3Выходные данныеСкопировать0Входные данныеСкопировать3 2 101 2 31 22 1Выходные данныеСкопировать0\n\nВходные данныеСкопировать4 2 173 1 2 54 23 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2 63 1 11 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2 101 2 31 22 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеДля первого примера, следующие три комбинации в целом дают 17 центов и удовлетворяют данным условиям: {0 монет типа 1, 1 монета типа 2, 3 монеты типа 3, 2 монеты типа 4}, {0, 0, 6, 1}, {2, 0, 3, 1}.Других комбинаций нет. Обратите внимание, что несмотря на то, что 4 встречается как в bi, так и в ci, условия задачи все равно удовлетворяются, потому что все bi различны и все ci различны по отдельности.",
      "solutions": [
        {
          "title": "Codeforces Round #174 - Codeforces",
          "content": "Всем привет! Соревнование Codeforces Round 174 будет проводиться в обоих дивизионах в воскресенье, 17-го Марта в 19:30 MSK. Задачи готовили abacadaea и я (scott_wu). Традиционно мы благодарим Gerald за помощь в подготовке соревнования и Delinur за перевод задач. Большое спасибо MikeMirzayanov за создание такого отличного сайта. Мы очень взволнованы, ведь это наш первый Codeforces раунд.В этом раунде Вы будете помогать Фермеру Джону, Бесси, и коровкам. Мы надеемся, Вам понравятся задачи! :)Распределение баллов по задачам будет немного нестандартное:Div2 — 500 — 1000 — 2000 — 2000 — 2500Div1 — 1000 — 1000 — 1500 — 2000 — 2500Удачи Вам и приятного кодинга! Как обычно, чтобы сделать раунд более захватывающим, мы советуем прочитать Вам условия всех задач!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7027",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 760
        },
        {
          "title": "Math Problems on Codeforces #174 - Codeforces",
          "content": "Hi Guys,Hope you enjoyed Round 174. :) I would like to add a few comments on some of the problems, beyond the editorial. div 2 A ****If you know some math, you can actually solve this problem in (!!!) You can show that the answer is φ (p - 1) where φ (n) is the number of positive integers i less than to n with gcd(i, n) = 1. To prove this we first show that there is always at least one primitive root for all primes p. (This is a fairly well known result so I won’t prove it here, but you can find many proofs online) So now assume g is a primitive root Then, the set {g, g2, ... gp - 1} is congruent to the set {1, 2, ... , p - 1}. Furthermore, its not hard to show that gi is a primitive root if and only if gcd(i, p - 1) = 1,  (try it!) hence our formula φ (p - 1). φ (n) can be computed by getting the prime factors of n,  since so this gives us our algorithm. :)div 1 D ****Here is a full solution to Codeforces #174 div 1 D.Let ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. Note the following formula for sum of arithmetic series: I claim that the pair (x, y) is cool if and only if and one of the following is true \\begin{enumerate} \\item ν2(x) + 1 = ν2(y) \\item ν2(y) = 0 \\end{enumerate} This can be proven by casework on the number on the parity of y. If y is odd, the average term of the arithmetic sequence is an integer, so f(y) = y divides f(x) and ν2(y) = 0.If y is even, the average is of the form .5·k where k is odd, so so it follows that y divides x so f(y) divides f(x),  and furthermore From this observation it follows that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1.Now that we have this observation, we can finish the problem using dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. Then the answer is just n - max (dp[1], dp[2], ..., dp[n]). div 1 E ****Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced’’ if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,So to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow. Sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b],  and the outdegree (#wins) of cow i is just (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, N]) = (Number of 1’s in range [1,i — 1]) + (N — i — (Number of 1’s in range [i + 1, N]))We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form Flip all numbers (0->1, 1->0) in a range [a, b]. Query number of 1’s in a range [a, b]. Note that the seg tree needed to handle this is the same seg tree you need for problem ‘lites’ on USACO 2008 Gold http://tjsct.wikidot.com/usaco-nov08-gold.Once again, thanks for participating!abacadaea",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7037",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3777
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces",
          "content": "Here is the editorial for Round #174. Thanks for participating. We hope you enjoyed the problems! :)Div2 AWe didn’t expect this problem to be so hard :(. This problem can be solved by brute forcing. For any x,  you can compute in O(p) time (iteratively multiply cur = (cur * i) % p, not use pow in math library!), so overall brute force will be O(p2) time.Note: there is actually algorithm.The problem was written by abacadaea.Div2 BWe first note that players who have folded do not affect our desired answer. Then, we can do casework on the number of players who are currently “IN”. If no cows are “IN”, then all the players who are “ALLIN” can show their hands. If exactly one cow is “IN”, she is the only one who can show, so the answer is 1. If two or more cows are “IN”, no one can show their hands. Then we simply count the number of cows of each type and check for each case. The total runtime is O(n).The problem was written by scott_wu.Div1 A / Div2 C Consider the problem with only queries 1 and 2. Then the problem is easy in O(n): keep track of the number of terms and the sum, and you can handle each query in O(1). But with query 3 we need to also be able to find the last term of the sequence at any given time. To do this, we keep track of the sequence di = ai + 1 - ai for i = 1, 2, ..., s - 1,  and as,  where s is the length of the sequence. Notice that query 2 only modifies one value of di,  and queries 1 and 3 are easily processed and able to update this information. This gives us an O(n) algorithm.One can also use a fenwick or segment tree to compute the last element, but it’s not nearly as nice :).The problem was written by abacadaea.Div1 B / Div2 DFirst, suppose we only have the sequence a2, a3, …an. We note that the current state is only determined by the location and the direction we are facing, so there are only 2·(n - 1) states total. Then, we can use DFS with memorization to find the distance traveled from each state, or  - 1 if a cycle is formed, in O(n) time. Now, when we add a1 into the sequence, we essentially only need to give the distance traveled starting from each state facing left. The only difference is that if we ever land on a1 again, there must be a cycle, as we started on a1. Using this, we can solve the problem in O(n) time total.The problem was written by scott_wu.Div1 C / Div2 EImagine the problem as a graph where coins are the nodes and Bessie’s statements are directed edges between coins. Because of the problem conditions, the graph must be a set of cycles and directed paths. If there are any cycles in the graph, the answer is clearly 0.Then, suppose we have a path p1, p2, …pk in the graph, where it is known that we have more coins of type p1 than of type p2, more of type p2 than of type p3,  and so on. The key observation in this problem is that this is equivalent to having k independent coins of value {a(p1), a(p1) + a(p2), a(p1) + a(p2) + a(p3), …}. The first coin in our new list represents how many more coins of type p1 than of type p2 we have, the second coin in our new list represents how many more coins of type p2 than of type p3 we have, and so on. However, we must be careful to note that we need at least one of each of the new coins except for the last one, so we can subtract their values from T before doing the DP.After creating our new set of values, we can run the DP the same way we would run a standard knapsack. This algorithm takes O(nt) time total.The problem was written by scott_wu.Div1 DLet ν2(n) denote the exponent of the largest power of 2 that divides n. For example ν2(5) = 0, ν2(96) = 5. Let f(n) denote the largest odd factor of n. We can show that for fixed ai, aj(i < j),  we can construct a cool sequence ai = bi, bi + 1, ... bj - 1, bj = aj if and only if and either ν2(ai) + j - i = ν2(aj) or ν2(aj) ≤ j - i - 1. Proof hereWith this observation, we can use dynamic programming where the kth state is the maximum number of ai (i ≤ k) we can keep so that it is possible to make a1, ... ak cool. The transition for this is O(n),  and the answer is just n - max (dp[1], dp[2], ..., dp[n]). This algorithm is O(n2). The problem was written by scott_wu.Div1 EThis will go over the basic outline for solution.We can show that the answer is where wi is the number of wins cow i appears to have. Proof hereNow sort the skill levels of the cows (the order of the si doesn’t actually matter). s1 is lowest skill. Now consider an n × n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form [a, b] × [a, b]. We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval [1,n]. The seg tree needs to handle queries of the form \\begin{enumerate} \\item Flip all numbers (0->1, 1->0) in a range [a, b]. \\item Query number of 1’s in a range [a, b]. \\end{enumerate} Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as (Number of 1’s in range [1,i — 1]) + (Number of 0’s in range [i + 1, n]). There are O(m) queries so this solution takes time.The problem was written by abacadaea.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7036",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #174 - Codeforces - Code 1",
          "code": "rgb(170, 0, 170)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 2",
          "code": "Can't process your hack, try again",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 3",
          "code": "\"Can't process your hack, try again\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 4",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 5",
          "code": "sum -= s[cnt];\ns[cnt - 1] += s[cnt]\ns[cnt] = 0;\n--cnt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 6",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 7",
          "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"199999\\n\");\n\tfor(int i=1; i<100000; i++) printf(\"2 1\\n\");\n\tfor(int i=1; i<=100000; i++) printf(\"1 99999 1\\n\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 8",
          "code": "FAIL Input can't contain chars with codes less than 32, but line 5 (1-based) contains [validator wfval.exe returns exit code 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 9",
          "code": "int sum = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 10",
          "code": "int N = 20000+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 11",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 12",
          "code": "sum -= bit.total(size - 1);\nbit.update(size, -bit.total(size));\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 13",
          "code": "bit.update(size - 1, -bit.total(size - 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 14",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #174 - Codeforces - Code 15",
          "code": "ll d = bit.total(size - 1);\nsum -= d;\nbit.update(size - 1, -d);\nbit.update(size, d);\n--size;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7027",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 1",
          "code": "We didn’t expect this problem to be so hard :(",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 2",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 3",
          "code": "wrong answer 103363rd numbers differ &mdash; expected: '-1307.3800420', found: '-1307.3840456', error = '0.0000031'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 4",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 5",
          "code": "offset[count] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 6",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 7",
          "code": "6\n2 1\n1 2 1\n3\n2 1\n1 2 1\n3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 8",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 9",
          "code": "0.500000\n1.500000\n1.000000\n1.000000\n2.000000\n2.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces #174 - Codeforces - Code 10",
          "code": "---------------------------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7036",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, n, \"q\");\n    inf.readSpace();\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    set<int> bi_set;\n    set<int> ci_set;\n\n    for (int i = 0; i < q; ++i) {\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(bi != ci, \"bi and ci should be distinct (bi=%d, ci=%d)\", bi, ci);\n\n        ensuref(bi_set.count(bi) == 0, \"All bi should be distinct (bi=%d)\", bi);\n        bi_set.insert(bi);\n\n        ensuref(ci_set.count(ci) == 0, \"All ci should be distinct (ci=%d)\", ci);\n        ci_set.insert(ci);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, n, \"q\");\n    inf.readSpace();\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    set<int> bi_set;\n    set<int> ci_set;\n\n    for (int i = 0; i < q; ++i) {\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(bi != ci, \"bi and ci should be distinct (bi=%d, ci=%d)\", bi, ci);\n\n        ensuref(bi_set.count(bi) == 0, \"All bi should be distinct (bi=%d)\", bi);\n        bi_set.insert(bi);\n\n        ensuref(ci_set.count(ci) == 0, \"All ci should be distinct (ci=%d)\", ci);\n        ci_set.insert(ci);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, n, \"q\");\n    inf.readSpace();\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    set<int> bi_set;\n    set<int> ci_set;\n\n    for (int i = 0; i < q; ++i) {\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(bi != ci, \"bi and ci should be distinct (bi=%d, ci=%d)\", bi, ci);\n\n        ensuref(bi_set.count(bi) == 0, \"All bi should be distinct (bi=%d)\", bi);\n        bi_set.insert(bi);\n\n        ensuref(ci_set.count(ci) == 0, \"All ci should be distinct (ci=%d)\", ci);\n        ci_set.insert(ci);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 0);\n    int t = opt<int>(\"t\", 100000);\n    string values_type = opt<string>(\"values_type\", \"random\");\n    string constraints_type = opt<string>(\"constraints_type\", \"random\");\n\n    vector<int> a(n);\n    // Generate a_i according to values_type\n    if (values_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    } else if (values_type == \"equal\") {\n        int val = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (values_type == \"ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (values_type == \"max\") {\n        fill(a.begin(), a.end(), 100000);\n    } else if (values_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (values_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    }\n\n    // Now generate constraints\n\n    vector<int> bi, ci;\n    if (constraints_type == \"none\" || q == 0) {\n        q = 0;\n        // No constraints\n    } else if (constraints_type == \"random\") {\n        // Generate q constraints\n        // Need to ensure that all bi are distinct, all ci are distinct, and bi != ci\n        set<int> bi_set, ci_set;\n        for (int i = 0; i < q; ++i) {\n            int b, c;\n            do {\n                b = rnd.next(1, n);\n            } while (bi_set.count(b));\n            bi_set.insert(b);\n            do {\n                c = rnd.next(1, n);\n            } while (c == b || ci_set.count(c));\n            ci_set.insert(c);\n            bi.push_back(b);\n            ci.push_back(c);\n        }\n    } else if (constraints_type == \"conflicting\") {\n        // Generate conflicting constraints to make answer 0\n        // For example, create a cycle\n        if (n < 3) {\n            // Cannot create a cycle, set q = 0\n            q = 0;\n        } else {\n            q = n;\n            for (int i = 0; i < q; ++i) {\n                int b = i + 1; // from 1 to n\n                int c = (i + 1) % n + 1; // next element, wrapping around\n                bi.push_back(b);\n                ci.push_back(c);\n            }\n        }\n    } else if (constraints_type == \"chain\") {\n        // Create a chain of constraints bi > ci\n        q = min(q, n/2);\n        set<int> used_bi, used_ci;\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < q; ++i) {\n            int b = indices[i];\n            int c = indices[i + q];\n            bi.push_back(b);\n            ci.push_back(c);\n        }\n    }\n\n    // Now output\n\n    printf(\"%d %d %d\\n\", n, q, t);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", bi[i], ci[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 0);\n    int t = opt<int>(\"t\", 100000);\n    string values_type = opt<string>(\"values_type\", \"random\");\n    string constraints_type = opt<string>(\"constraints_type\", \"random\");\n\n    vector<int> a(n);\n    // Generate a_i according to values_type\n    if (values_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    } else if (values_type == \"equal\") {\n        int val = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (values_type == \"ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (values_type == \"max\") {\n        fill(a.begin(), a.end(), 100000);\n    } else if (values_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (values_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    }\n\n    // Now generate constraints\n\n    vector<int> bi, ci;\n    if (constraints_type == \"none\" || q == 0) {\n        q = 0;\n        // No constraints\n    } else if (constraints_type == \"random\") {\n        // Generate q constraints\n        // Need to ensure that all bi are distinct, all ci are distinct, and bi != ci\n        set<int> bi_set, ci_set;\n        for (int i = 0; i < q; ++i) {\n            int b, c;\n            do {\n                b = rnd.next(1, n);\n            } while (bi_set.count(b));\n            bi_set.insert(b);\n            do {\n                c = rnd.next(1, n);\n            } while (c == b || ci_set.count(c));\n            ci_set.insert(c);\n            bi.push_back(b);\n            ci.push_back(c);\n        }\n    } else if (constraints_type == \"conflicting\") {\n        // Generate conflicting constraints to make answer 0\n        // For example, create a cycle\n        if (n < 3) {\n            // Cannot create a cycle, set q = 0\n            q = 0;\n        } else {\n            q = n;\n            for (int i = 0; i < q; ++i) {\n                int b = i + 1; // from 1 to n\n                int c = (i + 1) % n + 1; // next element, wrapping around\n                bi.push_back(b);\n                ci.push_back(c);\n            }\n        }\n    } else if (constraints_type == \"chain\") {\n        // Create a chain of constraints bi > ci\n        q = min(q, n/2);\n        set<int> used_bi, used_ci;\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < q; ++i) {\n            int b = indices[i];\n            int c = indices[i + q];\n            bi.push_back(b);\n            ci.push_back(c);\n        }\n    }\n\n    // Now output\n\n    printf(\"%d %d %d\\n\", n, q, t);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", bi[i], ci[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -q 0 -t 10 -values_type random -constraints_type none\n./gen -n 10 -t 100 -values_type ones -constraints_type random -q 5\n./gen -n 300 -t 100000 -values_type max -constraints_type none\n./gen -n 100 -q 50 -t 100000 -values_type equal -constraints_type random\n./gen -n 200 -q 100 -t 50000 -values_type increasing -constraints_type chain\n./gen -n 300 -q 0 -t 1 -values_type ones -constraints_type none\n./gen -n 300 -q 300 -t 100000 -values_type random -constraints_type conflicting\n./gen -n 50 -q 25 -t 100 -values_type decreasing -constraints_type random\n./gen -n 100 -q 0 -t 100000 -values_type decreasing -constraints_type none\n./gen -n 150 -q 75 -t 75000 -values_type increasing -constraints_type chain\n./gen -n 3 -q 3 -t 6 -values_type ones -constraints_type conflicting\n./gen -n 2 -q 1 -t 2 -values_type ones -constraints_type conflicting\n./gen -n 300 -q 150 -t 100000 -values_type random -constraints_type random\n./gen -n 3 -q 2 -t 6 -values_type ones -constraints_type random\n./gen -n 10 -q 5 -t 10 -values_type equal -constraints_type random\n./gen -n 100 -q 100 -t 10000 -values_type random -constraints_type conflicting\n./gen -n 300 -q 0 -t 100000 -values_type random -constraints_type none\n./gen -n 300 -q 10 -t 100000 -values_type random -constraints_type chain\n./gen -n 300 -q 299 -t 100000 -values_type random -constraints_type chain\n./gen -n 300 -q 0 -t 1 -values_type ones -constraints_type none\n./gen -n 300 -q 150 -t 50000 -values_type decreasing -constraints_type random\n./gen -n 300 -q 300 -t 100000 -values_type random -constraints_type conflicting\n./gen -n 300 -q 150 -t 100000 -values_type random -constraints_type chain\n./gen -n 2 -q 1 -t 100000 -values_type max -constraints_type chain\n./gen -n 5 -q 2 -t 5 -values_type ones -constraints_type random\n./gen -n 100 -q 50 -t 1000 -values_type random -constraints_type random\n./gen -n 100 -q 50 -t 100000 -values_type equal -constraints_type random\n./gen -n 100 -q 0 -t 100000 -values_type max -constraints_type none\n./gen -n 100 -q 50 -t 1 -values_type ones -constraints_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:10.756380",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "285/A",
      "title": "A. Slightly Decreasing Permutations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two space-separated integers: n, k (1 ≤ n ≤ 105, 0 ≤ k < n) — the permutation length and the decreasing coefficient.",
      "output_spec": "OutputIn a single line print n space-separated integers: p1, p2, ..., pn — the permutation of length n with decreasing coefficient k. If there are several permutations that meet this condition, print any of them. It is guaranteed that the permutation with the sought parameters exists.",
      "sample_tests": "ExamplesInputCopy5 2OutputCopy1 5 2 4 3InputCopy3 0OutputCopy1 2 3InputCopy3 2OutputCopy3 2 1",
      "description": "A. Slightly Decreasing Permutations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains two space-separated integers: n, k (1 ≤ n ≤ 105, 0 ≤ k < n) — the permutation length and the decreasing coefficient.\n\nOutputIn a single line print n space-separated integers: p1, p2, ..., pn — the permutation of length n with decreasing coefficient k. If there are several permutations that meet this condition, print any of them. It is guaranteed that the permutation with the sought parameters exists.\n\nInputCopy5 2OutputCopy1 5 2 4 3InputCopy3 0OutputCopy1 2 3InputCopy3 2OutputCopy3 2 1\n\nInputCopy5 2\n\nOutputCopy1 5 2 4 3\n\nInputCopy3 0\n\nOutputCopy1 2 3\n\nInputCopy3 2\n\nOutputCopy3 2 1",
      "solutions": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces",
          "content": "Good day, friends)Welcome to regular Codeforces round #175 for Div.2 participants. Traditionally Div.1 participants can take part out of the competition.The problems were again prepared by the group of authors: Pavel Kholkin (HolkinPV), Artem Rakhov (RAD), Fefer Ivan (Fefer_Ivan) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.Score distribution is published in advance) today it is standard: 500, 1000, 1500, 2000, 2500.We open the little secret of this competition, in all today's problems you find permutations)We wish everyone good luck, successful hacks, high rating and good mood)UPD1: the contest is over, hope you enjoy it)UPD2: the tutorial is already published here)UPD3: congratulations to winners:1) hechuan2) TroyI1183) BekzhanKassenov4) ahmed_aly5) lxgsbqylbk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 905
        },
        {
          "title": "Round #175 Problem E idea - Codeforces",
          "content": "It seems that some people haven't got the idea of this problem 285E - Positions in Permutations while the tutorial is still incomplete so I'd like to write some explanations about it.A common approach for this kind of problem is DP. What we do here is to choose numbers for the good positions first, then fill the others later on. Let f(i, j, k) is the number of ways to choose j good positions in the first i-th position and k is a 2-bit number that represents whether number i and number i + 1 is already used or not. The DP transition is quite simple.Let F(j) is the number of permutations with j good positions, then F(j) = Σ(f(n, j, k)) * (n - j)! (because there are n — j numbers left unchosen). However, there are cases we may form some extra good positions when putting these n — j numbers into our permutations, thus F(j) now stores the number of permutations with at least j good positions. But we want F(j) to be the number of permutations with exact j good positions, so we must exclude those permutations with more than j good positions.Let's do it in descending order. First F(n) must be the number of permutations with exact n good positions. Hence, we may calculate F(n - 1) based on F(n), then F(n - 2) based on F(n - 1) and F(n), and so on... The last part is to calculate how many times F(j) is repeatedly counted in F(i) (i < j), it's simply C(j, i) (the number of ways to choose i good positions from j good positions).The overall complexity is O(n^2).Please refer to my submission 3376355 for an implementation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 285 和字母"
          },
          "content_length": 1533
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces",
          "content": "285A - Slightly Decreasing PermutationsAs the answer you can print such permutation: n, n - 1, ..., n - k + 1, 1, 2, ..., n - k. For example, if n = 5, k = 2, then the answer is: 5, 4, 1, 2, 3. If k = 0, you should print 1, 2, ..., n. Such solution can be written in two loops.285B - Find MarbleIt is known that a permutation can be considered as set of cycles. The integer i moves to p[i] for all i (1 ≤ i ≤ n). You can start moving from integer s along the cycle. If you find integer t, then print the length of the path. If you return to s, then print  - 1.285C - Building PermutationThe solution of the problem is rather simple. Sort all integers a and then make from integer a[1] integer 1, from integer a[2] integer 2 and so on. So, integer a[i] adds to the answer the value |a[i] - i|. The answer should be count in 64-bit type. You can simply guess why such solution is correct.285D - Permutation SumFor a start, describe bruteforce solution. Firstly, we will always assume, that a is identity permutation, that is a[i] = i. In this case, the answer should be multiplied by n!. Or in other way your bruteforce will not be counted. Secondly, using our bruteforce we can see, that for even n the answer is 0.What do you also need to get accepted? First case is to calculate answers for all n on your computer and write them in constant array. In other words you can make precalc. Second case is to make you solution faster. The soltuion using meet-in-the-middle idea works fast for n ≤ 15. If you remember that for even n answer is 0 then you can get accepted using such solution. But other simple bruteforces and dynamic programmings on maps work slower than 3 seconds.285E - Positions in Permutations",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7093",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 285\\s*A"
          },
          "content_length": 1708
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 1",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 2",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 1",
          "code": "F(j) = Σ(f(n, j, k)) * (n - j)!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 2",
          "code": "F(j) — F(j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 1",
          "code": "res[i] ~ R[n][i][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 2",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 3",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 4",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 5",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read n and k from the input file\n    int n = inf.readInt();\n    int k = inf.readInt();\n\n    // Read n integers from the contestant's output\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        p[i] = ouf.readInt(1, n, format(\"p[%d]\", i + 1).c_str());\n    }\n\n    // Check for duplicates and ensure it's a valid permutation\n    vector<bool> used(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        if (used[pi]) {\n            quitf(_wa, \"Duplicate number %d found at position %d\", pi, i + 1);\n        }\n        used[pi] = true;\n    }\n\n    // Compute the decreasing coefficient\n    int dec_coef = 0;\n    for (int i = 0; i < n - 1; ++i) {\n        if (p[i] > p[i + 1]) {\n            ++dec_coef;\n        }\n    }\n\n    // Check if the decreasing coefficient matches the required k\n    if (dec_coef != k) {\n        quitf(_wa, \"Expected decreasing coefficient %d, found %d\", k, dec_coef);\n    }\n\n    // Ensure there is no extra output\n    if (!ouf.seekEof()) {\n        quitf(_wa, \"Extra output found after reading %d numbers\", n);\n    }\n\n    // All checks passed\n    quitf(_ok, \"Found decreasing coefficient %d\", dec_coef);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"\");\n\n    int k = -1;\n\n    if (type == \"min_k\") {\n        k = 0;\n    } else if (type == \"max_k\") {\n        k = n - 1;\n    } else if (type == \"half_k\") {\n        k = n / 2;\n    } else if (type == \"random\") {\n        k = rnd.next(0, n - 1);\n    } else if (type == \"k_is_one\") {\n        if (n >= 2) {\n            k = 1;\n        } else {\n            k = 0;\n        }\n    } else if (type == \"k_is_n_minus_two\") {\n        if (n >= 2) {\n            k = n - 2;\n        } else {\n            k = 0;\n        }\n    } else {\n        k = opt<int>(\"k\", -1);\n        if (k == -1) {\n            fprintf(stderr, \"Error: Parameter 'k' must be provided unless type is specified.\\n\");\n            return 1;\n        }\n    }\n\n    // Ensure k is in the valid range\n    if (!(0 <= k && k < n)) {\n        fprintf(stderr, \"Error: k must satisfy 0 <= k < n.\\n\");\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"\");\n\n    int k = -1;\n\n    if (type == \"min_k\") {\n        k = 0;\n    } else if (type == \"max_k\") {\n        k = n - 1;\n    } else if (type == \"half_k\") {\n        k = n / 2;\n    } else if (type == \"random\") {\n        k = rnd.next(0, n - 1);\n    } else if (type == \"k_is_one\") {\n        if (n >= 2) {\n            k = 1;\n        } else {\n            k = 0;\n        }\n    } else if (type == \"k_is_n_minus_two\") {\n        if (n >= 2) {\n            k = n - 2;\n        } else {\n            k = 0;\n        }\n    } else {\n        k = opt<int>(\"k\", -1);\n        if (k == -1) {\n            fprintf(stderr, \"Error: Parameter 'k' must be provided unless type is specified.\\n\");\n            return 1;\n        }\n    }\n\n    // Ensure k is in the valid range\n    if (!(0 <= k && k < n)) {\n        fprintf(stderr, \"Error: k must satisfy 0 <= k < n.\\n\");\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n (n=1), k=0\n./gen -n 1 -k 0\n\n# n=1, test with 'type' min_k\n./gen -n 1 -type min_k\n\n# n=1, test with 'type' max_k (should be k=0)\n./gen -n 1 -type max_k\n\n# n=2, k=0\n./gen -n 2 -k 0\n\n# n=2, k=1\n./gen -n 2 -k 1\n\n# n=3, k=0\n./gen -n 3 -k 0\n\n# n=3, k=1\n./gen -n 3 -k 1\n\n# n=3, k=2\n./gen -n 3 -k 2\n\n# n=10, k=0\n./gen -n 10 -k 0\n\n# n=10, k=9\n./gen -n 10 -k 9\n\n# n=100, type random\n./gen -n 100 -type random\n\n# n=1000, type half_k\n./gen -n 1000 -type half_k\n\n# n=10000, type min_k\n./gen -n 10000 -type min_k\n\n# n=10000, type max_k\n./gen -n 10000 -type max_k\n\n# n=50000, k=25000\n./gen -n 50000 -k 25000\n\n# n=50000, k=24999\n./gen -n 50000 -k 24999\n\n# n=99999, type random\n./gen -n 99999 -type random\n\n# n=100000, type min_k\n./gen -n 100000 -type min_k\n\n# n=100000, type max_k\n./gen -n 100000 -type max_k\n\n# n=100000, k=1\n./gen -n 100000 -k 1\n\n# n=100000, type half_k\n./gen -n 100000 -type half_k\n\n# n=100000, k=50000\n./gen -n 100000 -k 50000\n\n# n=99991 (prime number), k=12345\n./gen -n 99991 -k 12345\n\n# n=65536 (power of two), k=32768\n./gen -n 65536 -k 32768\n\n# n=100000, type random\n./gen -n 100000 -type random\n\n# n=100000, k=50000\n./gen -n 100000 -k 50000\n\n# n=100000, type k_is_n_minus_two\n./gen -n 100000 -type k_is_n_minus_two\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:12.898429",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "285/B",
      "title": "B. Find Marble",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers: n, s, t (1 ≤ n ≤ 105; 1 ≤ s, t ≤ n) — the number of glasses, the ball's initial and final position. The second line contains n space-separated integers: p1, p2, ..., pn (1 ≤ pi ≤ n) — the shuffling operation parameters. It is guaranteed that all pi's are distinct.Note that s can equal t.",
      "output_spec": "OutputIf the marble can move from position s to position t, then print on a single line a non-negative integer — the minimum number of shuffling operations, needed to get the marble to position t. If it is impossible, print number -1.",
      "sample_tests": "ExamplesInputCopy4 2 12 3 4 1OutputCopy3InputCopy4 3 34 1 3 2OutputCopy0InputCopy4 3 41 2 3 4OutputCopy-1InputCopy3 1 32 1 3OutputCopy-1",
      "description": "B. Find Marble\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers: n, s, t (1 ≤ n ≤ 105; 1 ≤ s, t ≤ n) — the number of glasses, the ball's initial and final position. The second line contains n space-separated integers: p1, p2, ..., pn (1 ≤ pi ≤ n) — the shuffling operation parameters. It is guaranteed that all pi's are distinct.Note that s can equal t.\n\nOutputIf the marble can move from position s to position t, then print on a single line a non-negative integer — the minimum number of shuffling operations, needed to get the marble to position t. If it is impossible, print number -1.\n\nInputCopy4 2 12 3 4 1OutputCopy3InputCopy4 3 34 1 3 2OutputCopy0InputCopy4 3 41 2 3 4OutputCopy-1InputCopy3 1 32 1 3OutputCopy-1\n\nInputCopy4 2 12 3 4 1\n\nOutputCopy3\n\nInputCopy4 3 34 1 3 2\n\nOutputCopy0\n\nInputCopy4 3 41 2 3 4\n\nOutputCopy-1\n\nInputCopy3 1 32 1 3\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces",
          "content": "Good day, friends)Welcome to regular Codeforces round #175 for Div.2 participants. Traditionally Div.1 participants can take part out of the competition.The problems were again prepared by the group of authors: Pavel Kholkin (HolkinPV), Artem Rakhov (RAD), Fefer Ivan (Fefer_Ivan) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.Score distribution is published in advance) today it is standard: 500, 1000, 1500, 2000, 2500.We open the little secret of this competition, in all today's problems you find permutations)We wish everyone good luck, successful hacks, high rating and good mood)UPD1: the contest is over, hope you enjoy it)UPD2: the tutorial is already published here)UPD3: congratulations to winners:1) hechuan2) TroyI1183) BekzhanKassenov4) ahmed_aly5) lxgsbqylbk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 905
        },
        {
          "title": "Round #175 Problem E idea - Codeforces",
          "content": "It seems that some people haven't got the idea of this problem 285E - Positions in Permutations while the tutorial is still incomplete so I'd like to write some explanations about it.A common approach for this kind of problem is DP. What we do here is to choose numbers for the good positions first, then fill the others later on. Let f(i, j, k) is the number of ways to choose j good positions in the first i-th position and k is a 2-bit number that represents whether number i and number i + 1 is already used or not. The DP transition is quite simple.Let F(j) is the number of permutations with j good positions, then F(j) = Σ(f(n, j, k)) * (n - j)! (because there are n — j numbers left unchosen). However, there are cases we may form some extra good positions when putting these n — j numbers into our permutations, thus F(j) now stores the number of permutations with at least j good positions. But we want F(j) to be the number of permutations with exact j good positions, so we must exclude those permutations with more than j good positions.Let's do it in descending order. First F(n) must be the number of permutations with exact n good positions. Hence, we may calculate F(n - 1) based on F(n), then F(n - 2) based on F(n - 1) and F(n), and so on... The last part is to calculate how many times F(j) is repeatedly counted in F(i) (i < j), it's simply C(j, i) (the number of ways to choose i good positions from j good positions).The overall complexity is O(n^2).Please refer to my submission 3376355 for an implementation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 285 和字母"
          },
          "content_length": 1533
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces",
          "content": "285A - Slightly Decreasing PermutationsAs the answer you can print such permutation: n, n - 1, ..., n - k + 1, 1, 2, ..., n - k. For example, if n = 5, k = 2, then the answer is: 5, 4, 1, 2, 3. If k = 0, you should print 1, 2, ..., n. Such solution can be written in two loops.285B - Find MarbleIt is known that a permutation can be considered as set of cycles. The integer i moves to p[i] for all i (1 ≤ i ≤ n). You can start moving from integer s along the cycle. If you find integer t, then print the length of the path. If you return to s, then print  - 1.285C - Building PermutationThe solution of the problem is rather simple. Sort all integers a and then make from integer a[1] integer 1, from integer a[2] integer 2 and so on. So, integer a[i] adds to the answer the value |a[i] - i|. The answer should be count in 64-bit type. You can simply guess why such solution is correct.285D - Permutation SumFor a start, describe bruteforce solution. Firstly, we will always assume, that a is identity permutation, that is a[i] = i. In this case, the answer should be multiplied by n!. Or in other way your bruteforce will not be counted. Secondly, using our bruteforce we can see, that for even n the answer is 0.What do you also need to get accepted? First case is to calculate answers for all n on your computer and write them in constant array. In other words you can make precalc. Second case is to make you solution faster. The soltuion using meet-in-the-middle idea works fast for n ≤ 15. If you remember that for even n answer is 0 then you can get accepted using such solution. But other simple bruteforces and dynamic programmings on maps work slower than 3 seconds.285E - Positions in Permutations",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7093",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 285\\s*B"
          },
          "content_length": 1708
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 1",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 2",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 1",
          "code": "F(j) = Σ(f(n, j, k)) * (n - j)!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 2",
          "code": "F(j) — F(j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 1",
          "code": "res[i] ~ R[n][i][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 2",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 3",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 4",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 5",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> ps(p.begin(), p.end());\n    ensuref(int(ps.size()) == n, \"All p_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> ps(p.begin(), p.end());\n    ensuref(int(ps.size()) == n, \"All p_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> ps(p.begin(), p.end());\n    ensuref(int(ps.size()) == n, \"All p_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"identity\") {\n        // Permutation p[i] = i + 1\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    }\n    else if (type == \"reverse\") {\n        // Permutation p[i] = n - i\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    }\n    else if (type == \"single_cycle\") {\n        // Permutation forms a single cycle: p[i] = (i + 1) % n + 1\n        for (int i = 0; i < n; ++i)\n            p[i] = (i + 1) % n + 1;\n    }\n    else if (type == \"small_cycles\") {\n        // Permutation consists of small cycles of length k\n        int k = opt<int>(\"k\", 2); // default cycle length is 2\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1; // 1-based indexing\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < n; i += k) {\n            int cycle_size = min(k, n - i);\n            for (int j = 0; j < cycle_size; ++j) {\n                p[indices[i + j] - 1] = indices[i + (j + 1) % cycle_size];\n            }\n        }\n    }\n    else if (type == \"random\") {\n        // Random permutation\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n    else {\n        // Default: random permutation\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n, s, t\n    printf(\"%d %d %d\\n\", n, s, t);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"identity\") {\n        // Permutation p[i] = i + 1\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    }\n    else if (type == \"reverse\") {\n        // Permutation p[i] = n - i\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    }\n    else if (type == \"single_cycle\") {\n        // Permutation forms a single cycle: p[i] = (i + 1) % n + 1\n        for (int i = 0; i < n; ++i)\n            p[i] = (i + 1) % n + 1;\n    }\n    else if (type == \"small_cycles\") {\n        // Permutation consists of small cycles of length k\n        int k = opt<int>(\"k\", 2); // default cycle length is 2\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1; // 1-based indexing\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < n; i += k) {\n            int cycle_size = min(k, n - i);\n            for (int j = 0; j < cycle_size; ++j) {\n                p[indices[i + j] - 1] = indices[i + (j + 1) % cycle_size];\n            }\n        }\n    }\n    else if (type == \"random\") {\n        // Random permutation\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n    else {\n        // Default: random permutation\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n, s, t\n    printf(\"%d %d %d\\n\", n, s, t);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Smallest n, s = t\n./gen -n 1 -s 1 -t 1 -type identity\n\n# Test case 2: Small n, s != t, impossible to reach\n./gen -n 2 -s 1 -t 2 -type identity\n\n# Test case 3: Small n, s != t, possible to reach in 1 step\n./gen -n 2 -s 1 -t 2 -type single_cycle\n\n# Test case 4: n = 5, s and t in the same cycle\n./gen -n 5 -s 2 -t 4 -type single_cycle\n\n# Test case 5: n = 5, s and t in different cycles\n./gen -n 5 -s 2 -t 5 -type small_cycles -k 2\n\n# Test case 6: n = 10, s and t in the same cycle\n./gen -n 10 -s 3 -t 7 -type small_cycles -k 5\n\n# Test case 7: n = 10, s = t, random permutation\n./gen -n 10 -s 4 -t 4 -type random\n\n# Test case 8: n = 1000, s and t random, random permutation\n./gen -n 1000 -s 123 -t 456 -type random\n\n# Test case 9: n = 1000, s and t random, random permutation\n./gen -n 1000 -s 789 -t 10 -type random\n\n# Test case 10: n = 1000, s and t in different cycles\n./gen -n 1000 -s 1 -t 1000 -type small_cycles -k 2\n\n# Test case 11: n = 100000, s = 1, t = n, single cycle\n./gen -n 100000 -s 1 -t 100000 -type single_cycle\n\n# Test case 12: n = 100000, s and t in the same cycle\n./gen -n 100000 -s 50000 -t 75000 -type single_cycle\n\n# Test case 13: n = 100000, s and t in different cycles\n./gen -n 100000 -s 1 -t 3 -type small_cycles -k 2\n\n# Test case 14: n = 100000, s = t, identity permutation\n./gen -n 100000 -s 2021 -t 2021 -type identity\n\n# Test case 15: n = 100000, s != t, impossible to reach\n./gen -n 100000 -s 2021 -t 2022 -type identity\n\n# Test case 16: n = 100000, s and t random, reverse permutation\n./gen -n 100000 -s 12345 -t 87654 -type reverse\n\n# Test case 17: n = 100000, s and t random, random permutation\n./gen -n 100000 -s 50000 -t 50000 -type random\n\n# Test case 18: n = 100000, s and t random, random permutation\n./gen -n 100000 -s 40000 -t 60000 -type random\n\n# Test case 19: n = 100000, s and t in different cycles, impossible\n./gen -n 100000 -s 1 -t 100000 -type small_cycles -k 2\n\n# Test case 20: n = 99999, s and t in different cycles due to odd n\n./gen -n 99999 -s 1 -t 99999 -type small_cycles -k 2\n\n# Test case 21: n = 100000, s and t in the same position after cycles\n./gen -n 100000 -s 1 -t 1 -type single_cycle\n\n# Test case 22: n = 100000, s != t, both are fixed points\n./gen -n 100000 -s 50000 -t 50001 -type identity\n\n# Test case 23: n = 100000, s != t, cycles of length 3\n./gen -n 100000 -s 1 -t 4 -type small_cycles -k 3\n\n# Test case 24: n = 100000, s and t random, random permutation\n./gen -n 100000 -s 12345 -t 67890 -type random\n\n# Test case 25: n = 100000, s and t unreachable (impossible)\n./gen -n 100000 -s 10000 -t 20000 -type identity\n\n# Test case 26: n = 100000, s and t in reverse positions\n./gen -n 100000 -s 1 -t 100000 -type reverse\n\n# Test case 27: n = 100000, s = t, random permutation\n./gen -n 100000 -s 55555 -t 55555 -type random\n\n# Test case 28: n = 50000, s and t in adjacent positions\n./gen -n 50000 -s 25000 -t 25001 -type small_cycles -k 2\n\n# Test case 29: n = 1, s = t = 1, single cycle\n./gen -n 1 -s 1 -t 1 -type single_cycle\n\n# Test case 30: n = 2, s = 1, t = 2, reverse permutation\n./gen -n 2 -s 1 -t 2 -type reverse\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:15.211671",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "285/C",
      "title": "C. Building Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 3·105) — the size of the sought permutation. The second line contains n integers a1, a2, ..., an ( - 109 ≤ ai ≤ 109).",
      "output_spec": "OutputPrint a single number — the minimum number of moves.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy23 0OutputCopy2InputCopy3-1 -1 2OutputCopy6",
      "description": "C. Building Permutation\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 3·105) — the size of the sought permutation. The second line contains n integers a1, a2, ..., an ( - 109 ≤ ai ≤ 109).\n\nOutputPrint a single number — the minimum number of moves.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy23 0OutputCopy2InputCopy3-1 -1 2OutputCopy6\n\nInputCopy23 0\n\nOutputCopy2\n\nInputCopy3-1 -1 2\n\nOutputCopy6\n\nNoteIn the first sample you should decrease the first number by one and then increase the second number by one. The resulting permutation is (2, 1).In the second sample you need 6 moves to build permutation (1, 3, 2).",
      "solutions": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces",
          "content": "Good day, friends)Welcome to regular Codeforces round #175 for Div.2 participants. Traditionally Div.1 participants can take part out of the competition.The problems were again prepared by the group of authors: Pavel Kholkin (HolkinPV), Artem Rakhov (RAD), Fefer Ivan (Fefer_Ivan) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.Score distribution is published in advance) today it is standard: 500, 1000, 1500, 2000, 2500.We open the little secret of this competition, in all today's problems you find permutations)We wish everyone good luck, successful hacks, high rating and good mood)UPD1: the contest is over, hope you enjoy it)UPD2: the tutorial is already published here)UPD3: congratulations to winners:1) hechuan2) TroyI1183) BekzhanKassenov4) ahmed_aly5) lxgsbqylbk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 905
        },
        {
          "title": "Round #175 Problem E idea - Codeforces",
          "content": "It seems that some people haven't got the idea of this problem 285E - Positions in Permutations while the tutorial is still incomplete so I'd like to write some explanations about it.A common approach for this kind of problem is DP. What we do here is to choose numbers for the good positions first, then fill the others later on. Let f(i, j, k) is the number of ways to choose j good positions in the first i-th position and k is a 2-bit number that represents whether number i and number i + 1 is already used or not. The DP transition is quite simple.Let F(j) is the number of permutations with j good positions, then F(j) = Σ(f(n, j, k)) * (n - j)! (because there are n — j numbers left unchosen). However, there are cases we may form some extra good positions when putting these n — j numbers into our permutations, thus F(j) now stores the number of permutations with at least j good positions. But we want F(j) to be the number of permutations with exact j good positions, so we must exclude those permutations with more than j good positions.Let's do it in descending order. First F(n) must be the number of permutations with exact n good positions. Hence, we may calculate F(n - 1) based on F(n), then F(n - 2) based on F(n - 1) and F(n), and so on... The last part is to calculate how many times F(j) is repeatedly counted in F(i) (i < j), it's simply C(j, i) (the number of ways to choose i good positions from j good positions).The overall complexity is O(n^2).Please refer to my submission 3376355 for an implementation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 285 和字母"
          },
          "content_length": 1533
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces",
          "content": "285A - Slightly Decreasing PermutationsAs the answer you can print such permutation: n, n - 1, ..., n - k + 1, 1, 2, ..., n - k. For example, if n = 5, k = 2, then the answer is: 5, 4, 1, 2, 3. If k = 0, you should print 1, 2, ..., n. Such solution can be written in two loops.285B - Find MarbleIt is known that a permutation can be considered as set of cycles. The integer i moves to p[i] for all i (1 ≤ i ≤ n). You can start moving from integer s along the cycle. If you find integer t, then print the length of the path. If you return to s, then print  - 1.285C - Building PermutationThe solution of the problem is rather simple. Sort all integers a and then make from integer a[1] integer 1, from integer a[2] integer 2 and so on. So, integer a[i] adds to the answer the value |a[i] - i|. The answer should be count in 64-bit type. You can simply guess why such solution is correct.285D - Permutation SumFor a start, describe bruteforce solution. Firstly, we will always assume, that a is identity permutation, that is a[i] = i. In this case, the answer should be multiplied by n!. Or in other way your bruteforce will not be counted. Secondly, using our bruteforce we can see, that for even n the answer is 0.What do you also need to get accepted? First case is to calculate answers for all n on your computer and write them in constant array. In other words you can make precalc. Second case is to make you solution faster. The soltuion using meet-in-the-middle idea works fast for n ≤ 15. If you remember that for even n answer is 0 then you can get accepted using such solution. But other simple bruteforces and dynamic programmings on maps work slower than 3 seconds.285E - Positions in Permutations",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7093",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 285\\s*C"
          },
          "content_length": 1708
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 1",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 2",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 1",
          "code": "F(j) = Σ(f(n, j, k)) * (n - j)!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 2",
          "code": "F(j) — F(j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 1",
          "code": "res[i] ~ R[n][i][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 2",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 3",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 4",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Tutorial - Codeforces - Code 5",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"negative_max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = -1000000000;\n    } else if (type == \"positive_max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000000;\n    } else if (type == \"permutation\") {\n        a.resize(n);\n        iota(a.begin(), a.end(), 1);\n        shuffle(a.begin(), a.end());\n    } else if (type == \"reverse\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"constant\") {\n        int val = opt<int>(\"val\", 0);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"duplicates\") {\n        int num_unique = rnd.next(1, min(n, 10)); // Up to 10 unique numbers\n        vector<int> unique_vals(num_unique);\n        for (int i = 0; i < num_unique; ++i)\n            unique_vals[i] = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = unique_vals[rnd.next(0, num_unique - 1)];\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n    \n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"negative_max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = -1000000000;\n    } else if (type == \"positive_max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000000;\n    } else if (type == \"permutation\") {\n        a.resize(n);\n        iota(a.begin(), a.end(), 1);\n        shuffle(a.begin(), a.end());\n    } else if (type == \"reverse\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"constant\") {\n        int val = opt<int>(\"val\", 0);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"duplicates\") {\n        int num_unique = rnd.next(1, min(n, 10)); // Up to 10 unique numbers\n        vector<int> unique_vals(num_unique);\n        for (int i = 0; i < num_unique; ++i)\n            unique_vals[i] = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = unique_vals[rnd.next(0, num_unique - 1)];\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n    \n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type permutation\n./gen -n 1 -type random\n./gen -n 2 -type zeros\n./gen -n 2 -type reverse\n./gen -n 2 -type random\n./gen -n 3 -type negative_max\n./gen -n 3 -type positive_max\n./gen -n 3 -type duplicates\n./gen -n 5 -type ascending\n./gen -n 5 -type reverse\n./gen -n 5 -type constant -val 100\n./gen -n 10 -type random\n./gen -n 10 -type duplicates\n./gen -n 1000 -type zeros\n./gen -n 1000 -type permutation\n./gen -n 1000 -type reverse\n./gen -n 1000 -type ascending\n./gen -n 1000 -type random\n./gen -n 1000 -type duplicates\n./gen -n 1000 -type negative_max\n./gen -n 1000 -type positive_max\n./gen -n 100000 -type zeros\n./gen -n 100000 -type negative_max\n./gen -n 100000 -type positive_max\n./gen -n 100000 -type duplicates\n./gen -n 100000 -type permutation\n./gen -n 100000 -type reverse\n./gen -n 100000 -type ascending\n./gen -n 100000 -type random\n./gen -n 300000 -type zeros\n./gen -n 300000 -type negative_max\n./gen -n 300000 -type positive_max\n./gen -n 300000 -type duplicates\n./gen -n 300000 -type permutation\n./gen -n 300000 -type reverse\n./gen -n 300000 -type ascending\n./gen -n 300000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:17.358260",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "285/D",
      "title": "D. Сумма перестановок",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке находится целое число n (1 ≤ n ≤ 16).",
      "output_spec": "Выходные данныеВ единственной строке выведите целое неотрицательное число — количество таких пар перестановок a и b, что существует перестановка c, которая является суммой a и b, по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать3Выходные данныеСкопировать18Входные данныеСкопировать5Выходные данныеСкопировать1800",
      "description": "D. Сумма перестановок\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке находится целое число n (1 ≤ n ≤ 16).\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите целое неотрицательное число — количество таких пар перестановок a и b, что существует перестановка c, которая является суммой a и b, по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать3Выходные данныеСкопировать18Входные данныеСкопировать5Выходные данныеСкопировать1800\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать18\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1800\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, друзья)Приглашаем вас на очередной раунд Codeforces #175 для участников Div. 2. Как обычно, участники Div. 1 могут поучаствовать в этом соревновании вне конкурса.Задачи для вас вновь готовила группа авторов в следующем составе: Павел Холкин (HolkinPV), Артем Рахов (RAD), Фефер Иван (Fefer_Ivan) и Геральд Агапов (Gerald). Как всегда благодарим Михаила Мирзаянова (MikeMirzayanov) за системы Codeforces и Polygon, а также Марию Белову (Delinur), которая перевела условия задач. Распределением баллов публикуем заранее) cегодня оно будет стандартным: 500, 1000, 1500, 2000, 2500.Откроем небольшой секрет этого соревнования, сегодня во всех задачах вы столкнетесь с перестановками)Надеемся, что соревнование окажется для вас удачным, желаем всем высокого рейтинга, успешных взломов и хорошего настроения)UPD1: соревнование завершилось, надеемся оно вам понравилось)UPD2: разбор задач уже можно найти здесь)UPD3: поздравляем победителей:1) hechuan2) TroyI1183) BekzhanKassenov4) ahmed_aly5) lxgsbqylbk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1021
        },
        {
          "title": "Round #175 Problem E idea - Codeforces",
          "content": "It seems that some people haven't got the idea of this problem 285E - Positions in Permutations while the tutorial is still incomplete so I'd like to write some explanations about it.A common approach for this kind of problem is DP. What we do here is to choose numbers for the good positions first, then fill the others later on. Let f(i, j, k) is the number of ways to choose j good positions in the first i-th position and k is a 2-bit number that represents whether number i and number i + 1 is already used or not. The DP transition is quite simple.Let F(j) is the number of permutations with j good positions, then F(j) = Σ(f(n, j, k)) * (n - j)! (because there are n — j numbers left unchosen). However, there are cases we may form some extra good positions when putting these n — j numbers into our permutations, thus F(j) now stores the number of permutations with at least j good positions. But we want F(j) to be the number of permutations with exact j good positions, so we must exclude those permutations with more than j good positions.Let's do it in descending order. First F(n) must be the number of permutations with exact n good positions. Hence, we may calculate F(n - 1) based on F(n), then F(n - 2) based on F(n - 1) and F(n), and so on... The last part is to calculate how many times F(j) is repeatedly counted in F(i) (i < j), it's simply C(j, i) (the number of ways to choose i good positions from j good positions).The overall complexity is O(n^2).Please refer to my submission 3376355 for an implementation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 285 和字母"
          },
          "content_length": 1533
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces",
          "content": "285A - Немного убывающие перестановкиВ качестве ответа можно было предложить такую перестановку: n, n - 1, ..., n - k + 1, 1, 2, ..., n - k. Например, если n = 5, k = 2, то ответ: 5, 4, 1, 2, 3. Если k = 0, нужно вывести 1, 2, ..., n. Такое решение можно написать в два цикла.285B - Найди шарикИзвестно, что перестановку можно представить в виде множества циклов. Число i переходит в число p[i] для всех i (1 ≤ i ≤ n). Можно было начать двигаться из стартового числа s по циклу до тех пор, пока мы не дойдем до конечного числа t, либо же не вернемся назад в s. Если мы вернулись в начало, нужно вывести  - 1, иначе вывести длину пути.285C - Получаем перестановкуУ этой задачи решение очень простое. Нужно отсортировать последовательность a, а затем первое число свести к числу 1, второе к числу 2, и так далее. Число a[i] добавит к ответу величину |a[i] - i|. Ответ нужно считать в 64-битном типе данных. Почему это решение верно? Разумеется, до этого легко догадаться. Чтобы в этом убедиться, попробуем это показать методом от противного. Рассмотрим, например, числа x, y, z. Пусть x < y < z и мы хотим свести число x к числу z вместо числа y. Однако, после некоторого количества операций  + 1 число x окажется равным y. После этого можно считать, что мы будем сводить первоначальное число y к числу z, а первоначальное число x к числу y. То есть, сведение числа x к числу z было равносильным по количеству операций. Различные подобные рассуждения приводят к решению, описанному выше.285D - Сумма перестановокОпишем сначала переборное решение. Во-первых, всегда будем считать, что перестановка a тождественная, то есть a[i] = i. В таком случае, полученный ответ просто домножим на n!. В противном случае ваш перебор не досчитается. Во-вторых, с помощью нашего перебора заметим, что для четных n ответ равен 0. Что теперь нужно сделать, чтобы сдать задачу. Первый вариант — это посчитать на вашем компьютере все ответы и записать их в константый массив, иначе говоря сделать прекалк. Вариант второй — пытаться ускорять ваше решение. Решение, использующее подход meet-in-the-middle успевает для n ≤ 15. Поскольку для четных n ответ 0, то такое решение также проходит. С другой стороны, другие простые переборы и динамики на map-ах в 3 секунды не уложились.285E - Позиции в перестановке",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7093",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 285\\s*D"
          },
          "content_length": 2284
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 1",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 2",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 1",
          "code": "F(j) = Σ(f(n, j, k)) * (n - j)!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 2",
          "code": "F(j) — F(j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "res[i] ~ R[n][i][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 3",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 4",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 5",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 16, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 16, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 16, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n = 0;\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 16;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 5);\n    } else if (type == \"large\") {\n        n = rnd.next(12, 16);\n    } else if (type == \"random\") {\n        n = rnd.next(1, 16);\n    } else if (type == \"custom\") {\n        n = opt<int>(\"n\");\n        if (n < 1 || n > 16) {\n            n = 1; // Default to minimum if invalid\n        }\n    } else {\n        n = 1; // Default to minimum if type is invalid\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n = 0;\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 16;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 5);\n    } else if (type == \"large\") {\n        n = rnd.next(12, 16);\n    } else if (type == \"random\") {\n        n = rnd.next(1, 16);\n    } else if (type == \"custom\") {\n        n = opt<int>(\"n\");\n        if (n < 1 || n > 16) {\n            n = 1; // Default to minimum if invalid\n        }\n    } else {\n        n = 1; // Default to minimum if type is invalid\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type custom -n 1\n./gen -type custom -n 2\n./gen -type custom -n 3\n./gen -type custom -n 4\n./gen -type custom -n 5\n./gen -type custom -n 6\n./gen -type custom -n 7\n./gen -type custom -n 8\n./gen -type custom -n 9\n./gen -type custom -n 10\n./gen -type custom -n 11\n./gen -type custom -n 12\n./gen -type custom -n 13\n./gen -type custom -n 14\n./gen -type custom -n 15\n./gen -type custom -n 16\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:19.320019",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "285/E",
      "title": "E. Позиции в перестановке",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записаны два целых числа n и k (1 ≤ n ≤ 1000, 0 ≤ k ≤ n).",
      "output_spec": "Выходные данныеВыведите количество перестановок размера n с ровно k хорошими позициями по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать1 0Выходные данныеСкопировать1Входные данныеСкопировать2 1Выходные данныеСкопировать0Входные данныеСкопировать3 2Выходные данныеСкопировать4Входные данныеСкопировать4 1Выходные данныеСкопировать6Входные данныеСкопировать7 4Выходные данныеСкопировать328",
      "description": "E. Позиции в перестановке\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записаны два целых числа n и k (1 ≤ n ≤ 1000, 0 ≤ k ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите количество перестановок размера n с ровно k хорошими позициями по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать1 0Выходные данныеСкопировать1Входные данныеСкопировать2 1Выходные данныеСкопировать0Входные данныеСкопировать3 2Выходные данныеСкопировать4Входные данныеСкопировать4 1Выходные данныеСкопировать6Входные данныеСкопировать7 4Выходные данныеСкопировать328\n\nВходные данныеСкопировать1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать328\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЕдинственная перестановка размера 1 имеет 0 хороших позиций.Перестановка (1, 2) имеет 0 хороших позиций, а перестановка (2, 1) — 2 позиции.Перестановки размера 3: (1, 2, 3) — 0 позиций  — 2 позиции  — 2 позиции  — 2 позиции  — 2 позиции (3, 2, 1) — 0 позиций",
      "solutions": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, друзья)Приглашаем вас на очередной раунд Codeforces #175 для участников Div. 2. Как обычно, участники Div. 1 могут поучаствовать в этом соревновании вне конкурса.Задачи для вас вновь готовила группа авторов в следующем составе: Павел Холкин (HolkinPV), Артем Рахов (RAD), Фефер Иван (Fefer_Ivan) и Геральд Агапов (Gerald). Как всегда благодарим Михаила Мирзаянова (MikeMirzayanov) за системы Codeforces и Polygon, а также Марию Белову (Delinur), которая перевела условия задач. Распределением баллов публикуем заранее) cегодня оно будет стандартным: 500, 1000, 1500, 2000, 2500.Откроем небольшой секрет этого соревнования, сегодня во всех задачах вы столкнетесь с перестановками)Надеемся, что соревнование окажется для вас удачным, желаем всем высокого рейтинга, успешных взломов и хорошего настроения)UPD1: соревнование завершилось, надеемся оно вам понравилось)UPD2: разбор задач уже можно найти здесь)UPD3: поздравляем победителей:1) hechuan2) TroyI1183) BekzhanKassenov4) ahmed_aly5) lxgsbqylbk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1021
        },
        {
          "title": "Round #175 Problem E idea - Codeforces",
          "content": "It seems that some people haven't got the idea of this problem 285E - Positions in Permutations while the tutorial is still incomplete so I'd like to write some explanations about it.A common approach for this kind of problem is DP. What we do here is to choose numbers for the good positions first, then fill the others later on. Let f(i, j, k) is the number of ways to choose j good positions in the first i-th position and k is a 2-bit number that represents whether number i and number i + 1 is already used or not. The DP transition is quite simple.Let F(j) is the number of permutations with j good positions, then F(j) = Σ(f(n, j, k)) * (n - j)! (because there are n — j numbers left unchosen). However, there are cases we may form some extra good positions when putting these n — j numbers into our permutations, thus F(j) now stores the number of permutations with at least j good positions. But we want F(j) to be the number of permutations with exact j good positions, so we must exclude those permutations with more than j good positions.Let's do it in descending order. First F(n) must be the number of permutations with exact n good positions. Hence, we may calculate F(n - 1) based on F(n), then F(n - 2) based on F(n - 1) and F(n), and so on... The last part is to calculate how many times F(j) is repeatedly counted in F(i) (i < j), it's simply C(j, i) (the number of ways to choose i good positions from j good positions).The overall complexity is O(n^2).Please refer to my submission 3376355 for an implementation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 285\\s*E"
          },
          "content_length": 1533
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces",
          "content": "285A - Немного убывающие перестановкиВ качестве ответа можно было предложить такую перестановку: n, n - 1, ..., n - k + 1, 1, 2, ..., n - k. Например, если n = 5, k = 2, то ответ: 5, 4, 1, 2, 3. Если k = 0, нужно вывести 1, 2, ..., n. Такое решение можно написать в два цикла.285B - Найди шарикИзвестно, что перестановку можно представить в виде множества циклов. Число i переходит в число p[i] для всех i (1 ≤ i ≤ n). Можно было начать двигаться из стартового числа s по циклу до тех пор, пока мы не дойдем до конечного числа t, либо же не вернемся назад в s. Если мы вернулись в начало, нужно вывести  - 1, иначе вывести длину пути.285C - Получаем перестановкуУ этой задачи решение очень простое. Нужно отсортировать последовательность a, а затем первое число свести к числу 1, второе к числу 2, и так далее. Число a[i] добавит к ответу величину |a[i] - i|. Ответ нужно считать в 64-битном типе данных. Почему это решение верно? Разумеется, до этого легко догадаться. Чтобы в этом убедиться, попробуем это показать методом от противного. Рассмотрим, например, числа x, y, z. Пусть x < y < z и мы хотим свести число x к числу z вместо числа y. Однако, после некоторого количества операций  + 1 число x окажется равным y. После этого можно считать, что мы будем сводить первоначальное число y к числу z, а первоначальное число x к числу y. То есть, сведение числа x к числу z было равносильным по количеству операций. Различные подобные рассуждения приводят к решению, описанному выше.285D - Сумма перестановокОпишем сначала переборное решение. Во-первых, всегда будем считать, что перестановка a тождественная, то есть a[i] = i. В таком случае, полученный ответ просто домножим на n!. В противном случае ваш перебор не досчитается. Во-вторых, с помощью нашего перебора заметим, что для четных n ответ равен 0. Что теперь нужно сделать, чтобы сдать задачу. Первый вариант — это посчитать на вашем компьютере все ответы и записать их в константый массив, иначе говоря сделать прекалк. Вариант второй — пытаться ускорять ваше решение. Решение, использующее подход meet-in-the-middle успевает для n ≤ 15. Поскольку для четных n ответ 0, то такое решение также проходит. С другой стороны, другие простые переборы и динамики на map-ах в 3 секунды не уложились.285E - Позиции в перестановке",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7093",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 285\\s*E"
          },
          "content_length": 2284
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 1",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) - Codeforces - Code 2",
          "code": "while(standings[0]!={insert your username here})\n{\n\tnext_permutation(standings.begin(),standings.end());\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7087",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 1",
          "code": "F(j) = Σ(f(n, j, k)) * (n - j)!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Round #175 Problem E idea - Codeforces - Code 2",
          "code": "F(j) — F(j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "res[i] ~ R[n][i][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 3",
          "code": "printf(\"%I64d\\n\", 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 4",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #175 (Div. 2) Разбор Задач - Codeforces - Code 5",
          "code": "printf(\"%I64d\\n\",0ll);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7093",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = -1; // default value not set\n    \n    if (type == \"random\") {\n        k = rnd.next(0, n);\n    } else if (type == \"zeroK\") {\n        k = 0;\n    } else if (type == \"maxK\") {\n        k = n;\n    } else if (type == \"halfK\") {\n        k = n / 2;\n    } else if (type == \"allK\") {\n        k = opt<int>(\"k\");\n    } else if (type == \"edgeN\") {\n        // For edgeN, n is small, k can be any value from 0 to n\n        k = rnd.next(0, n);\n    } else if (type == \"smallN\") {\n        n = rnd.next(1, 10);\n        k = rnd.next(0, n);\n    } else if (type == \"largeNZeroK\") {\n        k = 0;\n    } else if (type == \"largeNMaxK\") {\n        k = n;\n    } else {\n        // Default to random k\n        k = rnd.next(0, n);\n    }\n    \n    ensuref(k >= 0 && k <= n, \"k must be in range 0..n\");\n    \n    printf(\"%d %d\\n\", n, k);\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = -1; // default value not set\n    \n    if (type == \"random\") {\n        k = rnd.next(0, n);\n    } else if (type == \"zeroK\") {\n        k = 0;\n    } else if (type == \"maxK\") {\n        k = n;\n    } else if (type == \"halfK\") {\n        k = n / 2;\n    } else if (type == \"allK\") {\n        k = opt<int>(\"k\");\n    } else if (type == \"edgeN\") {\n        // For edgeN, n is small, k can be any value from 0 to n\n        k = rnd.next(0, n);\n    } else if (type == \"smallN\") {\n        n = rnd.next(1, 10);\n        k = rnd.next(0, n);\n    } else if (type == \"largeNZeroK\") {\n        k = 0;\n    } else if (type == \"largeNMaxK\") {\n        k = n;\n    } else {\n        // Default to random k\n        k = rnd.next(0, n);\n    }\n    \n    ensuref(k >= 0 && k <= n, \"k must be in range 0..n\");\n    \n    printf(\"%d %d\\n\", n, k);\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type edgeN\n./gen -n 2 -type edgeN\n./gen -n 3 -type edgeN\n\n./gen -n 1 -type allK -k 0\n\n./gen -n 2 -type allK -k 0\n./gen -n 2 -type allK -k 1\n./gen -n 2 -type allK -k 2\n\n./gen -n 3 -type allK -k 0\n./gen -n 3 -type allK -k 1\n./gen -n 3 -type allK -k 2\n./gen -n 3 -type allK -k 3\n\n./gen -n 10 -type random\n./gen -n 10 -type zeroK\n./gen -n 10 -type maxK\n./gen -n 10 -type halfK\n\n./gen -n 100 -type random\n./gen -n 100 -type zeroK\n./gen -n 100 -type maxK\n./gen -n 100 -type halfK\n\n./gen -n 500 -type random\n./gen -n 500 -type zeroK\n./gen -n 500 -type maxK\n./gen -n 500 -type halfK\n\n./gen -n 997 -type random\n./gen -n 997 -type zeroK\n./gen -n 997 -type maxK\n./gen -n 997 -type halfK\n\n./gen -n 1000 -type random\n./gen -n 1000 -type zeroK\n./gen -n 1000 -type maxK\n./gen -n 1000 -type halfK\n\n./gen -n 1 -type smallN\n./gen -n 5 -type smallN\n./gen -n 10 -type smallN\n\n./gen -n 1000 -type largeNZeroK\n./gen -n 1000 -type largeNMaxK\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:21.056073",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "286/A",
      "title": "A. Lucky Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the required permutation size.",
      "output_spec": "OutputPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.Otherwise, print n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) after a space — the required permutation.If there are multiple answers, you can print any of them.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1 InputCopy2OutputCopy-1InputCopy4OutputCopy2 4 1 3 InputCopy5OutputCopy2 5 3 1 4",
      "description": "A. Lucky Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the required permutation size.\n\nOutputPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.Otherwise, print n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) after a space — the required permutation.If there are multiple answers, you can print any of them.\n\nInputCopy1OutputCopy1 InputCopy2OutputCopy-1InputCopy4OutputCopy2 4 1 3 InputCopy5OutputCopy2 5 3 1 4\n\nOutputCopy1\n\nOutputCopy-1\n\nOutputCopy2 4 1 3\n\nOutputCopy2 5 3 1 4",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit?usp=sharing",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    int n = inf.readInt(1, 100000);\n\n    string ans_s = ans.readToken();\n    string ouf_s = ouf.readToken();\n\n    if (ans_s == \"-1\") {\n        // Jury says no solution exists\n        if (ouf_s == \"-1\") {\n            // Participant agrees - accept\n            // Ensure no extra data\n            if (!ans.seekEof())\n                quitf(_fail, \"Jury's output has extra data after -1\");\n            if (!ouf.seekEof())\n                quitf(_wa, \"Participant's output has extra data after -1\");\n            quitf(_ok, \"No solution exists and participant outputs -1\");\n        } else {\n            // Participant claims a solution exists\n            // Read participant's permutation\n            vector<int> p;\n            int first = atoi(ouf_s.c_str());\n            if (first < 1 || first > n)\n                quitf(_wa, \"Participant's permutation contains invalid number %d\", first);\n            p.push_back(first);\n            for (int i = 1; i < n; i++) {\n                int x = ouf.readInt(1, n, format(\"p[%d]\", i+1).c_str());\n                p.push_back(x);\n            }\n            if (!ouf.seekEof())\n                quitf(_wa, \"Participant's permutation has extra data\");\n            // Check the permutation\n            vector<int> pi(n+1), pp(n+1);\n            vector<bool> used(n+1, false);\n            for (int i = 1; i <= n; i++) {\n                int x = p[i-1];\n                if (used[x])\n                    quitf(_wa, \"Number %d occurs more than once in participant's permutation\", x);\n                used[x] = true;\n                pi[i] = x;\n            }\n            // Build p_p_i and check condition\n            for (int i = 1; i <= n; i++) {\n                pp[i] = pi[pi[i]];\n                if (pp[i] != n - i + 1)\n                    quitf(_wa, \"Invalid at position %d: p_p_%d = %d, expected %d\", i, i, pp[i], n - i + 1);\n            }\n            // Participant found a solution when jury says none exists\n            quitf(_fail, \"Participant found a lucky permutation but jury says none exists\");\n        }\n    } else {\n        // Jury says a solution exists\n        if (ouf_s == \"-1\") {\n            // Participant says no solution exists\n            quitf(_wa, \"Participant says no solution exists but a lucky permutation exists\");\n        } else {\n            // Participant provides a permutation\n            vector<int> p;\n            int first = atoi(ouf_s.c_str());\n            if (first < 1 || first > n)\n                quitf(_wa, \"Participant's permutation contains invalid number %d\", first);\n            p.push_back(first);\n            for (int i = 1; i < n; i++) {\n                int x = ouf.readInt(1, n, format(\"p[%d]\", i+1).c_str());\n                p.push_back(x);\n            }\n            if (!ouf.seekEof())\n                quitf(_wa, \"Participant's permutation has extra data\");\n            // Check the permutation\n            vector<int> pi(n+1), pp(n+1);\n            vector<bool> used(n+1, false);\n            for (int i = 1; i <= n; i++) {\n                int x = p[i-1];\n                if (used[x])\n                    quitf(_wa, \"Number %d occurs more than once in participant's permutation\", x);\n                used[x] = true;\n                pi[i] = x;\n            }\n            // Build p_p_i and check condition\n            for (int i = 1; i <= n; i++) {\n                pp[i] = pi[pi[i]];\n                if (pp[i] != n - i + 1)\n                    quitf(_wa, \"Invalid at position %d: p_p_%d = %d, expected %d\", i, i, pp[i], n - i + 1);\n            }\n            // Participant's permutation is valid\n            quitf(_ok, \"Participant's permutation is valid\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Try to read n\n    int n = opt<int>(\"n\", -1);  // default to -1 if not provided\n    string type = opt<string>(\"type\", \"default\");\n\n    if (n == -1) {\n        // If n not provided, determine n based on type\n        if (type == \"min_n\") {\n            n = 1;\n        } else if (type == \"max_n\") {\n            n = 100000;\n        } else if (type == \"special\") {\n            n = rnd.next(2, 3); // n = 2 or 3\n        } else if (type == \"small_random\") {\n            n = rnd.next(1, 100);\n        } else if (type == \"large_random\") {\n            n = rnd.next(100000 - 1000, 100000);\n        } else if (type == \"random\") {\n            n = rnd.next(1, 100000);\n        } else {\n            // default n=1\n            n = 1;\n        }\n    } else {\n        // n is provided\n        // No action needed\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Try to read n\n    int n = opt<int>(\"n\", -1);  // default to -1 if not provided\n    string type = opt<string>(\"type\", \"default\");\n\n    if (n == -1) {\n        // If n not provided, determine n based on type\n        if (type == \"min_n\") {\n            n = 1;\n        } else if (type == \"max_n\") {\n            n = 100000;\n        } else if (type == \"special\") {\n            n = rnd.next(2, 3); // n = 2 or 3\n        } else if (type == \"small_random\") {\n            n = rnd.next(1, 100);\n        } else if (type == \"large_random\") {\n            n = rnd.next(100000 - 1000, 100000);\n        } else if (type == \"random\") {\n            n = rnd.next(1, 100000);\n        } else {\n            // default n=1\n            n = 1;\n        }\n    } else {\n        // n is provided\n        // No action needed\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 100\n./gen -n 1000\n./gen -n 10000\n./gen -n 25000\n./gen -n 50000\n./gen -n 75000\n./gen -n 99999\n./gen -n 100000\n\n./gen -type min_n\n./gen -type max_n\n./gen -type special\n./gen -type small_random\n./gen -type small_random\n./gen -type small_random\n./gen -type large_random\n./gen -type large_random\n./gen -type large_random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases\n./gen -n 2\n./gen -n 3\n./gen -n 1\n./gen -n 100000\n./gen -n 99999\n\n# Special n's\n./gen -n 2\n./gen -n 3\n# Values in middle of the range\n./gen -n 12345\n./gen -n 54321\n./gen -n 56789\n./gen -n 98765\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:23.335897",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "286/B",
      "title": "B. Shifting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains integer n (2 ≤ n ≤ 106).",
      "output_spec": "OutputPrint n distinct space-separated integers from 1 to n — a beautiful permutation of size n.",
      "sample_tests": "ExamplesInputCopy2OutputCopy2 1 InputCopy3OutputCopy1 3 2 InputCopy4OutputCopy4 2 3 1",
      "description": "B. Shifting\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains integer n (2 ≤ n ≤ 106).\n\nOutputPrint n distinct space-separated integers from 1 to n — a beautiful permutation of size n.\n\nInputCopy2OutputCopy2 1 InputCopy3OutputCopy1 3 2 InputCopy4OutputCopy4 2 3 1\n\nOutputCopy2 1\n\nOutputCopy1 3 2\n\nOutputCopy4 2 3 1\n\nNoteA note to the third test sample:   f([1, 2, 3, 4], 2) = [2, 1, 4, 3]  f([2, 1, 4, 3], 3) = [1, 4, 2, 3]  f([1, 4, 2, 3], 4) = [4, 2, 3, 1]",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit?usp=sharing",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = -1;\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"minimal\") {\n        n = 2;\n    } else if (type == \"maximal\") {\n        n = 1000000;\n    } else if (type == \"small\") {\n        n = rnd.next(2, 100);\n    } else if (type == \"medium\") {\n        n = rnd.next(1000, 10000);\n    } else if (type == \"large\") {\n        n = rnd.next(100000, 1000000);\n    } else if (type == \"prime\") {\n        // Generate a prime number between 2 and 1e6\n        vector<int> primes;\n        // Sieve of Eratosthenes to generate primes up to 1e6\n        const int MAX_N = 1000000;\n        vector<bool> is_prime(MAX_N + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= MAX_N; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = 2 * i; j <= MAX_N; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        n = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else if (type == \"power_of_two\") {\n        // Generate a power of two between 2 and 1e6\n        vector<int> powers;\n        for (int i = 1; i <= 20; ++i) {\n            int val = 1 << i;\n            if (val >= 2 && val <= 1000000)\n                powers.push_back(val);\n        }\n        n = powers[rnd.next(0, (int)powers.size() - 1)];\n    } else if (type == \"one_less_power_of_two\") {\n        // Generate numbers of form 2^k - 1\n        vector<int> values;\n        for (int i = 2; i <= 20; ++i) {\n            int val = (1 << i) - 1;\n            if (val >= 2 && val <= 1000000)\n                values.push_back(val);\n        }\n        n = values[rnd.next(0, (int)values.size() - 1)];\n    } else if (type == \"one_more_power_of_two\") {\n        // Generate numbers of form 2^k + 1\n        vector<int> values;\n        for (int i = 1; i <= 20; ++i) {\n            int val = (1 << i) + 1;\n            if (val >= 2 && val <= 1000000)\n                values.push_back(val);\n        }\n        n = values[rnd.next(0, (int)values.size() - 1)];\n    } else if (type == \"even\") {\n        n = rnd.next(1, 500000) * 2;\n    } else if (type == \"odd\") {\n        n = rnd.next(1, 500000) * 2 - 1;\n        if (n < 2) n = 3;\n    } else if (type == \"custom_n\") {\n        n = opt<int>(\"n\");\n        ensure(2 <= n && n <= 1000000);\n    } else {\n        // default: n between 2 and 1e6\n        n = rnd.next(2, 1000000);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = -1;\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"minimal\") {\n        n = 2;\n    } else if (type == \"maximal\") {\n        n = 1000000;\n    } else if (type == \"small\") {\n        n = rnd.next(2, 100);\n    } else if (type == \"medium\") {\n        n = rnd.next(1000, 10000);\n    } else if (type == \"large\") {\n        n = rnd.next(100000, 1000000);\n    } else if (type == \"prime\") {\n        // Generate a prime number between 2 and 1e6\n        vector<int> primes;\n        // Sieve of Eratosthenes to generate primes up to 1e6\n        const int MAX_N = 1000000;\n        vector<bool> is_prime(MAX_N + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= MAX_N; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = 2 * i; j <= MAX_N; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        n = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else if (type == \"power_of_two\") {\n        // Generate a power of two between 2 and 1e6\n        vector<int> powers;\n        for (int i = 1; i <= 20; ++i) {\n            int val = 1 << i;\n            if (val >= 2 && val <= 1000000)\n                powers.push_back(val);\n        }\n        n = powers[rnd.next(0, (int)powers.size() - 1)];\n    } else if (type == \"one_less_power_of_two\") {\n        // Generate numbers of form 2^k - 1\n        vector<int> values;\n        for (int i = 2; i <= 20; ++i) {\n            int val = (1 << i) - 1;\n            if (val >= 2 && val <= 1000000)\n                values.push_back(val);\n        }\n        n = values[rnd.next(0, (int)values.size() - 1)];\n    } else if (type == \"one_more_power_of_two\") {\n        // Generate numbers of form 2^k + 1\n        vector<int> values;\n        for (int i = 1; i <= 20; ++i) {\n            int val = (1 << i) + 1;\n            if (val >= 2 && val <= 1000000)\n                values.push_back(val);\n        }\n        n = values[rnd.next(0, (int)values.size() - 1)];\n    } else if (type == \"even\") {\n        n = rnd.next(1, 500000) * 2;\n    } else if (type == \"odd\") {\n        n = rnd.next(1, 500000) * 2 - 1;\n        if (n < 2) n = 3;\n    } else if (type == \"custom_n\") {\n        n = opt<int>(\"n\");\n        ensure(2 <= n && n <= 1000000);\n    } else {\n        // default: n between 2 and 1e6\n        n = rnd.next(2, 1000000);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n\n./gen -type minimal\n\n# Maximal n\n./gen -type maximal\n\n# Small n (several times)\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Medium n (several times)\n./gen -type medium\n./gen -type medium\n./gen -type medium\n\n# Large n (several times)\n./gen -type large\n./gen -type large\n./gen -type large\n\n# Random n (default)\n./gen\n./gen\n./gen\n\n# n is a prime number\n./gen -type prime\n./gen -type prime\n./gen -type prime\n\n# n is a power of two\n./gen -type power_of_two\n./gen -type power_of_two\n\n# n is one less than a power of two\n./gen -type one_less_power_of_two\n./gen -type one_less_power_of_two\n\n# n is one more than a power of two\n./gen -type one_more_power_of_two\n./gen -type one_more_power_of_two\n\n# n is even (several times)\n./gen -type even\n./gen -type even\n\n# n is odd (several times)\n./gen -type odd\n./gen -type odd\n\n# Custom n (edge cases)\n./gen -type custom_n -n 999999\n./gen -type custom_n -n 1000000\n./gen -type custom_n -n 999998\n\n# Specific small n\n./gen -type custom_n -n 3\n./gen -type custom_n -n 4\n./gen -type custom_n -n 5\n\n# n near powers of two\n./gen -type custom_n -n 1023   # 2^10 - 1\n./gen -type custom_n -n 1025   # 2^10 + 1\n./gen -type custom_n -n 2047   # 2^11 - 1\n./gen -type custom_n -n 2049   # 2^11 + 1\n\n# n is near 1e6\n./gen -type custom_n -n 999995\n./gen -type custom_n -n 999999\n\n# n is a composite number with small factors\n./gen -type custom_n -n 999900  # 999900 = 2*2*3*3*5*5*7*7*13\n./gen -type custom_n -n 720720  # 720720 has many small factors\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:25.448035",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "286/C",
      "title": "C. Main Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 106). The second line contains n integers: p1, p2, ..., pn (1 ≤ pi ≤ 109).The third line contains integer t (0 ≤ t ≤ n), followed by t distinct integers q1, q2, ..., qt (1 ≤ qi ≤ n).The numbers in each line are separated by spaces.",
      "output_spec": "OutputPrint a single string \"NO\" (without the quotes) if Vova is mistaken and a suitable sequence {x1, x2, ..., xn} doesn't exist.Otherwise, in the first line print \"YES\" (without the quotes) and in the second line print n integers x1, x2, ..., xn (|xi| = pi; xqj < 0). If there are multiple sequences that correspond to the encrypting, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy21 10OutputCopyYES1 -1InputCopy41 1 1 11 3OutputCopyYES1 1 -1 -1InputCopy31 1 10OutputCopyNOInputCopy41 2 2 12 3 4OutputCopyYES1 2 -2 -1",
      "description": "C. Main Sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 106). The second line contains n integers: p1, p2, ..., pn (1 ≤ pi ≤ 109).The third line contains integer t (0 ≤ t ≤ n), followed by t distinct integers q1, q2, ..., qt (1 ≤ qi ≤ n).The numbers in each line are separated by spaces.\n\nOutputPrint a single string \"NO\" (without the quotes) if Vova is mistaken and a suitable sequence {x1, x2, ..., xn} doesn't exist.Otherwise, in the first line print \"YES\" (without the quotes) and in the second line print n integers x1, x2, ..., xn (|xi| = pi; xqj < 0). If there are multiple sequences that correspond to the encrypting, you are allowed to print any of them.\n\nInputCopy21 10OutputCopyYES1 -1InputCopy41 1 1 11 3OutputCopyYES1 1 -1 -1InputCopy31 1 10OutputCopyNOInputCopy41 2 2 12 3 4OutputCopyYES1 2 -2 -1\n\nInputCopy21 10\n\nOutputCopyYES1 -1\n\nInputCopy41 1 1 11 3\n\nOutputCopyYES1 1 -1 -1\n\nInputCopy31 1 10\n\nOutputCopyNO\n\nInputCopy41 2 2 12 3 4\n\nOutputCopyYES1 2 -2 -1",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit?usp=sharing",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"pi\");\n    inf.readEoln();\n    int t = inf.readInt(0, n, \"t\");\n    if (t == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        vector<int> q = inf.readInts(t, 1, n, \"qi\");\n        inf.readEoln();\n        set<int> q_set(q.begin(), q.end());\n        ensuref((int) q_set.size() == t, \"qi's must be distinct\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"pi\");\n    inf.readEoln();\n    int t = inf.readInt(0, n, \"t\");\n    if (t == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        vector<int> q = inf.readInts(t, 1, n, \"qi\");\n        inf.readEoln();\n        set<int> q_set(q.begin(), q.end());\n        ensuref((int) q_set.size() == t, \"qi's must be distinct\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"pi\");\n    inf.readEoln();\n    int t = inf.readInt(0, n, \"t\");\n    if (t == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        vector<int> q = inf.readInts(t, 1, n, \"qi\");\n        inf.readEoln();\n        set<int> q_set(q.begin(), q.end());\n        ensuref((int) q_set.size() == t, \"qi's must be distinct\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include <bits/stdc++.h>\n#include \"testlib.h\"\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from inf\n    int n = inf.readInt(1, 1000000);\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = inf.readInt(1, 1000000000);\n\n    int t = inf.readInt(0, n);\n    set<int> q_positions;\n    for (int i = 0; i < t; ++i)\n    {\n        int qi = inf.readInt(1, n);\n        q_positions.insert(qi - 1); // Zero-based indexing\n    }\n\n    // Read judge's answer\n    string judgeAns = ans.readToken();\n    if (judgeAns != \"YES\" && judgeAns != \"NO\")\n        quitf(_fail, \"Judge's answer is neither 'YES' nor 'NO'\");\n\n    // Read contestant's answer\n    string contAns = ouf.readToken();\n    if (contAns != \"YES\" && contAns != \"NO\")\n        quitf(_wa, \"Contestant's answer is neither 'YES' nor 'NO'\");\n\n    if (judgeAns == \"NO\")\n    {\n        if (contAns != \"NO\")\n            quitf(_wa, \"Contestant's answer is '%s' but correct answer is 'NO'\", contAns.c_str());\n        // Both answers are 'NO'\n        quitf(_ok, \"Correct answer: NO\");\n    }\n    else // judgeAns == \"YES\"\n    {\n        if (contAns != \"YES\")\n            quitf(_wa, \"Contestant's answer is '%s' but correct answer is 'YES'\", contAns.c_str());\n\n        // Read x[1..n] from contestant output\n        vector<int> x = ouf.readInts(n, -1000000000, 1000000000, \"x\");\n\n        // Ensure there is no extra output\n        if (!ouf.seekEof())\n            quitf(_wa, \"Extra data found in contestant's output\");\n\n        // Validate x[1..n]\n        for (int i = 0; i < n; ++i)\n        {\n            int xi = x[i];\n            int pi = p[i];\n            if (abs(xi) != pi)\n                quitf(_wa, \"At position %d, abs(xi) != pi: abs(%d) != %d\", i+1, xi, pi);\n\n            if (q_positions.count(i))\n            {\n                if (xi >= 0)\n                    quitf(_wa, \"At position %d (specified in q), xi is not negative: xi = %d\", i+1, xi);\n            }\n        }\n\n        // Check that x[1..n] forms a correct bracket sequence\n        stack<int> st;\n        for (int i = 0; i < n; ++i)\n        {\n            int xi = x[i];\n            if (xi > 0)\n            {\n                st.push(xi);\n            }\n            else // xi < 0\n            {\n                if (st.empty())\n                    quitf(_wa, \"Unmatched closing bracket at position %d\", i+1);\n                int top = st.top();\n                st.pop();\n                if (top != -xi)\n                    quitf(_wa, \"Mismatched bracket types at position %d: expected %d, found %d\", i+1, top, -xi);\n            }\n        }\n        if (!st.empty())\n            quitf(_wa, \"Unmatched opening brackets remain\");\n\n        // All checks passed\n        quitf(_ok, \"Correct\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    int t = opt<int>(\"t\", -1); // t is optional\n\n    int max_pi = opt<int>(\"max_pi\", 1000000000); // default max_pi is 1e9\n\n    vector<int> pi(n + 1);\n    vector<int> xi(n + 1);\n    vector<int> qj;\n    vector<int> closing_positions;\n\n    if (type == \"yes\") {\n        if (n % 2 != 0) {\n            n += 1; // n must be even for a correct bracket sequence\n        }\n\n        if (t == -1) {\n            t = rnd.next(0, n / 2);\n        }\n\n        int num_pairs = n / 2;\n        int maxType = max_pi;\n\n        vector<int> types;\n        for (int i = 1; i <= num_pairs; ++i) {\n            int type_val = rnd.next(1, maxType);\n            types.push_back(type_val);\n        }\n\n        shuffle(types.begin(), types.end());\n\n        int idx = 0;\n        for (int i = 1; i <= num_pairs; ++i) {\n            xi[idx + 1] = types[i - 1];\n            xi[idx + 2] = -types[i - 1];\n            closing_positions.push_back(idx + 2);\n            idx += 2;\n        }\n\n        for (int i = 1; i <= n; ++i) {\n            pi[i] = abs(xi[i]);\n        }\n\n        if (t > (int)closing_positions.size()) {\n            t = closing_positions.size();\n        }\n\n        shuffle(closing_positions.begin(), closing_positions.end());\n        qj.assign(closing_positions.begin(), closing_positions.begin() + t);\n\n        printf(\"%d\\n\", n);\n        for (int i = 1; i <= n; ++i) {\n            printf(\"%d%c\", pi[i], i == n ? '\\n' : ' ');\n        }\n\n        sort(qj.begin(), qj.end());\n        printf(\"%d\", t);\n        for (int i = 0; i < t; ++i) {\n            printf(\" %d\", qj[i]);\n        }\n        printf(\"\\n\");\n\n    } else if (type == \"no\") {\n        bool force_invalid = (opt<std::string>(\"force_invalid\", \"false\") == \"true\");\n\n        if (t == -1) {\n            t = rnd.next(0, n);\n        }\n\n        if (n % 2 != 0 || force_invalid) {\n            // Generate an invalid bracket sequence\n            int num_pairs = n / 2;\n            int maxType = max_pi;\n\n            vector<int> types;\n            for (int i = 1; i <= num_pairs; ++i) {\n                int type_val = rnd.next(1, maxType);\n                types.push_back(type_val);\n            }\n\n            int idx = 0;\n            for (int i = 1; i <= num_pairs; ++i) {\n                xi[idx + 1] = types[i - 1];\n                xi[idx + 2] = -types[i - 1];\n                idx += 2;\n            }\n\n            if (force_invalid && n >= 1) {\n                xi[1] = -xi[1]; // Force a closing bracket at position 1\n            }\n\n            for (int i = 1; i <= n; ++i) {\n                pi[i] = abs(xi[i]);\n            }\n\n            vector<int> negative_positions;\n            for (int i = 1; i <= n; ++i) {\n                if (xi[i] < 0) {\n                    negative_positions.push_back(i);\n                }\n            }\n\n            if (t > (int)negative_positions.size()) {\n                t = negative_positions.size();\n            }\n\n            shuffle(negative_positions.begin(), negative_positions.end());\n            qj.assign(negative_positions.begin(), negative_positions.begin() + t);\n\n            printf(\"%d\\n\", n);\n            for (int i = 1; i <= n; ++i) {\n                printf(\"%d%c\", pi[i], i == n ? '\\n' : ' ');\n            }\n\n            sort(qj.begin(), qj.end());\n            printf(\"%d\", t);\n            for (int i = 0; i < t; ++i) {\n                printf(\" %d\", qj[i]);\n            }\n            printf(\"\\n\");\n        } else {\n            // n is even and no invalidity forced, so we try to make an invalid test case\n            // Let's force a closing bracket at the start\n            int num_pairs = n / 2;\n            int maxType = max_pi;\n\n            vector<int> types;\n            for (int i = 1; i <= num_pairs; ++i) {\n                int type_val = rnd.next(1, maxType);\n                types.push_back(type_val);\n            }\n\n            int idx = 0;\n            for (int i = 1; i <= num_pairs; ++i) {\n                xi[idx + 1] = types[i - 1];\n                xi[idx + 2] = -types[i - 1];\n                idx += 2;\n            }\n\n            xi[1] = -xi[1]; // Force the first bracket to be closing\n\n            for (int i = 1; i <= n; ++i) {\n                pi[i] = abs(xi[i]);\n            }\n\n            vector<int> negative_positions;\n            for (int i = 1; i <= n; ++i) {\n                if (xi[i] < 0) {\n                    negative_positions.push_back(i);\n                }\n            }\n\n            if (t > (int)negative_positions.size()) {\n                t = negative_positions.size();\n            }\n\n            shuffle(negative_positions.begin(), negative_positions.end());\n            qj.assign(negative_positions.begin(), negative_positions.begin() + t);\n\n            printf(\"%d\\n\", n);\n            for (int i = 1; i <= n; ++i) {\n                printf(\"%d%c\", pi[i], i == n ? '\\n' : ' ');\n            }\n\n            sort(qj.begin(), qj.end());\n            printf(\"%d\", t);\n            for (int i = 0; i < t; ++i) {\n                printf(\" %d\", qj[i]);\n            }\n            printf(\"\\n\");\n        }\n\n    } else {\n        fprintf(stderr, \"Undefined type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    int t = opt<int>(\"t\", -1); // t is optional\n\n    int max_pi = opt<int>(\"max_pi\", 1000000000); // default max_pi is 1e9\n\n    vector<int> pi(n + 1);\n    vector<int> xi(n + 1);\n    vector<int> qj;\n    vector<int> closing_positions;\n\n    if (type == \"yes\") {\n        if (n % 2 != 0) {\n            n += 1; // n must be even for a correct bracket sequence\n        }\n\n        if (t == -1) {\n            t = rnd.next(0, n / 2);\n        }\n\n        int num_pairs = n / 2;\n        int maxType = max_pi;\n\n        vector<int> types;\n        for (int i = 1; i <= num_pairs; ++i) {\n            int type_val = rnd.next(1, maxType);\n            types.push_back(type_val);\n        }\n\n        shuffle(types.begin(), types.end());\n\n        int idx = 0;\n        for (int i = 1; i <= num_pairs; ++i) {\n            xi[idx + 1] = types[i - 1];\n            xi[idx + 2] = -types[i - 1];\n            closing_positions.push_back(idx + 2);\n            idx += 2;\n        }\n\n        for (int i = 1; i <= n; ++i) {\n            pi[i] = abs(xi[i]);\n        }\n\n        if (t > (int)closing_positions.size()) {\n            t = closing_positions.size();\n        }\n\n        shuffle(closing_positions.begin(), closing_positions.end());\n        qj.assign(closing_positions.begin(), closing_positions.begin() + t);\n\n        printf(\"%d\\n\", n);\n        for (int i = 1; i <= n; ++i) {\n            printf(\"%d%c\", pi[i], i == n ? '\\n' : ' ');\n        }\n\n        sort(qj.begin(), qj.end());\n        printf(\"%d\", t);\n        for (int i = 0; i < t; ++i) {\n            printf(\" %d\", qj[i]);\n        }\n        printf(\"\\n\");\n\n    } else if (type == \"no\") {\n        bool force_invalid = (opt<std::string>(\"force_invalid\", \"false\") == \"true\");\n\n        if (t == -1) {\n            t = rnd.next(0, n);\n        }\n\n        if (n % 2 != 0 || force_invalid) {\n            // Generate an invalid bracket sequence\n            int num_pairs = n / 2;\n            int maxType = max_pi;\n\n            vector<int> types;\n            for (int i = 1; i <= num_pairs; ++i) {\n                int type_val = rnd.next(1, maxType);\n                types.push_back(type_val);\n            }\n\n            int idx = 0;\n            for (int i = 1; i <= num_pairs; ++i) {\n                xi[idx + 1] = types[i - 1];\n                xi[idx + 2] = -types[i - 1];\n                idx += 2;\n            }\n\n            if (force_invalid && n >= 1) {\n                xi[1] = -xi[1]; // Force a closing bracket at position 1\n            }\n\n            for (int i = 1; i <= n; ++i) {\n                pi[i] = abs(xi[i]);\n            }\n\n            vector<int> negative_positions;\n            for (int i = 1; i <= n; ++i) {\n                if (xi[i] < 0) {\n                    negative_positions.push_back(i);\n                }\n            }\n\n            if (t > (int)negative_positions.size()) {\n                t = negative_positions.size();\n            }\n\n            shuffle(negative_positions.begin(), negative_positions.end());\n            qj.assign(negative_positions.begin(), negative_positions.begin() + t);\n\n            printf(\"%d\\n\", n);\n            for (int i = 1; i <= n; ++i) {\n                printf(\"%d%c\", pi[i], i == n ? '\\n' : ' ');\n            }\n\n            sort(qj.begin(), qj.end());\n            printf(\"%d\", t);\n            for (int i = 0; i < t; ++i) {\n                printf(\" %d\", qj[i]);\n            }\n            printf(\"\\n\");\n        } else {\n            // n is even and no invalidity forced, so we try to make an invalid test case\n            // Let's force a closing bracket at the start\n            int num_pairs = n / 2;\n            int maxType = max_pi;\n\n            vector<int> types;\n            for (int i = 1; i <= num_pairs; ++i) {\n                int type_val = rnd.next(1, maxType);\n                types.push_back(type_val);\n            }\n\n            int idx = 0;\n            for (int i = 1; i <= num_pairs; ++i) {\n                xi[idx + 1] = types[i - 1];\n                xi[idx + 2] = -types[i - 1];\n                idx += 2;\n            }\n\n            xi[1] = -xi[1]; // Force the first bracket to be closing\n\n            for (int i = 1; i <= n; ++i) {\n                pi[i] = abs(xi[i]);\n            }\n\n            vector<int> negative_positions;\n            for (int i = 1; i <= n; ++i) {\n                if (xi[i] < 0) {\n                    negative_positions.push_back(i);\n                }\n            }\n\n            if (t > (int)negative_positions.size()) {\n                t = negative_positions.size();\n            }\n\n            shuffle(negative_positions.begin(), negative_positions.end());\n            qj.assign(negative_positions.begin(), negative_positions.begin() + t);\n\n            printf(\"%d\\n\", n);\n            for (int i = 1; i <= n; ++i) {\n                printf(\"%d%c\", pi[i], i == n ? '\\n' : ' ');\n            }\n\n            sort(qj.begin(), qj.end());\n            printf(\"%d\", t);\n            for (int i = 0; i < t; ++i) {\n                printf(\" %d\", qj[i]);\n            }\n            printf(\"\\n\");\n        }\n\n    } else {\n        fprintf(stderr, \"Undefined type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type no\n./gen -n 2 -type yes\n./gen -n 3 -type no\n./gen -n 4 -type yes -t 1\n./gen -n 5 -type no\n./gen -n 6 -type yes\n./gen -n 6 -type yes -t 3\n./gen -n 6 -type no -force_invalid true\n./gen -n 10 -type yes -t 5\n./gen -n 10 -type no -force_invalid true\n./gen -n 100 -type yes\n./gen -n 100 -type no -force_invalid true\n./gen -n 1000 -type yes\n./gen -n 999 -type no\n./gen -n 10000 -type yes -max_pi 1\n./gen -n 99998 -type yes -t 50000\n./gen -n 99999 -type no\n./gen -n 100000 -type yes\n./gen -n 100000 -type no\n./gen -n 100000 -type no -force_invalid true\n./gen -n 1000000 -type yes\n./gen -n 1000000 -type yes -t 0\n./gen -n 999999 -type no\n./gen -n 1000000 -type no\n./gen -n 1000000 -type no -force_invalid true\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:27.501969",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "286/D",
      "title": "D. Туристы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны через пробел два целых числа n и m (1 ≤ n, m ≤ 105) — количество пар туристов и количество возводимых перегородок. В следующих m строках располагается по три целых числа li, ri и ti, разделенные пробелом (0 ≤ li < ri ≤ 109, 0 ≤ ti ≤ 109) — границы перегородки и время ее появления. В последней строке записаны через пробел в строго возрастающем порядке n различных целых чисел q1, q2, ..., qn (0 ≤ qi ≤ 109) — времена выхода пар туристов.Все времена заданы в секундах.",
      "output_spec": "Выходные данныеДля каждой пары выведите в отдельной строке единственное целое число — время в секундах, в течение которого туристы из соответствующей пары не будут видеть друг друга. Выводите эти числа в том же порядке, в каком пары заданы во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 21 4 33 6 50 1Выходные данныеСкопировать24Входные данныеСкопировать3 30 3 40 1 22 4 01 3 4Выходные данныеСкопировать244",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны через пробел два целых числа n и m (1 ≤ n, m ≤ 105) — количество пар туристов и количество возводимых перегородок. В следующих m строках располагается по три целых числа li, ri и ti, разделенные пробелом (0 ≤ li < ri ≤ 109, 0 ≤ ti ≤ 109) — границы перегородки и время ее появления. В последней строке записаны через пробел в строго возрастающем порядке n различных целых чисел q1, q2, ..., qn (0 ≤ qi ≤ 109) — времена выхода пар туристов.Все времена заданы в секундах.\n\nВходные данные\n\nВыходные данныеДля каждой пары выведите в отдельной строке единственное целое число — время в секундах, в течение которого туристы из соответствующей пары не будут видеть друг друга. Выводите эти числа в том же порядке, в каком пары заданы во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать2 21 4 33 6 50 1Выходные данныеСкопировать24Входные данныеСкопировать3 30 3 40 1 22 4 01 3 4Выходные данныеСкопировать244\n\nВходные данныеСкопировать2 21 4 33 6 50 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать24\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 30 3 40 1 22 4 01 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать244\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Всем привет! Этот раунд готовим я и KAN. Надеюсь, многим понравятся наши задачи.Хочу сказать спасибо PavelKunyavskiy, который тестировал задачи, вычитывал условия и вообще помог. Еще раунд решали alger95, Skird, fdoer, sand-martin, спасибо им за это.Конечно же огромное спасибо Gerald за организацию нашей работы, MikeMirzayanov за отличную систему и Delinur за перевод условий.Надеюсь, что в этом раунде будет решено больше задач, чем в нашем предыдущем. Удачи!Обратите внимание, раунд будет проведен в нестандартное время.Разбалловка:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500Поздравляю победителей.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Разбор на русском: здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 786
        },
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Всем привет! Этот раунд готовим я и KAN. Надеюсь, многим понравятся наши задачи.Хочу сказать спасибо PavelKunyavskiy, который тестировал задачи, вычитывал условия и вообще помог. Еще раунд решали alger95, Skird, fdoer, sand-martin, спасибо им за это.Конечно же огромное спасибо Gerald за организацию нашей работы, MikeMirzayanov за отличную систему и Delinur за перевод условий.Надеюсь, что в этом раунде будет решено больше задач, чем в нашем предыдущем. Удачи!Обратите внимание, раунд будет проведен в нестандартное время.Разбалловка:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500Поздравляю победителей.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Разбор на русском: здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit?usp=sharing",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": "1 2 3 4\n2 1 4 3\n1 4 2 3\n4 2 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": "1 2 3 4\n2 1 4 3\n1 4 2 3\n4 2 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": "1 2 3 4\n  2 1 4 3\n    1 4 2 3\n      4 2 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": "1 2 3 4\n  2 1 4 3\n    1 4 2 3\n      4 2 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 19",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 20",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 21",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 22",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": "1 2 3 4\n2 1 4 3\n1 4 2 3\n4 2 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": "1 2 3 4\n2 1 4 3\n1 4 2 3\n4 2 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": "1 2 3 4\n  2 1 4 3\n    1 4 2 3\n      4 2 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": "1 2 3 4\n  2 1 4 3\n    1 4 2 3\n      4 2 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 19",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 20",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 21",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 22",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(0, 999999999, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, 1000000000, \"r_i\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"t_i\");\n        inf.readEoln();\n    }\n\n    if(n > 0) {\n        vector<int> q(n);\n        q[0] = inf.readInt(0, 1000000000, \"q1\");\n        for(int i = 1; i < n; ++i) {\n            inf.readSpace();\n            q[i] = inf.readInt(0, 1000000000, \"q\");\n            ensuref(q[i] > q[i-1], \"q[%d]=%d must be greater than q[%d]=%d\", i+1, q[i], i, q[i-1]);\n        }\n        inf.readEoln();\n    } else {\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(0, 999999999, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, 1000000000, \"r_i\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"t_i\");\n        inf.readEoln();\n    }\n\n    if(n > 0) {\n        vector<int> q(n);\n        q[0] = inf.readInt(0, 1000000000, \"q1\");\n        for(int i = 1; i < n; ++i) {\n            inf.readSpace();\n            q[i] = inf.readInt(0, 1000000000, \"q\");\n            ensuref(q[i] > q[i-1], \"q[%d]=%d must be greater than q[%d]=%d\", i+1, q[i], i, q[i-1]);\n        }\n        inf.readEoln();\n    } else {\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(0, 999999999, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, 1000000000, \"r_i\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"t_i\");\n        inf.readEoln();\n    }\n\n    if(n > 0) {\n        vector<int> q(n);\n        q[0] = inf.readInt(0, 1000000000, \"q1\");\n        for(int i = 1; i < n; ++i) {\n            inf.readSpace();\n            q[i] = inf.readInt(0, 1000000000, \"q\");\n            ensuref(q[i] > q[i-1], \"q[%d]=%d must be greater than q[%d]=%d\", i+1, q[i], i, q[i-1]);\n        }\n        inf.readEoln();\n    } else {\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Maximum values for the problem constraints\nconst int MAX_NM = 100000;\nconst int MAX_COORD = 1000000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> q; // Times when pairs of tourists start walking\n    vector<tuple<int, int, int>> walls; // Walls defined as (li, ri, ti)\n\n    if (type == \"random\") {\n        // Generate n distinct random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n        sort(q.begin(), q.end());\n\n        // Generate m random walls\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n    } else if (type == \"walls_cover_all\") {\n        // Generate walls that cover the entire path\n        for (int i = 0; i < m; ++i) {\n            int li = 0;\n            int ri = MAX_COORD;\n            int ti = 0;\n            walls.emplace_back(li, ri, ti);\n        }\n        // Generate n random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n    } else if (type == \"walls_no_effect\") {\n        // Generate walls that will not affect tourists\n        for (int i = 0; i < m; ++i) {\n            int li = -rnd.next(1, MAX_COORD);\n            int ri = li + rnd.next(1, MAX_COORD / 2);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n        // Generate n random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n    } else if (type == \"walls_zero_length\") {\n        // Generate walls with zero length (li == ri)\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD);\n            int ri = li; // Zero length wall\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n        // Generate n random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n    } else if (type == \"walls_overlap\") {\n        // Generate walls that completely overlap\n        int li = rnd.next(0, MAX_COORD - 1);\n        int ri = rnd.next(li + 1, MAX_COORD);\n        int ti = rnd.next(0, MAX_COORD);\n        for (int i = 0; i < m; ++i) {\n            walls.emplace_back(li, ri, ti);\n        }\n        // Generate n random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n    } else if (type == \"walls_at_qi\") {\n        // Generate walls that appear at the same times as qi\n        // Generate n distinct random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n\n        // Use qi times for wall appearance times\n        int wall_times_count = min(m, n);\n        for (int i = 0; i < wall_times_count; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = q[i];\n            walls.emplace_back(li, ri, ti);\n        }\n        // If m > n, generate more walls with random times\n        for (int i = wall_times_count; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n    } else if (type == \"max_n_m\") {\n        n = MAX_NM;\n        m = MAX_NM;\n\n        // Generate n sequential starting times qi\n        q.resize(n);\n        for (int i = 0; i < n; ++i) {\n            q[i] = i;\n        }\n\n        // Generate m random walls\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n    } else {\n        // Default to random data\n        // Generate n distinct random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n        sort(q.begin(), q.end());\n\n        // Generate m random walls\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n    }\n\n    // Output the generated data\n    printf(\"%d %d\\n\", n, m);\n    for (const auto& wall : walls) {\n        int li, ri, ti;\n        std::tie(li, ri, ti) = wall;\n        printf(\"%d %d %d\\n\", li, ri, ti);\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", q[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Maximum values for the problem constraints\nconst int MAX_NM = 100000;\nconst int MAX_COORD = 1000000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> q; // Times when pairs of tourists start walking\n    vector<tuple<int, int, int>> walls; // Walls defined as (li, ri, ti)\n\n    if (type == \"random\") {\n        // Generate n distinct random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n        sort(q.begin(), q.end());\n\n        // Generate m random walls\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n    } else if (type == \"walls_cover_all\") {\n        // Generate walls that cover the entire path\n        for (int i = 0; i < m; ++i) {\n            int li = 0;\n            int ri = MAX_COORD;\n            int ti = 0;\n            walls.emplace_back(li, ri, ti);\n        }\n        // Generate n random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n    } else if (type == \"walls_no_effect\") {\n        // Generate walls that will not affect tourists\n        for (int i = 0; i < m; ++i) {\n            int li = -rnd.next(1, MAX_COORD);\n            int ri = li + rnd.next(1, MAX_COORD / 2);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n        // Generate n random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n    } else if (type == \"walls_zero_length\") {\n        // Generate walls with zero length (li == ri)\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD);\n            int ri = li; // Zero length wall\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n        // Generate n random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n    } else if (type == \"walls_overlap\") {\n        // Generate walls that completely overlap\n        int li = rnd.next(0, MAX_COORD - 1);\n        int ri = rnd.next(li + 1, MAX_COORD);\n        int ti = rnd.next(0, MAX_COORD);\n        for (int i = 0; i < m; ++i) {\n            walls.emplace_back(li, ri, ti);\n        }\n        // Generate n random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n    } else if (type == \"walls_at_qi\") {\n        // Generate walls that appear at the same times as qi\n        // Generate n distinct random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n\n        // Use qi times for wall appearance times\n        int wall_times_count = min(m, n);\n        for (int i = 0; i < wall_times_count; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = q[i];\n            walls.emplace_back(li, ri, ti);\n        }\n        // If m > n, generate more walls with random times\n        for (int i = wall_times_count; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n    } else if (type == \"max_n_m\") {\n        n = MAX_NM;\n        m = MAX_NM;\n\n        // Generate n sequential starting times qi\n        q.resize(n);\n        for (int i = 0; i < n; ++i) {\n            q[i] = i;\n        }\n\n        // Generate m random walls\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n    } else {\n        // Default to random data\n        // Generate n distinct random starting times qi\n        set<int> q_set;\n        while ((int)q_set.size() < n) {\n            int t = rnd.next(0, MAX_COORD);\n            q_set.insert(t);\n        }\n        q.assign(q_set.begin(), q_set.end());\n        sort(q.begin(), q.end());\n\n        // Generate m random walls\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(0, MAX_COORD - 1);\n            int ri = rnd.next(li + 1, MAX_COORD);\n            int ti = rnd.next(0, MAX_COORD);\n            walls.emplace_back(li, ri, ti);\n        }\n    }\n\n    // Output the generated data\n    printf(\"%d %d\\n\", n, m);\n    for (const auto& wall : walls) {\n        int li, ri, ti;\n        std::tie(li, ri, ti) = wall;\n        printf(\"%d %d %d\\n\", li, ri, ti);\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", q[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 10 -m 5 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 50000 -m 50000 -type random\n./gen -n 99999 -m 99999 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 1 -m 1 -type walls_cover_all\n./gen -n 10 -m 5 -type walls_cover_all\n./gen -n 50 -m 1 -type walls_cover_all\n./gen -n 1000 -m 10 -type walls_cover_all\n./gen -n 100000 -m 100000 -type walls_cover_all\n\n./gen -n 1 -m 1 -type walls_no_effect\n./gen -n 10 -m 5 -type walls_no_effect\n./gen -n 100 -m 50 -type walls_no_effect\n./gen -n 1000 -m 1000 -type walls_no_effect\n./gen -n 100000 -m 100000 -type walls_no_effect\n\n./gen -n 1 -m 1 -type walls_zero_length\n./gen -n 2 -m 2 -type walls_zero_length\n./gen -n 10 -m 10 -type walls_zero_length\n./gen -n 100 -m 100 -type walls_zero_length\n./gen -n 1000 -m 1000 -type walls_zero_length\n./gen -n 100000 -m 100000 -type walls_zero_length\n\n./gen -n 1 -m 1 -type walls_overlap\n./gen -n 10 -m 10 -type walls_overlap\n./gen -n 1000 -m 1000 -type walls_overlap\n./gen -n 100000 -m 100000 -type walls_overlap\n\n./gen -n 1 -m 1 -type walls_at_qi\n./gen -n 10 -m 10 -type walls_at_qi\n./gen -n 100 -m 100 -type walls_at_qi\n./gen -n 1000 -m 1000 -type walls_at_qi\n./gen -n 100000 -m 100000 -type walls_at_qi\n\n./gen -n 1 -m 1 -type max_n_m\n./gen -n 100000 -m 100000 -type max_n_m\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:29.916896",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "286/E",
      "title": "E. Ladies' Shop",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test8 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains space-separated integers n and m (1 ≤ n, m ≤ 106). The second line contains n distinct space-separated integers a1, a2, ..., an (1 ≤ a1 < a2 < ... < an ≤ m) — the bags' weight limits.",
      "output_spec": "OutputIn the first line print \"NO\" (without the quotes) if there isn't set pi, that would meet the conditions.Otherwise, in the first line print \"YES\" (without the quotes), in the second line print an integer k (showing how many numbers are in the suitable set with the minimum number of weights), in the third line print k space-separated integers p1, p2, ..., pk (1 ≤ p1 < p2 < ... < pk). If there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy6 105 6 7 8 9 10OutputCopyYES55 6 7 8 9 InputCopy1 101OutputCopyNOInputCopy1 106OutputCopyYES16",
      "description": "E. Ladies' Shop\n\ntime limit per test8 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains space-separated integers n and m (1 ≤ n, m ≤ 106). The second line contains n distinct space-separated integers a1, a2, ..., an (1 ≤ a1 < a2 < ... < an ≤ m) — the bags' weight limits.\n\nOutputIn the first line print \"NO\" (without the quotes) if there isn't set pi, that would meet the conditions.Otherwise, in the first line print \"YES\" (without the quotes), in the second line print an integer k (showing how many numbers are in the suitable set with the minimum number of weights), in the third line print k space-separated integers p1, p2, ..., pk (1 ≤ p1 < p2 < ... < pk). If there are multiple solutions, print any of them.\n\nInputCopy6 105 6 7 8 9 10OutputCopyYES55 6 7 8 9 InputCopy1 101OutputCopyNOInputCopy1 106OutputCopyYES16\n\nInputCopy6 105 6 7 8 9 10\n\nOutputCopyYES55 6 7 8 9\n\nInputCopy1 101\n\nOutputCopyNO\n\nInputCopy1 106\n\nOutputCopyYES16",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit?usp=sharing",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    int prev_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, m, format(\"a[%d]\", i + 1));\n        if (i > 0) {\n            ensuref(prev_ai < ai,\n                \"Sequence a_i must be strictly increasing: a[%d] = %d, a[%d] = %d\",\n                i, prev_ai, i + 1, ai);\n        }\n        prev_ai = ai;\n\n        if (i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    int prev_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, m, format(\"a[%d]\", i + 1));\n        if (i > 0) {\n            ensuref(prev_ai < ai,\n                \"Sequence a_i must be strictly increasing: a[%d] = %d, a[%d] = %d\",\n                i, prev_ai, i + 1, ai);\n        }\n        prev_ai = ai;\n\n        if (i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    int prev_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, m, format(\"a[%d]\", i + 1));\n        if (i > 0) {\n            ensuref(prev_ai < ai,\n                \"Sequence a_i must be strictly increasing: a[%d] = %d, a[%d] = %d\",\n                i, prev_ai, i + 1, ai);\n        }\n        prev_ai = ai;\n\n        if (i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\");\n\n    vector<int> a;\n\n    if (type == \"consecutive\") {\n        // Generate consecutive a_i's starting from a random number\n        int max_start = m - n + 1;\n        int start = rnd.next(1, max_start <= 0 ? 1 : max_start);\n        for (int i = 0; i < n; ++i) {\n            a.push_back(start + i);\n        }\n    }\n    else if (type == \"maximum\") {\n        // n = m = 1e6\n        n = m = 1000000;\n        for (int i = 1; i <= n; ++i) {\n            a.push_back(i);\n        }\n    }\n    else if (type == \"random\") {\n        set<int> s;\n        while ((int)s.size() < n) {\n            int num = rnd.next(1, m);\n            s.insert(num);\n        }\n        a.assign(s.begin(), s.end());\n        sort(a.begin(), a.end());\n    }\n    else if (type == \"no\") {\n        // Generate a test case where answer is NO\n        if (n == 1) {\n            a.push_back(1); // As per sample input\n        } else {\n            // Try to create gaps in a_i's \n            int curr = 1;\n            for (int i = 0; i < n; ++i) {\n                a.push_back(curr);\n                curr += rnd.next(2, 5); // Gaps of at least 2\n                if (curr > m) break;\n            }\n            n = a.size();\n        }\n    }\n    else if (type == \"yes\") {\n        // Generate a test case where answer is YES\n        set<int> s;\n        while ((int)s.size() < n) {\n            int num = rnd.next(1, m);\n            s.insert(num);\n        }\n        a.assign(s.begin(), s.end());\n        sort(a.begin(), a.end());\n    }\n    else if (type == \"minimal_k\") {\n        // Try to have minimal k=1\n        a.push_back(rnd.next(1, m));\n        n = 1;\n    }\n    else if (type == \"maximal_k\") {\n        // Try to force minimal k as large as possible\n        a.clear();\n        for (int i = 1; i <= n && i <= m; ++i) {\n            a.push_back(i);\n        }\n        n = a.size();\n    }\n\n    // Ensure a_i's are within [1, m] and sorted\n    for (int i = 0; i < n; ++i) {\n        if (a[i] < 1) a[i] = 1;\n        if (a[i] > m) a[i] = m;\n    }\n    sort(a.begin(), a.end());\n    a.erase(unique(a.begin(), a.end()), a.end());\n    n = a.size();\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output a_i's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 != n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\");\n\n    vector<int> a;\n\n    if (type == \"consecutive\") {\n        // Generate consecutive a_i's starting from a random number\n        int max_start = m - n + 1;\n        int start = rnd.next(1, max_start <= 0 ? 1 : max_start);\n        for (int i = 0; i < n; ++i) {\n            a.push_back(start + i);\n        }\n    }\n    else if (type == \"maximum\") {\n        // n = m = 1e6\n        n = m = 1000000;\n        for (int i = 1; i <= n; ++i) {\n            a.push_back(i);\n        }\n    }\n    else if (type == \"random\") {\n        set<int> s;\n        while ((int)s.size() < n) {\n            int num = rnd.next(1, m);\n            s.insert(num);\n        }\n        a.assign(s.begin(), s.end());\n        sort(a.begin(), a.end());\n    }\n    else if (type == \"no\") {\n        // Generate a test case where answer is NO\n        if (n == 1) {\n            a.push_back(1); // As per sample input\n        } else {\n            // Try to create gaps in a_i's \n            int curr = 1;\n            for (int i = 0; i < n; ++i) {\n                a.push_back(curr);\n                curr += rnd.next(2, 5); // Gaps of at least 2\n                if (curr > m) break;\n            }\n            n = a.size();\n        }\n    }\n    else if (type == \"yes\") {\n        // Generate a test case where answer is YES\n        set<int> s;\n        while ((int)s.size() < n) {\n            int num = rnd.next(1, m);\n            s.insert(num);\n        }\n        a.assign(s.begin(), s.end());\n        sort(a.begin(), a.end());\n    }\n    else if (type == \"minimal_k\") {\n        // Try to have minimal k=1\n        a.push_back(rnd.next(1, m));\n        n = 1;\n    }\n    else if (type == \"maximal_k\") {\n        // Try to force minimal k as large as possible\n        a.clear();\n        for (int i = 1; i <= n && i <= m; ++i) {\n            a.push_back(i);\n        }\n        n = a.size();\n    }\n\n    // Ensure a_i's are within [1, m] and sorted\n    for (int i = 0; i < n; ++i) {\n        if (a[i] < 1) a[i] = 1;\n        if (a[i] > m) a[i] = m;\n    }\n    sort(a.begin(), a.end());\n    a.erase(unique(a.begin(), a.end()), a.end());\n    n = a.size();\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output a_i's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 != n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 10 -type minimal_k\n./gen -n 1 -m 1000000 -type minimal_k\n./gen -n 10 -m 10 -type consecutive\n./gen -n 100 -m 100 -type consecutive\n./gen -n 1000 -m 1000 -type consecutive\n./gen -n 100000 -m 1000000 -type consecutive\n\n./gen -n 1 -m 10 -type no\n./gen -n 1 -m 1000000 -type no\n./gen -n 100 -m 1000 -type no\n./gen -n 1000 -m 10000 -type no\n./gen -n 100000 -m 1000000 -type no\n\n./gen -n 10 -m 10 -type yes\n./gen -n 100 -m 100 -type yes\n./gen -n 1000 -m 1000 -type yes\n./gen -n 100000 -m 1000000 -type yes\n\n./gen -n 1000 -m 10000 -type random\n./gen -n 10000 -m 100000 -type random\n./gen -n 100000 -m 1000000 -type random\n\n./gen -n 100000 -m 1000000 -type maximal_k\n\n./gen -n 1 -m 1 -type minimal_k\n\n./gen -n 500000 -m 1000000 -type maximal_k\n\n./gen -n 1 -m 1 -type no\n\n./gen -n 2 -m 1000 -type minimal_k\n\n./gen -n 2 -m 1000 -type yes\n\n./gen -n 2 -m 1000 -type no\n\n./gen -n 1 -m 500000 -type minimal_k\n\n./gen -n 1 -m 500000 -type no\n\n./gen -n 100 -m 500000 -type yes\n\n./gen -n 1000000 -m 1000000 -type maximum\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:32.075292",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "287/A",
      "title": "A. IQ Test",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFour lines contain four characters each: the j-th character of the i-th line equals \".\" if the cell in the i-th row and the j-th column of the square is painted white, and \"#\", if the cell is black.",
      "output_spec": "OutputPrint \"YES\" (without the quotes), if the test can be passed and \"NO\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy####.#..####....OutputCopyYESInputCopy####....####....OutputCopyNO",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFour lines contain four characters each: the j-th character of the i-th line equals \".\" if the cell in the i-th row and the j-th column of the square is painted white, and \"#\", if the cell is black.\n\nOutputPrint \"YES\" (without the quotes), if the test can be passed and \"NO\" (without the quotes) otherwise.\n\nInputCopy####.#..####....OutputCopyYESInputCopy####....####....OutputCopyNO\n\nInputCopy####.#..####....\n\nOutputCopyYES\n\nInputCopy####....####....\n\nOutputCopyNO\n\nNoteIn the first test sample it is enough to repaint the first cell in the second row. After such repainting the required 2 × 2 square is on the intersection of the 1-st and 2-nd row with the 1-st and 2-nd column.",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 4; ++i) {\n        string s = inf.readLine(\"[.#]{4}\", \"line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 4; ++i) {\n        string s = inf.readLine(\"[.#]{4}\", \"line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 4; ++i) {\n        string s = inf.readLine(\"[.#]{4}\", \"line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly one test case for the 4×4 IQ test problem.\n  It reads:\n    --type <string>    (default: \"random\")\n    --pblack <int>     (default: 50)\n\n  Possible types:\n    1) \"all_black\"     -> All cells are '#'\n    2) \"all_white\"     -> All cells are '.'\n    3) \"first_sample\"  -> The first sample from the statement (leading to \"YES\")\n    4) \"second_sample\" -> The second sample from the statement (leading to \"NO\")\n    5) \"impossible\"    -> Standard checkerboard that cannot form a 2×2 block\n                          of the same color even after one flip\n    6) \"random\"        -> Each cell is '#' with probability pblack%, '.' otherwise\n\n  The output is always 4 lines of 4 characters each, using '.' or '#'.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    string type = opt<string>(\"type\", \"random\");\n    int pBlack   = opt<int>(\"pblack\", 50); // used only if type == \"random\"\n\n    // Prepare a 4×4 grid (strings of length 4)\n    vector<string> grid(4, string(4, '.'));\n\n    if (type == \"all_black\") {\n        /*\n          All cells are '#'\n        */\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                grid[i][j] = '#';\n            }\n        }\n    }\n    else if (type == \"all_white\") {\n        /*\n          All cells are '.'\n          (grid is already initialized to '.' by default)\n        */\n        ; // do nothing; it's already all '.'\n    }\n    else if (type == \"first_sample\") {\n        /*\n          The first example from the problem statement:\n            ####\n            .#..\n            ####\n            ....\n          This leads to \"YES\" after flipping a certain cell.\n        */\n        // row 0\n        grid[0] = \"####\";\n        // row 1\n        grid[1] = \".#..\";\n        // row 2\n        grid[2] = \"####\";\n        // row 3\n        grid[3] = \"....\";\n    }\n    else if (type == \"second_sample\") {\n        /*\n          The second example from the problem statement:\n            ####\n            ....\n            ####\n            ....\n          This leads to \"NO\".\n        */\n        grid[0] = \"####\";\n        grid[1] = \"....\";\n        grid[2] = \"####\";\n        grid[3] = \"....\";\n    }\n    else if (type == \"impossible\") {\n        /*\n          A standard checkerboard that, even after flipping one cell,\n          cannot yield a 2×2 block of the same color. For example:\n            #.#.\n            .#.#\n            #.#.\n            .#.#\n        */\n        grid[0] = \"#.#.\";\n        grid[1] = \".#.#\";\n        grid[2] = \"#.#.\";\n        grid[3] = \".#.#\";\n    }\n    else {\n        /*\n          \"random\": generate each cell with probability pBlack% to be '#', \n                    otherwise '.' using the testlib rnd.\n        */\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                int r = rnd.next(100);\n                if (r < pBlack) {\n                    grid[i][j] = '#';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n\n    // Print out the resulting 4×4 grid\n    for (int i = 0; i < 4; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly one test case for the 4×4 IQ test problem.\n  It reads:\n    --type <string>    (default: \"random\")\n    --pblack <int>     (default: 50)\n\n  Possible types:\n    1) \"all_black\"     -> All cells are '#'\n    2) \"all_white\"     -> All cells are '.'\n    3) \"first_sample\"  -> The first sample from the statement (leading to \"YES\")\n    4) \"second_sample\" -> The second sample from the statement (leading to \"NO\")\n    5) \"impossible\"    -> Standard checkerboard that cannot form a 2×2 block\n                          of the same color even after one flip\n    6) \"random\"        -> Each cell is '#' with probability pblack%, '.' otherwise\n\n  The output is always 4 lines of 4 characters each, using '.' or '#'.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    string type = opt<string>(\"type\", \"random\");\n    int pBlack   = opt<int>(\"pblack\", 50); // used only if type == \"random\"\n\n    // Prepare a 4×4 grid (strings of length 4)\n    vector<string> grid(4, string(4, '.'));\n\n    if (type == \"all_black\") {\n        /*\n          All cells are '#'\n        */\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                grid[i][j] = '#';\n            }\n        }\n    }\n    else if (type == \"all_white\") {\n        /*\n          All cells are '.'\n          (grid is already initialized to '.' by default)\n        */\n        ; // do nothing; it's already all '.'\n    }\n    else if (type == \"first_sample\") {\n        /*\n          The first example from the problem statement:\n            ####\n            .#..\n            ####\n            ....\n          This leads to \"YES\" after flipping a certain cell.\n        */\n        // row 0\n        grid[0] = \"####\";\n        // row 1\n        grid[1] = \".#..\";\n        // row 2\n        grid[2] = \"####\";\n        // row 3\n        grid[3] = \"....\";\n    }\n    else if (type == \"second_sample\") {\n        /*\n          The second example from the problem statement:\n            ####\n            ....\n            ####\n            ....\n          This leads to \"NO\".\n        */\n        grid[0] = \"####\";\n        grid[1] = \"....\";\n        grid[2] = \"####\";\n        grid[3] = \"....\";\n    }\n    else if (type == \"impossible\") {\n        /*\n          A standard checkerboard that, even after flipping one cell,\n          cannot yield a 2×2 block of the same color. For example:\n            #.#.\n            .#.#\n            #.#.\n            .#.#\n        */\n        grid[0] = \"#.#.\";\n        grid[1] = \".#.#\";\n        grid[2] = \"#.#.\";\n        grid[3] = \".#.#\";\n    }\n    else {\n        /*\n          \"random\": generate each cell with probability pBlack% to be '#', \n                    otherwise '.' using the testlib rnd.\n        */\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                int r = rnd.next(100);\n                if (r < pBlack) {\n                    grid[i][j] = '#';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n\n    // Print out the resulting 4×4 grid\n    for (int i = 0; i < 4; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below is a set of ~20-30 example commands to invoke this generator.\n# Each command will print exactly one 4×4 test input to the standard output.\n\n# 1) Special patterns that are easy to check\n./gen -type all_black\n./gen -type all_white\n./gen -type first_sample\n./gen -type second_sample\n./gen -type impossible\n\n# 2) Random patterns with various percentages of black cells\n./gen -type random -pblack 0\n./gen -type random -pblack 25\n./gen -type random -pblack 50\n./gen -type random -pblack 75\n./gen -type random -pblack 100\n\n# 3) Repeat random patterns to produce additional distinct tests\n./gen -type random -pblack 30\n./gen -type random -pblack 30\n./gen -type random -pblack 30\n\n./gen -type random -pblack 60\n./gen -type random -pblack 60\n./gen -type random -pblack 60\n\n./gen -type random -pblack 10\n./gen -type random -pblack 10\n./gen -type random -pblack 10\n\n./gen -type random -pblack 90\n./gen -type random -pblack 90\n./gen -type random -pblack 90\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:34.218065",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "287/B",
      "title": "B. Pipeline",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.",
      "sample_tests": "ExamplesInputCopy4 3OutputCopy2InputCopy5 5OutputCopy1InputCopy8 4OutputCopy-1",
      "description": "B. Pipeline\n\ntime limit per test0.4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.\n\nInputCopy4 3OutputCopy2InputCopy5 5OutputCopy1InputCopy8 4OutputCopy-1\n\nInputCopy4 3\n\nOutputCopy2\n\nInputCopy5 5\n\nOutputCopy1\n\nInputCopy8 4\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\");\n    long long n_max = opt<long long>(\"n_max\", (long long)1e18);\n    int k_max = opt<int>(\"k_max\", (int)1e9);\n    \n    long long n;\n    int k;\n\n    if (type == \"small\") {\n        n = rnd.next(1LL, min(n_max, 1000LL));\n        k = rnd.next(2, min(k_max, 1000));\n    } else if (type == \"large\") {\n        n = rnd.next(max(1LL, n_max / 10), n_max);\n        k = rnd.next(max(2, k_max / 10), k_max);\n    } else if (type == \"max\") {\n        n = min(n_max, (long long)1e18);\n        k = min(k_max, (int)1e9);\n    } else if (type == \"equal\") {\n        n = rnd.next(2LL, n_max);\n        k = int(min((long long)k_max, n));\n    } else if (type == \"impossible\") {\n        k = rnd.next(2, k_max);\n\n        // Calculate maximum possible number of pipes\n        long long max_pipes = 1 + (long long)(k - 1) * k / 2;\n        n = max_pipes + rnd.next(1LL, max(1LL, n_max - max_pipes));\n\n        if (n > n_max) n = n_max;\n    } else if (type == \"random\") {\n        n = rnd.next(1LL, n_max);\n        k = rnd.next(2, k_max);\n    } else {\n        // Default case: generate random test case\n        n = rnd.next(1LL, n_max);\n        k = rnd.next(2, k_max);\n    }\n\n    // Output n and k\n    cout << n << \" \" << k << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\");\n    long long n_max = opt<long long>(\"n_max\", (long long)1e18);\n    int k_max = opt<int>(\"k_max\", (int)1e9);\n    \n    long long n;\n    int k;\n\n    if (type == \"small\") {\n        n = rnd.next(1LL, min(n_max, 1000LL));\n        k = rnd.next(2, min(k_max, 1000));\n    } else if (type == \"large\") {\n        n = rnd.next(max(1LL, n_max / 10), n_max);\n        k = rnd.next(max(2, k_max / 10), k_max);\n    } else if (type == \"max\") {\n        n = min(n_max, (long long)1e18);\n        k = min(k_max, (int)1e9);\n    } else if (type == \"equal\") {\n        n = rnd.next(2LL, n_max);\n        k = int(min((long long)k_max, n));\n    } else if (type == \"impossible\") {\n        k = rnd.next(2, k_max);\n\n        // Calculate maximum possible number of pipes\n        long long max_pipes = 1 + (long long)(k - 1) * k / 2;\n        n = max_pipes + rnd.next(1LL, max(1LL, n_max - max_pipes));\n\n        if (n > n_max) n = n_max;\n    } else if (type == \"random\") {\n        n = rnd.next(1LL, n_max);\n        k = rnd.next(2, k_max);\n    } else {\n        // Default case: generate random test case\n        n = rnd.next(1LL, n_max);\n        k = rnd.next(2, k_max);\n    }\n\n    // Output n and k\n    cout << n << \" \" << k << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type small -n_max 10 -k_max 5\n./gen -type small -n_max 10 -k_max 2\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type large -n_max 1000000000000 -k_max 1000000\n./gen -type large -n_max 1000000000000000 -k_max 100000\n\n./gen -type max\n./gen -type max -n_max 1000000000000000000 -k_max 1000000000\n\n./gen -type equal\n./gen -type equal\n./gen -type equal -n_max 1000000\n\n./gen -type impossible\n./gen -type impossible\n./gen -type impossible -n_max 10000000000000000 -k_max 1000000\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type random -n_max 1000000000 -k_max 100000\n\n./gen -type small\n./gen -type small\n./gen -type large\n./gen -type large\n./gen -type equal\n./gen -type equal\n./gen -type impossible\n./gen -type impossible\n./gen -type random\n./gen -type random\n./gen -type random -n_max 10000 -k_max 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:36.321124",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "287/C",
      "title": "C. Lucky Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the required permutation size.",
      "output_spec": "OutputPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.Otherwise, print n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) after a space — the required permutation.If there are multiple answers, you can print any of them.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1 InputCopy2OutputCopy-1InputCopy4OutputCopy2 4 1 3 InputCopy5OutputCopy2 5 3 1 4",
      "description": "C. Lucky Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the required permutation size.\n\nOutputPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.Otherwise, print n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) after a space — the required permutation.If there are multiple answers, you can print any of them.\n\nInputCopy1OutputCopy1 InputCopy2OutputCopy-1InputCopy4OutputCopy2 4 1 3 InputCopy5OutputCopy2 5 3 1 4\n\nOutputCopy1\n\nOutputCopy-1\n\nOutputCopy2 4 1 3\n\nOutputCopy2 5 3 1 4",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n\n    string jury_first_token = ans.readToken();\n\n    string participant_first_token = ouf.readToken();\n\n    if (jury_first_token == \"-1\") {\n        // No solution exists\n        if (participant_first_token != \"-1\") {\n            quitf(_wa, \"Contestant reports a solution exists, but the jury says no solution exists.\");\n        } else {\n            // Check for extra output after '-1'\n            if (!ouf.seekEof()) {\n                quitf(_wa, \"Contestant outputs extra data after '-1'.\");\n            } else {\n                quitf(_ok, \"No solution exists and contestant correctly outputs '-1'.\");\n            }\n        }\n    } else {\n        // Jury's answer is a permutation\n\n        if (participant_first_token == \"-1\") {\n            quitf(_wa, \"Contestant reports no solution exists, but the jury provides a solution.\");\n        }\n\n        // Read participant's permutation\n        vector<int> p(n);\n\n        int first_pi = atoi(participant_first_token.c_str());\n\n        if (first_pi < 1 || first_pi > n) {\n            quitf(_wa, \"First number in participant's output is out of range [1, %d]: %d\", n, first_pi);\n        }\n\n        p[0] = first_pi;\n\n        for (int i = 1; i < n; ++i) {\n            p[i] = ouf.readInt(1, n, format(\"p[%d]\", i + 1).c_str());\n        }\n\n        // Check for extra output after permutation\n        if (!ouf.seekEof()) {\n            quitf(_wa, \"Participant's output contains extra data after the permutation.\");\n        }\n\n        // Check that all elements are distinct\n        vector<bool> used(n + 1, false);\n        used[p[0]] = true;\n\n        for (int i = 1; i < n; ++i) {\n            int pi = p[i];\n            if (used[pi]) {\n                quitf(_wa, \"Number %d appears more than once in participant's output.\", pi);\n            }\n            used[pi] = true;\n        }\n\n        // Check the condition p_{p_i} = n - i + 1\n        for (int i = 0; i < n; ++i) {\n            int pi = p[i];\n            int p_pi = p[pi - 1];\n\n            int expected = n - i;\n\n            if (p_pi != expected) {\n                quitf(_wa, \"At position %d, p_p[%d] = %d, expected %d\", i + 1, i + 1, p_pi, expected);\n            }\n        }\n\n        quitf(_ok, \"Participant's output is a valid lucky permutation.\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", -1);\n    if (n == -1) {\n        string type = opt<string>(\"type\", \"random\");\n        if (type == \"min\") {\n            /* n = 1 */\n            n = 1;\n        } else if (type == \"no_solution\") {\n            /* n = 2, no solution exists */\n            n = 2;\n        } else if (type == \"max\") {\n            /* n = 100000 */\n            n = 100000;\n        } else if (type == \"even\") {\n            /* n is even */\n            int min_n = opt<int>(\"min_n\", 2);\n            int max_n = opt<int>(\"max_n\", 100000);\n            n = rnd.next(min_n / 2, max_n / 2) * 2; // Ensure n is even\n        } else if (type == \"odd\") {\n            /* n is odd */\n            int min_n = opt<int>(\"min_n\", 1);\n            int max_n = opt<int>(\"max_n\", 99999);\n            n = rnd.next((min_n + 1) / 2, (max_n + 1) / 2) * 2 - 1; // Ensure n is odd\n        } else if (type == \"big_random\") {\n            /* n is random between 99990 and 100000 */\n            n = rnd.next(99990, 100000);\n        } else {\n            /* Random n between min_n and max_n */\n            int min_n = opt<int>(\"min_n\", 1);\n            int max_n = opt<int>(\"max_n\", 100000);\n            n = rnd.next(min_n, max_n);\n        }\n    }\n    /* Output n */\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", -1);\n    if (n == -1) {\n        string type = opt<string>(\"type\", \"random\");\n        if (type == \"min\") {\n            /* n = 1 */\n            n = 1;\n        } else if (type == \"no_solution\") {\n            /* n = 2, no solution exists */\n            n = 2;\n        } else if (type == \"max\") {\n            /* n = 100000 */\n            n = 100000;\n        } else if (type == \"even\") {\n            /* n is even */\n            int min_n = opt<int>(\"min_n\", 2);\n            int max_n = opt<int>(\"max_n\", 100000);\n            n = rnd.next(min_n / 2, max_n / 2) * 2; // Ensure n is even\n        } else if (type == \"odd\") {\n            /* n is odd */\n            int min_n = opt<int>(\"min_n\", 1);\n            int max_n = opt<int>(\"max_n\", 99999);\n            n = rnd.next((min_n + 1) / 2, (max_n + 1) / 2) * 2 - 1; // Ensure n is odd\n        } else if (type == \"big_random\") {\n            /* n is random between 99990 and 100000 */\n            n = rnd.next(99990, 100000);\n        } else {\n            /* Random n between min_n and max_n */\n            int min_n = opt<int>(\"min_n\", 1);\n            int max_n = opt<int>(\"max_n\", 100000);\n            n = rnd.next(min_n, max_n);\n        }\n    }\n    /* Output n */\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen --n 1\n./gen --n 2\n./gen --n 3\n./gen --n 4\n./gen --n 5\n./gen --n 6\n./gen --n 7\n./gen --n 8\n./gen --n 9\n./gen --n 10\n\n./gen --type min\n./gen --type no_solution\n./gen --type max\n\n./gen --type even --min_n 2 --max_n 100\n./gen --type even --min_n 100 --max_n 1000\n./gen --type even --min_n 1000 --max_n 10000\n./gen --type even --min_n 10000 --max_n 100000\n\n./gen --type odd --min_n 1 --max_n 99\n./gen --type odd --min_n 101 --max_n 1000\n./gen --type odd --min_n 1001 --max_n 10000\n./gen --type odd --min_n 10001 --max_n 99999\n\n./gen --type random --min_n 1 --max_n 10\n./gen --type random --min_n 10 --max_n 100\n./gen --type random --min_n 100 --max_n 1000\n./gen --type random --min_n 1000 --max_n 10000\n./gen --type random --min_n 10000 --max_n 100000\n\n./gen --type random --min_n 2 --max_n 2\n./gen --type big_random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:38.170654",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "287/D",
      "title": "D. Shifting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains integer n (2 ≤ n ≤ 106).",
      "output_spec": "OutputPrint n distinct space-separated integers from 1 to n — a beautiful permutation of size n.",
      "sample_tests": "ExamplesInputCopy2OutputCopy2 1 InputCopy3OutputCopy1 3 2 InputCopy4OutputCopy4 2 3 1",
      "description": "D. Shifting\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains integer n (2 ≤ n ≤ 106).\n\nOutputPrint n distinct space-separated integers from 1 to n — a beautiful permutation of size n.\n\nInputCopy2OutputCopy2 1 InputCopy3OutputCopy1 3 2 InputCopy4OutputCopy4 2 3 1\n\nOutputCopy2 1\n\nOutputCopy1 3 2\n\nOutputCopy4 2 3 1\n\nNoteA note to the third test sample:   f([1, 2, 3, 4], 2) = [2, 1, 4, 3]  f([2, 1, 4, 3], 3) = [1, 4, 2, 3]  f([1, 4, 2, 3], 4) = [4, 2, 3, 1]",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // Default value -1 means n is not specified directly\n    int min_n = opt<int>(\"min_n\", 2);\n    int max_n = opt<int>(\"max_n\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Determine n based on the type parameter or use the specified n\n    if (n == -1) {\n        if (type == \"smallest\") {\n            n = 2;\n        } else if (type == \"small\") {\n            n = rnd.next(2, 10);\n        } else if (type == \"medium\") {\n            n = rnd.next(100, 1000);\n        } else if (type == \"large\") {\n            n = rnd.next(100000, 1000000);\n        } else if (type == \"max\") {\n            n = 1000000;\n        } else {\n            // Random n within the specified range\n            n = rnd.next(min_n, max_n);\n        }\n    }\n\n    // Ensure n is within the problem constraints\n    ensure(2 <= n && n <= 1000000);\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // Default value -1 means n is not specified directly\n    int min_n = opt<int>(\"min_n\", 2);\n    int max_n = opt<int>(\"max_n\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Determine n based on the type parameter or use the specified n\n    if (n == -1) {\n        if (type == \"smallest\") {\n            n = 2;\n        } else if (type == \"small\") {\n            n = rnd.next(2, 10);\n        } else if (type == \"medium\") {\n            n = rnd.next(100, 1000);\n        } else if (type == \"large\") {\n            n = rnd.next(100000, 1000000);\n        } else if (type == \"max\") {\n            n = 1000000;\n        } else {\n            // Random n within the specified range\n            n = rnd.next(min_n, max_n);\n        }\n    }\n\n    // Ensure n is within the problem constraints\n    ensure(2 <= n && n <= 1000000);\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n\n./gen -n 9973\n./gen -n 99991\n./gen -n 999983\n\n./gen -n 999999\n./gen -n 1000000\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type medium\n./gen -type medium\n./gen -type medium\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type max\n\n./gen -min_n=2 -max_n=100 -type random\n./gen -min_n=2 -max_n=100 -type random\n./gen -min_n=2 -max_n=100 -type random\n\n./gen -min_n=1000 -max_n=10000 -type random\n./gen -min_n=1000 -max_n=10000 -type random\n\n./gen -min_n=50000 -max_n=100000 -type random\n./gen -min_n=50000 -max_n=100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:40.459631",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "287/E",
      "title": "E. Main Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 106). The second line contains n integers: p1, p2, ..., pn (1 ≤ pi ≤ 109).The third line contains integer t (0 ≤ t ≤ n), followed by t distinct integers q1, q2, ..., qt (1 ≤ qi ≤ n).The numbers in each line are separated by spaces.",
      "output_spec": "OutputPrint a single string \"NO\" (without the quotes) if Vova is mistaken and a suitable sequence {x1, x2, ..., xn} doesn't exist.Otherwise, in the first line print \"YES\" (without the quotes) and in the second line print n integers x1, x2, ..., xn (|xi| = pi; xqj < 0). If there are multiple sequences that correspond to the encrypting, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy21 10OutputCopyYES1 -1InputCopy41 1 1 11 3OutputCopyYES1 1 -1 -1InputCopy31 1 10OutputCopyNOInputCopy41 2 2 12 3 4OutputCopyYES1 2 -2 -1",
      "description": "E. Main Sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 106). The second line contains n integers: p1, p2, ..., pn (1 ≤ pi ≤ 109).The third line contains integer t (0 ≤ t ≤ n), followed by t distinct integers q1, q2, ..., qt (1 ≤ qi ≤ n).The numbers in each line are separated by spaces.\n\nOutputPrint a single string \"NO\" (without the quotes) if Vova is mistaken and a suitable sequence {x1, x2, ..., xn} doesn't exist.Otherwise, in the first line print \"YES\" (without the quotes) and in the second line print n integers x1, x2, ..., xn (|xi| = pi; xqj < 0). If there are multiple sequences that correspond to the encrypting, you are allowed to print any of them.\n\nInputCopy21 10OutputCopyYES1 -1InputCopy41 1 1 11 3OutputCopyYES1 1 -1 -1InputCopy31 1 10OutputCopyNOInputCopy41 2 2 12 3 4OutputCopyYES1 2 -2 -1\n\nInputCopy21 10\n\nOutputCopyYES1 -1\n\nInputCopy41 1 1 11 3\n\nOutputCopyYES1 1 -1 -1\n\nInputCopy31 1 10\n\nOutputCopyNO\n\nInputCopy41 2 2 12 3 4\n\nOutputCopyYES1 2 -2 -1",
      "solutions": [
        {
          "title": "Codeforces Round #176 - Codeforces",
          "content": "Hi all! This round was prepared by me and KAN. I hope, you will enjoy our problems.I want to thank PavelKunyavskiy, who tested our problems, readed statements and so on. Moreover, alger95, Skird, fdoer, sand-martin tested round too, I thank them for it.And of course, I thank Gerald for organising our work, MikeMirzayanov for the great system and Delinur for translation of the statements.I hope, result will be better than results of our previous round. Good luck!Pay attention, round will be held at unusual time.Scoring:div1: 500-1500-1500-2000-2500div2 : 500-1500-1500-2500-2500My congrutulations for leaders.div1: al13n tomek niyaznigmatul voover Egor Zlobober White_Bear seanwu wjmsbmr peter50216 div2: fotiIe96 zfmdhy786 wzc1995 gjh mynameisverylong Full english editorial: here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7104",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Page not found",
          "content": "DriveSorry, the file you have requested does not exist.Make sure that you have the correct URL and that the file exists.Get stuff done with Google DriveApps in Google Drive make it easy to create, store and share online documents, spreadsheets, presentations and more.Learn more at drive.google.com/start/apps.",
          "author": "Unknown",
          "url": "https://docs.google.com/file/d/0B-7EjuzKMd80bWVLeC1BMzhGQm8/edit",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 310
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #176 - Codeforces - Code 1",
          "code": "for (ll i = k - 1; i >= 2; i--) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 2",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 3",
          "code": ".O..\n...O\nO...\n..O.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 4",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 5",
          "code": ".A.......\n........A\n...B.....\n......B..\n....O....\n..B......\n.....B...\nA........\n.......A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 6",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 7",
          "code": "1 -> ? -> 5\n2 -> ? -> 4\n3 -> ? -> 3\n4 -> ? -> 2\n5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 8",
          "code": "1 -> ? -> 5 -> ? -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 9",
          "code": "2 -> ? -> 4 -> ? -> 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 10",
          "code": "1 -> 2 -> 5 -> 4 -> 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 11",
          "code": "3 -> 3 -> 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 12",
          "code": "{#queries, #events, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 13",
          "code": "{#events, #queries, events, queries}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 14",
          "code": "for(int i=1;i<=4;++i)\n{for(int j=1;j<=4;++j)\ncin>>a[i][j];}\n\nfor(int i=1;i<=4;++i)\nfor(int j=1;j<=4;++j)\n{   int c=0;\n    if(a[i][j]==a[i+1][j])\n    c++;\n    if(a[i][j]==a[i][j+1])\n    c++;\n    if(a[i][j]==a[i+1][j+1])\n    c++;\n    if(c==3 || c==2)\n    {cout<<\"YES\";return 0;}\n}\ncout<<\"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 15",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 16",
          "code": ".#.#\n##.#\n....\n####",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 17",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #176 - Codeforces - Code 18",
          "code": "#.#.\n.#.#\n#.#.\n.#..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7104",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h> \n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    \n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p_i\");\n    inf.readEoln();\n    \n    int t = inf.readInt(0, n, \"t\");\n    if (t == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        \n        vector<int> q(t);\n        for (int i = 0; i < t; ++i) {\n            q[i] = inf.readInt(1, n, \"q_i\");\n            if (i < t - 1) {\n                inf.readSpace();\n            }\n        }\n        inf.readEoln();\n        \n        sort(q.begin(), q.end());\n        for (int i = 1; i < t; ++i) {\n            ensuref(q[i] != q[i - 1], \"q_i are not distinct, q[%d]=%d\", i+1, q[i]);\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h> \n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    \n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p_i\");\n    inf.readEoln();\n    \n    int t = inf.readInt(0, n, \"t\");\n    if (t == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        \n        vector<int> q(t);\n        for (int i = 0; i < t; ++i) {\n            q[i] = inf.readInt(1, n, \"q_i\");\n            if (i < t - 1) {\n                inf.readSpace();\n            }\n        }\n        inf.readEoln();\n        \n        sort(q.begin(), q.end());\n        for (int i = 1; i < t; ++i) {\n            ensuref(q[i] != q[i - 1], \"q_i are not distinct, q[%d]=%d\", i+1, q[i]);\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h> \n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    \n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p_i\");\n    inf.readEoln();\n    \n    int t = inf.readInt(0, n, \"t\");\n    if (t == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        \n        vector<int> q(t);\n        for (int i = 0; i < t; ++i) {\n            q[i] = inf.readInt(1, n, \"q_i\");\n            if (i < t - 1) {\n                inf.readSpace();\n            }\n        }\n        inf.readEoln();\n        \n        sort(q.begin(), q.end());\n        for (int i = 1; i < t; ++i) {\n            ensuref(q[i] != q[i - 1], \"q_i are not distinct, q[%d]=%d\", i+1, q[i]);\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    int n = inf.readInt();\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        p[i] = inf.readInt();\n    }\n    int t = inf.readInt();\n    set<int> q;\n    for (int i = 0; i < t; ++i) {\n        int qi = inf.readInt() - 1; // zero-based indexing\n        q.insert(qi);\n    }\n\n    // Read jury's answer from ans\n    string jans = ans.readWord();\n    if (jans != \"YES\" && jans != \"NO\") {\n        quitf(_fail, \"Jury's answer is neither YES nor NO\");\n    }\n\n    // Read contestant's answer from ouf\n    string pans = ouf.readWord();\n    if (pans != \"YES\" && pans != \"NO\") {\n        quitf(_pe, \"Contestant's answer is neither YES nor NO\");\n    }\n\n    if (jans == \"NO\") {\n        if (pans == \"NO\") {\n            quitf(_ok, \"Both contestant and jury output NO\");\n        } else {\n            // Jury says 'NO', contestant says 'YES', check contestant's x1..xn\n            // If contestant's x1..xn is acceptable, output '_fail'\n            // Else, output '_wa'\n\n            // Read x1..xn from ouf\n            vector<int> x(n);\n            for (int i = 0; i < n; ++i) {\n                x[i] = ouf.readInt();\n                if (abs(x[i]) != p[i]) {\n                    quitf(_wa, \"At position %d, absolute value of x[%d] (%d) does not match p[%d] (%d)\", i+1, i+1, abs(x[i]), i+1, p[i]);\n                }\n            }\n            // Verify xi < 0 at positions in q\n            for (int qi : q) {\n                if (x[qi] >= 0) {\n                    quitf(_wa, \"At position %d (specified in q), x[%d] is not negative (%d)\", qi+1, qi+1, x[qi]);\n                }\n            }\n            // Verify bracket sequence\n            stack<int> s;\n            for (int xi : x) {\n                if (xi > 0) {\n                    s.push(xi);\n                } else {\n                    if (s.empty()) {\n                        quitf(_wa, \"Bracket sequence is incorrect: unmatched closing bracket at position %d\", &xi - &x[0] + 1);\n                    }\n                    if (s.top() != -xi) {\n                        quitf(_wa, \"Bracket sequence is incorrect: mismatched brackets at position %d, expected %d but got %d\", &xi - &x[0] + 1, -s.top(), xi);\n                    }\n                    s.pop();\n                }\n            }\n            if (!s.empty()) {\n                quitf(_wa, \"Bracket sequence is incorrect: unmatched opening brackets\");\n            }\n            // Everything is acceptable\n            quitf(_fail, \"Jury's answer is NO, but contestant found a valid sequence\");\n        }\n    } else { // jans == \"YES\"\n        if (pans == \"NO\") {\n            quitf(_wa, \"Contestant outputs NO, but a valid sequence exists\");\n        } else { // pans == \"YES\"\n            // Read contestant's x1..xn and verify\n            vector<int> x(n);\n            for (int i = 0; i < n; ++i) {\n                x[i] = ouf.readInt();\n                if (abs(x[i]) != p[i]) {\n                    quitf(_wa, \"At position %d, absolute value of x[%d] (%d) does not match p[%d] (%d)\", i+1, i+1, abs(x[i]), i+1, p[i]);\n                }\n            }\n            // Verify xi < 0 at positions in q\n            for (int qi : q) {\n                if (x[qi] >= 0) {\n                    quitf(_wa, \"At position %d (specified in q), x[%d] is not negative (%d)\", qi+1, qi+1, x[qi]);\n                }\n            }\n            // Verify bracket sequence\n            stack<int> s;\n            for (int i = 0; i < n; ++i) {\n                int xi = x[i];\n                if (xi > 0) {\n                    s.push(xi);\n                } else {\n                    if (s.empty()) {\n                        quitf(_wa, \"Bracket sequence is incorrect: unmatched closing bracket at position %d\", i+1);\n                    }\n                    if (s.top() != -xi) {\n                        quitf(_wa, \"Bracket sequence is incorrect: mismatched brackets at position %d, expected %d but got %d\", i+1, -s.top(), xi);\n                    }\n                    s.pop();\n                }\n            }\n            if (!s.empty()) {\n                quitf(_wa, \"Bracket sequence is incorrect: unmatched opening brackets\");\n            }\n            // Everything is acceptable\n            quitf(_ok, \"Correct\");\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n    vector<int> q;\n\n    if (type == \"valid_random\") {\n        stack<int> s;\n        vector<int> x;\n        for (int i = 0; i < n; ++i) {\n            int open = rnd.next(0, 1);\n            if (open || s.empty()) {\n                int v = rnd.next(1, 1000000000);\n                x.push_back(v);\n                s.push(v);\n            } else {\n                int v = s.top();\n                x.push_back(-v);\n                s.pop();\n            }\n        }\n        while (!s.empty()) {\n            int v = s.top();\n            x.push_back(-v);\n            s.pop();\n            ++n;\n        }\n        p.resize(n);\n        for (int i = 0; i < n; ++i) {\n            p[i] = abs(x[i]);\n            if (x[i] < 0)\n                q.push_back(i + 1);\n        }\n        t = q.size();\n    } else if (type == \"invalid\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = 1;\n        t = 0;\n    } else if (type == \"max_n_valid\") {\n        n = 1000000;\n        vector<int> x;\n        for (int i = 0; i < n / 2; ++i) {\n            int v = rnd.next(1, 1000000000);\n            x.push_back(v);\n        }\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            x.push_back(-x[i]);\n        }\n        n = x.size();\n        p.resize(n);\n        for (int i = 0; i < n; ++i) {\n            p[i] = abs(x[i]);\n            if (x[i] < 0)\n                q.push_back(i + 1);\n        }\n        t = q.size();\n    } else {\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 1000000000);\n        set<int> positions;\n        while (positions.size() < t) {\n            int pos = rnd.next(1, n);\n            positions.insert(pos);\n        }\n        q.assign(positions.begin(), positions.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], (i + 1 == n) ? '\\n' : ' ');\n    printf(\"%d\", t);\n    for (int i = 0; i < t; ++i)\n        printf(\" %d\", q[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n    vector<int> q;\n\n    if (type == \"valid_random\") {\n        stack<int> s;\n        vector<int> x;\n        for (int i = 0; i < n; ++i) {\n            int open = rnd.next(0, 1);\n            if (open || s.empty()) {\n                int v = rnd.next(1, 1000000000);\n                x.push_back(v);\n                s.push(v);\n            } else {\n                int v = s.top();\n                x.push_back(-v);\n                s.pop();\n            }\n        }\n        while (!s.empty()) {\n            int v = s.top();\n            x.push_back(-v);\n            s.pop();\n            ++n;\n        }\n        p.resize(n);\n        for (int i = 0; i < n; ++i) {\n            p[i] = abs(x[i]);\n            if (x[i] < 0)\n                q.push_back(i + 1);\n        }\n        t = q.size();\n    } else if (type == \"invalid\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = 1;\n        t = 0;\n    } else if (type == \"max_n_valid\") {\n        n = 1000000;\n        vector<int> x;\n        for (int i = 0; i < n / 2; ++i) {\n            int v = rnd.next(1, 1000000000);\n            x.push_back(v);\n        }\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            x.push_back(-x[i]);\n        }\n        n = x.size();\n        p.resize(n);\n        for (int i = 0; i < n; ++i) {\n            p[i] = abs(x[i]);\n            if (x[i] < 0)\n                q.push_back(i + 1);\n        }\n        t = q.size();\n    } else {\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 1000000000);\n        set<int> positions;\n        while (positions.size() < t) {\n            int pos = rnd.next(1, n);\n            positions.insert(pos);\n        }\n        q.assign(positions.begin(), positions.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], (i + 1 == n) ? '\\n' : ' ');\n    printf(\"%d\", t);\n    for (int i = 0; i < t; ++i)\n        printf(\" %d\", q[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type valid_random\n./gen -n 1 -type invalid\n./gen -n 2 -type valid_random\n./gen -n 2 -type invalid\n./gen -n 10 -type valid_random\n./gen -n 10 -t 5 -type random\n./gen -n 100 -type valid_random\n./gen -n 100 -type invalid\n./gen -n 100 -t 50 -type random\n./gen -n 1000 -type valid_random\n./gen -n 1000 -type invalid\n./gen -n 1000 -t 500 -type random\n./gen -n 10000 -type valid_random\n./gen -n 10000 -type invalid\n./gen -n 10000 -t 5000 -type random\n./gen -n 100000 -type valid_random\n./gen -n 100000 -type invalid\n./gen -n 100000 -t 50000 -type random\n./gen -n 1000000 -type max_n_valid\n./gen -n 1000000 -type invalid\n./gen -n 1 -t 0 -type random\n./gen -n 1 -t 1 -type random\n./gen -n 2 -t 1 -type random\n./gen -n 10 -t 10 -type random\n./gen -n 100 -t 100 -type random\n./gen -n 1000 -t 1000 -type random\n./gen -n 10 -t 0 -type random\n./gen -n 100 -t 0 -type random\n./gen -n 1000 -t 0 -type random\n./gen -n 10 -type invalid\n./gen -n 100 -type invalid\n./gen -n 1000 -type invalid\n./gen -n 1000000 -t 500000 -type random\n./gen -n 1000000 -t 0 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:42.661516",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "288/A",
      "title": "A. Polo the Penguin and Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains two positive integers n and k (1 ≤ n ≤ 106, 1 ≤ k ≤ 26) — the string's length and the number of distinct letters.",
      "output_spec": "OutputIn a single line print the required string. If there isn't such string, print \"-1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy7 4OutputCopyababacdInputCopy4 7OutputCopy-1",
      "description": "A. Polo the Penguin and Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains two positive integers n and k (1 ≤ n ≤ 106, 1 ≤ k ≤ 26) — the string's length and the number of distinct letters.\n\nOutputIn a single line print the required string. If there isn't such string, print \"-1\" (without the quotes).\n\nInputCopy7 4OutputCopyababacdInputCopy4 7OutputCopy-1\n\nInputCopy7 4\n\nOutputCopyababacd\n\nInputCopy4 7\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #177 has been moved forward - Codeforces",
          "content": "As the TopCoder TCO 2013 Round 2A did not take place as planned but was moved (with sniper precision) right on the place of the Codeforces Round #177, we decided to reschedule the contest. I have to admit that my first urge was to leave everything as it is — TopCoder knew of Codeforces Round 177 and I cannot approve of such an approach to solving their technical issues. On the other hand, no fault lies on the community, and especially on dear witua, the writer of the forthcoming round. You’d like to participate and the writer is keen on making a round as popular as it gets. Besides, the problem coordinator Gerald would have fallen under much pressure, juggling work and TCO. That’s why the Codeforces Round #177 moves to the time that was initially planned for Round 178, and Round 178 moves a little ahead.We apologize for the schedule inconveniences and hope to see you among the Codeforces Round #177 participants. It will be fun!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 941
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Greetings!Codeforces Round #177 takes place tomorrow at 19:30 by Moscow. I hope you all will take part and enjoy the problems.Gerald, as usually, helps in preparings, Delinur translates all the problems for you. Thanks to them.Good Luck!Points distribution is standard:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Here are today's winners:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 463
        },
        {
          "title": "Codeforces Round #177, editorial - Codeforces",
          "content": "Hi!289A - Polo the Penguin and Segments Solution. First of all, we need to count, how many integers are inside given segments at the beginning. Since they don't intersect and even touch, no integer point can belong to more than one segment at the same time. This mans that starting value of segments is .If k divides p, then answer is 0 — we don't need to do anything, it's already done. But if it's not true, we need to know the minimal number of turns to make k divisor of p. Since we can in single turn increase p by 1 (by decreasing the left point of the leftmost segment), this number is equal to .Note. Note that just output is not enough: you need to pay attention for case when , or just output .289B - Polo the Penguin and MatrixSolution. First of all, we need to know when the answer is -1. For that you should notice that after any operation on number z, value doesn't change. Indeed, . This means that there is not answer if there are two different points for which is diffrent.Now we can transform our problem a bit. We can just write down all integers from matrix n × m to one array b of size k = n × m and sort them all in non-decreasing order. It is not hard to notice that in some of the optimal solutions, all number are at the end equal to one of the number for starting array. But also, it is optimal to make all number equal to (median element). Why to median? Suppose that we make all numbers equal to non-median element with index x. Then if |x - (k - x)| > 1 (i. e. from one side there are more elements than from another + 1). So, by moving out element more to median, we can make result better.After we know, to which number we should bring all, the answer is just , divided by d.Note. There is also full solution with complexity O(n2m2). 288A - Polo the Penguin and StringsSolution. To solve this problem we need to find out some contruction of resulting string. But first of all, we need find out when there is no result. Obviously, if k > n, there is not result — you cannot build string of length n with more than n characters. Another one case is when k = 1 and n > 1 — there is no answer in that case also.Consider that k = 2. It's really easy to see that answer for such case is a string of form abababab.... To construct string for k > 2 you need to add some extra characters — c, d, e.... To make string lexicographically smallest, you need to add that characters as close to the end as we can. And the best bet here is abbabab...abacdefgh.... So, we need just to add characters c, d, e, f... (i. e. k - 2 characters from c) to the end of the string.288B - Polo the Penguin and Houses Solution. Since k ≤ 8 you can solve this problem using brute force. This means that you can recursively construct all possible kk possibilities of first k assignments. (For k = 8 this is equal to 16 777 216.) For each of that assignments you need to check whether it is correct or not (by problem statement). Ths can be simply done using loops.When you know the number of assignment for the first k tables (let it be f(k)), all you need to do is to count the number of assignment for the rest n - k plaques. Since there should bo no path to 1, there should be no path to any of first k houses, so at each plaque for houses from k + 1 to n there can be any number from k + 1 to n, inclusive. There are (n - k)n - k such possibilities. And hence the total answer is f(k)(n - k)n - k.Note. There also exists solution with dynamic programming, and also there exists formula for f(x). You can read about it more here, here и here.288C - Polo the Penguin and XOR operationSolution. Since we need to maximize the result, we need to find such permutation, for which the least number of bit disappear. (We consider bit disappeared if it was 1 both in i and pi, so in it is 0). It turns out that for each n there is such permutation that no bit disappear. How to build it? We will be solving problem by iterations while n > 0. On each iteration, we need to find the biggest (the leftmost in binary representation) bit which is not 0 in binary representation of n and denote it position (bits are numbered from 0) by b. Now we need to find integer m — minimal integer from 0 to n, inclusive, such that b-th bit is also 1 in it. After that you can see (look image below), that at no bit disappear, at no bit disappear, ..., at no bit disappear. So, it is good to assign exactly that integers to our permutation, i. e. pm = m - 1 and pm - 1 = m, pm + 1 = m - 2 and pm - 2 = m + 1 and so on. After that assign value m - (n - m + 1) - 1 to n and go to next iteration.Now when we know how to build permutation and that no bit disappear, the value of the answer is equal to .288D - Polo the Penguin and Trees Solution. As always in such problems, root our tree at some vertex, for example vertex with number 1. We need to find out, what will happen when we have already chosen one path. Obviously, after deleting all vertices and their edges from that path, tree will disintegrate in some set of trees. Denote their sizes by c1, c2, ..., ck, where k is the number of trees. Then the number of ways to choose the second path is equal to . This gives us O(n2) solution — just to brute force all pathes and count the number of second paths by this formula. We need to do it in O(n). To do so, dfs our graph and fix some vertex during dfs, we will consider this vertex as the last vertex in the first path. Now we need to find the sum of above formula for the rest of the vertex. Here you can separately solve this problem for all vertex inside subtree of current vertex and for the rest of the vertices. For subtree vertices, you can, after finding the answers for all vertices of subtree, find the answer for root of subtree. To do so, you need to iterate all edges from current vertex and sum up results for that vetices. Also you need to add the sum of values multiplied by the number of vertices in subtree, where di are all sizes of subtrees of vertices from current vertex, not including from current edge). You can use some partial sums of something like that to make it linear. For the rest of the vertices (not in subtree) it is actually similar, but a bit harder. Here you need to keep current result as a parameter of dfs and when you entering some vertex you should add some additional counts to the current sum (similarly as in first case).Note. Also, you can find the number of bad pairs of pathes and subtract it from the total number. Also some divide and coquer solution exists, you can think about it.288E - Polo the Penguin and Lucky NumbersSolution. In this problem there are a lot of different formulas, most of them are for optimizing solution and making it lenear. Editorial shows just a general idea because it's pretty hard to explain all of them and good for you to derive it by yourself. If you have any questions — write them all in comments.Denote by a1, a2, ..., an all lucky number from segment. First of all, we need to do reduce the problem a bit. Let we have some fixed digit (pos, d), i. e. position of this digit is pos (from 0 from right to left) and value is d (4 or 7). Then, for all ai (1 ≤ i < n) such that pos-th digit of ai is equal to d, we need to add ai + 1 × d × 10pos to the answer. Now we can see that problem can be reduced to the following. For each fixed digit (pos, d) find the sum of all ai such that ai + 1 on the pos-th position has digit d. Obviously, we can solve the problem for 1..l and 1..r separately and then subtract the first from the second — that will be the answer.How to find such sum among all lucky numbers of some length but less than some lucky number x? We will describe the general idea. Any lucky number, less than x has some common prefix with x, then one digit is less than the corresponing in x (i. e. it is 7 in x and 4 in another integer) and the rest of the digits are arbitrary. So, by iterating all such positions where is the first digit less than in x, we can, using the fact that the rest of the digits are arbitrary and some formulas and precomputations, compute the results for each position and digit.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 288\\s*A"
          },
          "content_length": 8091
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random_valid\");\n\n    if (type == \"random_valid\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        int max_k = min(26, n);\n        if (k == -1) k = rnd.next(1, max_k);\n        else k = min(k, max_k);\n    } else if (type == \"random_invalid\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        int min_k = n + 1;\n        int max_k = 26;\n        if (min_k > max_k) {\n            printf(\"-1\\n\"); // No solution possible\n            return 0;\n        }\n        k = rnd.next(min_k, max_k);\n    } else if (type == \"max_n_max_k\") {\n        n = 1000000;\n        k = min(26, n);\n    } else if (type == \"max_n_min_k\") {\n        n = 1000000;\n        k = 1;\n    } else if (type == \"min_n_max_k\") {\n        n = 1;\n        k = 1; // Since n=1, k cannot be more than 1\n    } else if (type == \"k_eq_n\") {\n        if (n == -1) n = rnd.next(1, min(26, 1000000)); // n up to 26\n        k = n;\n    } else if (type == \"k_greater_than_n\") {\n        if (n == -1) n = rnd.next(1, 25); // Since k ≤ 26\n        k = n + 1;\n        if (k > 26) k = 26;\n    } else if (type == \"max_k\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        k = min(26, n);\n    } else if (type == \"min_k\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        k = 1;\n    } else if (type == \"edge_cases\") {\n        n = 1000000;\n        k = 1;\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure n and k are within constraints\n    if (n < 1 || n > 1000000 || k < 1 || k > 26) {\n        fprintf(stderr, \"Invalid n or k: n=%d, k=%d\\n\", n, k);\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random_valid\");\n\n    if (type == \"random_valid\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        int max_k = min(26, n);\n        if (k == -1) k = rnd.next(1, max_k);\n        else k = min(k, max_k);\n    } else if (type == \"random_invalid\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        int min_k = n + 1;\n        int max_k = 26;\n        if (min_k > max_k) {\n            printf(\"-1\\n\"); // No solution possible\n            return 0;\n        }\n        k = rnd.next(min_k, max_k);\n    } else if (type == \"max_n_max_k\") {\n        n = 1000000;\n        k = min(26, n);\n    } else if (type == \"max_n_min_k\") {\n        n = 1000000;\n        k = 1;\n    } else if (type == \"min_n_max_k\") {\n        n = 1;\n        k = 1; // Since n=1, k cannot be more than 1\n    } else if (type == \"k_eq_n\") {\n        if (n == -1) n = rnd.next(1, min(26, 1000000)); // n up to 26\n        k = n;\n    } else if (type == \"k_greater_than_n\") {\n        if (n == -1) n = rnd.next(1, 25); // Since k ≤ 26\n        k = n + 1;\n        if (k > 26) k = 26;\n    } else if (type == \"max_k\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        k = min(26, n);\n    } else if (type == \"min_k\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        k = 1;\n    } else if (type == \"edge_cases\") {\n        n = 1000000;\n        k = 1;\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure n and k are within constraints\n    if (n < 1 || n > 1000000 || k < 1 || k > 26) {\n        fprintf(stderr, \"Invalid n or k: n=%d, k=%d\\n\", n, k);\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random_valid\n./gen -type random_valid\n./gen -type random_valid\n./gen -type random_valid\n./gen -type random_valid\n\n./gen -type random_valid -n 1000\n./gen -type random_valid -n 1\n./gen -type random_valid -n 1000000\n\n./gen -type random_invalid\n./gen -type random_invalid\n./gen -type random_invalid\n\n./gen -type max_n_max_k\n./gen -type max_n_min_k\n./gen -type min_n_max_k\n\n./gen -type k_eq_n -n 26\n./gen -type k_eq_n -n 1\n./gen -type k_eq_n -n 20\n\n./gen -type k_greater_than_n -n 1\n./gen -type k_greater_than_n -n 25\n\n./gen -type max_k -n 1000000\n\n./gen -type min_k -n 1000000\n\n./gen -type edge_cases\n\n./gen -n 1 -k 1 -type random_valid\n./gen -n 1 -k 2 -type random_invalid\n./gen -n 1000000 -k 26 -type random_valid\n./gen -n 100 -k 26 -type random_valid\n./gen -n 26 -k 26 -type random_valid\n\n./gen -type min_k -n 1\n./gen -type min_k -n 500000\n./gen -type min_k -n 1000000\n\n./gen -n 2 -k 2 -type random_valid\n./gen -n 1000000 -k 2 -type random_valid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:44.704646",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "288/B",
      "title": "B. Polo the Penguin and Houses",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two space-separated integers n and k (1 ≤ n ≤ 1000, 1 ≤ k ≤ min(8, n)) — the number of the houses and the number k from the statement.",
      "output_spec": "OutputIn a single line print a single integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy5 2OutputCopy54InputCopy7 4OutputCopy1728",
      "description": "B. Polo the Penguin and Houses\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains two space-separated integers n and k (1 ≤ n ≤ 1000, 1 ≤ k ≤ min(8, n)) — the number of the houses and the number k from the statement.\n\nOutputIn a single line print a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy5 2OutputCopy54InputCopy7 4OutputCopy1728\n\nInputCopy5 2\n\nOutputCopy54\n\nInputCopy7 4\n\nOutputCopy1728",
      "solutions": [
        {
          "title": "Codeforces Round #177 has been moved forward - Codeforces",
          "content": "As the TopCoder TCO 2013 Round 2A did not take place as planned but was moved (with sniper precision) right on the place of the Codeforces Round #177, we decided to reschedule the contest. I have to admit that my first urge was to leave everything as it is — TopCoder knew of Codeforces Round 177 and I cannot approve of such an approach to solving their technical issues. On the other hand, no fault lies on the community, and especially on dear witua, the writer of the forthcoming round. You’d like to participate and the writer is keen on making a round as popular as it gets. Besides, the problem coordinator Gerald would have fallen under much pressure, juggling work and TCO. That’s why the Codeforces Round #177 moves to the time that was initially planned for Round 178, and Round 178 moves a little ahead.We apologize for the schedule inconveniences and hope to see you among the Codeforces Round #177 participants. It will be fun!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 941
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Greetings!Codeforces Round #177 takes place tomorrow at 19:30 by Moscow. I hope you all will take part and enjoy the problems.Gerald, as usually, helps in preparings, Delinur translates all the problems for you. Thanks to them.Good Luck!Points distribution is standard:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Here are today's winners:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 463
        },
        {
          "title": "Codeforces Round #177, editorial - Codeforces",
          "content": "Hi!289A - Polo the Penguin and Segments Solution. First of all, we need to count, how many integers are inside given segments at the beginning. Since they don't intersect and even touch, no integer point can belong to more than one segment at the same time. This mans that starting value of segments is .If k divides p, then answer is 0 — we don't need to do anything, it's already done. But if it's not true, we need to know the minimal number of turns to make k divisor of p. Since we can in single turn increase p by 1 (by decreasing the left point of the leftmost segment), this number is equal to .Note. Note that just output is not enough: you need to pay attention for case when , or just output .289B - Polo the Penguin and MatrixSolution. First of all, we need to know when the answer is -1. For that you should notice that after any operation on number z, value doesn't change. Indeed, . This means that there is not answer if there are two different points for which is diffrent.Now we can transform our problem a bit. We can just write down all integers from matrix n × m to one array b of size k = n × m and sort them all in non-decreasing order. It is not hard to notice that in some of the optimal solutions, all number are at the end equal to one of the number for starting array. But also, it is optimal to make all number equal to (median element). Why to median? Suppose that we make all numbers equal to non-median element with index x. Then if |x - (k - x)| > 1 (i. e. from one side there are more elements than from another + 1). So, by moving out element more to median, we can make result better.After we know, to which number we should bring all, the answer is just , divided by d.Note. There is also full solution with complexity O(n2m2). 288A - Polo the Penguin and StringsSolution. To solve this problem we need to find out some contruction of resulting string. But first of all, we need find out when there is no result. Obviously, if k > n, there is not result — you cannot build string of length n with more than n characters. Another one case is when k = 1 and n > 1 — there is no answer in that case also.Consider that k = 2. It's really easy to see that answer for such case is a string of form abababab.... To construct string for k > 2 you need to add some extra characters — c, d, e.... To make string lexicographically smallest, you need to add that characters as close to the end as we can. And the best bet here is abbabab...abacdefgh.... So, we need just to add characters c, d, e, f... (i. e. k - 2 characters from c) to the end of the string.288B - Polo the Penguin and Houses Solution. Since k ≤ 8 you can solve this problem using brute force. This means that you can recursively construct all possible kk possibilities of first k assignments. (For k = 8 this is equal to 16 777 216.) For each of that assignments you need to check whether it is correct or not (by problem statement). Ths can be simply done using loops.When you know the number of assignment for the first k tables (let it be f(k)), all you need to do is to count the number of assignment for the rest n - k plaques. Since there should bo no path to 1, there should be no path to any of first k houses, so at each plaque for houses from k + 1 to n there can be any number from k + 1 to n, inclusive. There are (n - k)n - k such possibilities. And hence the total answer is f(k)(n - k)n - k.Note. There also exists solution with dynamic programming, and also there exists formula for f(x). You can read about it more here, here и here.288C - Polo the Penguin and XOR operationSolution. Since we need to maximize the result, we need to find such permutation, for which the least number of bit disappear. (We consider bit disappeared if it was 1 both in i and pi, so in it is 0). It turns out that for each n there is such permutation that no bit disappear. How to build it? We will be solving problem by iterations while n > 0. On each iteration, we need to find the biggest (the leftmost in binary representation) bit which is not 0 in binary representation of n and denote it position (bits are numbered from 0) by b. Now we need to find integer m — minimal integer from 0 to n, inclusive, such that b-th bit is also 1 in it. After that you can see (look image below), that at no bit disappear, at no bit disappear, ..., at no bit disappear. So, it is good to assign exactly that integers to our permutation, i. e. pm = m - 1 and pm - 1 = m, pm + 1 = m - 2 and pm - 2 = m + 1 and so on. After that assign value m - (n - m + 1) - 1 to n and go to next iteration.Now when we know how to build permutation and that no bit disappear, the value of the answer is equal to .288D - Polo the Penguin and Trees Solution. As always in such problems, root our tree at some vertex, for example vertex with number 1. We need to find out, what will happen when we have already chosen one path. Obviously, after deleting all vertices and their edges from that path, tree will disintegrate in some set of trees. Denote their sizes by c1, c2, ..., ck, where k is the number of trees. Then the number of ways to choose the second path is equal to . This gives us O(n2) solution — just to brute force all pathes and count the number of second paths by this formula. We need to do it in O(n). To do so, dfs our graph and fix some vertex during dfs, we will consider this vertex as the last vertex in the first path. Now we need to find the sum of above formula for the rest of the vertex. Here you can separately solve this problem for all vertex inside subtree of current vertex and for the rest of the vertices. For subtree vertices, you can, after finding the answers for all vertices of subtree, find the answer for root of subtree. To do so, you need to iterate all edges from current vertex and sum up results for that vetices. Also you need to add the sum of values multiplied by the number of vertices in subtree, where di are all sizes of subtrees of vertices from current vertex, not including from current edge). You can use some partial sums of something like that to make it linear. For the rest of the vertices (not in subtree) it is actually similar, but a bit harder. Here you need to keep current result as a parameter of dfs and when you entering some vertex you should add some additional counts to the current sum (similarly as in first case).Note. Also, you can find the number of bad pairs of pathes and subtract it from the total number. Also some divide and coquer solution exists, you can think about it.288E - Polo the Penguin and Lucky NumbersSolution. In this problem there are a lot of different formulas, most of them are for optimizing solution and making it lenear. Editorial shows just a general idea because it's pretty hard to explain all of them and good for you to derive it by yourself. If you have any questions — write them all in comments.Denote by a1, a2, ..., an all lucky number from segment. First of all, we need to do reduce the problem a bit. Let we have some fixed digit (pos, d), i. e. position of this digit is pos (from 0 from right to left) and value is d (4 or 7). Then, for all ai (1 ≤ i < n) such that pos-th digit of ai is equal to d, we need to add ai + 1 × d × 10pos to the answer. Now we can see that problem can be reduced to the following. For each fixed digit (pos, d) find the sum of all ai such that ai + 1 on the pos-th position has digit d. Obviously, we can solve the problem for 1..l and 1..r separately and then subtract the first from the second — that will be the answer.How to find such sum among all lucky numbers of some length but less than some lucky number x? We will describe the general idea. Any lucky number, less than x has some common prefix with x, then one digit is less than the corresponing in x (i. e. it is 7 in x and 4 in another integer) and the rest of the digits are arbitrary. So, by iterating all such positions where is the first digit less than in x, we can, using the fact that the rest of the digits are arbitrary and some formulas and precomputations, compute the results for each position and digit.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 288\\s*B"
          },
          "content_length": 8091
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(8, n), \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(8, n), \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(8, n), \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n_k_1\") {\n        n = 1;\n        k = 1;\n    } else if (type == \"max_n_k_1\") {\n        n = 1000;\n        k = 1;\n    } else if (type == \"max_n_k_max\") {\n        n = 1000;\n        k = min(8, n);\n    } else if (type == \"n_equals_k\") {\n        n = rnd.next(1, 8);\n        k = n;\n    } else if (type == \"k_equals_1\") {\n        n = rnd.next(1, 1000);\n        k = 1;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000);\n        k = rnd.next(1, min(8, n));\n    } else {\n        // default random\n        n = rnd.next(1, 1000);\n        k = rnd.next(1, min(8, n));\n    }\n\n    // Ensure n and k are within bounds\n    n = max(1, min(1000, n));\n    k = max(1, min(k, min(8, n)));\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n_k_1\") {\n        n = 1;\n        k = 1;\n    } else if (type == \"max_n_k_1\") {\n        n = 1000;\n        k = 1;\n    } else if (type == \"max_n_k_max\") {\n        n = 1000;\n        k = min(8, n);\n    } else if (type == \"n_equals_k\") {\n        n = rnd.next(1, 8);\n        k = n;\n    } else if (type == \"k_equals_1\") {\n        n = rnd.next(1, 1000);\n        k = 1;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000);\n        k = rnd.next(1, min(8, n));\n    } else {\n        // default random\n        n = rnd.next(1, 1000);\n        k = rnd.next(1, min(8, n));\n    }\n\n    // Ensure n and k are within bounds\n    n = max(1, min(1000, n));\n    k = max(1, min(k, min(8, n)));\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n_k_1\n./gen -type max_n_k_1\n./gen -type max_n_k_max\n./gen -type n_equals_k\n./gen -type k_equals_1\n\n./gen -n 1000 -k 8\n./gen -n 1000 -k 7\n./gen -n 1000 -k 6\n./gen -n 1000 -k 5\n./gen -n 1000 -k 4\n./gen -n 1000 -k 3\n\n./gen -n 500 -k 8\n./gen -n 500 -k 1\n\n./gen -n 1 -k 1\n./gen -n 2 -k 1\n./gen -n 3 -k 2\n./gen -n 4 -k 3\n./gen -n 5 -k 4\n./gen -n 6 -k 5\n./gen -n 7 -k 6\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:46.725535",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "288/C",
      "title": "C. Пингвин Поло и операция XOR",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке задано целое положительное число n (1 ≤ n ≤ 106).",
      "output_spec": "Выходные данныеВ первой строке выведите целое число m — максимально возможную красоту, в следующей строке выведите любую перестановку целых чисел от 0 до n, красота которой равна m.Если существует несколько подходящих перестановок, разрешается вывести любую.",
      "sample_tests": "ПримерыВходные данныеСкопировать4Выходные данныеСкопировать200 2 1 4 3",
      "description": "C. Пингвин Поло и операция XOR\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке задано целое положительное число n (1 ≤ n ≤ 106).\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число m — максимально возможную красоту, в следующей строке выведите любую перестановку целых чисел от 0 до n, красота которой равна m.Если существует несколько подходящих перестановок, разрешается вывести любую.\n\nВыходные данные\n\nВходные данныеСкопировать4Выходные данныеСкопировать200 2 1 4 3\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать200 2 1 4 3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Перенос Codeforces Round #177 - Codeforces",
          "content": "В связи с тем, что у TopCoder сорвалось проведение TCO 2013 Round 2A, а перенесли они его со снайперской точностью на запланированный нами ранее Codeforces Round #177, мы решили подвинуть наше мероприятие. Признаюсь, моим первым побуждением было оставить всё как есть — TopCoder прекрасно знал о Codeforces Round 177, и я не могу одобрить такой подход к решению своих технических сложностей. С другой стороны, сообщество, а особенно автор предстоящего раунда, уважаемый witua, не виноваты — вам хочется участвовать, а автору интереснее, когда раунд собирает аншлаг. К тому же, координатору задач Gerald-у пришлось бы несладко, разрываясь между работой и TCO. Поэтому Codeforces Round #177 сдвинут на время запланированное для раунда #178, а тот будет перенесен чуток вперед.Мы приносим извинения за изменения в расписании. Надеемся, увидеть вас среди участников Codeforces Round #177. Будет весело!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Привет!Завтра, в 19:30 по Москве состоится Codeforces Round #177. Надеюсь, что, несмотря на то что раунд был перенесен, вы все примете участие в нем и будете счастливы.Помогает готовить раунд, как всегда, Gerald, условия переводит Delinur. Спасибо им.Удачи!Сегодня все стандартно:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Сегодняшние победители:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 472
        },
        {
          "title": "Codeforces Round #177, разбор задач - Codeforces",
          "content": "Здравствуйте!289A - Пингвин Поло и отрезкиКраткое описание. Есть 105 числовых отрезков, которые не пересекаются. За один шаг можно увеличить любой отрезок на 1 влево или вправо. Нужно найти минимальное количество шагов, после которых число целых чисел, принадлежащих отрезкам, будем делится на k.Решение. Для начала нужно посчитать, сколько чисел изначально принадлежат заданным отрезкам. Поскольку они не пересекаются и даже не касаются (это следует из неравенства min(ri, rj) < max(li, lj) для всех i, j), никакая точка не может принадлежать двум отрезкам одновременно. Поэтому изначально величиной множества есть число . Если p делится на k, то ответом будет число 0 — не надо делать никаких шагов, все уже готово. Но если это не так, нужно подумать, за какое минимальное количество шагов из p можно сделать число, которое делится k. Можно увидеть, что за один шаг величину множества можно увеличить ровно на 1 (просто либо увеличив влево самый левый отрезок либо увеличив вправо самый правый), но на число больше 1 мы никогда его не увеличим. Тогда минимальное количество шагов будет равно минимальному числу t такому, что . Несложно убедится, что . Примечание. Обратите внимание, что просто вывести недостаточно: нужно отдельно рассмотреть случай когда , или просто вывести .289B - Пингвин Поло и матрицаКраткое описание. Есть матрица n × m из целых чисел, а также число d. За один шаг можно увеличить или уменьшить любое из чисел матрицы (но только одно) ровно на d. Нужно найти минимальное количество шагов, после которых все элементы матрицы будут одинаковыми, или сообщить, что этого сделать невозможно.Решение. Для начала нужно выяснить, когда не существует ответа. Для этого нужно заметить, что после выполнения операции над числом z величина не изменится. Действительно . Поэтому необходимым условием существования ответа есть условие, что все равны между собой. Несложно убедится, что это будет и достаточное условие (это также видно по алгоритму описанному ниже).Теперь можно свести задачу к несколько другому виду. Переведем все n × m чисел матрицы в одномерный массив b, по сортируем по не убыванию и пронумеруем элементы от 1 до k (тут k это тоже самое что n × m). Цель задачи и шаги, естественно, остаются такими же. Несложно заметить в хотя бы в одному оптимальном ответе, все числа сведены к одному из чисел данного массива. Но, кроме этого, одним из оптимальных ответов будет свести все числа к числу , то есть к медиане массива. Почему именно к медиане? Предположим, что свели не к медианному элементу с номером x. Тогда |x - (k - x)| > 1, то есть с одной стороны хотя бы на 2 элемента больше, чем с другой. Поэтому, передвинув число в сторону уменьшение абсолютной разницы, можно улучшить (или хотя-бы точно не уменьшить) результат.После того как известно, к какому число нужно свести, несложно понять что результатом будет сумма , разделенная на d.Сложность такого решения: .Примечание. Полным решением также является решение со сложностью O(n2m2). 288A - Пингвин Поло и строкиКраткое описание. Нужно построить лексикографически минимальную строку длины n, состоящую из ровно k различных маленький латинских символов такую, что-бы никакие два соседних числа не совпадали.Решение. Решением этой задачи есть конструктивное построение нужной строки. Но для начала найдем такие параметры n и k, для которых не существует ответа. Естественно, что если k > n, то ответа не существует, так как не может быть k различных символов в строке длиной меньше k. Еще одним случаем есть случай когда k = 1, тогда если n > 1 ответа также не существует. Во всех остальных случаях ответ существует.Теперь, когда мы знаем что ответ существует, нужно построить лексикографически минимальный. Предположим, что k = 2. Несложно понять, что оптимальным ответом здесь будет строка вида abababab.... Логично, что для k > 2 ответ будет точно лексикографически больше за ответ при k = 2, поэтому стоит как-то как можно правее что-то дописать к ответу для k = 2 так, что-бы он был ответом для k > 2. Минимальное что мы можем (и должны) сделать это переписать последние k - 2 символа строки на первые k - 2 символа алфавита, начиная с символа «c». Например, для n = 7, k = 4 у нас получается строка abababa, а после замены — ababacd.Примечание. Не достаточно двух проверок k > n или k = 1, потому что для n = k = 1 есть ответ.288B - Пингвин Поло и домаКраткое описание. Нужно найти количество таких таких массивов p длины n из целых чисел от 1 до n, что-бы из первых k элементов можно дойти переходами вида x → px до 1, из последних n - k не можно было дойти до 1 и что-бы 1 был в цикле (т. е. можно дойти из 1 в 1 за положительное количество переходов).Решение. Поскольку k ≤ 8, задачу можно решить перебором. То есть, нужно рекурсивно найти всевозможные варианты первых k чисел на табличках (очевидно, что все они будут в диапазоне 1..k). Всего таких вариантов будет kk (при k = 8 это число равно 16 777 216). Также, для каждого варианта нужно убедится, что он правильный, то есть удовлетворяет все три условия. Это несложно сделать циклом: просто пройтись по всем переходам пока не зашли в цикл и убедится что дом номер 1 был посещен через ненулевое количество переходов.Когда количество вариантов записи первых k найдены (пусть оно равно f(k)), осталось только найти количество вариантов табличек для остальных n - k домов. Поскольку не должно существовать пути из них в 1, то не должно и существовать пути из них в любую из вершин с номером не больше k (иначе за первым условием будет путь в 1). Из этого следует, что на табличках домов с номерами от k + 1 до n можно ставить только номера от k + 1 до n. Так как нас не интересует как именно они расставлены, всего таких вариантов будет (n - k)n - k. Поэтому ответом будет f(k)(n - k)n - k.Примечание. Существует также решение с использованием динамического программирование, а также более аналитическое — формула для f(k). Более подробно об этом обсуждалось здесь, здесь и здесь.288C - Пингвин Поло и операция XORКраткое описание. Нужно найти такую перестановку p чисел от 0 до n, для которой величина максимально возможная.Решение. Так как нужно максимизировать ответ, нужно найти такую перестановку, при которой минимальное количество битов пропадут при операции xor, то есть что-бы было как можно меньше таких битов, что они одновременно равны 1 и в i и в pi (потому что тогда ои ничего не прибавят к ответу). Оказывается, для любого n можно найти такую перестановку, при которой ни один бит не пропадет. Как именно строить такую перестановку? Будем решать задачу итерациями пока n > 0. На каждой итерации, найдем самый старший бит, который не равен 0 в двоичной записи n и обозначим его номер (при нумерации с права налево от 0) через b. Также нужно найти число m — минимальное число от 0 до n (включительно), в котором бит с номером b равен 1. После этого можно увидеть (смотри рисунок ниже), что при не пропадет ни один бит, при не пропадет ни один бит, ..., при не пропадет ни один бит. Поэтому, нам стоит именное такие числа присвоить перестановке (то есть pm = m - 1 и pm - 1 = m, pm + 1 = m - 2 и pm - 2 = m + 1 и так далее). После этого присвоим n значение m - (n - m + 1) - 1 и перейдем к следующей итерации.Теперь, когда известно как можно построить перестановку так, что-бы ни один бит не пропадал, ответом будет .Примечание. В этой задачи было полезно написать генератор для небольших n. После этого несложно увидеть закономерность ответа, после чего намного проще дойти до его конструкции.288D - Пингвин Поло и деревоКраткое описание. Нужно найти количество пар путей в дереве, которые не пересекаются по вершинам (то есть не имеют общих вершин).Решение. Как всегда в подобных задачах, подвесим дерево за какую-то вершину, например за вершину с номером 1. Нужно выяснить, что будет, если есть какой-то фиксированный путь и надо найти количество способов выбрать другой. Очевидно, что после удаления всех вершин этого пути и инцидентных к ним ребер, дерево распадется на лес (тоесть на множество отдельных деревьев). Пусть их размеры (количество вершин) это числа c1, c2, ..., ck, где k — их количество. Тогда нам с каждой из таких групп нужно выбрать пару чисел, то есть суммарное количество способов будет . То есть, если перебирать такие пути, достаточно воспользоватся этой формулой что-бы найти ответ. Но такой алгоритм — O(n2), поскольку нужно перебирать все пути. Нужно избавится от этого. Для этого dfs-ом обойдем граф и будем фиксировать одну из вершин пути (последнюю). Теперь нужно найти для всех других вершин сумму таких формул как описано выше. Можно здесь отдельно искать такое количество для вершин поддерева и остальных вершин (тех что первое ребро ведет вверх). Для вершин поддерева нужно делать следующим образом. Пусть у нас есть посчитаны ответы для всех вершин, в которые ведут ребра из текущей. Рассмотрим одну из этих вершин и прибавим к нашему ответу ответ из этой вершины. Но это еще не все — нужно добавить еще сумму всех по всем другим вершинам что выходят из текущей (но кроме той которой мы рассматриваем), умноженное на количество вершин поддерева (не всего текущего, а только того что выходит из ребра что перебираем). Это удобно реализуется, используя частичные суммы для оптимизации (что-бы все время не пересчитывать сумму). Для остальных вершин (тех что не в поддереве) все аналогично, но немножко сложнее. Тут можно, например, в dfs-е поддерживать параметр, который равен ответу для текущей вершины. Потом, когда по ребру спускаемся вниз по дереву, нужно обновить результат как это было и в первом случае, но уже с количество вершин равным n минус размер поддерева (тоесть те вершины что не в поддереве).Примечание. Как вариант, можно искать количество плохих путей и выводить количество всех минус это количество. Еще возможным решением есть принцип разделяй и властвуй.288E - Пингвин Поло и счастливые числаКраткое описание. Есть два больших счастливых числа одинаковой длины. Нужно найти сумму произведений соседних счастливых чисел, которые лежат между двумя заданными.Решение. В данной задаче необходимо вывести довольно много формул, большинство из которых необходимы для оптимизации решение (например различные частичные суммы). В разборе приведена только общая идея авторского решение. Детали можно узнать посмотрев решения участников либо задав вопрос в комментариях ниже.Обозначим через a1, a2, ..., an все счастливые числа промежутка. Сначала нужно сделать следующее сведение задачи. Пусть в нас есть зафиксированная цифра (pos, d), то есть позиция (разряд) pos (начиная с 0 с права налево) и значение d (4 или 7). Тогда, для всех чисел ai (1 ≤ i < n) таких что pos-я цифра равна d к ответу нужно добавить ai + 1 × d × 10pos. Теперь видно, что задача можно свести к следующей. Для каждой фиксированной цифры (pos, d) нужно найти сумму все ai таких, что ai - 1 на pos-й позиции имеет цифру d. Естественно, задачу можно решить отдельно для промежутка 1..l и 1..r, а потом отнять первое от второго — это и будет ответ.Как искать такую сумму среди всех счастливых чисел такой-же длины как входное, но меньших за какое-то x? Опишем общую идею. Любое счастливое число (да и вообще любое) число, меньше за x будет сначала совпадать с ним, то есть иметь некоторый общий префикс, потом одна цифра станет меньше чем в x (то есть там где в x стоит 7 в новом числе стоит 4), а далее цифры будут располагаться произвольным образом. Таким образом, перебрав эту цифру, мы, учитывая произвольность остальных, можем, используя частичные суммы искать ответ для всех позиций и цифр.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 288\\s*C"
          },
          "content_length": 11475
        }
      ],
      "code_examples": [
        {
          "title": "Перенос Codeforces Round #177 - Codeforces - Code 1",
          "code": "for any reason",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7205",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Read n from input file\n\n    long long m = ouf.readLong(); // Read m from contestant's output\n\n    vector<int> p(n + 1);\n    unordered_set<int> used; // To ensure all numbers are unique and within range\n\n    for (int i = 0; i <= n; ++i) {\n        p[i] = ouf.readInt(0, n, format(\"p[%d]\", i).c_str());\n        if (used.count(p[i])) {\n            quitf(_wa, \"Number %d appears more than once in the permutation\", p[i]);\n        }\n        used.insert(p[i]);\n    }\n\n    // Calculate the beauty of the contestant's permutation\n    long long beauty = 0;\n    for (int i = 0; i <= n; ++i) {\n        beauty += p[i] ^ i;\n    }\n\n    // Check if the provided m matches the calculated beauty\n    if (beauty != m) {\n        quitf(_wa, \"Computed beauty %lld does not equal given m %lld\", beauty, m);\n    }\n\n    // Calculate the maximum possible beauty\n    long long maxBeauty = (long long)n * (n + 1);\n\n    // Check if the beauty is the maximum possible\n    if (m != maxBeauty) {\n        quitf(_wa, \"Beauty %lld is not maximum possible %lld\", m, maxBeauty);\n    }\n\n    // If all checks pass, accept the contestant's output\n    quitf(_ok, \"Beauty %lld is correct\", m);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n_min = 1;\n    int n_max = opt<int>(\"n_max\", 1000000);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n;\n\n    if (type == \"min\") {\n        n = n_min;\n    } else if (type == \"max\") {\n        n = n_max;\n    } else if (type == \"small\") {\n        n = rnd.next(n_min+1, min(n_min+10, n_max)); // small n\n    } else if (type == \"random\") {\n        n = rnd.next(n_min, n_max);\n    } else if (type == \"power2\") {\n        // n is power of 2\n        int p = rnd.next(0, (int)log2(n_max));\n        n = 1 << p;\n        n = min(max(n, n_min), n_max);\n    } else if (type == \"power2_minus1\") {\n        // n = 2^k - 1\n        int p = rnd.next(1, (int)log2(n_max)+1);\n        n = (1 << p) - 1;\n        n = min(max(n, n_min), n_max);\n    } else {\n        // default random\n        n = rnd.next(n_min, n_max);\n\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n_min = 1;\n    int n_max = opt<int>(\"n_max\", 1000000);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n;\n\n    if (type == \"min\") {\n        n = n_min;\n    } else if (type == \"max\") {\n        n = n_max;\n    } else if (type == \"small\") {\n        n = rnd.next(n_min+1, min(n_min+10, n_max)); // small n\n    } else if (type == \"random\") {\n        n = rnd.next(n_min, n_max);\n    } else if (type == \"power2\") {\n        // n is power of 2\n        int p = rnd.next(0, (int)log2(n_max));\n        n = 1 << p;\n        n = min(max(n, n_min), n_max);\n    } else if (type == \"power2_minus1\") {\n        // n = 2^k - 1\n        int p = rnd.next(1, (int)log2(n_max)+1);\n        n = (1 << p) - 1;\n        n = min(max(n, n_min), n_max);\n    } else {\n        // default random\n        n = rnd.next(n_min, n_max);\n\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n_max 1 -type min\n./gen -n_max 1 -type random\n\n./gen -n_max 10 -type small\n./gen -n_max 10 -type random\n./gen -n_max 10 -type power2\n./gen -n_max 10 -type power2_minus1\n\n./gen -n_max 1000 -type random\n./gen -n_max 1000 -type power2\n./gen -n_max 1000 -type power2_minus1\n\n./gen -n_max 1000000 -type max\n\n./gen -n_max 1000000 -type random\n./gen -n_max 1000000 -type power2\n./gen -n_max 1000000 -type power2_minus1\n\n./gen -n_max 1000000 -type random\n./gen -n_max 1000000 -type random\n./gen -n_max 1000000 -type random\n\n./gen -n_max 999999 -type random\n./gen -n_max 999999 -type random\n\n./gen -n_max 100000 -type random\n./gen -n_max 500000 -type random\n\n./gen -n_max 2 -type small\n./gen -n_max 3 -type small\n./gen -n_max 4 -type small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:48.384881",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "288/D",
      "title": "D. Polo the Penguin and Trees",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 80000) — the number of tree nodes. Each of the following n - 1 lines contains a pair of integers ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) — the i-th edge of the tree.It is guaranteed that the given graph is a tree.",
      "output_spec": "OutputIn a single line print a single integer — the answer to the problem.Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is recommended to use the cin, cout streams or the %I64d specificator.",
      "sample_tests": "ExamplesInputCopy41 22 33 4OutputCopy2",
      "description": "D. Polo the Penguin and Trees\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 80000) — the number of tree nodes. Each of the following n - 1 lines contains a pair of integers ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) — the i-th edge of the tree.It is guaranteed that the given graph is a tree.\n\nOutputIn a single line print a single integer — the answer to the problem.Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is recommended to use the cin, cout streams or the %I64d specificator.\n\nInputCopy41 22 33 4OutputCopy2\n\nInputCopy41 22 33 4\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #177 has been moved forward - Codeforces",
          "content": "As the TopCoder TCO 2013 Round 2A did not take place as planned but was moved (with sniper precision) right on the place of the Codeforces Round #177, we decided to reschedule the contest. I have to admit that my first urge was to leave everything as it is — TopCoder knew of Codeforces Round 177 and I cannot approve of such an approach to solving their technical issues. On the other hand, no fault lies on the community, and especially on dear witua, the writer of the forthcoming round. You’d like to participate and the writer is keen on making a round as popular as it gets. Besides, the problem coordinator Gerald would have fallen under much pressure, juggling work and TCO. That’s why the Codeforces Round #177 moves to the time that was initially planned for Round 178, and Round 178 moves a little ahead.We apologize for the schedule inconveniences and hope to see you among the Codeforces Round #177 participants. It will be fun!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 941
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Greetings!Codeforces Round #177 takes place tomorrow at 19:30 by Moscow. I hope you all will take part and enjoy the problems.Gerald, as usually, helps in preparings, Delinur translates all the problems for you. Thanks to them.Good Luck!Points distribution is standard:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Here are today's winners:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 463
        },
        {
          "title": "Codeforces Round #177, editorial - Codeforces",
          "content": "Hi!289A - Polo the Penguin and Segments Solution. First of all, we need to count, how many integers are inside given segments at the beginning. Since they don't intersect and even touch, no integer point can belong to more than one segment at the same time. This mans that starting value of segments is .If k divides p, then answer is 0 — we don't need to do anything, it's already done. But if it's not true, we need to know the minimal number of turns to make k divisor of p. Since we can in single turn increase p by 1 (by decreasing the left point of the leftmost segment), this number is equal to .Note. Note that just output is not enough: you need to pay attention for case when , or just output .289B - Polo the Penguin and MatrixSolution. First of all, we need to know when the answer is -1. For that you should notice that after any operation on number z, value doesn't change. Indeed, . This means that there is not answer if there are two different points for which is diffrent.Now we can transform our problem a bit. We can just write down all integers from matrix n × m to one array b of size k = n × m and sort them all in non-decreasing order. It is not hard to notice that in some of the optimal solutions, all number are at the end equal to one of the number for starting array. But also, it is optimal to make all number equal to (median element). Why to median? Suppose that we make all numbers equal to non-median element with index x. Then if |x - (k - x)| > 1 (i. e. from one side there are more elements than from another + 1). So, by moving out element more to median, we can make result better.After we know, to which number we should bring all, the answer is just , divided by d.Note. There is also full solution with complexity O(n2m2). 288A - Polo the Penguin and StringsSolution. To solve this problem we need to find out some contruction of resulting string. But first of all, we need find out when there is no result. Obviously, if k > n, there is not result — you cannot build string of length n with more than n characters. Another one case is when k = 1 and n > 1 — there is no answer in that case also.Consider that k = 2. It's really easy to see that answer for such case is a string of form abababab.... To construct string for k > 2 you need to add some extra characters — c, d, e.... To make string lexicographically smallest, you need to add that characters as close to the end as we can. And the best bet here is abbabab...abacdefgh.... So, we need just to add characters c, d, e, f... (i. e. k - 2 characters from c) to the end of the string.288B - Polo the Penguin and Houses Solution. Since k ≤ 8 you can solve this problem using brute force. This means that you can recursively construct all possible kk possibilities of first k assignments. (For k = 8 this is equal to 16 777 216.) For each of that assignments you need to check whether it is correct or not (by problem statement). Ths can be simply done using loops.When you know the number of assignment for the first k tables (let it be f(k)), all you need to do is to count the number of assignment for the rest n - k plaques. Since there should bo no path to 1, there should be no path to any of first k houses, so at each plaque for houses from k + 1 to n there can be any number from k + 1 to n, inclusive. There are (n - k)n - k such possibilities. And hence the total answer is f(k)(n - k)n - k.Note. There also exists solution with dynamic programming, and also there exists formula for f(x). You can read about it more here, here и here.288C - Polo the Penguin and XOR operationSolution. Since we need to maximize the result, we need to find such permutation, for which the least number of bit disappear. (We consider bit disappeared if it was 1 both in i and pi, so in it is 0). It turns out that for each n there is such permutation that no bit disappear. How to build it? We will be solving problem by iterations while n > 0. On each iteration, we need to find the biggest (the leftmost in binary representation) bit which is not 0 in binary representation of n and denote it position (bits are numbered from 0) by b. Now we need to find integer m — minimal integer from 0 to n, inclusive, such that b-th bit is also 1 in it. After that you can see (look image below), that at no bit disappear, at no bit disappear, ..., at no bit disappear. So, it is good to assign exactly that integers to our permutation, i. e. pm = m - 1 and pm - 1 = m, pm + 1 = m - 2 and pm - 2 = m + 1 and so on. After that assign value m - (n - m + 1) - 1 to n and go to next iteration.Now when we know how to build permutation and that no bit disappear, the value of the answer is equal to .288D - Polo the Penguin and Trees Solution. As always in such problems, root our tree at some vertex, for example vertex with number 1. We need to find out, what will happen when we have already chosen one path. Obviously, after deleting all vertices and their edges from that path, tree will disintegrate in some set of trees. Denote their sizes by c1, c2, ..., ck, where k is the number of trees. Then the number of ways to choose the second path is equal to . This gives us O(n2) solution — just to brute force all pathes and count the number of second paths by this formula. We need to do it in O(n). To do so, dfs our graph and fix some vertex during dfs, we will consider this vertex as the last vertex in the first path. Now we need to find the sum of above formula for the rest of the vertex. Here you can separately solve this problem for all vertex inside subtree of current vertex and for the rest of the vertices. For subtree vertices, you can, after finding the answers for all vertices of subtree, find the answer for root of subtree. To do so, you need to iterate all edges from current vertex and sum up results for that vetices. Also you need to add the sum of values multiplied by the number of vertices in subtree, where di are all sizes of subtrees of vertices from current vertex, not including from current edge). You can use some partial sums of something like that to make it linear. For the rest of the vertices (not in subtree) it is actually similar, but a bit harder. Here you need to keep current result as a parameter of dfs and when you entering some vertex you should add some additional counts to the current sum (similarly as in first case).Note. Also, you can find the number of bad pairs of pathes and subtract it from the total number. Also some divide and coquer solution exists, you can think about it.288E - Polo the Penguin and Lucky NumbersSolution. In this problem there are a lot of different formulas, most of them are for optimizing solution and making it lenear. Editorial shows just a general idea because it's pretty hard to explain all of them and good for you to derive it by yourself. If you have any questions — write them all in comments.Denote by a1, a2, ..., an all lucky number from segment. First of all, we need to do reduce the problem a bit. Let we have some fixed digit (pos, d), i. e. position of this digit is pos (from 0 from right to left) and value is d (4 or 7). Then, for all ai (1 ≤ i < n) such that pos-th digit of ai is equal to d, we need to add ai + 1 × d × 10pos to the answer. Now we can see that problem can be reduced to the following. For each fixed digit (pos, d) find the sum of all ai such that ai + 1 on the pos-th position has digit d. Obviously, we can solve the problem for 1..l and 1..r separately and then subtract the first from the second — that will be the answer.How to find such sum among all lucky numbers of some length but less than some lucky number x? We will describe the general idea. Any lucky number, less than x has some common prefix with x, then one digit is less than the corresponing in x (i. e. it is 7 in x and 4 in another integer) and the rest of the digits are arbitrary. So, by iterating all such positions where is the first digit less than in x, we can, using the fact that the rest of the digits are arbitrary and some formulas and precomputations, compute the results for each position and digit.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 288\\s*D"
          },
          "content_length": 8091
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 80000; // Maximum value of n\n\nint parent[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    int pu = find(u);\n    int pv = find(v);\n    if (pu == pv)\n        return false; // Cycle detected\n    parent[pu] = pv;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge cannot connect a node to itself (u_i != v_i)\");\n        inf.readEoln();\n\n        bool ok = unite(u, v);\n        ensuref(ok, \"Graph contains a cycle at edge %d (%d - %d)\", i + 1, u, v);\n    }\n\n    // After processing all edges, we should have only one connected component\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 80000; // Maximum value of n\n\nint parent[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    int pu = find(u);\n    int pv = find(v);\n    if (pu == pv)\n        return false; // Cycle detected\n    parent[pu] = pv;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge cannot connect a node to itself (u_i != v_i)\");\n        inf.readEoln();\n\n        bool ok = unite(u, v);\n        ensuref(ok, \"Graph contains a cycle at edge %d (%d - %d)\", i + 1, u, v);\n    }\n\n    // After processing all edges, we should have only one connected component\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 80000; // Maximum value of n\n\nint parent[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    int pu = find(u);\n    int pv = find(v);\n    if (pu == pv)\n        return false; // Cycle detected\n    parent[pu] = pv;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge cannot connect a node to itself (u_i != v_i)\");\n        inf.readEoln();\n\n        bool ok = unite(u, v);\n        ensuref(ok, \"Graph contains a cycle at edge %d (%d - %d)\", i + 1, u, v);\n    }\n\n    // After processing all edges, we should have only one connected component\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 2);\n\n    if (k <= 0) {\n        cerr << \"Invalid value of k: \" << k << endl;\n        exit(1);\n    }\n\n    vector<int> p(n);\n\n    if (type == \"chain\") {\n        // Chain: nodes connected in a line\n        for (int i = 1; i < n; ++i)\n            p[i] = i - 1;\n    } else if (type == \"star\") {\n        // Star: all nodes connected to node 0\n        for (int i = 1; i < n; ++i)\n            p[i] = 0;\n    } else if (type == \"binary\") {\n        // Binary tree\n        for (int i = 1; i < n; ++i)\n            p[i] = (i - 1) / 2;\n    } else if (type == \"random\") {\n        // Random tree\n        for (int i = 1; i < n; ++i)\n            p[i] = rnd.next(0, i - 1);\n    } else if (type == \"kary\") {\n        // k-ary tree\n        for (int i = 1; i < n; ++i)\n            p[i] = (i - 1) / k;\n    } else {\n        // Unknown type\n        cerr << \"Unknown tree type: \" << type << endl;\n        exit(1);\n    }\n\n    // Shuffle vertices 1..n-1\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Build edge list\n    vector< pair<int, int> > edges;\n    for (int i = 1; i < n; ++i) {\n        int u = perm[i];\n        int v = perm[p[i]];\n\n        // Randomly decide edge direction\n        if (rnd.next(0, 1))\n            edges.push_back( make_pair(u, v) );\n        else\n            edges.push_back( make_pair(v, u) );\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges\n    for (int i = 0; i < n - 1; ++i)\n        printf(\"%d %d\\n\", edges[i].first + 1, edges[i].second + 1);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 2);\n\n    if (k <= 0) {\n        cerr << \"Invalid value of k: \" << k << endl;\n        exit(1);\n    }\n\n    vector<int> p(n);\n\n    if (type == \"chain\") {\n        // Chain: nodes connected in a line\n        for (int i = 1; i < n; ++i)\n            p[i] = i - 1;\n    } else if (type == \"star\") {\n        // Star: all nodes connected to node 0\n        for (int i = 1; i < n; ++i)\n            p[i] = 0;\n    } else if (type == \"binary\") {\n        // Binary tree\n        for (int i = 1; i < n; ++i)\n            p[i] = (i - 1) / 2;\n    } else if (type == \"random\") {\n        // Random tree\n        for (int i = 1; i < n; ++i)\n            p[i] = rnd.next(0, i - 1);\n    } else if (type == \"kary\") {\n        // k-ary tree\n        for (int i = 1; i < n; ++i)\n            p[i] = (i - 1) / k;\n    } else {\n        // Unknown type\n        cerr << \"Unknown tree type: \" << type << endl;\n        exit(1);\n    }\n\n    // Shuffle vertices 1..n-1\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Build edge list\n    vector< pair<int, int> > edges;\n    for (int i = 1; i < n; ++i) {\n        int u = perm[i];\n        int v = perm[p[i]];\n\n        // Randomly decide edge direction\n        if (rnd.next(0, 1))\n            edges.push_back( make_pair(u, v) );\n        else\n            edges.push_back( make_pair(v, u) );\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges\n    for (int i = 0; i < n - 1; ++i)\n        printf(\"%d %d\\n\", edges[i].first + 1, edges[i].second + 1);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -type chain\n./gen -n 1 -type star\n./gen -n 1 -type random\n./gen -n 1 -type binary\n./gen -n 1 -type kary -k 2\n\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type random\n./gen -n 2 -type binary\n./gen -n 2 -type kary -k 2\n\n# Small n with various k values\n./gen -n 5 -type kary -k 1\n./gen -n 5 -type kary -k 2\n./gen -n 5 -type kary -k 5\n\n# Medium n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random\n./gen -n 10 -type binary\n./gen -n 10 -type kary -k 3\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type random\n./gen -n 100 -type binary\n./gen -n 100 -type kary -k 10\n\n# Large n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type random\n./gen -n 1000 -type binary\n./gen -n 1000 -type kary -k 50\n\n# n close to maximum\n./gen -n 79999 -type random\n\n# Maximum n\n./gen -n 80000 -type chain\n./gen -n 80000 -type star\n./gen -n 80000 -type binary\n./gen -n 80000 -type random\n\n# Edge cases with kary trees\n./gen -n 80000 -type kary -k 1      # Should be same as star\n./gen -n 80000 -type kary -k 79999  # Root connected to all other nodes\n./gen -n 80000 -type kary -k 2\n./gen -n 80000 -type kary -k 3\n./gen -n 80000 -type kary -k 10\n./gen -n 80000 -type kary -k 100\n\n# Other special cases\n./gen -n 80000 -type binary\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type chain\n./gen -n 3 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:50.295420",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "288/E",
      "title": "E. Polo the Penguin and Lucky Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a positive integer l, and the second line contains a positive integer r (1 ≤ l < r ≤ 10100000). The numbers are given without any leading zeroes.It is guaranteed that the lengths of the given numbers are equal to each other and that both of them are lucky numbers.",
      "output_spec": "OutputIn the single line print a single integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy47OutputCopy28InputCopy474777OutputCopy2316330",
      "description": "E. Polo the Penguin and Lucky Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a positive integer l, and the second line contains a positive integer r (1 ≤ l < r ≤ 10100000). The numbers are given without any leading zeroes.It is guaranteed that the lengths of the given numbers are equal to each other and that both of them are lucky numbers.\n\nOutputIn the single line print a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy47OutputCopy28InputCopy474777OutputCopy2316330\n\nInputCopy47\n\nOutputCopy28\n\nInputCopy474777\n\nOutputCopy2316330",
      "solutions": [
        {
          "title": "Codeforces Round #177 has been moved forward - Codeforces",
          "content": "As the TopCoder TCO 2013 Round 2A did not take place as planned but was moved (with sniper precision) right on the place of the Codeforces Round #177, we decided to reschedule the contest. I have to admit that my first urge was to leave everything as it is — TopCoder knew of Codeforces Round 177 and I cannot approve of such an approach to solving their technical issues. On the other hand, no fault lies on the community, and especially on dear witua, the writer of the forthcoming round. You’d like to participate and the writer is keen on making a round as popular as it gets. Besides, the problem coordinator Gerald would have fallen under much pressure, juggling work and TCO. That’s why the Codeforces Round #177 moves to the time that was initially planned for Round 178, and Round 178 moves a little ahead.We apologize for the schedule inconveniences and hope to see you among the Codeforces Round #177 participants. It will be fun!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 941
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Greetings!Codeforces Round #177 takes place tomorrow at 19:30 by Moscow. I hope you all will take part and enjoy the problems.Gerald, as usually, helps in preparings, Delinur translates all the problems for you. Thanks to them.Good Luck!Points distribution is standard:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Here are today's winners:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 463
        },
        {
          "title": "Codeforces Round #177, editorial - Codeforces",
          "content": "Hi!289A - Polo the Penguin and Segments Solution. First of all, we need to count, how many integers are inside given segments at the beginning. Since they don't intersect and even touch, no integer point can belong to more than one segment at the same time. This mans that starting value of segments is .If k divides p, then answer is 0 — we don't need to do anything, it's already done. But if it's not true, we need to know the minimal number of turns to make k divisor of p. Since we can in single turn increase p by 1 (by decreasing the left point of the leftmost segment), this number is equal to .Note. Note that just output is not enough: you need to pay attention for case when , or just output .289B - Polo the Penguin and MatrixSolution. First of all, we need to know when the answer is -1. For that you should notice that after any operation on number z, value doesn't change. Indeed, . This means that there is not answer if there are two different points for which is diffrent.Now we can transform our problem a bit. We can just write down all integers from matrix n × m to one array b of size k = n × m and sort them all in non-decreasing order. It is not hard to notice that in some of the optimal solutions, all number are at the end equal to one of the number for starting array. But also, it is optimal to make all number equal to (median element). Why to median? Suppose that we make all numbers equal to non-median element with index x. Then if |x - (k - x)| > 1 (i. e. from one side there are more elements than from another + 1). So, by moving out element more to median, we can make result better.After we know, to which number we should bring all, the answer is just , divided by d.Note. There is also full solution with complexity O(n2m2). 288A - Polo the Penguin and StringsSolution. To solve this problem we need to find out some contruction of resulting string. But first of all, we need find out when there is no result. Obviously, if k > n, there is not result — you cannot build string of length n with more than n characters. Another one case is when k = 1 and n > 1 — there is no answer in that case also.Consider that k = 2. It's really easy to see that answer for such case is a string of form abababab.... To construct string for k > 2 you need to add some extra characters — c, d, e.... To make string lexicographically smallest, you need to add that characters as close to the end as we can. And the best bet here is abbabab...abacdefgh.... So, we need just to add characters c, d, e, f... (i. e. k - 2 characters from c) to the end of the string.288B - Polo the Penguin and Houses Solution. Since k ≤ 8 you can solve this problem using brute force. This means that you can recursively construct all possible kk possibilities of first k assignments. (For k = 8 this is equal to 16 777 216.) For each of that assignments you need to check whether it is correct or not (by problem statement). Ths can be simply done using loops.When you know the number of assignment for the first k tables (let it be f(k)), all you need to do is to count the number of assignment for the rest n - k plaques. Since there should bo no path to 1, there should be no path to any of first k houses, so at each plaque for houses from k + 1 to n there can be any number from k + 1 to n, inclusive. There are (n - k)n - k such possibilities. And hence the total answer is f(k)(n - k)n - k.Note. There also exists solution with dynamic programming, and also there exists formula for f(x). You can read about it more here, here и here.288C - Polo the Penguin and XOR operationSolution. Since we need to maximize the result, we need to find such permutation, for which the least number of bit disappear. (We consider bit disappeared if it was 1 both in i and pi, so in it is 0). It turns out that for each n there is such permutation that no bit disappear. How to build it? We will be solving problem by iterations while n > 0. On each iteration, we need to find the biggest (the leftmost in binary representation) bit which is not 0 in binary representation of n and denote it position (bits are numbered from 0) by b. Now we need to find integer m — minimal integer from 0 to n, inclusive, such that b-th bit is also 1 in it. After that you can see (look image below), that at no bit disappear, at no bit disappear, ..., at no bit disappear. So, it is good to assign exactly that integers to our permutation, i. e. pm = m - 1 and pm - 1 = m, pm + 1 = m - 2 and pm - 2 = m + 1 and so on. After that assign value m - (n - m + 1) - 1 to n and go to next iteration.Now when we know how to build permutation and that no bit disappear, the value of the answer is equal to .288D - Polo the Penguin and Trees Solution. As always in such problems, root our tree at some vertex, for example vertex with number 1. We need to find out, what will happen when we have already chosen one path. Obviously, after deleting all vertices and their edges from that path, tree will disintegrate in some set of trees. Denote their sizes by c1, c2, ..., ck, where k is the number of trees. Then the number of ways to choose the second path is equal to . This gives us O(n2) solution — just to brute force all pathes and count the number of second paths by this formula. We need to do it in O(n). To do so, dfs our graph and fix some vertex during dfs, we will consider this vertex as the last vertex in the first path. Now we need to find the sum of above formula for the rest of the vertex. Here you can separately solve this problem for all vertex inside subtree of current vertex and for the rest of the vertices. For subtree vertices, you can, after finding the answers for all vertices of subtree, find the answer for root of subtree. To do so, you need to iterate all edges from current vertex and sum up results for that vetices. Also you need to add the sum of values multiplied by the number of vertices in subtree, where di are all sizes of subtrees of vertices from current vertex, not including from current edge). You can use some partial sums of something like that to make it linear. For the rest of the vertices (not in subtree) it is actually similar, but a bit harder. Here you need to keep current result as a parameter of dfs and when you entering some vertex you should add some additional counts to the current sum (similarly as in first case).Note. Also, you can find the number of bad pairs of pathes and subtract it from the total number. Also some divide and coquer solution exists, you can think about it.288E - Polo the Penguin and Lucky NumbersSolution. In this problem there are a lot of different formulas, most of them are for optimizing solution and making it lenear. Editorial shows just a general idea because it's pretty hard to explain all of them and good for you to derive it by yourself. If you have any questions — write them all in comments.Denote by a1, a2, ..., an all lucky number from segment. First of all, we need to do reduce the problem a bit. Let we have some fixed digit (pos, d), i. e. position of this digit is pos (from 0 from right to left) and value is d (4 or 7). Then, for all ai (1 ≤ i < n) such that pos-th digit of ai is equal to d, we need to add ai + 1 × d × 10pos to the answer. Now we can see that problem can be reduced to the following. For each fixed digit (pos, d) find the sum of all ai such that ai + 1 on the pos-th position has digit d. Obviously, we can solve the problem for 1..l and 1..r separately and then subtract the first from the second — that will be the answer.How to find such sum among all lucky numbers of some length but less than some lucky number x? We will describe the general idea. Any lucky number, less than x has some common prefix with x, then one digit is less than the corresponing in x (i. e. it is 7 in x and 4 in another integer) and the rest of the digits are arbitrary. So, by iterating all such positions where is the first digit less than in x, we can, using the fact that the rest of the digits are arbitrary and some formulas and precomputations, compute the results for each position and digit.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 288\\s*E"
          },
          "content_length": 8091
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string l = inf.readToken(\"[47]{1,1000000}\", \"l\");\n    inf.readEoln();\n\n    string r = inf.readToken(\"[47]{1,1000000}\", \"r\");\n    inf.readEoln();\n\n    ensuref(l.length() == r.length(),\n            \"Lengths of l and r must be equal, but len(l)=%zu and len(r)=%zu\",\n            l.length(), r.length());\n\n    ensuref(l < r, \"Expected l < r, but l=%s is not less than r=%s\", l.c_str(), r.c_str());\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string l = inf.readToken(\"[47]{1,1000000}\", \"l\");\n    inf.readEoln();\n\n    string r = inf.readToken(\"[47]{1,1000000}\", \"r\");\n    inf.readEoln();\n\n    ensuref(l.length() == r.length(),\n            \"Lengths of l and r must be equal, but len(l)=%zu and len(r)=%zu\",\n            l.length(), r.length());\n\n    ensuref(l < r, \"Expected l < r, but l=%s is not less than r=%s\", l.c_str(), r.c_str());\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string l = inf.readToken(\"[47]{1,1000000}\", \"l\");\n    inf.readEoln();\n\n    string r = inf.readToken(\"[47]{1,1000000}\", \"r\");\n    inf.readEoln();\n\n    ensuref(l.length() == r.length(),\n            \"Lengths of l and r must be equal, but len(l)=%zu and len(r)=%zu\",\n            l.length(), r.length());\n\n    ensuref(l < r, \"Expected l < r, but l=%s is not less than r=%s\", l.c_str(), r.c_str());\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) \n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string l, r;\n\n    if (type == \"minmax\") {\n        // l is the smallest lucky number of length n (all '4's)\n        // r is the largest lucky number of length n (all '7's)\n        l = string(n, '4');\n        r = string(n, '7');\n    } \n    else if (type == \"random\") {\n        // Generate two random lucky numbers of length n, l and r, with l < r\n        string digits = \"47\";\n        l = r = \"\";\n        for (int i = 0; i < n; ++i) {\n            l += digits[rnd.next(2)];\n            r += digits[rnd.next(2)];\n        }\n        // Ensure l < r\n        if (l >= r) {\n            swap(l, r);\n            if (l == r) {\n                // Regenerate r until l < r\n                while (true) {\n                    r = \"\";\n                    for (int i = 0; i < n; ++i) {\n                        r += digits[rnd.next(2)];\n                    }\n                    if (l < r) break;\n                }\n            }\n        }\n    }\n    else if (type == \"consecutive\") {\n        // Generate a random lucky number l of length n\n        vector<int> l_bin(n);\n        for (int i = 0; i < n; i++) {\n            l_bin[i] = rnd.next(2);\n        }\n        l = \"\";\n        for (int i = 0; i < n; i++) {\n            l += (l_bin[i] == 0 ? '4' : '7');\n        }\n        \n        // Generate the next lucky number r\n        vector<int> r_bin = l_bin;\n        int i = n - 1;\n        while (i >= 0 && r_bin[i] == 1) {\n            r_bin[i] = 0;\n            i--;\n        }\n        if (i >= 0) {\n            r_bin[i] = 1;\n            r = \"\";\n            for (int j = 0; j < n; j++) {\n                r += (r_bin[j] == 0 ? '4' : '7');\n            }\n        } else {\n            // Overflow, generate minimal l and r\n            l = string(n, '4');\n            r = l;\n            r[n - 1] = '7';\n        }\n        // Ensure l < r\n        if (l >= r) swap(l, r);\n    }\n    else if (type == \"almost_equal\") {\n        // Generate a random lucky number l of length n\n        l = \"\";\n        for (int i = 0; i < n; ++i) {\n            l += rnd.next(2) ? '4' : '7';\n        }\n        // Change one '4' to '7' from the right to make r > l\n        r = l;\n        bool changed = false;\n        for (int i = n - 1; i >= 0; i--) {\n            if (l[i] == '4') {\n                r[i] = '7';\n                changed = true;\n                break;\n            }\n        }\n        if (!changed) {\n            // All digits are '7', change the last digit to '4' in l\n            l[n - 1] = '4';\n            r = l;\n            r[n - 1] = '7';\n        }\n        // Ensure l < r\n        if (l >= r) swap(l, r);\n    }\n    else {\n        // Default: same as \"random\"\n        string digits = \"47\";\n        l = r = \"\";\n        for (int i = 0; i < n; ++i) {\n            l += digits[rnd.next(2)];\n            r += digits[rnd.next(2)];\n        }\n        if (l >= r) {\n            swap(l, r);\n            if (l == r) {\n                // Regenerate r until l < r\n                while (true) {\n                    r = \"\";\n                    for (int i = 0; i < n; ++i) {\n                        r += digits[rnd.next(2)];\n                    }\n                    if (l < r) break;\n                }\n            }\n        }\n    }\n\n    // Output l and r\n    printf(\"%s\\n\", l.c_str());\n    printf(\"%s\\n\", r.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) \n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string l, r;\n\n    if (type == \"minmax\") {\n        // l is the smallest lucky number of length n (all '4's)\n        // r is the largest lucky number of length n (all '7's)\n        l = string(n, '4');\n        r = string(n, '7');\n    } \n    else if (type == \"random\") {\n        // Generate two random lucky numbers of length n, l and r, with l < r\n        string digits = \"47\";\n        l = r = \"\";\n        for (int i = 0; i < n; ++i) {\n            l += digits[rnd.next(2)];\n            r += digits[rnd.next(2)];\n        }\n        // Ensure l < r\n        if (l >= r) {\n            swap(l, r);\n            if (l == r) {\n                // Regenerate r until l < r\n                while (true) {\n                    r = \"\";\n                    for (int i = 0; i < n; ++i) {\n                        r += digits[rnd.next(2)];\n                    }\n                    if (l < r) break;\n                }\n            }\n        }\n    }\n    else if (type == \"consecutive\") {\n        // Generate a random lucky number l of length n\n        vector<int> l_bin(n);\n        for (int i = 0; i < n; i++) {\n            l_bin[i] = rnd.next(2);\n        }\n        l = \"\";\n        for (int i = 0; i < n; i++) {\n            l += (l_bin[i] == 0 ? '4' : '7');\n        }\n        \n        // Generate the next lucky number r\n        vector<int> r_bin = l_bin;\n        int i = n - 1;\n        while (i >= 0 && r_bin[i] == 1) {\n            r_bin[i] = 0;\n            i--;\n        }\n        if (i >= 0) {\n            r_bin[i] = 1;\n            r = \"\";\n            for (int j = 0; j < n; j++) {\n                r += (r_bin[j] == 0 ? '4' : '7');\n            }\n        } else {\n            // Overflow, generate minimal l and r\n            l = string(n, '4');\n            r = l;\n            r[n - 1] = '7';\n        }\n        // Ensure l < r\n        if (l >= r) swap(l, r);\n    }\n    else if (type == \"almost_equal\") {\n        // Generate a random lucky number l of length n\n        l = \"\";\n        for (int i = 0; i < n; ++i) {\n            l += rnd.next(2) ? '4' : '7';\n        }\n        // Change one '4' to '7' from the right to make r > l\n        r = l;\n        bool changed = false;\n        for (int i = n - 1; i >= 0; i--) {\n            if (l[i] == '4') {\n                r[i] = '7';\n                changed = true;\n                break;\n            }\n        }\n        if (!changed) {\n            // All digits are '7', change the last digit to '4' in l\n            l[n - 1] = '4';\n            r = l;\n            r[n - 1] = '7';\n        }\n        // Ensure l < r\n        if (l >= r) swap(l, r);\n    }\n    else {\n        // Default: same as \"random\"\n        string digits = \"47\";\n        l = r = \"\";\n        for (int i = 0; i < n; ++i) {\n            l += digits[rnd.next(2)];\n            r += digits[rnd.next(2)];\n        }\n        if (l >= r) {\n            swap(l, r);\n            if (l == r) {\n                // Regenerate r until l < r\n                while (true) {\n                    r = \"\";\n                    for (int i = 0; i < n; ++i) {\n                        r += digits[rnd.next(2)];\n                    }\n                    if (l < r) break;\n                }\n            }\n        }\n    }\n\n    // Output l and r\n    printf(\"%s\\n\", l.c_str());\n    printf(\"%s\\n\", r.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minmax\n./gen -n 1 -type random\n./gen -n 1 -type consecutive\n./gen -n 1 -type almost_equal\n\n./gen -n 2 -type minmax\n./gen -n 2 -type random\n./gen -n 2 -type consecutive\n./gen -n 2 -type almost_equal\n\n./gen -n 3 -type minmax\n./gen -n 3 -type random\n./gen -n 3 -type consecutive\n./gen -n 3 -type almost_equal\n\n./gen -n 10 -type random\n./gen -n 10 -type minmax\n./gen -n 10 -type consecutive\n./gen -n 10 -type almost_equal\n\n./gen -n 100 -type random\n./gen -n 100 -type minmax\n./gen -n 100 -type consecutive\n./gen -n 100 -type almost_equal\n\n./gen -n 1000 -type random\n./gen -n 1000 -type minmax\n./gen -n 1000 -type consecutive\n./gen -n 1000 -type almost_equal\n\n./gen -n 10000 -type random\n./gen -n 10000 -type minmax\n./gen -n 10000 -type consecutive\n./gen -n 10000 -type almost_equal\n\n./gen -n 100000 -type random\n./gen -n 100000 -type minmax\n./gen -n 100000 -type consecutive\n./gen -n 100000 -type almost_equal\n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type minmax\n./gen -n 1000000 -type consecutive\n./gen -n 1000000 -type almost_equal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:52.370526",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "289/A",
      "title": "A. Polo the Penguin and Segments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n, k ≤ 105). Each of the following n lines contain a segment as a pair of integers li and ri ( - 105 ≤ li ≤ ri ≤ 105), separated by a space.It is guaranteed that no two segments intersect. In other words, for any two integers i, j (1 ≤ i < j ≤ n) the following inequality holds, min(ri, rj) < max(li, lj).",
      "output_spec": "OutputIn a single line print a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy2 31 23 4OutputCopy2InputCopy3 71 23 34 7OutputCopy0",
      "description": "A. Polo the Penguin and Segments\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n, k ≤ 105). Each of the following n lines contain a segment as a pair of integers li and ri ( - 105 ≤ li ≤ ri ≤ 105), separated by a space.It is guaranteed that no two segments intersect. In other words, for any two integers i, j (1 ≤ i < j ≤ n) the following inequality holds, min(ri, rj) < max(li, lj).\n\nOutputIn a single line print a single integer — the answer to the problem.\n\nInputCopy2 31 23 4OutputCopy2InputCopy3 71 23 34 7OutputCopy0\n\nInputCopy2 31 23 4\n\nOutputCopy2\n\nInputCopy3 71 23 34 7\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #177 has been moved forward - Codeforces",
          "content": "As the TopCoder TCO 2013 Round 2A did not take place as planned but was moved (with sniper precision) right on the place of the Codeforces Round #177, we decided to reschedule the contest. I have to admit that my first urge was to leave everything as it is — TopCoder knew of Codeforces Round 177 and I cannot approve of such an approach to solving their technical issues. On the other hand, no fault lies on the community, and especially on dear witua, the writer of the forthcoming round. You’d like to participate and the writer is keen on making a round as popular as it gets. Besides, the problem coordinator Gerald would have fallen under much pressure, juggling work and TCO. That’s why the Codeforces Round #177 moves to the time that was initially planned for Round 178, and Round 178 moves a little ahead.We apologize for the schedule inconveniences and hope to see you among the Codeforces Round #177 participants. It will be fun!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 941
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Greetings!Codeforces Round #177 takes place tomorrow at 19:30 by Moscow. I hope you all will take part and enjoy the problems.Gerald, as usually, helps in preparings, Delinur translates all the problems for you. Thanks to them.Good Luck!Points distribution is standard:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Here are today's winners:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 463
        },
        {
          "title": "Codeforces Round #177, editorial - Codeforces",
          "content": "Hi!289A - Polo the Penguin and Segments Solution. First of all, we need to count, how many integers are inside given segments at the beginning. Since they don't intersect and even touch, no integer point can belong to more than one segment at the same time. This mans that starting value of segments is .If k divides p, then answer is 0 — we don't need to do anything, it's already done. But if it's not true, we need to know the minimal number of turns to make k divisor of p. Since we can in single turn increase p by 1 (by decreasing the left point of the leftmost segment), this number is equal to .Note. Note that just output is not enough: you need to pay attention for case when , or just output .289B - Polo the Penguin and MatrixSolution. First of all, we need to know when the answer is -1. For that you should notice that after any operation on number z, value doesn't change. Indeed, . This means that there is not answer if there are two different points for which is diffrent.Now we can transform our problem a bit. We can just write down all integers from matrix n × m to one array b of size k = n × m and sort them all in non-decreasing order. It is not hard to notice that in some of the optimal solutions, all number are at the end equal to one of the number for starting array. But also, it is optimal to make all number equal to (median element). Why to median? Suppose that we make all numbers equal to non-median element with index x. Then if |x - (k - x)| > 1 (i. e. from one side there are more elements than from another + 1). So, by moving out element more to median, we can make result better.After we know, to which number we should bring all, the answer is just , divided by d.Note. There is also full solution with complexity O(n2m2). 288A - Polo the Penguin and StringsSolution. To solve this problem we need to find out some contruction of resulting string. But first of all, we need find out when there is no result. Obviously, if k > n, there is not result — you cannot build string of length n with more than n characters. Another one case is when k = 1 and n > 1 — there is no answer in that case also.Consider that k = 2. It's really easy to see that answer for such case is a string of form abababab.... To construct string for k > 2 you need to add some extra characters — c, d, e.... To make string lexicographically smallest, you need to add that characters as close to the end as we can. And the best bet here is abbabab...abacdefgh.... So, we need just to add characters c, d, e, f... (i. e. k - 2 characters from c) to the end of the string.288B - Polo the Penguin and Houses Solution. Since k ≤ 8 you can solve this problem using brute force. This means that you can recursively construct all possible kk possibilities of first k assignments. (For k = 8 this is equal to 16 777 216.) For each of that assignments you need to check whether it is correct or not (by problem statement). Ths can be simply done using loops.When you know the number of assignment for the first k tables (let it be f(k)), all you need to do is to count the number of assignment for the rest n - k plaques. Since there should bo no path to 1, there should be no path to any of first k houses, so at each plaque for houses from k + 1 to n there can be any number from k + 1 to n, inclusive. There are (n - k)n - k such possibilities. And hence the total answer is f(k)(n - k)n - k.Note. There also exists solution with dynamic programming, and also there exists formula for f(x). You can read about it more here, here и here.288C - Polo the Penguin and XOR operationSolution. Since we need to maximize the result, we need to find such permutation, for which the least number of bit disappear. (We consider bit disappeared if it was 1 both in i and pi, so in it is 0). It turns out that for each n there is such permutation that no bit disappear. How to build it? We will be solving problem by iterations while n > 0. On each iteration, we need to find the biggest (the leftmost in binary representation) bit which is not 0 in binary representation of n and denote it position (bits are numbered from 0) by b. Now we need to find integer m — minimal integer from 0 to n, inclusive, such that b-th bit is also 1 in it. After that you can see (look image below), that at no bit disappear, at no bit disappear, ..., at no bit disappear. So, it is good to assign exactly that integers to our permutation, i. e. pm = m - 1 and pm - 1 = m, pm + 1 = m - 2 and pm - 2 = m + 1 and so on. After that assign value m - (n - m + 1) - 1 to n and go to next iteration.Now when we know how to build permutation and that no bit disappear, the value of the answer is equal to .288D - Polo the Penguin and Trees Solution. As always in such problems, root our tree at some vertex, for example vertex with number 1. We need to find out, what will happen when we have already chosen one path. Obviously, after deleting all vertices and their edges from that path, tree will disintegrate in some set of trees. Denote their sizes by c1, c2, ..., ck, where k is the number of trees. Then the number of ways to choose the second path is equal to . This gives us O(n2) solution — just to brute force all pathes and count the number of second paths by this formula. We need to do it in O(n). To do so, dfs our graph and fix some vertex during dfs, we will consider this vertex as the last vertex in the first path. Now we need to find the sum of above formula for the rest of the vertex. Here you can separately solve this problem for all vertex inside subtree of current vertex and for the rest of the vertices. For subtree vertices, you can, after finding the answers for all vertices of subtree, find the answer for root of subtree. To do so, you need to iterate all edges from current vertex and sum up results for that vetices. Also you need to add the sum of values multiplied by the number of vertices in subtree, where di are all sizes of subtrees of vertices from current vertex, not including from current edge). You can use some partial sums of something like that to make it linear. For the rest of the vertices (not in subtree) it is actually similar, but a bit harder. Here you need to keep current result as a parameter of dfs and when you entering some vertex you should add some additional counts to the current sum (similarly as in first case).Note. Also, you can find the number of bad pairs of pathes and subtract it from the total number. Also some divide and coquer solution exists, you can think about it.288E - Polo the Penguin and Lucky NumbersSolution. In this problem there are a lot of different formulas, most of them are for optimizing solution and making it lenear. Editorial shows just a general idea because it's pretty hard to explain all of them and good for you to derive it by yourself. If you have any questions — write them all in comments.Denote by a1, a2, ..., an all lucky number from segment. First of all, we need to do reduce the problem a bit. Let we have some fixed digit (pos, d), i. e. position of this digit is pos (from 0 from right to left) and value is d (4 or 7). Then, for all ai (1 ≤ i < n) such that pos-th digit of ai is equal to d, we need to add ai + 1 × d × 10pos to the answer. Now we can see that problem can be reduced to the following. For each fixed digit (pos, d) find the sum of all ai such that ai + 1 on the pos-th position has digit d. Obviously, we can solve the problem for 1..l and 1..r separately and then subtract the first from the second — that will be the answer.How to find such sum among all lucky numbers of some length but less than some lucky number x? We will describe the general idea. Any lucky number, less than x has some common prefix with x, then one digit is less than the corresponing in x (i. e. it is 7 in x and 4 in another integer) and the rest of the digits are arbitrary. So, by iterating all such positions where is the first digit less than in x, we can, using the fact that the rest of the digits are arbitrary and some formulas and precomputations, compute the results for each position and digit.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 289\\s*A"
          },
          "content_length": 8091
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<pair<int, int>> intervals(n);\n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(-100000, 100000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, 100000, \"r_i\"); // l_i ≤ r_i\n        inf.readEoln();\n        intervals[i] = make_pair(l_i, r_i);\n    }\n    inf.readEof();\n\n    sort(intervals.begin(), intervals.end());\n    for (int i = 0; i + 1 < n; i++) {\n        int r_i = intervals[i].second;\n        int l_next = intervals[i + 1].first;\n        ensuref(r_i < l_next, \"Intervals %d and %d intersect or touch at point %d\", i + 1, i + 2, l_next);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<pair<int, int>> intervals(n);\n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(-100000, 100000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, 100000, \"r_i\"); // l_i ≤ r_i\n        inf.readEoln();\n        intervals[i] = make_pair(l_i, r_i);\n    }\n    inf.readEof();\n\n    sort(intervals.begin(), intervals.end());\n    for (int i = 0; i + 1 < n; i++) {\n        int r_i = intervals[i].second;\n        int l_next = intervals[i + 1].first;\n        ensuref(r_i < l_next, \"Intervals %d and %d intersect or touch at point %d\", i + 1, i + 2, l_next);\n    }\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<pair<int, int>> intervals(n);\n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(-100000, 100000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, 100000, \"r_i\"); // l_i ≤ r_i\n        inf.readEoln();\n        intervals[i] = make_pair(l_i, r_i);\n    }\n    inf.readEof();\n\n    sort(intervals.begin(), intervals.end());\n    for (int i = 0; i + 1 < n; i++) {\n        int r_i = intervals[i].second;\n        int l_next = intervals[i + 1].first;\n        ensuref(r_i < l_next, \"Intervals %d and %d intersect or touch at point %d\", i + 1, i + 2, l_next);\n    }\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -100000;\nconst int MAX_COORD = 100000;\nconst int MAX_RANGE = MAX_COORD - MIN_COORD + 1;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\");\n\n    // Initialize parameters\n    vector<int> len(n);\n    int total_length = 0;\n    int min_gap = 1;\n    int total_available = MAX_RANGE - (n - 1) * min_gap; // Total length available for intervals\n\n    if (type == \"min\") {\n        // Intervals of length 1\n        for (int i = 0; i < n; i++)\n            len[i] = 1;\n    } else if (type == \"max\") {\n        // Intervals as long as possible\n        int base_len = total_available / n;\n        int extra = total_available % n;\n        for (int i = 0; i < n; i++) {\n            len[i] = base_len;\n            if (i < extra) len[i]++;\n        }\n    } else if (type == \"random\") {\n        // Random intervals\n        int remaining_length = total_available;\n        for (int i = 0; i < n; i++) {\n            int max_len = remaining_length - (n - i - 1);\n            len[i] = rnd.next(1, max_len);\n            remaining_length -= len[i];\n        }\n    } else if (type == \"negative\") {\n        // Intervals in negative range\n        for (int i = 0; i < n; i++)\n            len[i] = 1;\n    } else if (type == \"edge0\" || type == \"edge1\" || type == \"edgek1\") {\n        // Intervals to adjust total length modulo k\n        for (int i = 0; i < n - 1; i++)\n            len[i] = 1;\n        int current_total = n - 1;\n        int target_mod = 0;\n        if (type == \"edge1\") target_mod = 1;\n        if (type == \"edgek1\") target_mod = k - 1;\n        int rem = (target_mod - current_total % k + k) % k;\n        if (rem == 0) rem += k;\n        len[n - 1] = rem;\n    } else {\n        // Default to intervals of length 1\n        for (int i = 0; i < n; i++)\n            len[i] = 1;\n    }\n\n    // Generate intervals\n    vector<int> li(n), ri(n);\n    int pos = MIN_COORD;\n    for (int i = 0; i < n; i++) {\n        li[i] = pos;\n        ri[i] = li[i] + len[i] - 1;\n        if (ri[i] > MAX_COORD) {\n            // Adjust starting position if we exceed MAX_COORD\n            int shift = ri[i] - MAX_COORD;\n            li[i] -= shift;\n            ri[i] -= shift;\n        }\n        pos = ri[i] + min_gap + rnd.next(0, 5); // Add some random gap\n        if (pos > MAX_COORD - (n - i - 1)) pos = MAX_COORD - (n - i - 1);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; i++)\n        printf(\"%d %d\\n\", li[i], ri[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -100000;\nconst int MAX_COORD = 100000;\nconst int MAX_RANGE = MAX_COORD - MIN_COORD + 1;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\");\n\n    // Initialize parameters\n    vector<int> len(n);\n    int total_length = 0;\n    int min_gap = 1;\n    int total_available = MAX_RANGE - (n - 1) * min_gap; // Total length available for intervals\n\n    if (type == \"min\") {\n        // Intervals of length 1\n        for (int i = 0; i < n; i++)\n            len[i] = 1;\n    } else if (type == \"max\") {\n        // Intervals as long as possible\n        int base_len = total_available / n;\n        int extra = total_available % n;\n        for (int i = 0; i < n; i++) {\n            len[i] = base_len;\n            if (i < extra) len[i]++;\n        }\n    } else if (type == \"random\") {\n        // Random intervals\n        int remaining_length = total_available;\n        for (int i = 0; i < n; i++) {\n            int max_len = remaining_length - (n - i - 1);\n            len[i] = rnd.next(1, max_len);\n            remaining_length -= len[i];\n        }\n    } else if (type == \"negative\") {\n        // Intervals in negative range\n        for (int i = 0; i < n; i++)\n            len[i] = 1;\n    } else if (type == \"edge0\" || type == \"edge1\" || type == \"edgek1\") {\n        // Intervals to adjust total length modulo k\n        for (int i = 0; i < n - 1; i++)\n            len[i] = 1;\n        int current_total = n - 1;\n        int target_mod = 0;\n        if (type == \"edge1\") target_mod = 1;\n        if (type == \"edgek1\") target_mod = k - 1;\n        int rem = (target_mod - current_total % k + k) % k;\n        if (rem == 0) rem += k;\n        len[n - 1] = rem;\n    } else {\n        // Default to intervals of length 1\n        for (int i = 0; i < n; i++)\n            len[i] = 1;\n    }\n\n    // Generate intervals\n    vector<int> li(n), ri(n);\n    int pos = MIN_COORD;\n    for (int i = 0; i < n; i++) {\n        li[i] = pos;\n        ri[i] = li[i] + len[i] - 1;\n        if (ri[i] > MAX_COORD) {\n            // Adjust starting position if we exceed MAX_COORD\n            int shift = ri[i] - MAX_COORD;\n            li[i] -= shift;\n            ri[i] -= shift;\n        }\n        pos = ri[i] + min_gap + rnd.next(0, 5); // Add some random gap\n        if (pos > MAX_COORD - (n - i - 1)) pos = MAX_COORD - (n - i - 1);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; i++)\n        printf(\"%d %d\\n\", li[i], ri[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type min\n./gen -n 2 -k 3 -type min\n./gen -n 5 -k 7 -type min\n\n./gen -n 10 -k 10 -type min\n./gen -n 10 -k 10 -type max\n./gen -n 10 -k 10 -type random\n\n./gen -n 100 -k 50 -type min\n./gen -n 100 -k 50 -type max\n./gen -n 100 -k 50 -type random\n\n./gen -n 1000 -k 1000 -type min\n./gen -n 1000 -k 1000 -type max\n./gen -n 1000 -k 1000 -type random\n\n./gen -n 10000 -k 5000 -type min\n./gen -n 10000 -k 5000 -type max\n./gen -n 10000 -k 5000 -type random\n\n./gen -n 100000 -k 100000 -type min\n./gen -n 100000 -k 100000 -type max\n./gen -n 100000 -k 100000 -type random\n\n./gen -n 100000 -k 99999 -type edge0\n./gen -n 100000 -k 2 -type edge1\n./gen -n 100000 -k 99999 -type edgek1\n\n./gen -n 50000 -k 25000 -type negative\n./gen -n 50000 -k 100000 -type negative\n\n./gen -n 100000 -k 1 -type min\n./gen -n 100000 -k 2 -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:54.462665",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "289/B",
      "title": "B. Пингвин Поло и матрица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы три целых числа n, m и d (1 ≤ n, m ≤ 100, 1 ≤ d ≤ 104) — размеры матрицы и параметр d. В следующих n строках записана матрица: j-тое целое число в i-той строке — элемент матрицы aij (1 ≤ aij ≤ 104).",
      "output_spec": "Выходные данныеВ единственной строке выведите целое число — минимальное количество шагов, которое требуется для того, чтобы все элементы матрицы были равны между собой. Если описанное невозможно, выведите «-1» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 22 46 8Выходные данныеСкопировать4Входные данныеСкопировать1 2 76 7Выходные данныеСкопировать-1",
      "description": "B. Пингвин Поло и матрица\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы три целых числа n, m и d (1 ≤ n, m ≤ 100, 1 ≤ d ≤ 104) — размеры матрицы и параметр d. В следующих n строках записана матрица: j-тое целое число в i-той строке — элемент матрицы aij (1 ≤ aij ≤ 104).\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите целое число — минимальное количество шагов, которое требуется для того, чтобы все элементы матрицы были равны между собой. Если описанное невозможно, выведите «-1» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать2 2 22 46 8Выходные данныеСкопировать4Входные данныеСкопировать1 2 76 7Выходные данныеСкопировать-1\n\nВходные данныеСкопировать2 2 22 46 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2 76 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Перенос Codeforces Round #177 - Codeforces",
          "content": "В связи с тем, что у TopCoder сорвалось проведение TCO 2013 Round 2A, а перенесли они его со снайперской точностью на запланированный нами ранее Codeforces Round #177, мы решили подвинуть наше мероприятие. Признаюсь, моим первым побуждением было оставить всё как есть — TopCoder прекрасно знал о Codeforces Round 177, и я не могу одобрить такой подход к решению своих технических сложностей. С другой стороны, сообщество, а особенно автор предстоящего раунда, уважаемый witua, не виноваты — вам хочется участвовать, а автору интереснее, когда раунд собирает аншлаг. К тому же, координатору задач Gerald-у пришлось бы несладко, разрываясь между работой и TCO. Поэтому Codeforces Round #177 сдвинут на время запланированное для раунда #178, а тот будет перенесен чуток вперед.Мы приносим извинения за изменения в расписании. Надеемся, увидеть вас среди участников Codeforces Round #177. Будет весело!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Привет!Завтра, в 19:30 по Москве состоится Codeforces Round #177. Надеюсь, что, несмотря на то что раунд был перенесен, вы все примете участие в нем и будете счастливы.Помогает готовить раунд, как всегда, Gerald, условия переводит Delinur. Спасибо им.Удачи!Сегодня все стандартно:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Сегодняшние победители:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 472
        },
        {
          "title": "Codeforces Round #177, разбор задач - Codeforces",
          "content": "Здравствуйте!289A - Пингвин Поло и отрезкиКраткое описание. Есть 105 числовых отрезков, которые не пересекаются. За один шаг можно увеличить любой отрезок на 1 влево или вправо. Нужно найти минимальное количество шагов, после которых число целых чисел, принадлежащих отрезкам, будем делится на k.Решение. Для начала нужно посчитать, сколько чисел изначально принадлежат заданным отрезкам. Поскольку они не пересекаются и даже не касаются (это следует из неравенства min(ri, rj) < max(li, lj) для всех i, j), никакая точка не может принадлежать двум отрезкам одновременно. Поэтому изначально величиной множества есть число . Если p делится на k, то ответом будет число 0 — не надо делать никаких шагов, все уже готово. Но если это не так, нужно подумать, за какое минимальное количество шагов из p можно сделать число, которое делится k. Можно увидеть, что за один шаг величину множества можно увеличить ровно на 1 (просто либо увеличив влево самый левый отрезок либо увеличив вправо самый правый), но на число больше 1 мы никогда его не увеличим. Тогда минимальное количество шагов будет равно минимальному числу t такому, что . Несложно убедится, что . Примечание. Обратите внимание, что просто вывести недостаточно: нужно отдельно рассмотреть случай когда , или просто вывести .289B - Пингвин Поло и матрицаКраткое описание. Есть матрица n × m из целых чисел, а также число d. За один шаг можно увеличить или уменьшить любое из чисел матрицы (но только одно) ровно на d. Нужно найти минимальное количество шагов, после которых все элементы матрицы будут одинаковыми, или сообщить, что этого сделать невозможно.Решение. Для начала нужно выяснить, когда не существует ответа. Для этого нужно заметить, что после выполнения операции над числом z величина не изменится. Действительно . Поэтому необходимым условием существования ответа есть условие, что все равны между собой. Несложно убедится, что это будет и достаточное условие (это также видно по алгоритму описанному ниже).Теперь можно свести задачу к несколько другому виду. Переведем все n × m чисел матрицы в одномерный массив b, по сортируем по не убыванию и пронумеруем элементы от 1 до k (тут k это тоже самое что n × m). Цель задачи и шаги, естественно, остаются такими же. Несложно заметить в хотя бы в одному оптимальном ответе, все числа сведены к одному из чисел данного массива. Но, кроме этого, одним из оптимальных ответов будет свести все числа к числу , то есть к медиане массива. Почему именно к медиане? Предположим, что свели не к медианному элементу с номером x. Тогда |x - (k - x)| > 1, то есть с одной стороны хотя бы на 2 элемента больше, чем с другой. Поэтому, передвинув число в сторону уменьшение абсолютной разницы, можно улучшить (или хотя-бы точно не уменьшить) результат.После того как известно, к какому число нужно свести, несложно понять что результатом будет сумма , разделенная на d.Сложность такого решения: .Примечание. Полным решением также является решение со сложностью O(n2m2). 288A - Пингвин Поло и строкиКраткое описание. Нужно построить лексикографически минимальную строку длины n, состоящую из ровно k различных маленький латинских символов такую, что-бы никакие два соседних числа не совпадали.Решение. Решением этой задачи есть конструктивное построение нужной строки. Но для начала найдем такие параметры n и k, для которых не существует ответа. Естественно, что если k > n, то ответа не существует, так как не может быть k различных символов в строке длиной меньше k. Еще одним случаем есть случай когда k = 1, тогда если n > 1 ответа также не существует. Во всех остальных случаях ответ существует.Теперь, когда мы знаем что ответ существует, нужно построить лексикографически минимальный. Предположим, что k = 2. Несложно понять, что оптимальным ответом здесь будет строка вида abababab.... Логично, что для k > 2 ответ будет точно лексикографически больше за ответ при k = 2, поэтому стоит как-то как можно правее что-то дописать к ответу для k = 2 так, что-бы он был ответом для k > 2. Минимальное что мы можем (и должны) сделать это переписать последние k - 2 символа строки на первые k - 2 символа алфавита, начиная с символа «c». Например, для n = 7, k = 4 у нас получается строка abababa, а после замены — ababacd.Примечание. Не достаточно двух проверок k > n или k = 1, потому что для n = k = 1 есть ответ.288B - Пингвин Поло и домаКраткое описание. Нужно найти количество таких таких массивов p длины n из целых чисел от 1 до n, что-бы из первых k элементов можно дойти переходами вида x → px до 1, из последних n - k не можно было дойти до 1 и что-бы 1 был в цикле (т. е. можно дойти из 1 в 1 за положительное количество переходов).Решение. Поскольку k ≤ 8, задачу можно решить перебором. То есть, нужно рекурсивно найти всевозможные варианты первых k чисел на табличках (очевидно, что все они будут в диапазоне 1..k). Всего таких вариантов будет kk (при k = 8 это число равно 16 777 216). Также, для каждого варианта нужно убедится, что он правильный, то есть удовлетворяет все три условия. Это несложно сделать циклом: просто пройтись по всем переходам пока не зашли в цикл и убедится что дом номер 1 был посещен через ненулевое количество переходов.Когда количество вариантов записи первых k найдены (пусть оно равно f(k)), осталось только найти количество вариантов табличек для остальных n - k домов. Поскольку не должно существовать пути из них в 1, то не должно и существовать пути из них в любую из вершин с номером не больше k (иначе за первым условием будет путь в 1). Из этого следует, что на табличках домов с номерами от k + 1 до n можно ставить только номера от k + 1 до n. Так как нас не интересует как именно они расставлены, всего таких вариантов будет (n - k)n - k. Поэтому ответом будет f(k)(n - k)n - k.Примечание. Существует также решение с использованием динамического программирование, а также более аналитическое — формула для f(k). Более подробно об этом обсуждалось здесь, здесь и здесь.288C - Пингвин Поло и операция XORКраткое описание. Нужно найти такую перестановку p чисел от 0 до n, для которой величина максимально возможная.Решение. Так как нужно максимизировать ответ, нужно найти такую перестановку, при которой минимальное количество битов пропадут при операции xor, то есть что-бы было как можно меньше таких битов, что они одновременно равны 1 и в i и в pi (потому что тогда ои ничего не прибавят к ответу). Оказывается, для любого n можно найти такую перестановку, при которой ни один бит не пропадет. Как именно строить такую перестановку? Будем решать задачу итерациями пока n > 0. На каждой итерации, найдем самый старший бит, который не равен 0 в двоичной записи n и обозначим его номер (при нумерации с права налево от 0) через b. Также нужно найти число m — минимальное число от 0 до n (включительно), в котором бит с номером b равен 1. После этого можно увидеть (смотри рисунок ниже), что при не пропадет ни один бит, при не пропадет ни один бит, ..., при не пропадет ни один бит. Поэтому, нам стоит именное такие числа присвоить перестановке (то есть pm = m - 1 и pm - 1 = m, pm + 1 = m - 2 и pm - 2 = m + 1 и так далее). После этого присвоим n значение m - (n - m + 1) - 1 и перейдем к следующей итерации.Теперь, когда известно как можно построить перестановку так, что-бы ни один бит не пропадал, ответом будет .Примечание. В этой задачи было полезно написать генератор для небольших n. После этого несложно увидеть закономерность ответа, после чего намного проще дойти до его конструкции.288D - Пингвин Поло и деревоКраткое описание. Нужно найти количество пар путей в дереве, которые не пересекаются по вершинам (то есть не имеют общих вершин).Решение. Как всегда в подобных задачах, подвесим дерево за какую-то вершину, например за вершину с номером 1. Нужно выяснить, что будет, если есть какой-то фиксированный путь и надо найти количество способов выбрать другой. Очевидно, что после удаления всех вершин этого пути и инцидентных к ним ребер, дерево распадется на лес (тоесть на множество отдельных деревьев). Пусть их размеры (количество вершин) это числа c1, c2, ..., ck, где k — их количество. Тогда нам с каждой из таких групп нужно выбрать пару чисел, то есть суммарное количество способов будет . То есть, если перебирать такие пути, достаточно воспользоватся этой формулой что-бы найти ответ. Но такой алгоритм — O(n2), поскольку нужно перебирать все пути. Нужно избавится от этого. Для этого dfs-ом обойдем граф и будем фиксировать одну из вершин пути (последнюю). Теперь нужно найти для всех других вершин сумму таких формул как описано выше. Можно здесь отдельно искать такое количество для вершин поддерева и остальных вершин (тех что первое ребро ведет вверх). Для вершин поддерева нужно делать следующим образом. Пусть у нас есть посчитаны ответы для всех вершин, в которые ведут ребра из текущей. Рассмотрим одну из этих вершин и прибавим к нашему ответу ответ из этой вершины. Но это еще не все — нужно добавить еще сумму всех по всем другим вершинам что выходят из текущей (но кроме той которой мы рассматриваем), умноженное на количество вершин поддерева (не всего текущего, а только того что выходит из ребра что перебираем). Это удобно реализуется, используя частичные суммы для оптимизации (что-бы все время не пересчитывать сумму). Для остальных вершин (тех что не в поддереве) все аналогично, но немножко сложнее. Тут можно, например, в dfs-е поддерживать параметр, который равен ответу для текущей вершины. Потом, когда по ребру спускаемся вниз по дереву, нужно обновить результат как это было и в первом случае, но уже с количество вершин равным n минус размер поддерева (тоесть те вершины что не в поддереве).Примечание. Как вариант, можно искать количество плохих путей и выводить количество всех минус это количество. Еще возможным решением есть принцип разделяй и властвуй.288E - Пингвин Поло и счастливые числаКраткое описание. Есть два больших счастливых числа одинаковой длины. Нужно найти сумму произведений соседних счастливых чисел, которые лежат между двумя заданными.Решение. В данной задаче необходимо вывести довольно много формул, большинство из которых необходимы для оптимизации решение (например различные частичные суммы). В разборе приведена только общая идея авторского решение. Детали можно узнать посмотрев решения участников либо задав вопрос в комментариях ниже.Обозначим через a1, a2, ..., an все счастливые числа промежутка. Сначала нужно сделать следующее сведение задачи. Пусть в нас есть зафиксированная цифра (pos, d), то есть позиция (разряд) pos (начиная с 0 с права налево) и значение d (4 или 7). Тогда, для всех чисел ai (1 ≤ i < n) таких что pos-я цифра равна d к ответу нужно добавить ai + 1 × d × 10pos. Теперь видно, что задача можно свести к следующей. Для каждой фиксированной цифры (pos, d) нужно найти сумму все ai таких, что ai - 1 на pos-й позиции имеет цифру d. Естественно, задачу можно решить отдельно для промежутка 1..l и 1..r, а потом отнять первое от второго — это и будет ответ.Как искать такую сумму среди всех счастливых чисел такой-же длины как входное, но меньших за какое-то x? Опишем общую идею. Любое счастливое число (да и вообще любое) число, меньше за x будет сначала совпадать с ним, то есть иметь некоторый общий префикс, потом одна цифра станет меньше чем в x (то есть там где в x стоит 7 в новом числе стоит 4), а далее цифры будут располагаться произвольным образом. Таким образом, перебрав эту цифру, мы, учитывая произвольность остальных, можем, используя частичные суммы искать ответ для всех позиций и цифр.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 289\\s*B"
          },
          "content_length": 11475
        }
      ],
      "code_examples": [
        {
          "title": "Перенос Codeforces Round #177 - Codeforces - Code 1",
          "code": "for any reason",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7205",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int a = inf.readInt(1, 10000, \"a_ij\");\n            if (j + 1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int a = inf.readInt(1, 10000, \"a_ij\");\n            if (j + 1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int a = inf.readInt(1, 10000, \"a_ij\");\n            if (j + 1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate the matrix a[n][m]\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"equal\") {\n        // All elements are equal\n        int val = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = val;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random elements, ensuring differences are divisible by d\n        int base = rnd.next(1, 10000);\n        int remainder = base % d;\n        vector<int> possible_k;\n        for (int k = -1000; k <= 1000; ++k) {\n            int val = base + k * d;\n            if (val >= 1 && val <= 10000)\n                possible_k.push_back(k);\n        }\n        int sz = possible_k.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int k = possible_k[rnd.next(0, sz - 1)];\n                a[i][j] = base + k * d;\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Elements such that differences are not divisible by d\n        int base = rnd.next(1, 10000);\n        int rem1 = base % d;\n        int rem2 = (rem1 + 1) % d;\n\n        for (int i = 0; i < n*m - 1; ++i) {\n            int val = base + d * rnd.next(-1000, 1000);\n            val = max(1, min(10000, val));\n            a[i / m][i % m] = val;\n        }\n        // Set one element with different remainder mod d\n        int val = base + d * rnd.next(-1000, 1000) + (rem2 - rem1);\n        if (val < 1) val += d;\n        else if (val > 10000) val -= d;\n        val = max(1, min(10000, val));\n        a[(n*m - 1)/ m][(n*m - 1) % m] = val;\n    } else if (type == \"max\") {\n        // Elements are maximum value\n        int base = 10000 - (10000 % d);\n        if (base == 0) base = d; // Ensure base >= 1\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = base;\n            }\n        }\n    } else if (type == \"min\") {\n        // Elements are minimum value\n        int base = 1 + ((d - 1) % d);\n        a.assign(n, vector<int>(m, base));\n    } else if (type == \"max_moves\") {\n        // Generate matrix such that the number of moves is large\n        // For maximum moves, we can set elements spread apart.\n\n        // Find valid values\n        vector<int> possible_values;\n        for (int val = 1; val <= 10000; ++val) {\n            if ((val - 1) % d == 0)\n                possible_values.push_back(val);\n        }\n\n        int min_val = possible_values.front();\n        int max_val = possible_values.back();\n\n        for (int i = 0; i < n*m; ++i) {\n            if (i % 2 == 0) {\n                a[i / m][i % m] = min_val;\n            } else {\n                a[i / m][i % m] = max_val;\n            }\n        }\n    }\n\n    // Output n m d\n    printf(\"%d %d %d\\n\", n, m, d);\n    // Output matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", a[i][j], (j == m - 1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate the matrix a[n][m]\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"equal\") {\n        // All elements are equal\n        int val = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = val;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random elements, ensuring differences are divisible by d\n        int base = rnd.next(1, 10000);\n        int remainder = base % d;\n        vector<int> possible_k;\n        for (int k = -1000; k <= 1000; ++k) {\n            int val = base + k * d;\n            if (val >= 1 && val <= 10000)\n                possible_k.push_back(k);\n        }\n        int sz = possible_k.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int k = possible_k[rnd.next(0, sz - 1)];\n                a[i][j] = base + k * d;\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Elements such that differences are not divisible by d\n        int base = rnd.next(1, 10000);\n        int rem1 = base % d;\n        int rem2 = (rem1 + 1) % d;\n\n        for (int i = 0; i < n*m - 1; ++i) {\n            int val = base + d * rnd.next(-1000, 1000);\n            val = max(1, min(10000, val));\n            a[i / m][i % m] = val;\n        }\n        // Set one element with different remainder mod d\n        int val = base + d * rnd.next(-1000, 1000) + (rem2 - rem1);\n        if (val < 1) val += d;\n        else if (val > 10000) val -= d;\n        val = max(1, min(10000, val));\n        a[(n*m - 1)/ m][(n*m - 1) % m] = val;\n    } else if (type == \"max\") {\n        // Elements are maximum value\n        int base = 10000 - (10000 % d);\n        if (base == 0) base = d; // Ensure base >= 1\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = base;\n            }\n        }\n    } else if (type == \"min\") {\n        // Elements are minimum value\n        int base = 1 + ((d - 1) % d);\n        a.assign(n, vector<int>(m, base));\n    } else if (type == \"max_moves\") {\n        // Generate matrix such that the number of moves is large\n        // For maximum moves, we can set elements spread apart.\n\n        // Find valid values\n        vector<int> possible_values;\n        for (int val = 1; val <= 10000; ++val) {\n            if ((val - 1) % d == 0)\n                possible_values.push_back(val);\n        }\n\n        int min_val = possible_values.front();\n        int max_val = possible_values.back();\n\n        for (int i = 0; i < n*m; ++i) {\n            if (i % 2 == 0) {\n                a[i / m][i % m] = min_val;\n            } else {\n                a[i / m][i % m] = max_val;\n            }\n        }\n    }\n\n    // Output n m d\n    printf(\"%d %d %d\\n\", n, m, d);\n    // Output matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", a[i][j], (j == m - 1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -d 2 -type equal\n./gen -n 2 -m 2 -d 3 -type random\n./gen -n 2 -m 2 -d 3 -type impossible\n./gen -n 1 -m 1 -d 1 -type random\n\n./gen -n 100 -m 100 -d 1 -type equal\n./gen -n 100 -m 100 -d 1 -type max\n./gen -n 100 -m 100 -d 1 -type min\n./gen -n 100 -m 100 -d 1 -type random\n./gen -n 100 -m 100 -d 10000 -type random\n./gen -n 100 -m 100 -d 10000 -type impossible\n\n./gen -n 100 -m 100 -d 1 -type max_moves\n\n./gen -n 50 -m 50 -d 5000 -type random\n./gen -n 50 -m 50 -d 5000 -type impossible\n./gen -n 50 -m 50 -d 10000 -type equal\n./gen -n 50 -m 50 -d 10000 -type min\n\n./gen -n 1 -m 100 -d 1 -type random\n./gen -n 100 -m 1 -d 1 -type random\n\n./gen -n 1 -m 1 -d 10000 -type random\n\n./gen -n 10 -m 10 -d 2 -type random\n./gen -n 10 -m 10 -d 2 -type impossible\n./gen -n 10 -m 10 -d 3 -type random\n./gen -n 10 -m 10 -d 3 -type impossible\n\n./gen -n 5 -m 5 -d 7 -type equal\n./gen -n 5 -m 5 -d 7 -type random\n\n./gen -n 99 -m 100 -d 500 -type max_moves\n./gen -n 100 -m 99 -d 500 -type random\n./gen -n 100 -m 100 -d 10000 -type max\n./gen -n 1 -m 1 -d 1 -type max_moves\n./gen -n 100 -m 100 -d 1 -type impossible\n\n./gen -n 100 -m 100 -d 1234 -type random\n./gen -n 100 -m 100 -d 1234 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:56.577340",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "289/C",
      "title": "C. Polo the Penguin and Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains two positive integers n and k (1 ≤ n ≤ 106, 1 ≤ k ≤ 26) — the string's length and the number of distinct letters.",
      "output_spec": "OutputIn a single line print the required string. If there isn't such string, print \"-1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy7 4OutputCopyababacdInputCopy4 7OutputCopy-1",
      "description": "C. Polo the Penguin and Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains two positive integers n and k (1 ≤ n ≤ 106, 1 ≤ k ≤ 26) — the string's length and the number of distinct letters.\n\nOutputIn a single line print the required string. If there isn't such string, print \"-1\" (without the quotes).\n\nInputCopy7 4OutputCopyababacdInputCopy4 7OutputCopy-1\n\nInputCopy7 4\n\nOutputCopyababacd\n\nInputCopy4 7\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #177 has been moved forward - Codeforces",
          "content": "As the TopCoder TCO 2013 Round 2A did not take place as planned but was moved (with sniper precision) right on the place of the Codeforces Round #177, we decided to reschedule the contest. I have to admit that my first urge was to leave everything as it is — TopCoder knew of Codeforces Round 177 and I cannot approve of such an approach to solving their technical issues. On the other hand, no fault lies on the community, and especially on dear witua, the writer of the forthcoming round. You’d like to participate and the writer is keen on making a round as popular as it gets. Besides, the problem coordinator Gerald would have fallen under much pressure, juggling work and TCO. That’s why the Codeforces Round #177 moves to the time that was initially planned for Round 178, and Round 178 moves a little ahead.We apologize for the schedule inconveniences and hope to see you among the Codeforces Round #177 participants. It will be fun!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 941
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Greetings!Codeforces Round #177 takes place tomorrow at 19:30 by Moscow. I hope you all will take part and enjoy the problems.Gerald, as usually, helps in preparings, Delinur translates all the problems for you. Thanks to them.Good Luck!Points distribution is standard:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Here are today's winners:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 463
        },
        {
          "title": "Codeforces Round #177, editorial - Codeforces",
          "content": "Hi!289A - Polo the Penguin and Segments Solution. First of all, we need to count, how many integers are inside given segments at the beginning. Since they don't intersect and even touch, no integer point can belong to more than one segment at the same time. This mans that starting value of segments is .If k divides p, then answer is 0 — we don't need to do anything, it's already done. But if it's not true, we need to know the minimal number of turns to make k divisor of p. Since we can in single turn increase p by 1 (by decreasing the left point of the leftmost segment), this number is equal to .Note. Note that just output is not enough: you need to pay attention for case when , or just output .289B - Polo the Penguin and MatrixSolution. First of all, we need to know when the answer is -1. For that you should notice that after any operation on number z, value doesn't change. Indeed, . This means that there is not answer if there are two different points for which is diffrent.Now we can transform our problem a bit. We can just write down all integers from matrix n × m to one array b of size k = n × m and sort them all in non-decreasing order. It is not hard to notice that in some of the optimal solutions, all number are at the end equal to one of the number for starting array. But also, it is optimal to make all number equal to (median element). Why to median? Suppose that we make all numbers equal to non-median element with index x. Then if |x - (k - x)| > 1 (i. e. from one side there are more elements than from another + 1). So, by moving out element more to median, we can make result better.After we know, to which number we should bring all, the answer is just , divided by d.Note. There is also full solution with complexity O(n2m2). 288A - Polo the Penguin and StringsSolution. To solve this problem we need to find out some contruction of resulting string. But first of all, we need find out when there is no result. Obviously, if k > n, there is not result — you cannot build string of length n with more than n characters. Another one case is when k = 1 and n > 1 — there is no answer in that case also.Consider that k = 2. It's really easy to see that answer for such case is a string of form abababab.... To construct string for k > 2 you need to add some extra characters — c, d, e.... To make string lexicographically smallest, you need to add that characters as close to the end as we can. And the best bet here is abbabab...abacdefgh.... So, we need just to add characters c, d, e, f... (i. e. k - 2 characters from c) to the end of the string.288B - Polo the Penguin and Houses Solution. Since k ≤ 8 you can solve this problem using brute force. This means that you can recursively construct all possible kk possibilities of first k assignments. (For k = 8 this is equal to 16 777 216.) For each of that assignments you need to check whether it is correct or not (by problem statement). Ths can be simply done using loops.When you know the number of assignment for the first k tables (let it be f(k)), all you need to do is to count the number of assignment for the rest n - k plaques. Since there should bo no path to 1, there should be no path to any of first k houses, so at each plaque for houses from k + 1 to n there can be any number from k + 1 to n, inclusive. There are (n - k)n - k such possibilities. And hence the total answer is f(k)(n - k)n - k.Note. There also exists solution with dynamic programming, and also there exists formula for f(x). You can read about it more here, here и here.288C - Polo the Penguin and XOR operationSolution. Since we need to maximize the result, we need to find such permutation, for which the least number of bit disappear. (We consider bit disappeared if it was 1 both in i and pi, so in it is 0). It turns out that for each n there is such permutation that no bit disappear. How to build it? We will be solving problem by iterations while n > 0. On each iteration, we need to find the biggest (the leftmost in binary representation) bit which is not 0 in binary representation of n and denote it position (bits are numbered from 0) by b. Now we need to find integer m — minimal integer from 0 to n, inclusive, such that b-th bit is also 1 in it. After that you can see (look image below), that at no bit disappear, at no bit disappear, ..., at no bit disappear. So, it is good to assign exactly that integers to our permutation, i. e. pm = m - 1 and pm - 1 = m, pm + 1 = m - 2 and pm - 2 = m + 1 and so on. After that assign value m - (n - m + 1) - 1 to n and go to next iteration.Now when we know how to build permutation and that no bit disappear, the value of the answer is equal to .288D - Polo the Penguin and Trees Solution. As always in such problems, root our tree at some vertex, for example vertex with number 1. We need to find out, what will happen when we have already chosen one path. Obviously, after deleting all vertices and their edges from that path, tree will disintegrate in some set of trees. Denote their sizes by c1, c2, ..., ck, where k is the number of trees. Then the number of ways to choose the second path is equal to . This gives us O(n2) solution — just to brute force all pathes and count the number of second paths by this formula. We need to do it in O(n). To do so, dfs our graph and fix some vertex during dfs, we will consider this vertex as the last vertex in the first path. Now we need to find the sum of above formula for the rest of the vertex. Here you can separately solve this problem for all vertex inside subtree of current vertex and for the rest of the vertices. For subtree vertices, you can, after finding the answers for all vertices of subtree, find the answer for root of subtree. To do so, you need to iterate all edges from current vertex and sum up results for that vetices. Also you need to add the sum of values multiplied by the number of vertices in subtree, where di are all sizes of subtrees of vertices from current vertex, not including from current edge). You can use some partial sums of something like that to make it linear. For the rest of the vertices (not in subtree) it is actually similar, but a bit harder. Here you need to keep current result as a parameter of dfs and when you entering some vertex you should add some additional counts to the current sum (similarly as in first case).Note. Also, you can find the number of bad pairs of pathes and subtract it from the total number. Also some divide and coquer solution exists, you can think about it.288E - Polo the Penguin and Lucky NumbersSolution. In this problem there are a lot of different formulas, most of them are for optimizing solution and making it lenear. Editorial shows just a general idea because it's pretty hard to explain all of them and good for you to derive it by yourself. If you have any questions — write them all in comments.Denote by a1, a2, ..., an all lucky number from segment. First of all, we need to do reduce the problem a bit. Let we have some fixed digit (pos, d), i. e. position of this digit is pos (from 0 from right to left) and value is d (4 or 7). Then, for all ai (1 ≤ i < n) such that pos-th digit of ai is equal to d, we need to add ai + 1 × d × 10pos to the answer. Now we can see that problem can be reduced to the following. For each fixed digit (pos, d) find the sum of all ai such that ai + 1 on the pos-th position has digit d. Obviously, we can solve the problem for 1..l and 1..r separately and then subtract the first from the second — that will be the answer.How to find such sum among all lucky numbers of some length but less than some lucky number x? We will describe the general idea. Any lucky number, less than x has some common prefix with x, then one digit is less than the corresponing in x (i. e. it is 7 in x and 4 in another integer) and the rest of the digits are arbitrary. So, by iterating all such positions where is the first digit less than in x, we can, using the fact that the rest of the digits are arbitrary and some formulas and precomputations, compute the results for each position and digit.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 289 和字母"
          },
          "content_length": 8091
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = -1;\n    int k = -1;\n    string type = opt<string>(\"type\", \"random\");\n\n    const int N_MAX = 1000000;\n    const int K_MAX = 26;\n\n    if (type == \"custom\") {\n        n = opt<int>(\"n\");\n        k = opt<int>(\"k\");\n    } else if (type == \"max_n\") {\n        n = N_MAX;\n        k = rnd.next(1, K_MAX);\n    } else if (type == \"min_n\") {\n        n = 1;\n        k = rnd.next(1, K_MAX);\n    } else if (type == \"impossible\") {\n        int option = rnd.next(2);\n        if (option == 0) {\n            // k > n, n ∈ [1,25], k ∈ [n+1,26]\n            n = rnd.next(1, 25);\n            k = rnd.next(n+1, 26);\n        } else {\n            // n ≥ 2 and k ==1\n            n = rnd.next(2, N_MAX);\n            k = 1;\n        }\n    } else if (type == \"max_k\") {\n        k = K_MAX;\n        n = rnd.next(k, N_MAX);\n    } else if (type == \"min_k\") {\n        k = 1;\n        n = rnd.next(1, N_MAX);\n    } else if (type == \"random\") {\n        n = rnd.next(1, N_MAX);\n        k = rnd.next(1, K_MAX);\n    } else if (type == \"max_n_max_k\") {\n        n = N_MAX;\n        k = K_MAX;\n    } else if (type == \"max_n_min_k\") {\n        n = N_MAX;\n        k = 1;\n    } else if (type == \"n_equals_k\") {\n        k = rnd.next(1, K_MAX);\n        n = k;\n    } else if (type == \"n_gt_k\") {\n        k = rnd.next(1, K_MAX - 1);\n        n = rnd.next(k+1, N_MAX);\n    } else if (type == \"n_lt_k\") {\n        // Ensure that k > n, which is invalid but within constraints\n        n = rnd.next(1, 25);\n        k = rnd.next(n+1, 26);\n    } else {\n        // Default to random\n        n = rnd.next(1, N_MAX);\n        k = rnd.next(1, K_MAX);\n    }\n\n    // Ensure that n and k are within constraints\n    if (n < 1) n = 1;\n    if (n > N_MAX) n = N_MAX;\n    if (k < 1) k = 1;\n    if (k > K_MAX) k = K_MAX;\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = -1;\n    int k = -1;\n    string type = opt<string>(\"type\", \"random\");\n\n    const int N_MAX = 1000000;\n    const int K_MAX = 26;\n\n    if (type == \"custom\") {\n        n = opt<int>(\"n\");\n        k = opt<int>(\"k\");\n    } else if (type == \"max_n\") {\n        n = N_MAX;\n        k = rnd.next(1, K_MAX);\n    } else if (type == \"min_n\") {\n        n = 1;\n        k = rnd.next(1, K_MAX);\n    } else if (type == \"impossible\") {\n        int option = rnd.next(2);\n        if (option == 0) {\n            // k > n, n ∈ [1,25], k ∈ [n+1,26]\n            n = rnd.next(1, 25);\n            k = rnd.next(n+1, 26);\n        } else {\n            // n ≥ 2 and k ==1\n            n = rnd.next(2, N_MAX);\n            k = 1;\n        }\n    } else if (type == \"max_k\") {\n        k = K_MAX;\n        n = rnd.next(k, N_MAX);\n    } else if (type == \"min_k\") {\n        k = 1;\n        n = rnd.next(1, N_MAX);\n    } else if (type == \"random\") {\n        n = rnd.next(1, N_MAX);\n        k = rnd.next(1, K_MAX);\n    } else if (type == \"max_n_max_k\") {\n        n = N_MAX;\n        k = K_MAX;\n    } else if (type == \"max_n_min_k\") {\n        n = N_MAX;\n        k = 1;\n    } else if (type == \"n_equals_k\") {\n        k = rnd.next(1, K_MAX);\n        n = k;\n    } else if (type == \"n_gt_k\") {\n        k = rnd.next(1, K_MAX - 1);\n        n = rnd.next(k+1, N_MAX);\n    } else if (type == \"n_lt_k\") {\n        // Ensure that k > n, which is invalid but within constraints\n        n = rnd.next(1, 25);\n        k = rnd.next(n+1, 26);\n    } else {\n        // Default to random\n        n = rnd.next(1, N_MAX);\n        k = rnd.next(1, K_MAX);\n    }\n\n    // Ensure that n and k are within constraints\n    if (n < 1) n = 1;\n    if (n > N_MAX) n = N_MAX;\n    if (k < 1) k = 1;\n    if (k > K_MAX) k = K_MAX;\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type custom -n 1 -k 1\n./gen -type custom -n 2 -k 2\n./gen -type custom -n 2 -k 1       # Impossible case: n >= 2 and k = 1\n./gen -type custom -n 5 -k 5\n./gen -type custom -n 5 -k 6       # Impossible case: k > n\n./gen -type custom -n 1 -k 2       # Impossible case: k > n\n./gen -type custom -n 25 -k 26     # Impossible case: k > n\n./gen -type custom -n 26 -k 26\n./gen -type custom -n 26 -k 1\n./gen -type custom -n 1000000 -k 1 # Impossible case: n >= 2 and k = 1\n./gen -type custom -n 1000000 -k 26\n./gen -type max_n                  # Generates n=1e6, random k\n./gen -type min_n                  # Generates n=1, random k\n./gen -type max_k                  # Generates k=26, n >= k\n./gen -type min_k                  # Generates k=1, random n\n./gen -type impossible             # Generates an impossible test case\n./gen -type impossible             # Another impossible test case\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type n_equals_k             # Generates n = k\n./gen -type n_gt_k                 # Generates n > k\n./gen -type n_lt_k                 # Generates k > n (impossible case)\n./gen -type max_n_max_k            # Generates n=1e6, k=26\n./gen -type max_n_min_k            # Generates n=1e6, k=1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:02:58.391020",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "289/D",
      "title": "D. Пингвин Поло и дома",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке через пробел заданы два целых числа n и k (1 ≤ n ≤ 1000, 1 ≤ k ≤ min(8, n)) — количество домов и число k из условия.",
      "output_spec": "Выходные данныеВ единственной строке выведите целое число — ответ на задачу по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 2Выходные данныеСкопировать54Входные данныеСкопировать7 4Выходные данныеСкопировать1728",
      "description": "D. Пингвин Поло и дома\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке через пробел заданы два целых числа n и k (1 ≤ n ≤ 1000, 1 ≤ k ≤ min(8, n)) — количество домов и число k из условия.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите целое число — ответ на задачу по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать5 2Выходные данныеСкопировать54Входные данныеСкопировать7 4Выходные данныеСкопировать1728\n\nВходные данныеСкопировать5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать54\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1728\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Перенос Codeforces Round #177 - Codeforces",
          "content": "В связи с тем, что у TopCoder сорвалось проведение TCO 2013 Round 2A, а перенесли они его со снайперской точностью на запланированный нами ранее Codeforces Round #177, мы решили подвинуть наше мероприятие. Признаюсь, моим первым побуждением было оставить всё как есть — TopCoder прекрасно знал о Codeforces Round 177, и я не могу одобрить такой подход к решению своих технических сложностей. С другой стороны, сообщество, а особенно автор предстоящего раунда, уважаемый witua, не виноваты — вам хочется участвовать, а автору интереснее, когда раунд собирает аншлаг. К тому же, координатору задач Gerald-у пришлось бы несладко, разрываясь между работой и TCO. Поэтому Codeforces Round #177 сдвинут на время запланированное для раунда #178, а тот будет перенесен чуток вперед.Мы приносим извинения за изменения в расписании. Надеемся, увидеть вас среди участников Codeforces Round #177. Будет весело!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Привет!Завтра, в 19:30 по Москве состоится Codeforces Round #177. Надеюсь, что, несмотря на то что раунд был перенесен, вы все примете участие в нем и будете счастливы.Помогает готовить раунд, как всегда, Gerald, условия переводит Delinur. Спасибо им.Удачи!Сегодня все стандартно:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Сегодняшние победители:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 472
        },
        {
          "title": "Codeforces Round #177, разбор задач - Codeforces",
          "content": "Здравствуйте!289A - Пингвин Поло и отрезкиКраткое описание. Есть 105 числовых отрезков, которые не пересекаются. За один шаг можно увеличить любой отрезок на 1 влево или вправо. Нужно найти минимальное количество шагов, после которых число целых чисел, принадлежащих отрезкам, будем делится на k.Решение. Для начала нужно посчитать, сколько чисел изначально принадлежат заданным отрезкам. Поскольку они не пересекаются и даже не касаются (это следует из неравенства min(ri, rj) < max(li, lj) для всех i, j), никакая точка не может принадлежать двум отрезкам одновременно. Поэтому изначально величиной множества есть число . Если p делится на k, то ответом будет число 0 — не надо делать никаких шагов, все уже готово. Но если это не так, нужно подумать, за какое минимальное количество шагов из p можно сделать число, которое делится k. Можно увидеть, что за один шаг величину множества можно увеличить ровно на 1 (просто либо увеличив влево самый левый отрезок либо увеличив вправо самый правый), но на число больше 1 мы никогда его не увеличим. Тогда минимальное количество шагов будет равно минимальному числу t такому, что . Несложно убедится, что . Примечание. Обратите внимание, что просто вывести недостаточно: нужно отдельно рассмотреть случай когда , или просто вывести .289B - Пингвин Поло и матрицаКраткое описание. Есть матрица n × m из целых чисел, а также число d. За один шаг можно увеличить или уменьшить любое из чисел матрицы (но только одно) ровно на d. Нужно найти минимальное количество шагов, после которых все элементы матрицы будут одинаковыми, или сообщить, что этого сделать невозможно.Решение. Для начала нужно выяснить, когда не существует ответа. Для этого нужно заметить, что после выполнения операции над числом z величина не изменится. Действительно . Поэтому необходимым условием существования ответа есть условие, что все равны между собой. Несложно убедится, что это будет и достаточное условие (это также видно по алгоритму описанному ниже).Теперь можно свести задачу к несколько другому виду. Переведем все n × m чисел матрицы в одномерный массив b, по сортируем по не убыванию и пронумеруем элементы от 1 до k (тут k это тоже самое что n × m). Цель задачи и шаги, естественно, остаются такими же. Несложно заметить в хотя бы в одному оптимальном ответе, все числа сведены к одному из чисел данного массива. Но, кроме этого, одним из оптимальных ответов будет свести все числа к числу , то есть к медиане массива. Почему именно к медиане? Предположим, что свели не к медианному элементу с номером x. Тогда |x - (k - x)| > 1, то есть с одной стороны хотя бы на 2 элемента больше, чем с другой. Поэтому, передвинув число в сторону уменьшение абсолютной разницы, можно улучшить (или хотя-бы точно не уменьшить) результат.После того как известно, к какому число нужно свести, несложно понять что результатом будет сумма , разделенная на d.Сложность такого решения: .Примечание. Полным решением также является решение со сложностью O(n2m2). 288A - Пингвин Поло и строкиКраткое описание. Нужно построить лексикографически минимальную строку длины n, состоящую из ровно k различных маленький латинских символов такую, что-бы никакие два соседних числа не совпадали.Решение. Решением этой задачи есть конструктивное построение нужной строки. Но для начала найдем такие параметры n и k, для которых не существует ответа. Естественно, что если k > n, то ответа не существует, так как не может быть k различных символов в строке длиной меньше k. Еще одним случаем есть случай когда k = 1, тогда если n > 1 ответа также не существует. Во всех остальных случаях ответ существует.Теперь, когда мы знаем что ответ существует, нужно построить лексикографически минимальный. Предположим, что k = 2. Несложно понять, что оптимальным ответом здесь будет строка вида abababab.... Логично, что для k > 2 ответ будет точно лексикографически больше за ответ при k = 2, поэтому стоит как-то как можно правее что-то дописать к ответу для k = 2 так, что-бы он был ответом для k > 2. Минимальное что мы можем (и должны) сделать это переписать последние k - 2 символа строки на первые k - 2 символа алфавита, начиная с символа «c». Например, для n = 7, k = 4 у нас получается строка abababa, а после замены — ababacd.Примечание. Не достаточно двух проверок k > n или k = 1, потому что для n = k = 1 есть ответ.288B - Пингвин Поло и домаКраткое описание. Нужно найти количество таких таких массивов p длины n из целых чисел от 1 до n, что-бы из первых k элементов можно дойти переходами вида x → px до 1, из последних n - k не можно было дойти до 1 и что-бы 1 был в цикле (т. е. можно дойти из 1 в 1 за положительное количество переходов).Решение. Поскольку k ≤ 8, задачу можно решить перебором. То есть, нужно рекурсивно найти всевозможные варианты первых k чисел на табличках (очевидно, что все они будут в диапазоне 1..k). Всего таких вариантов будет kk (при k = 8 это число равно 16 777 216). Также, для каждого варианта нужно убедится, что он правильный, то есть удовлетворяет все три условия. Это несложно сделать циклом: просто пройтись по всем переходам пока не зашли в цикл и убедится что дом номер 1 был посещен через ненулевое количество переходов.Когда количество вариантов записи первых k найдены (пусть оно равно f(k)), осталось только найти количество вариантов табличек для остальных n - k домов. Поскольку не должно существовать пути из них в 1, то не должно и существовать пути из них в любую из вершин с номером не больше k (иначе за первым условием будет путь в 1). Из этого следует, что на табличках домов с номерами от k + 1 до n можно ставить только номера от k + 1 до n. Так как нас не интересует как именно они расставлены, всего таких вариантов будет (n - k)n - k. Поэтому ответом будет f(k)(n - k)n - k.Примечание. Существует также решение с использованием динамического программирование, а также более аналитическое — формула для f(k). Более подробно об этом обсуждалось здесь, здесь и здесь.288C - Пингвин Поло и операция XORКраткое описание. Нужно найти такую перестановку p чисел от 0 до n, для которой величина максимально возможная.Решение. Так как нужно максимизировать ответ, нужно найти такую перестановку, при которой минимальное количество битов пропадут при операции xor, то есть что-бы было как можно меньше таких битов, что они одновременно равны 1 и в i и в pi (потому что тогда ои ничего не прибавят к ответу). Оказывается, для любого n можно найти такую перестановку, при которой ни один бит не пропадет. Как именно строить такую перестановку? Будем решать задачу итерациями пока n > 0. На каждой итерации, найдем самый старший бит, который не равен 0 в двоичной записи n и обозначим его номер (при нумерации с права налево от 0) через b. Также нужно найти число m — минимальное число от 0 до n (включительно), в котором бит с номером b равен 1. После этого можно увидеть (смотри рисунок ниже), что при не пропадет ни один бит, при не пропадет ни один бит, ..., при не пропадет ни один бит. Поэтому, нам стоит именное такие числа присвоить перестановке (то есть pm = m - 1 и pm - 1 = m, pm + 1 = m - 2 и pm - 2 = m + 1 и так далее). После этого присвоим n значение m - (n - m + 1) - 1 и перейдем к следующей итерации.Теперь, когда известно как можно построить перестановку так, что-бы ни один бит не пропадал, ответом будет .Примечание. В этой задачи было полезно написать генератор для небольших n. После этого несложно увидеть закономерность ответа, после чего намного проще дойти до его конструкции.288D - Пингвин Поло и деревоКраткое описание. Нужно найти количество пар путей в дереве, которые не пересекаются по вершинам (то есть не имеют общих вершин).Решение. Как всегда в подобных задачах, подвесим дерево за какую-то вершину, например за вершину с номером 1. Нужно выяснить, что будет, если есть какой-то фиксированный путь и надо найти количество способов выбрать другой. Очевидно, что после удаления всех вершин этого пути и инцидентных к ним ребер, дерево распадется на лес (тоесть на множество отдельных деревьев). Пусть их размеры (количество вершин) это числа c1, c2, ..., ck, где k — их количество. Тогда нам с каждой из таких групп нужно выбрать пару чисел, то есть суммарное количество способов будет . То есть, если перебирать такие пути, достаточно воспользоватся этой формулой что-бы найти ответ. Но такой алгоритм — O(n2), поскольку нужно перебирать все пути. Нужно избавится от этого. Для этого dfs-ом обойдем граф и будем фиксировать одну из вершин пути (последнюю). Теперь нужно найти для всех других вершин сумму таких формул как описано выше. Можно здесь отдельно искать такое количество для вершин поддерева и остальных вершин (тех что первое ребро ведет вверх). Для вершин поддерева нужно делать следующим образом. Пусть у нас есть посчитаны ответы для всех вершин, в которые ведут ребра из текущей. Рассмотрим одну из этих вершин и прибавим к нашему ответу ответ из этой вершины. Но это еще не все — нужно добавить еще сумму всех по всем другим вершинам что выходят из текущей (но кроме той которой мы рассматриваем), умноженное на количество вершин поддерева (не всего текущего, а только того что выходит из ребра что перебираем). Это удобно реализуется, используя частичные суммы для оптимизации (что-бы все время не пересчитывать сумму). Для остальных вершин (тех что не в поддереве) все аналогично, но немножко сложнее. Тут можно, например, в dfs-е поддерживать параметр, который равен ответу для текущей вершины. Потом, когда по ребру спускаемся вниз по дереву, нужно обновить результат как это было и в первом случае, но уже с количество вершин равным n минус размер поддерева (тоесть те вершины что не в поддереве).Примечание. Как вариант, можно искать количество плохих путей и выводить количество всех минус это количество. Еще возможным решением есть принцип разделяй и властвуй.288E - Пингвин Поло и счастливые числаКраткое описание. Есть два больших счастливых числа одинаковой длины. Нужно найти сумму произведений соседних счастливых чисел, которые лежат между двумя заданными.Решение. В данной задаче необходимо вывести довольно много формул, большинство из которых необходимы для оптимизации решение (например различные частичные суммы). В разборе приведена только общая идея авторского решение. Детали можно узнать посмотрев решения участников либо задав вопрос в комментариях ниже.Обозначим через a1, a2, ..., an все счастливые числа промежутка. Сначала нужно сделать следующее сведение задачи. Пусть в нас есть зафиксированная цифра (pos, d), то есть позиция (разряд) pos (начиная с 0 с права налево) и значение d (4 или 7). Тогда, для всех чисел ai (1 ≤ i < n) таких что pos-я цифра равна d к ответу нужно добавить ai + 1 × d × 10pos. Теперь видно, что задача можно свести к следующей. Для каждой фиксированной цифры (pos, d) нужно найти сумму все ai таких, что ai - 1 на pos-й позиции имеет цифру d. Естественно, задачу можно решить отдельно для промежутка 1..l и 1..r, а потом отнять первое от второго — это и будет ответ.Как искать такую сумму среди всех счастливых чисел такой-же длины как входное, но меньших за какое-то x? Опишем общую идею. Любое счастливое число (да и вообще любое) число, меньше за x будет сначала совпадать с ним, то есть иметь некоторый общий префикс, потом одна цифра станет меньше чем в x (то есть там где в x стоит 7 в новом числе стоит 4), а далее цифры будут располагаться произвольным образом. Таким образом, перебрав эту цифру, мы, учитывая произвольность остальных, можем, используя частичные суммы искать ответ для всех позиций и цифр.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 289 和字母"
          },
          "content_length": 11475
        }
      ],
      "code_examples": [
        {
          "title": "Перенос Codeforces Round #177 - Codeforces - Code 1",
          "code": "for any reason",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7205",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(8, n), \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(8, n), \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(8, n), \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"min\") {\n        n = 1;\n        k = 1;\n    } else if (type == \"max\") {\n        n = 1000;\n        k = 8;\n    } else if (type == \"kEquals1\") {\n        if (n == -1) n = rnd.next(1, 1000);\n        k = 1;\n    } else if (type == \"kEqualsN\") {\n        n = rnd.next(1, 8);\n        k = n;\n    } else if (type == \"nIsSmall\") {\n        n = rnd.next(1, 5);\n        k = rnd.next(1, min(8, n));\n    } else if (type == \"nIs7\") {\n        n = 7;\n        k = rnd.next(1, min(8, n));\n    } else if (type == \"nIs8\") {\n        n = 8;\n        k = rnd.next(1, 8);\n    } else if (type == \"nIs9\") {\n        n = 9;\n        k = rnd.next(1, 8);\n    } else if (type == \"nIs1000\") {\n        n = 1000;\n        k = rnd.next(1, 8);\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000);\n        k = rnd.next(1, min(8, n));\n    } else {\n        // Default case, use provided n and k\n        if (n == -1) n = rnd.next(1, 1000);\n        if (k == -1 || k > min(8, n) || k < 1) {\n            k = rnd.next(1, min(8, n));\n        }\n    }\n\n    // Ensure k is within [1, min(8, n)]\n    k = min(k, min(8, n));\n    k = max(k, 1);\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"min\") {\n        n = 1;\n        k = 1;\n    } else if (type == \"max\") {\n        n = 1000;\n        k = 8;\n    } else if (type == \"kEquals1\") {\n        if (n == -1) n = rnd.next(1, 1000);\n        k = 1;\n    } else if (type == \"kEqualsN\") {\n        n = rnd.next(1, 8);\n        k = n;\n    } else if (type == \"nIsSmall\") {\n        n = rnd.next(1, 5);\n        k = rnd.next(1, min(8, n));\n    } else if (type == \"nIs7\") {\n        n = 7;\n        k = rnd.next(1, min(8, n));\n    } else if (type == \"nIs8\") {\n        n = 8;\n        k = rnd.next(1, 8);\n    } else if (type == \"nIs9\") {\n        n = 9;\n        k = rnd.next(1, 8);\n    } else if (type == \"nIs1000\") {\n        n = 1000;\n        k = rnd.next(1, 8);\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000);\n        k = rnd.next(1, min(8, n));\n    } else {\n        // Default case, use provided n and k\n        if (n == -1) n = rnd.next(1, 1000);\n        if (k == -1 || k > min(8, n) || k < 1) {\n            k = rnd.next(1, min(8, n));\n        }\n    }\n\n    // Ensure k is within [1, min(8, n)]\n    k = min(k, min(8, n));\n    k = max(k, 1);\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type kEquals1\n./gen -type kEqualsN\n./gen -type nIsSmall\n./gen -type nIs7\n./gen -type nIs8\n./gen -type nIs9\n./gen -type nIs1000\n./gen -type random\n./gen -n 1 -k 1\n./gen -n 2 -k 1\n./gen -n 2 -k 2\n./gen -n 5 -k 3\n./gen -n 7 -k 7\n./gen -n 8 -k 8\n./gen -n 9 -k 8\n./gen -n 10 -k 5\n./gen -n 100 -k 8\n./gen -n 500 -k 1\n./gen -n 500 -k 8\n./gen -n 999 -k 7\n./gen -n 1000 -k 2\n./gen -n 1000 -k 8\n./gen -n 1000 -k 1\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -n 8 -k 1\n./gen -n 8 -k 8\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:00.917658",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "289/E",
      "title": "E. Polo the Penguin and XOR operation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains a positive integer n (1 ≤ n ≤ 106).",
      "output_spec": "OutputIn the first line print integer m the maximum possible beauty. In the second line print any permutation of integers from 0 to n with the beauty equal to m.If there are several suitable permutations, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy4OutputCopy200 2 1 4 3",
      "description": "E. Polo the Penguin and XOR operation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains a positive integer n (1 ≤ n ≤ 106).\n\nOutputIn the first line print integer m the maximum possible beauty. In the second line print any permutation of integers from 0 to n with the beauty equal to m.If there are several suitable permutations, you are allowed to print any of them.\n\nInputCopy4OutputCopy200 2 1 4 3\n\nOutputCopy200 2 1 4 3",
      "solutions": [
        {
          "title": "Codeforces Round #177 has been moved forward - Codeforces",
          "content": "As the TopCoder TCO 2013 Round 2A did not take place as planned but was moved (with sniper precision) right on the place of the Codeforces Round #177, we decided to reschedule the contest. I have to admit that my first urge was to leave everything as it is — TopCoder knew of Codeforces Round 177 and I cannot approve of such an approach to solving their technical issues. On the other hand, no fault lies on the community, and especially on dear witua, the writer of the forthcoming round. You’d like to participate and the writer is keen on making a round as popular as it gets. Besides, the problem coordinator Gerald would have fallen under much pressure, juggling work and TCO. That’s why the Codeforces Round #177 moves to the time that was initially planned for Round 178, and Round 178 moves a little ahead.We apologize for the schedule inconveniences and hope to see you among the Codeforces Round #177 participants. It will be fun!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7205",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 941
        },
        {
          "title": "Codeforces Round #177 - Codeforces",
          "content": "Greetings!Codeforces Round #177 takes place tomorrow at 19:30 by Moscow. I hope you all will take part and enjoy the problems.Gerald, as usually, helps in preparings, Delinur translates all the problems for you. Thanks to them.Good Luck!Points distribution is standard:Div1: 500 1000 1500 2000 2500Div2: 500 1000 1500 2000 2500Here are today's winners:Div1: wjmsbmr peter50216 rng_58 XilinX RAD RomaWhite eduardische Div2: alimiaomiao yutaka1999 Alex.lap zlqiszlq",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7218",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 463
        },
        {
          "title": "Codeforces Round #177, editorial - Codeforces",
          "content": "Hi!289A - Polo the Penguin and Segments Solution. First of all, we need to count, how many integers are inside given segments at the beginning. Since they don't intersect and even touch, no integer point can belong to more than one segment at the same time. This mans that starting value of segments is .If k divides p, then answer is 0 — we don't need to do anything, it's already done. But if it's not true, we need to know the minimal number of turns to make k divisor of p. Since we can in single turn increase p by 1 (by decreasing the left point of the leftmost segment), this number is equal to .Note. Note that just output is not enough: you need to pay attention for case when , or just output .289B - Polo the Penguin and MatrixSolution. First of all, we need to know when the answer is -1. For that you should notice that after any operation on number z, value doesn't change. Indeed, . This means that there is not answer if there are two different points for which is diffrent.Now we can transform our problem a bit. We can just write down all integers from matrix n × m to one array b of size k = n × m and sort them all in non-decreasing order. It is not hard to notice that in some of the optimal solutions, all number are at the end equal to one of the number for starting array. But also, it is optimal to make all number equal to (median element). Why to median? Suppose that we make all numbers equal to non-median element with index x. Then if |x - (k - x)| > 1 (i. e. from one side there are more elements than from another + 1). So, by moving out element more to median, we can make result better.After we know, to which number we should bring all, the answer is just , divided by d.Note. There is also full solution with complexity O(n2m2). 288A - Polo the Penguin and StringsSolution. To solve this problem we need to find out some contruction of resulting string. But first of all, we need find out when there is no result. Obviously, if k > n, there is not result — you cannot build string of length n with more than n characters. Another one case is when k = 1 and n > 1 — there is no answer in that case also.Consider that k = 2. It's really easy to see that answer for such case is a string of form abababab.... To construct string for k > 2 you need to add some extra characters — c, d, e.... To make string lexicographically smallest, you need to add that characters as close to the end as we can. And the best bet here is abbabab...abacdefgh.... So, we need just to add characters c, d, e, f... (i. e. k - 2 characters from c) to the end of the string.288B - Polo the Penguin and Houses Solution. Since k ≤ 8 you can solve this problem using brute force. This means that you can recursively construct all possible kk possibilities of first k assignments. (For k = 8 this is equal to 16 777 216.) For each of that assignments you need to check whether it is correct or not (by problem statement). Ths can be simply done using loops.When you know the number of assignment for the first k tables (let it be f(k)), all you need to do is to count the number of assignment for the rest n - k plaques. Since there should bo no path to 1, there should be no path to any of first k houses, so at each plaque for houses from k + 1 to n there can be any number from k + 1 to n, inclusive. There are (n - k)n - k such possibilities. And hence the total answer is f(k)(n - k)n - k.Note. There also exists solution with dynamic programming, and also there exists formula for f(x). You can read about it more here, here и here.288C - Polo the Penguin and XOR operationSolution. Since we need to maximize the result, we need to find such permutation, for which the least number of bit disappear. (We consider bit disappeared if it was 1 both in i and pi, so in it is 0). It turns out that for each n there is such permutation that no bit disappear. How to build it? We will be solving problem by iterations while n > 0. On each iteration, we need to find the biggest (the leftmost in binary representation) bit which is not 0 in binary representation of n and denote it position (bits are numbered from 0) by b. Now we need to find integer m — minimal integer from 0 to n, inclusive, such that b-th bit is also 1 in it. After that you can see (look image below), that at no bit disappear, at no bit disappear, ..., at no bit disappear. So, it is good to assign exactly that integers to our permutation, i. e. pm = m - 1 and pm - 1 = m, pm + 1 = m - 2 and pm - 2 = m + 1 and so on. After that assign value m - (n - m + 1) - 1 to n and go to next iteration.Now when we know how to build permutation and that no bit disappear, the value of the answer is equal to .288D - Polo the Penguin and Trees Solution. As always in such problems, root our tree at some vertex, for example vertex with number 1. We need to find out, what will happen when we have already chosen one path. Obviously, after deleting all vertices and their edges from that path, tree will disintegrate in some set of trees. Denote their sizes by c1, c2, ..., ck, where k is the number of trees. Then the number of ways to choose the second path is equal to . This gives us O(n2) solution — just to brute force all pathes and count the number of second paths by this formula. We need to do it in O(n). To do so, dfs our graph and fix some vertex during dfs, we will consider this vertex as the last vertex in the first path. Now we need to find the sum of above formula for the rest of the vertex. Here you can separately solve this problem for all vertex inside subtree of current vertex and for the rest of the vertices. For subtree vertices, you can, after finding the answers for all vertices of subtree, find the answer for root of subtree. To do so, you need to iterate all edges from current vertex and sum up results for that vetices. Also you need to add the sum of values multiplied by the number of vertices in subtree, where di are all sizes of subtrees of vertices from current vertex, not including from current edge). You can use some partial sums of something like that to make it linear. For the rest of the vertices (not in subtree) it is actually similar, but a bit harder. Here you need to keep current result as a parameter of dfs and when you entering some vertex you should add some additional counts to the current sum (similarly as in first case).Note. Also, you can find the number of bad pairs of pathes and subtract it from the total number. Also some divide and coquer solution exists, you can think about it.288E - Polo the Penguin and Lucky NumbersSolution. In this problem there are a lot of different formulas, most of them are for optimizing solution and making it lenear. Editorial shows just a general idea because it's pretty hard to explain all of them and good for you to derive it by yourself. If you have any questions — write them all in comments.Denote by a1, a2, ..., an all lucky number from segment. First of all, we need to do reduce the problem a bit. Let we have some fixed digit (pos, d), i. e. position of this digit is pos (from 0 from right to left) and value is d (4 or 7). Then, for all ai (1 ≤ i < n) such that pos-th digit of ai is equal to d, we need to add ai + 1 × d × 10pos to the answer. Now we can see that problem can be reduced to the following. For each fixed digit (pos, d) find the sum of all ai such that ai + 1 on the pos-th position has digit d. Obviously, we can solve the problem for 1..l and 1..r separately and then subtract the first from the second — that will be the answer.How to find such sum among all lucky numbers of some length but less than some lucky number x? We will describe the general idea. Any lucky number, less than x has some common prefix with x, then one digit is less than the corresponing in x (i. e. it is 7 in x and 4 in another integer) and the rest of the digits are arbitrary. So, by iterating all such positions where is the first digit less than in x, we can, using the fact that the rest of the digits are arbitrary and some formulas and precomputations, compute the results for each position and digit.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7241",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 289 和字母"
          },
          "content_length": 8091
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #177 - Codeforces - Code 1",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 2",
          "code": "(initial) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 8)   8 6 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 9)   9 8 5 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 10)  10 8 9 4 3 2 1 0 7 6 5 4 3 2 1 \n(i = 11)  11 10 9 8 3 2 1 0 7 6 5 4 3 2 1 \n(i = 12)  12 10 9 8 11 2 1 0 7 6 5 4 3 2 1 \n(i = 13)  13 12 9 8 11 10 1 0 7 6 5 4 3 2 1 \n(i = 14)  14 12 13 8 11 10 9 0 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 3",
          "code": "When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 4",
          "code": "he can walk to house number 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #177 - Codeforces - Code 5",
          "code": "a + i = ( 2 ^ k )-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7218",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // n: if provided, we print exactly that\n    // type: can be used to generate special or random n\n    // maxn: upper limit when generating a random n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"\");\n    int maxn = opt<int>(\"maxn\", 1000000);\n\n    // If a specific n is provided, just print it\n    if (n != -1) {\n        // Must be in [1..1e6], though user is responsible for passing valid parameters\n        printf(\"%d\\n\", n);\n        return 0;\n    }\n    \n    // Type-based generation\n    if (type == \"max\") {\n        // Strictly the largest allowed n\n        printf(\"1000000\\n\");\n        return 0;\n    }\n\n    if (type == \"small\") {\n        // Generate a small random n in [1 .. 20]\n        int res = rnd.next(1, 20);\n        printf(\"%d\\n\", res);\n        return 0;\n    }\n\n    if (type == \"random\") {\n        // Generate random n in [1 .. maxn]\n        int res = rnd.next(1, maxn);\n        printf(\"%d\\n\", res);\n        return 0;\n    }\n\n    if (type == \"power2\") {\n        // Generate a random power of 2 up to 1e6\n        vector<int> powers;\n        for(int i = 0; i < 20; i++) {\n            int val = 1 << i;\n            if(val > 1000000) break;\n            powers.push_back(val);\n        }\n        int idx = rnd.next((int)powers.size());\n        printf(\"%d\\n\", powers[idx]);\n        return 0;\n    }\n\n    if (type == \"nearPower2\") {\n        // Pick a random power of 2 up to 1e6, then add a small offset\n        vector<int> powers;\n        for(int i = 0; i < 20; i++) {\n            int val = 1 << i;\n            if(val > 1000000) break;\n            powers.push_back(val);\n        }\n        int base = powers[rnd.next((int)powers.size())];\n        // offset from -5 to 5\n        int offset = rnd.next(-5, 5);\n        int res = base + offset;\n        // clamp to [1..1000000]\n        res = max(res, 1);\n        res = min(res, 1000000);\n        printf(\"%d\\n\", res);\n        return 0;\n    }\n\n    // Default fallback: just print 1\n    printf(\"1\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // n: if provided, we print exactly that\n    // type: can be used to generate special or random n\n    // maxn: upper limit when generating a random n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"\");\n    int maxn = opt<int>(\"maxn\", 1000000);\n\n    // If a specific n is provided, just print it\n    if (n != -1) {\n        // Must be in [1..1e6], though user is responsible for passing valid parameters\n        printf(\"%d\\n\", n);\n        return 0;\n    }\n    \n    // Type-based generation\n    if (type == \"max\") {\n        // Strictly the largest allowed n\n        printf(\"1000000\\n\");\n        return 0;\n    }\n\n    if (type == \"small\") {\n        // Generate a small random n in [1 .. 20]\n        int res = rnd.next(1, 20);\n        printf(\"%d\\n\", res);\n        return 0;\n    }\n\n    if (type == \"random\") {\n        // Generate random n in [1 .. maxn]\n        int res = rnd.next(1, maxn);\n        printf(\"%d\\n\", res);\n        return 0;\n    }\n\n    if (type == \"power2\") {\n        // Generate a random power of 2 up to 1e6\n        vector<int> powers;\n        for(int i = 0; i < 20; i++) {\n            int val = 1 << i;\n            if(val > 1000000) break;\n            powers.push_back(val);\n        }\n        int idx = rnd.next((int)powers.size());\n        printf(\"%d\\n\", powers[idx]);\n        return 0;\n    }\n\n    if (type == \"nearPower2\") {\n        // Pick a random power of 2 up to 1e6, then add a small offset\n        vector<int> powers;\n        for(int i = 0; i < 20; i++) {\n            int val = 1 << i;\n            if(val > 1000000) break;\n            powers.push_back(val);\n        }\n        int base = powers[rnd.next((int)powers.size())];\n        // offset from -5 to 5\n        int offset = rnd.next(-5, 5);\n        int res = base + offset;\n        // clamp to [1..1000000]\n        res = max(res, 1);\n        res = min(res, 1000000);\n        printf(\"%d\\n\", res);\n        return 0;\n    }\n\n    // Default fallback: just print 1\n    printf(\"1\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -type small\n./gen -type small\n./gen -type random -maxn 10\n./gen -type random -maxn 100\n./gen -type random -maxn 999\n./gen -type random -maxn 1000000\n./gen -type power2\n./gen -type nearPower2\n./gen -type max\n./gen -n 99999\n./gen -n 100000\n./gen -n 131071\n./gen -n 131072\n./gen -n 524287\n./gen -n 524288\n./gen -n 999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:02.875240",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "29/A",
      "title": "A. Плевая задача",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 100) — число верблюдов в зоопарке. Далее следует n строк по два целых числа xi и di ( - 104 ≤ xi ≤ 104, 1 ≤ |di| ≤ 2·104) — записи в блокноте Васи. xi — координата точки, в которой стоит i-ый верблюд, в метрах. di — на сколько метров плюнул i-ый верблюд. Положительные значения di означают, что i-ый верблюд плевал вправо, отрицательные — что i-ый верблюд плевал влево. В одной точке не может стоять больше одного верблюда.",
      "output_spec": "Выходные данныеЕсли в зоопарке есть два верблюда, которые плюнули друг в друга, выведите YES. Иначе выведите NO.",
      "sample_tests": "ПримерыВходные данныеСкопировать20 11 -1Выходные данныеСкопироватьYESВходные данныеСкопировать30 11 12 -2Выходные данныеСкопироватьNOВходные данныеСкопировать52 -103 100 55 -510 1Выходные данныеСкопироватьYES",
      "description": "A. Плевая задача\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 100) — число верблюдов в зоопарке. Далее следует n строк по два целых числа xi и di ( - 104 ≤ xi ≤ 104, 1 ≤ |di| ≤ 2·104) — записи в блокноте Васи. xi — координата точки, в которой стоит i-ый верблюд, в метрах. di — на сколько метров плюнул i-ый верблюд. Положительные значения di означают, что i-ый верблюд плевал вправо, отрицательные — что i-ый верблюд плевал влево. В одной точке не может стоять больше одного верблюда.\n\nВходные данные\n\nВыходные данныеЕсли в зоопарке есть два верблюда, которые плюнули друг в друга, выведите YES. Иначе выведите NO.\n\nВыходные данные\n\nВходные данныеСкопировать20 11 -1Выходные данныеСкопироватьYESВходные данныеСкопировать30 11 12 -2Выходные данныеСкопироватьNOВходные данныеСкопировать52 -103 100 55 -510 1Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать20 11 -1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать30 11 12 -2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать52 -103 100 55 -510 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces",
          "content": "В России сегодня не просто 20-е сентября, а День Рекрутера. В Азербайджане – нефтяника, а в Беларуси – таможенника. Для нас же это плюс ко всему еще один хороший день, чтобы провести раунд. Добро пожаловать на Codeforces Beta Round #29 (Див. 2, Codeforces format)!Готовить раунд помогали: Михаил Мирзаянов, Дмитрий Матов, Геральд Агапов и Николай Кузнецов, за что им спасибо.Счастливого Дня рекрутера,Артем РаховUPD:ЗадачиРезультатыПобедитель: espr1t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/684",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 29"
          },
          "content_length": 450
        },
        {
          "title": "My solution @ Round #29, [without Problem E] - Codeforces",
          "content": "Problem A:Check whether exist a pair i and j,they satisfy xi+di = xj && xj+dj = xi;Problem B:Pay attention to Just Right or Red. use Div and Mod can solve it easily;Problem C:As we know, there are only two path -- forward and reverse, so we can do DFS from the one-degree nodes (only two nodes).As their index may be very larger, so I used map<int,int> to do hash.void dfs(int i){     int sz = mat[i].size()-1, j;     UF(j,0,sz)     if (!vis[mat[i][j]])     {        vis[mat[i][j]] = 1;        printf(\" %d\",val[mat[i][j]]);        dfs(mat[i][j]);     }}Problem D: Floyd.First, Floyd pretreat the path from I to J, and save the path. Then get the answer.The order is a1,a2...ak, K is the number of the leaves, we can assume a0 = ak+1 = 1, the root.then, answer push_back the path[ai][ai+1].if the ans.size() > 2*N-1 , cout -1;else cout the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 1",
          "code": "8\n4 3\n1 4\n8 5\n7 6\n3 5\n7 3\n4 2\n2 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 2",
          "code": "3\n458744979 589655889\n248228386 824699605\n458744979 824699605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 3",
          "code": "4\n90104473 221011623\n18773664 221011623\n90104473 74427905\n74427905 186329050",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 4",
          "code": "5\n695442143 421284135\n641835294 542627184\n852367357 120042890\n641835294 852367357\n542627184 421284135",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 5",
          "code": "Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 6",
          "code": "1000 999 1 1 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 7",
          "code": "772 467 142 356 889",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 8",
          "code": "264896923 2497658\n57071588 447086061\n2497658 483723090\n57071588 264896923\n158310110 483723090\n158310110 72866107",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 9",
          "code": "In this case 5 4 3 1 1. Why the answer is 2.33333333I think it should be 2.66666667.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> positions;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\"); // xi\n        inf.readSpace();\n        int di = inf.readInt(-20000, 20000, \"di\"); // di\n        ensuref(abs(di) >= 1, \"|di| >=1, but di=%d\", di);\n        inf.readEoln();\n\n        ensuref(positions.insert(xi).second, \"xi must be unique, but xi=%d appears more than once\", xi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> positions;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\"); // xi\n        inf.readSpace();\n        int di = inf.readInt(-20000, 20000, \"di\"); // di\n        ensuref(abs(di) >= 1, \"|di| >=1, but di=%d\", di);\n        inf.readEoln();\n\n        ensuref(positions.insert(xi).second, \"xi must be unique, but xi=%d appears more than once\", xi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> positions;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\"); // xi\n        inf.readSpace();\n        int di = inf.readInt(-20000, 20000, \"di\"); // di\n        ensuref(abs(di) >= 1, \"|di| >=1, but di=%d\", di);\n        inf.readEoln();\n\n        ensuref(positions.insert(xi).second, \"xi must be unique, but xi=%d appears more than once\", xi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n    vector<int> di(n);\n\n    const int minx = -10000;\n    const int maxx = 10000;\n    const int mind = 1;\n    const int maxd = 20000;\n\n    if (type == \"random\") {\n        // Generate random positions\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(minx, maxx);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n\n        // Generate random distances\n        for (int i = 0; i < n; i++) {\n            // Randomly choose positive or negative distance\n            int sign = rnd.next(0,1) ? 1 : -1;\n            int d = rnd.next(mind, maxd) * sign;\n            di[i] = d;\n        }\n    } else if (type == \"collision\") {\n        // Create a pair of camels that spit at each other\n        assert(n >= 2);\n        set<int> positions;\n        // Generate position for camel A\n        int xa;\n        while (true) {\n            xa = rnd.next(minx, maxx);\n            if (positions.find(xa) == positions.end()) {\n                positions.insert(xa);\n                break;\n            }\n        }\n        // Generate position for camel B\n        int xb;\n        while (true) {\n            int delta = rnd.next(mind, maxd);\n            int sign = rnd.next(0,1) ? 1 : -1;\n            xb = xa + delta * sign;\n            if (xb < minx || xb > maxx) continue;\n            if (positions.find(xb) == positions.end()) {\n                positions.insert(xb);\n                break;\n            }\n        }\n        xi[0] = xa;\n        xi[1] = xb;\n        // Now, set di[0] so that camel A spits at camel B\n        di[0] = xb - xa;\n        if (di[0] > 0 && di[0] < mind) di[0] = mind;\n        if (di[0] < 0 && -di[0] < mind) di[0] = -mind;\n\n        // Set di[1] so that camel B spits at camel A\n        di[1] = xa - xb;\n        if (di[1] > 0 && di[1] < mind) di[1] = mind;\n        if (di[1] < 0 && -di[1] < mind) di[1] = -mind;\n\n        // Now fill the rest camels\n        while ((int)positions.size() < n) {\n            int x = rnd.next(minx, maxx);\n            if (positions.find(x) == positions.end()) {\n                positions.insert(x);\n            }\n        }\n        vector<int> pos(positions.begin(), positions.end());\n        int idx = 2;\n        for (int i = 0; i < (int)pos.size(); i++) {\n            if (pos[i] != xa && pos[i] != xb) {\n                xi[idx] = pos[i];\n                // Random di\n                int sign = rnd.next(0,1) ? 1 : -1;\n                int d = rnd.next(mind, maxd) * sign;\n                di[idx] = d;\n                idx++;\n            }\n        }\n\n    } else if (type == \"no_collision\") {\n        // Generate positions\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(minx, maxx);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n\n        // For each camel, set di so that they don't spit at each other\n        for (int i = 0; i < n; i++) {\n            int sign = rnd.next(0,1) ? 1 : -1;\n            int d = rnd.next(mind, maxd) * sign;\n\n            // Make sure xi[i] + di[i] is not equal to any xj\n            bool collision;\n            int attempts = 0;\n            do {\n                attempts++;\n                if (attempts > 1000) break; // To prevent infinite loops\n                collision = false;\n                d = rnd.next(mind, maxd) * sign;\n                int target = xi[i] + d;\n\n                if (target < minx || target > maxx) {\n                    collision = true;\n                    continue;\n                }\n                if (positions.find(target) != positions.end()) {\n                    // There is a collision\n                    collision = true;\n                } else {\n                    collision = false;\n                }\n            } while (collision);\n            di[i] = d;\n        }\n    } else if (type == \"multiple_collisions\") {\n        // Generate multiple pairs of camels that spit at each other\n        assert(n % 2 == 0); // Ensure n is even\n        set<int> positions;\n        vector<pair<int,int>> pairs;\n        // Generate pairs\n        for (int i = 0; i < n/2; i++) {\n            int xa, xb;\n            while (true) {\n                xa = rnd.next(minx, maxx);\n                if (positions.find(xa) == positions.end()) {\n                    positions.insert(xa);\n                    break;\n                }\n            }\n            while (true) {\n                int delta = rnd.next(mind, maxd);\n                int sign = rnd.next(0,1) ? 1 : -1;\n                xb = xa + delta * sign;\n                if (xb < minx || xb > maxx) continue;\n                if (positions.find(xb) == positions.end()) {\n                    positions.insert(xb);\n                    break;\n                }\n            }\n            pairs.push_back({xa, xb});\n        }\n        xi.resize(n);\n        di.resize(n);\n        int idx = 0;\n        for (auto p : pairs) {\n            xi[idx] = p.first;\n            di[idx] = p.second - p.first;\n            if (di[idx] > 0 && di[idx] < mind) di[idx] = mind;\n            if (di[idx] < 0 && -di[idx] < mind) di[idx] = -mind;\n            idx++;\n\n            xi[idx] = p.second;\n            di[idx] = p.first - p.second;\n            if (di[idx] > 0 && di[idx] < mind) di[idx] = mind;\n            if (di[idx] < 0 && -di[idx] < mind) di[idx] = -mind;\n            idx++;\n        }\n    } else if (type == \"max_positions\") {\n        // Positions at maximum and minimum possible values\n        xi[0] = minx;\n        di[0] = rnd.next(mind, maxd);\n        if (n > 1) {\n            xi[1] = maxx;\n            di[1] = -rnd.next(mind, maxd);\n        }\n        // Fill rest\n        set<int> positions = {xi[0]};\n        if (n > 1) positions.insert(xi[1]);\n        while ((int)positions.size() < n) {\n            int x = rnd.next(minx, maxx);\n            if (positions.find(x) == positions.end()) {\n                positions.insert(x);\n            }\n        }\n        xi.assign(positions.begin(), positions.end());\n        for (int i = 2; i < n; i++) {\n            int sign = rnd.next(0,1) ? 1 : -1;\n            di[i] = rnd.next(mind, maxd) * sign;\n        }\n    } else {\n        // Error: unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Shuffle the camels\n    vector<int> order(n);\n    for (int i = 0; i < n; i++) order[i] = i;\n    shuffle(order.begin(), order.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int idx = 0; idx < n; idx++) {\n        int i = order[idx];\n        printf(\"%d %d\\n\", xi[i], di[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n    vector<int> di(n);\n\n    const int minx = -10000;\n    const int maxx = 10000;\n    const int mind = 1;\n    const int maxd = 20000;\n\n    if (type == \"random\") {\n        // Generate random positions\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(minx, maxx);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n\n        // Generate random distances\n        for (int i = 0; i < n; i++) {\n            // Randomly choose positive or negative distance\n            int sign = rnd.next(0,1) ? 1 : -1;\n            int d = rnd.next(mind, maxd) * sign;\n            di[i] = d;\n        }\n    } else if (type == \"collision\") {\n        // Create a pair of camels that spit at each other\n        assert(n >= 2);\n        set<int> positions;\n        // Generate position for camel A\n        int xa;\n        while (true) {\n            xa = rnd.next(minx, maxx);\n            if (positions.find(xa) == positions.end()) {\n                positions.insert(xa);\n                break;\n            }\n        }\n        // Generate position for camel B\n        int xb;\n        while (true) {\n            int delta = rnd.next(mind, maxd);\n            int sign = rnd.next(0,1) ? 1 : -1;\n            xb = xa + delta * sign;\n            if (xb < minx || xb > maxx) continue;\n            if (positions.find(xb) == positions.end()) {\n                positions.insert(xb);\n                break;\n            }\n        }\n        xi[0] = xa;\n        xi[1] = xb;\n        // Now, set di[0] so that camel A spits at camel B\n        di[0] = xb - xa;\n        if (di[0] > 0 && di[0] < mind) di[0] = mind;\n        if (di[0] < 0 && -di[0] < mind) di[0] = -mind;\n\n        // Set di[1] so that camel B spits at camel A\n        di[1] = xa - xb;\n        if (di[1] > 0 && di[1] < mind) di[1] = mind;\n        if (di[1] < 0 && -di[1] < mind) di[1] = -mind;\n\n        // Now fill the rest camels\n        while ((int)positions.size() < n) {\n            int x = rnd.next(minx, maxx);\n            if (positions.find(x) == positions.end()) {\n                positions.insert(x);\n            }\n        }\n        vector<int> pos(positions.begin(), positions.end());\n        int idx = 2;\n        for (int i = 0; i < (int)pos.size(); i++) {\n            if (pos[i] != xa && pos[i] != xb) {\n                xi[idx] = pos[i];\n                // Random di\n                int sign = rnd.next(0,1) ? 1 : -1;\n                int d = rnd.next(mind, maxd) * sign;\n                di[idx] = d;\n                idx++;\n            }\n        }\n\n    } else if (type == \"no_collision\") {\n        // Generate positions\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(minx, maxx);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n\n        // For each camel, set di so that they don't spit at each other\n        for (int i = 0; i < n; i++) {\n            int sign = rnd.next(0,1) ? 1 : -1;\n            int d = rnd.next(mind, maxd) * sign;\n\n            // Make sure xi[i] + di[i] is not equal to any xj\n            bool collision;\n            int attempts = 0;\n            do {\n                attempts++;\n                if (attempts > 1000) break; // To prevent infinite loops\n                collision = false;\n                d = rnd.next(mind, maxd) * sign;\n                int target = xi[i] + d;\n\n                if (target < minx || target > maxx) {\n                    collision = true;\n                    continue;\n                }\n                if (positions.find(target) != positions.end()) {\n                    // There is a collision\n                    collision = true;\n                } else {\n                    collision = false;\n                }\n            } while (collision);\n            di[i] = d;\n        }\n    } else if (type == \"multiple_collisions\") {\n        // Generate multiple pairs of camels that spit at each other\n        assert(n % 2 == 0); // Ensure n is even\n        set<int> positions;\n        vector<pair<int,int>> pairs;\n        // Generate pairs\n        for (int i = 0; i < n/2; i++) {\n            int xa, xb;\n            while (true) {\n                xa = rnd.next(minx, maxx);\n                if (positions.find(xa) == positions.end()) {\n                    positions.insert(xa);\n                    break;\n                }\n            }\n            while (true) {\n                int delta = rnd.next(mind, maxd);\n                int sign = rnd.next(0,1) ? 1 : -1;\n                xb = xa + delta * sign;\n                if (xb < minx || xb > maxx) continue;\n                if (positions.find(xb) == positions.end()) {\n                    positions.insert(xb);\n                    break;\n                }\n            }\n            pairs.push_back({xa, xb});\n        }\n        xi.resize(n);\n        di.resize(n);\n        int idx = 0;\n        for (auto p : pairs) {\n            xi[idx] = p.first;\n            di[idx] = p.second - p.first;\n            if (di[idx] > 0 && di[idx] < mind) di[idx] = mind;\n            if (di[idx] < 0 && -di[idx] < mind) di[idx] = -mind;\n            idx++;\n\n            xi[idx] = p.second;\n            di[idx] = p.first - p.second;\n            if (di[idx] > 0 && di[idx] < mind) di[idx] = mind;\n            if (di[idx] < 0 && -di[idx] < mind) di[idx] = -mind;\n            idx++;\n        }\n    } else if (type == \"max_positions\") {\n        // Positions at maximum and minimum possible values\n        xi[0] = minx;\n        di[0] = rnd.next(mind, maxd);\n        if (n > 1) {\n            xi[1] = maxx;\n            di[1] = -rnd.next(mind, maxd);\n        }\n        // Fill rest\n        set<int> positions = {xi[0]};\n        if (n > 1) positions.insert(xi[1]);\n        while ((int)positions.size() < n) {\n            int x = rnd.next(minx, maxx);\n            if (positions.find(x) == positions.end()) {\n                positions.insert(x);\n            }\n        }\n        xi.assign(positions.begin(), positions.end());\n        for (int i = 2; i < n; i++) {\n            int sign = rnd.next(0,1) ? 1 : -1;\n            di[i] = rnd.next(mind, maxd) * sign;\n        }\n    } else {\n        // Error: unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Shuffle the camels\n    vector<int> order(n);\n    for (int i = 0; i < n; i++) order[i] = i;\n    shuffle(order.begin(), order.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int idx = 0; idx < n; idx++) {\n        int i = order[idx];\n        printf(\"%d %d\\n\", xi[i], di[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type collision\n./gen -n 2 -type no_collision\n./gen -n 2 -type random\n\n./gen -n 5 -type random\n./gen -n 5 -type collision\n./gen -n 5 -type no_collision\n\n./gen -n 10 -type random\n./gen -n 10 -type collision\n./gen -n 10 -type no_collision\n./gen -n 10 -type multiple_collisions\n\n./gen -n 20 -type random\n./gen -n 20 -type collision\n./gen -n 20 -type no_collision\n./gen -n 20 -type multiple_collisions\n\n./gen -n 50 -type random\n./gen -n 50 -type collision\n./gen -n 50 -type no_collision\n./gen -n 50 -type multiple_collisions\n\n./gen -n 100 -type random\n./gen -n 100 -type collision\n./gen -n 100 -type no_collision\n./gen -n 100 -type multiple_collisions\n\n./gen -n 100 -type max_positions\n./gen -n 100 -type random\n\n./gen -n 4 -type multiple_collisions\n./gen -n 6 -type multiple_collisions\n./gen -n 8 -type multiple_collisions\n\n./gen -n 2 -type collision\n./gen -n 3 -type collision\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:04.788716",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "29/B",
      "title": "B. Traffic Lights",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers l, d, v, g, r (1 ≤ l, d, v, g, r ≤ 1000, d < l) — the distance between A and B (in meters), the distance from A to the traffic lights, car's speed, the duration of green light and the duration of red light.",
      "output_spec": "OutputOutput a single number — the minimum time that the car needs to get from point A to point B. Your output must have relative or absolute error less than 10 - 6.",
      "sample_tests": "ExamplesInputCopy2 1 3 4 5OutputCopy0.66666667InputCopy5 4 3 1 1OutputCopy2.33333333",
      "description": "B. Traffic Lights\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers l, d, v, g, r (1 ≤ l, d, v, g, r ≤ 1000, d < l) — the distance between A and B (in meters), the distance from A to the traffic lights, car's speed, the duration of green light and the duration of red light.\n\nOutputOutput a single number — the minimum time that the car needs to get from point A to point B. Your output must have relative or absolute error less than 10 - 6.\n\nInputCopy2 1 3 4 5OutputCopy0.66666667InputCopy5 4 3 1 1OutputCopy2.33333333\n\nInputCopy2 1 3 4 5\n\nOutputCopy0.66666667\n\nInputCopy5 4 3 1 1\n\nOutputCopy2.33333333",
      "solutions": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces",
          "content": "Today in Russia it's not just the 20th of september, it's Recruiter's Day. In Azerbaijan – Oil Industry Worker's Day, and in Belarus – Customs Officer's Day. But for us it's another good day to arrange the round. Welcome to Codeforces Beta Round #29 (Div. 2, Codeforces format)!Helped with preparation of the round: Mike Mirzayanov, Dmitry Matov, Gerald Agapov and Nickolay Kuznetsov, thank them for that.Happy Recruiter's Day,Artem RakhovUPD:ProblemsStandingsWinner: espr1t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/684",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 29"
          },
          "content_length": 474
        },
        {
          "title": "My solution @ Round #29, [without Problem E] - Codeforces",
          "content": "Problem A:Check whether exist a pair i and j,they satisfy xi+di = xj && xj+dj = xi;Problem B:Pay attention to Just Right or Red. use Div and Mod can solve it easily;Problem C:As we know, there are only two path -- forward and reverse, so we can do DFS from the one-degree nodes (only two nodes).As their index may be very larger, so I used map<int,int> to do hash.void dfs(int i){     int sz = mat[i].size()-1, j;     UF(j,0,sz)     if (!vis[mat[i][j]])     {        vis[mat[i][j]] = 1;        printf(\" %d\",val[mat[i][j]]);        dfs(mat[i][j]);     }}Problem D: Floyd.First, Floyd pretreat the path from I to J, and save the path. Then get the answer.The order is a1,a2...ak, K is the number of the leaves, we can assume a0 = ak+1 = 1, the root.then, answer push_back the path[ai][ai+1].if the ans.size() > 2*N-1 , cout -1;else cout the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 1",
          "code": "8\n4 3\n1 4\n8 5\n7 6\n3 5\n7 3\n4 2\n2 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 2",
          "code": "3\n458744979 589655889\n248228386 824699605\n458744979 824699605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 3",
          "code": "4\n90104473 221011623\n18773664 221011623\n90104473 74427905\n74427905 186329050",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 4",
          "code": "1000 999 1 1 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 5",
          "code": "772 467 142 356 889",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 6",
          "code": "264896923 2497658\n57071588 447086061\n2497658 483723090\n57071588 264896923\n158310110 483723090\n158310110 72866107",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 7",
          "code": "In this case 5 4 3 1 1. Why the answer is 2.33333333I think it should be 2.66666667.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000, \"d\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int g = inf.readInt(1, 1000, \"g\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readEoln();\n\n    ensuref(d < l, \"Constraint violated: d (%d) must be less than l (%d)\", d, l);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000, \"d\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int g = inf.readInt(1, 1000, \"g\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readEoln();\n\n    ensuref(d < l, \"Constraint violated: d (%d) must be less than l (%d)\", d, l);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000, \"d\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int g = inf.readInt(1, 1000, \"g\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readEoln();\n\n    ensuref(d < l, \"Constraint violated: d (%d) must be less than l (%d)\", d, l);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\", \"random\");\n\n    int l = opt<int>(\"l\", -1);\n    int d = opt<int>(\"d\", -1);\n    int v = opt<int>(\"v\", -1);\n    int g = opt<int>(\"g\", -1);\n    int r = opt<int>(\"r\", -1);\n\n    // Initialize variables\n    if (l == -1) {\n        if (type == \"edge-max\")\n            l = 1000;\n        else if (type == \"edge-min\")\n            l = 2; // Minimum value for l given d < l\n        else\n            l = rnd.next(2, 1000);\n    }\n    if (d == -1) {\n        if (type == \"edge-max\")\n            d = l - 1;\n        else if (type == \"edge-min\")\n            d = 1;\n        else\n            d = rnd.next(1, l - 1);\n    }\n    if (v == -1) {\n        if (type == \"edge-max\")\n            v = 1000;\n        else if (type == \"edge-min\")\n            v = 1;\n        else\n            v = rnd.next(1, 1000);\n    }\n    if (g == -1) {\n        if (type == \"edge-max\")\n            g = 1000;\n        else if (type == \"edge-min\")\n            g = 1;\n        else\n            g = rnd.next(1, 1000);\n    }\n    if (r == -1) {\n        if (type == \"edge-max\")\n            r = 1000;\n        else if (type == \"edge-min\")\n            r = 1;\n        else\n            r = rnd.next(1, 1000);\n    }\n\n    // Generate special test cases based on type\n    if (type == \"just-in-time-green\") {\n        // Car arrives just as red turns to green\n        v = v == -1 ? rnd.next(1, 1000) : v;\n        g = g == -1 ? rnd.next(1, 1000) : g;\n        r = r == -1 ? rnd.next(1, 1000) : r;\n        int cycle = g + r;\n        int k = rnd.next(1, 10); // k >= 1 to avoid zero time\n        double t = k * cycle + r;\n        d = (int)(v * t);\n        l = max(l, d + rnd.next(1, 100));\n    } else if (type == \"just-missed-green\") {\n        // Car arrives just as green turns to red\n        v = v == -1 ? rnd.next(1, 1000) : v;\n        g = g == -1 ? rnd.next(1, 1000) : g;\n        r = r == -1 ? rnd.next(1, 1000) : r;\n        int cycle = g + r;\n        int k = rnd.next(0, 10);\n        double t = k * cycle + g;\n        d = (int)(v * t);\n        l = max(l, d + rnd.next(1, 100));\n    } else if (type == \"wait-long\") {\n        // Car has to wait a long time at the traffic light\n        g = g == -1 ? rnd.next(1, 10) : g;\n        r = r == -1 ? 1000 - g : r;\n        v = v == -1 ? rnd.next(1, 1000) : v;\n        int cycle = g + r;\n        int k = rnd.next(0, 10);\n        double t = k * cycle + g + rnd.next(1, r - 1);\n        d = (int)(v * t);\n        l = max(l, d + rnd.next(1, 100));\n    }\n\n    // Ensure variables are within constraints\n    l = max(2, min(l, 1000));\n    d = max(1, min(d, l - 1));\n    v = max(1, min(v, 1000));\n    g = max(1, min(g, 1000));\n    r = max(1, min(r, 1000));\n\n    // Output test case\n    printf(\"%d %d %d %d %d\\n\", l, d, v, g, r);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\", \"random\");\n\n    int l = opt<int>(\"l\", -1);\n    int d = opt<int>(\"d\", -1);\n    int v = opt<int>(\"v\", -1);\n    int g = opt<int>(\"g\", -1);\n    int r = opt<int>(\"r\", -1);\n\n    // Initialize variables\n    if (l == -1) {\n        if (type == \"edge-max\")\n            l = 1000;\n        else if (type == \"edge-min\")\n            l = 2; // Minimum value for l given d < l\n        else\n            l = rnd.next(2, 1000);\n    }\n    if (d == -1) {\n        if (type == \"edge-max\")\n            d = l - 1;\n        else if (type == \"edge-min\")\n            d = 1;\n        else\n            d = rnd.next(1, l - 1);\n    }\n    if (v == -1) {\n        if (type == \"edge-max\")\n            v = 1000;\n        else if (type == \"edge-min\")\n            v = 1;\n        else\n            v = rnd.next(1, 1000);\n    }\n    if (g == -1) {\n        if (type == \"edge-max\")\n            g = 1000;\n        else if (type == \"edge-min\")\n            g = 1;\n        else\n            g = rnd.next(1, 1000);\n    }\n    if (r == -1) {\n        if (type == \"edge-max\")\n            r = 1000;\n        else if (type == \"edge-min\")\n            r = 1;\n        else\n            r = rnd.next(1, 1000);\n    }\n\n    // Generate special test cases based on type\n    if (type == \"just-in-time-green\") {\n        // Car arrives just as red turns to green\n        v = v == -1 ? rnd.next(1, 1000) : v;\n        g = g == -1 ? rnd.next(1, 1000) : g;\n        r = r == -1 ? rnd.next(1, 1000) : r;\n        int cycle = g + r;\n        int k = rnd.next(1, 10); // k >= 1 to avoid zero time\n        double t = k * cycle + r;\n        d = (int)(v * t);\n        l = max(l, d + rnd.next(1, 100));\n    } else if (type == \"just-missed-green\") {\n        // Car arrives just as green turns to red\n        v = v == -1 ? rnd.next(1, 1000) : v;\n        g = g == -1 ? rnd.next(1, 1000) : g;\n        r = r == -1 ? rnd.next(1, 1000) : r;\n        int cycle = g + r;\n        int k = rnd.next(0, 10);\n        double t = k * cycle + g;\n        d = (int)(v * t);\n        l = max(l, d + rnd.next(1, 100));\n    } else if (type == \"wait-long\") {\n        // Car has to wait a long time at the traffic light\n        g = g == -1 ? rnd.next(1, 10) : g;\n        r = r == -1 ? 1000 - g : r;\n        v = v == -1 ? rnd.next(1, 1000) : v;\n        int cycle = g + r;\n        int k = rnd.next(0, 10);\n        double t = k * cycle + g + rnd.next(1, r - 1);\n        d = (int)(v * t);\n        l = max(l, d + rnd.next(1, 100));\n    }\n\n    // Ensure variables are within constraints\n    l = max(2, min(l, 1000));\n    d = max(1, min(d, l - 1));\n    v = max(1, min(v, 1000));\n    g = max(1, min(g, 1000));\n    r = max(1, min(r, 1000));\n\n    // Output test case\n    printf(\"%d %d %d %d %d\\n\", l, d, v, g, r);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type edge-min\n./gen -type edge-max\n\n./gen -type just-in-time-green\n./gen -type just-missed-green\n./gen -type wait-long\n\n# Random cases with specified parameters\n./gen -type random -l 1000\n./gen -type random -d 1\n./gen -type random -v 1000\n./gen -type random -g 1\n./gen -type random -r 1\n\n# Edge cases with specific combinations\n./gen -type random -l 2 -d 1 -v 1 -g 1 -r 1\n./gen -type random -l 1000 -d 999 -v 1000 -g 1000 -r 1000\n\n# Cases to test specific timings\n./gen -type random -g 1000 -r 1\n./gen -type random -g 1 -r 1000\n./gen -type random -v 1\n\n# Additional random cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:06.786014",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "29/C",
      "title": "C. Mail Stamps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — amount of mail stamps on the envelope. Then there follow n lines with two integers each — description of the stamps. Each stamp is described with indexes of the cities between which a letter is sent. The indexes of cities are integers from 1 to 109. Indexes of all the cities are different. Every time the letter is sent from one city to another, exactly one stamp is put on the envelope. It is guaranteed that the given stamps correspond to some valid route from some city to some other city.",
      "output_spec": "OutputOutput n + 1 numbers — indexes of cities in one of the two possible routes of the letter.",
      "sample_tests": "ExamplesInputCopy21 100100 2OutputCopy2 100 1 InputCopy33 1100 23 2OutputCopy100 2 3 1",
      "description": "C. Mail Stamps\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — amount of mail stamps on the envelope. Then there follow n lines with two integers each — description of the stamps. Each stamp is described with indexes of the cities between which a letter is sent. The indexes of cities are integers from 1 to 109. Indexes of all the cities are different. Every time the letter is sent from one city to another, exactly one stamp is put on the envelope. It is guaranteed that the given stamps correspond to some valid route from some city to some other city.\n\nOutputOutput n + 1 numbers — indexes of cities in one of the two possible routes of the letter.\n\nInputCopy21 100100 2OutputCopy2 100 1 InputCopy33 1100 23 2OutputCopy100 2 3 1\n\nInputCopy21 100100 2\n\nOutputCopy2 100 1\n\nInputCopy33 1100 23 2\n\nOutputCopy100 2 3 1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces",
          "content": "Today in Russia it's not just the 20th of september, it's Recruiter's Day. In Azerbaijan – Oil Industry Worker's Day, and in Belarus – Customs Officer's Day. But for us it's another good day to arrange the round. Welcome to Codeforces Beta Round #29 (Div. 2, Codeforces format)!Helped with preparation of the round: Mike Mirzayanov, Dmitry Matov, Gerald Agapov and Nickolay Kuznetsov, thank them for that.Happy Recruiter's Day,Artem RakhovUPD:ProblemsStandingsWinner: espr1t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/684",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 29"
          },
          "content_length": 474
        },
        {
          "title": "My solution @ Round #29, [without Problem E] - Codeforces",
          "content": "Problem A:Check whether exist a pair i and j,they satisfy xi+di = xj && xj+dj = xi;Problem B:Pay attention to Just Right or Red. use Div and Mod can solve it easily;Problem C:As we know, there are only two path -- forward and reverse, so we can do DFS from the one-degree nodes (only two nodes).As their index may be very larger, so I used map<int,int> to do hash.void dfs(int i){     int sz = mat[i].size()-1, j;     UF(j,0,sz)     if (!vis[mat[i][j]])     {        vis[mat[i][j]] = 1;        printf(\" %d\",val[mat[i][j]]);        dfs(mat[i][j]);     }}Problem D: Floyd.First, Floyd pretreat the path from I to J, and save the path. Then get the answer.The order is a1,a2...ak, K is the number of the leaves, we can assume a0 = ak+1 = 1, the root.then, answer push_back the path[ai][ai+1].if the ans.size() > 2*N-1 , cout -1;else cout the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 1",
          "code": "8\n4 3\n1 4\n8 5\n7 6\n3 5\n7 3\n4 2\n2 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 2",
          "code": "3\n458744979 589655889\n248228386 824699605\n458744979 824699605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 3",
          "code": "4\n90104473 221011623\n18773664 221011623\n90104473 74427905\n74427905 186329050",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 4",
          "code": "1000 999 1 1 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 5",
          "code": "772 467 142 356 889",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 6",
          "code": "264896923 2497658\n57071588 447086061\n2497658 483723090\n57071588 264896923\n158310110 483723090\n158310110 72866107",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 7",
          "code": "In this case 5 4 3 1 1. Why the answer is 2.33333333I think it should be 2.66666667.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int a_i = inf.readInt(1, 1000000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, 1000000000, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int a_i = inf.readInt(1, 1000000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, 1000000000, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int a_i = inf.readInt(1, 1000000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, 1000000000, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nset<pair<long long, long long>> edges;\nset<long long> cities;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    for (int i = 0; i < n; i++) {\n        long long a = inf.readLong();\n        long long b = inf.readLong();\n        edges.insert(make_pair(a, b));\n        edges.insert(make_pair(b, a)); // Since edges are undirected\n        cities.insert(a);\n        cities.insert(b);\n    }\n\n    int path_len = n + 1;\n    vector<long long> path;\n    for (int i = 0; i < path_len; i++) {\n        long long v = ouf.readLong();\n        if (cities.find(v) == cities.end()) {\n            quitf(_wa, \"City %lld in output is not among the cities in the input\", v);\n        }\n        path.push_back(v);\n    }\n\n    // Check for duplicate cities in the path\n    set<long long> used;\n    for (long long v : path) {\n        if (used.find(v) != used.end()) {\n            quitf(_wa, \"City %lld appears more than once in the path\", v);\n        }\n        used.insert(v);\n    }\n\n    // Check that each consecutive pair is connected by an edge\n    for (int i = 0; i < path_len - 1; i++) {\n        long long u = path[i];\n        long long v = path[i + 1];\n        if (edges.find(make_pair(u, v)) == edges.end()) {\n            quitf(_wa, \"No edge between city %lld and city %lld\", u, v);\n        }\n    }\n\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> city_indices;\n\n    if (type == \"linear_increasing\") {\n        // City indices are consecutive increasing numbers starting from a random value\n        int start = rnd.next(1, int(1e9) - n);\n        for(int i = 0; i <= n; ++i) {\n            city_indices.push_back(start + i);\n        }\n    } else if (type == \"linear_decreasing\") {\n        // City indices are consecutive decreasing numbers starting from a random value\n        int start = rnd.next(n+1, int(1e9));\n        for(int i = 0; i <= n; ++i) {\n            city_indices.push_back(start - i);\n        }\n    } else if (type == \"max_indices\") {\n        // City indices are random and close to the maximum value\n        int max_value = int(1e9);\n        set<int> indices_set;\n        while((int)indices_set.size() < n+1) {\n            int value = rnd.next(max_value - n, max_value);\n            indices_set.insert(value);\n        }\n        for(int val : indices_set) {\n            city_indices.push_back(val);\n        }\n    } else if (type == \"min_indices\") {\n        // City indices are random and close to the minimum value\n        int min_value = 1;\n        set<int> indices_set;\n        while((int)indices_set.size() < n+1) {\n            int value = rnd.next(min_value, min_value + n);\n            indices_set.insert(value);\n        }\n        for(int val : indices_set) {\n            city_indices.push_back(val);\n        }\n    } else if (type == \"large_random\") {\n        // For large n, generate indices in a specific range to avoid performance issues\n        int max_value = int(1e9);\n        int min_value = max_value - n*10;\n        set<int> indices_set;\n        while((int)indices_set.size() < n+1) {\n            int value = rnd.next(min_value, max_value);\n            indices_set.insert(value);\n        }\n        for(int val : indices_set) {\n            city_indices.push_back(val);\n        }\n    } else {\n        // Default or \"random\" type: city indices are random within the full range\n        set<int> indices_set;\n        while((int)indices_set.size() < n+1) {\n            int value = rnd.next(1, int(1e9));\n            indices_set.insert(value);\n        }\n        for(int val : indices_set) {\n            city_indices.push_back(val);\n        }\n    }\n\n    // Create edges (stamps) between adjacent city indices to form a valid route\n    vector<pair<int, int>> stamps;\n    for(int i = 0; i < n; ++i) {\n        int u = city_indices[i];\n        int v = city_indices[i+1];\n        if(rnd.next(0,1)) swap(u, v); // Randomly swap u and v\n        stamps.push_back({u, v});\n    }\n\n    // Shuffle the stamps to simulate random stamping order\n    shuffle(stamps.begin(), stamps.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the stamps\n    for(const auto& p : stamps) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> city_indices;\n\n    if (type == \"linear_increasing\") {\n        // City indices are consecutive increasing numbers starting from a random value\n        int start = rnd.next(1, int(1e9) - n);\n        for(int i = 0; i <= n; ++i) {\n            city_indices.push_back(start + i);\n        }\n    } else if (type == \"linear_decreasing\") {\n        // City indices are consecutive decreasing numbers starting from a random value\n        int start = rnd.next(n+1, int(1e9));\n        for(int i = 0; i <= n; ++i) {\n            city_indices.push_back(start - i);\n        }\n    } else if (type == \"max_indices\") {\n        // City indices are random and close to the maximum value\n        int max_value = int(1e9);\n        set<int> indices_set;\n        while((int)indices_set.size() < n+1) {\n            int value = rnd.next(max_value - n, max_value);\n            indices_set.insert(value);\n        }\n        for(int val : indices_set) {\n            city_indices.push_back(val);\n        }\n    } else if (type == \"min_indices\") {\n        // City indices are random and close to the minimum value\n        int min_value = 1;\n        set<int> indices_set;\n        while((int)indices_set.size() < n+1) {\n            int value = rnd.next(min_value, min_value + n);\n            indices_set.insert(value);\n        }\n        for(int val : indices_set) {\n            city_indices.push_back(val);\n        }\n    } else if (type == \"large_random\") {\n        // For large n, generate indices in a specific range to avoid performance issues\n        int max_value = int(1e9);\n        int min_value = max_value - n*10;\n        set<int> indices_set;\n        while((int)indices_set.size() < n+1) {\n            int value = rnd.next(min_value, max_value);\n            indices_set.insert(value);\n        }\n        for(int val : indices_set) {\n            city_indices.push_back(val);\n        }\n    } else {\n        // Default or \"random\" type: city indices are random within the full range\n        set<int> indices_set;\n        while((int)indices_set.size() < n+1) {\n            int value = rnd.next(1, int(1e9));\n            indices_set.insert(value);\n        }\n        for(int val : indices_set) {\n            city_indices.push_back(val);\n        }\n    }\n\n    // Create edges (stamps) between adjacent city indices to form a valid route\n    vector<pair<int, int>> stamps;\n    for(int i = 0; i < n; ++i) {\n        int u = city_indices[i];\n        int v = city_indices[i+1];\n        if(rnd.next(0,1)) swap(u, v); // Randomly swap u and v\n        stamps.push_back({u, v});\n    }\n\n    // Shuffle the stamps to simulate random stamping order\n    shuffle(stamps.begin(), stamps.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the stamps\n    for(const auto& p : stamps) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type linear_increasing\n./gen -n 2 -type linear_increasing\n./gen -n 3 -type linear_increasing\n\n./gen -n 1 -type linear_decreasing\n./gen -n 2 -type linear_decreasing\n./gen -n 3 -type linear_decreasing\n\n./gen -n 10 -type linear_increasing\n./gen -n 10 -type linear_decreasing\n./gen -n 10 -type random\n./gen -n 10 -type max_indices\n./gen -n 10 -type min_indices\n\n./gen -n 100 -type linear_increasing\n./gen -n 100 -type linear_decreasing\n./gen -n 100 -type random\n./gen -n 100 -type max_indices\n./gen -n 100 -type min_indices\n\n./gen -n 1000 -type random\n./gen -n 1000 -type max_indices\n./gen -n 1000 -type min_indices\n\n./gen -n 10000 -type random\n./gen -n 10000 -type max_indices\n./gen -n 10000 -type min_indices\n\n./gen -n 100000 -type random\n./gen -n 100000 -type large_random\n./gen -n 100000 -type max_indices\n./gen -n 100000 -type min_indices\n\n./gen -n 99999 -type linear_increasing\n./gen -n 99999 -type linear_decreasing\n\n./gen -n 50000 -type random\n./gen -n 50000 -type max_indices\n./gen -n 50000 -type min_indices\n\n./gen -n 12345 -type random\n./gen -n 54321 -type random\n\n./gen -n 100000 -type linear_increasing\n./gen -n 100000 -type linear_decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:08.934153",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "29/D",
      "title": "D. Ant on the Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (3 ≤ n ≤ 300) — amount of vertexes in the tree. Next n - 1 lines describe edges. Each edge is described with two integers — indexes of vertexes which it connects. Each edge can be passed in any direction. Vertexes are numbered starting from 1. The root of the tree has number 1. The last line contains k integers, where k is amount of leaves in the tree. These numbers describe the order in which the leaves should be visited. It is guaranteed that each leaf appears in this order exactly once.",
      "output_spec": "OutputIf the required route doesn't exist, output -1. Otherwise, output 2n - 1 numbers, describing the route. Every time the ant comes to a vertex, output it's index.",
      "sample_tests": "ExamplesInputCopy31 22 33OutputCopy1 2 3 2 1 InputCopy61 21 32 44 54 65 6 3OutputCopy1 2 4 5 4 6 4 2 1 3 1 InputCopy61 21 32 44 54 65 3 6OutputCopy-1",
      "description": "D. Ant on the Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (3 ≤ n ≤ 300) — amount of vertexes in the tree. Next n - 1 lines describe edges. Each edge is described with two integers — indexes of vertexes which it connects. Each edge can be passed in any direction. Vertexes are numbered starting from 1. The root of the tree has number 1. The last line contains k integers, where k is amount of leaves in the tree. These numbers describe the order in which the leaves should be visited. It is guaranteed that each leaf appears in this order exactly once.\n\nOutputIf the required route doesn't exist, output -1. Otherwise, output 2n - 1 numbers, describing the route. Every time the ant comes to a vertex, output it's index.\n\nInputCopy31 22 33OutputCopy1 2 3 2 1 InputCopy61 21 32 44 54 65 6 3OutputCopy1 2 4 5 4 6 4 2 1 3 1 InputCopy61 21 32 44 54 65 3 6OutputCopy-1\n\nInputCopy31 22 33\n\nOutputCopy1 2 3 2 1\n\nInputCopy61 21 32 44 54 65 6 3\n\nOutputCopy1 2 4 5 4 6 4 2 1 3 1\n\nInputCopy61 21 32 44 54 65 3 6\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces",
          "content": "Today in Russia it's not just the 20th of september, it's Recruiter's Day. In Azerbaijan – Oil Industry Worker's Day, and in Belarus – Customs Officer's Day. But for us it's another good day to arrange the round. Welcome to Codeforces Beta Round #29 (Div. 2, Codeforces format)!Helped with preparation of the round: Mike Mirzayanov, Dmitry Matov, Gerald Agapov and Nickolay Kuznetsov, thank them for that.Happy Recruiter's Day,Artem RakhovUPD:ProblemsStandingsWinner: espr1t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/684",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 29"
          },
          "content_length": 474
        },
        {
          "title": "My solution @ Round #29, [without Problem E] - Codeforces",
          "content": "Problem A:Check whether exist a pair i and j,they satisfy xi+di = xj && xj+dj = xi;Problem B:Pay attention to Just Right or Red. use Div and Mod can solve it easily;Problem C:As we know, there are only two path -- forward and reverse, so we can do DFS from the one-degree nodes (only two nodes).As their index may be very larger, so I used map<int,int> to do hash.void dfs(int i){     int sz = mat[i].size()-1, j;     UF(j,0,sz)     if (!vis[mat[i][j]])     {        vis[mat[i][j]] = 1;        printf(\" %d\",val[mat[i][j]]);        dfs(mat[i][j]);     }}Problem D: Floyd.First, Floyd pretreat the path from I to J, and save the path. Then get the answer.The order is a1,a2...ak, K is the number of the leaves, we can assume a0 = ak+1 = 1, the root.then, answer push_back the path[ai][ai+1].if the ans.size() > 2*N-1 , cout -1;else cout the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 1",
          "code": "8\n4 3\n1 4\n8 5\n7 6\n3 5\n7 3\n4 2\n2 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 2",
          "code": "3\n458744979 589655889\n248228386 824699605\n458744979 824699605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 3",
          "code": "4\n90104473 221011623\n18773664 221011623\n90104473 74427905\n74427905 186329050",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 4",
          "code": "1000 999 1 1 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 5",
          "code": "772 467 142 356 889",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 6",
          "code": "264896923 2497658\n57071588 447086061\n2497658 483723090\n57071588 264896923\n158310110 483723090\n158310110 72866107",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 7",
          "code": "In this case 5 4 3 1 1. Why the answer is 2.33333333I think it should be 2.66666667.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 300 + 5;\n\nint parent[MAX_N];\n\nvoid init(int n) {\n    for (int i = 1; i <= n; ++i) \n        parent[i] = i;\n}\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x);\n    int fy = find(y);\n    if (fx == fy)\n        return false;\n    parent[fx] = fy;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readEoln();\n\n    vector<int> degrees(n+1, 0);\n    init(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No self-loops allowed at node %d\", u);\n\n        degrees[u]++;\n        degrees[v]++;\n\n        if (!unite(u, v)) {\n            ensuref(false, \"Graph contains cycles due to edge between %d and %d\", u, v);\n        }\n    }\n    // Check connectedness\n    int root_parent = find(1);\n    for (int i = 1; i <= n; ++i) {\n        if (find(i) != root_parent){\n            ensuref(false, \"Graph is not connected, node %d is not connected to root\", i);\n        }\n    }\n\n    set<int> leaves_tree;\n    for (int i = 1; i <= n; ++i) {\n        if (degrees[i] == 1 && i != 1) {\n            leaves_tree.insert(i);\n        }\n    }\n\n    int k = leaves_tree.size();\n\n    // Read the last line\n    string s = inf.readLine();\n    istringstream iss(s);\n    vector<int> leaves_order;\n    int x;\n    while (iss >> x) {\n        ensuref(1 <= x && x <= n, \"Leaf number %d out of range\", x);\n        leaves_order.push_back(x);\n    }\n\n    ensuref(leaves_order.size() == k, \"Expected %d leaves, but got %d in the order\", k, int(leaves_order.size()));\n\n    set<int> leaves_order_set(leaves_order.begin(), leaves_order.end());\n    ensuref(int(leaves_order_set.size()) == k, \"Duplicate leaves in the order\");\n\n    ensuref(leaves_order_set == leaves_tree, \"Leaves in the order do not match leaves in the tree\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 300 + 5;\n\nint parent[MAX_N];\n\nvoid init(int n) {\n    for (int i = 1; i <= n; ++i) \n        parent[i] = i;\n}\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x);\n    int fy = find(y);\n    if (fx == fy)\n        return false;\n    parent[fx] = fy;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readEoln();\n\n    vector<int> degrees(n+1, 0);\n    init(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No self-loops allowed at node %d\", u);\n\n        degrees[u]++;\n        degrees[v]++;\n\n        if (!unite(u, v)) {\n            ensuref(false, \"Graph contains cycles due to edge between %d and %d\", u, v);\n        }\n    }\n    // Check connectedness\n    int root_parent = find(1);\n    for (int i = 1; i <= n; ++i) {\n        if (find(i) != root_parent){\n            ensuref(false, \"Graph is not connected, node %d is not connected to root\", i);\n        }\n    }\n\n    set<int> leaves_tree;\n    for (int i = 1; i <= n; ++i) {\n        if (degrees[i] == 1 && i != 1) {\n            leaves_tree.insert(i);\n        }\n    }\n\n    int k = leaves_tree.size();\n\n    // Read the last line\n    string s = inf.readLine();\n    istringstream iss(s);\n    vector<int> leaves_order;\n    int x;\n    while (iss >> x) {\n        ensuref(1 <= x && x <= n, \"Leaf number %d out of range\", x);\n        leaves_order.push_back(x);\n    }\n\n    ensuref(leaves_order.size() == k, \"Expected %d leaves, but got %d in the order\", k, int(leaves_order.size()));\n\n    set<int> leaves_order_set(leaves_order.begin(), leaves_order.end());\n    ensuref(int(leaves_order_set.size()) == k, \"Duplicate leaves in the order\");\n\n    ensuref(leaves_order_set == leaves_tree, \"Leaves in the order do not match leaves in the tree\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 300 + 5;\n\nint parent[MAX_N];\n\nvoid init(int n) {\n    for (int i = 1; i <= n; ++i) \n        parent[i] = i;\n}\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x);\n    int fy = find(y);\n    if (fx == fy)\n        return false;\n    parent[fx] = fy;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readEoln();\n\n    vector<int> degrees(n+1, 0);\n    init(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No self-loops allowed at node %d\", u);\n\n        degrees[u]++;\n        degrees[v]++;\n\n        if (!unite(u, v)) {\n            ensuref(false, \"Graph contains cycles due to edge between %d and %d\", u, v);\n        }\n    }\n    // Check connectedness\n    int root_parent = find(1);\n    for (int i = 1; i <= n; ++i) {\n        if (find(i) != root_parent){\n            ensuref(false, \"Graph is not connected, node %d is not connected to root\", i);\n        }\n    }\n\n    set<int> leaves_tree;\n    for (int i = 1; i <= n; ++i) {\n        if (degrees[i] == 1 && i != 1) {\n            leaves_tree.insert(i);\n        }\n    }\n\n    int k = leaves_tree.size();\n\n    // Read the last line\n    string s = inf.readLine();\n    istringstream iss(s);\n    vector<int> leaves_order;\n    int x;\n    while (iss >> x) {\n        ensuref(1 <= x && x <= n, \"Leaf number %d out of range\", x);\n        leaves_order.push_back(x);\n    }\n\n    ensuref(leaves_order.size() == k, \"Expected %d leaves, but got %d in the order\", k, int(leaves_order.size()));\n\n    set<int> leaves_order_set(leaves_order.begin(), leaves_order.end());\n    ensuref(int(leaves_order_set.size()) == k, \"Duplicate leaves in the order\");\n\n    ensuref(leaves_order_set == leaves_tree, \"Leaves in the order do not match leaves in the tree\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n; // number of vertices\nvector<vector<int>> tree; // adjacency list\nvector<int> leafOrder;\n\nset<pair<int, int>> edges; // set of edges\nset<int> leaves; // set of leaves (excluding root)\n\nvoid readInput() {\n    // Read n\n    n = inf.readInt(3, 300);\n    tree.resize(n + 1); // nodes numbered from 1 to n inclusive\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n);\n        int v = inf.readInt(1, n);\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n        edges.insert(make_pair(min(u, v), max(u, v)));\n    }\n    // Identify leaves (excluding root)\n    for (int i = 2; i <= n; i++) {\n        if (tree[i].size() == 1) {\n            leaves.insert(i);\n        }\n    }\n    // Read leaf order\n    while (!inf.seekEof()) {\n        int x = inf.readInt(1, n);\n        leafOrder.push_back(x);\n    }\n}\n\nvector<int> readRoute(InStream& stream) {\n    vector<int> route;\n    if (stream.seekEof()) {\n        stream.quitf(_fail, \"No output\");\n    }\n    string s = stream.readToken();\n    if (s == \"-1\") {\n        route.push_back(-1);\n        return route;\n    } else {\n        int firstNode = atoi(s.c_str());\n        if (firstNode != 1) {\n            stream.quitf(_wa, \"Route does not start at root node 1\");\n        }\n        route.push_back(firstNode);\n        while (!stream.seekEof()) {\n            int node = stream.readInt(1, n);\n            route.push_back(node);\n        }\n        if (route.size() != 2 * n - 1) {\n            stream.quitf(_wa, \"Route length is incorrect, expected %d, found %d\", 2 * n - 1, int(route.size()));\n        }\n        if (route.back() != 1) {\n            stream.quitf(_wa, \"Route does not end at root node 1\");\n        }\n        return route;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    readInput(); // read the input and build the tree\n    vector<int> juryRoute = readRoute(ans);\n    vector<int> participantRoute = readRoute(ouf);\n\n    if (juryRoute.size() == 1 && juryRoute[0] == -1) {\n        if (participantRoute.size() == 1 && participantRoute[0] == -1) {\n            quitf(_ok, \"Correct, both outputs are -1\");\n        } else {\n            quitf(_wa, \"Jury says no route, but participant outputs a route\");\n        }\n    } else {\n        if (participantRoute.size() == 1 && participantRoute[0] == -1) {\n            quitf(_wa, \"Participant outputs -1, but route exists\");\n        } else {\n            // Both outputs are routes, validate participant's route\n            vector<int>& route = participantRoute;\n\n            // Check that edges are valid\n            map<pair<int, int>, int> edgeCounts;\n            for (int i = 0; i < route.size() - 1; ++i) {\n                int u = route[i];\n                int v = route[i + 1];\n                int a = min(u, v);\n                int b = max(u, v);\n                if (edges.find(make_pair(a, b)) == edges.end()) {\n                    ouf.quitf(_wa, \"Edge between %d and %d does not exist in the tree\", u, v);\n                }\n                edgeCounts[make_pair(a, b)]++;\n            }\n\n            // Check that every edge is traversed exactly twice\n            for (auto e : edges) {\n                if (edgeCounts[e] != 2) {\n                    ouf.quitf(_wa, \"Edge between %d and %d is traversed %d times instead of 2\", e.first, e.second, edgeCounts[e]);\n                }\n            }\n            if (edgeCounts.size() != edges.size()) {\n                ouf.quitf(_wa, \"Some edges traversed are not in the tree\");\n            }\n\n            // Ensure every vertex is visited\n            set<int> visited(route.begin(), route.end());\n            if (int(visited.size()) != n) {\n                ouf.quitf(_wa, \"Not all vertices are visited\");\n            }\n\n            // Check that the leaves are visited in specified order\n            map<int, int> firstVisit; // leaf -> position\n            for (int i = 0; i < int(route.size()); ++i) {\n                int node = route[i];\n                if (leaves.find(node) != leaves.end()) {\n                    if (firstVisit.find(node) == firstVisit.end()) {\n                        firstVisit[node] = i;\n                    }\n                }\n            }\n            for (int leaf : leafOrder) {\n                if (firstVisit.find(leaf) == firstVisit.end()) {\n                    ouf.quitf(_wa, \"Leaf %d is not visited in the route\", leaf);\n                }\n            }\n            for (int i = 1; i < int(leafOrder.size()); ++i) {\n                int prevLeaf = leafOrder[i - 1];\n                int currLeaf = leafOrder[i];\n                if (firstVisit[prevLeaf] >= firstVisit[currLeaf]) {\n                    ouf.quitf(_wa, \"Leaves are not visited in the specified order\");\n                }\n            }\n            // If we reach here, participant's route is acceptable\n            quitf(_ok, \"Correct route\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string leaf_order = opt<string>(\"leaf_order\", \"random\");\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"line\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        int cnt = 1; // Start from node 1\n        queue<int> q;\n        q.push(cnt);\n        while (cnt < n) {\n            int parent = q.front(); q.pop();\n            int left = ++cnt;\n            edges.push_back({parent, left});\n            q.push(left);\n            if (cnt >= n) break;\n            int right = ++cnt;\n            edges.push_back({parent, right});\n            q.push(right);\n        }\n    } else if (type == \"random\") {\n        if (n == 1) {\n            // special case: single node tree\n        } else {\n            // Generate a random tree using Prufer code\n            vector<int> prufer;\n            for (int i = 0; i < n - 2; ++i) {\n                prufer.push_back(rnd.next(1, n));\n            }\n            vector<int> degree(n + 1, 1);\n            for (int v : prufer) {\n                degree[v]++;\n            }\n            set<int> leaves;\n            for (int i = 1; i <= n; ++i) {\n                if (degree[i] == 1) {\n                    leaves.insert(i);\n                }\n            }\n            for (int v : prufer) {\n                int leaf = *leaves.begin();\n                leaves.erase(leaves.begin());\n                edges.push_back({leaf, v});\n                degree[leaf]--;\n                degree[v]--;\n                if (degree[v] == 1) {\n                    leaves.insert(v);\n                }\n            }\n            auto it = leaves.begin();\n            int u = *it;\n            ++it;\n            int v = *it;\n            edges.push_back({u, v});\n        }\n    }\n\n    // Calculate degrees to find leaves\n    vector<int> deg(n + 1, 0);\n    for (auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        deg[u]++;\n        deg[v]++;\n    }\n\n    // Collect leaves (degree == 1, excluding root)\n    vector<int> leaves;\n    for (int i = 1; i <= n; ++i) {\n        if (deg[i] == 1 && i != 1) {\n            leaves.push_back(i);\n        }\n    }\n\n    if (leaf_order == \"random\") {\n        shuffle(leaves.begin(), leaves.end());\n    } else if (leaf_order == \"in_order\") {\n        sort(leaves.begin(), leaves.end());\n    } else if (leaf_order == \"reverse\") {\n        sort(leaves.begin(), leaves.end(), greater<int>());\n    } else if (leaf_order == \"impossible\") {\n        if (leaves.size() >= 2)\n            swap(leaves[0], leaves[1]); // Swap first two leaves to potentially create an impossible sequence.\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    // Output leaves sequence\n    for (int i = 0; i < leaves.size(); ++i) {\n        printf(\"%d\", leaves[i]);\n        if (i + 1 < leaves.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string leaf_order = opt<string>(\"leaf_order\", \"random\");\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"line\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        int cnt = 1; // Start from node 1\n        queue<int> q;\n        q.push(cnt);\n        while (cnt < n) {\n            int parent = q.front(); q.pop();\n            int left = ++cnt;\n            edges.push_back({parent, left});\n            q.push(left);\n            if (cnt >= n) break;\n            int right = ++cnt;\n            edges.push_back({parent, right});\n            q.push(right);\n        }\n    } else if (type == \"random\") {\n        if (n == 1) {\n            // special case: single node tree\n        } else {\n            // Generate a random tree using Prufer code\n            vector<int> prufer;\n            for (int i = 0; i < n - 2; ++i) {\n                prufer.push_back(rnd.next(1, n));\n            }\n            vector<int> degree(n + 1, 1);\n            for (int v : prufer) {\n                degree[v]++;\n            }\n            set<int> leaves;\n            for (int i = 1; i <= n; ++i) {\n                if (degree[i] == 1) {\n                    leaves.insert(i);\n                }\n            }\n            for (int v : prufer) {\n                int leaf = *leaves.begin();\n                leaves.erase(leaves.begin());\n                edges.push_back({leaf, v});\n                degree[leaf]--;\n                degree[v]--;\n                if (degree[v] == 1) {\n                    leaves.insert(v);\n                }\n            }\n            auto it = leaves.begin();\n            int u = *it;\n            ++it;\n            int v = *it;\n            edges.push_back({u, v});\n        }\n    }\n\n    // Calculate degrees to find leaves\n    vector<int> deg(n + 1, 0);\n    for (auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        deg[u]++;\n        deg[v]++;\n    }\n\n    // Collect leaves (degree == 1, excluding root)\n    vector<int> leaves;\n    for (int i = 1; i <= n; ++i) {\n        if (deg[i] == 1 && i != 1) {\n            leaves.push_back(i);\n        }\n    }\n\n    if (leaf_order == \"random\") {\n        shuffle(leaves.begin(), leaves.end());\n    } else if (leaf_order == \"in_order\") {\n        sort(leaves.begin(), leaves.end());\n    } else if (leaf_order == \"reverse\") {\n        sort(leaves.begin(), leaves.end(), greater<int>());\n    } else if (leaf_order == \"impossible\") {\n        if (leaves.size() >= 2)\n            swap(leaves[0], leaves[1]); // Swap first two leaves to potentially create an impossible sequence.\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    // Output leaves sequence\n    for (int i = 0; i < leaves.size(); ++i) {\n        printf(\"%d\", leaves[i]);\n        if (i + 1 < leaves.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type line -leaf_order in_order\n./gen -n 3 -type line -leaf_order reverse\n./gen -n 3 -type line -leaf_order random\n\n./gen -n 5 -type star -leaf_order in_order\n./gen -n 5 -type star -leaf_order reverse\n./gen -n 5 -type star -leaf_order random\n\n./gen -n 7 -type binary -leaf_order in_order\n./gen -n 7 -type binary -leaf_order reverse\n./gen -n 7 -type binary -leaf_order random\n\n./gen -n 10 -type random -leaf_order in_order\n./gen -n 10 -type random -leaf_order reverse\n./gen -n 10 -type random -leaf_order random\n\n./gen -n 50 -type line -leaf_order in_order\n./gen -n 50 -type line -leaf_order reverse\n./gen -n 50 -type line -leaf_order random\n\n./gen -n 100 -type star -leaf_order in_order\n./gen -n 100 -type star -leaf_order reverse\n./gen -n 100 -type star -leaf_order random\n\n./gen -n 200 -type binary -leaf_order in_order\n./gen -n 200 -type binary -leaf_order reverse\n./gen -n 200 -type binary -leaf_order random\n\n./gen -n 300 -type random -leaf_order in_order\n./gen -n 300 -type random -leaf_order reverse\n./gen -n 300 -type random -leaf_order random\n\n# Including some 'impossible' cases\n./gen -n 6 -type line -leaf_order impossible\n./gen -n 6 -type star -leaf_order impossible\n./gen -n 7 -type binary -leaf_order impossible\n./gen -n 10 -type random -leaf_order impossible\n./gen -n 50 -type random -leaf_order impossible\n\n# Additional tests\n./gen -n 100 -type line -leaf_order impossible\n./gen -n 100 -type star -leaf_order impossible\n./gen -n 100 -type binary -leaf_order impossible\n./gen -n 100 -type random -leaf_order impossible\n\n# Maximum size tests\n./gen -n 300 -type line -leaf_order random\n./gen -n 300 -type star -leaf_order random\n./gen -n 300 -type binary -leaf_order random\n./gen -n 300 -type random -leaf_order random\n\n# Edge cases\n./gen -n 3 -type random -leaf_order impossible\n./gen -n 3 -type random -leaf_order random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:11.168338",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "29/E",
      "title": "E. Quarrel",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 10000) — the amount of crossroads and the amount of roads. Each of the following m lines contains two integers — the numbers of crossroads connected by the road. It is guaranteed that no road connects a crossroads with itself and no two crossroads are connected by more than one road.",
      "output_spec": "OutputIf the required routes don't exist, output -1. Otherwise, the first line should contain integer k — the length of shortest routes (the length of the route is the amount of roads in it). The next line should contain k + 1 integers — Bob's route, i.e. the numbers of k + 1 crossroads passed by Bob. The last line should contain Alex's route in the same format. If there are several optimal solutions, output any of them.",
      "sample_tests": "ExamplesInputCopy2 11 2OutputCopy11 2 2 1 InputCopy7 51 22 77 62 33 4OutputCopy-1InputCopy7 61 22 77 62 33 41 5OutputCopy61 2 3 4 3 2 7 7 6 7 2 1 5 1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 10000) — the amount of crossroads and the amount of roads. Each of the following m lines contains two integers — the numbers of crossroads connected by the road. It is guaranteed that no road connects a crossroads with itself and no two crossroads are connected by more than one road.\n\nOutputIf the required routes don't exist, output -1. Otherwise, the first line should contain integer k — the length of shortest routes (the length of the route is the amount of roads in it). The next line should contain k + 1 integers — Bob's route, i.e. the numbers of k + 1 crossroads passed by Bob. The last line should contain Alex's route in the same format. If there are several optimal solutions, output any of them.\n\nInputCopy2 11 2OutputCopy11 2 2 1 InputCopy7 51 22 77 62 33 4OutputCopy-1InputCopy7 61 22 77 62 33 41 5OutputCopy61 2 3 4 3 2 7 7 6 7 2 1 5 1\n\nInputCopy2 11 2\n\nOutputCopy11 2 2 1\n\nInputCopy7 51 22 77 62 33 4\n\nOutputCopy-1\n\nInputCopy7 61 22 77 62 33 41 5\n\nOutputCopy61 2 3 4 3 2 7 7 6 7 2 1 5 1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces",
          "content": "Today in Russia it's not just the 20th of september, it's Recruiter's Day. In Azerbaijan – Oil Industry Worker's Day, and in Belarus – Customs Officer's Day. But for us it's another good day to arrange the round. Welcome to Codeforces Beta Round #29 (Div. 2, Codeforces format)!Helped with preparation of the round: Mike Mirzayanov, Dmitry Matov, Gerald Agapov and Nickolay Kuznetsov, thank them for that.Happy Recruiter's Day,Artem RakhovUPD:ProblemsStandingsWinner: espr1t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/684",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 29"
          },
          "content_length": 474
        },
        {
          "title": "My solution @ Round #29, [without Problem E] - Codeforces",
          "content": "Problem A:Check whether exist a pair i and j,they satisfy xi+di = xj && xj+dj = xi;Problem B:Pay attention to Just Right or Red. use Div and Mod can solve it easily;Problem C:As we know, there are only two path -- forward and reverse, so we can do DFS from the one-degree nodes (only two nodes).As their index may be very larger, so I used map<int,int> to do hash.void dfs(int i){     int sz = mat[i].size()-1, j;     UF(j,0,sz)     if (!vis[mat[i][j]])     {        vis[mat[i][j]] = 1;        printf(\" %d\",val[mat[i][j]]);        dfs(mat[i][j]);     }}Problem D: Floyd.First, Floyd pretreat the path from I to J, and save the path. Then get the answer.The order is a1,a2...ak, K is the number of the leaves, we can assume a0 = ak+1 = 1, the root.then, answer push_back the path[ai][ai+1].if the ans.size() > 2*N-1 , cout -1;else cout the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 1",
          "code": "8\n4 3\n1 4\n8 5\n7 6\n3 5\n7 3\n4 2\n2 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 2",
          "code": "3\n458744979 589655889\n248228386 824699605\n458744979 824699605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 3",
          "code": "4\n90104473 221011623\n18773664 221011623\n90104473 74427905\n74427905 186329050",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 4",
          "code": "1000 999 1 1 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 5",
          "code": "772 467 142 356 889",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 6",
          "code": "264896923 2497658\n57071588 447086061\n2497658 483723090\n57071588 264896923\n158310110 483723090\n158310110 72866107",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #29 (Codeforces format, Див. 2) - Codeforces - Code 7",
          "code": "In this case 5 4 3 1 1. Why the answer is 2.33333333I think it should be 2.66666667.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/684",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        // Ensure no road connects a crossroads with itself.\n        ensuref(u != v, \"Road cannot connect a crossroads with itself (u_i = v_i = %d)\", u);\n\n        // Ensure no two crossroads are connected by more than one road.\n        int a = min(u, v), b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Multiple roads between crossroads %d and %d\", a, b);\n        edges.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        // Ensure no road connects a crossroads with itself.\n        ensuref(u != v, \"Road cannot connect a crossroads with itself (u_i = v_i = %d)\", u);\n\n        // Ensure no two crossroads are connected by more than one road.\n        int a = min(u, v), b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Multiple roads between crossroads %d and %d\", a, b);\n        edges.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        // Ensure no road connects a crossroads with itself.\n        ensuref(u != v, \"Road cannot connect a crossroads with itself (u_i = v_i = %d)\", u);\n\n        // Ensure no two crossroads are connected by more than one road.\n        int a = min(u, v), b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Multiple roads between crossroads %d and %d\", a, b);\n        edges.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 500 + 1; // Since n can be up to 500\n\nint n, m;\nvector<int> adj[MAXN];\n\nbool edgeExists(int u, int v) {\n    // Check if edge exists between u and v\n    return find(adj[u].begin(), adj[u].end(), v) != adj[u].end();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input graph\n    n = inf.readInt(2, 500, \"n\");\n    m = inf.readInt(1, 10000, \"m\");\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        int v = inf.readInt(1, n, \"v\");\n        if (u == v)\n            inf.quitf(_fail, \"Self-loops are not allowed in the graph.\");\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    bool juryHasSolution;\n    int jury_k = ans.readInt(); // Read jury's answer\n    if (jury_k == -1) {\n        juryHasSolution = false;\n    } else {\n        juryHasSolution = true;\n        // We can skip reading the rest of the jury's answer\n        // as it's not necessary for this checker\n    }\n\n    bool participantHasSolution;\n    int participant_k = ouf.readInt(); // Read participant's answer\n    if (participant_k == -1) {\n        participantHasSolution = false;\n    } else {\n        participantHasSolution = true;\n    }\n\n    if (!participantHasSolution) {\n        if (juryHasSolution) {\n            quitf(_wa, \"Participant claims no solution exists, but the jury found a solution.\");\n        } else {\n            quitf(_ok, \"Correct: both participant and jury agree that no solution exists.\");\n        }\n    } else {\n        if (!juryHasSolution) {\n            quitf(_fail, \"Participant found a solution but the jury claims no solution exists.\");\n        }\n        // The participant provided a solution, need to validate it\n\n        // Validate k\n        if (participant_k < 1)\n            quitf(_wa, \"Invalid k (%d). It should be at least 1.\", participant_k);\n\n        // Read Bob's route\n        vector<int> bobPath = ouf.readInts(participant_k + 1, 1, n, \"Bob's path\");\n        // Read Alex's route\n        vector<int> alexPath = ouf.readInts(participant_k + 1, 1, n, \"Alex's path\");\n\n        // Validate Bob's path\n        if (bobPath.front() != 1)\n            quitf(_wa, \"Bob's path does not start from crossroad 1.\");\n        if (bobPath.back() != n)\n            quitf(_wa, \"Bob's path does not end at crossroad n (%d).\", n);\n        for (int i = 0; i < participant_k; i++) {\n            int u = bobPath[i];\n            int v = bobPath[i + 1];\n            if (!edgeExists(u, v))\n                quitf(_wa, \"Bob's path contains invalid edge between %d and %d.\", u, v);\n        }\n\n        // Validate Alex's path\n        if (alexPath.front() != n)\n            quitf(_wa, \"Alex's path does not start from crossroad n (%d).\", n);\n        if (alexPath.back() != 1)\n            quitf(_wa, \"Alex's path does not end at crossroad 1.\");\n        for (int i = 0; i < participant_k; i++) {\n            int u = alexPath[i];\n            int v = alexPath[i + 1];\n            if (!edgeExists(u, v))\n                quitf(_wa, \"Alex's path contains invalid edge between %d and %d.\", u, v);\n        }\n\n        // Check that Bob and Alex are not at the same crossroad at the same time\n        for (int t = 0; t <= participant_k; t++) {\n            if (bobPath[t] == alexPath[t])\n                quitf(_wa, \"Bob and Alex are at the same crossroad %d at time %d.\", bobPath[t], t);\n        }\n\n        // If all checks pass, accept the participant's solution\n        quitf(_ok, \"Correct solution.\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", -1); // default -1 means set m as per type\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        m = n - 1;\n        for(int i=1; i<n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        for(int i=2; i<=n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"double_star\") {\n        m = 2 * (n - 2);\n        for(int i=2; i<n; ++i) {\n            edges.push_back({1, i});\n            edges.push_back({n, i});\n        }\n    } else if (type == \"random_sparse\") {\n        if (m == -1) m = n - 1 + rnd.next(0, n/2);\n        // Generate random tree first\n        vector<int> parent(n+1);\n        for(int i=2; i<=n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        // Add random edges to reach m\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v && !edge_set.count({u,v}) && !edge_set.count({v,u})) {\n                edges.push_back({u,v});\n                edge_set.insert({u,v});\n            }\n        }\n    } else if (type == \"random_dense\") {\n        if (m == -1) m = min(10000, n*(n-1)/2);\n        // Generate random edges\n        set<pair<int,int>> edge_set;\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                int a = min(u,v);\n                int b = max(u,v);\n                if (!edge_set.count({a,b})) {\n                    edge_set.insert({a,b});\n                    edges.push_back({u,v});\n                }\n            }\n        }\n    } else if (type == \"no_solution\") {\n        // Construct a chain of odd length where no solution exists\n        if (n % 2 == 0) n++; // Ensure n is odd\n        m = n - 1;\n        for(int i=1; i<n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"yes_solution\") {\n        // Construct a chain with an extra edge to allow a solution\n        m = n;\n        for(int i=1; i<n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({1, n});\n    } else {\n        // Default to random connected graph\n        if (m == -1) m = min(10000, n*(n-1)/2);\n        // Generate random tree first\n        vector<int> parent(n+1);\n        for(int i=2; i<=n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        // Add random edges to reach m\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v && !edge_set.count({u,v}) && !edge_set.count({v,u})) {\n                edges.push_back({u,v});\n                edge_set.insert({u,v});\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", -1); // default -1 means set m as per type\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        m = n - 1;\n        for(int i=1; i<n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        for(int i=2; i<=n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"double_star\") {\n        m = 2 * (n - 2);\n        for(int i=2; i<n; ++i) {\n            edges.push_back({1, i});\n            edges.push_back({n, i});\n        }\n    } else if (type == \"random_sparse\") {\n        if (m == -1) m = n - 1 + rnd.next(0, n/2);\n        // Generate random tree first\n        vector<int> parent(n+1);\n        for(int i=2; i<=n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        // Add random edges to reach m\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v && !edge_set.count({u,v}) && !edge_set.count({v,u})) {\n                edges.push_back({u,v});\n                edge_set.insert({u,v});\n            }\n        }\n    } else if (type == \"random_dense\") {\n        if (m == -1) m = min(10000, n*(n-1)/2);\n        // Generate random edges\n        set<pair<int,int>> edge_set;\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                int a = min(u,v);\n                int b = max(u,v);\n                if (!edge_set.count({a,b})) {\n                    edge_set.insert({a,b});\n                    edges.push_back({u,v});\n                }\n            }\n        }\n    } else if (type == \"no_solution\") {\n        // Construct a chain of odd length where no solution exists\n        if (n % 2 == 0) n++; // Ensure n is odd\n        m = n - 1;\n        for(int i=1; i<n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"yes_solution\") {\n        // Construct a chain with an extra edge to allow a solution\n        m = n;\n        for(int i=1; i<n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({1, n});\n    } else {\n        // Default to random connected graph\n        if (m == -1) m = min(10000, n*(n-1)/2);\n        // Generate random tree first\n        vector<int> parent(n+1);\n        for(int i=2; i<=n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        // Add random edges to reach m\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v && !edge_set.count({u,v}) && !edge_set.count({v,u})) {\n                edges.push_back({u,v});\n                edge_set.insert({u,v});\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 3 -type chain\n./gen -n 4 -type chain\n./gen -n 5 -type chain\n\n./gen -n 5 -type star\n./gen -n 5 -type double_star\n\n./gen -n 5 -type no_solution\n./gen -n 5 -type yes_solution\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random_sparse\n./gen -n 10 -type random_dense\n\n./gen -n 50 -type chain\n./gen -n 50 -type random_sparse\n./gen -n 50 -type random_dense\n\n./gen -n 100 -type random_sparse\n./gen -n 100 -type random_dense\n\n./gen -n 200 -type chain\n./gen -n 200 -type no_solution\n\n./gen -n 300 -type yes_solution\n./gen -n 300 -type random_sparse\n\n./gen -n 400 -type random_sparse\n./gen -n 400 -type random_dense\n\n./gen -n 500 -type random_dense\n./gen -n 500 -type no_solution\n./gen -n 500 -type yes_solution\n\n./gen -n 500 -type chain\n./gen -n 500 -type star\n\n./gen -n 500 -type double_star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:13.257086",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "292/A",
      "title": "A. SMSC",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 103) — the number of tasks of the SMSC. Next n lines contain the tasks' descriptions: the i-th line contains two space-separated integers ti and ci (1 ≤ ti, ci ≤ 106) — the time (the second) when the i-th task was received and the number of messages to send, correspondingly.It is guaranteed that all tasks were received at different moments of time. It is guaranteed that the tasks are sorted in the chronological order, that is, ti < ti + 1 for all integer i (1 ≤ i < n).",
      "output_spec": "OutputIn a single line print two space-separated integers — the time when the last text message was sent and the maximum queue size at a certain moment of time.",
      "sample_tests": "ExamplesInputCopy21 12 1OutputCopy3 1InputCopy11000000 10OutputCopy1000010 10InputCopy33 34 35 3OutputCopy12 7",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 103) — the number of tasks of the SMSC. Next n lines contain the tasks' descriptions: the i-th line contains two space-separated integers ti and ci (1 ≤ ti, ci ≤ 106) — the time (the second) when the i-th task was received and the number of messages to send, correspondingly.It is guaranteed that all tasks were received at different moments of time. It is guaranteed that the tasks are sorted in the chronological order, that is, ti < ti + 1 for all integer i (1 ≤ i < n).\n\nOutputIn a single line print two space-separated integers — the time when the last text message was sent and the maximum queue size at a certain moment of time.\n\nInputCopy21 12 1OutputCopy3 1InputCopy11000000 10OutputCopy1000010 10InputCopy33 34 35 3OutputCopy12 7\n\nInputCopy21 12 1\n\nOutputCopy3 1\n\nInputCopy11000000 10\n\nOutputCopy1000010 10\n\nInputCopy33 34 35 3\n\nOutputCopy12 7\n\nNoteIn the first test sample:   second 1: the first message has appeared in the queue, the queue's size is 1;  second 2: the first message is sent, the second message has been received, the queue's size is 1;  second 3: the second message is sent, the queue's size is 0, Thus, the maximum size of the queue is 1, the last message was sent at the second 3.",
      "solutions": [
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces",
          "content": "Good day)Soon is coming Round 1 of the All-Russian Programming Championship CROC-2013. Contestants who gain a score equal to the 400-th place finisher score or greater will advance to the Round 2 (also you need to gain positive score).Round will be held by usual Codeforces rules (with hacks and decreasing values of the problems). During the round the problems are judged only on pretests and system testing will take place after the end of the contest. The pretests do not cover all possible cases of input data, test your programs carefully.Before the end of the round it is strictly forbidden to publish the problem statements/solutions/any thoughts and ideas about them elsewhere. It is forbidden to talk about the problems, discuss the statements, solutions and so on.The problems were prepared by the group of authors: Pavel Kholkin (HolkinPV), Gerald Agapov (Gerald) and Michael Mirzayanov (MikeMirzayanov). I will add that our team have already prepared for you qualification round and answered the questions during the whole competition. Traditionally thanks to Mary Belova (Delinur) for translating the problems.UPD1: The problems are sorted by increasing of estimated difficulty. The score dustribution is decided to be not standard a little bit : 1000, 1000, 1500, 2000, 2500.UPD2: due to the large number of participants, it is decided that it will not be able to participate out the competition. For official contest participants the round will be rated.We wish all the participants good luck and successful advance to the next round of competition.",
          "author": "HolkinPV",
          "url": "https://codeforces.com/blog/entry/7361",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1564
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 (Разбор задач) - Codeforces",
          "content": "292A - SMSCДля каждого момента i времени запомним количество сообщений z[i], которое нужно отправить в момент времени i. Теперь пройдем по каждому моменту времени от 1 до 106, поддерживая текущий размер очереди sz. На каждой итерации попробуем уменьшить размер очереди на 1, то есть выполним sz = max(sz - 1, 0), затем прибавим сообщения, которые нужно отправить в эту секунду, то есть выполним sz = sz + z[i]. На каждом шаге будем обновлять максимальное значение очереди и текущее время, если sz > 0. После выполнения цикла, если в очереди остались неотправленные сообщения, то нужно еще раз обновить ответ.292B - Network TopologyВ этой задаче нужно было посчитать степени каждой вершины и найти ответ. Замечу, поскольку n >  = 4, m >  = 3 и граф связный, то ответ однозначный.1) все степени 2 и у двух вершин степень 1 — шина.2) все степени 2 — кольцо3) все степени 1 и у одной степень  > 2 — звезда4) иначе неизвестно292C - Beautiful IP AddressesЗадача решается перебором. Для начала переберем сколько цифр в каждом четверти мы возьмем, например AAA.B.CC.DDD. Теперь посчитаем количество символов в этой строке (AAABCCDDD) и переберем цифры на первой половине этой строки (поскольку строка должна быть палиндромом, то вторая половина однозначно восстанавливается). После этого проверим, что такой ip-адрес является корректным и содержит правильный набор цифр. Если ip-адрес удовлетворяет всем условиям задачи, то добавим его к ответу.292D - Connected ComponentsОграничения в задаче были не слишком удачными и провоцировали писать решение за квадрат, мы постарались максимально не позволить таким решениям пройти.У этой задачи много правильных решений. Изначально планировалось решение, которое предподсчитывает частичные dsu (структура данных disjoint set union) на префиксах и на суффиксах, то есть массивы ldsu[M][N] и rdsu[M][N]. После этого на запрос [lf ; rg] легко ответить за время O(N·A - 1), если объединить множества ldsu[lf - 1] и rdsu[rg + 1], где A - 1 -- обратная функция Аккермана (константа от dsu).292E - Copying DataУ этой задачи много правильных решений. Изначально предполагалось решение, использующие корневую эвристику. Разобьем все запросы на sqrt(m) блоков. Будем поддерживать текущий массив b в виде отрезков в массиве z, который хранит четверки (lf, rg, type, start), где lf, rg — отрезок индексов массива b, type — 0 или 1, означающее из какого массива взяты числа для этого отрезка, start — позиция начала этого отрезка в массиве типа type. На запросы будем отвечать в тупую, то есть честно пересчитывать как изменится массив z от запроса копирования и отвечать на запросы значения в позициях. Однако, каждые sqrt(m) запросов будем сливать данные из массива z в массив b, для того чтобы сам массив z сильно не разрастался.Есть простое решение с деревом отрезков, которое умеет делать покраску на отрезке. Пусть пришел запрос копирования [lf ; rg], , тогда покрасим отрезок запроса [lf ; rg] в цвет, равный номеру запросу. Все запросы будем сохранять. Пусть пришел запрос значения в позиции x, тогда найдем цвет в дереве в этой позиции. Если такого цвета нет, значит мы находимся в исходном массиве b (выведем b[x]), иначе посчитаем смещение dx от начала этого запроса до нашей позиции x и выведем a[x + dx].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 292\\s*A"
          },
          "content_length": 3238
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 1",
          "code": "it is decided that it will not be able to participate out the competition.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 2",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 3",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 4",
          "code": "printf(\"1 %d %d %d\\n\", 1, 1, n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 5",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 6",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 7",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 8",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 9",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 10",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 11",
          "code": "Still not..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000);\n    inf.readEoln();\n\n    int t_prev = 0;\n    for (int i = 1; i <= n; ++i) {\n        int ti = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000);\n        inf.readEoln();\n\n        ensuref(ti > t_prev, \"Time ti should be increasing: t[%d]=%d is not greater than t[%d]=%d\", i, ti, i - 1, t_prev);\n\n        t_prev = ti;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000);\n    inf.readEoln();\n\n    int t_prev = 0;\n    for (int i = 1; i <= n; ++i) {\n        int ti = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000);\n        inf.readEoln();\n\n        ensuref(ti > t_prev, \"Time ti should be increasing: t[%d]=%d is not greater than t[%d]=%d\", i, ti, i - 1, t_prev);\n\n        t_prev = ti;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000);\n    inf.readEoln();\n\n    int t_prev = 0;\n    for (int i = 1; i <= n; ++i) {\n        int ti = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000);\n        inf.readEoln();\n\n        ensuref(ti > t_prev, \"Time ti should be increasing: t[%d]=%d is not greater than t[%d]=%d\", i, ti, i - 1, t_prev);\n\n        t_prev = ti;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_c = opt<int>(\"max_c\", 1000000);\n    int gap_param = opt<int>(\"gap\", 1000);\n\n    vector<int> ti(n), ci(n);\n\n    if (type == \"uniform_c1\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            ci[i] = 1;\n        }\n    } else if (type == \"uniform_cm\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            ci[i] = max_c;\n        }\n    } else if (type == \"increasing_c\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            if (n == 1)\n                ci[i] = 1;\n            else\n                ci[i] = 1 + (max_c - 1) * i / (n - 1);\n        }\n    } else if (type == \"decreasing_c\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            if (n == 1)\n                ci[i] = max_c;\n            else\n                ci[i] = max_c - (max_c - 1) * i / (n - 1);\n        }\n    } else if (type == \"random_c\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            ci[i] = rnd.next(1, max_c);\n        }\n    } else if (type == \"burst\") {\n        ti[0] = 1;\n        ci[0] = max_c;\n        for (int i = 1; i < n; ++i) {\n            ti[i] = ti[i - 1] + rnd.next(0, 1);\n            if (ti[i] <= ti[i - 1]) ti[i] = ti[i - 1] + 1;\n            if (ti[i] > 1000000) ti[i] = 1000000;\n            ci[i] = max_c;\n        }\n    } else if (type == \"gap\") {\n        int gap = gap_param;\n        for (int i = 0; i < n; ++i) {\n            if (i == 0) ti[i] = 1;\n            else ti[i] = ti[i - 1] + gap;\n            ci[i] = rnd.next(1, max_c);\n        }\n        if (ti[n - 1] > 1000000) {\n            int total_gap = 1000000 - 1;\n            gap = total_gap / n;\n            ti[0] = 1;\n            for (int i = 1; i < n; ++i) {\n                ti[i] = ti[i - 1] + gap;\n            }\n        }\n    } else if (type == \"max_queue\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            ci[i] = max_c;\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            if (i == 0)\n                ti[i] = rnd.next(1, 10);\n            else\n                ti[i] = ti[i - 1] + rnd.next(1, 10);\n            ci[i] = rnd.next(1, max_c);\n        }\n        // Ensure ti doesn't exceed 1e6\n        if (ti[n - 1] > 1000000) {\n            int max_ti = 1000000;\n            int min_ti = ti[0];\n            int total_gap = max_ti - min_ti;\n            int avg_gap = total_gap / n;\n            ti[0] = min_ti;\n            for (int i = 1; i < n; ++i) {\n                ti[i] = ti[i - 1] + avg_gap;\n            }\n        }\n    }\n\n    // Ensure that ti and ci are within constraints\n    for (int i = 0; i < n; ++i) {\n        if (ti[i] < 1) ti[i] = 1;\n        if (ti[i] > 1000000) ti[i] = 1000000;\n        if (ci[i] < 1) ci[i] = 1;\n        if (ci[i] > 1000000) ci[i] = 1000000;\n        if (i > 0 && ti[i] <= ti[i - 1]) {\n            ti[i] = ti[i - 1] + 1;\n            if (ti[i] > 1000000) ti[i] = 1000000;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ti[i], ci[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_c = opt<int>(\"max_c\", 1000000);\n    int gap_param = opt<int>(\"gap\", 1000);\n\n    vector<int> ti(n), ci(n);\n\n    if (type == \"uniform_c1\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            ci[i] = 1;\n        }\n    } else if (type == \"uniform_cm\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            ci[i] = max_c;\n        }\n    } else if (type == \"increasing_c\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            if (n == 1)\n                ci[i] = 1;\n            else\n                ci[i] = 1 + (max_c - 1) * i / (n - 1);\n        }\n    } else if (type == \"decreasing_c\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            if (n == 1)\n                ci[i] = max_c;\n            else\n                ci[i] = max_c - (max_c - 1) * i / (n - 1);\n        }\n    } else if (type == \"random_c\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            ci[i] = rnd.next(1, max_c);\n        }\n    } else if (type == \"burst\") {\n        ti[0] = 1;\n        ci[0] = max_c;\n        for (int i = 1; i < n; ++i) {\n            ti[i] = ti[i - 1] + rnd.next(0, 1);\n            if (ti[i] <= ti[i - 1]) ti[i] = ti[i - 1] + 1;\n            if (ti[i] > 1000000) ti[i] = 1000000;\n            ci[i] = max_c;\n        }\n    } else if (type == \"gap\") {\n        int gap = gap_param;\n        for (int i = 0; i < n; ++i) {\n            if (i == 0) ti[i] = 1;\n            else ti[i] = ti[i - 1] + gap;\n            ci[i] = rnd.next(1, max_c);\n        }\n        if (ti[n - 1] > 1000000) {\n            int total_gap = 1000000 - 1;\n            gap = total_gap / n;\n            ti[0] = 1;\n            for (int i = 1; i < n; ++i) {\n                ti[i] = ti[i - 1] + gap;\n            }\n        }\n    } else if (type == \"max_queue\") {\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i + 1;\n            ci[i] = max_c;\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            if (i == 0)\n                ti[i] = rnd.next(1, 10);\n            else\n                ti[i] = ti[i - 1] + rnd.next(1, 10);\n            ci[i] = rnd.next(1, max_c);\n        }\n        // Ensure ti doesn't exceed 1e6\n        if (ti[n - 1] > 1000000) {\n            int max_ti = 1000000;\n            int min_ti = ti[0];\n            int total_gap = max_ti - min_ti;\n            int avg_gap = total_gap / n;\n            ti[0] = min_ti;\n            for (int i = 1; i < n; ++i) {\n                ti[i] = ti[i - 1] + avg_gap;\n            }\n        }\n    }\n\n    // Ensure that ti and ci are within constraints\n    for (int i = 0; i < n; ++i) {\n        if (ti[i] < 1) ti[i] = 1;\n        if (ti[i] > 1000000) ti[i] = 1000000;\n        if (ci[i] < 1) ci[i] = 1;\n        if (ci[i] > 1000000) ci[i] = 1000000;\n        if (i > 0 && ti[i] <= ti[i - 1]) {\n            ti[i] = ti[i - 1] + 1;\n            if (ti[i] > 1000000) ti[i] = 1000000;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ti[i], ci[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type uniform_c1\n./gen -n 1 -type uniform_cm\n./gen -n 10 -type uniform_c1\n./gen -n 10 -type uniform_cm\n./gen -n 100 -type increasing_c\n./gen -n 100 -type decreasing_c\n./gen -n 100 -type random_c\n./gen -n 1000 -type uniform_c1\n./gen -n 1000 -type uniform_cm\n./gen -n 1000 -type random_c\n./gen -n 1000 -type burst\n./gen -n 1000 -type gap\n./gen -n 1000 -type max_queue\n./gen -n 500 -type random_c\n./gen -n 100 -type random_c\n./gen -n 1000 -type increasing_c\n./gen -n 1000 -type decreasing_c\n./gen -n 500 -type burst\n./gen -n 1 -type gap\n./gen -n 1000 -type gap -gap 9999\n./gen -n 1000 -type random\n./gen -n 1000 -type random_c -max_c 1000\n./gen -n 1000 -type random_c -max_c 10\n./gen -n 1000 -type random_c -max_c 1\n./gen -n 1000 -type random_c -max_c 1000000\n./gen -n 10 -type uniform_c1\n./gen -n 10 -type uniform_cm\n./gen -n 10 -type increasing_c\n./gen -n 10 -type decreasing_c\n./gen -n 10 -type random_c\n./gen -n 10 -type burst\n./gen -n 10 -type gap\n./gen -n 10 -type max_queue\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:15.343155",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "292/B",
      "title": "B. Топология сети",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел заданы два целых числа n и m (4 ≤ n ≤ 105; 3 ≤ m ≤ 105) — количество вершин и ребер в графе соответственно. Далее в m строках задано описание ребер графа. В i-той строке через пробел задана пара целых чисел xi, yi (1 ≤ xi, yi ≤ n) — номера вершин, которые соединяет i-ое ребро.Гарантируется, что заданный граф является связным. Между любыми двумя вершинами существует не более одного ребра. Ни одно ребро не соединяет вершину саму с собой.",
      "output_spec": "Выходные данныеВ единственную строку выведите название топологии сети, к которой относится заданный граф. Если ответом является шина, выведите «bus topology» (без кавычек), если ответом является кольцо, выведите «ring topology» (без кавычек), если ответом является звезда, выведите «star topology» (без кавычек). Если ни один из этих типов не подходит, выведите «unknown topology» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать4 31 22 33 4Выходные данныеСкопироватьbus topologyВходные данныеСкопировать4 41 22 33 44 1Выходные данныеСкопироватьring topologyВходные данныеСкопировать4 31 21 31 4Выходные данныеСкопироватьstar topologyВходные данныеСкопировать4 41 22 33 11 4Выходные данныеСкопироватьunknown topology",
      "description": "B. Топология сети\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел заданы два целых числа n и m (4 ≤ n ≤ 105; 3 ≤ m ≤ 105) — количество вершин и ребер в графе соответственно. Далее в m строках задано описание ребер графа. В i-той строке через пробел задана пара целых чисел xi, yi (1 ≤ xi, yi ≤ n) — номера вершин, которые соединяет i-ое ребро.Гарантируется, что заданный граф является связным. Между любыми двумя вершинами существует не более одного ребра. Ни одно ребро не соединяет вершину саму с собой.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите название топологии сети, к которой относится заданный граф. Если ответом является шина, выведите «bus topology» (без кавычек), если ответом является кольцо, выведите «ring topology» (без кавычек), если ответом является звезда, выведите «star topology» (без кавычек). Если ни один из этих типов не подходит, выведите «unknown topology» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать4 31 22 33 4Выходные данныеСкопироватьbus topologyВходные данныеСкопировать4 41 22 33 44 1Выходные данныеСкопироватьring topologyВходные данныеСкопировать4 31 21 31 4Выходные данныеСкопироватьstar topologyВходные данныеСкопировать4 41 22 33 11 4Выходные данныеСкопироватьunknown topology\n\nВходные данныеСкопировать4 31 22 33 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьbus topology\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 22 33 44 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьring topology\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 31 21 31 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьstar topology\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 22 33 11 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьunknown topology\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces",
          "content": "Доброго времени суток)Совсем скоро стартует Раунд 1 Всероссийского Открытого Чемпионата по программированию \"КРОК-2013\". Из в Раунда 1 в следующий Раунд 2 проходят участники, набравшие не меньше баллов, чем участник на 400-ом месте (при условии положительного числа набранных баллов).Раунд будет проходить по обычным правилам Codeforces (со взломами и падением стоимостей задач). Во время раунда задачи тестируются системой только на претестах, а системное тестирование состоится после окончания соревнования. Претесты не покрывают все возможные случаи входных данных, поэтому тщательно тестируйте свои программы.До окончания раунда категорически запрещается публиковать где-либо условия задач/решения/какие-либо мысли и соображения о них. Запрещено общаться на тему задач, обсуждать условия, решения и прочее.Задачи для вас подготовила команда авторов в составе: Павел Холкин (HolkinPV), Геральд Агапов (Gerald) и Михаил Мирзаянов (MikeMirzayanov). Отмечу, что команда в этом же составе провела для вас квалификационный раунд и отвечала на вопросы в течении всего соревнования. Традиционно благодарим Марию Белову (Delinur), которая перевела для вас условия задач.UPD1: Задачи будут расположены в порядке возрастания предполагаемой сложности. Распределение баллов было решено сделать немного нестандартным: 1000, 1000, 1500, 2000, 2500.UPD2: в связи с большим количеством участников было решено, что в соревновании нельзя будет участвовать вне конкурса. Для официальных участников соревнование будет рейтинговым.Всем участникам желаем удачи и успешного прохождения в следующий раунд соревнования.",
          "author": "HolkinPV",
          "url": "https://codeforces.com/blog/entry/7361",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1597
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 (Разбор задач) - Codeforces",
          "content": "292A - SMSCДля каждого момента i времени запомним количество сообщений z[i], которое нужно отправить в момент времени i. Теперь пройдем по каждому моменту времени от 1 до 106, поддерживая текущий размер очереди sz. На каждой итерации попробуем уменьшить размер очереди на 1, то есть выполним sz = max(sz - 1, 0), затем прибавим сообщения, которые нужно отправить в эту секунду, то есть выполним sz = sz + z[i]. На каждом шаге будем обновлять максимальное значение очереди и текущее время, если sz > 0. После выполнения цикла, если в очереди остались неотправленные сообщения, то нужно еще раз обновить ответ.292B - Network TopologyВ этой задаче нужно было посчитать степени каждой вершины и найти ответ. Замечу, поскольку n >  = 4, m >  = 3 и граф связный, то ответ однозначный.1) все степени 2 и у двух вершин степень 1 — шина.2) все степени 2 — кольцо3) все степени 1 и у одной степень  > 2 — звезда4) иначе неизвестно292C - Beautiful IP AddressesЗадача решается перебором. Для начала переберем сколько цифр в каждом четверти мы возьмем, например AAA.B.CC.DDD. Теперь посчитаем количество символов в этой строке (AAABCCDDD) и переберем цифры на первой половине этой строки (поскольку строка должна быть палиндромом, то вторая половина однозначно восстанавливается). После этого проверим, что такой ip-адрес является корректным и содержит правильный набор цифр. Если ip-адрес удовлетворяет всем условиям задачи, то добавим его к ответу.292D - Connected ComponentsОграничения в задаче были не слишком удачными и провоцировали писать решение за квадрат, мы постарались максимально не позволить таким решениям пройти.У этой задачи много правильных решений. Изначально планировалось решение, которое предподсчитывает частичные dsu (структура данных disjoint set union) на префиксах и на суффиксах, то есть массивы ldsu[M][N] и rdsu[M][N]. После этого на запрос [lf ; rg] легко ответить за время O(N·A - 1), если объединить множества ldsu[lf - 1] и rdsu[rg + 1], где A - 1 -- обратная функция Аккермана (константа от dsu).292E - Copying DataУ этой задачи много правильных решений. Изначально предполагалось решение, использующие корневую эвристику. Разобьем все запросы на sqrt(m) блоков. Будем поддерживать текущий массив b в виде отрезков в массиве z, который хранит четверки (lf, rg, type, start), где lf, rg — отрезок индексов массива b, type — 0 или 1, означающее из какого массива взяты числа для этого отрезка, start — позиция начала этого отрезка в массиве типа type. На запросы будем отвечать в тупую, то есть честно пересчитывать как изменится массив z от запроса копирования и отвечать на запросы значения в позициях. Однако, каждые sqrt(m) запросов будем сливать данные из массива z в массив b, для того чтобы сам массив z сильно не разрастался.Есть простое решение с деревом отрезков, которое умеет делать покраску на отрезке. Пусть пришел запрос копирования [lf ; rg], , тогда покрасим отрезок запроса [lf ; rg] в цвет, равный номеру запросу. Все запросы будем сохранять. Пусть пришел запрос значения в позиции x, тогда найдем цвет в дереве в этой позиции. Если такого цвета нет, значит мы находимся в исходном массиве b (выведем b[x]), иначе посчитаем смещение dx от начала этого запроса до нашей позиции x и выведем a[x + dx].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 292\\s*B"
          },
          "content_length": 3238
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 1",
          "code": "it is decided that it will not be able to participate out the competition.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 2",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 3",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 4",
          "code": "printf(\"1 %d %d %d\\n\", 1, 1, n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 5",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 6",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 7",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 8",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 9",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 10",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 11",
          "code": "int getParent(int x)\n{\n        if(parent[x] != parent[parent[x]])\n                parent[x] = getParent(parent[x]);\n        return parent[x];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 12",
          "code": "int getParent(int x)\n{\n        if(parent[x] != parent[parent[x]])\n                parent[x] = getParent(parent[x]);\n        return parent[x];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 13",
          "code": "if (r[x] == r[y]) {\n\tp[y] = x;\n\tr[x]++;\n} else if (r[x] < r[y]) {\n\tp[x] = y;\n} else {\n\tp[y] = x;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 14",
          "code": "if (r[x] == r[y]) {\n\tp[y] = x;\n\tr[x]++;\n} else if (r[x] < r[y]) {\n\tp[x] = y;\n} else {\n\tp[y] = x;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 15",
          "code": "Still not..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 16",
          "code": "if ((c[now][o]>r || c[now][o]<l) && !fix[g[now][o]])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 17",
          "code": "if (!fix[g[now][o]] && (c[now][o]>r || c[now][o]<l))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(n <= 100000, \"n must be less than or equal to 100000\");\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d connects node to itself (%d)\", i + 1, xi);\n\n        int a = xi, b = yi;\n        if (a > b) swap(a, b);\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between node %d and %d\", a, b);\n        edges.insert(edge);\n\n        int x_root = find(a);\n        int y_root = find(b);\n        if (x_root != y_root) {\n            parent[x_root] = y_root;\n        }\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(n <= 100000, \"n must be less than or equal to 100000\");\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d connects node to itself (%d)\", i + 1, xi);\n\n        int a = xi, b = yi;\n        if (a > b) swap(a, b);\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between node %d and %d\", a, b);\n        edges.insert(edge);\n\n        int x_root = find(a);\n        int y_root = find(b);\n        if (x_root != y_root) {\n            parent[x_root] = y_root;\n        }\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(n <= 100000, \"n must be less than or equal to 100000\");\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d connects node to itself (%d)\", i + 1, xi);\n\n        int a = xi, b = yi;\n        if (a > b) swap(a, b);\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between node %d and %d\", a, b);\n        edges.insert(edge);\n\n        int x_root = find(a);\n        int y_root = find(b);\n        if (x_root != y_root) {\n            parent[x_root] = y_root;\n        }\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    ensure(n >= 4);\n    ensure(n <= 100000);\n\n    vector<pair<int,int>> edges;\n    if (type == \"bus\") {\n        // Bus topology: path\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 0; i < n - 1; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"ring\") {\n        // Ring topology: cycle\n        if (m == -1) m = n;\n        ensure(m == n);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 0; i < n; ++i) {\n            edges.push_back({i, (i + 1) % n});\n        }\n    } else if (type == \"star\") {\n        // Star topology\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n    } else if (type == \"near_bus\") {\n        // Bus topology with an extra edge\n        if (m == -1) m = n;\n        ensure(m == n);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 0; i < n - 1; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Add an extra edge between two non-adjacent nodes\n        int u = rnd.next(0, n - 1);\n        int v = rnd.next(0, n - 1);\n        while (abs(u - v) <= 1 || u == v) { // ensure not adjacent in the path\n            u = rnd.next(0, n - 1);\n            v = rnd.next(0, n - 1);\n        }\n        edges.push_back({u, v});\n    } else if (type == \"near_ring\") {\n        // Ring topology with an extra edge\n        if (m == -1) m = n + 1;\n        ensure(m == n + 1);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 0; i < n; ++i) {\n            edges.push_back({i, (i + 1) % n});\n        }\n        // Add an extra edge between two non-adjacent nodes\n        int u = rnd.next(0, n - 1);\n        int v = rnd.next(0, n - 1);\n        while (abs(u - v) <= 1 || abs(u - v) == n - 1 || u == v) { // ensure not adjacent in the ring\n            u = rnd.next(0, n - 1);\n            v = rnd.next(0, n - 1);\n        }\n        edges.push_back({u, v});\n    } else if (type == \"near_star\") {\n        // Star topology with an extra edge\n        if (m == -1) m = n;\n        ensure(m == n);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n        // Add an extra edge between two leaves\n        int u = rnd.next(1, n - 1);\n        int v = rnd.next(1, n - 1);\n        while (u == v) {\n            v = rnd.next(1, n - 1);\n        }\n        edges.push_back({u, v});\n    } else if (type == \"unknown\") {\n        // Generate connected graph that is not bus, ring, or star\n        if (m == -1) m = min(100000, n + rnd.next(0, n * 2));\n        ensure(m >= n - 1 && m <= 100000);\n        ensure(m >= 3);\n\n        // First, generate a random tree\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = rnd.next(0, i - 1);\n            edges.push_back({u, v});\n        }\n        int current_m = n - 1;\n\n        // Now add extra edges to reach m\n        set<pair<int,int>> edge_set;\n        for (auto &e : edges) {\n            if (e.first > e.second) swap(e.first, e.second);\n            edge_set.insert(e);\n        }\n        while (current_m < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            edges.push_back({u, v});\n            current_m++;\n        }\n    } else {\n        // Default: generate random connected graph with n nodes and m edges\n        if (m == -1) m = rnd.next(n - 1, min(100000, n*(n-1)/2));\n        ensure(m >= n - 1 && m <= 100000);\n        ensure(m >= 3);\n\n        // Generate random tree\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = rnd.next(0, i - 1);\n            edges.push_back({u, v});\n        }\n        int current_m = n - 1;\n\n        // Now add extra edges to reach m\n        set<pair<int,int>> edge_set;\n        for (auto &e : edges) {\n            if (e.first > e.second) swap(e.first, e.second);\n            edge_set.insert(e);\n        }\n        while (current_m < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            edges.push_back({u, v});\n            current_m++;\n        }\n    }\n\n    // Now we have edges with nodes from 0 to n-1\n    // Let's create a random permutation of node labels\n    vector<int> node_labels(n);\n    for (int i = 0; i < n; ++i)\n        node_labels[i] = i + 1;\n\n    shuffle(node_labels.begin(), node_labels.end());\n\n    // Now relabel the nodes in edges\n    for (auto &e : edges) {\n        e.first = node_labels[e.first];\n        e.second = node_labels[e.second];\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto &e : edges) {\n        // Output edges with nodes swapped randomly\n        if (rnd.next(0, 1))\n            printf(\"%d %d\\n\", e.first, e.second);\n        else\n            printf(\"%d %d\\n\", e.second, e.first);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    ensure(n >= 4);\n    ensure(n <= 100000);\n\n    vector<pair<int,int>> edges;\n    if (type == \"bus\") {\n        // Bus topology: path\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 0; i < n - 1; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"ring\") {\n        // Ring topology: cycle\n        if (m == -1) m = n;\n        ensure(m == n);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 0; i < n; ++i) {\n            edges.push_back({i, (i + 1) % n});\n        }\n    } else if (type == \"star\") {\n        // Star topology\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n    } else if (type == \"near_bus\") {\n        // Bus topology with an extra edge\n        if (m == -1) m = n;\n        ensure(m == n);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 0; i < n - 1; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Add an extra edge between two non-adjacent nodes\n        int u = rnd.next(0, n - 1);\n        int v = rnd.next(0, n - 1);\n        while (abs(u - v) <= 1 || u == v) { // ensure not adjacent in the path\n            u = rnd.next(0, n - 1);\n            v = rnd.next(0, n - 1);\n        }\n        edges.push_back({u, v});\n    } else if (type == \"near_ring\") {\n        // Ring topology with an extra edge\n        if (m == -1) m = n + 1;\n        ensure(m == n + 1);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 0; i < n; ++i) {\n            edges.push_back({i, (i + 1) % n});\n        }\n        // Add an extra edge between two non-adjacent nodes\n        int u = rnd.next(0, n - 1);\n        int v = rnd.next(0, n - 1);\n        while (abs(u - v) <= 1 || abs(u - v) == n - 1 || u == v) { // ensure not adjacent in the ring\n            u = rnd.next(0, n - 1);\n            v = rnd.next(0, n - 1);\n        }\n        edges.push_back({u, v});\n    } else if (type == \"near_star\") {\n        // Star topology with an extra edge\n        if (m == -1) m = n;\n        ensure(m == n);\n        ensure(m >= 3 && m <= 100000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n        // Add an extra edge between two leaves\n        int u = rnd.next(1, n - 1);\n        int v = rnd.next(1, n - 1);\n        while (u == v) {\n            v = rnd.next(1, n - 1);\n        }\n        edges.push_back({u, v});\n    } else if (type == \"unknown\") {\n        // Generate connected graph that is not bus, ring, or star\n        if (m == -1) m = min(100000, n + rnd.next(0, n * 2));\n        ensure(m >= n - 1 && m <= 100000);\n        ensure(m >= 3);\n\n        // First, generate a random tree\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = rnd.next(0, i - 1);\n            edges.push_back({u, v});\n        }\n        int current_m = n - 1;\n\n        // Now add extra edges to reach m\n        set<pair<int,int>> edge_set;\n        for (auto &e : edges) {\n            if (e.first > e.second) swap(e.first, e.second);\n            edge_set.insert(e);\n        }\n        while (current_m < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            edges.push_back({u, v});\n            current_m++;\n        }\n    } else {\n        // Default: generate random connected graph with n nodes and m edges\n        if (m == -1) m = rnd.next(n - 1, min(100000, n*(n-1)/2));\n        ensure(m >= n - 1 && m <= 100000);\n        ensure(m >= 3);\n\n        // Generate random tree\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = rnd.next(0, i - 1);\n            edges.push_back({u, v});\n        }\n        int current_m = n - 1;\n\n        // Now add extra edges to reach m\n        set<pair<int,int>> edge_set;\n        for (auto &e : edges) {\n            if (e.first > e.second) swap(e.first, e.second);\n            edge_set.insert(e);\n        }\n        while (current_m < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            edges.push_back({u, v});\n            current_m++;\n        }\n    }\n\n    // Now we have edges with nodes from 0 to n-1\n    // Let's create a random permutation of node labels\n    vector<int> node_labels(n);\n    for (int i = 0; i < n; ++i)\n        node_labels[i] = i + 1;\n\n    shuffle(node_labels.begin(), node_labels.end());\n\n    // Now relabel the nodes in edges\n    for (auto &e : edges) {\n        e.first = node_labels[e.first];\n        e.second = node_labels[e.second];\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto &e : edges) {\n        // Output edges with nodes swapped randomly\n        if (rnd.next(0, 1))\n            printf(\"%d %d\\n\", e.first, e.second);\n        else\n            printf(\"%d %d\\n\", e.second, e.first);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type bus\n./gen -n 4 -type ring\n./gen -n 4 -type star\n./gen -n 4 -type near_bus\n./gen -n 4 -type near_ring\n./gen -n 4 -type near_star\n./gen -n 4 -type unknown\n\n./gen -n 10 -type bus\n./gen -n 10 -type ring\n./gen -n 10 -type star\n./gen -n 10 -type near_bus\n./gen -n 10 -type near_ring\n./gen -n 10 -type near_star\n./gen -n 10 -type unknown\n\n./gen -n 100 -type bus\n./gen -n 100 -type ring\n./gen -n 100 -type star\n./gen -n 100 -type near_bus\n./gen -n 100 -type near_ring\n./gen -n 100 -type near_star\n./gen -n 100 -type unknown\n\n./gen -n 1000 -type bus\n./gen -n 1000 -type ring\n./gen -n 1000 -type star\n./gen -n 1000 -type near_bus\n./gen -n 1000 -type near_ring\n./gen -n 1000 -type near_star\n./gen -n 1000 -type unknown\n\n./gen -n 100000 -type bus\n./gen -n 100000 -type ring\n./gen -n 100000 -type star\n./gen -n 100000 -type near_bus\n./gen -n 100000 -type near_ring\n./gen -n 100000 -type near_star\n./gen -n 100000 -type unknown\n\n./gen -n 50000 -type random -m 100000\n./gen -n 70000 -type unknown -m 100000\n./gen -n 4 -type random\n./gen -n 4 -type unknown\n\n./gen -n 99999 -type bus\n./gen -n 99999 -type near_bus\n./gen -n 99999 -type ring\n./gen -n 99999 -type near_ring\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:17.019456",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "292/C",
      "title": "C. Beautiful IP Addresses",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 10) — the number of digits in the set. The second line contains the set of integers a1, a2, ..., an (0 ≤ ai ≤ 9). It is guaranteed that all digits in the set are distinct.",
      "output_spec": "OutputIn the first line print a single integer k — the number of beautiful IP addresses that contain the given set of digits. In the following k lines print the IP addresses, one per line in the arbitrary order.",
      "sample_tests": "ExamplesInputCopy60 1 2 9 8 7OutputCopy678.190.209.18779.180.208.19787.190.209.17889.170.207.19897.180.208.17998.170.207.189InputCopy14OutputCopy164.4.4.44.4.4.444.4.44.44.4.44.444.44.4.44.44.4.444.44.44.44.44.44.4444.4.4.444.4.4.4444.4.44.444.4.44.4444.44.4.444.44.4.4444.44.44.444.44.44.44",
      "description": "C. Beautiful IP Addresses\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 10) — the number of digits in the set. The second line contains the set of integers a1, a2, ..., an (0 ≤ ai ≤ 9). It is guaranteed that all digits in the set are distinct.\n\nOutputIn the first line print a single integer k — the number of beautiful IP addresses that contain the given set of digits. In the following k lines print the IP addresses, one per line in the arbitrary order.\n\nInputCopy60 1 2 9 8 7OutputCopy678.190.209.18779.180.208.19787.190.209.17889.170.207.19897.180.208.17998.170.207.189InputCopy14OutputCopy164.4.4.44.4.4.444.4.44.44.4.44.444.44.4.44.44.4.444.44.44.44.44.44.4444.4.4.444.4.4.4444.4.44.444.4.44.4444.44.4.444.44.4.4444.44.44.444.44.44.44\n\nInputCopy60 1 2 9 8 7\n\nOutputCopy678.190.209.18779.180.208.19787.190.209.17889.170.207.19897.180.208.17998.170.207.189\n\nInputCopy14\n\nOutputCopy164.4.4.44.4.4.444.4.44.44.4.44.444.44.4.44.44.4.444.44.44.44.44.44.4444.4.4.444.4.4.4444.4.44.444.4.44.4444.44.4.444.44.4.4444.44.44.444.44.44.44",
      "solutions": [
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces",
          "content": "Good day)Soon is coming Round 1 of the All-Russian Programming Championship CROC-2013. Contestants who gain a score equal to the 400-th place finisher score or greater will advance to the Round 2 (also you need to gain positive score).Round will be held by usual Codeforces rules (with hacks and decreasing values of the problems). During the round the problems are judged only on pretests and system testing will take place after the end of the contest. The pretests do not cover all possible cases of input data, test your programs carefully.Before the end of the round it is strictly forbidden to publish the problem statements/solutions/any thoughts and ideas about them elsewhere. It is forbidden to talk about the problems, discuss the statements, solutions and so on.The problems were prepared by the group of authors: Pavel Kholkin (HolkinPV), Gerald Agapov (Gerald) and Michael Mirzayanov (MikeMirzayanov). I will add that our team have already prepared for you qualification round and answered the questions during the whole competition. Traditionally thanks to Mary Belova (Delinur) for translating the problems.UPD1: The problems are sorted by increasing of estimated difficulty. The score dustribution is decided to be not standard a little bit : 1000, 1000, 1500, 2000, 2500.UPD2: due to the large number of participants, it is decided that it will not be able to participate out the competition. For official contest participants the round will be rated.We wish all the participants good luck and successful advance to the next round of competition.",
          "author": "HolkinPV",
          "url": "https://codeforces.com/blog/entry/7361",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1564
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 (Разбор задач) - Codeforces",
          "content": "292A - SMSCДля каждого момента i времени запомним количество сообщений z[i], которое нужно отправить в момент времени i. Теперь пройдем по каждому моменту времени от 1 до 106, поддерживая текущий размер очереди sz. На каждой итерации попробуем уменьшить размер очереди на 1, то есть выполним sz = max(sz - 1, 0), затем прибавим сообщения, которые нужно отправить в эту секунду, то есть выполним sz = sz + z[i]. На каждом шаге будем обновлять максимальное значение очереди и текущее время, если sz > 0. После выполнения цикла, если в очереди остались неотправленные сообщения, то нужно еще раз обновить ответ.292B - Network TopologyВ этой задаче нужно было посчитать степени каждой вершины и найти ответ. Замечу, поскольку n >  = 4, m >  = 3 и граф связный, то ответ однозначный.1) все степени 2 и у двух вершин степень 1 — шина.2) все степени 2 — кольцо3) все степени 1 и у одной степень  > 2 — звезда4) иначе неизвестно292C - Beautiful IP AddressesЗадача решается перебором. Для начала переберем сколько цифр в каждом четверти мы возьмем, например AAA.B.CC.DDD. Теперь посчитаем количество символов в этой строке (AAABCCDDD) и переберем цифры на первой половине этой строки (поскольку строка должна быть палиндромом, то вторая половина однозначно восстанавливается). После этого проверим, что такой ip-адрес является корректным и содержит правильный набор цифр. Если ip-адрес удовлетворяет всем условиям задачи, то добавим его к ответу.292D - Connected ComponentsОграничения в задаче были не слишком удачными и провоцировали писать решение за квадрат, мы постарались максимально не позволить таким решениям пройти.У этой задачи много правильных решений. Изначально планировалось решение, которое предподсчитывает частичные dsu (структура данных disjoint set union) на префиксах и на суффиксах, то есть массивы ldsu[M][N] и rdsu[M][N]. После этого на запрос [lf ; rg] легко ответить за время O(N·A - 1), если объединить множества ldsu[lf - 1] и rdsu[rg + 1], где A - 1 -- обратная функция Аккермана (константа от dsu).292E - Copying DataУ этой задачи много правильных решений. Изначально предполагалось решение, использующие корневую эвристику. Разобьем все запросы на sqrt(m) блоков. Будем поддерживать текущий массив b в виде отрезков в массиве z, который хранит четверки (lf, rg, type, start), где lf, rg — отрезок индексов массива b, type — 0 или 1, означающее из какого массива взяты числа для этого отрезка, start — позиция начала этого отрезка в массиве типа type. На запросы будем отвечать в тупую, то есть честно пересчитывать как изменится массив z от запроса копирования и отвечать на запросы значения в позициях. Однако, каждые sqrt(m) запросов будем сливать данные из массива z в массив b, для того чтобы сам массив z сильно не разрастался.Есть простое решение с деревом отрезков, которое умеет делать покраску на отрезке. Пусть пришел запрос копирования [lf ; rg], , тогда покрасим отрезок запроса [lf ; rg] в цвет, равный номеру запросу. Все запросы будем сохранять. Пусть пришел запрос значения в позиции x, тогда найдем цвет в дереве в этой позиции. Если такого цвета нет, значит мы находимся в исходном массиве b (выведем b[x]), иначе посчитаем смещение dx от начала этого запроса до нашей позиции x и выведем a[x + dx].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 292\\s*C"
          },
          "content_length": 3238
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 1",
          "code": "it is decided that it will not be able to participate out the competition.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 2",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 3",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 4",
          "code": "printf(\"1 %d %d %d\\n\", 1, 1, n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 5",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 6",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 7",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 8",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 9",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 10",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 11",
          "code": "Still not..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,10,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0,9,\"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All digits a_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,10,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0,9,\"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All digits a_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,10,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0,9,\"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All digits a_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nset<char> digits;\n\n// This function reads and validates the list of IP addresses from the given stream.\n// It checks that each IP address is correctly formatted, satisfies all the problem's conditions,\n// and returns the set of IP addresses. If any validation fails, it reports an error.\nset<string> readAns(InStream& stream) {\n    int k = stream.readInt(0, 1000000, \"number of IP addresses\");\n    set<string> ips;\n    for (int i = 0; i < k; ++i) {\n        string ip = stream.readToken();\n        // Validate the IP address\n        stringstream ss(ip);\n        string segment;\n        vector<string> segments;\n        while (getline(ss, segment, '.')) {\n            segments.push_back(segment);\n        }\n        if (segments.size() != 4) {\n            stream.quitf(_wa, \"IP address '%s' does not consist of 4 segments\", ip.c_str());\n        }\n        string concatenated;\n        set<char> used_digits;\n        for (int j = 0; j < 4; ++j) {\n            string num_str = segments[j];\n            // Check for leading zeros\n            if (num_str.size() > 1 && num_str[0] == '0') {\n                stream.quitf(_wa, \"Segment '%s' in IP address '%s' has leading zeros\", num_str.c_str(), ip.c_str());\n            }\n            // Check that the segment consists only of digits\n            if (!all_of(num_str.begin(), num_str.end(), ::isdigit)) {\n                stream.quitf(_wa, \"Segment '%s' in IP address '%s' contains non-digit characters\", num_str.c_str(), ip.c_str());\n            }\n            // Check that the segment is within the valid range\n            int num = atoi(num_str.c_str());\n            if (num < 0 || num > 255) {\n                stream.quitf(_wa, \"Segment '%s' in IP address '%s' is out of range [0, 255]\", num_str.c_str(), ip.c_str());\n            }\n            // Check that the digits are from the given set\n            for (char c : num_str) {\n                if (digits.count(c) == 0) {\n                    stream.quitf(_wa, \"Digit '%c' in IP address '%s' is not in the given set\", c, ip.c_str());\n                }\n                used_digits.insert(c);\n            }\n            concatenated += num_str;\n        }\n        // Check that each digit from the set occurs at least once\n        for (char d : digits) {\n            if (used_digits.count(d) == 0) {\n                stream.quitf(_wa, \"Digit '%c' does not occur in IP address '%s'\", d, ip.c_str());\n            }\n        }\n        // Check that the concatenated string is a palindrome\n        string rev_concatenated = concatenated;\n        reverse(rev_concatenated.begin(), rev_concatenated.end());\n        if (concatenated != rev_concatenated) {\n            stream.quitf(_wa, \"Concatenated string '%s' of IP address '%s' is not a palindrome\", concatenated.c_str(), ip.c_str());\n        }\n        // Add the IP address to the set\n        ips.insert(ip);\n    }\n    return ips;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and the set of digits\n    n = inf.readInt(1, 10, \"n\");\n    digits.clear();\n    for (int i = 0; i < n; ++i) {\n        int d = inf.readInt(0, 9, \"digit\");\n        if (digits.count('0' + d)) {\n            quitf(_fail, \"Duplicate digits in input\");\n        }\n        digits.insert('0' + d);\n    }\n\n    // Read the judge's answer\n    set<string> jury_ips = readAns(ans);\n    // Read the contestant's answer\n    set<string> cont_ips = readAns(ouf);\n\n    // Compare the sets of IP addresses\n    if (jury_ips != cont_ips)\n        quitf(_wa, \"The list of IP addresses does not match the expected list\");\n\n    quitf(_ok, \"Accepted\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 5);\n    string type = opt<string>(\"type\", \"random\");\n\n    set<int> digits;\n    if (type == \"min_n\") {\n        n = 1;\n        digits.insert(rnd.next(0, 9));\n    } else if (type == \"max_n\") {\n        n = 10;\n        for (int i = 0; i <= 9; ++i)\n            digits.insert(i);\n    } else if (type == \"include_zero\") {\n        digits.insert(0);\n        while ((int)digits.size() < n)\n            digits.insert(rnd.next(1,9));\n    } else if (type == \"exclude_zero\") {\n        while ((int)digits.size() < n)\n            digits.insert(rnd.next(1,9));\n    } else if (type == \"only_zero\") {\n        n = 1;\n        digits.insert(0);\n    } else if (type == \"only_one_digit\") {\n        n = 1;\n        digits.insert(rnd.next(0,9));\n    } else if (type == \"consecutive_digits\") {\n        int start = rnd.next(0, 10 - n);\n        for (int i = start; i < start + n; ++i)\n            digits.insert(i);\n    } else {\n        while ((int)digits.size() < n)\n            digits.insert(rnd.next(0, 9));\n    }\n    vector<int> d(digits.begin(), digits.end());\n    shuffle(d.begin(), d.end());\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", d[i], \" \\n\"[i == n - 1]);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 5);\n    string type = opt<string>(\"type\", \"random\");\n\n    set<int> digits;\n    if (type == \"min_n\") {\n        n = 1;\n        digits.insert(rnd.next(0, 9));\n    } else if (type == \"max_n\") {\n        n = 10;\n        for (int i = 0; i <= 9; ++i)\n            digits.insert(i);\n    } else if (type == \"include_zero\") {\n        digits.insert(0);\n        while ((int)digits.size() < n)\n            digits.insert(rnd.next(1,9));\n    } else if (type == \"exclude_zero\") {\n        while ((int)digits.size() < n)\n            digits.insert(rnd.next(1,9));\n    } else if (type == \"only_zero\") {\n        n = 1;\n        digits.insert(0);\n    } else if (type == \"only_one_digit\") {\n        n = 1;\n        digits.insert(rnd.next(0,9));\n    } else if (type == \"consecutive_digits\") {\n        int start = rnd.next(0, 10 - n);\n        for (int i = start; i < start + n; ++i)\n            digits.insert(i);\n    } else {\n        while ((int)digits.size() < n)\n            digits.insert(rnd.next(0, 9));\n    }\n    vector<int> d(digits.begin(), digits.end());\n    shuffle(d.begin(), d.end());\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", d[i], \" \\n\"[i == n - 1]);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_n\n./gen -n 10 -type max_n\n./gen -n 5 -type include_zero\n./gen -n 5 -type exclude_zero\n./gen -n 5 -type random\n./gen -n 5 -type random\n./gen -n 5 -type random\n./gen -n 1 -type only_zero\n./gen -n 1 -type only_one_digit\n./gen -n 2 -type consecutive_digits\n./gen -n 5 -type consecutive_digits\n./gen -n 3 -type include_zero\n./gen -n 3 -type exclude_zero\n./gen -n 6 -type random\n./gen -n 7 -type random\n./gen -n 8 -type random\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 9 -type random\n./gen -n 10 -type random\n./gen -n 9 -type exclude_zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:19.397332",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "292/D",
      "title": "D. Connected Components",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, m (2 ≤ n ≤ 500; 1 ≤ m ≤ 104) — the number of computers and the number of cables, correspondingly.The following m lines contain the cables' description. The i-th line contains space-separated pair of integers xi, yi (1 ≤ xi, yi ≤ n; xi ≠ yi) — the numbers of the computers that are connected by the i-th cable. Note that a pair of computers can be connected by multiple cables.The next line contains integer k (1 ≤ k ≤ 2·104) — the number of experiments. Next k lines contain the experiments' descriptions. The i-th line contains space-separated integers li, ri (1 ≤ li ≤ ri ≤ m) — the numbers of the cables that Polycarpus disconnects during the i-th experiment.",
      "output_spec": "OutputPrint k numbers, the i-th number represents the number of connected components of the graph that defines the computer network during the i-th experiment.",
      "sample_tests": "ExamplesInputCopy6 51 25 42 33 13 661 32 51 55 52 43 3OutputCopy456342",
      "description": "D. Connected Components\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, m (2 ≤ n ≤ 500; 1 ≤ m ≤ 104) — the number of computers and the number of cables, correspondingly.The following m lines contain the cables' description. The i-th line contains space-separated pair of integers xi, yi (1 ≤ xi, yi ≤ n; xi ≠ yi) — the numbers of the computers that are connected by the i-th cable. Note that a pair of computers can be connected by multiple cables.The next line contains integer k (1 ≤ k ≤ 2·104) — the number of experiments. Next k lines contain the experiments' descriptions. The i-th line contains space-separated integers li, ri (1 ≤ li ≤ ri ≤ m) — the numbers of the cables that Polycarpus disconnects during the i-th experiment.\n\nOutputPrint k numbers, the i-th number represents the number of connected components of the graph that defines the computer network during the i-th experiment.\n\nInputCopy6 51 25 42 33 13 661 32 51 55 52 43 3OutputCopy456342\n\nInputCopy6 51 25 42 33 13 661 32 51 55 52 43 3\n\nOutputCopy456342",
      "solutions": [
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces",
          "content": "Good day)Soon is coming Round 1 of the All-Russian Programming Championship CROC-2013. Contestants who gain a score equal to the 400-th place finisher score or greater will advance to the Round 2 (also you need to gain positive score).Round will be held by usual Codeforces rules (with hacks and decreasing values of the problems). During the round the problems are judged only on pretests and system testing will take place after the end of the contest. The pretests do not cover all possible cases of input data, test your programs carefully.Before the end of the round it is strictly forbidden to publish the problem statements/solutions/any thoughts and ideas about them elsewhere. It is forbidden to talk about the problems, discuss the statements, solutions and so on.The problems were prepared by the group of authors: Pavel Kholkin (HolkinPV), Gerald Agapov (Gerald) and Michael Mirzayanov (MikeMirzayanov). I will add that our team have already prepared for you qualification round and answered the questions during the whole competition. Traditionally thanks to Mary Belova (Delinur) for translating the problems.UPD1: The problems are sorted by increasing of estimated difficulty. The score dustribution is decided to be not standard a little bit : 1000, 1000, 1500, 2000, 2500.UPD2: due to the large number of participants, it is decided that it will not be able to participate out the competition. For official contest participants the round will be rated.We wish all the participants good luck and successful advance to the next round of competition.",
          "author": "HolkinPV",
          "url": "https://codeforces.com/blog/entry/7361",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1564
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 (Разбор задач) - Codeforces",
          "content": "292A - SMSCДля каждого момента i времени запомним количество сообщений z[i], которое нужно отправить в момент времени i. Теперь пройдем по каждому моменту времени от 1 до 106, поддерживая текущий размер очереди sz. На каждой итерации попробуем уменьшить размер очереди на 1, то есть выполним sz = max(sz - 1, 0), затем прибавим сообщения, которые нужно отправить в эту секунду, то есть выполним sz = sz + z[i]. На каждом шаге будем обновлять максимальное значение очереди и текущее время, если sz > 0. После выполнения цикла, если в очереди остались неотправленные сообщения, то нужно еще раз обновить ответ.292B - Network TopologyВ этой задаче нужно было посчитать степени каждой вершины и найти ответ. Замечу, поскольку n >  = 4, m >  = 3 и граф связный, то ответ однозначный.1) все степени 2 и у двух вершин степень 1 — шина.2) все степени 2 — кольцо3) все степени 1 и у одной степень  > 2 — звезда4) иначе неизвестно292C - Beautiful IP AddressesЗадача решается перебором. Для начала переберем сколько цифр в каждом четверти мы возьмем, например AAA.B.CC.DDD. Теперь посчитаем количество символов в этой строке (AAABCCDDD) и переберем цифры на первой половине этой строки (поскольку строка должна быть палиндромом, то вторая половина однозначно восстанавливается). После этого проверим, что такой ip-адрес является корректным и содержит правильный набор цифр. Если ip-адрес удовлетворяет всем условиям задачи, то добавим его к ответу.292D - Connected ComponentsОграничения в задаче были не слишком удачными и провоцировали писать решение за квадрат, мы постарались максимально не позволить таким решениям пройти.У этой задачи много правильных решений. Изначально планировалось решение, которое предподсчитывает частичные dsu (структура данных disjoint set union) на префиксах и на суффиксах, то есть массивы ldsu[M][N] и rdsu[M][N]. После этого на запрос [lf ; rg] легко ответить за время O(N·A - 1), если объединить множества ldsu[lf - 1] и rdsu[rg + 1], где A - 1 -- обратная функция Аккермана (константа от dsu).292E - Copying DataУ этой задачи много правильных решений. Изначально предполагалось решение, использующие корневую эвристику. Разобьем все запросы на sqrt(m) блоков. Будем поддерживать текущий массив b в виде отрезков в массиве z, который хранит четверки (lf, rg, type, start), где lf, rg — отрезок индексов массива b, type — 0 или 1, означающее из какого массива взяты числа для этого отрезка, start — позиция начала этого отрезка в массиве типа type. На запросы будем отвечать в тупую, то есть честно пересчитывать как изменится массив z от запроса копирования и отвечать на запросы значения в позициях. Однако, каждые sqrt(m) запросов будем сливать данные из массива z в массив b, для того чтобы сам массив z сильно не разрастался.Есть простое решение с деревом отрезков, которое умеет делать покраску на отрезке. Пусть пришел запрос копирования [lf ; rg], , тогда покрасим отрезок запроса [lf ; rg] в цвет, равный номеру запросу. Все запросы будем сохранять. Пусть пришел запрос значения в позиции x, тогда найдем цвет в дереве в этой позиции. Если такого цвета нет, значит мы находимся в исходном массиве b (выведем b[x]), иначе посчитаем смещение dx от начала этого запроса до нашей позиции x и выведем a[x + dx].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 292\\s*D"
          },
          "content_length": 3238
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 1",
          "code": "it is decided that it will not be able to participate out the competition.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 2",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 3",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 4",
          "code": "printf(\"1 %d %d %d\\n\", 1, 1, n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 5",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 6",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 7",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 8",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 9",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 10",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Croc Champ 2013 — Round 1 - Codeforces - Code 11",
          "code": "Still not..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= m; i++) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        ensuref(xi != yi, \"Self-loops are not allowed (edge %d connects node %d to itself)\", i, xi);\n        inf.readEoln();\n    }\n    \n    int k = inf.readInt(1, 20000, \"k\");\n    inf.readEoln();\n    for (int i = 1; i <= k; i++) {\n        int li = inf.readInt(1, m, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, m, \"r_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= m; i++) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        ensuref(xi != yi, \"Self-loops are not allowed (edge %d connects node %d to itself)\", i, xi);\n        inf.readEoln();\n    }\n    \n    int k = inf.readInt(1, 20000, \"k\");\n    inf.readEoln();\n    for (int i = 1; i <= k; i++) {\n        int li = inf.readInt(1, m, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, m, \"r_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= m; i++) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        ensuref(xi != yi, \"Self-loops are not allowed (edge %d connects node %d to itself)\", i, xi);\n        inf.readEoln();\n    }\n    \n    int k = inf.readInt(1, 20000, \"k\");\n    inf.readEoln();\n    for (int i = 1; i <= k; i++) {\n        int li = inf.readInt(1, m, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, m, \"r_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a tree with nodes from 1 to n\nvector<pair<int, int>> generateTree(int n) {\n    vector<pair<int, int>> treeEdges;\n    for (int i = 2; i <= n; i++) {\n        int u = i;\n        int v = rnd.next(1, i - 1);\n        treeEdges.push_back(make_pair(u, v));\n    }\n    return treeEdges;\n}\n\n// Function to generate a tree within a given set of nodes\nvector<pair<int, int>> generateTree(const vector<int>& nodes) {\n    vector<pair<int, int>> treeEdges;\n    int size = nodes.size();\n    for (int i = 1; i < size; i++) {\n        int u = nodes[i];\n        int v = nodes[rnd.next(0, i - 1)];\n        treeEdges.push_back(make_pair(u, v));\n    }\n    return treeEdges;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string experiment_type = opt<string>(\"experiment_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (graph_type == \"sparse\") {\n        // Generate a tree\n        edges = generateTree(n);\n        // Add extra edges if m > n - 1\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (graph_type == \"dense\") {\n        // Generate all possible edges and select m of them\n        int maxEdges = n * (n - 1) / 2;\n        int totalEdges = min(maxEdges, m);\n        vector<pair<int, int>> possibleEdges;\n        for (int u = 1; u <= n; u++) {\n            for (int v = u + 1; v <= n; v++) {\n                possibleEdges.push_back(make_pair(u, v));\n            }\n        }\n        shuffle(possibleEdges.begin(), possibleEdges.end());\n        for (int i = 0; i < totalEdges; i++) {\n            edges.push_back(possibleEdges[i]);\n        }\n    } else if (graph_type == \"cycle\") {\n        // Create a cycle\n        for (int i = 1; i <= n; i++) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back(make_pair(u, v));\n        }\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (graph_type == \"star\") {\n        // Create a star graph\n        int center = rnd.next(1, n);\n        for (int i = 1; i <= n; i++) {\n            if (i != center) {\n                edges.push_back(make_pair(center, i));\n            }\n        }\n        while ((int)edges.size() < m) {\n            int u = center;\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (graph_type == \"multiedge\") {\n        // Include multiple edges between same pairs\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (graph_type == \"disconnected\") {\n        // Create multiple components\n        int numComponents = rnd.next(2, min(10, n));\n        vector<int> componentSizes(numComponents, n / numComponents);\n        for (int i = 0; i < n % numComponents; i++) {\n            componentSizes[i]++;\n        }\n        int nodeId = 1;\n        for (int c = 0; c < numComponents; c++) {\n            int size = componentSizes[c];\n            vector<int> nodes;\n            for (int i = 0; i < size; i++) {\n                nodes.push_back(nodeId++);\n            }\n            vector<pair<int,int>> componentEdges = generateTree(nodes);\n            edges.insert(edges.end(), componentEdges.begin(), componentEdges.end());\n        }\n        // Add extra edges if m > edges.size()\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else {\n        // Default to random graph\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    }\n\n    // Now generate experiments\n    vector<pair<int, int>> experiments;\n\n    if (experiment_type == \"full_disconnect\") {\n        for (int i = 0; i < k; i++) {\n            experiments.push_back(make_pair(1, m));\n        }\n    } else if (experiment_type == \"single_edge\") {\n        for (int i = 0; i < k; i++) {\n            int edgeIndex = rnd.next(1, m);\n            experiments.push_back(make_pair(edgeIndex, edgeIndex));\n        }\n    } else if (experiment_type == \"random_ranges\") {\n        for (int i = 0; i < k; i++) {\n            int li = rnd.next(1, m);\n            int ri = rnd.next(li, m);\n            experiments.push_back(make_pair(li, ri));\n        }\n    } else {\n        // Default to random ranges\n        for (int i = 0; i < k; i++) {\n            int li = rnd.next(1, m);\n            int ri = rnd.next(li, m);\n            experiments.push_back(make_pair(li, ri));\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; i++) {\n        printf(\"%d %d\\n\", experiments[i].first, experiments[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a tree with nodes from 1 to n\nvector<pair<int, int>> generateTree(int n) {\n    vector<pair<int, int>> treeEdges;\n    for (int i = 2; i <= n; i++) {\n        int u = i;\n        int v = rnd.next(1, i - 1);\n        treeEdges.push_back(make_pair(u, v));\n    }\n    return treeEdges;\n}\n\n// Function to generate a tree within a given set of nodes\nvector<pair<int, int>> generateTree(const vector<int>& nodes) {\n    vector<pair<int, int>> treeEdges;\n    int size = nodes.size();\n    for (int i = 1; i < size; i++) {\n        int u = nodes[i];\n        int v = nodes[rnd.next(0, i - 1)];\n        treeEdges.push_back(make_pair(u, v));\n    }\n    return treeEdges;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string experiment_type = opt<string>(\"experiment_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (graph_type == \"sparse\") {\n        // Generate a tree\n        edges = generateTree(n);\n        // Add extra edges if m > n - 1\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (graph_type == \"dense\") {\n        // Generate all possible edges and select m of them\n        int maxEdges = n * (n - 1) / 2;\n        int totalEdges = min(maxEdges, m);\n        vector<pair<int, int>> possibleEdges;\n        for (int u = 1; u <= n; u++) {\n            for (int v = u + 1; v <= n; v++) {\n                possibleEdges.push_back(make_pair(u, v));\n            }\n        }\n        shuffle(possibleEdges.begin(), possibleEdges.end());\n        for (int i = 0; i < totalEdges; i++) {\n            edges.push_back(possibleEdges[i]);\n        }\n    } else if (graph_type == \"cycle\") {\n        // Create a cycle\n        for (int i = 1; i <= n; i++) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back(make_pair(u, v));\n        }\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (graph_type == \"star\") {\n        // Create a star graph\n        int center = rnd.next(1, n);\n        for (int i = 1; i <= n; i++) {\n            if (i != center) {\n                edges.push_back(make_pair(center, i));\n            }\n        }\n        while ((int)edges.size() < m) {\n            int u = center;\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (graph_type == \"multiedge\") {\n        // Include multiple edges between same pairs\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (graph_type == \"disconnected\") {\n        // Create multiple components\n        int numComponents = rnd.next(2, min(10, n));\n        vector<int> componentSizes(numComponents, n / numComponents);\n        for (int i = 0; i < n % numComponents; i++) {\n            componentSizes[i]++;\n        }\n        int nodeId = 1;\n        for (int c = 0; c < numComponents; c++) {\n            int size = componentSizes[c];\n            vector<int> nodes;\n            for (int i = 0; i < size; i++) {\n                nodes.push_back(nodeId++);\n            }\n            vector<pair<int,int>> componentEdges = generateTree(nodes);\n            edges.insert(edges.end(), componentEdges.begin(), componentEdges.end());\n        }\n        // Add extra edges if m > edges.size()\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else {\n        // Default to random graph\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    }\n\n    // Now generate experiments\n    vector<pair<int, int>> experiments;\n\n    if (experiment_type == \"full_disconnect\") {\n        for (int i = 0; i < k; i++) {\n            experiments.push_back(make_pair(1, m));\n        }\n    } else if (experiment_type == \"single_edge\") {\n        for (int i = 0; i < k; i++) {\n            int edgeIndex = rnd.next(1, m);\n            experiments.push_back(make_pair(edgeIndex, edgeIndex));\n        }\n    } else if (experiment_type == \"random_ranges\") {\n        for (int i = 0; i < k; i++) {\n            int li = rnd.next(1, m);\n            int ri = rnd.next(li, m);\n            experiments.push_back(make_pair(li, ri));\n        }\n    } else {\n        // Default to random ranges\n        for (int i = 0; i < k; i++) {\n            int li = rnd.next(1, m);\n            int ri = rnd.next(li, m);\n            experiments.push_back(make_pair(li, ri));\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; i++) {\n        printf(\"%d %d\\n\", experiments[i].first, experiments[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, minimal m, full disconnect experiments\n./gen -n 2 -m 1 -k 1 -graph_type sparse -experiment_type full_disconnect\n\n# Small n, maximal m, random experiments\n./gen -n 2 -m 2 -k 5 -graph_type dense -experiment_type random_ranges\n\n# Medium n, minimal m, single edge disconnect experiments\n./gen -n 50 -m 49 -k 10 -graph_type sparse -experiment_type single_edge\n\n# Medium n, maximal m, full disconnect experiments\n./gen -n 50 -m 1225 -k 20 -graph_type dense -experiment_type full_disconnect\n\n# Large n, minimal m, random experiments\n./gen -n 500 -m 499 -k 100 -graph_type sparse -experiment_type random_ranges\n\n# Large n, maximal m, random experiments\n./gen -n 500 -m 10000 -k 20000 -graph_type dense -experiment_type random_ranges\n\n# Graph with multiedge, random experiments\n./gen -n 100 -m 1000 -k 5000 -graph_type multiedge -experiment_type random_ranges\n\n# Disconnected graph, full disconnect experiments\n./gen -n 500 -m 10000 -k 10000 -graph_type disconnected -experiment_type full_disconnect\n\n# Star graph, single edge experiments\n./gen -n 500 -m 499 -k 200 -graph_type star -experiment_type single_edge\n\n# Cycle graph, random experiments\n./gen -n 500 -m 500 -k 1000 -graph_type cycle -experiment_type random_ranges\n\n# Random graph, full disconnect experiments\n./gen -n 400 -m 8000 -k 5000 -graph_type random -experiment_type full_disconnect\n\n# Random graph, random experiments\n./gen -n 300 -m 9000 -k 15000 -graph_type random -experiment_type random_ranges\n\n# Sparse graph, single edge experiments\n./gen -n 100 -m 99 -k 2000 -graph_type sparse -experiment_type single_edge\n\n# Dense graph, full disconnect experiments\n./gen -n 200 -m 10000 -k 20000 -graph_type dense -experiment_type full_disconnect\n\n# Multiedge graph, random experiments\n./gen -n 150 -m 5000 -k 10000 -graph_type multiedge -experiment_type random_ranges\n\n# Disconnected graph, random experiments\n./gen -n 500 -m 5000 -k 10000 -graph_type disconnected -experiment_type random_ranges\n\n# Star graph, full disconnect experiments\n./gen -n 250 -m 249 -k 5000 -graph_type star -experiment_type full_disconnect\n\n# Cycle graph, single edge experiments\n./gen -n 300 -m 300 -k 3000 -graph_type cycle -experiment_type single_edge\n\n# Random graph with minimal m, random experiments\n./gen -n 500 -m 499 -k 5000 -graph_type random -experiment_type random_ranges\n\n# Random graph with maximal m, single edge experiments\n./gen -n 500 -m 10000 -k 20000 -graph_type random -experiment_type single_edge\n\n# Graph with maximum edges for n = 100\n./gen -n 100 -m 4950 -k 10000 -graph_type dense -experiment_type random_ranges\n\n# Sparse graph with n = 500, m = n - 1\n./gen -n 500 -m 499 -k 1000 -graph_type sparse -experiment_type random_ranges\n\n# Disconnected graph with small m\n./gen -n 500 -m 250 -k 5000 -graph_type disconnected -experiment_type full_disconnect\n\n# Star graph with n = 500, m = 999\n./gen -n 500 -m 999 -k 5000 -graph_type star -experiment_type random_ranges\n\n# Random graph with m = 10000 and n = 500\n./gen -n 500 -m 10000 -k 20000 -graph_type random -experiment_type random_ranges\n\n# Cycle graph with n = 500\n./gen -n 500 -m 500 -k 1000 -graph_type cycle -experiment_type random_ranges\n\n# Multiedge graph with maximum m\n./gen -n 200 -m 10000 -k 20000 -graph_type multiedge -experiment_type random_ranges\n\n# Random graph with small n and large m\n./gen -n 10 -m 1000 -k 2000 -graph_type random -experiment_type random_ranges\n\n# Star graph with maximum m\n./gen -n 100 -m 10000 -k 10000 -graph_type star -experiment_type random_ranges\n\n# Disconnected graph with n = 400, m = 400\n./gen -n 400 -m 400 -k 4000 -graph_type disconnected -experiment_type random_ranges\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:21.650802",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "292/E",
      "title": "E. Копирование данных",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел заданы два целых числа n и m (1 ≤ n, m ≤ 105) — количество элементов в массивах и количество запросов соответственно. Во второй строке задан массив целых чисел a1, a2, ..., an (|ai| ≤ 109). В третьей строке задан массив целых чисел b1, b2, ..., bn (|bi| ≤ 109).В следующих m строках заданы описания запросов. В i-ой строке сначала задано целое число ti — тип i-го запроса (1 ≤ ti ≤ 2). Если ti = 1, то i-ый запрос обозначает операцию копирования, если ti = 2, то i-ый запрос обозначает взятие значения в массиве b. Если ti = 1, то после типа запроса записаны три целых числа xi, yi, ki (1 ≤ xi, yi, ki ≤ n) — параметры запроса копирования. Если ti = 2, то следом, после типа запроса, в строке записано целое число xi (1 ≤ xi ≤ n) — позиция в массиве b.Все числа в строках разделены одиночными пробелами. Гарантируется, что все запросы корректны, то есть границы копирования не выходят за границы массивов a и b.",
      "output_spec": "Выходные данныеДля каждого запроса второго типа в отдельную строку выведите результат.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 101 2 0 -1 33 1 5 -2 02 51 3 3 32 52 42 11 2 1 42 12 41 4 2 12 2Выходные данныеСкопировать03-1323-1",
      "description": "E. Копирование данных\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел заданы два целых числа n и m (1 ≤ n, m ≤ 105) — количество элементов в массивах и количество запросов соответственно. Во второй строке задан массив целых чисел a1, a2, ..., an (|ai| ≤ 109). В третьей строке задан массив целых чисел b1, b2, ..., bn (|bi| ≤ 109).В следующих m строках заданы описания запросов. В i-ой строке сначала задано целое число ti — тип i-го запроса (1 ≤ ti ≤ 2). Если ti = 1, то i-ый запрос обозначает операцию копирования, если ti = 2, то i-ый запрос обозначает взятие значения в массиве b. Если ti = 1, то после типа запроса записаны три целых числа xi, yi, ki (1 ≤ xi, yi, ki ≤ n) — параметры запроса копирования. Если ti = 2, то следом, после типа запроса, в строке записано целое число xi (1 ≤ xi ≤ n) — позиция в массиве b.Все числа в строках разделены одиночными пробелами. Гарантируется, что все запросы корректны, то есть границы копирования не выходят за границы массивов a и b.\n\nВходные данные\n\nВыходные данныеДля каждого запроса второго типа в отдельную строку выведите результат.\n\nВыходные данные\n\nВходные данныеСкопировать5 101 2 0 -1 33 1 5 -2 02 51 3 3 32 52 42 11 2 1 42 12 41 4 2 12 2Выходные данныеСкопировать03-1323-1\n\nВходные данныеСкопировать5 101 2 0 -1 33 1 5 -2 02 51 3 3 32 52 42 11 2 1 42 12 41 4 2 12 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать03-1323-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces",
          "content": "Доброго времени суток)Совсем скоро стартует Раунд 1 Всероссийского Открытого Чемпионата по программированию \"КРОК-2013\". Из в Раунда 1 в следующий Раунд 2 проходят участники, набравшие не меньше баллов, чем участник на 400-ом месте (при условии положительного числа набранных баллов).Раунд будет проходить по обычным правилам Codeforces (со взломами и падением стоимостей задач). Во время раунда задачи тестируются системой только на претестах, а системное тестирование состоится после окончания соревнования. Претесты не покрывают все возможные случаи входных данных, поэтому тщательно тестируйте свои программы.До окончания раунда категорически запрещается публиковать где-либо условия задач/решения/какие-либо мысли и соображения о них. Запрещено общаться на тему задач, обсуждать условия, решения и прочее.Задачи для вас подготовила команда авторов в составе: Павел Холкин (HolkinPV), Геральд Агапов (Gerald) и Михаил Мирзаянов (MikeMirzayanov). Отмечу, что команда в этом же составе провела для вас квалификационный раунд и отвечала на вопросы в течении всего соревнования. Традиционно благодарим Марию Белову (Delinur), которая перевела для вас условия задач.UPD1: Задачи будут расположены в порядке возрастания предполагаемой сложности. Распределение баллов было решено сделать немного нестандартным: 1000, 1000, 1500, 2000, 2500.UPD2: в связи с большим количеством участников было решено, что в соревновании нельзя будет участвовать вне конкурса. Для официальных участников соревнование будет рейтинговым.Всем участникам желаем удачи и успешного прохождения в следующий раунд соревнования.",
          "author": "HolkinPV",
          "url": "https://codeforces.com/blog/entry/7361",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1597
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 (Разбор задач) - Codeforces",
          "content": "292A - SMSCДля каждого момента i времени запомним количество сообщений z[i], которое нужно отправить в момент времени i. Теперь пройдем по каждому моменту времени от 1 до 106, поддерживая текущий размер очереди sz. На каждой итерации попробуем уменьшить размер очереди на 1, то есть выполним sz = max(sz - 1, 0), затем прибавим сообщения, которые нужно отправить в эту секунду, то есть выполним sz = sz + z[i]. На каждом шаге будем обновлять максимальное значение очереди и текущее время, если sz > 0. После выполнения цикла, если в очереди остались неотправленные сообщения, то нужно еще раз обновить ответ.292B - Network TopologyВ этой задаче нужно было посчитать степени каждой вершины и найти ответ. Замечу, поскольку n >  = 4, m >  = 3 и граф связный, то ответ однозначный.1) все степени 2 и у двух вершин степень 1 — шина.2) все степени 2 — кольцо3) все степени 1 и у одной степень  > 2 — звезда4) иначе неизвестно292C - Beautiful IP AddressesЗадача решается перебором. Для начала переберем сколько цифр в каждом четверти мы возьмем, например AAA.B.CC.DDD. Теперь посчитаем количество символов в этой строке (AAABCCDDD) и переберем цифры на первой половине этой строки (поскольку строка должна быть палиндромом, то вторая половина однозначно восстанавливается). После этого проверим, что такой ip-адрес является корректным и содержит правильный набор цифр. Если ip-адрес удовлетворяет всем условиям задачи, то добавим его к ответу.292D - Connected ComponentsОграничения в задаче были не слишком удачными и провоцировали писать решение за квадрат, мы постарались максимально не позволить таким решениям пройти.У этой задачи много правильных решений. Изначально планировалось решение, которое предподсчитывает частичные dsu (структура данных disjoint set union) на префиксах и на суффиксах, то есть массивы ldsu[M][N] и rdsu[M][N]. После этого на запрос [lf ; rg] легко ответить за время O(N·A - 1), если объединить множества ldsu[lf - 1] и rdsu[rg + 1], где A - 1 -- обратная функция Аккермана (константа от dsu).292E - Copying DataУ этой задачи много правильных решений. Изначально предполагалось решение, использующие корневую эвристику. Разобьем все запросы на sqrt(m) блоков. Будем поддерживать текущий массив b в виде отрезков в массиве z, который хранит четверки (lf, rg, type, start), где lf, rg — отрезок индексов массива b, type — 0 или 1, означающее из какого массива взяты числа для этого отрезка, start — позиция начала этого отрезка в массиве типа type. На запросы будем отвечать в тупую, то есть честно пересчитывать как изменится массив z от запроса копирования и отвечать на запросы значения в позициях. Однако, каждые sqrt(m) запросов будем сливать данные из массива z в массив b, для того чтобы сам массив z сильно не разрастался.Есть простое решение с деревом отрезков, которое умеет делать покраску на отрезке. Пусть пришел запрос копирования [lf ; rg], , тогда покрасим отрезок запроса [lf ; rg] в цвет, равный номеру запросу. Все запросы будем сохранять. Пусть пришел запрос значения в позиции x, тогда найдем цвет в дереве в этой позиции. Если такого цвета нет, значит мы находимся в исходном массиве b (выведем b[x]), иначе посчитаем смещение dx от начала этого запроса до нашей позиции x и выведем a[x + dx].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 292\\s*E"
          },
          "content_length": 3238
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 1",
          "code": "it is decided that it will not be able to participate out the competition.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 2",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 3",
          "code": "int main() {\n  int n = 1e5,Q = 1e5;\n  printf(\"%d %d\\n\", n, Q);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d\", 100);\n    if (i == n - 1) printf(\"\\n\"); else printf(\" \");\n  }\n  for (int i = 0; i < Q; i++) printf(\"%d %d %d\\n\", 1, 1, n);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 4",
          "code": "printf(\"1 %d %d %d\\n\", 1, 1, n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 5",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 6",
          "code": "void dfs(int v){\n      used[v]=true;\n      for (int j=0;j<g[v].size();j++)\n          if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))\n             dfs(g[v][j].v);\n };",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 7",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 8",
          "code": "if (!used[g[v][j].v] && (g[v][j].ind<l || g[v][j].ind>r))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 9",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 10",
          "code": "if ((g[v][j].ind<l || g[v][j].ind>r) && !used[g[v][j].v])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 11",
          "code": "int getParent(int x)\n{\n        if(parent[x] != parent[parent[x]])\n                parent[x] = getParent(parent[x]);\n        return parent[x];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 12",
          "code": "int getParent(int x)\n{\n        if(parent[x] != parent[parent[x]])\n                parent[x] = getParent(parent[x]);\n        return parent[x];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 13",
          "code": "if (r[x] == r[y]) {\n\tp[y] = x;\n\tr[x]++;\n} else if (r[x] < r[y]) {\n\tp[x] = y;\n} else {\n\tp[y] = x;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 14",
          "code": "if (r[x] == r[y]) {\n\tp[y] = x;\n\tr[x]++;\n} else if (r[x] < r[y]) {\n\tp[x] = y;\n} else {\n\tp[y] = x;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 15",
          "code": "Still not..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 16",
          "code": "if ((c[now][o]>r || c[now][o]<l) && !fix[g[now][o]])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 1 - Codeforces - Code 17",
          "code": "if (!fix[g[now][o]] && (c[now][o]>r || c[now][o]<l))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7361",
          "author": "HolkinPV"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(-1000000000, 1000000000, \"a_i\");\n        if (i != n) inf.readSpace();\n        else inf.readEoln();\n    }\n\n    // Read array b[1..n]\n    for (int i = 1; i <= n; ++i) {\n        int bi = inf.readInt(-1000000000, 1000000000, \"b_i\");\n        if (i != n) inf.readSpace();\n        else inf.readEoln();\n    }\n\n    // Read m queries\n    for (int i = 1; i <= m; ++i) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        if (t == 1) {\n            inf.readSpace();\n            int xi = inf.readInt(1, n, \"x_i\");\n            inf.readSpace();\n            int yi = inf.readInt(1, n, \"y_i\");\n            inf.readSpace();\n            int ki = inf.readInt(1, n, \"k_i\");\n            ensuref(xi + ki - 1 <= n, \"Copy operation xi + ki - 1 (%d + %d -1 = %d) should be ≤ n (%d)\", xi, ki, xi + ki - 1, n);\n            ensuref(yi + ki - 1 <= n, \"Copy operation yi + ki - 1 (%d + %d -1 = %d) should be ≤ n (%d)\", yi, ki, yi + ki - 1, n);\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int xi = inf.readInt(1, n, \"x_i\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid query type %d\", t);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(-1000000000, 1000000000, \"a_i\");\n        if (i != n) inf.readSpace();\n        else inf.readEoln();\n    }\n\n    // Read array b[1..n]\n    for (int i = 1; i <= n; ++i) {\n        int bi = inf.readInt(-1000000000, 1000000000, \"b_i\");\n        if (i != n) inf.readSpace();\n        else inf.readEoln();\n    }\n\n    // Read m queries\n    for (int i = 1; i <= m; ++i) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        if (t == 1) {\n            inf.readSpace();\n            int xi = inf.readInt(1, n, \"x_i\");\n            inf.readSpace();\n            int yi = inf.readInt(1, n, \"y_i\");\n            inf.readSpace();\n            int ki = inf.readInt(1, n, \"k_i\");\n            ensuref(xi + ki - 1 <= n, \"Copy operation xi + ki - 1 (%d + %d -1 = %d) should be ≤ n (%d)\", xi, ki, xi + ki - 1, n);\n            ensuref(yi + ki - 1 <= n, \"Copy operation yi + ki - 1 (%d + %d -1 = %d) should be ≤ n (%d)\", yi, ki, yi + ki - 1, n);\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int xi = inf.readInt(1, n, \"x_i\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid query type %d\", t);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(-1000000000, 1000000000, \"a_i\");\n        if (i != n) inf.readSpace();\n        else inf.readEoln();\n    }\n\n    // Read array b[1..n]\n    for (int i = 1; i <= n; ++i) {\n        int bi = inf.readInt(-1000000000, 1000000000, \"b_i\");\n        if (i != n) inf.readSpace();\n        else inf.readEoln();\n    }\n\n    // Read m queries\n    for (int i = 1; i <= m; ++i) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        if (t == 1) {\n            inf.readSpace();\n            int xi = inf.readInt(1, n, \"x_i\");\n            inf.readSpace();\n            int yi = inf.readInt(1, n, \"y_i\");\n            inf.readSpace();\n            int ki = inf.readInt(1, n, \"k_i\");\n            ensuref(xi + ki - 1 <= n, \"Copy operation xi + ki - 1 (%d + %d -1 = %d) should be ≤ n (%d)\", xi, ki, xi + ki - 1, n);\n            ensuref(yi + ki - 1 <= n, \"Copy operation yi + ki - 1 (%d + %d -1 = %d) should be ≤ n (%d)\", yi, ki, yi + ki - 1, n);\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int xi = inf.readInt(1, n, \"x_i\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid query type %d\", t);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    vector<int> a(n+1); // 1-based indexing\n    vector<int> b(n+1); // 1-based indexing\n\n    if (type == \"random\" || type == \"max_n\" || type == \"alternating\"\n        || type == \"all_queries\" || type == \"all_copies\"\n        || type == \"edge_indices\" || type == \"large_k\" || type == \"single_element_copy\") {\n        // Generate arrays a and b\n        for (int i = 1; i <= n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"zeros\") {\n        // All elements are zero\n        for (int i = 1; i <= n; ++i) {\n            a[i] = 0;\n            b[i] = 0;\n        }\n    } else if (type == \"max_values\") {\n        // All elements are maximum value\n        for (int i = 1; i <= n; ++i) {\n            a[i] = 1000000000;\n            b[i] = 1000000000;\n        }\n    } else if (type == \"min_values\") {\n        // All elements are minimum value\n        for (int i = 1; i <= n; ++i) {\n            a[i] = -1000000000;\n            b[i] = -1000000000;\n        }\n    }\n    // Output arrays a and b\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n    }\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", b[i], i == n ? '\\n' : ' ');\n    }\n\n    // Generate m queries\n    vector<int> query_types(m+1);\n\n    if (type == \"random\" || type == \"max_n\") {\n        // Random queries\n        for (int i = 1; i <= m; ++i) {\n            int t = rnd.next(1,2);\n            query_types[i] = t;\n        }\n    } else if (type == \"all_queries\") {\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = 2;\n        }\n    } else if (type == \"all_copies\") {\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = (i % 2 == 1) ? 1 : 2; // alternate starting with 1\n        }\n    } else if (type == \"large_k\") {\n        // All copy queries with ki = n\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = 1;\n        }\n    } else if (type == \"single_element_copy\") {\n        // All copy queries with ki = 1\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = 1;\n        }\n    } else if (type == \"edge_indices\") {\n        // Use indices at the boundaries\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = rnd.next(1,2);\n        }\n    }\n\n    for (int i = 1; i <= m; ++i) {\n        int t = query_types[i];\n        if (t == 1) {\n            // Copy query\n            int xi, yi, ki;\n            if (type == \"edge_indices\") {\n                ki = rnd.next(1, n);\n                int xi_candidates[2] = {1, n - ki +1};\n                int yi_candidates[2] = {1, n - ki +1};\n                xi = xi_candidates[rnd.next(0,1)];\n                yi = yi_candidates[rnd.next(0,1)];\n            } else if (type == \"large_k\") {\n                ki = n;\n                xi = 1;\n                yi = 1;\n            } else if (type == \"single_element_copy\") {\n                ki = 1;\n                xi = rnd.next(1, n);\n                yi = rnd.next(1, n);\n            } else {\n                xi = rnd.next(1, n);\n                int max_ki = n - xi +1;\n                ki = rnd.next(1, max_ki);\n                yi = rnd.next(1, n - ki +1);\n            }\n            printf(\"1 %d %d %d\\n\", xi, yi, ki);\n        } else {\n            // Query value\n            int xi;\n            if (type == \"edge_indices\") {\n                xi = rnd.next(0,1) ? 1 : n;\n            } else {\n                xi = rnd.next(1, n);\n            }\n            printf(\"2 %d\\n\", xi);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    vector<int> a(n+1); // 1-based indexing\n    vector<int> b(n+1); // 1-based indexing\n\n    if (type == \"random\" || type == \"max_n\" || type == \"alternating\"\n        || type == \"all_queries\" || type == \"all_copies\"\n        || type == \"edge_indices\" || type == \"large_k\" || type == \"single_element_copy\") {\n        // Generate arrays a and b\n        for (int i = 1; i <= n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"zeros\") {\n        // All elements are zero\n        for (int i = 1; i <= n; ++i) {\n            a[i] = 0;\n            b[i] = 0;\n        }\n    } else if (type == \"max_values\") {\n        // All elements are maximum value\n        for (int i = 1; i <= n; ++i) {\n            a[i] = 1000000000;\n            b[i] = 1000000000;\n        }\n    } else if (type == \"min_values\") {\n        // All elements are minimum value\n        for (int i = 1; i <= n; ++i) {\n            a[i] = -1000000000;\n            b[i] = -1000000000;\n        }\n    }\n    // Output arrays a and b\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n    }\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", b[i], i == n ? '\\n' : ' ');\n    }\n\n    // Generate m queries\n    vector<int> query_types(m+1);\n\n    if (type == \"random\" || type == \"max_n\") {\n        // Random queries\n        for (int i = 1; i <= m; ++i) {\n            int t = rnd.next(1,2);\n            query_types[i] = t;\n        }\n    } else if (type == \"all_queries\") {\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = 2;\n        }\n    } else if (type == \"all_copies\") {\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = (i % 2 == 1) ? 1 : 2; // alternate starting with 1\n        }\n    } else if (type == \"large_k\") {\n        // All copy queries with ki = n\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = 1;\n        }\n    } else if (type == \"single_element_copy\") {\n        // All copy queries with ki = 1\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = 1;\n        }\n    } else if (type == \"edge_indices\") {\n        // Use indices at the boundaries\n        for (int i = 1; i <= m; ++i) {\n            query_types[i] = rnd.next(1,2);\n        }\n    }\n\n    for (int i = 1; i <= m; ++i) {\n        int t = query_types[i];\n        if (t == 1) {\n            // Copy query\n            int xi, yi, ki;\n            if (type == \"edge_indices\") {\n                ki = rnd.next(1, n);\n                int xi_candidates[2] = {1, n - ki +1};\n                int yi_candidates[2] = {1, n - ki +1};\n                xi = xi_candidates[rnd.next(0,1)];\n                yi = yi_candidates[rnd.next(0,1)];\n            } else if (type == \"large_k\") {\n                ki = n;\n                xi = 1;\n                yi = 1;\n            } else if (type == \"single_element_copy\") {\n                ki = 1;\n                xi = rnd.next(1, n);\n                yi = rnd.next(1, n);\n            } else {\n                xi = rnd.next(1, n);\n                int max_ki = n - xi +1;\n                ki = rnd.next(1, max_ki);\n                yi = rnd.next(1, n - ki +1);\n            }\n            printf(\"1 %d %d %d\\n\", xi, yi, ki);\n        } else {\n            // Query value\n            int xi;\n            if (type == \"edge_indices\") {\n                xi = rnd.next(0,1) ? 1 : n;\n            } else {\n                xi = rnd.next(1, n);\n            }\n            printf(\"2 %d\\n\", xi);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 10 -type random\n./gen -n 10 -m 20 -type random\n./gen -n 1 -m 1 -type random\n\n./gen -n 100000 -m 100000 -type max_n\n./gen -n 100000 -m 50000 -type all_queries\n./gen -n 100000 -m 50000 -type all_copies\n\n./gen -n 99999 -m 100000 -type alternating\n./gen -n 100000 -m 100000 -type edge_indices\n\n./gen -n 100000 -m 100000 -type large_k\n./gen -n 100000 -m 100000 -type single_element_copy\n\n./gen -n 100000 -m 100000 -type zeros\n./gen -n 100000 -m 100000 -type max_values\n./gen -n 100000 -m 100000 -type min_values\n\n./gen -n 2 -m 2 -type edge_indices\n./gen -n 10000 -m 100000 -type random\n\n./gen -n 100000 -m 1000 -type random\n./gen -n 100000 -m 100000 -type alternating\n\n./gen -n 100000 -m 100000 -type edge_indices\n./gen -n 100000 -m 100000 -type large_k\n\n./gen -n 1 -m 10 -type single_element_copy\n./gen -n 100000 -m 100000 -type alternating\n\n./gen -n 99999 -m 1 -type random\n./gen -n 50000 -m 50000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100000 -m 50000 -type all_queries\n./gen -n 100000 -m 50000 -type all_copies\n./gen -n 50000 -m 50000 -type large_k\n./gen -n 50000 -m 50000 -type single_element_copy\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:24.023072",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "293/A",
      "title": "A. Weird Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106). The second line contains string s — Yaroslav's word. The third line contains string t — Andrey's word.It is guaranteed that both words consist of 2·n characters \"0\" and \"1\".",
      "output_spec": "OutputPrint \"First\", if both players play optimally well and Yaroslav wins. If Andrey wins, print \"Second\" and if the game ends with a draw, print \"Draw\". Print the words without the quotes.",
      "sample_tests": "ExamplesInputCopy201110001OutputCopyFirstInputCopy3110110001001OutputCopyFirstInputCopy3111000000111OutputCopyDrawInputCopy40101011000101101OutputCopyFirstInputCopy40110000010010011OutputCopySecond",
      "description": "A. Weird Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 106). The second line contains string s — Yaroslav's word. The third line contains string t — Andrey's word.It is guaranteed that both words consist of 2·n characters \"0\" and \"1\".\n\nOutputPrint \"First\", if both players play optimally well and Yaroslav wins. If Andrey wins, print \"Second\" and if the game ends with a draw, print \"Draw\". Print the words without the quotes.\n\nInputCopy201110001OutputCopyFirstInputCopy3110110001001OutputCopyFirstInputCopy3111000000111OutputCopyDrawInputCopy40101011000101101OutputCopyFirstInputCopy40110000010010011OutputCopySecond\n\nInputCopy201110001\n\nOutputCopyFirst\n\nInputCopy3110110001001\n\nOutputCopyFirst\n\nInputCopy3111000000111\n\nOutputCopyDraw\n\nInputCopy40101011000101101\n\nOutputCopyFirst\n\nInputCopy40110000010010011\n\nOutputCopySecond",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Croc Champ 2013 — Round 2 — Editorial - Codeforces",
          "content": "Here you can find the solutions for the problems from the past round. You can ask questions in the comments below.A Div 2If ai divide aj than ai ≤ aj. So the number which will divide every other number should be less than or equal to every other number, so the only possible candidate — it's the minimum in the array. So just check whether all elements are divisible by the minimal one.B Div 2Easy to see, that Ksusha is unable to complete her journey if there is a sequence of consecutive # with length more than k.C Div 2 / A Div 1The first observation — we don't care about the actual strings, all information we need — number of pairs {0,0}, {0,1}, {1,0}, {1,1}. Count that and then just follow the greedy algorithm, for the first player: try to get a index with {1,1} if there are some, than {1,0}, than {0,1} and than {0,0}.For the second player similar strategy: first {1,1}, than {0,1}, than {1,0}, than {0,0}.After that just compare who has more 1.D Div 2 / B Div 1Every path from the topleft cell to the bottomright cell contain exactly n + m - 1 cells. And all of the should be of different color. So n + m - 1 ≤ k. Due to the small constraints for k we may assume that bruteforce might work. The only optimization to get the correct solution is some canonization of the colors. So let's go over all of the cells in some order and color them but with following condition. If i > j, than color i appeared later than color j. If we bruteforce in such way we will have about 1 million different patterns for max case. Than just match them with already painted cells and calculate for each pattern how many different permutations of color we can apply to it.E Div 2 / C Div 1After reading the problem statement one can understand that all we need is to calculate the number of positive integer solutions of equation: (a + b + c)3 - a3 - b3 - c3 = n.The key observation is: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, after that simply calculate all divisors of and then first go over all x = a + b, such that then go over all y = (a + c) ≥ x, such that and then determine z = (b + c), such that . After that we need to solve the system a + b = x, a + c = y, b + c = z and find out how many solutions it adds.D Div 1We can see that we asked to calculate for all integer points inside the polygon or on its border. We can see that we can process Xs and Ys independently.For each x determine yleft, yright, such that all points (x, y) where yleft ≤ y ≤ yright are inside the polygon and the range [yleft, yright] is as maximal as possible. Now let's assume that we have a1, a2, ..., ak different points with fixed x coordinate (a1 stands for x =  - 106, a2 for x =  - 106 + 1 and so on).Now the required answer is a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... We can see that: (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,and so on.So we can precalculate partial sums like a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (the difference between two consecutive sums is 2(ai + ... + a1), so we can do that in O(k) time).After this precomputation we just need to sum the results.E Div 1Let's assume that we have a data structure which can perform such operations as: — add point (x,y) to the structure; shift all points in the structure by vector (dx,dy); answer how many point (x,y) are in the structure where x ≤ xbound, y ≤ ybound; get all elements which are now in the structure; For every vertex of the tree we will store the pointer to such structure.How we update the structures. We will proceed all the vertices in dfs order, if we are in a leaf node, than we create structure which contains only one element (0,0).Otherwise we will sort the children structures by it's size in decreasing order and assign the pointer of the biggest structure to the pointer of the current vertex (Don't forget to shift the structure by (1, weight of edge)).After that we will go over all other children one by one and do the following thing: Shift the structure by (1, weight of edge); Get all elements from the structure; For every element (x,y) answer the query xbound = L - x, ybound = W - y (we use parent's structure); Add elements one by one into the structure; After that answer the query xbound = L, ybound = W and add element (0,0).The sum of the results of all the queries is our answer. It's easy to see that there will be no more than queries and add operations.The remaining part is designing the structure.It can be done in many ways. One of the ways: We have small structures with sizes equals to powers of two; Each structure — it's two-dimensional segments tree; We can add one element in a following way: if there is no substructure with size 1, than add it; else get structures with sizes 1, 2, 4, ..., 2k and all its' elements and rebuild the structure with size 2k + 1; Shifting — just remember shifting vector for every substructure; Answering the query — go over all substructures and add the results. Editorial was prepared by sdya and Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5006
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref((int)s.length() == 2 * n, \"The length of string s must be 2*n=%d, but found %d\", 2 * n, (int)s.length());\n    for (char c : s) {\n        ensuref(c == '0' || c == '1', \"All characters in string s must be '0' or '1'\");\n    }\n\n    string t = inf.readLine();\n    ensuref((int)t.length() == 2 * n, \"The length of string t must be 2*n=%d, but found %d\", 2 * n, (int)t.length());\n    for (char c : t) {\n        ensuref(c == '0' || c == '1', \"All characters in string t must be '0' or '1'\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref((int)s.length() == 2 * n, \"The length of string s must be 2*n=%d, but found %d\", 2 * n, (int)s.length());\n    for (char c : s) {\n        ensuref(c == '0' || c == '1', \"All characters in string s must be '0' or '1'\");\n    }\n\n    string t = inf.readLine();\n    ensuref((int)t.length() == 2 * n, \"The length of string t must be 2*n=%d, but found %d\", 2 * n, (int)t.length());\n    for (char c : t) {\n        ensuref(c == '0' || c == '1', \"All characters in string t must be '0' or '1'\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref((int)s.length() == 2 * n, \"The length of string s must be 2*n=%d, but found %d\", 2 * n, (int)s.length());\n    for (char c : s) {\n        ensuref(c == '0' || c == '1', \"All characters in string s must be '0' or '1'\");\n    }\n\n    string t = inf.readLine();\n    ensuref((int)t.length() == 2 * n, \"The length of string t must be 2*n=%d, but found %d\", 2 * n, (int)t.length());\n    for (char c : t) {\n        ensuref(c == '0' || c == '1', \"All characters in string t must be '0' or '1'\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int total_length = 2 * n;\n    string s(total_length, '0'), t(total_length, '0');\n\n    if (type == \"random\") {\n        for(int i = 0; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = rnd.next(0,1) + '0';\n        }\n    } else if (type == \"all_ones\") {\n        s = string(total_length, '1');\n        t = string(total_length, '1');\n    } else if (type == \"all_zeros\") {\n        s = string(total_length, '0');\n        t = string(total_length, '0');\n    } else if (type == \"s_ones_t_zeros\") {\n        s = string(total_length, '1');\n        t = string(total_length, '0');\n    } else if (type == \"s_zeros_t_ones\") {\n        s = string(total_length, '0');\n        t = string(total_length, '1');\n    } else if (type == \"s_equal_t_random\") {\n        for(int i = 0; i < total_length; ++i) {\n            char c = rnd.next(0,1) + '0';\n            s[i] = c;\n            t[i] = c;\n        }\n    } else if (type == \"s_reverse_t\") {\n        for(int i = 0; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n        t = s;\n        reverse(t.begin(), t.end());\n    } else if (type == \"s_complement_t\") {\n        for(int i = 0; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = (s[i] == '0') ? '1' : '0';\n        }\n    } else if (type == \"half_same_half_different\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = s[i]; // same in first half\n        }\n        for(int i = n; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = (s[i] == '0') ? '1' : '0'; // different in second half\n        }\n    } else {\n        // default random\n        for(int i = 0; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = rnd.next(0,1) + '0';\n        }\n    }\n\n    // output n\n    printf(\"%d\\n\", n);\n    // output s\n    printf(\"%s\\n\", s.c_str());\n    // output t\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int total_length = 2 * n;\n    string s(total_length, '0'), t(total_length, '0');\n\n    if (type == \"random\") {\n        for(int i = 0; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = rnd.next(0,1) + '0';\n        }\n    } else if (type == \"all_ones\") {\n        s = string(total_length, '1');\n        t = string(total_length, '1');\n    } else if (type == \"all_zeros\") {\n        s = string(total_length, '0');\n        t = string(total_length, '0');\n    } else if (type == \"s_ones_t_zeros\") {\n        s = string(total_length, '1');\n        t = string(total_length, '0');\n    } else if (type == \"s_zeros_t_ones\") {\n        s = string(total_length, '0');\n        t = string(total_length, '1');\n    } else if (type == \"s_equal_t_random\") {\n        for(int i = 0; i < total_length; ++i) {\n            char c = rnd.next(0,1) + '0';\n            s[i] = c;\n            t[i] = c;\n        }\n    } else if (type == \"s_reverse_t\") {\n        for(int i = 0; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n        t = s;\n        reverse(t.begin(), t.end());\n    } else if (type == \"s_complement_t\") {\n        for(int i = 0; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = (s[i] == '0') ? '1' : '0';\n        }\n    } else if (type == \"half_same_half_different\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = s[i]; // same in first half\n        }\n        for(int i = n; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = (s[i] == '0') ? '1' : '0'; // different in second half\n        }\n    } else {\n        // default random\n        for(int i = 0; i < total_length; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n            t[i] = rnd.next(0,1) + '0';\n        }\n    }\n\n    // output n\n    printf(\"%d\\n\", n);\n    // output s\n    printf(\"%s\\n\", s.c_str());\n    // output t\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, different types\n./gen -n 1 -type random\n./gen -n 1 -type all_ones\n./gen -n 1 -type all_zeros\n./gen -n 1 -type s_ones_t_zeros\n./gen -n 1 -type s_zeros_t_ones\n./gen -n 1 -type s_equal_t_random\n./gen -n 1 -type s_reverse_t\n./gen -n 1 -type s_complement_t\n./gen -n 1 -type half_same_half_different\n\n# Moderate n\n./gen -n 10 -type random\n./gen -n 10 -type all_ones\n./gen -n 10 -type all_zeros\n./gen -n 10 -type s_ones_t_zeros\n./gen -n 10 -type s_zeros_t_ones\n./gen -n 10 -type s_equal_t_random\n./gen -n 10 -type s_reverse_t\n./gen -n 10 -type s_complement_t\n./gen -n 10 -type half_same_half_different\n\n# Larger n\n./gen -n 1000 -type random\n./gen -n 1000 -type s_ones_t_zeros\n./gen -n 1000 -type s_complement_t\n\n./gen -n 100000 -type random\n\n./gen -n 500000 -type random\n\n./gen -n 1000000 -type random\n\n# Edge cases\n./gen -n 1000000 -type all_ones\n./gen -n 1000000 -type s_ones_t_zeros\n./gen -n 1000000 -type s_complement_t\n./gen -n 1000000 -type s_reverse_t\n\n# Special cases\n./gen -n 999999 -type half_same_half_different\n./gen -n 999999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:26.418206",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "293/B",
      "title": "B. Различные пути",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа n, m, k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10). В следующих n строках записано по m целых чисел — доска. В первой из них заданы m самых верхних клеток доски слева направо, во второй m вторых сверху и так далее. Если число в строке равно 0, то соответствующая клетка не покрашена, иначе это число задает изначальный цвет клетки доски — целое число от 1 до k.Считайте, что цвета пронумерованы от 1 до k некоторым образом.",
      "output_spec": "Выходные данныеВыведите остаток от деления количества возможных раскрасок на 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 40 00 0Выходные данныеСкопировать48Входные данныеСкопировать2 2 41 22 1Выходные данныеСкопировать0Входные данныеСкопировать5 6 100 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0Выходные данныеСкопировать3628800Входные данныеСкопировать2 6 101 2 3 4 5 60 0 0 0 0 0Выходные данныеСкопировать4096",
      "description": "B. Различные пути\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа n, m, k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10). В следующих n строках записано по m целых чисел — доска. В первой из них заданы m самых верхних клеток доски слева направо, во второй m вторых сверху и так далее. Если число в строке равно 0, то соответствующая клетка не покрашена, иначе это число задает изначальный цвет клетки доски — целое число от 1 до k.Считайте, что цвета пронумерованы от 1 до k некоторым образом.\n\nВходные данные\n\nВыходные данныеВыведите остаток от деления количества возможных раскрасок на 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать2 2 40 00 0Выходные данныеСкопировать48Входные данныеСкопировать2 2 41 22 1Выходные данныеСкопировать0Входные данныеСкопировать5 6 100 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0Выходные данныеСкопировать3628800Входные данныеСкопировать2 6 101 2 3 4 5 60 0 0 0 0 0Выходные данныеСкопировать4096\n\nВходные данныеСкопировать2 2 40 00 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать48\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 41 22 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 6 100 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3628800\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 6 101 2 3 4 5 60 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4096\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces",
          "content": "Всем привет!Сегодня состоится второй раунд Всероссийского Открытого Чемпионата по программированию \"КРОК-2013\". Раунд для вас готовили: sdya, Seyaua, Gerald и, как обычно, задачи на английский переводила Delinur.Приятная новость для тех, кто не попал в лучшие 400 участников в предыдущем раунде — сегодня каждый может поучаствовать вне конкурса. При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.Официальным участникам напоминаем, что: Все участники чемпионата должны быть не моложе 18 лет на момент регистрации Финал чемпионата состоится 16 и 17 мая в Москве в офисе компании КРОК (50 участников) Проживание во время финала будет оплачено компанией КРОК Для граждан Российской Федерации: организаторы покроют транспортные расходы по территории РФ, транспортные расходы не по территории РФ — по согласованию (возможно, частично) Финалисты должны подтвердить свое участие до 2 мая И небольшой бонус: лучшие 200 официальных участников чемпионата получат футболки!Желаем всем получить удовольствие от решения задач ну и, конечно, удачи!UPD: Разбалловка по задачам сегодня будет немножко отличаться от стандартной: 500-1500-1500-2000-2500 для первого дивизиона и 500-1000-1500-2500-2500 для второго.UPD2: Мы приносим свои извинения за технические неполадки во время раунда. Посовещавшись, мы решили, что соревнование должно быть рейтинговым. А результаты соревнования будут учитываться в отборе на финал чемпионата КРОК.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1467
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 — Разбор - Codeforces",
          "content": "A Div 2Если aj делится на ai, то тогда ai ≤ aj. Тогда число, на которое будут делиться все остальные числа будет не более чем любое выбранное число. То есть единственный возможный кандидат — это минимум в массиве. Поэтому просто проверим, что все элементы массива делятся на минимальный элемент.B Div 2Легко видеть, что Ксюша не сможет закончить ее путешествие, если существует последовательность подряд идущих # длиное более чем k.C Div 2 / A Div 1Первое наблюдение: мы не будем волноваться о том, как выглядят строки на самом деле, вся информация, которая нам нужна — это количество пар-символов вида: {0, 0}, {0, 1}, {1, 0}, {1, 1}. Посчитаем эти количества и будем следовать следующему жадному алгоритму:Для первого игрока: будем брать сначала {1, 1}, если их нет, то {1,0}. Если их нет, то {0, 1} и, в последнюю очередь, будем брать {0, 0}.Для второго игрока похожая стратегия: сначала {1, 1}, потом {0, 1}, потом {1, 0} и, в последнюю очередь, {0, 0}.После этого сравним у кого получилось больше единичек.D Div 2 / B Div 1Любой путь из верхней левой клетки в правую нижнюю состоит ровно из n + m - 1 клеток. И все они должны быть покрашены в разные цвета. Значит n + m - 1 ≤ k. Исходя из маленьких ограничений на k можно предположить, что брут-форс будет работать. Единственная оптимизация для получения действительно правильного решения — это некоторая канонизация раскрасок. Будем идти по всем клеткам в некотором порядке и красить их согласно следующим условиям. Если i > j, тогда цвет i встречается позже цвета j. После такого перебора мы получим примерно миллион различных шаблонов для максимального теста.Далее, просто будем сопоставлять уже покрашенные клетки с каждым шаблоном и считать, сколько различных перестановок цветов подходят к данному шаблону.E Div 2 / C Div 1После прочтения условия, можно понять, что все, что нам нужно — это посчитать количество решений уравнения (a + b + c)3 - a3 - b3 - c3 = n в положительных целых числах.Ключевое наблюдение это: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, после чего мы можем просто вычислять все делители числа и идти по всем делителям x = a + b, таким что ? далее будем идти по делителям y = (a + c) ≥ x, где и в конце будем вычислять z = (b + c), такое что .После этого, решим систему a + b = x, a + c = y, b + c = z и добавим количество подходящих решений к ответу.D Div 1Можно заметить, что в этой задаче просят посчитать для всех целых точек внутри многоугольника (или на его границе). Можно заметить, что мы можем обрабатывать иксы и игреки независимо.Для каждого x определим yleft, yright таким образом, что все точки (x, y), где yleft ≤ y ≤ yright лежат внутри многоугольника и отрезок [yleft, yright] максимально возможный.Теперь будем считать, что мы имеем a1, a2, ..., ak различных точек для каждого фиксированного x (a1 соответствует x =  - 106, a2 соответствует x =  - 106 + 1 и так далее).Теперь требуемый ответ это a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... Можно заметить, что (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,и так далее.Поэтому достаточно предпросчитать частичные суммы вида a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (разность между двумя соседними суммами составляет 2(ai + ... + a1), поэтому мы можем делать это за O(k)).После предпросчета достаточно сложить полученные результаты.E Div 1Будем считать что у нас есть структура данных, которая позволяет осуществлять следующие операции: добавить точку (x, y) в структуру; сдвинуть все точки структуры на вектор (dx, dy); узнать как много точек (x,y), удовлетворяющих x ≤ xbound, y ≤ ybound; получить все элементы, которые на данный момент находятся в структуре; Для каждой вершины дерева мы будем хранить указатель на структуру такого вида.ОБъясним, как нужно обновлять структуры. Мы будем обрабатывать все вершины в порядке обхода в глубине, и если мы находимся в листе, то мы будем создавать структуру с единственным элементом (0, 0).В противном же случае, мы будем сортировать структуры сыновей по их размеру в убывающем порядке и будем присваивать указатель наибольшей структуры указателю на текущую вершину (здесь нужно не забыть сдвигать структуру на (1, вес ребра)).После этого будем идти по всем сыновьям вершины и делать следующее: Сдвинем структуру на (1, вес ребра); Возьмем все элементы структуры; Для каждого элемента (x, y) ответим на запрос xbound = L - x, ybound = W - y (используем родительскую структуру); Добавим элементы по одному в структуру; После этого ответим на запрос xbound = L, ybound = W и добавим элемент (0, 0).Сумма полученных результатов по всем запросам и будет ответом. Легко видеть, что мы совершим не более чем запросов и операций добавления.Осталось только объяснить, как создать нужную нам структуру данных.Существует несколько способов сделать это, один из них: Будем иметь маленькие подструктуры у которых размеры являются степенями двойки; Каждая структура — это двумерное дерево отрезков; Мы можем добавлять элемент следующим образом: если нет подструктуры размера 1, тогда создадим ее, иначе же возьмем все структуры размерами 1, 2, 4, ..., 2k и перестроим в структуру размера 2k + 1. Сдвиг: достаточно помнить вектор сдвига для каждой подструктуры; Ответ на запрос: идем по подструктурам и суммируем результаты. Разбор задач был подготовлен sdya и Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5301
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 1",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 2",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 3",
          "code": "dp[0][1][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 4",
          "code": "dp[1][0][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 5",
          "code": "dp[1][1][{1,2,3}]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 6",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 7",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 8",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 9",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 10",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 11",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 12",
          "code": "При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 13",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 14",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 15",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 16",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, k, \"row\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, k, \"row\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, k, \"row\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    int paint_percentage = opt<int>(\"paint_percent\", -1); // default -1 meaning not used\n\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    if (type == \"empty\") {\n        // All zeros, do nothing\n    } else if (type == \"full\") {\n        // Fill all cells with random colors between 1 and k\n        for(int i = 0; i < n; ++i) \n            for(int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(1, k);\n    } else if (type == \"random\") {\n        int total_cells = n*m;\n        int cells_to_paint;\n        if(paint_percentage == -1) {\n            paint_percentage = rnd.next(0,100);\n        }\n        cells_to_paint = total_cells * paint_percentage / 100;\n\n        vector<pair<int,int>> cells;\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                cells.push_back({i,j});\n\n        shuffle(cells.begin(), cells.end());\n\n        for(int i = 0; i < cells_to_paint; ++i) {\n            int x = cells[i].first;\n            int y = cells[i].second;\n            grid[x][y] = rnd.next(1, k);\n        }\n\n    } else if (type == \"onecolor\") {\n        k = 1;\n        // Cells are zeros (unpainted)\n    } else if (type == \"path_painted\") {\n        int color = rnd.next(1, k);\n        int i = 0, j = 0;\n        grid[i][j] = color;\n        while (i != n-1 || j != m-1) {\n            if (i == n-1) j++;\n            else if (j == m-1) i++;\n            else if (rnd.next(0,1) == 0) i++;\n            else j++;\n            grid[i][j] = color;\n        }\n    } else if (type == \"diagonal\") {\n        for(int i = 0; i < min(n,m); ++i)\n            grid[i][i] = rnd.next(1, k);\n    } else if (type == \"column_painted\") {\n        for(int i = 0; i < n; ++i)\n            grid[i][0] = rnd.next(1, k);\n    }\n    \n    printf(\"%d %d %d\\n\", n, m, k);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    int paint_percentage = opt<int>(\"paint_percent\", -1); // default -1 meaning not used\n\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    if (type == \"empty\") {\n        // All zeros, do nothing\n    } else if (type == \"full\") {\n        // Fill all cells with random colors between 1 and k\n        for(int i = 0; i < n; ++i) \n            for(int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(1, k);\n    } else if (type == \"random\") {\n        int total_cells = n*m;\n        int cells_to_paint;\n        if(paint_percentage == -1) {\n            paint_percentage = rnd.next(0,100);\n        }\n        cells_to_paint = total_cells * paint_percentage / 100;\n\n        vector<pair<int,int>> cells;\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                cells.push_back({i,j});\n\n        shuffle(cells.begin(), cells.end());\n\n        for(int i = 0; i < cells_to_paint; ++i) {\n            int x = cells[i].first;\n            int y = cells[i].second;\n            grid[x][y] = rnd.next(1, k);\n        }\n\n    } else if (type == \"onecolor\") {\n        k = 1;\n        // Cells are zeros (unpainted)\n    } else if (type == \"path_painted\") {\n        int color = rnd.next(1, k);\n        int i = 0, j = 0;\n        grid[i][j] = color;\n        while (i != n-1 || j != m-1) {\n            if (i == n-1) j++;\n            else if (j == m-1) i++;\n            else if (rnd.next(0,1) == 0) i++;\n            else j++;\n            grid[i][j] = color;\n        }\n    } else if (type == \"diagonal\") {\n        for(int i = 0; i < min(n,m); ++i)\n            grid[i][i] = rnd.next(1, k);\n    } else if (type == \"column_painted\") {\n        for(int i = 0; i < n; ++i)\n            grid[i][0] = rnd.next(1, k);\n    }\n    \n    printf(\"%d %d %d\\n\", n, m, k);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type empty\n./gen -n 1 -m 1 -k 1 -type full\n./gen -n 1 -m 1 -k 1 -type random -paint_percent 50\n./gen -n 1000 -m 1000 -k 10 -type empty\n./gen -n 1000 -m 1000 -k 10 -type full\n./gen -n 1000 -m 1000 -k 10 -type random -paint_percent 50\n./gen -n 500 -m 500 -k 5 -type random -paint_percent 10\n./gen -n 1000 -m 1000 -k 10 -type random -paint_percent 90\n./gen -n 1000 -m 1 -k 10 -type empty\n./gen -n 1 -m 1000 -k 10 -type empty\n./gen -n 1 -m 1000 -k 1 -type onecolor\n./gen -n 1 -m 1 -k 1 -type onecolor\n./gen -n 1000 -m 1000 -k 1 -type onecolor\n./gen -n 1000 -m 1000 -k 10 -type path_painted\n./gen -n 1000 -m 1000 -k 10 -type diagonal\n./gen -n 1000 -m 1000 -k 10 -type column_painted\n./gen -n 10 -m 10 -k 2 -type random\n./gen -n 2 -m 2 -k 10 -type full\n./gen -n 2 -m 2 -k 1 -type full\n./gen -n 1000 -m 1000 -k 2 -type random\n./gen -n 1000 -m 1000 -k 10 -type random -paint_percent 0\n./gen -n 1000 -m 1000 -k 10 -type random -paint_percent 100\n./gen -n 1000 -m 1000 -k 7 -type random\n./gen -n 1000 -m 1000 -k 1 -type random\n./gen -n 50 -m 50 -k 10 -type random\n./gen -n 1000 -m 1000 -k 10 -type random\n./gen -n 50 -m 50 -k 10 -type path_painted\n./gen -n 1000 -m 1000 -k 10 -type path_painted\n./gen -n 1000 -m 1000 -k 10 -type column_painted\n./gen -n 1000 -m 1000 -k 10 -type diagonal\n./gen -n 1 -m 1000 -k 10 -type path_painted\n./gen -n 1000 -m 1 -k 10 -type path_painted\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:28.490627",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "293/C",
      "title": "C. Cube Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains integer n (1 ≤ n ≤ 1014). We know that all numbers a, b, c are positive integers.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputIn the single line print the required number of ways. If it turns out that there isn't a single way of suitable sizes of a, b, c, print 0.",
      "sample_tests": "ExamplesInputCopy24OutputCopy1InputCopy648OutputCopy7InputCopy5OutputCopy0InputCopy93163582512000OutputCopy39090",
      "description": "C. Cube Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains integer n (1 ≤ n ≤ 1014). We know that all numbers a, b, c are positive integers.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputIn the single line print the required number of ways. If it turns out that there isn't a single way of suitable sizes of a, b, c, print 0.\n\nInputCopy24OutputCopy1InputCopy648OutputCopy7InputCopy5OutputCopy0InputCopy93163582512000OutputCopy39090\n\nInputCopy24\n\nOutputCopy1\n\nInputCopy648\n\nOutputCopy7\n\nOutputCopy0\n\nInputCopy93163582512000\n\nOutputCopy39090",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Croc Champ 2013 — Round 2 — Editorial - Codeforces",
          "content": "Here you can find the solutions for the problems from the past round. You can ask questions in the comments below.A Div 2If ai divide aj than ai ≤ aj. So the number which will divide every other number should be less than or equal to every other number, so the only possible candidate — it's the minimum in the array. So just check whether all elements are divisible by the minimal one.B Div 2Easy to see, that Ksusha is unable to complete her journey if there is a sequence of consecutive # with length more than k.C Div 2 / A Div 1The first observation — we don't care about the actual strings, all information we need — number of pairs {0,0}, {0,1}, {1,0}, {1,1}. Count that and then just follow the greedy algorithm, for the first player: try to get a index with {1,1} if there are some, than {1,0}, than {0,1} and than {0,0}.For the second player similar strategy: first {1,1}, than {0,1}, than {1,0}, than {0,0}.After that just compare who has more 1.D Div 2 / B Div 1Every path from the topleft cell to the bottomright cell contain exactly n + m - 1 cells. And all of the should be of different color. So n + m - 1 ≤ k. Due to the small constraints for k we may assume that bruteforce might work. The only optimization to get the correct solution is some canonization of the colors. So let's go over all of the cells in some order and color them but with following condition. If i > j, than color i appeared later than color j. If we bruteforce in such way we will have about 1 million different patterns for max case. Than just match them with already painted cells and calculate for each pattern how many different permutations of color we can apply to it.E Div 2 / C Div 1After reading the problem statement one can understand that all we need is to calculate the number of positive integer solutions of equation: (a + b + c)3 - a3 - b3 - c3 = n.The key observation is: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, after that simply calculate all divisors of and then first go over all x = a + b, such that then go over all y = (a + c) ≥ x, such that and then determine z = (b + c), such that . After that we need to solve the system a + b = x, a + c = y, b + c = z and find out how many solutions it adds.D Div 1We can see that we asked to calculate for all integer points inside the polygon or on its border. We can see that we can process Xs and Ys independently.For each x determine yleft, yright, such that all points (x, y) where yleft ≤ y ≤ yright are inside the polygon and the range [yleft, yright] is as maximal as possible. Now let's assume that we have a1, a2, ..., ak different points with fixed x coordinate (a1 stands for x =  - 106, a2 for x =  - 106 + 1 and so on).Now the required answer is a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... We can see that: (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,and so on.So we can precalculate partial sums like a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (the difference between two consecutive sums is 2(ai + ... + a1), so we can do that in O(k) time).After this precomputation we just need to sum the results.E Div 1Let's assume that we have a data structure which can perform such operations as: — add point (x,y) to the structure; shift all points in the structure by vector (dx,dy); answer how many point (x,y) are in the structure where x ≤ xbound, y ≤ ybound; get all elements which are now in the structure; For every vertex of the tree we will store the pointer to such structure.How we update the structures. We will proceed all the vertices in dfs order, if we are in a leaf node, than we create structure which contains only one element (0,0).Otherwise we will sort the children structures by it's size in decreasing order and assign the pointer of the biggest structure to the pointer of the current vertex (Don't forget to shift the structure by (1, weight of edge)).After that we will go over all other children one by one and do the following thing: Shift the structure by (1, weight of edge); Get all elements from the structure; For every element (x,y) answer the query xbound = L - x, ybound = W - y (we use parent's structure); Add elements one by one into the structure; After that answer the query xbound = L, ybound = W and add element (0,0).The sum of the results of all the queries is our answer. It's easy to see that there will be no more than queries and add operations.The remaining part is designing the structure.It can be done in many ways. One of the ways: We have small structures with sizes equals to powers of two; Each structure — it's two-dimensional segments tree; We can add one element in a following way: if there is no substructure with size 1, than add it; else get structures with sizes 1, 2, 4, ..., 2k and all its' elements and rebuild the structure with size 2k + 1; Shifting — just remember shifting vector for every substructure; Answering the query — go over all substructures and add the results. Editorial was prepared by sdya and Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5006
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    ll maxn = opt<ll>(\"maxn\", 100000000000000LL);\n    ll n = opt<ll>(\"n\", -1); // If n is provided, output it directly.\n\n    if (n != -1) {\n        // Output n directly.\n        printf(\"%lld\\n\", n);\n        return 0;\n    }\n\n    if (type == \"random\") {\n        // Generate a random n between 1 and maxn.\n        n = rnd.next(1LL, maxn);\n        printf(\"%lld\\n\", n);\n    } else if (type == \"nondiv3\") {\n        // Generate a random n not divisible by 3.\n        n = rnd.next(1LL, maxn);\n        if (n % 3 == 0) n += 1;\n        if (n > maxn) n -= 3;\n        if (n < 1) n = 1;\n        if (n % 3 == 0) n += 2;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"nosolution\") {\n        // n is not divisible by 3, so there are no solutions.\n        n = rnd.next(1LL, maxn);\n        n = n - n % 3 + 1;\n        if (n % 3 == 0) n += 1;\n        if (n > maxn) n -= 3;\n        if (n < 1) n = 1;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"multiple_solutions\") {\n        // Generate n where the number of solutions is large.\n        vector<ll> m_candidates = {60, 360, 840, 1260, 1680, 2520, 5040, 7560, 9240, 13860, 18480, 27720};\n        ll m = m_candidates[rnd.next(0, (int)m_candidates.size() - 1)];\n        ll k = rnd.next(1LL, maxn / (m * 3));\n        n = m * 3 * k;\n        if (n > maxn) n = maxn;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"huge_solutions\") {\n        // Use a large m with many divisors to get many solutions.\n        ll m = 93163582512000LL; // From the sample input with a large number of solutions.\n        n = m * 3;\n        if (n > maxn) n = maxn;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"single_solution\") {\n        // Generate n with only one solution, e.g., m = 8.\n        ll m = 8;\n        n = m * 3;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"maxn\") {\n        // Output the maximum n.\n        n = maxn;\n        printf(\"%lld\\n\", n);\n    } else {\n        // Default to random n.\n        n = rnd.next(1LL, maxn);\n        printf(\"%lld\\n\", n);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    ll maxn = opt<ll>(\"maxn\", 100000000000000LL);\n    ll n = opt<ll>(\"n\", -1); // If n is provided, output it directly.\n\n    if (n != -1) {\n        // Output n directly.\n        printf(\"%lld\\n\", n);\n        return 0;\n    }\n\n    if (type == \"random\") {\n        // Generate a random n between 1 and maxn.\n        n = rnd.next(1LL, maxn);\n        printf(\"%lld\\n\", n);\n    } else if (type == \"nondiv3\") {\n        // Generate a random n not divisible by 3.\n        n = rnd.next(1LL, maxn);\n        if (n % 3 == 0) n += 1;\n        if (n > maxn) n -= 3;\n        if (n < 1) n = 1;\n        if (n % 3 == 0) n += 2;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"nosolution\") {\n        // n is not divisible by 3, so there are no solutions.\n        n = rnd.next(1LL, maxn);\n        n = n - n % 3 + 1;\n        if (n % 3 == 0) n += 1;\n        if (n > maxn) n -= 3;\n        if (n < 1) n = 1;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"multiple_solutions\") {\n        // Generate n where the number of solutions is large.\n        vector<ll> m_candidates = {60, 360, 840, 1260, 1680, 2520, 5040, 7560, 9240, 13860, 18480, 27720};\n        ll m = m_candidates[rnd.next(0, (int)m_candidates.size() - 1)];\n        ll k = rnd.next(1LL, maxn / (m * 3));\n        n = m * 3 * k;\n        if (n > maxn) n = maxn;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"huge_solutions\") {\n        // Use a large m with many divisors to get many solutions.\n        ll m = 93163582512000LL; // From the sample input with a large number of solutions.\n        n = m * 3;\n        if (n > maxn) n = maxn;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"single_solution\") {\n        // Generate n with only one solution, e.g., m = 8.\n        ll m = 8;\n        n = m * 3;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"maxn\") {\n        // Output the maximum n.\n        n = maxn;\n        printf(\"%lld\\n\", n);\n    } else {\n        // Default to random n.\n        n = rnd.next(1LL, maxn);\n        printf(\"%lld\\n\", n);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -maxn 100\n./gen -type random -maxn 1000\n./gen -type random -maxn 1000000\n./gen -type random -maxn 1000000000\n./gen -type random -maxn 100000000000000\n./gen -type nondiv3 -maxn 100\n./gen -type nondiv3 -maxn 1000\n./gen -type nondiv3 -maxn 1000000\n./gen -type nondiv3 -maxn 1000000000\n./gen -type nondiv3 -maxn 100000000000000\n./gen -type nosolution -maxn 100\n./gen -type nosolution -maxn 1000\n./gen -type nosolution -maxn 1000000\n./gen -type nosolution -maxn 1000000000\n./gen -type nosolution -maxn 100000000000000\n./gen -type multiple_solutions -maxn 1000000\n./gen -type multiple_solutions -maxn 1000000000\n./gen -type multiple_solutions -maxn 100000000000000\n./gen -type huge_solutions -maxn 100000000000000\n./gen -type single_solution\n./gen -type maxn\n./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:30.310895",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "293/D",
      "title": "D. Ксения и квадрат",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано целое число n (3 ≤ n ≤ 105) — количество вершин выпуклого многоугольника Ксении. В следующих n строках заданы координаты вершин многоугольника в порядке некоторого обхода. В i-ой строке записаны целые числа xi, yi (|xi|, |yi| ≤ 106) — координаты i-ой в порядке обхода вершины.",
      "output_spec": "Выходные данныеВыведите единственное вещественное число — искомое математическое ожидание. Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать30 05 55 0Выходные данныеСкопировать4.6666666667Входные данныеСкопировать4-1 34 56 23 -5Выходные данныеСкопировать8.1583333333Входные данныеСкопировать317 136859 93716 641Выходные данныеСкопировать66811.3704155169",
      "description": "D. Ксения и квадрат\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано целое число n (3 ≤ n ≤ 105) — количество вершин выпуклого многоугольника Ксении. В следующих n строках заданы координаты вершин многоугольника в порядке некоторого обхода. В i-ой строке записаны целые числа xi, yi (|xi|, |yi| ≤ 106) — координаты i-ой в порядке обхода вершины.\n\nВходные данные\n\nВыходные данныеВыведите единственное вещественное число — искомое математическое ожидание. Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать30 05 55 0Выходные данныеСкопировать4.6666666667Входные данныеСкопировать4-1 34 56 23 -5Выходные данныеСкопировать8.1583333333Входные данныеСкопировать317 136859 93716 641Выходные данныеСкопировать66811.3704155169\n\nВходные данныеСкопировать30 05 55 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4.6666666667\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4-1 34 56 23 -5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8.1583333333\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать317 136859 93716 641\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать66811.3704155169\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces",
          "content": "Всем привет!Сегодня состоится второй раунд Всероссийского Открытого Чемпионата по программированию \"КРОК-2013\". Раунд для вас готовили: sdya, Seyaua, Gerald и, как обычно, задачи на английский переводила Delinur.Приятная новость для тех, кто не попал в лучшие 400 участников в предыдущем раунде — сегодня каждый может поучаствовать вне конкурса. При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.Официальным участникам напоминаем, что: Все участники чемпионата должны быть не моложе 18 лет на момент регистрации Финал чемпионата состоится 16 и 17 мая в Москве в офисе компании КРОК (50 участников) Проживание во время финала будет оплачено компанией КРОК Для граждан Российской Федерации: организаторы покроют транспортные расходы по территории РФ, транспортные расходы не по территории РФ — по согласованию (возможно, частично) Финалисты должны подтвердить свое участие до 2 мая И небольшой бонус: лучшие 200 официальных участников чемпионата получат футболки!Желаем всем получить удовольствие от решения задач ну и, конечно, удачи!UPD: Разбалловка по задачам сегодня будет немножко отличаться от стандартной: 500-1500-1500-2000-2500 для первого дивизиона и 500-1000-1500-2500-2500 для второго.UPD2: Мы приносим свои извинения за технические неполадки во время раунда. Посовещавшись, мы решили, что соревнование должно быть рейтинговым. А результаты соревнования будут учитываться в отборе на финал чемпионата КРОК.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1467
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 — Разбор - Codeforces",
          "content": "A Div 2Если aj делится на ai, то тогда ai ≤ aj. Тогда число, на которое будут делиться все остальные числа будет не более чем любое выбранное число. То есть единственный возможный кандидат — это минимум в массиве. Поэтому просто проверим, что все элементы массива делятся на минимальный элемент.B Div 2Легко видеть, что Ксюша не сможет закончить ее путешествие, если существует последовательность подряд идущих # длиное более чем k.C Div 2 / A Div 1Первое наблюдение: мы не будем волноваться о том, как выглядят строки на самом деле, вся информация, которая нам нужна — это количество пар-символов вида: {0, 0}, {0, 1}, {1, 0}, {1, 1}. Посчитаем эти количества и будем следовать следующему жадному алгоритму:Для первого игрока: будем брать сначала {1, 1}, если их нет, то {1,0}. Если их нет, то {0, 1} и, в последнюю очередь, будем брать {0, 0}.Для второго игрока похожая стратегия: сначала {1, 1}, потом {0, 1}, потом {1, 0} и, в последнюю очередь, {0, 0}.После этого сравним у кого получилось больше единичек.D Div 2 / B Div 1Любой путь из верхней левой клетки в правую нижнюю состоит ровно из n + m - 1 клеток. И все они должны быть покрашены в разные цвета. Значит n + m - 1 ≤ k. Исходя из маленьких ограничений на k можно предположить, что брут-форс будет работать. Единственная оптимизация для получения действительно правильного решения — это некоторая канонизация раскрасок. Будем идти по всем клеткам в некотором порядке и красить их согласно следующим условиям. Если i > j, тогда цвет i встречается позже цвета j. После такого перебора мы получим примерно миллион различных шаблонов для максимального теста.Далее, просто будем сопоставлять уже покрашенные клетки с каждым шаблоном и считать, сколько различных перестановок цветов подходят к данному шаблону.E Div 2 / C Div 1После прочтения условия, можно понять, что все, что нам нужно — это посчитать количество решений уравнения (a + b + c)3 - a3 - b3 - c3 = n в положительных целых числах.Ключевое наблюдение это: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, после чего мы можем просто вычислять все делители числа и идти по всем делителям x = a + b, таким что ? далее будем идти по делителям y = (a + c) ≥ x, где и в конце будем вычислять z = (b + c), такое что .После этого, решим систему a + b = x, a + c = y, b + c = z и добавим количество подходящих решений к ответу.D Div 1Можно заметить, что в этой задаче просят посчитать для всех целых точек внутри многоугольника (или на его границе). Можно заметить, что мы можем обрабатывать иксы и игреки независимо.Для каждого x определим yleft, yright таким образом, что все точки (x, y), где yleft ≤ y ≤ yright лежат внутри многоугольника и отрезок [yleft, yright] максимально возможный.Теперь будем считать, что мы имеем a1, a2, ..., ak различных точек для каждого фиксированного x (a1 соответствует x =  - 106, a2 соответствует x =  - 106 + 1 и так далее).Теперь требуемый ответ это a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... Можно заметить, что (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,и так далее.Поэтому достаточно предпросчитать частичные суммы вида a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (разность между двумя соседними суммами составляет 2(ai + ... + a1), поэтому мы можем делать это за O(k)).После предпросчета достаточно сложить полученные результаты.E Div 1Будем считать что у нас есть структура данных, которая позволяет осуществлять следующие операции: добавить точку (x, y) в структуру; сдвинуть все точки структуры на вектор (dx, dy); узнать как много точек (x,y), удовлетворяющих x ≤ xbound, y ≤ ybound; получить все элементы, которые на данный момент находятся в структуре; Для каждой вершины дерева мы будем хранить указатель на структуру такого вида.ОБъясним, как нужно обновлять структуры. Мы будем обрабатывать все вершины в порядке обхода в глубине, и если мы находимся в листе, то мы будем создавать структуру с единственным элементом (0, 0).В противном же случае, мы будем сортировать структуры сыновей по их размеру в убывающем порядке и будем присваивать указатель наибольшей структуры указателю на текущую вершину (здесь нужно не забыть сдвигать структуру на (1, вес ребра)).После этого будем идти по всем сыновьям вершины и делать следующее: Сдвинем структуру на (1, вес ребра); Возьмем все элементы структуры; Для каждого элемента (x, y) ответим на запрос xbound = L - x, ybound = W - y (используем родительскую структуру); Добавим элементы по одному в структуру; После этого ответим на запрос xbound = L, ybound = W и добавим элемент (0, 0).Сумма полученных результатов по всем запросам и будет ответом. Легко видеть, что мы совершим не более чем запросов и операций добавления.Осталось только объяснить, как создать нужную нам структуру данных.Существует несколько способов сделать это, один из них: Будем иметь маленькие подструктуры у которых размеры являются степенями двойки; Каждая структура — это двумерное дерево отрезков; Мы можем добавлять элемент следующим образом: если нет подструктуры размера 1, тогда создадим ее, иначе же возьмем все структуры размерами 1, 2, 4, ..., 2k и перестроим в структуру размера 2k + 1. Сдвиг: достаточно помнить вектор сдвига для каждой подструктуры; Ответ на запрос: идем по подструктурам и суммируем результаты. Разбор задач был подготовлен sdya и Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5301
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 1",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 2",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 3",
          "code": "dp[0][1][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 4",
          "code": "dp[1][0][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 5",
          "code": "dp[1][1][{1,2,3}]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 6",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 7",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 8",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 9",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 10",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 11",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 12",
          "code": "При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 13",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 14",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 15",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 16",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nll cross(pii a, pii b, pii c) {\n    // Cross product of vectors (b - a) and (c - b)\n    ll x1 = b.first - a.first;\n    ll y1 = b.second - a.second;\n    ll x2 = c.first - b.first;\n    ll y2 = c.second - b.second;\n    return x1 * y2 - x2 * y1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<pii> points;\n    for(int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        points.push_back({x, y});\n    }\n    // Check for convexity\n    int sign = 0;\n    for(int i = 0; i < n; i++) {\n        pii a = points[i];\n        pii b = points[(i + 1) % n];\n        pii c = points[(i + 2) % n];\n        ll cp = cross(a, b, c);\n        if(cp == 0) {\n            continue; // Colinear points, skip\n        } else {\n            int current_sign = (cp > 0) ? 1 : -1;\n            if(sign == 0) {\n                sign = current_sign;\n            } else {\n                ensuref(sign == current_sign, \"Polygon is not convex at vertex %d\", i + 1);\n            }\n        }\n    }\n    // Check area is non-zero\n    ll area2 = 0; // Double the area\n    for(int i = 0; i < n; i++) {\n        pii a = points[i];\n        pii b = points[(i + 1) % n];\n        area2 += (ll)a.first * b.second;\n        area2 -= (ll)a.second * b.first;\n    }\n    ensuref(area2 != 0, \"Polygon has zero area\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nll cross(pii a, pii b, pii c) {\n    // Cross product of vectors (b - a) and (c - b)\n    ll x1 = b.first - a.first;\n    ll y1 = b.second - a.second;\n    ll x2 = c.first - b.first;\n    ll y2 = c.second - b.second;\n    return x1 * y2 - x2 * y1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<pii> points;\n    for(int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        points.push_back({x, y});\n    }\n    // Check for convexity\n    int sign = 0;\n    for(int i = 0; i < n; i++) {\n        pii a = points[i];\n        pii b = points[(i + 1) % n];\n        pii c = points[(i + 2) % n];\n        ll cp = cross(a, b, c);\n        if(cp == 0) {\n            continue; // Colinear points, skip\n        } else {\n            int current_sign = (cp > 0) ? 1 : -1;\n            if(sign == 0) {\n                sign = current_sign;\n            } else {\n                ensuref(sign == current_sign, \"Polygon is not convex at vertex %d\", i + 1);\n            }\n        }\n    }\n    // Check area is non-zero\n    ll area2 = 0; // Double the area\n    for(int i = 0; i < n; i++) {\n        pii a = points[i];\n        pii b = points[(i + 1) % n];\n        area2 += (ll)a.first * b.second;\n        area2 -= (ll)a.second * b.first;\n    }\n    ensuref(area2 != 0, \"Polygon has zero area\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nll cross(pii a, pii b, pii c) {\n    // Cross product of vectors (b - a) and (c - b)\n    ll x1 = b.first - a.first;\n    ll y1 = b.second - a.second;\n    ll x2 = c.first - b.first;\n    ll y2 = c.second - b.second;\n    return x1 * y2 - x2 * y1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<pii> points;\n    for(int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        points.push_back({x, y});\n    }\n    // Check for convexity\n    int sign = 0;\n    for(int i = 0; i < n; i++) {\n        pii a = points[i];\n        pii b = points[(i + 1) % n];\n        pii c = points[(i + 2) % n];\n        ll cp = cross(a, b, c);\n        if(cp == 0) {\n            continue; // Colinear points, skip\n        } else {\n            int current_sign = (cp > 0) ? 1 : -1;\n            if(sign == 0) {\n                sign = current_sign;\n            } else {\n                ensuref(sign == current_sign, \"Polygon is not convex at vertex %d\", i + 1);\n            }\n        }\n    }\n    // Check area is non-zero\n    ll area2 = 0; // Double the area\n    for(int i = 0; i < n; i++) {\n        pii a = points[i];\n        pii b = points[(i + 1) % n];\n        area2 += (ll)a.first * b.second;\n        area2 -= (ll)a.second * b.first;\n    }\n    ensuref(area2 != 0, \"Polygon has zero area\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single convex polygon of non-zero area.\n\n  Usage:\n     ./gen -n <number_of_vertices> -type <triangle|rectangle|regular|random>\n\n  Details of each type:\n    1) \"triangle\"  => Always outputs exactly 3 vertices (ignores n).\n    2) \"rectangle\" => Always outputs exactly 4 vertices (ignores n).\n    3) \"regular\"   => Outputs n vertices of a regular n-gon (with some fixed radius).\n    4) \"random\"    => Outputs a random convex polygon with n vertices\n                      (coordinates in the range [-1,000,000..1,000,000]).\n*/\n\nstatic const double PI = acos(-1.0);\n\n/* Compute signed area (using cross product) to check if area > 0 and orientation is consistent. */\ndouble polygonArea(const vector<pair<int,int>> &pts) {\n    long long area2 = 0; // twice the area\n    int n = (int)pts.size();\n    for(int i = 0; i < n; i++){\n        // Current (x_i, y_i)\n        long long x1 = pts[i].first;\n        long long y1 = pts[i].second;\n        // Next (x_{i+1}, y_{i+1})\n        long long x2 = pts[(i+1)%n].first;\n        long long y2 = pts[(i+1)%n].second;\n        area2 += (x1 * y2 - y1 * x2);\n    }\n    return 0.5 * (double)area2;\n}\n\n/* Return true if the polygon is strictly convex (assuming no three collinear consecutive vertices).\n   We check that consecutive cross products have the same sign (positive or negative).\n   For a valid convex polygon in CCW order, each cross should be >= 0,\n   we want strictly > 0 to avoid area=0 sub-parts. But a tiny failure is extremely unlikely.\n*/\nbool isConvexCCW(const vector<pair<int,int>> &pts){\n    int n = (int)pts.size();\n    if(n < 3) return false;\n    // We check the sign of cross((p2 - p1), (p3 - p2)) for i in [0..n-1].\n    // Must all be > 0 for strictly convex CCW.\n    for(int i = 0; i < n; i++){\n        // previous, current, next\n        auto A = pts[(i + n - 1) % n];\n        auto B = pts[i];\n        auto C = pts[(i + 1) % n];\n        long long x1 = B.first - A.first;\n        long long y1 = B.second - A.second;\n        long long x2 = C.first - B.first;\n        long long y2 = C.second - B.second;\n        long long cross = x1 * y2 - y1 * x2;\n        if(cross <= 0){\n            return false;\n        }\n    }\n    return true;\n}\n\n/* Output a set of points (x, y) to stdout. */\nvoid outputPolygon(const vector<pair<int,int>> &pts){\n    // n\n    printf(\"%d\\n\", (int)pts.size());\n    // coordinates (either in CCW or CW order is fine).\n    for (auto &p : pts) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n}\n\n/* Generate a random triangle of nonzero area in range [-10,10]. */\nvector<pair<int,int>> genTriangle(){\n    vector<pair<int,int>> tri(3);\n    while(true){\n        for(int i=0; i<3; i++){\n            tri[i].first  = rnd.next(-10, 10);\n            tri[i].second = rnd.next(-10, 10);\n        }\n        // Check if area != 0\n        double area = fabs(polygonArea(tri));\n        if(area > 1e-9) {\n            // We can orient them CCW if needed\n            if(polygonArea(tri) < 0){\n                reverse(tri.begin(), tri.end());\n            }\n            break;\n        }\n    }\n    return tri;\n}\n\n/* Generate a random rectangle (4 vertices).\n   We'll pick two distinct X coords and two distinct Y coords and form a rectangle, \n   then possibly output them in CCW order.\n*/\nvector<pair<int,int>> genRectangle(){\n    // Distinct x and y from [-100..100], ensuring nonzero area\n    int x1 = rnd.next(-100, 100);\n    int x2 = rnd.next(-100, 100);\n    while(x2 == x1) x2 = rnd.next(-100, 100);\n    int y1 = rnd.next(-100, 100);\n    int y2 = rnd.next(-100, 100);\n    while(y2 == y1) y2 = rnd.next(-100, 100);\n\n    // sort so that x1 < x2, y1 < y2\n    if(x2 < x1) swap(x1, x2);\n    if(y2 < y1) swap(y1, y2);\n\n    // Build rectangle in CCW\n    vector<pair<int,int>> rect(4);\n    rect[0] = {x1, y1};\n    rect[1] = {x2, y1};\n    rect[2] = {x2, y2};\n    rect[3] = {x1, y2};\n\n    return rect;\n}\n\n/* Generate a regular n-gon of radius R=some fixed integer, centered at (0,0). */\nvector<pair<int,int>> genRegularPolygon(int n){\n    // We'll pick radius in [10..100] for variety\n    int R = rnd.next(10, 100);\n    // Build normal CCW order\n    vector<pair<int,int>> pts(n);\n    for(int i=0; i<n; i++){\n        double theta = 2.0*PI * (double)i / (double)n; // from 0..2pi\n        double x = R*cos(theta);\n        double y = R*sin(theta);\n        // Round to integer\n        int ix = (int)floor(x+0.5);\n        int iy = (int)floor(y+0.5);\n\n        pts[i] = {ix, iy};\n    }\n    // Check area, if somehow degenerate we can re-generate, but it's extremely unlikely.\n    if(polygonArea(pts) < 0) reverse(pts.begin(), pts.end());\n    return pts;\n}\n\n/*\n   Generate a random convex polygon with exactly n vertices.\n   We use a known \"angle + strictly increasing radius\" trick:\n\n   1) Generate n random angles in [0, 2π), store them in a vector \"angles\".\n   2) Generate n random radii in [1, MAX_R], store them in \"radii\".\n   3) Sort angles ascending, sort radii ascending.\n   4) Pair them up: vertex i = ( radii[i]*cos(angles[i]),  radii[i]*sin(angles[i]) ).\n   5) Round to integer, ensure we keep the polygon CCW. If degenerate, retry.\n\n   Usually, the chance of degeneracy is very small for a large range of radii/angles.\n*/\n\nvector<pair<int,int>> genRandomConvexPolygon(int n){\n    const int MAX_R = 999999; // so that we remain within ±1,000,000 after rounding\n    while(true){\n        vector<double> angles(n), radii(n);\n        for(int i=0; i<n; i++){\n            angles[i] = rnd.next(0.0, 2.0*PI);\n        }\n        sort(angles.begin(), angles.end());\n        // generate & sort radii\n        for(int i=0; i<n; i++){\n            // random radius in [1..MAX_R], we use next(1,MAX_R)\n            radii[i] = rnd.next(1, MAX_R);\n        }\n        sort(radii.begin(), radii.end());\n\n        // build polygon\n        vector<pair<int,int>> poly(n);\n        for(int i=0; i<n; i++){\n            double r = radii[i];\n            double a = angles[i];\n            double x = r*cos(a);\n            double y = r*sin(a);\n            // round\n            int ix = (int) floor(x + 0.5);\n            int iy = (int) floor(y + 0.5);\n            poly[i] = {ix, iy};\n        }\n\n        // Check area sign; if negative, reverse to make it CCW\n        double areaVal = polygonArea(poly);\n        if(fabs(areaVal) < 1e-9) {\n            // extremely unlikely degenerate case, re-generate\n            continue;\n        }\n        if(areaVal < 0) {\n            reverse(poly.begin(), poly.end());\n        }\n\n        // Extra check for convexity. Usually it should be strictly convex.\n        if(isConvexCCW(poly)) {\n            return poly;\n        }\n        // Otherwise, re-generate (rare).\n    }\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> polygon;\n\n    if(type == \"triangle\") {\n        // Always produce 3 vertices\n        polygon = genTriangle();\n    } \n    else if(type == \"rectangle\") {\n        // Always produce 4 vertices\n        polygon = genRectangle();\n    }\n    else if(type == \"regular\") {\n        // Produce a regular n-gon\n        // n MUST be >= 3 in the problem constraints\n        if(n < 3) {\n            // If user tries an invalid n, clamp to 3 to avoid invalid polygon\n            n = 3;\n        }\n        polygon = genRegularPolygon(n);\n    }\n    else {\n        // \"random\" convex polygon with exactly n vertices\n        // n must be at least 3\n        if(n < 3) {\n            n = 3;\n        }\n        polygon = genRandomConvexPolygon(n);\n    }\n\n    // Output result\n    outputPolygon(polygon);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single convex polygon of non-zero area.\n\n  Usage:\n     ./gen -n <number_of_vertices> -type <triangle|rectangle|regular|random>\n\n  Details of each type:\n    1) \"triangle\"  => Always outputs exactly 3 vertices (ignores n).\n    2) \"rectangle\" => Always outputs exactly 4 vertices (ignores n).\n    3) \"regular\"   => Outputs n vertices of a regular n-gon (with some fixed radius).\n    4) \"random\"    => Outputs a random convex polygon with n vertices\n                      (coordinates in the range [-1,000,000..1,000,000]).\n*/\n\nstatic const double PI = acos(-1.0);\n\n/* Compute signed area (using cross product) to check if area > 0 and orientation is consistent. */\ndouble polygonArea(const vector<pair<int,int>> &pts) {\n    long long area2 = 0; // twice the area\n    int n = (int)pts.size();\n    for(int i = 0; i < n; i++){\n        // Current (x_i, y_i)\n        long long x1 = pts[i].first;\n        long long y1 = pts[i].second;\n        // Next (x_{i+1}, y_{i+1})\n        long long x2 = pts[(i+1)%n].first;\n        long long y2 = pts[(i+1)%n].second;\n        area2 += (x1 * y2 - y1 * x2);\n    }\n    return 0.5 * (double)area2;\n}\n\n/* Return true if the polygon is strictly convex (assuming no three collinear consecutive vertices).\n   We check that consecutive cross products have the same sign (positive or negative).\n   For a valid convex polygon in CCW order, each cross should be >= 0,\n   we want strictly > 0 to avoid area=0 sub-parts. But a tiny failure is extremely unlikely.\n*/\nbool isConvexCCW(const vector<pair<int,int>> &pts){\n    int n = (int)pts.size();\n    if(n < 3) return false;\n    // We check the sign of cross((p2 - p1), (p3 - p2)) for i in [0..n-1].\n    // Must all be > 0 for strictly convex CCW.\n    for(int i = 0; i < n; i++){\n        // previous, current, next\n        auto A = pts[(i + n - 1) % n];\n        auto B = pts[i];\n        auto C = pts[(i + 1) % n];\n        long long x1 = B.first - A.first;\n        long long y1 = B.second - A.second;\n        long long x2 = C.first - B.first;\n        long long y2 = C.second - B.second;\n        long long cross = x1 * y2 - y1 * x2;\n        if(cross <= 0){\n            return false;\n        }\n    }\n    return true;\n}\n\n/* Output a set of points (x, y) to stdout. */\nvoid outputPolygon(const vector<pair<int,int>> &pts){\n    // n\n    printf(\"%d\\n\", (int)pts.size());\n    // coordinates (either in CCW or CW order is fine).\n    for (auto &p : pts) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n}\n\n/* Generate a random triangle of nonzero area in range [-10,10]. */\nvector<pair<int,int>> genTriangle(){\n    vector<pair<int,int>> tri(3);\n    while(true){\n        for(int i=0; i<3; i++){\n            tri[i].first  = rnd.next(-10, 10);\n            tri[i].second = rnd.next(-10, 10);\n        }\n        // Check if area != 0\n        double area = fabs(polygonArea(tri));\n        if(area > 1e-9) {\n            // We can orient them CCW if needed\n            if(polygonArea(tri) < 0){\n                reverse(tri.begin(), tri.end());\n            }\n            break;\n        }\n    }\n    return tri;\n}\n\n/* Generate a random rectangle (4 vertices).\n   We'll pick two distinct X coords and two distinct Y coords and form a rectangle, \n   then possibly output them in CCW order.\n*/\nvector<pair<int,int>> genRectangle(){\n    // Distinct x and y from [-100..100], ensuring nonzero area\n    int x1 = rnd.next(-100, 100);\n    int x2 = rnd.next(-100, 100);\n    while(x2 == x1) x2 = rnd.next(-100, 100);\n    int y1 = rnd.next(-100, 100);\n    int y2 = rnd.next(-100, 100);\n    while(y2 == y1) y2 = rnd.next(-100, 100);\n\n    // sort so that x1 < x2, y1 < y2\n    if(x2 < x1) swap(x1, x2);\n    if(y2 < y1) swap(y1, y2);\n\n    // Build rectangle in CCW\n    vector<pair<int,int>> rect(4);\n    rect[0] = {x1, y1};\n    rect[1] = {x2, y1};\n    rect[2] = {x2, y2};\n    rect[3] = {x1, y2};\n\n    return rect;\n}\n\n/* Generate a regular n-gon of radius R=some fixed integer, centered at (0,0). */\nvector<pair<int,int>> genRegularPolygon(int n){\n    // We'll pick radius in [10..100] for variety\n    int R = rnd.next(10, 100);\n    // Build normal CCW order\n    vector<pair<int,int>> pts(n);\n    for(int i=0; i<n; i++){\n        double theta = 2.0*PI * (double)i / (double)n; // from 0..2pi\n        double x = R*cos(theta);\n        double y = R*sin(theta);\n        // Round to integer\n        int ix = (int)floor(x+0.5);\n        int iy = (int)floor(y+0.5);\n\n        pts[i] = {ix, iy};\n    }\n    // Check area, if somehow degenerate we can re-generate, but it's extremely unlikely.\n    if(polygonArea(pts) < 0) reverse(pts.begin(), pts.end());\n    return pts;\n}\n\n/*\n   Generate a random convex polygon with exactly n vertices.\n   We use a known \"angle + strictly increasing radius\" trick:\n\n   1) Generate n random angles in [0, 2π), store them in a vector \"angles\".\n   2) Generate n random radii in [1, MAX_R], store them in \"radii\".\n   3) Sort angles ascending, sort radii ascending.\n   4) Pair them up: vertex i = ( radii[i]*cos(angles[i]),  radii[i]*sin(angles[i]) ).\n   5) Round to integer, ensure we keep the polygon CCW. If degenerate, retry.\n\n   Usually, the chance of degeneracy is very small for a large range of radii/angles.\n*/\n\nvector<pair<int,int>> genRandomConvexPolygon(int n){\n    const int MAX_R = 999999; // so that we remain within ±1,000,000 after rounding\n    while(true){\n        vector<double> angles(n), radii(n);\n        for(int i=0; i<n; i++){\n            angles[i] = rnd.next(0.0, 2.0*PI);\n        }\n        sort(angles.begin(), angles.end());\n        // generate & sort radii\n        for(int i=0; i<n; i++){\n            // random radius in [1..MAX_R], we use next(1,MAX_R)\n            radii[i] = rnd.next(1, MAX_R);\n        }\n        sort(radii.begin(), radii.end());\n\n        // build polygon\n        vector<pair<int,int>> poly(n);\n        for(int i=0; i<n; i++){\n            double r = radii[i];\n            double a = angles[i];\n            double x = r*cos(a);\n            double y = r*sin(a);\n            // round\n            int ix = (int) floor(x + 0.5);\n            int iy = (int) floor(y + 0.5);\n            poly[i] = {ix, iy};\n        }\n\n        // Check area sign; if negative, reverse to make it CCW\n        double areaVal = polygonArea(poly);\n        if(fabs(areaVal) < 1e-9) {\n            // extremely unlikely degenerate case, re-generate\n            continue;\n        }\n        if(areaVal < 0) {\n            reverse(poly.begin(), poly.end());\n        }\n\n        // Extra check for convexity. Usually it should be strictly convex.\n        if(isConvexCCW(poly)) {\n            return poly;\n        }\n        // Otherwise, re-generate (rare).\n    }\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> polygon;\n\n    if(type == \"triangle\") {\n        // Always produce 3 vertices\n        polygon = genTriangle();\n    } \n    else if(type == \"rectangle\") {\n        // Always produce 4 vertices\n        polygon = genRectangle();\n    }\n    else if(type == \"regular\") {\n        // Produce a regular n-gon\n        // n MUST be >= 3 in the problem constraints\n        if(n < 3) {\n            // If user tries an invalid n, clamp to 3 to avoid invalid polygon\n            n = 3;\n        }\n        polygon = genRegularPolygon(n);\n    }\n    else {\n        // \"random\" convex polygon with exactly n vertices\n        // n must be at least 3\n        if(n < 3) {\n            n = 3;\n        }\n        polygon = genRandomConvexPolygon(n);\n    }\n\n    // Output result\n    outputPolygon(polygon);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands to run this generator with different parameters.\n# Each command prints one test case (one polygon) to standard output.\n\n./gen -n 3 -type triangle\n./gen -n 10 -type triangle\n./gen -n 4 -type rectangle\n./gen -n 6 -type rectangle\n./gen -n 3 -type regular\n./gen -n 4 -type regular\n./gen -n 7 -type regular\n./gen -n 10 -type regular\n./gen -n 3 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 200 -type random\n./gen -n 500 -type random\n./gen -n 999 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n./gen -n 9999 -type random\n./gen -n 10000 -type random\n./gen -n 20000 -type random\n./gen -n 50000 -type random\n./gen -n 99999 -type random\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:32.569802",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "293/E",
      "title": "E. Close Vertices",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, l and w (1 ≤ n ≤ 105, 1 ≤ l ≤ n, 0 ≤ w ≤ 109). The next n - 1 lines contain the descriptions of the tree edges. The i-th line contains two integers pi, wi (1 ≤ pi < (i + 1), 0 ≤ wi ≤ 104), that mean that the i-th edge connects vertex (i + 1) and pi and has weight wi.Consider the tree vertices indexed from 1 to n in some way.",
      "output_spec": "OutputPrint a single integer — the number of close pairs.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy4 4 61 31 41 3OutputCopy4InputCopy6 2 171 32 52 131 65 9OutputCopy9",
      "description": "E. Close Vertices\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, l and w (1 ≤ n ≤ 105, 1 ≤ l ≤ n, 0 ≤ w ≤ 109). The next n - 1 lines contain the descriptions of the tree edges. The i-th line contains two integers pi, wi (1 ≤ pi < (i + 1), 0 ≤ wi ≤ 104), that mean that the i-th edge connects vertex (i + 1) and pi and has weight wi.Consider the tree vertices indexed from 1 to n in some way.\n\nOutputPrint a single integer — the number of close pairs.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy4 4 61 31 41 3OutputCopy4InputCopy6 2 171 32 52 131 65 9OutputCopy9\n\nInputCopy4 4 61 31 41 3\n\nOutputCopy4\n\nInputCopy6 2 171 32 52 131 65 9\n\nOutputCopy9",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Croc Champ 2013 — Round 2 — Editorial - Codeforces",
          "content": "Here you can find the solutions for the problems from the past round. You can ask questions in the comments below.A Div 2If ai divide aj than ai ≤ aj. So the number which will divide every other number should be less than or equal to every other number, so the only possible candidate — it's the minimum in the array. So just check whether all elements are divisible by the minimal one.B Div 2Easy to see, that Ksusha is unable to complete her journey if there is a sequence of consecutive # with length more than k.C Div 2 / A Div 1The first observation — we don't care about the actual strings, all information we need — number of pairs {0,0}, {0,1}, {1,0}, {1,1}. Count that and then just follow the greedy algorithm, for the first player: try to get a index with {1,1} if there are some, than {1,0}, than {0,1} and than {0,0}.For the second player similar strategy: first {1,1}, than {0,1}, than {1,0}, than {0,0}.After that just compare who has more 1.D Div 2 / B Div 1Every path from the topleft cell to the bottomright cell contain exactly n + m - 1 cells. And all of the should be of different color. So n + m - 1 ≤ k. Due to the small constraints for k we may assume that bruteforce might work. The only optimization to get the correct solution is some canonization of the colors. So let's go over all of the cells in some order and color them but with following condition. If i > j, than color i appeared later than color j. If we bruteforce in such way we will have about 1 million different patterns for max case. Than just match them with already painted cells and calculate for each pattern how many different permutations of color we can apply to it.E Div 2 / C Div 1After reading the problem statement one can understand that all we need is to calculate the number of positive integer solutions of equation: (a + b + c)3 - a3 - b3 - c3 = n.The key observation is: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, after that simply calculate all divisors of and then first go over all x = a + b, such that then go over all y = (a + c) ≥ x, such that and then determine z = (b + c), such that . After that we need to solve the system a + b = x, a + c = y, b + c = z and find out how many solutions it adds.D Div 1We can see that we asked to calculate for all integer points inside the polygon or on its border. We can see that we can process Xs and Ys independently.For each x determine yleft, yright, such that all points (x, y) where yleft ≤ y ≤ yright are inside the polygon and the range [yleft, yright] is as maximal as possible. Now let's assume that we have a1, a2, ..., ak different points with fixed x coordinate (a1 stands for x =  - 106, a2 for x =  - 106 + 1 and so on).Now the required answer is a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... We can see that: (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,and so on.So we can precalculate partial sums like a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (the difference between two consecutive sums is 2(ai + ... + a1), so we can do that in O(k) time).After this precomputation we just need to sum the results.E Div 1Let's assume that we have a data structure which can perform such operations as: — add point (x,y) to the structure; shift all points in the structure by vector (dx,dy); answer how many point (x,y) are in the structure where x ≤ xbound, y ≤ ybound; get all elements which are now in the structure; For every vertex of the tree we will store the pointer to such structure.How we update the structures. We will proceed all the vertices in dfs order, if we are in a leaf node, than we create structure which contains only one element (0,0).Otherwise we will sort the children structures by it's size in decreasing order and assign the pointer of the biggest structure to the pointer of the current vertex (Don't forget to shift the structure by (1, weight of edge)).After that we will go over all other children one by one and do the following thing: Shift the structure by (1, weight of edge); Get all elements from the structure; For every element (x,y) answer the query xbound = L - x, ybound = W - y (we use parent's structure); Add elements one by one into the structure; After that answer the query xbound = L, ybound = W and add element (0,0).The sum of the results of all the queries is our answer. It's easy to see that there will be no more than queries and add operations.The remaining part is designing the structure.It can be done in many ways. One of the ways: We have small structures with sizes equals to powers of two; Each structure — it's two-dimensional segments tree; We can add one element in a following way: if there is no substructure with size 1, than add it; else get structures with sizes 1, 2, 4, ..., 2k and all its' elements and rebuild the structure with size 2k + 1; Shifting — just remember shifting vector for every substructure; Answering the query — go over all substructures and add the results. Editorial was prepared by sdya and Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5006
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    // Check for cycles\n    ensuref(x != y, \"The graph contains a cycle between nodes %d and %d\", x, y);\n    parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, n, \"l\");\n    inf.readSpace();\n    int w = inf.readInt(0, 1000000000, \"w\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 1; i <= n - 1; i++) {\n        int pi = inf.readInt(1, i, \"pi\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 10000, \"wi\");\n        inf.readEoln();\n\n        int u = i + 1;\n        int v = pi;\n        unite(u, v);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"The graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    // Check for cycles\n    ensuref(x != y, \"The graph contains a cycle between nodes %d and %d\", x, y);\n    parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, n, \"l\");\n    inf.readSpace();\n    int w = inf.readInt(0, 1000000000, \"w\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 1; i <= n - 1; i++) {\n        int pi = inf.readInt(1, i, \"pi\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 10000, \"wi\");\n        inf.readEoln();\n\n        int u = i + 1;\n        int v = pi;\n        unite(u, v);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"The graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    // Check for cycles\n    ensuref(x != y, \"The graph contains a cycle between nodes %d and %d\", x, y);\n    parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, n, \"l\");\n    inf.readSpace();\n    int w = inf.readInt(0, 1000000000, \"w\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 1; i <= n - 1; i++) {\n        int pi = inf.readInt(1, i, \"pi\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 10000, \"wi\");\n        inf.readEoln();\n\n        int u = i + 1;\n        int v = pi;\n        unite(u, v);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"The graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int w = opt<int>(\"w\");\n    string tree_type = opt<string>(\"type\", \"random\");\n    string weight_type = opt<string>(\"weight_type\", \"random\");\n\n    vector<int> p(n + 1); // parent of node i, for i from 2 to n.\n\n    if (tree_type == \"chain\") {\n        // Chain: each node connects to the previous one\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Star: All nodes connect to node 1\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (tree_type == \"binary\") {\n        // Balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i / 2;\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree: connect to a node near the root\n        for (int i = 2; i <= n; ++i) {\n            p[i] = max(1, i - rnd.next(1, min(i - 1, 5)));\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    vector<int> wi(n + 1); // Edge weights wi[2..n]\n\n    if (weight_type == \"zero\") {\n        for (int i = 2; i <= n; ++i) {\n            wi[i] = 0;\n        }\n    } else if (weight_type == \"max\") {\n        for (int i = 2; i <= n; ++i) {\n            wi[i] = 10000;\n        }\n    } else if (weight_type == \"increasing\") {\n        wi[2] = rnd.next(0, 1000);\n        for (int i = 3; i <= n; ++i) {\n            wi[i] = min(10000, wi[i - 1] + rnd.next(0, 1000));\n        }\n    } else if (weight_type == \"decreasing\") {\n        wi[2] = rnd.next(5000, 10000);\n        for (int i = 3; i <= n; ++i) {\n            wi[i] = max(0, wi[i - 1] - rnd.next(0, 1000));\n        }\n    } else {\n        // Random weights\n        for (int i = 2; i <= n; ++i) {\n            wi[i] = rnd.next(0, 10000);\n        }\n    }\n\n    // Output n, l, w\n    printf(\"%d %d %d\\n\", n, l, w);\n\n    // Output edges\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d %d\\n\", p[i], wi[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int w = opt<int>(\"w\");\n    string tree_type = opt<string>(\"type\", \"random\");\n    string weight_type = opt<string>(\"weight_type\", \"random\");\n\n    vector<int> p(n + 1); // parent of node i, for i from 2 to n.\n\n    if (tree_type == \"chain\") {\n        // Chain: each node connects to the previous one\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Star: All nodes connect to node 1\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (tree_type == \"binary\") {\n        // Balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i / 2;\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree: connect to a node near the root\n        for (int i = 2; i <= n; ++i) {\n            p[i] = max(1, i - rnd.next(1, min(i - 1, 5)));\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    vector<int> wi(n + 1); // Edge weights wi[2..n]\n\n    if (weight_type == \"zero\") {\n        for (int i = 2; i <= n; ++i) {\n            wi[i] = 0;\n        }\n    } else if (weight_type == \"max\") {\n        for (int i = 2; i <= n; ++i) {\n            wi[i] = 10000;\n        }\n    } else if (weight_type == \"increasing\") {\n        wi[2] = rnd.next(0, 1000);\n        for (int i = 3; i <= n; ++i) {\n            wi[i] = min(10000, wi[i - 1] + rnd.next(0, 1000));\n        }\n    } else if (weight_type == \"decreasing\") {\n        wi[2] = rnd.next(5000, 10000);\n        for (int i = 3; i <= n; ++i) {\n            wi[i] = max(0, wi[i - 1] - rnd.next(0, 1000));\n        }\n    } else {\n        // Random weights\n        for (int i = 2; i <= n; ++i) {\n            wi[i] = rnd.next(0, 10000);\n        }\n    }\n\n    // Output n, l, w\n    printf(\"%d %d %d\\n\", n, l, w);\n\n    // Output edges\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d %d\\n\", p[i], wi[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small tree, minimal l and w\n./gen -n 1 -l 1 -w 0 -type chain -weight_type zero\n./gen -n 2 -l 1 -w 0 -type chain -weight_type zero\n./gen -n 3 -l 1 -w 0 -type star -weight_type zero\n\n# Small tree, maximal l and w\n./gen -n 5 -l 5 -w 1000000000 -type star -weight_type zero\n\n# Chain tree, maximum n, minimal l and w\n./gen -n 100000 -l 1 -w 0 -type chain -weight_type zero\n\n# Random tree, maximum n, maximum l and w\n./gen -n 100000 -l 100000 -w 1000000000 -type random -weight_type random\n\n# Random tree, maximum n, edge weights zero\n./gen -n 100000 -l 100000 -w 0 -type random -weight_type zero\n\n# Random tree, edge weights maximum\n./gen -n 100000 -l 100000 -w 1000000000 -type random -weight_type max\n\n# Binary tree, moderate n, random weights\n./gen -n 20000 -l 10000 -w 500000000 -type binary -weight_type random\n\n# Chain tree, increasing weights\n./gen -n 5000 -l 5000 -w 1000000000 -type chain -weight_type increasing\n\n# Chain tree, decreasing weights\n./gen -n 5000 -l 5000 -w 500000000 -type chain -weight_type decreasing\n\n# Random tree, small l and w\n./gen -n 10000 -l 2 -w 1000 -type random -weight_type random\n\n# Random tree, large l, zero weights\n./gen -n 10000 -l 10000 -w 0 -type random -weight_type zero\n\n# Star tree, minimal weights\n./gen -n 50000 -l 1 -w 0 -type star -weight_type zero\n\n# Star tree, maximal weights\n./gen -n 50000 -l 1 -w 1000000000 -type star -weight_type max\n\n# Skewed tree, random weights\n./gen -n 70000 -l 10000 -w 500000000 -type skewed -weight_type random\n\n# Random tree, random l and w\n./gen -n 90000 -l 50000 -w 300000000 -type random -weight_type random\n\n# Random tree, l = n/2, w = 1e9\n./gen -n 100000 -l 50000 -w 1000000000 -type random -weight_type random\n\n# Chain tree, l = n, w = sum of weights\n./gen -n 100000 -l 100000 -w 1000000000 -type chain -weight_type random\n\n# Chain tree, weights to allow only short paths\n./gen -n 10000 -l 10 -w 100 -type chain -weight_type increasing\n\n# Chain tree, weights to allow only long paths\n./gen -n 10000 -l 10000 -w 0 -type chain -weight_type zero\n\n# Random tree, weights to exclude most pairs\n./gen -n 20000 -l 2 -w 1 -type random -weight_type max\n\n# Random tree, weights to include all pairs\n./gen -n 20000 -l 20000 -w 1000000000 -type random -weight_type zero\n\n# Small n, various l and w\n./gen -n 15 -l 7 -w 5000 -type random -weight_type random\n./gen -n 15 -l 7 -w 5000 -type chain -weight_type zero\n\n# Maximum n, l=1, w=1e9\n./gen -n 100000 -l 1 -w 1000000000 -type random -weight_type random\n\n# Moderate n, l and w\n./gen -n 50000 -l 1000 -w 100000000 -type binary -weight_type random\n\n# Random tree, weights at the maximum\n./gen -n 100000 -l 1000 -w 1000000000 -type random -weight_type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:34.315733",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "294/A",
      "title": "A. Shaass and Oskols",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n, (1 ≤ n ≤ 100). The next line contains a list of space-separated integers a1, a2, ..., an, (0 ≤ ai ≤ 100). The third line contains an integer m, (0 ≤ m ≤ 100). Each of the next m lines contains two integers xi and yi. The integers mean that for the i-th time Shaass shoot the yi-th (from left) bird on the xi-th wire, (1 ≤ xi ≤ n, 1 ≤ yi). It's guaranteed there will be at least yi birds on the xi-th wire at that moment.",
      "output_spec": "OutputOn the i-th line of the output print the number of birds on the i-th wire.",
      "sample_tests": "ExamplesInputCopy510 10 10 10 1052 53 132 121 134 6OutputCopy0125016InputCopy32 4 112 2OutputCopy303",
      "description": "A. Shaass and Oskols\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n, (1 ≤ n ≤ 100). The next line contains a list of space-separated integers a1, a2, ..., an, (0 ≤ ai ≤ 100). The third line contains an integer m, (0 ≤ m ≤ 100). Each of the next m lines contains two integers xi and yi. The integers mean that for the i-th time Shaass shoot the yi-th (from left) bird on the xi-th wire, (1 ≤ xi ≤ n, 1 ≤ yi). It's guaranteed there will be at least yi birds on the xi-th wire at that moment.\n\nOutputOn the i-th line of the output print the number of birds on the i-th wire.\n\nInputCopy510 10 10 10 1052 53 132 121 134 6OutputCopy0125016InputCopy32 4 112 2OutputCopy303\n\nInputCopy510 10 10 10 1052 53 132 121 134 6\n\nOutputCopy0125016\n\nInputCopy32 4 112 2\n\nOutputCopy303",
      "solutions": [
        {
          "title": "Codeforces Round #178 (Div. 2) - Codeforces",
          "content": "Hi all! :)I (Untitled) invite you to participate in Codeforces Round #178 (Div. 2) which will be held today. I want to thank Gerald Delinur MikeMirzayanov for their help in preparation of this event. I also want to thank havaliza who tested the round and made the graphics for the problems.The hero of today's contest is Shaass. Hope you enjoy helping him! :DGood luck and have fun ;)UPD. Editorial is partially out and will be completed soon! :{",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7271",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 446
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces",
          "content": "294A - Shaass and OskolsAlthough Oskol is not really name of a specie of birds, In Iran it's known as a kind of bird which is very forgetful and can't even remember his way back to home when he flies away! It's commonly used instead of the word \"stupid\" among the kids! :DIn this problem you just have to now how many birds are there on each wire after each shot. A good trick for the first and the last wire would be to define wires 0 and n + 1. In this way the birds that fly away sit on these wires and you don't need to worry about accessing some element outside the range of your array.Here is a neat implementation in C++ from contestant rpslive: 3484601294B - Shaass and BookshelfAs said in the statement, the thickness of each book is either 1 or 2. Think about when we want to arrange v1 books of thickness 1 and v2 books of thickness 2 vertically and arrange all other n - v1 - v2 books horizontally above them to achieve a configuration with total thickness of vertical books equal to v1 + 2v2. Is it possible to find such arrangement? Because the total thickness of vertical books is fixed it's good to calculate the minimum possible total width of horizontal books. As the width of a book doesn't matter in vertical arrangement it's good to use the books with shorter width horizontally and the ones with longer width vertically. So pick out v1 books with longest width among books of thickness 1 and do the same with books of thickness 2. The sum of width of n - v1 - v2 remaining books should be at most v1 + 2v2.The solution would be to try the things we explained above for all possible values of v1 and v2. And print the best answer. :)There exists other ways to solve this problem mostly using dynamic programming but this was the intended solution of the problem.Here is a nice implementation in C++ from contestant bayram: 3485189 (You should also know that 'bir' means 'one' in Turkish and 'iki' means two!)294C - Shaass and LightsI just want to solve the third sample of this problem for you and you can figure out the rest by yourself. :)The third sample is ...#...#... where # is a switched on lamp and . is a switched off lamp. As you can see we have three different types of lights. The first three lights (Type A), the 5th to 8th lights (Type B) and the last three lights (Type C). We have to switch on the lights three times for each type of lights. Aside from the order of moves for each type there are possible permutations of the string AAABBBCCC which tells us how to combine the steps of different types. Switching on the lights is done uniquely for types 1 and 3. But for type 2 each time we have to possible options until we're left with one off light. So there are 23 - 1 ways to do this. So the answer would be 1680*1*4*1 = 6720.The general solution would be to find all groups off consecutive switched off lamps and calculate the number of ways to combine all these groups. Then for each group you should calculate in how many ways it can be solved.The implementation needs some standard combinatorial computations which you can see here: 3485187294D - Shaass and Painter RobotTODO294E - Shaass the GreatTODOI promise the editorial will be completed come soon soon soon! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 294\\s*A"
          },
          "content_length": 3212
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 1",
          "code": "...#...#...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 2",
          "code": "1680*1*4*1 = 6720",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n  \n    vector<int> birds(n+2); // +2 to avoid index out of bounds\n    vector<int> ai = inf.readInts(n, 0, 100, \"ai\");\n    int totalBirds = 0;\n    for (int i = 1; i <= n; i++) {\n        birds[i] = ai[i-1];\n        totalBirds += ai[i-1];\n    }\n    inf.readEoln();\n \n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n  \n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, totalBirds, \"yi\");\n        inf.readEoln();\n      \n        ensuref(birds[xi] >= yi, \"At shot %d, wire %d has %d birds, but yi=%d\", i+1, xi, birds[xi], yi);\n \n        int left = yi -1;\n        int right = birds[xi] - yi;\n \n        if (xi > 1) {\n            birds[xi -1] += left;\n        }\n        // else, left birds fly away\n \n        if (xi < n) {\n            birds[xi +1] += right;\n        }\n        // else, right birds fly away\n\n        birds[xi] = 0; // All birds on wire xi have left or been killed\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n  \n    vector<int> birds(n+2); // +2 to avoid index out of bounds\n    vector<int> ai = inf.readInts(n, 0, 100, \"ai\");\n    int totalBirds = 0;\n    for (int i = 1; i <= n; i++) {\n        birds[i] = ai[i-1];\n        totalBirds += ai[i-1];\n    }\n    inf.readEoln();\n \n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n  \n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, totalBirds, \"yi\");\n        inf.readEoln();\n      \n        ensuref(birds[xi] >= yi, \"At shot %d, wire %d has %d birds, but yi=%d\", i+1, xi, birds[xi], yi);\n \n        int left = yi -1;\n        int right = birds[xi] - yi;\n \n        if (xi > 1) {\n            birds[xi -1] += left;\n        }\n        // else, left birds fly away\n \n        if (xi < n) {\n            birds[xi +1] += right;\n        }\n        // else, right birds fly away\n\n        birds[xi] = 0; // All birds on wire xi have left or been killed\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n  \n    vector<int> birds(n+2); // +2 to avoid index out of bounds\n    vector<int> ai = inf.readInts(n, 0, 100, \"ai\");\n    int totalBirds = 0;\n    for (int i = 1; i <= n; i++) {\n        birds[i] = ai[i-1];\n        totalBirds += ai[i-1];\n    }\n    inf.readEoln();\n \n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n  \n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, totalBirds, \"yi\");\n        inf.readEoln();\n      \n        ensuref(birds[xi] >= yi, \"At shot %d, wire %d has %d birds, but yi=%d\", i+1, xi, birds[xi], yi);\n \n        int left = yi -1;\n        int right = birds[xi] - yi;\n \n        if (xi > 1) {\n            birds[xi -1] += left;\n        }\n        // else, left birds fly away\n \n        if (xi < n) {\n            birds[xi +1] += right;\n        }\n        // else, right birds fly away\n\n        birds[xi] = 0; // All birds on wire xi have left or been killed\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<pair<int, int>> shots;\n\n    if (type == \"random\") {\n        // Generate random initial number of birds on each wire\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n\n        vector<int> current_birds = a;\n\n        for (int shot = 0; shot < m; ++shot) {\n            // Collect wires that have birds\n            vector<int> non_empty_wires;\n            for (int i = 0; i < n; ++i) {\n                if (current_birds[i] > 0) {\n                    non_empty_wires.push_back(i);\n                }\n            }\n\n            if (non_empty_wires.empty()) break; // No more birds to shoot\n\n            // Choose a wire with birds\n            int xi_idx = rnd.next(0, (int)non_empty_wires.size() - 1);\n            int xi = non_empty_wires[xi_idx];\n\n            int birds_on_wire = current_birds[xi];\n\n            // Choose a valid bird position\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi}); // Wires are 1-indexed\n\n            // Simulate the effect of the shot\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            // Left birds jump up\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n\n            // Right birds jump down\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size(); // Update m in case we had fewer shots\n    } else if (type == \"maxconstraints\") {\n        n = 100;\n        m = 100;\n\n        // All wires have maximum number of birds\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100;\n        }\n\n        vector<int> current_birds = a;\n\n        for (int shot = 0; shot < m; ++shot) {\n            // Collect wires that have birds\n            vector<int> non_empty_wires;\n            for (int i = 0; i < n; ++i) {\n                if (current_birds[i] > 0) {\n                    non_empty_wires.push_back(i);\n                }\n            }\n\n            if (non_empty_wires.empty()) break; // No more birds to shoot\n\n            // Choose a wire with birds\n            int xi_idx = rnd.next(0, (int)non_empty_wires.size() - 1);\n            int xi = non_empty_wires[xi_idx];\n\n            int birds_on_wire = current_birds[xi];\n\n            // Choose a valid bird position\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi}); // Wires are 1-indexed\n\n            // Simulate the effect of the shot\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            // Left birds jump up\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n\n            // Right birds jump down\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size(); // Update m in case we had fewer shots\n    } else if (type == \"minconstraints\") {\n        n = 1;\n        m = min(m, 1); // Maximum of 1 shot possible\n\n        // Random number of birds on the wire\n        a[0] = rnd.next(0, 100);\n\n        vector<int> current_birds = a;\n\n        if (m > 0 && current_birds[0] > 0) {\n            int xi = 0;\n            int yi = rnd.next(1, current_birds[xi]);\n\n            shots.push_back({xi + 1, yi});\n\n            // Simulate the effect of the shot\n            // Left birds fly away\n            // Right birds fly away\n            current_birds[xi] = 0;\n        } else {\n            m = 0;\n        }\n    } else if (type == \"shotsontop\") {\n        // All shots on the top wire\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n\n        vector<int> current_birds = a;\n        int xi = 0; // Top wire\n\n        for (int shot = 0; shot < m && current_birds[xi] > 0; ++shot) {\n            int birds_on_wire = current_birds[xi];\n\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi}); // Wires are 1-indexed\n\n            // Simulate the effect of the shot\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            // Left birds fly away (no wire above)\n            // Right birds jump down\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size(); // Update m in case we had fewer shots\n    } else if (type == \"shotsonbottom\") {\n        // All shots on the bottom wire\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n\n        vector<int> current_birds = a;\n        int xi = n - 1; // Bottom wire\n\n        for (int shot = 0; shot < m && current_birds[xi] > 0; ++shot) {\n            int birds_on_wire = current_birds[xi];\n\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi}); // Wires are 1-indexed\n\n            // Simulate the effect of the shot\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            // Left birds jump up\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n            // Right birds fly away (no wire below)\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size(); // Update m in case we had fewer shots\n    } else if (type == \"zeros\") {\n        // All wires have zero birds\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n        m = 0; // No shots possible\n    } else if (type == \"maxbirds\") {\n        // Wires with maximum birds\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100;\n        }\n\n        // Generate random shots\n        vector<int> current_birds = a;\n\n        for (int shot = 0; shot < m; ++shot) {\n            // Collect wires that have birds\n            vector<int> non_empty_wires;\n            for (int i = 0; i < n; ++i) {\n                if (current_birds[i] > 0) {\n                    non_empty_wires.push_back(i);\n                }\n            }\n\n            if (non_empty_wires.empty()) break;\n\n            // Choose a wire with birds\n            int xi_idx = rnd.next(0, (int)non_empty_wires.size() - 1);\n            int xi = non_empty_wires[xi_idx];\n\n            int birds_on_wire = current_birds[xi];\n\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi});\n\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size();\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n\n        vector<int> current_birds = a;\n\n        for (int shot = 0; shot < m; ++shot) {\n            // Collect wires that have birds\n            vector<int> non_empty_wires;\n            for (int i = 0; i < n; ++i) {\n                if (current_birds[i] > 0) {\n                    non_empty_wires.push_back(i);\n                }\n            }\n\n            if (non_empty_wires.empty()) break;\n\n            // Choose a wire with birds\n            int xi_idx = rnd.next(0, (int)non_empty_wires.size() - 1);\n            int xi = non_empty_wires[xi_idx];\n\n            int birds_on_wire = current_birds[xi];\n\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi});\n\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size();\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 < n) ? ' ' : '\\n');\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", shots[i].first, shots[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<pair<int, int>> shots;\n\n    if (type == \"random\") {\n        // Generate random initial number of birds on each wire\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n\n        vector<int> current_birds = a;\n\n        for (int shot = 0; shot < m; ++shot) {\n            // Collect wires that have birds\n            vector<int> non_empty_wires;\n            for (int i = 0; i < n; ++i) {\n                if (current_birds[i] > 0) {\n                    non_empty_wires.push_back(i);\n                }\n            }\n\n            if (non_empty_wires.empty()) break; // No more birds to shoot\n\n            // Choose a wire with birds\n            int xi_idx = rnd.next(0, (int)non_empty_wires.size() - 1);\n            int xi = non_empty_wires[xi_idx];\n\n            int birds_on_wire = current_birds[xi];\n\n            // Choose a valid bird position\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi}); // Wires are 1-indexed\n\n            // Simulate the effect of the shot\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            // Left birds jump up\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n\n            // Right birds jump down\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size(); // Update m in case we had fewer shots\n    } else if (type == \"maxconstraints\") {\n        n = 100;\n        m = 100;\n\n        // All wires have maximum number of birds\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100;\n        }\n\n        vector<int> current_birds = a;\n\n        for (int shot = 0; shot < m; ++shot) {\n            // Collect wires that have birds\n            vector<int> non_empty_wires;\n            for (int i = 0; i < n; ++i) {\n                if (current_birds[i] > 0) {\n                    non_empty_wires.push_back(i);\n                }\n            }\n\n            if (non_empty_wires.empty()) break; // No more birds to shoot\n\n            // Choose a wire with birds\n            int xi_idx = rnd.next(0, (int)non_empty_wires.size() - 1);\n            int xi = non_empty_wires[xi_idx];\n\n            int birds_on_wire = current_birds[xi];\n\n            // Choose a valid bird position\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi}); // Wires are 1-indexed\n\n            // Simulate the effect of the shot\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            // Left birds jump up\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n\n            // Right birds jump down\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size(); // Update m in case we had fewer shots\n    } else if (type == \"minconstraints\") {\n        n = 1;\n        m = min(m, 1); // Maximum of 1 shot possible\n\n        // Random number of birds on the wire\n        a[0] = rnd.next(0, 100);\n\n        vector<int> current_birds = a;\n\n        if (m > 0 && current_birds[0] > 0) {\n            int xi = 0;\n            int yi = rnd.next(1, current_birds[xi]);\n\n            shots.push_back({xi + 1, yi});\n\n            // Simulate the effect of the shot\n            // Left birds fly away\n            // Right birds fly away\n            current_birds[xi] = 0;\n        } else {\n            m = 0;\n        }\n    } else if (type == \"shotsontop\") {\n        // All shots on the top wire\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n\n        vector<int> current_birds = a;\n        int xi = 0; // Top wire\n\n        for (int shot = 0; shot < m && current_birds[xi] > 0; ++shot) {\n            int birds_on_wire = current_birds[xi];\n\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi}); // Wires are 1-indexed\n\n            // Simulate the effect of the shot\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            // Left birds fly away (no wire above)\n            // Right birds jump down\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size(); // Update m in case we had fewer shots\n    } else if (type == \"shotsonbottom\") {\n        // All shots on the bottom wire\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n\n        vector<int> current_birds = a;\n        int xi = n - 1; // Bottom wire\n\n        for (int shot = 0; shot < m && current_birds[xi] > 0; ++shot) {\n            int birds_on_wire = current_birds[xi];\n\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi}); // Wires are 1-indexed\n\n            // Simulate the effect of the shot\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            // Left birds jump up\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n            // Right birds fly away (no wire below)\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size(); // Update m in case we had fewer shots\n    } else if (type == \"zeros\") {\n        // All wires have zero birds\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n        m = 0; // No shots possible\n    } else if (type == \"maxbirds\") {\n        // Wires with maximum birds\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100;\n        }\n\n        // Generate random shots\n        vector<int> current_birds = a;\n\n        for (int shot = 0; shot < m; ++shot) {\n            // Collect wires that have birds\n            vector<int> non_empty_wires;\n            for (int i = 0; i < n; ++i) {\n                if (current_birds[i] > 0) {\n                    non_empty_wires.push_back(i);\n                }\n            }\n\n            if (non_empty_wires.empty()) break;\n\n            // Choose a wire with birds\n            int xi_idx = rnd.next(0, (int)non_empty_wires.size() - 1);\n            int xi = non_empty_wires[xi_idx];\n\n            int birds_on_wire = current_birds[xi];\n\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi});\n\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size();\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n\n        vector<int> current_birds = a;\n\n        for (int shot = 0; shot < m; ++shot) {\n            // Collect wires that have birds\n            vector<int> non_empty_wires;\n            for (int i = 0; i < n; ++i) {\n                if (current_birds[i] > 0) {\n                    non_empty_wires.push_back(i);\n                }\n            }\n\n            if (non_empty_wires.empty()) break;\n\n            // Choose a wire with birds\n            int xi_idx = rnd.next(0, (int)non_empty_wires.size() - 1);\n            int xi = non_empty_wires[xi_idx];\n\n            int birds_on_wire = current_birds[xi];\n\n            int yi = rnd.next(1, birds_on_wire);\n\n            shots.push_back({xi + 1, yi});\n\n            int left_birds = yi - 1;\n            int right_birds = birds_on_wire - yi;\n\n            if (xi > 0) {\n                current_birds[xi - 1] += left_birds;\n            }\n            if (xi + 1 < n) {\n                current_birds[xi + 1] += right_birds;\n            }\n\n            current_birds[xi] = 0;\n        }\n\n        m = shots.size();\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 < n) ? ' ' : '\\n');\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", shots[i].first, shots[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type minconstraints\n./gen -n 1 -m 1 -type minconstraints\n./gen -n 5 -m 10 -type random\n./gen -n 10 -m 20 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 100 -type random\n\n./gen -n 10 -m 0 -type zeros\n./gen -n 100 -m 0 -type zeros\n\n./gen -n 10 -m 10 -type maxbirds\n./gen -n 100 -m 100 -type maxbirds\n\n./gen -n 5 -m 5 -type shotsontop\n./gen -n 5 -m 5 -type shotsonbottom\n\n./gen -n 10 -m 20 -type shotsontop\n./gen -n 10 -m 20 -type shotsonbottom\n\n./gen -n 100 -m 50 -type shotsontop\n./gen -n 100 -m 50 -type shotsonbottom\n\n./gen -n 100 -m 100 -type maxconstraints\n./gen -n 1 -m 1 -type minconstraints\n\n./gen -n 10 -m 15 -type default\n./gen -n 20 -m 25 -type default\n\n./gen -n 30 -m 50 -type random\n./gen -n 50 -m 70 -type random\n./gen -n 70 -m 80 -type random\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:36.383688",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "294/B",
      "title": "B. Shaass and Bookshelf",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n, (1 ≤ n ≤ 100). Each of the next n lines contains two integers ti and wi denoting the thickness and width of the i-th book correspondingly, (1 ≤ ti ≤ 2, 1 ≤ wi ≤ 100).",
      "output_spec": "OutputOn the only line of the output print the minimum total thickness of the vertical books that we can achieve.",
      "sample_tests": "ExamplesInputCopy51 121 32 152 52 1OutputCopy5InputCopy31 102 12 4OutputCopy3",
      "description": "B. Shaass and Bookshelf\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n, (1 ≤ n ≤ 100). Each of the next n lines contains two integers ti and wi denoting the thickness and width of the i-th book correspondingly, (1 ≤ ti ≤ 2, 1 ≤ wi ≤ 100).\n\nOutputOn the only line of the output print the minimum total thickness of the vertical books that we can achieve.\n\nInputCopy51 121 32 152 52 1OutputCopy5InputCopy31 102 12 4OutputCopy3\n\nInputCopy51 121 32 152 52 1\n\nOutputCopy5\n\nInputCopy31 102 12 4\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #178 (Div. 2) - Codeforces",
          "content": "Hi all! :)I (Untitled) invite you to participate in Codeforces Round #178 (Div. 2) which will be held today. I want to thank Gerald Delinur MikeMirzayanov for their help in preparation of this event. I also want to thank havaliza who tested the round and made the graphics for the problems.The hero of today's contest is Shaass. Hope you enjoy helping him! :DGood luck and have fun ;)UPD. Editorial is partially out and will be completed soon! :{",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7271",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 446
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces",
          "content": "294A - Shaass and OskolsAlthough Oskol is not really name of a specie of birds, In Iran it's known as a kind of bird which is very forgetful and can't even remember his way back to home when he flies away! It's commonly used instead of the word \"stupid\" among the kids! :DIn this problem you just have to now how many birds are there on each wire after each shot. A good trick for the first and the last wire would be to define wires 0 and n + 1. In this way the birds that fly away sit on these wires and you don't need to worry about accessing some element outside the range of your array.Here is a neat implementation in C++ from contestant rpslive: 3484601294B - Shaass and BookshelfAs said in the statement, the thickness of each book is either 1 or 2. Think about when we want to arrange v1 books of thickness 1 and v2 books of thickness 2 vertically and arrange all other n - v1 - v2 books horizontally above them to achieve a configuration with total thickness of vertical books equal to v1 + 2v2. Is it possible to find such arrangement? Because the total thickness of vertical books is fixed it's good to calculate the minimum possible total width of horizontal books. As the width of a book doesn't matter in vertical arrangement it's good to use the books with shorter width horizontally and the ones with longer width vertically. So pick out v1 books with longest width among books of thickness 1 and do the same with books of thickness 2. The sum of width of n - v1 - v2 remaining books should be at most v1 + 2v2.The solution would be to try the things we explained above for all possible values of v1 and v2. And print the best answer. :)There exists other ways to solve this problem mostly using dynamic programming but this was the intended solution of the problem.Here is a nice implementation in C++ from contestant bayram: 3485189 (You should also know that 'bir' means 'one' in Turkish and 'iki' means two!)294C - Shaass and LightsI just want to solve the third sample of this problem for you and you can figure out the rest by yourself. :)The third sample is ...#...#... where # is a switched on lamp and . is a switched off lamp. As you can see we have three different types of lights. The first three lights (Type A), the 5th to 8th lights (Type B) and the last three lights (Type C). We have to switch on the lights three times for each type of lights. Aside from the order of moves for each type there are possible permutations of the string AAABBBCCC which tells us how to combine the steps of different types. Switching on the lights is done uniquely for types 1 and 3. But for type 2 each time we have to possible options until we're left with one off light. So there are 23 - 1 ways to do this. So the answer would be 1680*1*4*1 = 6720.The general solution would be to find all groups off consecutive switched off lamps and calculate the number of ways to combine all these groups. Then for each group you should calculate in how many ways it can be solved.The implementation needs some standard combinatorial computations which you can see here: 3485187294D - Shaass and Painter RobotTODO294E - Shaass the GreatTODOI promise the editorial will be completed come soon soon soon! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 294\\s*B"
          },
          "content_length": 3212
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 1",
          "code": "...#...#...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 2",
          "code": "1680*1*4*1 = 6720",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int t_i = inf.readInt(1, 2);\n        inf.readSpace();\n        int w_i = inf.readInt(1, 100);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int t_i = inf.readInt(1, 2);\n        inf.readSpace();\n        int w_i = inf.readInt(1, 100);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int t_i = inf.readInt(1, 2);\n        inf.readSpace();\n        int w_i = inf.readInt(1, 100);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string t_type = opt<string>(\"t_type\", \"random\"); // \"all1\", \"all2\", \"random\", \"alternating\"\n    string w_type = opt<string>(\"w_type\", \"random\"); // \"small\", \"large\", \"random\", \"fixed\"\n    int w_value = opt<int>(\"w_value\", 1); // default to 1\n    string special = opt<string>(\"special\", \"none\"); // \"none\", \"equal_sum\"\n\n    vector<int> t(n);\n    vector<int> w(n);\n\n    if (special == \"equal_sum\") {\n        // Generate a test case where the sum of widths of horizontal books equals total thickness of vertical books.\n        int total_thickness = 0;\n        int total_width = 0;\n\n        // First half books are vertical with thickness 1 and width 1\n        for (int i = 0; i < n/2; ++i) {\n            t[i] = 1;\n            w[i] = 1;\n            total_thickness += t[i];\n        }\n\n        // Second half books are horizontal with width 1\n        for (int i = n/2; i < n; ++i) {\n            t[i] = 2; // These will be treated as horizontal\n            w[i] = 1;\n            total_width += w[i];\n        }\n\n        // Adjust w[i] of horizontal books to ensure total_width equals total_thickness\n        if (total_thickness != total_width) {\n            int diff = total_thickness - total_width;\n            if (diff > 0 && n/2 < n) {\n                w[n/2] += diff;\n                total_width += diff;\n            }\n        }\n\n    } else {\n\n        // Generate t_i\n        if (t_type == \"all1\") {\n            fill(t.begin(), t.end(), 1);\n        } else if (t_type == \"all2\") {\n            fill(t.begin(), t.end(), 2);\n        } else if (t_type == \"alternating\") {\n            for(int i = 0; i < n; ++i){\n                t[i] = (i % 2) + 1;\n            }\n        } else { // random\n            for(int i = 0; i < n; ++i){\n                t[i] = rnd.next(1, 2);\n            }\n        }\n\n        // Generate w_i\n        if (w_type == \"small\") {\n            for(int i = 0; i < n; ++i){\n                w[i] = rnd.next(1, 10);\n            }\n        } else if (w_type == \"large\") {\n            for(int i = 0; i < n; ++i){\n                w[i] = rnd.next(90, 100);\n            }\n        } else if (w_type == \"fixed\") {\n            for(int i = 0; i < n; ++i){\n                w[i] = w_value;\n            }\n        } else { // random\n            for(int i = 0; i < n; ++i){\n                w[i] = rnd.next(1, 100);\n            }\n        }\n\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%d %d\\n\", t[i], w[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string t_type = opt<string>(\"t_type\", \"random\"); // \"all1\", \"all2\", \"random\", \"alternating\"\n    string w_type = opt<string>(\"w_type\", \"random\"); // \"small\", \"large\", \"random\", \"fixed\"\n    int w_value = opt<int>(\"w_value\", 1); // default to 1\n    string special = opt<string>(\"special\", \"none\"); // \"none\", \"equal_sum\"\n\n    vector<int> t(n);\n    vector<int> w(n);\n\n    if (special == \"equal_sum\") {\n        // Generate a test case where the sum of widths of horizontal books equals total thickness of vertical books.\n        int total_thickness = 0;\n        int total_width = 0;\n\n        // First half books are vertical with thickness 1 and width 1\n        for (int i = 0; i < n/2; ++i) {\n            t[i] = 1;\n            w[i] = 1;\n            total_thickness += t[i];\n        }\n\n        // Second half books are horizontal with width 1\n        for (int i = n/2; i < n; ++i) {\n            t[i] = 2; // These will be treated as horizontal\n            w[i] = 1;\n            total_width += w[i];\n        }\n\n        // Adjust w[i] of horizontal books to ensure total_width equals total_thickness\n        if (total_thickness != total_width) {\n            int diff = total_thickness - total_width;\n            if (diff > 0 && n/2 < n) {\n                w[n/2] += diff;\n                total_width += diff;\n            }\n        }\n\n    } else {\n\n        // Generate t_i\n        if (t_type == \"all1\") {\n            fill(t.begin(), t.end(), 1);\n        } else if (t_type == \"all2\") {\n            fill(t.begin(), t.end(), 2);\n        } else if (t_type == \"alternating\") {\n            for(int i = 0; i < n; ++i){\n                t[i] = (i % 2) + 1;\n            }\n        } else { // random\n            for(int i = 0; i < n; ++i){\n                t[i] = rnd.next(1, 2);\n            }\n        }\n\n        // Generate w_i\n        if (w_type == \"small\") {\n            for(int i = 0; i < n; ++i){\n                w[i] = rnd.next(1, 10);\n            }\n        } else if (w_type == \"large\") {\n            for(int i = 0; i < n; ++i){\n                w[i] = rnd.next(90, 100);\n            }\n        } else if (w_type == \"fixed\") {\n            for(int i = 0; i < n; ++i){\n                w[i] = w_value;\n            }\n        } else { // random\n            for(int i = 0; i < n; ++i){\n                w[i] = rnd.next(1, 100);\n            }\n        }\n\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%d %d\\n\", t[i], w[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n\n./gen -n 1 -t_type all1 -w_type fixed -w_value 1\n./gen -n 1 -t_type all2 -w_type fixed -w_value 100\n./gen -n 1 -t_type random -w_type random\n\n# Small n\n./gen -n 2 -t_type random -w_type random\n./gen -n 5 -t_type random -w_type random\n\n# Medium n\n./gen -n 10 -t_type random -w_type random\n./gen -n 10 -t_type alternating -w_type small\n./gen -n 10 -t_type alternating -w_type large\n./gen -n 10 -t_type alternating -w_type fixed -w_value 50\n./gen -n 10 -special equal_sum\n\n# Maximal n\n./gen -n 100 -t_type all1 -w_type fixed -w_value 1\n./gen -n 100 -t_type all1 -w_type fixed -w_value 100\n./gen -n 100 -t_type all2 -w_type fixed -w_value 1\n./gen -n 100 -t_type all2 -w_type fixed -w_value 100\n./gen -n 100 -t_type alternating -w_type random\n./gen -n 100 -t_type random -w_type small\n./gen -n 100 -t_type random -w_type large\n./gen -n 100 -t_type random -w_type random\n./gen -n 100 -t_type all1 -w_type random\n./gen -n 100 -t_type all2 -w_type random\n./gen -n 100 -t_type all1 -w_type small\n./gen -n 100 -t_type all2 -w_type small\n./gen -n 100 -t_type all1 -w_type large\n./gen -n 100 -t_type all2 -w_type large\n./gen -n 100 -t_type alternating -w_type fixed -w_value 1\n./gen -n 100 -t_type alternating -w_type fixed -w_value 100\n./gen -n 100 -t_type random -w_type fixed -w_value 1\n./gen -n 100 -t_type random -w_type fixed -w_value 100\n./gen -n 100 -t_type random -w_type fixed -w_value 50\n./gen -n 100 -special equal_sum\n\n# Edge n\n./gen -n 99 -t_type random -w_type random\n./gen -n 99 -special equal_sum\n\n# Additional random test cases\n./gen -n 100 -t_type random -w_type random\n./gen -n 100 -t_type random -w_type random\n./gen -n 100 -t_type random -w_type random\n./gen -n 100 -t_type random -w_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:38.019507",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "294/C",
      "title": "C. Shaass and Lights",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m where n is the number of lights in the sequence and m is the number of lights which are initially switched on, (1 ≤ n ≤ 1000, 1 ≤ m ≤ n). The second line contains m distinct integers, each between 1 to n inclusive, denoting the indices of lights which are initially switched on.",
      "output_spec": "OutputIn the only line of the output print the number of different possible ways to switch on all the lights modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy3 11OutputCopy1InputCopy4 21 4OutputCopy2InputCopy11 24 8OutputCopy6720",
      "description": "C. Shaass and Lights\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m where n is the number of lights in the sequence and m is the number of lights which are initially switched on, (1 ≤ n ≤ 1000, 1 ≤ m ≤ n). The second line contains m distinct integers, each between 1 to n inclusive, denoting the indices of lights which are initially switched on.\n\nOutputIn the only line of the output print the number of different possible ways to switch on all the lights modulo 1000000007 (109 + 7).\n\nInputCopy3 11OutputCopy1InputCopy4 21 4OutputCopy2InputCopy11 24 8OutputCopy6720\n\nInputCopy3 11\n\nOutputCopy1\n\nInputCopy4 21 4\n\nOutputCopy2\n\nInputCopy11 24 8\n\nOutputCopy6720",
      "solutions": [
        {
          "title": "Codeforces Round #178 (Div. 2) - Codeforces",
          "content": "Hi all! :)I (Untitled) invite you to participate in Codeforces Round #178 (Div. 2) which will be held today. I want to thank Gerald Delinur MikeMirzayanov for their help in preparation of this event. I also want to thank havaliza who tested the round and made the graphics for the problems.The hero of today's contest is Shaass. Hope you enjoy helping him! :DGood luck and have fun ;)UPD. Editorial is partially out and will be completed soon! :{",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7271",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 446
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces",
          "content": "294A - Shaass and OskolsAlthough Oskol is not really name of a specie of birds, In Iran it's known as a kind of bird which is very forgetful and can't even remember his way back to home when he flies away! It's commonly used instead of the word \"stupid\" among the kids! :DIn this problem you just have to now how many birds are there on each wire after each shot. A good trick for the first and the last wire would be to define wires 0 and n + 1. In this way the birds that fly away sit on these wires and you don't need to worry about accessing some element outside the range of your array.Here is a neat implementation in C++ from contestant rpslive: 3484601294B - Shaass and BookshelfAs said in the statement, the thickness of each book is either 1 or 2. Think about when we want to arrange v1 books of thickness 1 and v2 books of thickness 2 vertically and arrange all other n - v1 - v2 books horizontally above them to achieve a configuration with total thickness of vertical books equal to v1 + 2v2. Is it possible to find such arrangement? Because the total thickness of vertical books is fixed it's good to calculate the minimum possible total width of horizontal books. As the width of a book doesn't matter in vertical arrangement it's good to use the books with shorter width horizontally and the ones with longer width vertically. So pick out v1 books with longest width among books of thickness 1 and do the same with books of thickness 2. The sum of width of n - v1 - v2 remaining books should be at most v1 + 2v2.The solution would be to try the things we explained above for all possible values of v1 and v2. And print the best answer. :)There exists other ways to solve this problem mostly using dynamic programming but this was the intended solution of the problem.Here is a nice implementation in C++ from contestant bayram: 3485189 (You should also know that 'bir' means 'one' in Turkish and 'iki' means two!)294C - Shaass and LightsI just want to solve the third sample of this problem for you and you can figure out the rest by yourself. :)The third sample is ...#...#... where # is a switched on lamp and . is a switched off lamp. As you can see we have three different types of lights. The first three lights (Type A), the 5th to 8th lights (Type B) and the last three lights (Type C). We have to switch on the lights three times for each type of lights. Aside from the order of moves for each type there are possible permutations of the string AAABBBCCC which tells us how to combine the steps of different types. Switching on the lights is done uniquely for types 1 and 3. But for type 2 each time we have to possible options until we're left with one off light. So there are 23 - 1 ways to do this. So the answer would be 1680*1*4*1 = 6720.The general solution would be to find all groups off consecutive switched off lamps and calculate the number of ways to combine all these groups. Then for each group you should calculate in how many ways it can be solved.The implementation needs some standard combinatorial computations which you can see here: 3485187294D - Shaass and Painter RobotTODO294E - Shaass the GreatTODOI promise the editorial will be completed come soon soon soon! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 294\\s*C"
          },
          "content_length": 3212
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 1",
          "code": "...#...#...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 2",
          "code": "1680*1*4*1 = 6720",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(m, 1, n);\n    inf.readEoln();\n    \n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == m, \"Integers are not distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(m, 1, n);\n    inf.readEoln();\n    \n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == m, \"Integers are not distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(m, 1, n);\n    inf.readEoln();\n    \n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == m, \"Integers are not distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 1000) {\n        fprintf(stderr, \"n must be between 1 and 1000 inclusive\\n\");\n        return 1;\n    }\n\n    if (m < 1 || m > n) {\n        fprintf(stderr, \"m must be between 1 and n inclusive\\n\");\n        return 1;\n    }\n\n    vector<int> initial_on_lights;\n\n    if (type == \"random\") {\n        vector<int> all_numbers(n);\n        for (int i = 0; i < n; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        for (int i = 0; i < m; ++i)\n            initial_on_lights.push_back(all_numbers[i]);\n    } else if (type == \"left\") {\n        for (int i = 1; i <= m; ++i)\n            initial_on_lights.push_back(i);\n    } else if (type == \"right\") {\n        for (int i = n - m + 1; i <= n; ++i)\n            initial_on_lights.push_back(i);\n    } else if (type == \"middle\") {\n        int start = max(1, n / 2 - m / 2 + 1);\n        int end = min(n, start + m - 1);\n        for (int i = start; i <= end; ++i)\n            initial_on_lights.push_back(i);\n        // If not enough, adjust start or end\n        while ((int)initial_on_lights.size() < m) {\n            if (start > 1) {\n                --start;\n                initial_on_lights.push_back(start);\n            } else if (end < n) {\n                ++end;\n                initial_on_lights.push_back(end);\n            } else {\n                break;\n            }\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 1; i <= n && (int)initial_on_lights.size() < m; i += 2)\n            initial_on_lights.push_back(i);\n        for (int i = 2; i <= n && (int)initial_on_lights.size() < m; i += 2)\n            initial_on_lights.push_back(i);\n    } else if (type == \"clumped\") {\n        int start = max(1, n / 2 - m / 2 + 1);\n        for (int i = start; i < start + m; ++i)\n            initial_on_lights.push_back(i);\n    } else if (type == \"spread\") {\n        if (m == 1) {\n            initial_on_lights.push_back(1);\n        } else {\n            for (int i = 0; i < m; ++i)\n                initial_on_lights.push_back(1 + (i * (n - 1)) / (m - 1));\n        }\n    } else if (type == \"edge1\") {\n        // All lights initially on\n        if (n != m) {\n            fprintf(stderr, \"For edge1 type, n must be equal to m\\n\");\n            return 1;\n        }\n        for (int i = 1; i <= n; ++i)\n            initial_on_lights.push_back(i);\n    } else if (type == \"edge2\") {\n        // Only one light initially on\n        if (m != 1) {\n            fprintf(stderr, \"For edge2 type, m must be equal to 1\\n\");\n            return 1;\n        }\n        initial_on_lights.push_back(rnd.next(1, n));\n    } else if (type == \"edge3\") {\n        // One light in the middle is initially on\n        if (m != 1) {\n            fprintf(stderr, \"For edge3 type, m must be equal to 1\\n\");\n            return 1;\n        }\n        initial_on_lights.push_back((n + 1) / 2);\n    } else if (type == \"edge4\") {\n        // Initial on-lights at positions 1 and n\n        if (m != 2) {\n            fprintf(stderr, \"For edge4 type, m must be equal to 2\\n\");\n            return 1;\n        }\n        initial_on_lights.push_back(1);\n        initial_on_lights.push_back(n);\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // If the number of initial_on_lights is less than m, add random numbers\n    while ((int)initial_on_lights.size() < m) {\n        int x = rnd.next(1, n);\n        if (find(initial_on_lights.begin(), initial_on_lights.end(), x) == initial_on_lights.end()) {\n            initial_on_lights.push_back(x);\n        }\n    }\n\n    // Ensure no duplicates\n    sort(initial_on_lights.begin(), initial_on_lights.end());\n    initial_on_lights.erase(unique(initial_on_lights.begin(), initial_on_lights.end()), initial_on_lights.end());\n    if ((int)initial_on_lights.size() != m) {\n        fprintf(stderr, \"Failed to generate m distinct initial on-lights\\n\");\n        return 1;\n    }\n\n    // Shuffle the order of initial_on_lights\n    shuffle(initial_on_lights.begin(), initial_on_lights.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < (int)initial_on_lights.size(); ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", initial_on_lights[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 1000) {\n        fprintf(stderr, \"n must be between 1 and 1000 inclusive\\n\");\n        return 1;\n    }\n\n    if (m < 1 || m > n) {\n        fprintf(stderr, \"m must be between 1 and n inclusive\\n\");\n        return 1;\n    }\n\n    vector<int> initial_on_lights;\n\n    if (type == \"random\") {\n        vector<int> all_numbers(n);\n        for (int i = 0; i < n; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        for (int i = 0; i < m; ++i)\n            initial_on_lights.push_back(all_numbers[i]);\n    } else if (type == \"left\") {\n        for (int i = 1; i <= m; ++i)\n            initial_on_lights.push_back(i);\n    } else if (type == \"right\") {\n        for (int i = n - m + 1; i <= n; ++i)\n            initial_on_lights.push_back(i);\n    } else if (type == \"middle\") {\n        int start = max(1, n / 2 - m / 2 + 1);\n        int end = min(n, start + m - 1);\n        for (int i = start; i <= end; ++i)\n            initial_on_lights.push_back(i);\n        // If not enough, adjust start or end\n        while ((int)initial_on_lights.size() < m) {\n            if (start > 1) {\n                --start;\n                initial_on_lights.push_back(start);\n            } else if (end < n) {\n                ++end;\n                initial_on_lights.push_back(end);\n            } else {\n                break;\n            }\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 1; i <= n && (int)initial_on_lights.size() < m; i += 2)\n            initial_on_lights.push_back(i);\n        for (int i = 2; i <= n && (int)initial_on_lights.size() < m; i += 2)\n            initial_on_lights.push_back(i);\n    } else if (type == \"clumped\") {\n        int start = max(1, n / 2 - m / 2 + 1);\n        for (int i = start; i < start + m; ++i)\n            initial_on_lights.push_back(i);\n    } else if (type == \"spread\") {\n        if (m == 1) {\n            initial_on_lights.push_back(1);\n        } else {\n            for (int i = 0; i < m; ++i)\n                initial_on_lights.push_back(1 + (i * (n - 1)) / (m - 1));\n        }\n    } else if (type == \"edge1\") {\n        // All lights initially on\n        if (n != m) {\n            fprintf(stderr, \"For edge1 type, n must be equal to m\\n\");\n            return 1;\n        }\n        for (int i = 1; i <= n; ++i)\n            initial_on_lights.push_back(i);\n    } else if (type == \"edge2\") {\n        // Only one light initially on\n        if (m != 1) {\n            fprintf(stderr, \"For edge2 type, m must be equal to 1\\n\");\n            return 1;\n        }\n        initial_on_lights.push_back(rnd.next(1, n));\n    } else if (type == \"edge3\") {\n        // One light in the middle is initially on\n        if (m != 1) {\n            fprintf(stderr, \"For edge3 type, m must be equal to 1\\n\");\n            return 1;\n        }\n        initial_on_lights.push_back((n + 1) / 2);\n    } else if (type == \"edge4\") {\n        // Initial on-lights at positions 1 and n\n        if (m != 2) {\n            fprintf(stderr, \"For edge4 type, m must be equal to 2\\n\");\n            return 1;\n        }\n        initial_on_lights.push_back(1);\n        initial_on_lights.push_back(n);\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // If the number of initial_on_lights is less than m, add random numbers\n    while ((int)initial_on_lights.size() < m) {\n        int x = rnd.next(1, n);\n        if (find(initial_on_lights.begin(), initial_on_lights.end(), x) == initial_on_lights.end()) {\n            initial_on_lights.push_back(x);\n        }\n    }\n\n    // Ensure no duplicates\n    sort(initial_on_lights.begin(), initial_on_lights.end());\n    initial_on_lights.erase(unique(initial_on_lights.begin(), initial_on_lights.end()), initial_on_lights.end());\n    if ((int)initial_on_lights.size() != m) {\n        fprintf(stderr, \"Failed to generate m distinct initial on-lights\\n\");\n        return 1;\n    }\n\n    // Shuffle the order of initial_on_lights\n    shuffle(initial_on_lights.begin(), initial_on_lights.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < (int)initial_on_lights.size(); ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", initial_on_lights[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type edge1\n./gen -n 1 -m 1 -type edge2\n\n./gen -n 2 -m 1 -type edge2\n./gen -n 2 -m 2 -type edge1\n\n./gen -n 10 -m 1 -type edge2\n./gen -n 10 -m 2 -type edge4\n./gen -n 10 -m 1 -type edge3\n./gen -n 10 -m 5 -type left\n./gen -n 10 -m 5 -type right\n./gen -n 10 -m 5 -type middle\n./gen -n 10 -m 5 -type alternating\n./gen -n 10 -m 5 -type clumped\n./gen -n 10 -m 5 -type spread\n./gen -n 10 -m 5 -type random\n\n./gen -n 100 -m 50 -type random\n./gen -n 100 -m 1 -type edge2\n./gen -n 100 -m 100 -type edge1\n./gen -n 100 -m 2 -type edge4\n./gen -n 100 -m 50 -type alternating\n./gen -n 100 -m 50 -type clumped\n./gen -n 100 -m 50 -type spread\n\n./gen -n 999 -m 999 -type edge1\n./gen -n 999 -m 1 -type edge2\n./gen -n 999 -m 500 -type middle\n./gen -n 999 -m 500 -type spread\n./gen -n 999 -m 500 -type random\n\n./gen -n 1000 -m 1 -type edge3\n./gen -n 1000 -m 1000 -type edge1\n./gen -n 1000 -m 500 -type left\n./gen -n 1000 -m 500 -type right\n./gen -n 1000 -m 500 -type alternating\n\n./gen -n 1000 -m 1 -type edge2\n./gen -n 1000 -m 2 -type edge4\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:40.244044",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "294/D",
      "title": "D. Shaass and Painter Robot",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m, (2 ≤ n, m ≤ 105). The second line contains two integers xs and ys (1 ≤ xs ≤ n, 1 ≤ ys ≤ m) and the direction robot is facing initially. Direction is one of the strings: \"UL\" (upper-left direction), \"UR\" (upper-right), \"DL\" (down-left) or \"DR\" (down-right).Note, that record (xs, ys) denotes the tile that is located at the xs-th row from the top and at the ys-th column from the left of the kitchen.It's guaranteed that the starting position will be a border tile (a tile with less than four side-adjacent tiles).",
      "output_spec": "OutputPrint the amount of paint the robot consumes to obtain a checkered kitchen floor. Or print -1 if it never happens.Please do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.",
      "sample_tests": "ExamplesInputCopy3 41 1 DROutputCopy7InputCopy3 43 3 DROutputCopy11InputCopy3 31 1 DROutputCopy-1InputCopy3 31 2 DLOutputCopy4",
      "description": "D. Shaass and Painter Robot\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m, (2 ≤ n, m ≤ 105). The second line contains two integers xs and ys (1 ≤ xs ≤ n, 1 ≤ ys ≤ m) and the direction robot is facing initially. Direction is one of the strings: \"UL\" (upper-left direction), \"UR\" (upper-right), \"DL\" (down-left) or \"DR\" (down-right).Note, that record (xs, ys) denotes the tile that is located at the xs-th row from the top and at the ys-th column from the left of the kitchen.It's guaranteed that the starting position will be a border tile (a tile with less than four side-adjacent tiles).\n\nOutputPrint the amount of paint the robot consumes to obtain a checkered kitchen floor. Or print -1 if it never happens.Please do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.\n\nInputCopy3 41 1 DROutputCopy7InputCopy3 43 3 DROutputCopy11InputCopy3 31 1 DROutputCopy-1InputCopy3 31 2 DLOutputCopy4\n\nInputCopy3 41 1 DR\n\nOutputCopy7\n\nInputCopy3 43 3 DR\n\nOutputCopy11\n\nInputCopy3 31 1 DR\n\nOutputCopy-1\n\nInputCopy3 31 2 DL\n\nOutputCopy4",
      "solutions": [
        {
          "title": "Codeforces Round #178 (Div. 2) - Codeforces",
          "content": "Hi all! :)I (Untitled) invite you to participate in Codeforces Round #178 (Div. 2) which will be held today. I want to thank Gerald Delinur MikeMirzayanov for their help in preparation of this event. I also want to thank havaliza who tested the round and made the graphics for the problems.The hero of today's contest is Shaass. Hope you enjoy helping him! :DGood luck and have fun ;)UPD. Editorial is partially out and will be completed soon! :{",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7271",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 446
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces",
          "content": "294A - Shaass and OskolsAlthough Oskol is not really name of a specie of birds, In Iran it's known as a kind of bird which is very forgetful and can't even remember his way back to home when he flies away! It's commonly used instead of the word \"stupid\" among the kids! :DIn this problem you just have to now how many birds are there on each wire after each shot. A good trick for the first and the last wire would be to define wires 0 and n + 1. In this way the birds that fly away sit on these wires and you don't need to worry about accessing some element outside the range of your array.Here is a neat implementation in C++ from contestant rpslive: 3484601294B - Shaass and BookshelfAs said in the statement, the thickness of each book is either 1 or 2. Think about when we want to arrange v1 books of thickness 1 and v2 books of thickness 2 vertically and arrange all other n - v1 - v2 books horizontally above them to achieve a configuration with total thickness of vertical books equal to v1 + 2v2. Is it possible to find such arrangement? Because the total thickness of vertical books is fixed it's good to calculate the minimum possible total width of horizontal books. As the width of a book doesn't matter in vertical arrangement it's good to use the books with shorter width horizontally and the ones with longer width vertically. So pick out v1 books with longest width among books of thickness 1 and do the same with books of thickness 2. The sum of width of n - v1 - v2 remaining books should be at most v1 + 2v2.The solution would be to try the things we explained above for all possible values of v1 and v2. And print the best answer. :)There exists other ways to solve this problem mostly using dynamic programming but this was the intended solution of the problem.Here is a nice implementation in C++ from contestant bayram: 3485189 (You should also know that 'bir' means 'one' in Turkish and 'iki' means two!)294C - Shaass and LightsI just want to solve the third sample of this problem for you and you can figure out the rest by yourself. :)The third sample is ...#...#... where # is a switched on lamp and . is a switched off lamp. As you can see we have three different types of lights. The first three lights (Type A), the 5th to 8th lights (Type B) and the last three lights (Type C). We have to switch on the lights three times for each type of lights. Aside from the order of moves for each type there are possible permutations of the string AAABBBCCC which tells us how to combine the steps of different types. Switching on the lights is done uniquely for types 1 and 3. But for type 2 each time we have to possible options until we're left with one off light. So there are 23 - 1 ways to do this. So the answer would be 1680*1*4*1 = 6720.The general solution would be to find all groups off consecutive switched off lamps and calculate the number of ways to combine all these groups. Then for each group you should calculate in how many ways it can be solved.The implementation needs some standard combinatorial computations which you can see here: 3485187294D - Shaass and Painter RobotTODO294E - Shaass the GreatTODOI promise the editorial will be completed come soon soon soon! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 294\\s*D"
          },
          "content_length": 3212
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 1",
          "code": "...#...#...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 2",
          "code": "1680*1*4*1 = 6720",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    int xs = inf.readInt(1, n, \"xs\");\n    inf.readSpace();\n    int ys = inf.readInt(1, m, \"ys\");\n    inf.readSpace();\n    string dir = inf.readToken(\"(UL|UR|DL|DR)\", \"dir\");\n    inf.readEoln();\n\n    ensuref(xs == 1 || xs == n || ys == 1 || ys == m,\n        \"Starting position (xs=%d, ys=%d) must be on the border tile\", xs, ys);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    int xs = inf.readInt(1, n, \"xs\");\n    inf.readSpace();\n    int ys = inf.readInt(1, m, \"ys\");\n    inf.readSpace();\n    string dir = inf.readToken(\"(UL|UR|DL|DR)\", \"dir\");\n    inf.readEoln();\n\n    ensuref(xs == 1 || xs == n || ys == 1 || ys == m,\n        \"Starting position (xs=%d, ys=%d) must be on the border tile\", xs, ys);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    int xs = inf.readInt(1, n, \"xs\");\n    inf.readSpace();\n    int ys = inf.readInt(1, m, \"ys\");\n    inf.readSpace();\n    string dir = inf.readToken(\"(UL|UR|DL|DR)\", \"dir\");\n    inf.readEoln();\n\n    ensuref(xs == 1 || xs == n || ys == 1 || ys == m,\n        \"Starting position (xs=%d, ys=%d) must be on the border tile\", xs, ys);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    int xs = opt<int>(\"xs\", -1);\n    int ys = opt<int>(\"ys\", -1);\n    string dir = opt<string>(\"dir\", \"\");\n\n    if (xs == -1 || ys == -1) {\n        // Need to generate starting position\n        vector<pair<int, int>> border_tiles;\n        // Add corners\n        border_tiles.push_back({1, 1});\n        border_tiles.push_back({1, m});\n        border_tiles.push_back({n, 1});\n        border_tiles.push_back({n, m});\n        // Add edges excluding corners\n        if (m >= 3) {\n            for (int y = 2; y <= m - 1; ++y) {\n                border_tiles.push_back({1, y}); // top edge\n                border_tiles.push_back({n, y}); // bottom edge\n            }\n        }\n        if (n >= 3) {\n            for (int x = 2; x <= n - 1; ++x) {\n                border_tiles.push_back({x, 1}); // left edge\n                border_tiles.push_back({x, m}); // right edge\n            }\n        }\n        auto start_pos = rnd.any(border_tiles);\n        xs = start_pos.first;\n        ys = start_pos.second;\n    } else {\n        // Check if xs and ys are on the border\n        if (xs < 1 || xs > n || ys < 1 || ys > m) {\n            fprintf(stderr, \"Error: xs and ys must be within the grid.\\n\");\n            exit(1);\n        }\n        if (!(xs == 1 || xs == n || ys == 1 || ys == m)) {\n            fprintf(stderr, \"Error: Starting position must be on the border.\\n\");\n            exit(1);\n        }\n    }\n\n    if (dir.empty()) {\n        dir = rnd.any(vector<string>{\"UL\", \"UR\", \"DL\", \"DR\"});\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %d %s\\n\", xs, ys, dir.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    int xs = opt<int>(\"xs\", -1);\n    int ys = opt<int>(\"ys\", -1);\n    string dir = opt<string>(\"dir\", \"\");\n\n    if (xs == -1 || ys == -1) {\n        // Need to generate starting position\n        vector<pair<int, int>> border_tiles;\n        // Add corners\n        border_tiles.push_back({1, 1});\n        border_tiles.push_back({1, m});\n        border_tiles.push_back({n, 1});\n        border_tiles.push_back({n, m});\n        // Add edges excluding corners\n        if (m >= 3) {\n            for (int y = 2; y <= m - 1; ++y) {\n                border_tiles.push_back({1, y}); // top edge\n                border_tiles.push_back({n, y}); // bottom edge\n            }\n        }\n        if (n >= 3) {\n            for (int x = 2; x <= n - 1; ++x) {\n                border_tiles.push_back({x, 1}); // left edge\n                border_tiles.push_back({x, m}); // right edge\n            }\n        }\n        auto start_pos = rnd.any(border_tiles);\n        xs = start_pos.first;\n        ys = start_pos.second;\n    } else {\n        // Check if xs and ys are on the border\n        if (xs < 1 || xs > n || ys < 1 || ys > m) {\n            fprintf(stderr, \"Error: xs and ys must be within the grid.\\n\");\n            exit(1);\n        }\n        if (!(xs == 1 || xs == n || ys == 1 || ys == m)) {\n            fprintf(stderr, \"Error: Starting position must be on the border.\\n\");\n            exit(1);\n        }\n    }\n\n    if (dir.empty()) {\n        dir = rnd.any(vector<string>{\"UL\", \"UR\", \"DL\", \"DR\"});\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %d %s\\n\", xs, ys, dir.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -xs 1 -ys 1 -dir DR  # Minimal size\n./gen -n 3 -m 3 -xs 1 -ys 1 -dir DR  # Should output -1\n./gen -n 3 -m 3 -xs 1 -ys 2 -dir DL  # From sample input 4\n\n./gen -n 100000 -m 100000  # Max size, random start\n./gen -n 100000 -m 100000 -xs 1 -ys 1 -dir DR  # Max size, corner start\n\n./gen -n 100000 -m 100000 -xs 1 -ys 1 -dir DR  # Max size, corner start, might be infinite in some cases\n./gen -n 50000 -m 50000 -xs 1 -ys 1 -dir DR  # n and m both even, starting at (1,1), might finish\n\n./gen -n 99999 -m 99999 -xs 1 -ys 1 -dir DR  # n and m both odd, starting at (1,1), infinite loop\n\n./gen -n 100000 -m 2  # n max, m minimal\n./gen -n 2 -m 100000  # m max, n minimal\n\n./gen -n 3 -m 4 -xs 3 -ys 3 -dir DR  # From sample input 2\n\n./gen -n 3 -m 4 -xs 1 -ys 1 -dir DR  # From sample input 1\n\n./gen -n 3 -m 3 -xs 1 -ys 1 -dir DR  # Should output -1\n\n./gen -n 3 -m 3 -xs 1 -ys 2 -dir DL  # Should output 4\n\n./gen -n 1000 -m 1000 -xs 1 -ys 1 -dir DR # Medium size, starting at corner\n\n./gen -n 1000 -m 1000 -xs 1 -ys 500 -dir UR # Starting at middle of top edge\n\n./gen -n 1000 -m 1000 -dir UR # Random border start, random dir\n\n./gen -n 99999 -m 100000 -xs 1 -ys 1 -dir DR # Large n and m, starting at corner\n\n./gen -n 100000 -m 99999 -xs 100000 -ys 1 -dir UL # Large n and m, starting at corner\n\n./gen -n 30000 -m 40000 # Random start\n\n./gen -n 100000 -m 100000 -xs 1 -ys 1 -dir DR # Max size, starting at corner\n\n./gen -n 2 -m 100000 # n minimal, m maximal\n\n./gen -n 100000 -m 2 # m minimal, n maximal\n\n./gen -n 100000 -m 100000 -xs 1 -ys 50000 -dir UR # Starting at middle of top edge\n\n./gen -n 100000 -m 100000 -xs 100000 -ys 50000 -dir DL # Starting at middle of bottom edge\n\n./gen -n 100000 -m 100000 -xs 50000 -ys 1 -dir UR # Left edge\n\n./gen -n 100000 -m 100000 -xs 50000 -ys 100000 -dir UL # Right edge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:42.360757",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "294/E",
      "title": "E. Shaass the Great",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n denoting the number of cities in the empire, (2 ≤ n ≤ 5000). The next n - 1 lines each contains three integers ai, bi and wi showing that two cities ai and bi are connected using a road of length wi, (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ wi ≤ 106).",
      "output_spec": "OutputOn the only line of the output print the minimum pairwise sum of distances between the cities.Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.",
      "sample_tests": "ExamplesInputCopy31 2 21 3 4OutputCopy12InputCopy61 2 12 3 13 4 14 5 15 6 1OutputCopy29InputCopy61 3 12 3 13 4 1004 5 24 6 1OutputCopy825",
      "description": "E. Shaass the Great\n\ntime limit per test3.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n denoting the number of cities in the empire, (2 ≤ n ≤ 5000). The next n - 1 lines each contains three integers ai, bi and wi showing that two cities ai and bi are connected using a road of length wi, (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ wi ≤ 106).\n\nOutputOn the only line of the output print the minimum pairwise sum of distances between the cities.Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.\n\nInputCopy31 2 21 3 4OutputCopy12InputCopy61 2 12 3 13 4 14 5 15 6 1OutputCopy29InputCopy61 3 12 3 13 4 1004 5 24 6 1OutputCopy825\n\nInputCopy31 2 21 3 4\n\nOutputCopy12\n\nInputCopy61 2 12 3 13 4 14 5 15 6 1\n\nOutputCopy29\n\nInputCopy61 3 12 3 13 4 1004 5 24 6 1\n\nOutputCopy825",
      "solutions": [
        {
          "title": "Codeforces Round #178 (Div. 2) - Codeforces",
          "content": "Hi all! :)I (Untitled) invite you to participate in Codeforces Round #178 (Div. 2) which will be held today. I want to thank Gerald Delinur MikeMirzayanov for their help in preparation of this event. I also want to thank havaliza who tested the round and made the graphics for the problems.The hero of today's contest is Shaass. Hope you enjoy helping him! :DGood luck and have fun ;)UPD. Editorial is partially out and will be completed soon! :{",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7271",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 446
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces",
          "content": "294A - Shaass and OskolsAlthough Oskol is not really name of a specie of birds, In Iran it's known as a kind of bird which is very forgetful and can't even remember his way back to home when he flies away! It's commonly used instead of the word \"stupid\" among the kids! :DIn this problem you just have to now how many birds are there on each wire after each shot. A good trick for the first and the last wire would be to define wires 0 and n + 1. In this way the birds that fly away sit on these wires and you don't need to worry about accessing some element outside the range of your array.Here is a neat implementation in C++ from contestant rpslive: 3484601294B - Shaass and BookshelfAs said in the statement, the thickness of each book is either 1 or 2. Think about when we want to arrange v1 books of thickness 1 and v2 books of thickness 2 vertically and arrange all other n - v1 - v2 books horizontally above them to achieve a configuration with total thickness of vertical books equal to v1 + 2v2. Is it possible to find such arrangement? Because the total thickness of vertical books is fixed it's good to calculate the minimum possible total width of horizontal books. As the width of a book doesn't matter in vertical arrangement it's good to use the books with shorter width horizontally and the ones with longer width vertically. So pick out v1 books with longest width among books of thickness 1 and do the same with books of thickness 2. The sum of width of n - v1 - v2 remaining books should be at most v1 + 2v2.The solution would be to try the things we explained above for all possible values of v1 and v2. And print the best answer. :)There exists other ways to solve this problem mostly using dynamic programming but this was the intended solution of the problem.Here is a nice implementation in C++ from contestant bayram: 3485189 (You should also know that 'bir' means 'one' in Turkish and 'iki' means two!)294C - Shaass and LightsI just want to solve the third sample of this problem for you and you can figure out the rest by yourself. :)The third sample is ...#...#... where # is a switched on lamp and . is a switched off lamp. As you can see we have three different types of lights. The first three lights (Type A), the 5th to 8th lights (Type B) and the last three lights (Type C). We have to switch on the lights three times for each type of lights. Aside from the order of moves for each type there are possible permutations of the string AAABBBCCC which tells us how to combine the steps of different types. Switching on the lights is done uniquely for types 1 and 3. But for type 2 each time we have to possible options until we're left with one off light. So there are 23 - 1 ways to do this. So the answer would be 1680*1*4*1 = 6720.The general solution would be to find all groups off consecutive switched off lamps and calculate the number of ways to combine all these groups. Then for each group you should calculate in how many ways it can be solved.The implementation needs some standard combinatorial computations which you can see here: 3485187294D - Shaass and Painter RobotTODO294E - Shaass the GreatTODOI promise the editorial will be completed come soon soon soon! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 294\\s*E"
          },
          "content_length": 3212
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 1",
          "code": "...#...#...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #178 Editorial - Codeforces - Code 2",
          "code": "1680*1*4*1 = 6720",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7287",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000, \"wi\");\n        inf.readEoln();\n\n        int u = ai;\n        int v = bi;\n        if (u > v) swap(u, v);\n\n        ensuref(edges.count({u, v}) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert({u, v});\n\n        int root_u = find(u);\n        int root_v = find(v);\n        ensuref(root_u != root_v, \"Edges create a cycle between %d and %d\", u, v);\n\n        unite(u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000, \"wi\");\n        inf.readEoln();\n\n        int u = ai;\n        int v = bi;\n        if (u > v) swap(u, v);\n\n        ensuref(edges.count({u, v}) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert({u, v});\n\n        int root_u = find(u);\n        int root_v = find(v);\n        ensuref(root_u != root_v, \"Edges create a cycle between %d and %d\", u, v);\n\n        unite(u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000, \"wi\");\n        inf.readEoln();\n\n        int u = ai;\n        int v = bi;\n        if (u > v) swap(u, v);\n\n        ensuref(edges.count({u, v}) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert({u, v});\n\n        int root_u = find(u);\n        int root_v = find(v);\n        ensuref(root_u != root_v, \"Edges create a cycle between %d and %d\", u, v);\n\n        unite(u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string weight_type = opt<string>(\"weight_type\", \"random\");\n    int weight_value = opt<int>(\"weight_value\", -1);\n\n    vector<pair<int,int>> edges;\n    vector<int> parent(n, -1);\n\n    if(tree_type == \"chain\") {\n        // Build a chain/tree (line)\n        for(int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i - 1, i));\n            parent[i] = i - 1;\n        }\n    } else if(tree_type == \"star\") {\n        // Build a star (all connected to node 0)\n        for(int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(0, i));\n            parent[i] = 0;\n        }\n    } else if(tree_type == \"binary\") {\n        // Build a binary tree\n        for(int i = 1; i < n; ++i) {\n            parent[i] = (i - 1) / 2;\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else if(tree_type == \"skewed\") {\n        // Build a skewed tree\n        for(int i = 1; i < n - 1; ++i) {\n            parent[i] = i + 1;\n            edges.push_back(make_pair(parent[i], i));\n        }\n        parent[n - 1] = 0;\n        edges.push_back(make_pair(0, n - 1));\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i) {\n            parent[i] = rnd.next(0, i - 1);\n            edges.push_back(make_pair(parent[i], i));\n        }\n    }\n\n    // Assign weights\n    vector<int> weights(n - 1);\n    int min_w = 1;\n    int max_w = 1000000; // 1e6\n\n    if (weight_type == \"uniform\") {\n        int w = weight_value;\n        if (w == -1) w = min_w;\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = w;\n        }\n    } else if (weight_type == \"min\") {\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = min_w;\n        }\n    } else if (weight_type == \"max\") {\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = max_w;\n        }\n    } else if (weight_type == \"random\") {\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = rnd.next(min_w, max_w);\n        }\n    } else if (weight_type == \"zigzag\") {\n        // Alternate between min and max\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = (i % 2 == 0) ? min_w : max_w;\n        }\n    } else if (weight_type == \"increasing\") {\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = min_w + (i % (max_w - min_w + 1));\n        }\n    } else {\n        // Default to random weights\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = rnd.next(min_w, max_w);\n        }\n    }\n\n    // Output the tree\n    // Shuffle the edges to avoid any patterns\n    vector<int> order(n - 1);\n    for(int i = 0; i < n - 1; ++i) order[i] = i;\n    shuffle(order.begin(), order.end());\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n - 1; ++i) {\n        int idx = order[i];\n        int a = edges[idx].first + 1; // Node indices from 1 to n\n        int b = edges[idx].second + 1;\n        int w = weights[idx];\n        printf(\"%d %d %d\\n\", a, b, w);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string weight_type = opt<string>(\"weight_type\", \"random\");\n    int weight_value = opt<int>(\"weight_value\", -1);\n\n    vector<pair<int,int>> edges;\n    vector<int> parent(n, -1);\n\n    if(tree_type == \"chain\") {\n        // Build a chain/tree (line)\n        for(int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i - 1, i));\n            parent[i] = i - 1;\n        }\n    } else if(tree_type == \"star\") {\n        // Build a star (all connected to node 0)\n        for(int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(0, i));\n            parent[i] = 0;\n        }\n    } else if(tree_type == \"binary\") {\n        // Build a binary tree\n        for(int i = 1; i < n; ++i) {\n            parent[i] = (i - 1) / 2;\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else if(tree_type == \"skewed\") {\n        // Build a skewed tree\n        for(int i = 1; i < n - 1; ++i) {\n            parent[i] = i + 1;\n            edges.push_back(make_pair(parent[i], i));\n        }\n        parent[n - 1] = 0;\n        edges.push_back(make_pair(0, n - 1));\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i) {\n            parent[i] = rnd.next(0, i - 1);\n            edges.push_back(make_pair(parent[i], i));\n        }\n    }\n\n    // Assign weights\n    vector<int> weights(n - 1);\n    int min_w = 1;\n    int max_w = 1000000; // 1e6\n\n    if (weight_type == \"uniform\") {\n        int w = weight_value;\n        if (w == -1) w = min_w;\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = w;\n        }\n    } else if (weight_type == \"min\") {\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = min_w;\n        }\n    } else if (weight_type == \"max\") {\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = max_w;\n        }\n    } else if (weight_type == \"random\") {\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = rnd.next(min_w, max_w);\n        }\n    } else if (weight_type == \"zigzag\") {\n        // Alternate between min and max\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = (i % 2 == 0) ? min_w : max_w;\n        }\n    } else if (weight_type == \"increasing\") {\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = min_w + (i % (max_w - min_w + 1));\n        }\n    } else {\n        // Default to random weights\n        for(int i = 0; i < n - 1; ++i) {\n            weights[i] = rnd.next(min_w, max_w);\n        }\n    }\n\n    // Output the tree\n    // Shuffle the edges to avoid any patterns\n    vector<int> order(n - 1);\n    for(int i = 0; i < n - 1; ++i) order[i] = i;\n    shuffle(order.begin(), order.end());\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n - 1; ++i) {\n        int idx = order[i];\n        int a = edges[idx].first + 1; // Node indices from 1 to n\n        int b = edges[idx].second + 1;\n        int w = weights[idx];\n        printf(\"%d %d %d\\n\", a, b, w);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -tree_type chain -weight_type min\n./gen -n 2 -tree_type chain -weight_type max\n./gen -n 3 -tree_type chain -weight_type min\n./gen -n 3 -tree_type chain -weight_type max\n./gen -n 3 -tree_type star -weight_type uniform -weight_value 1\n./gen -n 3 -tree_type star -weight_type uniform -weight_value 1000000\n\n./gen -n 50 -tree_type chain -weight_type min\n./gen -n 50 -tree_type star -weight_type max\n./gen -n 50 -tree_type random -weight_type random\n\n./gen -n 5000 -tree_type chain -weight_type min\n./gen -n 5000 -tree_type chain -weight_type max\n./gen -n 5000 -tree_type star -weight_type min\n./gen -n 5000 -tree_type star -weight_type max\n./gen -n 5000 -tree_type binary -weight_type min\n./gen -n 5000 -tree_type binary -weight_type max\n./gen -n 5000 -tree_type random -weight_type random\n./gen -n 5000 -tree_type random -weight_type min\n./gen -n 5000 -tree_type random -weight_type max\n./gen -n 5000 -tree_type skewed -weight_type zigzag\n./gen -n 5000 -tree_type skewed -weight_type increasing\n\n./gen -n 1000 -tree_type chain -weight_type min\n./gen -n 1000 -tree_type chain -weight_type max\n./gen -n 1000 -tree_type binary -weight_type random\n./gen -n 5000 -tree_type skewed -weight_type random\n\n./gen -n 5000 -tree_type random -weight_type uniform -weight_value 1\n./gen -n 5000 -tree_type random -weight_type uniform -weight_value 1000\n./gen -n 5000 -tree_type random -weight_type uniform -weight_value 1000000\n\n./gen -n 4999 -tree_type random -weight_type random\n./gen -n 2 -tree_type random -weight_type random\n./gen -n 2 -tree_type star -weight_type random\n./gen -n 5000 -tree_type chain -weight_type zigzag\n./gen -n 5000 -tree_type binary -weight_type increasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:44.075718",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "295/A",
      "title": "A. Greg and Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, m, k (1 ≤ n, m, k ≤ 105). The second line contains n integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the initial array.Next m lines contain operations, the operation number i is written as three integers: li, ri, di, (1 ≤ li ≤ ri ≤ n), (0 ≤ di ≤ 105).Next k lines contain the queries, the query number i is written as two integers: xi, yi, (1 ≤ xi ≤ yi ≤ m).The numbers in the lines are separated by single spaces.",
      "output_spec": "OutputOn a single line print n integers a1, a2, ..., an — the array after executing all the queries. Separate the printed numbers by spaces.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy3 3 31 2 31 2 11 3 22 3 41 21 32 3OutputCopy9 18 17InputCopy1 1 111 1 11 1OutputCopy2InputCopy4 3 61 2 3 41 2 12 3 23 4 41 21 32 31 21 32 3OutputCopy5 18 31 20",
      "description": "A. Greg and Array\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m, k (1 ≤ n, m, k ≤ 105). The second line contains n integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the initial array.Next m lines contain operations, the operation number i is written as three integers: li, ri, di, (1 ≤ li ≤ ri ≤ n), (0 ≤ di ≤ 105).Next k lines contain the queries, the query number i is written as two integers: xi, yi, (1 ≤ xi ≤ yi ≤ m).The numbers in the lines are separated by single spaces.\n\nOutputOn a single line print n integers a1, a2, ..., an — the array after executing all the queries. Separate the printed numbers by spaces.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.\n\nInputCopy3 3 31 2 31 2 11 3 22 3 41 21 32 3OutputCopy9 18 17InputCopy1 1 111 1 11 1OutputCopy2InputCopy4 3 61 2 3 41 2 12 3 23 4 41 21 32 31 21 32 3OutputCopy5 18 31 20\n\nInputCopy3 3 31 2 31 2 11 3 22 3 41 21 32 3\n\nOutputCopy9 18 17\n\nInputCopy1 1 111 1 11 1\n\nOutputCopy2\n\nInputCopy4 3 61 2 3 41 2 12 3 23 4 41 21 32 31 21 32 3\n\nOutputCopy5 18 31 20",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Hello everyone!Codeforces Round #179 will take place on Thursday, April 11th at 19:30 MSK. This is my fifth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problems point values for 1 division will be standart. For the 2 division it will be: 500-1500-1500-2000-2500.Gl & hf ! :)Contest is over. I hope that problems vere interesting for you. Division 1 winners:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Division 2 winners:1). goie2). Koblyk3). Beriand Ideas of the solutions are here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 683
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Yaroslav and PermutationsNote that after applying the operations of the exchange, we can get any permutation of numbers. Not difficult to understand that the answer is \"YES\", if you can place a single number that it would not stand in the neighboring cells. Thus, if a some number is meeted C times, it must fulfill the condition C <= (n+1) / 2.296B - Yaroslav and Two StringsБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Greg and ArrayДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Greg and GraphДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Greg and FriendsЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Greg and CavesБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Yaroslav and PointsНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 295\\s*A"
          },
          "content_length": 4571
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    vector<int> a = inf.readInts(n, 0, 100000);\n    inf.readEoln();\n\n    // Read m operations\n    for (int i = 1; i <= m; ++i) {\n        // Read li\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        // Read ri\n        int ri = inf.readInt(li, n, \"ri\"); // ri >= li\n        inf.readSpace();\n        // Read di\n        int di = inf.readInt(0, 100000, \"di\");\n        inf.readEoln();\n    }\n\n    // Read k queries\n    for (int i = 1; i <= k; ++i) {\n        // Read xi\n        int xi = inf.readInt(1, m, \"xi\");\n        inf.readSpace();\n        // Read yi\n        int yi = inf.readInt(xi, m, \"yi\"); // yi >= xi\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    vector<int> a = inf.readInts(n, 0, 100000);\n    inf.readEoln();\n\n    // Read m operations\n    for (int i = 1; i <= m; ++i) {\n        // Read li\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        // Read ri\n        int ri = inf.readInt(li, n, \"ri\"); // ri >= li\n        inf.readSpace();\n        // Read di\n        int di = inf.readInt(0, 100000, \"di\");\n        inf.readEoln();\n    }\n\n    // Read k queries\n    for (int i = 1; i <= k; ++i) {\n        // Read xi\n        int xi = inf.readInt(1, m, \"xi\");\n        inf.readSpace();\n        // Read yi\n        int yi = inf.readInt(xi, m, \"yi\"); // yi >= xi\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    vector<int> a = inf.readInts(n, 0, 100000);\n    inf.readEoln();\n\n    // Read m operations\n    for (int i = 1; i <= m; ++i) {\n        // Read li\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        // Read ri\n        int ri = inf.readInt(li, n, \"ri\"); // ri >= li\n        inf.readSpace();\n        // Read di\n        int di = inf.readInt(0, 100000, \"di\");\n        inf.readEoln();\n    }\n\n    // Read k queries\n    for (int i = 1; i <= k; ++i) {\n        // Read xi\n        int xi = inf.readInt(1, m, \"xi\");\n        inf.readSpace();\n        // Read yi\n        int yi = inf.readInt(xi, m, \"yi\"); // yi >= xi\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"edge_cases\") {\n        // minimal n, m, k\n        n = 1;\n        m = 1;\n        k = 1;\n        a[0] = 1;\n\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"%d\\n\", a[0]);\n        printf(\"%d %d %d\\n\", 1, 1, 1);\n        printf(\"%d %d\\n\", 1, 1);\n        return 0;\n    }\n    else if (type == \"random\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n\n        vector<int> l(m), r(m), d(m);\n        for (int i = 0; i < m; ++i) {\n            l[i] = rnd.next(1, n);\n            r[i] = rnd.next(1, n);\n            if (l[i] > r[i]) swap(l[i], r[i]);\n            d[i] = rnd.next(0, 100000);\n        }\n\n        vector<int> x(k), y(k);\n        for (int i = 0; i < k; ++i) {\n            x[i] = rnd.next(1, m);\n            y[i] = rnd.next(1, m);\n            if (x[i] > y[i]) swap(x[i], y[i]);\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n        }\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d %d\\n\", l[i], r[i], d[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d %d\\n\", x[i], y[i]);\n        }\n    }\n    else if (type == \"max_di\") {\n        // di is maximum\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n\n        vector<int> l(m), r(m), d(m);\n        for (int i = 0; i < m; ++i) {\n            l[i] = rnd.next(1, n);\n            r[i] = rnd.next(1, n);\n            if (l[i] > r[i]) swap(l[i], r[i]);\n            d[i] = 100000;\n        }\n\n        vector<int> x(k), y(k);\n        for (int i = 0; i < k; ++i) {\n            x[i] = 1;\n            y[i] = m;\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n        }\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d %d\\n\", l[i], r[i], d[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d %d\\n\", x[i], y[i]);\n        }\n    }\n    else if (type == \"single_element\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        vector<int> l(m), r(m), d(m);\n        int index = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            l[i] = index;\n            r[i] = index;\n            d[i] = rnd.next(0, 100000);\n        }\n        vector<int> x(k), y(k);\n        for (int i = 0; i < k; ++i) {\n            x[i] = rnd.next(1, m);\n            y[i] = rnd.next(x[i], m);\n        }\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n        }\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d %d\\n\", l[i], r[i], d[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d %d\\n\", x[i], y[i]);\n        }\n    }\n    else if (type == \"full_range\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        vector<int> l(m), r(m), d(m);\n        for (int i = 0; i < m; ++i) {\n            l[i] = 1;\n            r[i] = n;\n            d[i] = rnd.next(0, 100000);\n        }\n        vector<int> x(k), y(k);\n        for (int i = 0; i < k; ++i) {\n            x[i] = 1;\n            y[i] = m;\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n        }\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d %d\\n\", l[i], r[i], d[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d %d\\n\", x[i], y[i]);\n        }\n    }\n    else {\n        // Default to random (same as above)\n        // ...\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"edge_cases\") {\n        // minimal n, m, k\n        n = 1;\n        m = 1;\n        k = 1;\n        a[0] = 1;\n\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"%d\\n\", a[0]);\n        printf(\"%d %d %d\\n\", 1, 1, 1);\n        printf(\"%d %d\\n\", 1, 1);\n        return 0;\n    }\n    else if (type == \"random\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n\n        vector<int> l(m), r(m), d(m);\n        for (int i = 0; i < m; ++i) {\n            l[i] = rnd.next(1, n);\n            r[i] = rnd.next(1, n);\n            if (l[i] > r[i]) swap(l[i], r[i]);\n            d[i] = rnd.next(0, 100000);\n        }\n\n        vector<int> x(k), y(k);\n        for (int i = 0; i < k; ++i) {\n            x[i] = rnd.next(1, m);\n            y[i] = rnd.next(1, m);\n            if (x[i] > y[i]) swap(x[i], y[i]);\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n        }\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d %d\\n\", l[i], r[i], d[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d %d\\n\", x[i], y[i]);\n        }\n    }\n    else if (type == \"max_di\") {\n        // di is maximum\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n\n        vector<int> l(m), r(m), d(m);\n        for (int i = 0; i < m; ++i) {\n            l[i] = rnd.next(1, n);\n            r[i] = rnd.next(1, n);\n            if (l[i] > r[i]) swap(l[i], r[i]);\n            d[i] = 100000;\n        }\n\n        vector<int> x(k), y(k);\n        for (int i = 0; i < k; ++i) {\n            x[i] = 1;\n            y[i] = m;\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n        }\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d %d\\n\", l[i], r[i], d[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d %d\\n\", x[i], y[i]);\n        }\n    }\n    else if (type == \"single_element\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        vector<int> l(m), r(m), d(m);\n        int index = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            l[i] = index;\n            r[i] = index;\n            d[i] = rnd.next(0, 100000);\n        }\n        vector<int> x(k), y(k);\n        for (int i = 0; i < k; ++i) {\n            x[i] = rnd.next(1, m);\n            y[i] = rnd.next(x[i], m);\n        }\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n        }\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d %d\\n\", l[i], r[i], d[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d %d\\n\", x[i], y[i]);\n        }\n    }\n    else if (type == \"full_range\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        vector<int> l(m), r(m), d(m);\n        for (int i = 0; i < m; ++i) {\n            l[i] = 1;\n            r[i] = n;\n            d[i] = rnd.next(0, 100000);\n        }\n        vector<int> x(k), y(k);\n        for (int i = 0; i < k; ++i) {\n            x[i] = 1;\n            y[i] = m;\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n        }\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d %d\\n\", l[i], r[i], d[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d %d\\n\", x[i], y[i]);\n        }\n    }\n    else {\n        // Default to random (same as above)\n        // ...\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type edge_cases\n./gen -n 3 -m 3 -k 3 -type random\n./gen -n 10 -m 10 -k 10 -type random\n./gen -n 100 -m 100 -k 100 -type random\n./gen -n 1000 -m 1000 -k 1000 -type random\n./gen -n 10000 -m 10000 -k 10000 -type random\n./gen -n 100000 -m 100000 -k 100000 -type random\n\n./gen -n 5 -m 5 -k 5 -type max_di\n./gen -n 1000 -m 1000 -k 1000 -type max_di\n./gen -n 100000 -m 100000 -k 100000 -type max_di\n\n./gen -n 1000 -m 1000 -k 1000 -type single_element\n./gen -n 100000 -m 100000 -k 100000 -type single_element\n\n./gen -n 1000 -m 1000 -k 1000 -type full_range\n./gen -n 100000 -m 100000 -k 100000 -type full_range\n\n./gen -n 1 -m 1 -k 1 -type random\n./gen -n 100000 -m 100000 -k 1 -type random\n./gen -n 100000 -m 1 -k 100000 -type random\n\n./gen -n 100000 -m 100000 -k 100000 -type random\n\n./gen -n 100000 -m 100000 -k 100000 -type single_element\n\n./gen -n 100000 -m 100000 -k 100000 -type full_range\n\n./gen -n 50000 -m 50000 -k 50000 -type random\n./gen -n 100 -m 1000 -k 10000 -type random\n./gen -n 10000 -m 10000 -k 100 -type random\n./gen -n 99999 -m 99999 -k 99999 -type max_di\n./gen -n 100 -m 100000 -k 100000 -type random\n./gen -n 100000 -m 100000 -k 100 -type random\n./gen -n 100 -m 100 -k 100000 -type random\n./gen -n 20000 -m 20000 -k 20000 -type random\n./gen -n 20000 -m 100000 -k 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:46.046176",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "295/B",
      "title": "B. Greg and Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 500) — the number of vertices in the graph.Next n lines contain n integers each — the graph adjacency matrix: the j-th number in the i-th line aij (1 ≤ aij ≤ 105, aii = 0) represents the weight of the edge that goes from vertex i to vertex j.The next line contains n distinct integers: x1, x2, ..., xn (1 ≤ xi ≤ n) — the vertices that Greg deletes.",
      "output_spec": "OutputPrint n integers — the i-th number equals the required sum before the i-th step.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy101OutputCopy0 InputCopy20 54 01 2OutputCopy9 0 InputCopy40 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3OutputCopy17 23 404 0",
      "description": "B. Greg and Graph\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 500) — the number of vertices in the graph.Next n lines contain n integers each — the graph adjacency matrix: the j-th number in the i-th line aij (1 ≤ aij ≤ 105, aii = 0) represents the weight of the edge that goes from vertex i to vertex j.The next line contains n distinct integers: x1, x2, ..., xn (1 ≤ xi ≤ n) — the vertices that Greg deletes.\n\nOutputPrint n integers — the i-th number equals the required sum before the i-th step.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.\n\nInputCopy101OutputCopy0 InputCopy20 54 01 2OutputCopy9 0 InputCopy40 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3OutputCopy17 23 404 0\n\nInputCopy101\n\nOutputCopy0\n\nInputCopy20 54 01 2\n\nOutputCopy9 0\n\nInputCopy40 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3\n\nOutputCopy17 23 404 0",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Hello everyone!Codeforces Round #179 will take place on Thursday, April 11th at 19:30 MSK. This is my fifth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problems point values for 1 division will be standart. For the 2 division it will be: 500-1500-1500-2000-2500.Gl & hf ! :)Contest is over. I hope that problems vere interesting for you. Division 1 winners:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Division 2 winners:1). goie2). Koblyk3). Beriand Ideas of the solutions are here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 683
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Yaroslav and PermutationsNote that after applying the operations of the exchange, we can get any permutation of numbers. Not difficult to understand that the answer is \"YES\", if you can place a single number that it would not stand in the neighboring cells. Thus, if a some number is meeted C times, it must fulfill the condition C <= (n+1) / 2.296B - Yaroslav and Two StringsБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Greg and ArrayДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Greg and GraphДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Greg and FriendsЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Greg and CavesБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Yaroslav and PointsНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 295\\s*B"
          },
          "content_length": 4571
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> a = inf.readInts(n, 0, 100000, format(\"a[%d]\", i+1));\n        inf.readEoln();\n        ensuref(a[i] == 0, \"a[%d][%d] should be 0 but is %d\", i+1, i+1, a[i]);\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                ensuref(a[j] >= 1, \"a[%d][%d] should be at least 1 but is %d\", i+1, j+1, a[j]);\n            }\n        }\n    }\n\n    vector<int> x = inf.readInts(n, 1, n, \"x\");\n    inf.readEoln();\n    set<int> xs(x.begin(), x.end());\n    ensuref(int(xs.size()) == n, \"Vertices x1..xn must be distinct integers between 1 and n inclusive\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> a = inf.readInts(n, 0, 100000, format(\"a[%d]\", i+1));\n        inf.readEoln();\n        ensuref(a[i] == 0, \"a[%d][%d] should be 0 but is %d\", i+1, i+1, a[i]);\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                ensuref(a[j] >= 1, \"a[%d][%d] should be at least 1 but is %d\", i+1, j+1, a[j]);\n            }\n        }\n    }\n\n    vector<int> x = inf.readInts(n, 1, n, \"x\");\n    inf.readEoln();\n    set<int> xs(x.begin(), x.end());\n    ensuref(int(xs.size()) == n, \"Vertices x1..xn must be distinct integers between 1 and n inclusive\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> a = inf.readInts(n, 0, 100000, format(\"a[%d]\", i+1));\n        inf.readEoln();\n        ensuref(a[i] == 0, \"a[%d][%d] should be 0 but is %d\", i+1, i+1, a[i]);\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                ensuref(a[j] >= 1, \"a[%d][%d] should be at least 1 but is %d\", i+1, j+1, a[j]);\n            }\n        }\n    }\n\n    vector<int> x = inf.readInts(n, 1, n, \"x\");\n    inf.readEoln();\n    set<int> xs(x.begin(), x.end());\n    ensuref(int(xs.size()) == n, \"Vertices x1..xn must be distinct integers between 1 and n inclusive\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n    string deltype = opt<string>(\"deltype\", \"random\");\n    \n    // Initialize adjacency matrix\n    vector<vector<int>> a(n, vector<int>(n));\n\n    // Generate adjacency matrix according to wtype\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(i == j) {\n                a[i][j] = 0;\n            } else {\n                if(wtype == \"constant\") {\n                    a[i][j] = 1;\n                } else if(wtype == \"max\") {\n                    a[i][j] = 100000; // 1e5\n                } else if(wtype == \"random\") {\n                    a[i][j] = rnd.next(1, 100000);\n                } else if(wtype == \"inc\") {\n                    a[i][j] = ((i + j) % 100000) + 1;\n                } else if(wtype == \"dec\") {\n                    a[i][j] = ((2 * n - i - j) % 100000) + 1;\n                } else {\n                    // Default to random\n                    a[i][j] = rnd.next(1, 100000);\n                }\n            }\n        }\n    }\n\n    // Generate deletion sequence xs\n    vector<int> xs(n);\n    for(int i = 0; i < n; ++i) {\n        xs[i] = i + 1;\n    }\n\n    if(deltype == \"sorted\") {\n        // xs already in order\n    } else if(deltype == \"reversed\") {\n        reverse(xs.begin(), xs.end());\n    } else if(deltype == \"random\") {\n        shuffle(xs.begin(), xs.end());\n    } else {\n        // Default to random\n        shuffle(xs.begin(), xs.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output adjacency matrix\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", a[i][j]);\n            if(j + 1 < n)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    // Output deletion sequence\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", xs[i]);\n        if(i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n    string deltype = opt<string>(\"deltype\", \"random\");\n    \n    // Initialize adjacency matrix\n    vector<vector<int>> a(n, vector<int>(n));\n\n    // Generate adjacency matrix according to wtype\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(i == j) {\n                a[i][j] = 0;\n            } else {\n                if(wtype == \"constant\") {\n                    a[i][j] = 1;\n                } else if(wtype == \"max\") {\n                    a[i][j] = 100000; // 1e5\n                } else if(wtype == \"random\") {\n                    a[i][j] = rnd.next(1, 100000);\n                } else if(wtype == \"inc\") {\n                    a[i][j] = ((i + j) % 100000) + 1;\n                } else if(wtype == \"dec\") {\n                    a[i][j] = ((2 * n - i - j) % 100000) + 1;\n                } else {\n                    // Default to random\n                    a[i][j] = rnd.next(1, 100000);\n                }\n            }\n        }\n    }\n\n    // Generate deletion sequence xs\n    vector<int> xs(n);\n    for(int i = 0; i < n; ++i) {\n        xs[i] = i + 1;\n    }\n\n    if(deltype == \"sorted\") {\n        // xs already in order\n    } else if(deltype == \"reversed\") {\n        reverse(xs.begin(), xs.end());\n    } else if(deltype == \"random\") {\n        shuffle(xs.begin(), xs.end());\n    } else {\n        // Default to random\n        shuffle(xs.begin(), xs.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output adjacency matrix\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", a[i][j]);\n            if(j + 1 < n)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    // Output deletion sequence\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", xs[i]);\n        if(i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -wtype constant -deltype sorted\n./gen -n 1 -wtype random -deltype random\n\n./gen -n 2 -wtype constant -deltype sorted\n./gen -n 2 -wtype random -deltype random\n\n./gen -n 3 -wtype inc -deltype random\n./gen -n 3 -wtype dec -deltype random\n\n./gen -n 4 -wtype random -deltype random\n\n./gen -n 10 -wtype constant -deltype sorted\n./gen -n 10 -wtype max -deltype reversed\n./gen -n 10 -wtype random -deltype random\n\n./gen -n 50 -wtype inc -deltype random\n./gen -n 50 -wtype dec -deltype sorted\n\n./gen -n 100 -wtype constant -deltype sorted\n./gen -n 100 -wtype random -deltype random\n\n./gen -n 499 -wtype max -deltype random\n./gen -n 499 -wtype random -deltype random\n\n./gen -n 500 -wtype constant -deltype sorted\n./gen -n 500 -wtype max -deltype sorted\n./gen -n 500 -wtype max -deltype random\n./gen -n 500 -wtype random -deltype reversed\n./gen -n 500 -wtype random -deltype random\n./gen -n 500 -wtype inc -deltype random\n./gen -n 500 -wtype dec -deltype random\n./gen -n 500 -wtype inc -deltype sorted\n./gen -n 500 -wtype dec -deltype reversed\n./gen -n 500 -wtype random -deltype sorted\n./gen -n 500 -wtype constant -deltype reversed\n\n./gen -n 500 -wtype random -deltype random\n./gen -n 500 -wtype random -deltype random\n./gen -n 500 -wtype random -deltype random\n./gen -n 500 -wtype random -deltype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:48.310017",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "295/C",
      "title": "C. Greg and Friends",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ 5000) — the number of people, including Greg, and the boat's weight limit. The next line contains n integers — the people's weights. A person's weight is either 50 kilos or 100 kilos.You can consider Greg and his friends indexed in some way.",
      "output_spec": "OutputIn the first line print an integer — the minimum number of rides. If transporting everyone to the other bank is impossible, print an integer -1.In the second line print the remainder after dividing the number of ways to transport the people in the minimum number of rides by number 1000000007 (109 + 7). If transporting everyone to the other bank is impossible, print integer 0.",
      "sample_tests": "ExamplesInputCopy1 5050OutputCopy11InputCopy3 10050 50 100OutputCopy52InputCopy2 5050 50OutputCopy-10",
      "description": "C. Greg and Friends\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ 5000) — the number of people, including Greg, and the boat's weight limit. The next line contains n integers — the people's weights. A person's weight is either 50 kilos or 100 kilos.You can consider Greg and his friends indexed in some way.\n\nOutputIn the first line print an integer — the minimum number of rides. If transporting everyone to the other bank is impossible, print an integer -1.In the second line print the remainder after dividing the number of ways to transport the people in the minimum number of rides by number 1000000007 (109 + 7). If transporting everyone to the other bank is impossible, print integer 0.\n\nInputCopy1 5050OutputCopy11InputCopy3 10050 50 100OutputCopy52InputCopy2 5050 50OutputCopy-10\n\nInputCopy1 5050\n\nOutputCopy11\n\nInputCopy3 10050 50 100\n\nOutputCopy52\n\nInputCopy2 5050 50\n\nOutputCopy-10\n\nNoteIn the first test Greg walks alone and consequently, he needs only one ride across the river.In the second test you should follow the plan:  transport two 50 kg. people;  transport one 50 kg. person back;  transport one 100 kg. person;  transport one 50 kg. person back;  transport two 50 kg. people. That totals to 5 rides. Depending on which person to choose at step 2, we can get two distinct ways.",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Hello everyone!Codeforces Round #179 will take place on Thursday, April 11th at 19:30 MSK. This is my fifth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problems point values for 1 division will be standart. For the 2 division it will be: 500-1500-1500-2000-2500.Gl & hf ! :)Contest is over. I hope that problems vere interesting for you. Division 1 winners:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Division 2 winners:1). goie2). Koblyk3). Beriand Ideas of the solutions are here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 683
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Yaroslav and PermutationsNote that after applying the operations of the exchange, we can get any permutation of numbers. Not difficult to understand that the answer is \"YES\", if you can place a single number that it would not stand in the neighboring cells. Thus, if a some number is meeted C times, it must fulfill the condition C <= (n+1) / 2.296B - Yaroslav and Two StringsБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Greg and ArrayДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Greg and GraphДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Greg and FriendsЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Greg and CavesБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Yaroslav and PointsНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 295\\s*C"
          },
          "content_length": 4571
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,50,\"n\");\n    inf.readSpace();\n    int k = inf.readInt(1,5000,\"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n,50,100,\"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        ensuref(a[i] == 50 || a[i] == 100, \"Weight at position %d is %d, expected 50 or 100\", i+1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,50,\"n\");\n    inf.readSpace();\n    int k = inf.readInt(1,5000,\"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n,50,100,\"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        ensuref(a[i] == 50 || a[i] == 100, \"Weight at position %d is %d, expected 50 or 100\", i+1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,50,\"n\");\n    inf.readSpace();\n    int k = inf.readInt(1,5000,\"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n,50,100,\"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        ensuref(a[i] == 50 || a[i] == 100, \"Weight at position %d is %d, expected 50 or 100\", i+1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 5000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> weights(n);\n\n    if (type == \"all50\") {\n        for (int i = 0; i < n; i++)\n            weights[i] = 50;\n    }\n    else if (type == \"all100\") {\n        for (int i = 0; i < n; i++)\n            weights[i] = 100;\n    }\n    else if (type == \"mix\") {\n        for (int i = 0; i < n; i++)\n            weights[i] = rnd.next(2) == 0 ? 50 : 100;\n    }\n    else if (type == \"impossible_small_k\") {\n        // k is less than 50, impossible to transport anyone\n        k = rnd.next(1, 49);\n        for (int i = 0; i < n; i++)\n            weights[i] = 50;\n    }\n    else if (type == \"impossible_heavy_people\") {\n        // k less than 100, all people weigh 100, cannot transport any\n        k = rnd.next(50, 99);\n        for (int i = 0; i < n; i++)\n            weights[i] = 100;\n    }\n    else {\n        // Random weights\n        for (int i = 0; i < n; i++)\n            weights[i] = rnd.next(2) == 0 ? 50 : 100;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output weights\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", weights[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 5000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> weights(n);\n\n    if (type == \"all50\") {\n        for (int i = 0; i < n; i++)\n            weights[i] = 50;\n    }\n    else if (type == \"all100\") {\n        for (int i = 0; i < n; i++)\n            weights[i] = 100;\n    }\n    else if (type == \"mix\") {\n        for (int i = 0; i < n; i++)\n            weights[i] = rnd.next(2) == 0 ? 50 : 100;\n    }\n    else if (type == \"impossible_small_k\") {\n        // k is less than 50, impossible to transport anyone\n        k = rnd.next(1, 49);\n        for (int i = 0; i < n; i++)\n            weights[i] = 50;\n    }\n    else if (type == \"impossible_heavy_people\") {\n        // k less than 100, all people weigh 100, cannot transport any\n        k = rnd.next(50, 99);\n        for (int i = 0; i < n; i++)\n            weights[i] = 100;\n    }\n    else {\n        // Random weights\n        for (int i = 0; i < n; i++)\n            weights[i] = rnd.next(2) == 0 ? 50 : 100;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output weights\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", weights[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 50 -type all50\n./gen -n 1 -k 100 -type all100\n./gen -n 2 -k 100 -type all50\n./gen -n 2 -k 50 -type all50\n./gen -n 3 -k 100 -type mix\n./gen -n 5 -k 150 -type mix\n./gen -n 10 -k 200 -type mix\n./gen -n 50 -k 5000 -type all50\n./gen -n 50 -k 5000 -type all100\n./gen -n 50 -k 5000 -type mix\n\n./gen -n 10 -type impossible_small_k\n./gen -n 10 -type impossible_heavy_people\n./gen -n 20 -k 5000 -type mix\n./gen -n 30 -k 1000 -type mix\n./gen -n 40 -k 500 -type mix\n\n./gen -n 10 -k 200 -type all50\n./gen -n 10 -k 100 -type all100\n./gen -n 10 -k 100 -type mix\n./gen -n 25 -k 125 -type all50\n./gen -n 25 -k 125 -type all100\n./gen -n 25 -k 125 -type mix\n\n./gen -n 50 -k 250 -type all50\n./gen -n 50 -k 500 -type all100\n./gen -n 50 -k 750 -type mix\n\n./gen -n 30 -k 300 -type all50\n./gen -n 30 -k 300 -type all100\n\n./gen -n 15 -k 75 -type all50\n./gen -n 15 -k 75 -type all100\n\n./gen -n 50 -k 50 -type all50\n./gen -n 50 -k 100 -type all50\n./gen -n 50 -k 50 -type all100\n./gen -n 50 -k 100 -type all100\n\n./gen -n 45 -k 2250 -type mix\n./gen -n 50 -k 2500 -type mix\n\n./gen -n 49 -k 2450 -type mix\n./gen -n 50 -k 5000 -type mix\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:50.464756",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "295/D",
      "title": "D. Егор и пещеры",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа n, m — размеры экрана планшета (1 ≤ n, m ≤ 2000).",
      "output_spec": "Выходные данныеВ единственную строку выведите остаток от деления ответа на задачу на число 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1Выходные данныеСкопировать0Входные данныеСкопировать4 4Выходные данныеСкопировать485Входные данныеСкопировать3 5Выходные данныеСкопировать451",
      "description": "D. Егор и пещеры\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы два целых числа n, m — размеры экрана планшета (1 ≤ n, m ≤ 2000).\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите остаток от деления ответа на задачу на число 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать1 1Выходные данныеСкопировать0Входные данныеСкопировать4 4Выходные данныеСкопировать485Входные данныеСкопировать3 5Выходные данныеСкопировать451\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать485\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать451\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces",
          "content": "Всем привет!Сегодня состоится второй раунд Всероссийского Открытого Чемпионата по программированию \"КРОК-2013\". Раунд для вас готовили: sdya, Seyaua, Gerald и, как обычно, задачи на английский переводила Delinur.Приятная новость для тех, кто не попал в лучшие 400 участников в предыдущем раунде — сегодня каждый может поучаствовать вне конкурса. При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.Официальным участникам напоминаем, что: Все участники чемпионата должны быть не моложе 18 лет на момент регистрации Финал чемпионата состоится 16 и 17 мая в Москве в офисе компании КРОК (50 участников) Проживание во время финала будет оплачено компанией КРОК Для граждан Российской Федерации: организаторы покроют транспортные расходы по территории РФ, транспортные расходы не по территории РФ — по согласованию (возможно, частично) Финалисты должны подтвердить свое участие до 2 мая И небольшой бонус: лучшие 200 официальных участников чемпионата получат футболки!Желаем всем получить удовольствие от решения задач ну и, конечно, удачи!UPD: Разбалловка по задачам сегодня будет немножко отличаться от стандартной: 500-1500-1500-2000-2500 для первого дивизиона и 500-1000-1500-2500-2500 для второго.UPD2: Мы приносим свои извинения за технические неполадки во время раунда. Посовещавшись, мы решили, что соревнование должно быть рейтинговым. А результаты соревнования будут учитываться в отборе на финал чемпионата КРОК.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1467
        },
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Всем привет!Совсем скоро, 11 апреля в 19:30 MSK состоится Codeforces Round #179, автором которого являюсь я. Это мой пятый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе стандартная, а во втором: 500-1500-1500-2000-2500.Gl & hf ! :)Контест завершен. Надеюсь вам понравились задачи. Победители в первом дивизионе:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Победители во втором дивизионе:1). goie2). Koblyk3). Beriand Идеи решений тут.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 655
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Ярослав и перестановкиЗаметим, что после применения операций обмена любая перестановка чисел.Не сложно понять, что ответ будет положительным, если можно разместить одно число, что бы оно не стояло в соседних клетках.Таким образом, если некоторое число встретилось С раз, то должно выполнятся условие С<=(n+1)/2.296B - Ярослав и две строкиБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Егор и массивДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Егор и графДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Егор и друзьяЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Егор и пещерыБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Ярослав и точкиНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 295\\s*D"
          },
          "content_length": 4521
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 1",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 2",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 3",
          "code": "dp[0][1][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 4",
          "code": "dp[1][0][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 5",
          "code": "dp[1][1][{1,2,3}]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 6",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 7",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 8",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 9",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 10",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 11",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 12",
          "code": "При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 13",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 14",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 15",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 16",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <stdio.h>\n#include <math.h>\n#include <fstream>\n#include <algorithm>\n#include <time.h>\n//#include <cstdio>\n\nusing namespace std;\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tint p[10001];\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>p[i];\n\t}\n\tint l[10001],r[10001],d[10001];\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>l[i]>>r[i]>>d[i];\n\t}\n\tint op[10001];\n\tint oc[10001];\n\tfor(int i=1;i<=n;i++){\n\t\top[i]=0;\n\t\toc[i]=0;\n\t}\n\tint x,y;\n\tfor(int i=1;i<=k;i++){\n\t\tcin>>x>>y;\n\t\toc[x]++;\n\t\tif(y<m){\n\t\t\toc[y+1]--;\n\t\t}\n\t}\n\t\n\tint occ=0;\n\tfor(int i=1;i<=m;i++){\n\t\tocc+=oc[i];\n\t\td[i]*=occ;\n\t\top[l[i]]+=d[i];\n\t\tif(r[i]<n){\n\t\t\top[r[i]+1]-=d[i];\n\t\t}\n\t}\n\tint opc=0;\n\tfor(int i=1;i<=n;i++){\n\t\topc+=op[i];\n\t\tcout<<p[i]+opc<<\" \";\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <stdio.h>\n#include <math.h>\n#include <fstream>\n#include <algorithm>\n#include <time.h>\n//#include <cstdio>\n\nusing namespace std;\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tint p[10001];\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>p[i];\n\t}\n\tint l[10001],r[10001],d[10001];\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>l[i]>>r[i]>>d[i];\n\t}\n\tint op[10001];\n\tint oc[10001];\n\tfor(int i=1;i<=n;i++){\n\t\top[i]=0;\n\t\toc[i]=0;\n\t}\n\tint x,y;\n\tfor(int i=1;i<=k;i++){\n\t\tcin>>x>>y;\n\t\toc[x]++;\n\t\tif(y<m){\n\t\t\toc[y+1]--;\n\t\t}\n\t}\n\t\n\tint occ=0;\n\tfor(int i=1;i<=m;i++){\n\t\tocc+=oc[i];\n\t\td[i]*=occ;\n\t\top[l[i]]+=d[i];\n\t\tif(r[i]<n){\n\t\t\top[r[i]+1]-=d[i];\n\t\t}\n\t}\n\tint opc=0;\n\tfor(int i=1;i<=n;i++){\n\t\topc+=op[i];\n\t\tcout<<p[i]+opc<<\" \";\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 5",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 6",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 7",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    ensure(1 <= n && n <= 2000);\n    ensure(1 <= m && m <= 2000);\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    ensure(1 <= n && n <= 2000);\n    ensure(1 <= m && m <= 2000);\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1\n./gen -n 1 -m 2\n./gen -n 2 -m 1\n./gen -n 2 -m 2\n./gen -n 3 -m 5\n./gen -n 4 -m 4\n./gen -n 5 -m 3\n./gen -n 10 -m 10\n./gen -n 15 -m 20\n./gen -n 20 -m 15\n./gen -n 50 -m 2000\n./gen -n 2000 -m 50\n./gen -n 100 -m 100\n./gen -n 2000 -m 2000\n./gen -n 1 -m 2000\n./gen -n 2000 -m 1\n./gen -n 999 -m 1000\n./gen -n 1000 -m 999\n./gen -n 1234 -m 567\n./gen -n 1765 -m 1843\n./gen -n 1500 -m 1500\n./gen -n 1998 -m 2000\n./gen -n 2000 -m 1997\n./gen -n 1999 -m 1999\n./gen -n 1999 -m 2000\n./gen -n 2000 -m 1999\n./gen -n 1 -m 1000\n./gen -n 1000 -m 1\n./gen -n 2 -m 2\n./gen -n 3 -m 3\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:52.296556",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "295/E",
      "title": "E. Yaroslav and Points",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n — the number of points (1 ≤ n ≤ 105). The second line contains distinct integers x1, x2, ..., xn — the coordinates of points (|xi| ≤ 109).The third line contains integer m — the number of queries (1 ≤ m ≤ 105). The next m lines contain the queries. The j-th line first contains integer tj (1 ≤ tj ≤ 2) — the query type. If tj = 1, then it is followed by two integers pj and dj (1 ≤ pj ≤ n, |dj| ≤ 1000). If tj = 2, then it is followed by two integers lj and rj ( - 109 ≤ lj ≤ rj ≤ 109).It is guaranteed that at any moment all the points have distinct coordinates.",
      "output_spec": "OutputFor each type 2 query print the answer on a single line. Print the answers in the order, in which the queries follow in the input.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy836 50 28 -75 40 -60 -95 -48202 -61 291 5 -531 1 4291 5 1302 -101 -712 -69 531 1 4041 5 5182 -101 532 50 8721 1 -2072 -99 -401 7 -3891 6 -1711 2 4641 7 -7071 1 -7301 1 5602 635 6441 7 -677OutputCopy17620406104616381560",
      "description": "E. Yaroslav and Points\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n — the number of points (1 ≤ n ≤ 105). The second line contains distinct integers x1, x2, ..., xn — the coordinates of points (|xi| ≤ 109).The third line contains integer m — the number of queries (1 ≤ m ≤ 105). The next m lines contain the queries. The j-th line first contains integer tj (1 ≤ tj ≤ 2) — the query type. If tj = 1, then it is followed by two integers pj and dj (1 ≤ pj ≤ n, |dj| ≤ 1000). If tj = 2, then it is followed by two integers lj and rj ( - 109 ≤ lj ≤ rj ≤ 109).It is guaranteed that at any moment all the points have distinct coordinates.\n\nOutputFor each type 2 query print the answer on a single line. Print the answers in the order, in which the queries follow in the input.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.\n\nInputCopy836 50 28 -75 40 -60 -95 -48202 -61 291 5 -531 1 4291 5 1302 -101 -712 -69 531 1 4041 5 5182 -101 532 50 8721 1 -2072 -99 -401 7 -3891 6 -1711 2 4641 7 -7071 1 -7301 1 5602 635 6441 7 -677OutputCopy17620406104616381560\n\nInputCopy836 50 28 -75 40 -60 -95 -48202 -61 291 5 -531 1 4291 5 1302 -101 -712 -69 531 1 4041 5 5182 -101 532 50 8721 1 -2072 -99 -401 7 -3891 6 -1711 2 4641 7 -7071 1 -7301 1 5602 635 6441 7 -677\n\nOutputCopy17620406104616381560",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Hello everyone!Codeforces Round #179 will take place on Thursday, April 11th at 19:30 MSK. This is my fifth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problems point values for 1 division will be standart. For the 2 division it will be: 500-1500-1500-2000-2500.Gl & hf ! :)Contest is over. I hope that problems vere interesting for you. Division 1 winners:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Division 2 winners:1). goie2). Koblyk3). Beriand Ideas of the solutions are here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 683
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Yaroslav and PermutationsNote that after applying the operations of the exchange, we can get any permutation of numbers. Not difficult to understand that the answer is \"YES\", if you can place a single number that it would not stand in the neighboring cells. Thus, if a some number is meeted C times, it must fulfill the condition C <= (n+1) / 2.296B - Yaroslav and Two StringsБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Greg and ArrayДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Greg and GraphДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Greg and FriendsЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Greg and CavesБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Yaroslav and PointsНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 295\\s*E"
          },
          "content_length": 4571
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> x(n);\n    set<long long> coords;\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        x[i] = xi;\n        ensuref(coords.insert(x[i]).second, \"xi are not distinct, xi[%d]=%lld\", i+1, x[i]);\n    }\n    inf.readEoln();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for (int query = 1; query <= m; query++) {\n        int tj = inf.readInt(1, 2, \"tj\");\n        if (tj == 1) {\n            // Type 1 query\n            inf.readSpace();\n            int pj = inf.readInt(1, n, \"pj\");\n            inf.readSpace();\n            int dj = inf.readInt(-1000, 1000, \"dj\");\n            inf.readEoln();\n            long long old_xpj = x[pj - 1];\n            x[pj - 1] += dj;\n            long long new_xpj = x[pj - 1];\n            // Update coords\n            size_t erased = coords.erase(old_xpj);\n            ensuref(erased == 1, \"Failed to remove old coordinate of point %d\", pj);\n            ensuref(coords.insert(new_xpj).second, \"Coordinates are not distinct after moving point %d\", pj);\n        } else {\n            // tj == 2\n            inf.readSpace();\n            int lj = inf.readInt(-1000000000, 1000000000, \"lj\");\n            inf.readSpace();\n            int rj = inf.readInt(lj, 1000000000, \"rj\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> x(n);\n    set<long long> coords;\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        x[i] = xi;\n        ensuref(coords.insert(x[i]).second, \"xi are not distinct, xi[%d]=%lld\", i+1, x[i]);\n    }\n    inf.readEoln();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for (int query = 1; query <= m; query++) {\n        int tj = inf.readInt(1, 2, \"tj\");\n        if (tj == 1) {\n            // Type 1 query\n            inf.readSpace();\n            int pj = inf.readInt(1, n, \"pj\");\n            inf.readSpace();\n            int dj = inf.readInt(-1000, 1000, \"dj\");\n            inf.readEoln();\n            long long old_xpj = x[pj - 1];\n            x[pj - 1] += dj;\n            long long new_xpj = x[pj - 1];\n            // Update coords\n            size_t erased = coords.erase(old_xpj);\n            ensuref(erased == 1, \"Failed to remove old coordinate of point %d\", pj);\n            ensuref(coords.insert(new_xpj).second, \"Coordinates are not distinct after moving point %d\", pj);\n        } else {\n            // tj == 2\n            inf.readSpace();\n            int lj = inf.readInt(-1000000000, 1000000000, \"lj\");\n            inf.readSpace();\n            int rj = inf.readInt(lj, 1000000000, \"rj\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> x(n);\n    set<long long> coords;\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        x[i] = xi;\n        ensuref(coords.insert(x[i]).second, \"xi are not distinct, xi[%d]=%lld\", i+1, x[i]);\n    }\n    inf.readEoln();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for (int query = 1; query <= m; query++) {\n        int tj = inf.readInt(1, 2, \"tj\");\n        if (tj == 1) {\n            // Type 1 query\n            inf.readSpace();\n            int pj = inf.readInt(1, n, \"pj\");\n            inf.readSpace();\n            int dj = inf.readInt(-1000, 1000, \"dj\");\n            inf.readEoln();\n            long long old_xpj = x[pj - 1];\n            x[pj - 1] += dj;\n            long long new_xpj = x[pj - 1];\n            // Update coords\n            size_t erased = coords.erase(old_xpj);\n            ensuref(erased == 1, \"Failed to remove old coordinate of point %d\", pj);\n            ensuref(coords.insert(new_xpj).second, \"Coordinates are not distinct after moving point %d\", pj);\n        } else {\n            // tj == 2\n            inf.readSpace();\n            int lj = inf.readInt(-1000000000, 1000000000, \"lj\");\n            inf.readSpace();\n            int rj = inf.readInt(lj, 1000000000, \"rj\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces test data for the problem:\n\n    1) We have n distinct integer coordinates x1, x2, ..., xn (|xi| ≤ 1e9).\n    2) We have m queries of two types:\n       - (type=1) Move the p-th point by d (|d| ≤ 1000), ensuring all coords stay distinct.\n       - (type=2) Compute the sum of pairwise distances among points in [l, r].\n    3) We must ensure that after each type=1 query, all coordinates remain distinct.\n\n  We parse:\n     -n : number of points\n     -m : number of queries\n     -type (string, default \"random\"): determines how to generate the coordinates and queries, e.g.,\n         \"small\"     -> uses smaller coordinate ranges.\n         \"allmove\"   -> all queries are type=1.\n         \"allrange\"  -> all queries are type=2.\n         \"clusters\"  -> points in a few clusters, queries random.\n         \"random\"    -> fully random distribution of query types.\n\n  No random seed is accepted or set; testlib automatically seeds rnd.\n*/\n\nstatic const int MAX_SHIFT = 1000; // |d| ≤ 1000\n\n// Tries to pick a random shift in [-MAX_SHIFT, MAX_SHIFT] \\ {0} that doesn't collide\n// with the existing set of coordinates. Returns (true, shift) if successful.\npair<bool,int> pickValidShift(long long currentCoord, unordered_set<long long> &used, int maxAttempts = 2000) {\n    for (int attempt = 0; attempt < maxAttempts; attempt++) {\n        int d = rnd.next(-MAX_SHIFT, MAX_SHIFT);\n        if (d == 0) continue; // must be nonzero\n        long long newCoord = currentCoord + d;\n        // Check if distinct\n        if (!used.count(newCoord)) {\n            return make_pair(true, d);\n        }\n    }\n    return make_pair(false, 0);\n}\n\n// Generate n distinct integer coordinates in some manner depending on \"type\".\n// Store them in coords, and also keep them in a hashed set for quick collision checks.\nvoid generateCoordinates(int n, const string &genType, vector<long long> &coords, unordered_set<long long> &used) {\n    coords.clear();\n    coords.reserve(n);\n    used.clear();\n\n    // Decide a range for coordinate generation\n    // We'll keep it moderate in \"small\", bigger in other modes.\n    long long rangeCoord = (genType == \"small\") ? 1000LL : 1000000000LL;\n\n    if (genType == \"clusters\") {\n        // We'll pick ~5 cluster centers, each in [-rangeCoord, rangeCoord]\n        // Then spread points around them in [-1000, 1000].\n        int clusters = min(n, 5);\n        vector<long long> centers;\n        centers.reserve(clusters);\n        for (int i = 0; i < clusters; i++) {\n            // pick a random center\n            long long c = rnd.next(-rangeCoord, rangeCoord);\n            centers.push_back(c);\n        }\n        int idx = 0;\n        while ((int)coords.size() < n) {\n            long long base = centers[idx % clusters];\n            long long offset = rnd.next(-1000, 1000);\n            long long candidate = base + offset;\n            if (!used.count(candidate)) {\n                used.insert(candidate);\n                coords.push_back(candidate);\n            }\n            idx++;\n        }\n    } else {\n        // \"small\", \"random\", \"allmove\", \"allrange\", or other\n        // We just pick distinct coords from [-rangeCoord, rangeCoord].\n        while ((int)coords.size() < n) {\n            long long candidate = rnd.next(-rangeCoord, rangeCoord);\n            if (!used.count(candidate)) {\n                used.insert(candidate);\n                coords.push_back(candidate);\n            }\n        }\n    }\n}\n\n// Generate m queries depending on \"type\". We print them in the required format:\n//   For type=1, we print: \"1 p d\"\n//   For type=2, we print: \"2 l r\"\n// We also update the set of used coords (and the coords array) after each move.\nvoid generateQueries(int n, int m, const string &genType,\n                     vector<long long> &coords,\n                     unordered_set<long long> &used) {\n    // We can choose how many type=1 vs type=2 queries if not forced by genType.\n    // If \"allmove\" -> all queries are type=1\n    // If \"allrange\" -> all queries are type=2\n    // Otherwise random distribution.\n\n    long long rangeCoord = (genType == \"small\") ? 1000LL : 1000000000LL;\n\n    for (int i = 0; i < m; i++) {\n        int queryType;\n        if (genType == \"allmove\") queryType = 1;\n        else if (genType == \"allrange\") queryType = 2;\n        else {\n            // random distribution\n            queryType = rnd.next(1, 2);\n        }\n\n        if (queryType == 1) {\n            // Move query\n            // pick a random point index p in [1..n]\n            int p = rnd.next(1, n);\n            // try to find a valid shift\n            auto ret = pickValidShift(coords[p - 1], used);\n            if (!ret.first) {\n                // If we can't find a shift, fallback to a type=2 query instead\n                // (or just produce a trivial shift that won't collide?)\n                // We'll do a random type=2 query:\n                long long L = rnd.next(-rangeCoord, rangeCoord);\n                long long R = rnd.next(-rangeCoord, rangeCoord);\n                if (L > R) swap(L, R);\n                cout << 2 << \" \" << L << \" \" << R << \"\\n\";\n                continue;\n            }\n            int d = ret.second;\n            // Now perform the actual move\n            long long oldC = coords[p - 1];\n            long long newC = oldC + d;\n            // update\n            used.erase(oldC);\n            used.insert(newC);\n            coords[p - 1] = newC;\n\n            // print\n            cout << 1 << \" \" << p << \" \" << d << \"\\n\";\n        } else {\n            // Range query\n            long long L = rnd.next(-rangeCoord, rangeCoord);\n            long long R = rnd.next(-rangeCoord, rangeCoord);\n            if (L > R) swap(L, R);\n            cout << 2 << \" \" << L << \" \" << R << \"\\n\";\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");      // number of points\n    int m = opt<int>(\"m\");      // number of queries\n    string genType = opt<string>(\"type\", \"random\");\n\n    // 1) Generate n distinct coordinates\n    vector<long long> coords;\n    unordered_set<long long> used;\n    used.reserve(n * 2UL);\n    used.max_load_factor(0.7f);\n\n    generateCoordinates(n, genType, coords, used);\n\n    // 2) Output the first line: n\n    cout << n << \"\\n\";\n\n    // 3) Output the distinct integers x1..xn\n    //    The problem statement requires them in a single line\n    for (int i = 0; i < n; i++) {\n        cout << coords[i] << (i + 1 < n ? ' ' : '\\n');\n    }\n\n    // 4) Output the third line: m\n    cout << m << \"\\n\";\n\n    // 5) Generate and output m queries\n    generateQueries(n, m, genType, coords, used);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces test data for the problem:\n\n    1) We have n distinct integer coordinates x1, x2, ..., xn (|xi| ≤ 1e9).\n    2) We have m queries of two types:\n       - (type=1) Move the p-th point by d (|d| ≤ 1000), ensuring all coords stay distinct.\n       - (type=2) Compute the sum of pairwise distances among points in [l, r].\n    3) We must ensure that after each type=1 query, all coordinates remain distinct.\n\n  We parse:\n     -n : number of points\n     -m : number of queries\n     -type (string, default \"random\"): determines how to generate the coordinates and queries, e.g.,\n         \"small\"     -> uses smaller coordinate ranges.\n         \"allmove\"   -> all queries are type=1.\n         \"allrange\"  -> all queries are type=2.\n         \"clusters\"  -> points in a few clusters, queries random.\n         \"random\"    -> fully random distribution of query types.\n\n  No random seed is accepted or set; testlib automatically seeds rnd.\n*/\n\nstatic const int MAX_SHIFT = 1000; // |d| ≤ 1000\n\n// Tries to pick a random shift in [-MAX_SHIFT, MAX_SHIFT] \\ {0} that doesn't collide\n// with the existing set of coordinates. Returns (true, shift) if successful.\npair<bool,int> pickValidShift(long long currentCoord, unordered_set<long long> &used, int maxAttempts = 2000) {\n    for (int attempt = 0; attempt < maxAttempts; attempt++) {\n        int d = rnd.next(-MAX_SHIFT, MAX_SHIFT);\n        if (d == 0) continue; // must be nonzero\n        long long newCoord = currentCoord + d;\n        // Check if distinct\n        if (!used.count(newCoord)) {\n            return make_pair(true, d);\n        }\n    }\n    return make_pair(false, 0);\n}\n\n// Generate n distinct integer coordinates in some manner depending on \"type\".\n// Store them in coords, and also keep them in a hashed set for quick collision checks.\nvoid generateCoordinates(int n, const string &genType, vector<long long> &coords, unordered_set<long long> &used) {\n    coords.clear();\n    coords.reserve(n);\n    used.clear();\n\n    // Decide a range for coordinate generation\n    // We'll keep it moderate in \"small\", bigger in other modes.\n    long long rangeCoord = (genType == \"small\") ? 1000LL : 1000000000LL;\n\n    if (genType == \"clusters\") {\n        // We'll pick ~5 cluster centers, each in [-rangeCoord, rangeCoord]\n        // Then spread points around them in [-1000, 1000].\n        int clusters = min(n, 5);\n        vector<long long> centers;\n        centers.reserve(clusters);\n        for (int i = 0; i < clusters; i++) {\n            // pick a random center\n            long long c = rnd.next(-rangeCoord, rangeCoord);\n            centers.push_back(c);\n        }\n        int idx = 0;\n        while ((int)coords.size() < n) {\n            long long base = centers[idx % clusters];\n            long long offset = rnd.next(-1000, 1000);\n            long long candidate = base + offset;\n            if (!used.count(candidate)) {\n                used.insert(candidate);\n                coords.push_back(candidate);\n            }\n            idx++;\n        }\n    } else {\n        // \"small\", \"random\", \"allmove\", \"allrange\", or other\n        // We just pick distinct coords from [-rangeCoord, rangeCoord].\n        while ((int)coords.size() < n) {\n            long long candidate = rnd.next(-rangeCoord, rangeCoord);\n            if (!used.count(candidate)) {\n                used.insert(candidate);\n                coords.push_back(candidate);\n            }\n        }\n    }\n}\n\n// Generate m queries depending on \"type\". We print them in the required format:\n//   For type=1, we print: \"1 p d\"\n//   For type=2, we print: \"2 l r\"\n// We also update the set of used coords (and the coords array) after each move.\nvoid generateQueries(int n, int m, const string &genType,\n                     vector<long long> &coords,\n                     unordered_set<long long> &used) {\n    // We can choose how many type=1 vs type=2 queries if not forced by genType.\n    // If \"allmove\" -> all queries are type=1\n    // If \"allrange\" -> all queries are type=2\n    // Otherwise random distribution.\n\n    long long rangeCoord = (genType == \"small\") ? 1000LL : 1000000000LL;\n\n    for (int i = 0; i < m; i++) {\n        int queryType;\n        if (genType == \"allmove\") queryType = 1;\n        else if (genType == \"allrange\") queryType = 2;\n        else {\n            // random distribution\n            queryType = rnd.next(1, 2);\n        }\n\n        if (queryType == 1) {\n            // Move query\n            // pick a random point index p in [1..n]\n            int p = rnd.next(1, n);\n            // try to find a valid shift\n            auto ret = pickValidShift(coords[p - 1], used);\n            if (!ret.first) {\n                // If we can't find a shift, fallback to a type=2 query instead\n                // (or just produce a trivial shift that won't collide?)\n                // We'll do a random type=2 query:\n                long long L = rnd.next(-rangeCoord, rangeCoord);\n                long long R = rnd.next(-rangeCoord, rangeCoord);\n                if (L > R) swap(L, R);\n                cout << 2 << \" \" << L << \" \" << R << \"\\n\";\n                continue;\n            }\n            int d = ret.second;\n            // Now perform the actual move\n            long long oldC = coords[p - 1];\n            long long newC = oldC + d;\n            // update\n            used.erase(oldC);\n            used.insert(newC);\n            coords[p - 1] = newC;\n\n            // print\n            cout << 1 << \" \" << p << \" \" << d << \"\\n\";\n        } else {\n            // Range query\n            long long L = rnd.next(-rangeCoord, rangeCoord);\n            long long R = rnd.next(-rangeCoord, rangeCoord);\n            if (L > R) swap(L, R);\n            cout << 2 << \" \" << L << \" \" << R << \"\\n\";\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");      // number of points\n    int m = opt<int>(\"m\");      // number of queries\n    string genType = opt<string>(\"type\", \"random\");\n\n    // 1) Generate n distinct coordinates\n    vector<long long> coords;\n    unordered_set<long long> used;\n    used.reserve(n * 2UL);\n    used.max_load_factor(0.7f);\n\n    generateCoordinates(n, genType, coords, used);\n\n    // 2) Output the first line: n\n    cout << n << \"\\n\";\n\n    // 3) Output the distinct integers x1..xn\n    //    The problem statement requires them in a single line\n    for (int i = 0; i < n; i++) {\n        cout << coords[i] << (i + 1 < n ? ' ' : '\\n');\n    }\n\n    // 4) Output the third line: m\n    cout << m << \"\\n\";\n\n    // 5) Generate and output m queries\n    generateQueries(n, m, genType, coords, used);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below is a list of example commands to run this generator.\n# Each command prints exactly one test case to standard output.\n# You may redirect each into a separate file if desired, but\n# here we simply show the invocations without redirection.\n\n# Very small tests\n./gen -n 1 -m 1 -type small\n./gen -n 2 -m 2 -type small\n./gen -n 5 -m 5 -type small\n\n# Medium small tests\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type clusters\n./gen -n 10 -m 10 -type allmove\n./gen -n 10 -m 10 -type allrange\n\n# More variety with moderate values\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type clusters\n./gen -n 50 -m 50 -type allmove\n./gen -n 50 -m 50 -type allrange\n\n# Larger n or m, random distributions\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type clusters\n./gen -n 1000 -m 2000 -type random\n./gen -n 2000 -m 1000 -type random\n\n# Even larger tests\n./gen -n 50000 -m 50000 -type random\n./gen -n 50000 -m 50000 -type clusters\n./gen -n 50000 -m 50000 -type allmove\n./gen -n 50000 -m 50000 -type allrange\n\n# Maximum scale tests\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type allmove\n./gen -n 100000 -m 100000 -type allrange\n./gen -n 100000 -m 100000 -type clusters\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:54.258905",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "296/A",
      "title": "A. Yaroslav and Permutations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the array. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000) — the array elements.",
      "output_spec": "OutputIn the single line print \"YES\" (without the quotes) if Yaroslav can obtain the array he needs, and \"NO\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy11OutputCopyYESInputCopy31 1 2OutputCopyYESInputCopy47 7 7 7OutputCopyNO",
      "description": "A. Yaroslav and Permutations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the array. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000) — the array elements.\n\nOutputIn the single line print \"YES\" (without the quotes) if Yaroslav can obtain the array he needs, and \"NO\" (without the quotes) otherwise.\n\nInputCopy11OutputCopyYESInputCopy31 1 2OutputCopyYESInputCopy47 7 7 7OutputCopyNO\n\nInputCopy11\n\nOutputCopyYES\n\nInputCopy31 1 2\n\nOutputCopyYES\n\nInputCopy47 7 7 7\n\nOutputCopyNO\n\nNoteIn the first sample the initial array fits well.In the second sample Yaroslav can get array: 1, 2, 1. He can swap the last and the second last elements to obtain it.In the third sample Yarosav can't get the array he needs.",
      "solutions": [
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Hello everyone!Codeforces Round #179 will take place on Thursday, April 11th at 19:30 MSK. This is my fifth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problems point values for 1 division will be standart. For the 2 division it will be: 500-1500-1500-2000-2500.Gl & hf ! :)Contest is over. I hope that problems vere interesting for you. Division 1 winners:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Division 2 winners:1). goie2). Koblyk3). Beriand Ideas of the solutions are here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 683
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Yaroslav and PermutationsNote that after applying the operations of the exchange, we can get any permutation of numbers. Not difficult to understand that the answer is \"YES\", if you can place a single number that it would not stand in the neighboring cells. Thus, if a some number is meeted C times, it must fulfill the condition C <= (n+1) / 2.296B - Yaroslav and Two StringsБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Greg and ArrayДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Greg and GraphДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Greg and FriendsЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Greg and CavesБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Yaroslav and PointsНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 296\\s*A"
          },
          "content_length": 4571
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");                 // The size of the array\n    string type = opt<string>(\"type\", \"random\");  // The type of test case\n\n    vector<int> a(n);\n    if (type == \"all_same\") {\n        // All elements are the same (expected output: \"NO\" if n > 1)\n        int val = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"alternating\") {\n        // Elements alternate between two different values (expected output: \"YES\")\n        int val1 = rnd.next(1, 1000);\n        int val2 = rnd.next(1, 1000);\n        while (val2 == val1) {\n            val2 = rnd.next(1, 1000);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"max_freq_half\") {\n        // Maximum frequency is exactly (n + 1) / 2 (edge case for \"YES\")\n        int freq = (n + 1) / 2;\n        int val1 = rnd.next(1, 1000);\n        int val2 = rnd.next(1, 1000);\n        while (val2 == val1) {\n            val2 = rnd.next(1, 1000);\n        }\n        for (int i = 0; i < freq; ++i) {\n            a[i] = val1;\n        }\n        for (int i = freq; i < n; ++i) {\n            a[i] = val2;\n        }\n        // Shuffle the array to randomize the positions\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_freq_more\") {\n        // Maximum frequency is greater than (n + 1) / 2 (expected output: \"NO\")\n        int freq = (n + 1) / 2 + 1;\n        int val1 = rnd.next(1, 1000);\n        int val2 = rnd.next(1, 1000);\n        while (val2 == val1) {\n            val2 = rnd.next(1, 1000);\n        }\n        for (int i = 0; i < freq; ++i) {\n            a[i] = val1;\n        }\n        for (int i = freq; i < n; ++i) {\n            a[i] = val2;\n        }\n        // Shuffle the array to randomize the positions\n        shuffle(a.begin(), a.end());\n    } else if (type == \"yes_random\") {\n        // Random array where the answer should be \"YES\"\n        map<int, int> cnt;\n        int max_freq_limit = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            int val = rnd.next(1, 1000);\n            while (cnt[val] >= max_freq_limit) {\n                val = rnd.next(1, 1000);\n            }\n            a[i] = val;\n            cnt[val]++;\n        }\n    } else if (type == \"no_random\") {\n        // Random array where the answer should be \"NO\"\n        if (n == 1) {\n            // For n = 1, it's always \"YES\"\n            a[0] = rnd.next(1, 1000);\n        } else {\n            int freq = (n + 1) / 2 + 1;\n            int val1 = rnd.next(1, 1000);\n            int val2 = rnd.next(1, 1000);\n            while (val2 == val1) {\n                val2 = rnd.next(1, 1000);\n            }\n            for (int i = 0; i < freq; ++i) {\n                a[i] = val1;\n            }\n            for (int i = freq; i < n; ++i) {\n                a[i] = val2;\n            }\n            shuffle(a.begin(), a.end());\n        }\n    } else if (type == \"large_numbers\") {\n        // Array with large numbers (within specified constraints)\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(900, 1000);\n        }\n    } else {\n        // Default: completely random array within constraints\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the array elements\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");                 // The size of the array\n    string type = opt<string>(\"type\", \"random\");  // The type of test case\n\n    vector<int> a(n);\n    if (type == \"all_same\") {\n        // All elements are the same (expected output: \"NO\" if n > 1)\n        int val = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"alternating\") {\n        // Elements alternate between two different values (expected output: \"YES\")\n        int val1 = rnd.next(1, 1000);\n        int val2 = rnd.next(1, 1000);\n        while (val2 == val1) {\n            val2 = rnd.next(1, 1000);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"max_freq_half\") {\n        // Maximum frequency is exactly (n + 1) / 2 (edge case for \"YES\")\n        int freq = (n + 1) / 2;\n        int val1 = rnd.next(1, 1000);\n        int val2 = rnd.next(1, 1000);\n        while (val2 == val1) {\n            val2 = rnd.next(1, 1000);\n        }\n        for (int i = 0; i < freq; ++i) {\n            a[i] = val1;\n        }\n        for (int i = freq; i < n; ++i) {\n            a[i] = val2;\n        }\n        // Shuffle the array to randomize the positions\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_freq_more\") {\n        // Maximum frequency is greater than (n + 1) / 2 (expected output: \"NO\")\n        int freq = (n + 1) / 2 + 1;\n        int val1 = rnd.next(1, 1000);\n        int val2 = rnd.next(1, 1000);\n        while (val2 == val1) {\n            val2 = rnd.next(1, 1000);\n        }\n        for (int i = 0; i < freq; ++i) {\n            a[i] = val1;\n        }\n        for (int i = freq; i < n; ++i) {\n            a[i] = val2;\n        }\n        // Shuffle the array to randomize the positions\n        shuffle(a.begin(), a.end());\n    } else if (type == \"yes_random\") {\n        // Random array where the answer should be \"YES\"\n        map<int, int> cnt;\n        int max_freq_limit = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            int val = rnd.next(1, 1000);\n            while (cnt[val] >= max_freq_limit) {\n                val = rnd.next(1, 1000);\n            }\n            a[i] = val;\n            cnt[val]++;\n        }\n    } else if (type == \"no_random\") {\n        // Random array where the answer should be \"NO\"\n        if (n == 1) {\n            // For n = 1, it's always \"YES\"\n            a[0] = rnd.next(1, 1000);\n        } else {\n            int freq = (n + 1) / 2 + 1;\n            int val1 = rnd.next(1, 1000);\n            int val2 = rnd.next(1, 1000);\n            while (val2 == val1) {\n                val2 = rnd.next(1, 1000);\n            }\n            for (int i = 0; i < freq; ++i) {\n                a[i] = val1;\n            }\n            for (int i = freq; i < n; ++i) {\n                a[i] = val2;\n            }\n            shuffle(a.begin(), a.end());\n        }\n    } else if (type == \"large_numbers\") {\n        // Array with large numbers (within specified constraints)\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(900, 1000);\n        }\n    } else {\n        // Default: completely random array within constraints\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the array elements\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases where n is small and the answer should be \"YES\"\n./gen -n 1 -type yes_random\n./gen -n 2 -type yes_random\n./gen -n 3 -type alternating\n./gen -n 3 -type max_freq_half\n./gen -n 5 -type yes_random\n\n# Test cases where n is small and the answer should be \"NO\"\n./gen -n 1 -type all_same\n./gen -n 3 -type no_random\n./gen -n 4 -type all_same\n./gen -n 5 -type max_freq_more\n\n# Test cases where n is medium and the answer should be \"YES\"\n./gen -n 50 -type yes_random\n./gen -n 50 -type max_freq_half\n./gen -n 50 -type alternating\n\n# Test cases where n is medium and the answer should be \"NO\"\n./gen -n 50 -type max_freq_more\n./gen -n 50 -type all_same\n\n# Test cases where n is large and the answer should be \"YES\"\n./gen -n 100 -type yes_random\n./gen -n 100 -type max_freq_half\n./gen -n 100 -type alternating\n\n# Test cases where n is large and the answer should be \"NO\"\n./gen -n 100 -type max_freq_more\n./gen -n 100 -type all_same\n\n# Edge cases\n./gen -n 1 -type all_same\n./gen -n 2 -type alternating\n./gen -n 100 -type large_numbers\n./gen -n 100 -type random\n\n# Randomly generated test cases with varying n\n./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 30 -type random\n./gen -n 40 -type random\n./gen -n 50 -type random\n./gen -n 60 -type random\n./gen -n 70 -type random\n./gen -n 80 -type random\n./gen -n 90 -type random\n./gen -n 100 -type random\n\n# Mixed test cases to cover additional scenarios\n./gen -n 75 -type yes_random\n./gen -n 80 -type no_random\n./gen -n 90 -type yes_random\n./gen -n 99 -type max_freq_half\n./gen -n 100 -type max_freq_more\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:56.177759",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "296/B",
      "title": "B. Yaroslav and Two Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the length of both templates. The second line contains the first template — a string that consists of digits and characters \"?\". The string's length equals n. The third line contains the second template in the same format.",
      "output_spec": "OutputIn a single line print the remainder after dividing the answer to the problem by number 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy29009OutputCopy1InputCopy21155OutputCopy0InputCopy5??????????OutputCopy993531194",
      "description": "B. Yaroslav and Two Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the length of both templates. The second line contains the first template — a string that consists of digits and characters \"?\". The string's length equals n. The third line contains the second template in the same format.\n\nOutputIn a single line print the remainder after dividing the answer to the problem by number 1000000007 (109 + 7).\n\nInputCopy29009OutputCopy1InputCopy21155OutputCopy0InputCopy5??????????OutputCopy993531194\n\nInputCopy29009\n\nOutputCopy1\n\nInputCopy21155\n\nOutputCopy0\n\nInputCopy5??????????\n\nOutputCopy993531194\n\nNoteThe first test contains no question marks and both strings are incomparable, so the answer is 1.The second test has no question marks, but the given strings are comparable, so the answer is 0.",
      "solutions": [
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Hello everyone!Codeforces Round #179 will take place on Thursday, April 11th at 19:30 MSK. This is my fifth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problems point values for 1 division will be standart. For the 2 division it will be: 500-1500-1500-2000-2500.Gl & hf ! :)Contest is over. I hope that problems vere interesting for you. Division 1 winners:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Division 2 winners:1). goie2). Koblyk3). Beriand Ideas of the solutions are here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 683
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Yaroslav and PermutationsNote that after applying the operations of the exchange, we can get any permutation of numbers. Not difficult to understand that the answer is \"YES\", if you can place a single number that it would not stand in the neighboring cells. Thus, if a some number is meeted C times, it must fulfill the condition C <= (n+1) / 2.296B - Yaroslav and Two StringsБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Greg and ArrayДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Greg and GraphДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Greg and FriendsЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Greg and CavesБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Yaroslav and PointsНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 296\\s*B"
          },
          "content_length": 4571
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[0-9?]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    string w = inf.readToken(pattern, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[0-9?]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    string w = inf.readToken(pattern, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[0-9?]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    string w = inf.readToken(pattern, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic char randomDigit() {\n    return char('0' + rnd.next(10));\n}\n\n// Generate a pair (s[i], t[i]) such that s[i] < t[i].\nstatic pair<char, char> strictlyLessDigits() {\n    // s in [0..8], t in [s+1..9]\n    int x = rnd.next(9);        // s in [0..8]\n    int y = rnd.next(x+1, 9);   // t in [x+1..9]\n    return make_pair(char('0' + x), char('0' + y));\n}\n\n// Generate a pair (s[i], t[i]) such that s[i] > t[i].\nstatic pair<char, char> strictlyGreaterDigits() {\n    // s in [1..9], t in [0..s-1]\n    int x = rnd.next(1, 9);     // s in [1..9]\n    int y = rnd.next(0, x-1);   // t in [0..x-1]\n    return make_pair(char('0' + x), char('0' + y));\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Prepare output strings\n    string s(n, '?'), t(n, '?');\n\n    if (type == \"allqm\") {\n        // Both s and t are all '?'\n        // Already initialized with '?'\n    }\n    else if (type == \"noqm\") {\n        // Both s and t are all digits (no '?')\n        for (int i = 0; i < n; i++) {\n            s[i] = randomDigit();\n            t[i] = randomDigit();\n        }\n    }\n    else if (type == \"fewqm\") {\n        // Each position has ~90% chance to be a digit, 10% '?'\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(10) == 0) s[i] = '?';\n            else s[i] = randomDigit();\n            if (rnd.next(10) == 0) t[i] = '?';\n            else t[i] = randomDigit();\n        }\n    }\n    else if (type == \"halfqm\") {\n        // Each position has 50% chance to be '?'\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(2) == 0) s[i] = '?';\n            else s[i] = randomDigit();\n            if (rnd.next(2) == 0) t[i] = '?';\n            else t[i] = randomDigit();\n        }\n    }\n    else if (type == \"random\") {\n        // Each position has ~30% chance to be '?', else a digit\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(10) < 3) s[i] = '?';\n            else s[i] = randomDigit();\n            if (rnd.next(10) < 3) t[i] = '?';\n            else t[i] = randomDigit();\n        }\n    }\n    else if (type == \"slt\") {\n        // s[i] < t[i] for every position\n        // If n=1, we just do direct. If no possibility, skip. But there's always a possibility.\n        for (int i = 0; i < n; i++) {\n            auto pr = strictlyLessDigits();\n            s[i] = pr.first;\n            t[i] = pr.second;\n        }\n    }\n    else if (type == \"sgt\") {\n        // s[i] > t[i] for every position\n        for (int i = 0; i < n; i++) {\n            auto pr = strictlyGreaterDigits();\n            s[i] = pr.first;\n            t[i] = pr.second;\n        }\n    }\n    else if (type == \"eqdigits\") {\n        // s[i] = t[i], all digits (no '?')\n        for (int i = 0; i < n; i++) {\n            char d = randomDigit();\n            s[i] = d;\n            t[i] = d;\n        }\n    }\n    else if (type == \"oneqm\") {\n        // Exactly one question mark in total, rest are digits\n        // Randomly choose if it appears in s or t, and which position\n        bool inS = rnd.next(2) == 0;   // coin toss\n        int pos = rnd.next(n);\n        for (int i = 0; i < n; i++) {\n            s[i] = randomDigit();\n            t[i] = randomDigit();\n        }\n        if (inS) {\n            s[pos] = '?';\n        } else {\n            t[pos] = '?';\n        }\n    }\n    else {\n        // Default fallback: same as \"random\"\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(10) < 3) s[i] = '?';\n            else s[i] = randomDigit();\n            if (rnd.next(10) < 3) t[i] = '?';\n            else t[i] = randomDigit();\n        }\n    }\n\n    // Output\n    cout << n << \"\\n\" << s << \"\\n\" << t << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic char randomDigit() {\n    return char('0' + rnd.next(10));\n}\n\n// Generate a pair (s[i], t[i]) such that s[i] < t[i].\nstatic pair<char, char> strictlyLessDigits() {\n    // s in [0..8], t in [s+1..9]\n    int x = rnd.next(9);        // s in [0..8]\n    int y = rnd.next(x+1, 9);   // t in [x+1..9]\n    return make_pair(char('0' + x), char('0' + y));\n}\n\n// Generate a pair (s[i], t[i]) such that s[i] > t[i].\nstatic pair<char, char> strictlyGreaterDigits() {\n    // s in [1..9], t in [0..s-1]\n    int x = rnd.next(1, 9);     // s in [1..9]\n    int y = rnd.next(0, x-1);   // t in [0..x-1]\n    return make_pair(char('0' + x), char('0' + y));\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Prepare output strings\n    string s(n, '?'), t(n, '?');\n\n    if (type == \"allqm\") {\n        // Both s and t are all '?'\n        // Already initialized with '?'\n    }\n    else if (type == \"noqm\") {\n        // Both s and t are all digits (no '?')\n        for (int i = 0; i < n; i++) {\n            s[i] = randomDigit();\n            t[i] = randomDigit();\n        }\n    }\n    else if (type == \"fewqm\") {\n        // Each position has ~90% chance to be a digit, 10% '?'\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(10) == 0) s[i] = '?';\n            else s[i] = randomDigit();\n            if (rnd.next(10) == 0) t[i] = '?';\n            else t[i] = randomDigit();\n        }\n    }\n    else if (type == \"halfqm\") {\n        // Each position has 50% chance to be '?'\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(2) == 0) s[i] = '?';\n            else s[i] = randomDigit();\n            if (rnd.next(2) == 0) t[i] = '?';\n            else t[i] = randomDigit();\n        }\n    }\n    else if (type == \"random\") {\n        // Each position has ~30% chance to be '?', else a digit\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(10) < 3) s[i] = '?';\n            else s[i] = randomDigit();\n            if (rnd.next(10) < 3) t[i] = '?';\n            else t[i] = randomDigit();\n        }\n    }\n    else if (type == \"slt\") {\n        // s[i] < t[i] for every position\n        // If n=1, we just do direct. If no possibility, skip. But there's always a possibility.\n        for (int i = 0; i < n; i++) {\n            auto pr = strictlyLessDigits();\n            s[i] = pr.first;\n            t[i] = pr.second;\n        }\n    }\n    else if (type == \"sgt\") {\n        // s[i] > t[i] for every position\n        for (int i = 0; i < n; i++) {\n            auto pr = strictlyGreaterDigits();\n            s[i] = pr.first;\n            t[i] = pr.second;\n        }\n    }\n    else if (type == \"eqdigits\") {\n        // s[i] = t[i], all digits (no '?')\n        for (int i = 0; i < n; i++) {\n            char d = randomDigit();\n            s[i] = d;\n            t[i] = d;\n        }\n    }\n    else if (type == \"oneqm\") {\n        // Exactly one question mark in total, rest are digits\n        // Randomly choose if it appears in s or t, and which position\n        bool inS = rnd.next(2) == 0;   // coin toss\n        int pos = rnd.next(n);\n        for (int i = 0; i < n; i++) {\n            s[i] = randomDigit();\n            t[i] = randomDigit();\n        }\n        if (inS) {\n            s[pos] = '?';\n        } else {\n            t[pos] = '?';\n        }\n    }\n    else {\n        // Default fallback: same as \"random\"\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(10) < 3) s[i] = '?';\n            else s[i] = randomDigit();\n            if (rnd.next(10) < 3) t[i] = '?';\n            else t[i] = randomDigit();\n        }\n    }\n\n    // Output\n    cout << n << \"\\n\" << s << \"\\n\" << t << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type allqm\n./gen -n 2 -type allqm\n\n./gen -n 2 -type noqm\n./gen -n 5 -type noqm\n\n./gen -n 5 -type fewqm\n./gen -n 10 -type fewqm\n\n./gen -n 5 -type halfqm\n./gen -n 10 -type halfqm\n\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n./gen -n 5 -type slt\n./gen -n 5 -type sgt\n\n./gen -n 5 -type eqdigits\n./gen -n 5 -type oneqm\n\n./gen -n 10 -type slt\n./gen -n 10 -type sgt\n\n./gen -n 10 -type eqdigits\n./gen -n 10 -type oneqm\n\n# Larger tests\n./gen -n 50 -type noqm\n./gen -n 50 -type random\n./gen -n 100000 -type halfqm\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:58.083092",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "296/C",
      "title": "C. Greg and Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, m, k (1 ≤ n, m, k ≤ 105). The second line contains n integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the initial array.Next m lines contain operations, the operation number i is written as three integers: li, ri, di, (1 ≤ li ≤ ri ≤ n), (0 ≤ di ≤ 105).Next k lines contain the queries, the query number i is written as two integers: xi, yi, (1 ≤ xi ≤ yi ≤ m).The numbers in the lines are separated by single spaces.",
      "output_spec": "OutputOn a single line print n integers a1, a2, ..., an — the array after executing all the queries. Separate the printed numbers by spaces.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy3 3 31 2 31 2 11 3 22 3 41 21 32 3OutputCopy9 18 17InputCopy1 1 111 1 11 1OutputCopy2InputCopy4 3 61 2 3 41 2 12 3 23 4 41 21 32 31 21 32 3OutputCopy5 18 31 20",
      "description": "C. Greg and Array\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m, k (1 ≤ n, m, k ≤ 105). The second line contains n integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the initial array.Next m lines contain operations, the operation number i is written as three integers: li, ri, di, (1 ≤ li ≤ ri ≤ n), (0 ≤ di ≤ 105).Next k lines contain the queries, the query number i is written as two integers: xi, yi, (1 ≤ xi ≤ yi ≤ m).The numbers in the lines are separated by single spaces.\n\nOutputOn a single line print n integers a1, a2, ..., an — the array after executing all the queries. Separate the printed numbers by spaces.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.\n\nInputCopy3 3 31 2 31 2 11 3 22 3 41 21 32 3OutputCopy9 18 17InputCopy1 1 111 1 11 1OutputCopy2InputCopy4 3 61 2 3 41 2 12 3 23 4 41 21 32 31 21 32 3OutputCopy5 18 31 20\n\nInputCopy3 3 31 2 31 2 11 3 22 3 41 21 32 3\n\nOutputCopy9 18 17\n\nInputCopy1 1 111 1 11 1\n\nOutputCopy2\n\nInputCopy4 3 61 2 3 41 2 12 3 23 4 41 21 32 31 21 32 3\n\nOutputCopy5 18 31 20",
      "solutions": [
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Hello everyone!Codeforces Round #179 will take place on Thursday, April 11th at 19:30 MSK. This is my fifth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problems point values for 1 division will be standart. For the 2 division it will be: 500-1500-1500-2000-2500.Gl & hf ! :)Contest is over. I hope that problems vere interesting for you. Division 1 winners:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Division 2 winners:1). goie2). Koblyk3). Beriand Ideas of the solutions are here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 683
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Yaroslav and PermutationsNote that after applying the operations of the exchange, we can get any permutation of numbers. Not difficult to understand that the answer is \"YES\", if you can place a single number that it would not stand in the neighboring cells. Thus, if a some number is meeted C times, it must fulfill the condition C <= (n+1) / 2.296B - Yaroslav and Two StringsБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Greg and ArrayДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Greg and GraphДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Greg and FriendsЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Greg and CavesБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Yaroslav and PointsНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 296 和字母"
          },
          "content_length": 4571
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int di = inf.readInt(0, 100000, \"di\");\n        inf.readEoln();\n        ensuref(li <= ri, \"Operation %d: li (%d) should be <= ri (%d)\", i + 1, li, ri);\n    }\n\n    for(int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, m, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n        ensuref(xi <= yi, \"Query %d: xi (%d) should be <= yi (%d)\", i + 1, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int di = inf.readInt(0, 100000, \"di\");\n        inf.readEoln();\n        ensuref(li <= ri, \"Operation %d: li (%d) should be <= ri (%d)\", i + 1, li, ri);\n    }\n\n    for(int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, m, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n        ensuref(xi <= yi, \"Query %d: xi (%d) should be <= yi (%d)\", i + 1, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int di = inf.readInt(0, 100000, \"di\");\n        inf.readEoln();\n        ensuref(li <= ri, \"Operation %d: li (%d) should be <= ri (%d)\", i + 1, li, ri);\n    }\n\n    for(int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, m, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n        ensuref(xi <= yi, \"Query %d: xi (%d) should be <= yi (%d)\", i + 1, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<tuple<int, int, int>> operations(m);\n    vector<pair<int, int>> queries(k);\n\n    if (type == \"max\") {\n        // All ai = 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n        // All operations: li = 1, ri = n, di = 1e5\n        for (int i = 0; i < m; ++i) {\n            operations[i] = make_tuple(1, n, 100000);\n        }\n        // All queries: xi = 1, yi = m\n        for (int i = 0; i < k; ++i) {\n            queries[i] = make_pair(1, m);\n        }\n    } else if (type == \"min\") {\n        // All ai = 0\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n        // All operations with li = ri, di = 0\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            operations[i] = make_tuple(li, li, 0);\n        }\n        // All queries with xi = yi\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            queries[i] = make_pair(xi, xi);\n        }\n    } else if (type == \"random\") {\n        // Random ai between 0 and 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        // Random queries\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            queries[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"operations_full\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Operations covering the entire array\n        for (int i = 0; i < m; ++i) {\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(1, n, di);\n        }\n        // Random queries\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            queries[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"operations_single\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Operations on single elements\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            operations[i] = make_tuple(li, li, rnd.next(0, 100000));\n        }\n        // Random queries\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            queries[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"queries_full\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        // Queries covering all operations\n        for (int i = 0; i < k; ++i) {\n            queries[i] = make_pair(1, m);\n        }\n    } else if (type == \"queries_single\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        // Queries with xi = yi\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            queries[i] = make_pair(xi, xi);\n        }\n    } else if (type == \"overlapping_queries\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        // Overlapping queries\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            if (i > 0 && rnd.next(0, 1) == 1) {\n                // Overlap with previous query\n                xi = queries[i - 1].first + rnd.next(0, m - queries[i - 1].first);\n                yi = queries[i - 1].second;\n            }\n            queries[i] = make_pair(xi, yi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            queries[i] = make_pair(xi, yi);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) {\n        int li, ri, di;\n        tie(li, ri, di) = operations[i];\n        printf(\"%d %d %d\\n\", li, ri, di);\n    }\n    for (int i = 0; i < k; ++i) {\n        int xi, yi;\n        xi = queries[i].first;\n        yi = queries[i].second;\n        printf(\"%d %d\\n\", xi, yi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<tuple<int, int, int>> operations(m);\n    vector<pair<int, int>> queries(k);\n\n    if (type == \"max\") {\n        // All ai = 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n        // All operations: li = 1, ri = n, di = 1e5\n        for (int i = 0; i < m; ++i) {\n            operations[i] = make_tuple(1, n, 100000);\n        }\n        // All queries: xi = 1, yi = m\n        for (int i = 0; i < k; ++i) {\n            queries[i] = make_pair(1, m);\n        }\n    } else if (type == \"min\") {\n        // All ai = 0\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n        // All operations with li = ri, di = 0\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            operations[i] = make_tuple(li, li, 0);\n        }\n        // All queries with xi = yi\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            queries[i] = make_pair(xi, xi);\n        }\n    } else if (type == \"random\") {\n        // Random ai between 0 and 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        // Random queries\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            queries[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"operations_full\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Operations covering the entire array\n        for (int i = 0; i < m; ++i) {\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(1, n, di);\n        }\n        // Random queries\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            queries[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"operations_single\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Operations on single elements\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            operations[i] = make_tuple(li, li, rnd.next(0, 100000));\n        }\n        // Random queries\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            queries[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"queries_full\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        // Queries covering all operations\n        for (int i = 0; i < k; ++i) {\n            queries[i] = make_pair(1, m);\n        }\n    } else if (type == \"queries_single\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        // Queries with xi = yi\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            queries[i] = make_pair(xi, xi);\n        }\n    } else if (type == \"overlapping_queries\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        // Overlapping queries\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            if (i > 0 && rnd.next(0, 1) == 1) {\n                // Overlap with previous query\n                xi = queries[i - 1].first + rnd.next(0, m - queries[i - 1].first);\n                yi = queries[i - 1].second;\n            }\n            queries[i] = make_pair(xi, yi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int di = rnd.next(0, 100000);\n            operations[i] = make_tuple(li, ri, di);\n        }\n        for (int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, m);\n            int yi = rnd.next(xi, m);\n            queries[i] = make_pair(xi, yi);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) {\n        int li, ri, di;\n        tie(li, ri, di) = operations[i];\n        printf(\"%d %d %d\\n\", li, ri, di);\n    }\n    for (int i = 0; i < k; ++i) {\n        int xi, yi;\n        xi = queries[i].first;\n        yi = queries[i].second;\n        printf(\"%d %d\\n\", xi, yi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type min\n./gen -n 1 -m 1 -k 1 -type max\n./gen -n 10 -m 10 -k 10 -type random\n./gen -n 100 -m 100 -k 100 -type random\n./gen -n 1000 -m 1000 -k 1000 -type random\n./gen -n 10000 -m 10000 -k 10000 -type random\n./gen -n 100000 -m 100000 -k 100000 -type random\n./gen -n 100000 -m 100000 -k 100000 -type max\n./gen -n 1000 -m 1000 -k 1000 -type operations_full\n./gen -n 1000 -m 1000 -k 1000 -type operations_single\n./gen -n 1000 -m 1000 -k 1000 -type queries_full\n./gen -n 1000 -m 1000 -k 1000 -type queries_single\n./gen -n 1000 -m 1000 -k 1000 -type overlapping_queries\n./gen -n 100000 -m 100000 -k 100000 -type operations_full\n./gen -n 100000 -m 100000 -k 100000 -type operations_single\n./gen -n 100000 -m 100000 -k 100000 -type queries_full\n./gen -n 100000 -m 100000 -k 100000 -type queries_single\n./gen -n 100000 -m 100000 -k 100000 -type overlapping_queries\n./gen -n 100 -m 100000 -k 100000 -type random\n./gen -n 100000 -m 100000 -k 100 -type random\n./gen -n 100000 -m 100 -k 100000 -type random\n./gen -n 1 -m 100000 -k 100000 -type random\n./gen -n 100000 -m 1 -k 100000 -type random\n./gen -n 100000 -m 100000 -k 1 -type random\n./gen -n 100000 -m 100000 -k 100000 -type min\n./gen -n 50000 -m 50000 -k 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:03:59.771085",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "296/D",
      "title": "D. Егор и граф",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 500) — количество вершин в графе.В следующих n строках содержится по n целых чисел — матрица смежности графа: j-тое число в i-той строке aij (1 ≤ aij ≤ 105, aii = 0) обозначает вес ребра, ведущего из вершины i в вершину j.В следующей строке содержится n различных целых чисел: x1, x2, ..., xn (1 ≤ xi ≤ n) — вершины, которые удаляет Егор.",
      "output_spec": "Выходные данныеВыведите n целых чисел — i-тое число равно искомой сумме перед i-тым шагом.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на C++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать101Выходные данныеСкопировать0 Входные данныеСкопировать20 54 01 2Выходные данныеСкопировать9 0 Входные данныеСкопировать40 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3Выходные данныеСкопировать17 23 404 0",
      "description": "D. Егор и граф\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 500) — количество вершин в графе.В следующих n строках содержится по n целых чисел — матрица смежности графа: j-тое число в i-той строке aij (1 ≤ aij ≤ 105, aii = 0) обозначает вес ребра, ведущего из вершины i в вершину j.В следующей строке содержится n различных целых чисел: x1, x2, ..., xn (1 ≤ xi ≤ n) — вершины, которые удаляет Егор.\n\nВходные данные\n\nВыходные данныеВыведите n целых чисел — i-тое число равно искомой сумме перед i-тым шагом.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на C++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать101Выходные данныеСкопировать0 Входные данныеСкопировать20 54 01 2Выходные данныеСкопировать9 0 Входные данныеСкопировать40 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3Выходные данныеСкопировать17 23 404 0\n\nВходные данныеСкопировать101\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать20 54 01 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать40 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать17 23 404 0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Всем привет!Совсем скоро, 11 апреля в 19:30 MSK состоится Codeforces Round #179, автором которого являюсь я. Это мой пятый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе стандартная, а во втором: 500-1500-1500-2000-2500.Gl & hf ! :)Контест завершен. Надеюсь вам понравились задачи. Победители в первом дивизионе:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Победители во втором дивизионе:1). goie2). Koblyk3). Beriand Идеи решений тут.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 655
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Ярослав и перестановкиЗаметим, что после применения операций обмена любая перестановка чисел.Не сложно понять, что ответ будет положительным, если можно разместить одно число, что бы оно не стояло в соседних клетках.Таким образом, если некоторое число встретилось С раз, то должно выполнятся условие С<=(n+1)/2.296B - Ярослав и две строкиБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Егор и массивДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Егор и графДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Егор и друзьяЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Егор и пещерыБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Ярослав и точкиНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 296"
          },
          "content_length": 4521
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <stdio.h>\n#include <math.h>\n#include <fstream>\n#include <algorithm>\n#include <time.h>\n//#include <cstdio>\n\nusing namespace std;\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tint p[10001];\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>p[i];\n\t}\n\tint l[10001],r[10001],d[10001];\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>l[i]>>r[i]>>d[i];\n\t}\n\tint op[10001];\n\tint oc[10001];\n\tfor(int i=1;i<=n;i++){\n\t\top[i]=0;\n\t\toc[i]=0;\n\t}\n\tint x,y;\n\tfor(int i=1;i<=k;i++){\n\t\tcin>>x>>y;\n\t\toc[x]++;\n\t\tif(y<m){\n\t\t\toc[y+1]--;\n\t\t}\n\t}\n\t\n\tint occ=0;\n\tfor(int i=1;i<=m;i++){\n\t\tocc+=oc[i];\n\t\td[i]*=occ;\n\t\top[l[i]]+=d[i];\n\t\tif(r[i]<n){\n\t\t\top[r[i]+1]-=d[i];\n\t\t}\n\t}\n\tint opc=0;\n\tfor(int i=1;i<=n;i++){\n\t\topc+=op[i];\n\t\tcout<<p[i]+opc<<\" \";\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <stdio.h>\n#include <math.h>\n#include <fstream>\n#include <algorithm>\n#include <time.h>\n//#include <cstdio>\n\nusing namespace std;\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tint p[10001];\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>p[i];\n\t}\n\tint l[10001],r[10001],d[10001];\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>l[i]>>r[i]>>d[i];\n\t}\n\tint op[10001];\n\tint oc[10001];\n\tfor(int i=1;i<=n;i++){\n\t\top[i]=0;\n\t\toc[i]=0;\n\t}\n\tint x,y;\n\tfor(int i=1;i<=k;i++){\n\t\tcin>>x>>y;\n\t\toc[x]++;\n\t\tif(y<m){\n\t\t\toc[y+1]--;\n\t\t}\n\t}\n\t\n\tint occ=0;\n\tfor(int i=1;i<=m;i++){\n\t\tocc+=oc[i];\n\t\td[i]*=occ;\n\t\top[l[i]]+=d[i];\n\t\tif(r[i]<n){\n\t\t\top[r[i]+1]-=d[i];\n\t\t}\n\t}\n\tint opc=0;\n\tfor(int i=1;i<=n;i++){\n\t\topc+=op[i];\n\t\tcout<<p[i]+opc<<\" \";\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 5",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 6",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 7",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int L, R;\n            if (i == j) {\n                L = R = 0;\n            } else {\n                L = 1;\n                R = 100000;\n            }\n            int aij = inf.readInt(L, R, format(\"a[%d][%d]\", i+1, j+1));\n            if (j + 1 < n)\n                inf.readSpace();\n        }\n        inf.readEoln();\n    }\n\n    vector<int> x = inf.readInts(n, 1, n, \"x\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == n, \"All x_i values must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int L, R;\n            if (i == j) {\n                L = R = 0;\n            } else {\n                L = 1;\n                R = 100000;\n            }\n            int aij = inf.readInt(L, R, format(\"a[%d][%d]\", i+1, j+1));\n            if (j + 1 < n)\n                inf.readSpace();\n        }\n        inf.readEoln();\n    }\n\n    vector<int> x = inf.readInts(n, 1, n, \"x\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == n, \"All x_i values must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int L, R;\n            if (i == j) {\n                L = R = 0;\n            } else {\n                L = 1;\n                R = 100000;\n            }\n            int aij = inf.readInt(L, R, format(\"a[%d][%d]\", i+1, j+1));\n            if (j + 1 < n)\n                inf.readSpace();\n        }\n        inf.readEoln();\n    }\n\n    vector<int> x = inf.readInts(n, 1, n, \"x\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == n, \"All x_i values must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string weight_type = opt<string>(\"weight\", \"random\");\n    string delete_order = opt<string>(\"delete_order\", \"random\");\n\n    vector<vector<int> > a(n, vector<int>(n));\n\n    if (weight_type == \"uniform\") {\n        // All weights are 1\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = 1;\n        }\n    } else if (weight_type == \"max\") {\n        // All weights are 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = 100000;\n        }\n    } else if (weight_type == \"skewed\") {\n        // Weights are min(i, j) % 1e5 + 1\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = (min(i, j) % 100000) + 1;\n        }\n    } else if (weight_type == \"alternating\") {\n        // Weights alternate between 1 and 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = ((i + j) % 2 == 0) ? 1 : 100000;\n        }\n    } else {\n        // Random weights between 1 and 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = rnd.next(1, 100000);\n        }\n    }\n\n    vector<int> x(n);\n    for (int i = 0; i < n; ++i)\n        x[i] = i + 1;\n\n    if (delete_order == \"sequential\") {\n        // x is already in order\n    } else if (delete_order == \"reverse\") {\n        reverse(x.begin(), x.end());\n    } else {\n        shuffle(x.begin(), x.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < n)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", x[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string weight_type = opt<string>(\"weight\", \"random\");\n    string delete_order = opt<string>(\"delete_order\", \"random\");\n\n    vector<vector<int> > a(n, vector<int>(n));\n\n    if (weight_type == \"uniform\") {\n        // All weights are 1\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = 1;\n        }\n    } else if (weight_type == \"max\") {\n        // All weights are 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = 100000;\n        }\n    } else if (weight_type == \"skewed\") {\n        // Weights are min(i, j) % 1e5 + 1\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = (min(i, j) % 100000) + 1;\n        }\n    } else if (weight_type == \"alternating\") {\n        // Weights alternate between 1 and 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = ((i + j) % 2 == 0) ? 1 : 100000;\n        }\n    } else {\n        // Random weights between 1 and 1e5\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = 0;\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    a[i][j] = rnd.next(1, 100000);\n        }\n    }\n\n    vector<int> x(n);\n    for (int i = 0; i < n; ++i)\n        x[i] = i + 1;\n\n    if (delete_order == \"sequential\") {\n        // x is already in order\n    } else if (delete_order == \"reverse\") {\n        reverse(x.begin(), x.end());\n    } else {\n        shuffle(x.begin(), x.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < n)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", x[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -weight uniform -delete_order sequential\n./gen -n 1 -weight max -delete_order reverse\n./gen -n 1 -weight random -delete_order random\n./gen -n 2 -weight uniform -delete_order sequential\n./gen -n 2 -weight max -delete_order reverse\n./gen -n 2 -weight random -delete_order random\n./gen -n 3 -weight uniform -delete_order sequential\n./gen -n 3 -weight max -delete_order reverse\n./gen -n 3 -weight random -delete_order random\n./gen -n 5 -weight skewed -delete_order sequential\n./gen -n 5 -weight alternating -delete_order reverse\n./gen -n 5 -weight random -delete_order random\n./gen -n 10 -weight uniform -delete_order sequential\n./gen -n 50 -weight max -delete_order reverse\n./gen -n 75 -weight random -delete_order random\n./gen -n 100 -weight skewed -delete_order sequential\n./gen -n 150 -weight alternating -delete_order reverse\n./gen -n 500 -weight uniform -delete_order sequential\n./gen -n 500 -weight max -delete_order reverse\n./gen -n 500 -weight random -delete_order random\n./gen -n 500 -weight skewed -delete_order sequential\n./gen -n 500 -weight alternating -delete_order reverse\n./gen -n 500 -weight alternating -delete_order random\n./gen -n 500 -weight random -delete_order sequential\n./gen -n 500 -weight uniform -delete_order random\n./gen -n 500 -weight max -delete_order random\n./gen -n 500 -weight skewed -delete_order random\n./gen -n 499 -weight random -delete_order sequential\n./gen -n 498 -weight random -delete_order reverse\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:01.526113",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "296/E",
      "title": "E. Егор и друзья",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ 5000) — количество людей, включая Егора, и вместительность лодки. В следующей строке записаны n целых чисел — веса людей. Вес человека — это либо 50 килограмм, либо 100 килограмм. Можете считать, что Егор и друзья пронумерованы некоторым образом.",
      "output_spec": "Выходные данныеВ первую строку выведите целое число — минимальное количество переправ. Если невозможно переправить всех людей на другой берег, то выведите целое число -1.Во вторую строку выведите остаток от деления количества способов переправить людей за минимальное количество переправ на число 1000000007 (109 + 7). Если невозможно переправить всех людей на другой берег, то выведите число 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 5050Выходные данныеСкопировать11Входные данныеСкопировать3 10050 50 100Выходные данныеСкопировать52Входные данныеСкопировать2 5050 50Выходные данныеСкопировать-10",
      "description": "E. Егор и друзья\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ 5000) — количество людей, включая Егора, и вместительность лодки. В следующей строке записаны n целых чисел — веса людей. Вес человека — это либо 50 килограмм, либо 100 килограмм. Можете считать, что Егор и друзья пронумерованы некоторым образом.\n\nВходные данные\n\nВыходные данныеВ первую строку выведите целое число — минимальное количество переправ. Если невозможно переправить всех людей на другой берег, то выведите целое число -1.Во вторую строку выведите остаток от деления количества способов переправить людей за минимальное количество переправ на число 1000000007 (109 + 7). Если невозможно переправить всех людей на другой берег, то выведите число 0.\n\nВыходные данные\n\nВходные данныеСкопировать1 5050Выходные данныеСкопировать11Входные данныеСкопировать3 10050 50 100Выходные данныеСкопировать52Входные данныеСкопировать2 5050 50Выходные данныеСкопировать-10\n\nВходные данныеСкопировать1 5050\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 10050 50 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать52\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 5050 50\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте Егор гуляет один и соответственно требуется только одна переправа через реку.Во втором тесте нужно действовать по следующему плану:  переправить двух людей весом по 50 килограмм;  переправить одного человека весом 50 килограмм обратно;  переправить человека весом 100 килограмм;  переправить человека весом 50 килограмм обратно;  переправить двух людей весом по 50 килограмм. Суммарно выходит 5 переправ. В зависимости от того, какого человека выбрать на шаге 2, получаются два различных способа.",
      "solutions": [
        {
          "title": "Codeforces Round #179 - Codeforces",
          "content": "Всем привет!Совсем скоро, 11 апреля в 19:30 MSK состоится Codeforces Round #179, автором которого являюсь я. Это мой пятый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе стандартная, а во втором: 500-1500-1500-2000-2500.Gl & hf ! :)Контест завершен. Надеюсь вам понравились задачи. Победители в первом дивизионе:1). marcina0072). yeputons3). gawry4). KADR5). enot110 Победители во втором дивизионе:1). goie2). Koblyk3). Beriand Идеи решений тут.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7321",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 655
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces",
          "content": "296A - Ярослав и перестановкиЗаметим, что после применения операций обмена любая перестановка чисел.Не сложно понять, что ответ будет положительным, если можно разместить одно число, что бы оно не стояло в соседних клетках.Таким образом, если некоторое число встретилось С раз, то должно выполнятся условие С<=(n+1)/2.296B - Ярослав и две строкиБудем решать обратную задачу: посчитать количество способов сделать сравнимые пары.Для начала посчитаем количество способов сделать первую строку меньше равной второй.Это количество равно произведению количества способов сделать это для каждой позиции по отдельности,так как они все позиции независимы. Посчитаем такую же величину, но когда вторая строка меньше-равна первой. И аналогично посчитаем количество способов сделать две строки равными. Для каждого символа величины можно считать простым циклом.Теперь возьмем величину 10 в степени количества знаков вопроса во входном файле и отнимем полученный ответ на обратную задачу, это и будет ответом.295A - Егор и массивДля того, что бы прибавить значение d на отрезке [x,y] достаточно завести массив b и поставить значенияb[x] += db[y+1] -= dДальше за один проход по массиву легко восстанавливаются все числа.Применим данный метод дважды: сначала для запросов, а потом для операций(зная сколько раз мы ее выполним).295B - Егор и графДля решения задачи нужно хорошо понимать принцип работы алгоритма Флойда.Общий вид алгоритма Флойда:for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) a[i][j] = min(a[i][j], a[i][k]+a[k][j]);То есть на каждом шаге мы пытаемся пропустить путь через вершину К.Будем не удалять вершины, а добавлять(идя с конца).На каждом шаге будем пробовать пропустить путь между всеми вершинами через новую.Таким образом мы получим решение, работающее за кубическое время.295C - Егор и друзьяЗаметим, что на каждом шаге нас интересует только положение лодки(номер берега) и количество людей веса 50 и 100 на каждом береге. При чем количество людей на одном береге полностью определяется через другой.Для поиска минимального количества переправ будем использовать волновой алгоритм, основанный на этом состоянии.Для нахождения количества способов просто добавим сумму всех переходов в состояние при переходе будем переносить все способы из одного состояния в другое умножая на количество способов выбрать людей, которые нужны для перехода из одного состояний в другое.295D - Егор и пещерыБудем пользоваться динамическим программированием: dp[i][j] — сколько существует способов построить фигуру, что в строке i будет ровно j столбцов занятыми черными клетками и всем, что между ними. При этом фигура должная не убывать (иными словами мы берем только верхнюю часть фигуры).Как делать переход? Заметим, что dp[i][j] = 1+dp[i-1][2] * (j-2+1)+ ... +dp[i-1][l] * (j-l+1)+ ... +dp[i-1][j].Распишем это: dp[i][j] = 1+dp[i-1][2] * j+ ... +dp[i-1][l] * j+ ... +dp[i-1][j] * j — dp[i-1][2] * 1 — dp[i-1][3] * 2 — ... — dp[i-1][j] * (j-1).Понятно, что если завести частичные сумму, то данные величины считать становится очень просто.Как посчитать полный ответ: будем перебирать номер максимального подходящего t(обозначенного в условии).Теперь единственное отличие, это то что следующая строка должна содержать строго меньше столбцов. То есть имеем аналогичный переход, с -1 слагаемым.Так же заметим, что зафиксировав \"основу\" мы должны домножить количество способов на число способов разместить ее на плоскости, то есть основу шириной j мы можем поставить (m-j+1) способами.295E - Ярослав и точкиНаучимся решать задачу: найти сумму расстояний между точками.Если расписать, что происходит при добавлении одной точки, то получим формулу: x_i*(2*i-n) Где x_i — отсортированные координаты, а n общее количество точек.Научимся зная ответы для двух отрезков точек знать ответ для их объединения.Понятно, что для подсчета такой информации нужно всего лишь сложить два ответа,и добавить сумму координат первого множества умноженное на некоторое число ии добавить сумму координат второго множества умноженное на некоторое, возможно другое, число.Таким образом зная ответы для некоторых отрезков общий ответ.Будем использовать корневую декомпозицию или декартово дерево для хранения таких отрезков.Не сложно понять, что вставка и удаление делается достаточно быстро для этих структур.Например для корневой декомпозиции можно каждый раз просто вырезать и вставлять точку в нужные отрезки, а если множество стало содержать длинные отрезки или много отрезков, то просто перестроим его заново. Асимптотика решения не меняется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 296"
          },
          "content_length": 4521
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #179 - Codeforces - Code 1",
          "code": "if(D.n) v.pb(D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 2",
          "code": "rep(i,0,1010)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 3",
          "code": "#define MX  ( 1000  +3 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 4",
          "code": "C(x, i) * C(y, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 - Codeforces - Code 5",
          "code": "C(n, k) = n! / (k! * (n - k)!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7321",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <stdio.h>\n#include <math.h>\n#include <fstream>\n#include <algorithm>\n#include <time.h>\n//#include <cstdio>\n\nusing namespace std;\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tint p[10001];\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>p[i];\n\t}\n\tint l[10001],r[10001],d[10001];\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>l[i]>>r[i]>>d[i];\n\t}\n\tint op[10001];\n\tint oc[10001];\n\tfor(int i=1;i<=n;i++){\n\t\top[i]=0;\n\t\toc[i]=0;\n\t}\n\tint x,y;\n\tfor(int i=1;i<=k;i++){\n\t\tcin>>x>>y;\n\t\toc[x]++;\n\t\tif(y<m){\n\t\t\toc[y+1]--;\n\t\t}\n\t}\n\t\n\tint occ=0;\n\tfor(int i=1;i<=m;i++){\n\t\tocc+=oc[i];\n\t\td[i]*=occ;\n\t\top[l[i]]+=d[i];\n\t\tif(r[i]<n){\n\t\t\top[r[i]+1]-=d[i];\n\t\t}\n\t}\n\tint opc=0;\n\tfor(int i=1;i<=n;i++){\n\t\topc+=op[i];\n\t\tcout<<p[i]+opc<<\" \";\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <stdio.h>\n#include <math.h>\n#include <fstream>\n#include <algorithm>\n#include <time.h>\n//#include <cstdio>\n\nusing namespace std;\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tint p[10001];\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>p[i];\n\t}\n\tint l[10001],r[10001],d[10001];\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>l[i]>>r[i]>>d[i];\n\t}\n\tint op[10001];\n\tint oc[10001];\n\tfor(int i=1;i<=n;i++){\n\t\top[i]=0;\n\t\toc[i]=0;\n\t}\n\tint x,y;\n\tfor(int i=1;i<=k;i++){\n\t\tcin>>x>>y;\n\t\toc[x]++;\n\t\tif(y<m){\n\t\t\toc[y+1]--;\n\t\t}\n\t}\n\t\n\tint occ=0;\n\tfor(int i=1;i<=m;i++){\n\t\tocc+=oc[i];\n\t\td[i]*=occ;\n\t\top[l[i]]+=d[i];\n\t\tif(r[i]<n){\n\t\t\top[r[i]+1]-=d[i];\n\t\t}\n\t}\n\tint opc=0;\n\tfor(int i=1;i<=n;i++){\n\t\topc+=op[i];\n\t\tcout<<p[i]+opc<<\" \";\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 5",
          "code": "after op_1: ARR = [ 2,3,3]\n\n     after op_2: ARR = [ 4,5,5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 6",
          "code": "after op_1: ARR = [ 5,6,5]\n\n     after op_2: ARR = [ 7,8,7]\n\n     after op_3: ARR = [ 7,12,11]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #179 tutorial - Codeforces - Code 7",
          "code": "after op_2: ARR = [ 9,14,13]\n\n     after op_3: ARR = [ 9,18,17]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n    \n    vector<int> weights = inf.readInts(n, 50, 100, \"weights\");\n    inf.readEoln(); // Ensure EOLN after reading the n weights\n    \n    // Ensure each weight is either 50 or 100\n    for (int i = 0; i < n; ++i) {\n        ensuref(weights[i] == 50 || weights[i] == 100, \n            \"weights[%d] must be 50 or 100, but it is %d\", i+1, weights[i]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n    \n    vector<int> weights = inf.readInts(n, 50, 100, \"weights\");\n    inf.readEoln(); // Ensure EOLN after reading the n weights\n    \n    // Ensure each weight is either 50 or 100\n    for (int i = 0; i < n; ++i) {\n        ensuref(weights[i] == 50 || weights[i] == 100, \n            \"weights[%d] must be 50 or 100, but it is %d\", i+1, weights[i]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n    \n    vector<int> weights = inf.readInts(n, 50, 100, \"weights\");\n    inf.readEoln(); // Ensure EOLN after reading the n weights\n    \n    // Ensure each weight is either 50 or 100\n    for (int i = 0; i < n; ++i) {\n        ensuref(weights[i] == 50 || weights[i] == 100, \n            \"weights[%d] must be 50 or 100, but it is %d\", i+1, weights[i]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> weights(n);\n\n    if (type == \"all50\") {\n        // All people weigh 50 kg.\n        for(int i = 0; i < n; ++i)\n            weights[i] = 50;\n    } else if (type == \"all100\") {\n        // All people weigh 100 kg.\n        for(int i = 0; i < n; ++i)\n            weights[i] = 100;\n    } else if (type == \"half50\") {\n        // Half the people weigh 50 kg, half weigh 100 kg.\n        for(int i = 0; i < n; ++i)\n            weights[i] = (i < n/2) ? 50 : 100;\n        shuffle(weights.begin(), weights.end());\n    } else if (type == \"random\") {\n        // Weights are random between 50 kg and 100 kg.\n        for(int i = 0; i < n; ++i)\n            weights[i] = rnd.next(0, 1) ? 50 : 100;\n    } else {\n        // Default to random weights.\n        for(int i = 0; i < n; ++i)\n            weights[i] = rnd.next(0, 1) ? 50 : 100;\n    }\n\n    // Output n and k.\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", weights[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> weights(n);\n\n    if (type == \"all50\") {\n        // All people weigh 50 kg.\n        for(int i = 0; i < n; ++i)\n            weights[i] = 50;\n    } else if (type == \"all100\") {\n        // All people weigh 100 kg.\n        for(int i = 0; i < n; ++i)\n            weights[i] = 100;\n    } else if (type == \"half50\") {\n        // Half the people weigh 50 kg, half weigh 100 kg.\n        for(int i = 0; i < n; ++i)\n            weights[i] = (i < n/2) ? 50 : 100;\n        shuffle(weights.begin(), weights.end());\n    } else if (type == \"random\") {\n        // Weights are random between 50 kg and 100 kg.\n        for(int i = 0; i < n; ++i)\n            weights[i] = rnd.next(0, 1) ? 50 : 100;\n    } else {\n        // Default to random weights.\n        for(int i = 0; i < n; ++i)\n            weights[i] = rnd.next(0, 1) ? 50 : 100;\n    }\n\n    // Output n and k.\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", weights[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal cases\n./gen -n 1 -k 50 -type all50\n./gen -n 1 -k 100 -type all100\n\n# Impossible cases\n./gen -n 5 -k 49 -type all50      # All 50 kg people, k = 49 (impossible)\n./gen -n 5 -k 99 -type all100     # All 100 kg people, k = 99 (impossible)\n\n# All 50 kg people with varying boat capacities\n./gen -n 10 -k 50 -type all50\n./gen -n 10 -k 100 -type all50\n./gen -n 10 -k 200 -type all50\n\n# All 100 kg people with varying boat capacities\n./gen -n 10 -k 100 -type all100\n./gen -n 10 -k 200 -type all100\n./gen -n 10 -k 500 -type all100\n\n# Half 50 kg and half 100 kg people\n./gen -n 10 -k 150 -type half50\n./gen -n 10 -k 200 -type half50\n./gen -n 10 -k 300 -type half50\n\n# Random weights\n./gen -n 15 -k 100 -type random\n./gen -n 20 -k 150 -type random\n./gen -n 25 -k 250 -type random\n\n# Maximum values\n./gen -n 50 -k 5000 -type random\n./gen -n 50 -k 100 -type all50\n./gen -n 50 -k 100 -type all100\n\n# Small boat capacity with all 50 kg people\n./gen -n 20 -k 50 -type all50\n\n# Small boat capacity with random weights\n./gen -n 20 -k 50 -type random\n\n# Medium boat capacity with random weights\n./gen -n 30 -k 200 -type random\n\n# All 100 kg people with small to medium boat capacities\n./gen -n 20 -k 100 -type all100\n./gen -n 20 -k 150 -type all100\n\n# Edge cases with tight boat capacities\n./gen -n 50 -k 150 -type half50\n./gen -n 1 -k 49 -type all50        # Invalid single person case (impossible)\n./gen -n 1 -k 99 -type all100       # Invalid single person case (impossible)\n./gen -n 50 -k 50 -type all50       # All 50 kg, boat can carry one person at a time\n./gen -n 50 -k 50 -type all100      # All 100 kg, boat can't carry anyone (impossible)\n\n# Additional random test cases\n./gen -n 35 -k 250 -type random\n./gen -n 40 -k 350 -type random\n./gen -n 45 -k 400 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:03.256156",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "297/A",
      "title": "A. Parity Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the string a and the second line contains the string b (1 ≤ |a|, |b| ≤ 1000). Both strings contain only the characters \"0\" and \"1\". Here |x| denotes the length of the string x.",
      "output_spec": "OutputPrint \"YES\" (without quotes) if it is possible to turn a into b, and \"NO\" (without quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy010110110OutputCopyYESInputCopy00111110OutputCopyNO",
      "description": "A. Parity Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the string a and the second line contains the string b (1 ≤ |a|, |b| ≤ 1000). Both strings contain only the characters \"0\" and \"1\". Here |x| denotes the length of the string x.\n\nOutputPrint \"YES\" (without quotes) if it is possible to turn a into b, and \"NO\" (without quotes) otherwise.\n\nInputCopy010110110OutputCopyYESInputCopy00111110OutputCopyNO\n\nInputCopy010110110\n\nOutputCopyYES\n\nInputCopy00111110\n\nOutputCopyNO\n\nNoteIn the first sample, the steps are as follows: 01011 → 1011 → 011 → 0110",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 297 和字母"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 297\\s*A"
          },
          "content_length": 4179
        },
        {
          "title": "Codeforces Round #180 Div 1 Problem E - Codeforces",
          "content": "Solution of round #180 Div 1 Problem E -- Mystic carvingsFor any three lines, they can intersect in one of the following 5 ways:The problem is asking for the number of Type 2 or Type 5. Some of these configs are easy to count (e.g. Type 1), some are not. To count the number of Type 1, we can exhaust the middle line with index i, and count the number of lines on the right of the middle line (let it be xi) and on the left of the middle line (let it be yi), then the number of Type 1 with that middle line is given by xiyi. There are several methods to calculate xi efficiently. One of them is to process the endpoints in counter clockwise order (let the current endpoint be k), and use a segment tree or binary indexed tree to keep track of the number of lines (ai, bi), ai < bi with l ≤ ai < bi ≤ k for different l. Let j be the line with bj = k, then to find the number of lines with aj < ai < bi < bj, we just need to query the count at aj, then update the binary indexed tree by adding one to the position aj. In the actual implementation, we need to consider that the endpoints are wrapped circularly as well.Unfortunately, Type 2 and Type 5 are the difficult ones. But we are only asked to find the total number of Type 2 and Type 5, which is (number of triples of lines) — (number of Type 1, 3 and 4). The problem then reduces to finding the total number of Type 3 and 4 (namely \"We cannot give a 囧 without an XD and a HA\"). Note that Type 3 and 4 shares a characteristic that two of the lines (the X in Type 3, and the two vertical lines in Type 4) has exactly one intersection with one of the other two lines. Therefore we can find the number of Type 3 and 4 by iterating through the lines, then count the number of lines on the right (xi), on the left (yi), and intersecting the considered line (zi = n - 1 - xi - yi), and give the number of Type 3 and 4 as the sum of zi(xi + yi). After removing double counting, we can get the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1948
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string binaryStringPattern = \"[01]{1,1000}\";\n\n    string a = inf.readLine(binaryStringPattern, \"a\");\n    string b = inf.readLine(binaryStringPattern, \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string binaryStringPattern = \"[01]{1,1000}\";\n\n    string a = inf.readLine(binaryStringPattern, \"a\");\n    string b = inf.readLine(binaryStringPattern, \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string binaryStringPattern = \"[01]{1,1000}\";\n\n    string a = inf.readLine(binaryStringPattern, \"a\");\n    string b = inf.readLine(binaryStringPattern, \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int length) {\n    string s = \"\";\n    for (int i = 0; i < length; ++i) {\n        s += (char)(rnd.next(2) + '0');\n    }\n    return s;\n}\n\nstring simulate(string s, int max_operations, int target_length) {\n    for (int i = 0; i < max_operations && (int)s.size() < target_length; ++i) {\n        int op = rnd.next(2);\n        if (op == 0 && (int)s.size() < target_length) {\n            // Append parity(s) to s\n            int ones = count(s.begin(), s.end(), '1');\n            s += (ones % 2 == 1) ? '1' : '0';\n        } else if (op == 1 && !s.empty()) {\n            // Remove first character\n            s = s.substr(1);\n        }\n    }\n    // Append parity bits to reach target length\n    while ((int)s.size() < target_length) {\n        int ones = count(s.begin(), s.end(), '1');\n        s += (ones % 2 == 1) ? '1' : '0';\n    }\n    if ((int)s.size() > target_length) {\n        s = s.substr(0, target_length);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"possible\");\n    string subtype = opt<string>(\"subtype\", \"random\");\n\n    string a, b;\n\n    if (type == \"possible\") {\n        if (subtype == \"random\") {\n            a = generate_random_string(n);\n            int max_operations = 2 * max(n, m); // Arbitrary choice\n            b = simulate(a, max_operations, m);\n        } else if (subtype == \"identical\") {\n            a = generate_random_string(n);\n            b = a;\n        } else if (subtype == \"remove_front_only\") {\n            a = generate_random_string(n);\n            int remove_count = rnd.next(0, n - 1);\n            b = a.substr(remove_count);\n            if ((int)b.size() < m) {\n                // Append parity bits to reach length m\n                b = simulate(b, m - (int)b.size(), m);\n            } else if ((int)b.size() > m) {\n                b = b.substr(0, m);\n            }\n        } else if (subtype == \"append_parity_only\") {\n            a = generate_random_string(n);\n            b = a;\n            int append_count = m - n;\n            for (int i = 0; i < append_count; ++i) {\n                int ones = count(b.begin(), b.end(), '1');\n                b += (ones % 2 == 1) ? '1' : '0';\n            }\n        } else if (subtype == \"both\") {\n            a = generate_random_string(n);\n            int remove_count = rnd.next(0, n - 1);\n            string s = a.substr(remove_count);\n            int append_count = m - (n - remove_count);\n            for (int i = 0; i < append_count; ++i) {\n                int ones = count(s.begin(), s.end(), '1');\n                s += (ones % 2 == 1) ? '1' : '0';\n            }\n            b = s;\n        } else if (subtype == \"maximal_length\") {\n            n = 1000;\n            m = 1000;\n            a = generate_random_string(n);\n            b = a;\n        }\n    } else if (type == \"impossible\") {\n        if (subtype == \"all_zero_to_one\") {\n            a = string(n, '0');\n            b = generate_random_string(m);\n            if (b.find('1') == string::npos) {\n                b[rnd.next(0, m - 1)] = '1';\n            }\n        } else if (subtype == \"incorrect_parity_chain\") {\n            a = generate_random_string(n);\n            b = a;\n            // Modify b so that it's impossible to reach from a\n            // Change a character in b that cannot be produced by parity operations\n            int pos = rnd.next(0, m - 1);\n            b[pos] = (b[pos] == '0') ? '1' : '0';\n        } else if (subtype == \"minimal_length\") {\n            n = 1;\n            m = 1;\n            a = generate_random_string(n);\n            b = (a[0] == '0') ? \"1\" : \"0\";\n        }\n    }\n\n    // Output a and b\n    printf(\"%s\\n%s\\n\", a.c_str(), b.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int length) {\n    string s = \"\";\n    for (int i = 0; i < length; ++i) {\n        s += (char)(rnd.next(2) + '0');\n    }\n    return s;\n}\n\nstring simulate(string s, int max_operations, int target_length) {\n    for (int i = 0; i < max_operations && (int)s.size() < target_length; ++i) {\n        int op = rnd.next(2);\n        if (op == 0 && (int)s.size() < target_length) {\n            // Append parity(s) to s\n            int ones = count(s.begin(), s.end(), '1');\n            s += (ones % 2 == 1) ? '1' : '0';\n        } else if (op == 1 && !s.empty()) {\n            // Remove first character\n            s = s.substr(1);\n        }\n    }\n    // Append parity bits to reach target length\n    while ((int)s.size() < target_length) {\n        int ones = count(s.begin(), s.end(), '1');\n        s += (ones % 2 == 1) ? '1' : '0';\n    }\n    if ((int)s.size() > target_length) {\n        s = s.substr(0, target_length);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"possible\");\n    string subtype = opt<string>(\"subtype\", \"random\");\n\n    string a, b;\n\n    if (type == \"possible\") {\n        if (subtype == \"random\") {\n            a = generate_random_string(n);\n            int max_operations = 2 * max(n, m); // Arbitrary choice\n            b = simulate(a, max_operations, m);\n        } else if (subtype == \"identical\") {\n            a = generate_random_string(n);\n            b = a;\n        } else if (subtype == \"remove_front_only\") {\n            a = generate_random_string(n);\n            int remove_count = rnd.next(0, n - 1);\n            b = a.substr(remove_count);\n            if ((int)b.size() < m) {\n                // Append parity bits to reach length m\n                b = simulate(b, m - (int)b.size(), m);\n            } else if ((int)b.size() > m) {\n                b = b.substr(0, m);\n            }\n        } else if (subtype == \"append_parity_only\") {\n            a = generate_random_string(n);\n            b = a;\n            int append_count = m - n;\n            for (int i = 0; i < append_count; ++i) {\n                int ones = count(b.begin(), b.end(), '1');\n                b += (ones % 2 == 1) ? '1' : '0';\n            }\n        } else if (subtype == \"both\") {\n            a = generate_random_string(n);\n            int remove_count = rnd.next(0, n - 1);\n            string s = a.substr(remove_count);\n            int append_count = m - (n - remove_count);\n            for (int i = 0; i < append_count; ++i) {\n                int ones = count(s.begin(), s.end(), '1');\n                s += (ones % 2 == 1) ? '1' : '0';\n            }\n            b = s;\n        } else if (subtype == \"maximal_length\") {\n            n = 1000;\n            m = 1000;\n            a = generate_random_string(n);\n            b = a;\n        }\n    } else if (type == \"impossible\") {\n        if (subtype == \"all_zero_to_one\") {\n            a = string(n, '0');\n            b = generate_random_string(m);\n            if (b.find('1') == string::npos) {\n                b[rnd.next(0, m - 1)] = '1';\n            }\n        } else if (subtype == \"incorrect_parity_chain\") {\n            a = generate_random_string(n);\n            b = a;\n            // Modify b so that it's impossible to reach from a\n            // Change a character in b that cannot be produced by parity operations\n            int pos = rnd.next(0, m - 1);\n            b[pos] = (b[pos] == '0') ? '1' : '0';\n        } else if (subtype == \"minimal_length\") {\n            n = 1;\n            m = 1;\n            a = generate_random_string(n);\n            b = (a[0] == '0') ? \"1\" : \"0\";\n        }\n    }\n\n    // Output a and b\n    printf(\"%s\\n%s\\n\", a.c_str(), b.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type possible -subtype identical\n./gen -n 1 -m 1 -type possible -subtype remove_front_only\n./gen -n 1 -m 2 -type possible -subtype append_parity_only\n./gen -n 1 -m 3 -type possible -subtype both\n./gen -n 1 -m 1 -type possible -subtype random\n\n./gen -n 10 -m 10 -type possible -subtype identical\n./gen -n 10 -m 5 -type possible -subtype remove_front_only\n./gen -n 10 -m 15 -type possible -subtype append_parity_only\n./gen -n 10 -m 12 -type possible -subtype both\n./gen -n 10 -m 10 -type possible -subtype random\n\n./gen -n 100 -m 100 -type possible -subtype identical\n./gen -n 100 -m 80 -type possible -subtype remove_front_only\n./gen -n 100 -m 120 -type possible -subtype append_parity_only\n./gen -n 100 -m 110 -type possible -subtype both\n./gen -n 100 -m 100 -type possible -subtype random\n\n./gen -n 1000 -m 1000 -type possible -subtype identical\n./gen -n 1000 -m 900 -type possible -subtype remove_front_only\n./gen -n 1000 -m 1100 -type possible -subtype append_parity_only\n./gen -n 1000 -m 1000 -type possible -subtype both\n./gen -n 1000 -m 1000 -type possible -subtype maximal_length\n\n./gen -n 10 -m 10 -type impossible -subtype all_zero_to_one\n./gen -n 100 -m 100 -type impossible -subtype all_zero_to_one\n./gen -n 1000 -m 1000 -type impossible -subtype all_zero_to_one\n\n./gen -n 10 -m 10 -type impossible -subtype incorrect_parity_chain\n./gen -n 100 -m 100 -type impossible -subtype incorrect_parity_chain\n./gen -n 1000 -m 1000 -type impossible -subtype incorrect_parity_chain\n\n./gen -n 1 -m 1 -type impossible -subtype minimal_length\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:05.396086",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "297/B",
      "title": "B. Fish Weight",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (1 ≤ n, m ≤ 105, 1 ≤ k ≤ 109) — the number of fish caught by Alice and Bob respectively, and the number of fish species.The second line contains n integers each from 1 to k, the list of fish type caught by Alice. The third line contains m integers each from 1 to k, the list of fish type caught by Bob.Note that one may have caught more than one fish for a same species.",
      "output_spec": "OutputOutput \"YES\" (without quotes) if it is possible, and \"NO\" (without quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy3 3 32 2 21 1 3OutputCopyYESInputCopy4 7 95 2 7 33 5 2 7 3 8 7OutputCopyNO",
      "description": "B. Fish Weight\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (1 ≤ n, m ≤ 105, 1 ≤ k ≤ 109) — the number of fish caught by Alice and Bob respectively, and the number of fish species.The second line contains n integers each from 1 to k, the list of fish type caught by Alice. The third line contains m integers each from 1 to k, the list of fish type caught by Bob.Note that one may have caught more than one fish for a same species.\n\nOutputOutput \"YES\" (without quotes) if it is possible, and \"NO\" (without quotes) otherwise.\n\nInputCopy3 3 32 2 21 1 3OutputCopyYESInputCopy4 7 95 2 7 33 5 2 7 3 8 7OutputCopyNO\n\nInputCopy3 3 32 2 21 1 3\n\nOutputCopyYES\n\nInputCopy4 7 95 2 7 33 5 2 7 3 8 7\n\nOutputCopyNO\n\nNoteIn the first sample, if w1 = 1, w2 = 2, w3 = 2.5,  then Alice has a total of 2 + 2 + 2 = 6 weight units, while Bob only has 1 + 1 + 2.5 = 4.5.In the second sample, the fish that Alice caught is a subset of Bob's. Therefore, the total weight of Bob’s fish is always not less than the total weight of Alice’s fish.",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 297 和字母"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 297\\s*B"
          },
          "content_length": 4179
        },
        {
          "title": "Codeforces Round #180 Div 1 Problem E - Codeforces",
          "content": "Solution of round #180 Div 1 Problem E -- Mystic carvingsFor any three lines, they can intersect in one of the following 5 ways:The problem is asking for the number of Type 2 or Type 5. Some of these configs are easy to count (e.g. Type 1), some are not. To count the number of Type 1, we can exhaust the middle line with index i, and count the number of lines on the right of the middle line (let it be xi) and on the left of the middle line (let it be yi), then the number of Type 1 with that middle line is given by xiyi. There are several methods to calculate xi efficiently. One of them is to process the endpoints in counter clockwise order (let the current endpoint be k), and use a segment tree or binary indexed tree to keep track of the number of lines (ai, bi), ai < bi with l ≤ ai < bi ≤ k for different l. Let j be the line with bj = k, then to find the number of lines with aj < ai < bi < bj, we just need to query the count at aj, then update the binary indexed tree by adding one to the position aj. In the actual implementation, we need to consider that the endpoints are wrapped circularly as well.Unfortunately, Type 2 and Type 5 are the difficult ones. But we are only asked to find the total number of Type 2 and Type 5, which is (number of triples of lines) — (number of Type 1, 3 and 4). The problem then reduces to finding the total number of Type 3 and 4 (namely \"We cannot give a 囧 without an XD and a HA\"). Note that Type 3 and 4 shares a characteristic that two of the lines (the X in Type 3, and the two vertical lines in Type 4) has exactly one intersection with one of the other two lines. Therefore we can find the number of Type 3 and 4 by iterating through the lines, then count the number of lines on the right (xi), on the left (yi), and intersecting the considered line (zi = n - 1 - xi - yi), and give the number of Type 3 and 4 as the sum of zi(xi + yi). After removing double counting, we can get the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1948
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, k);\n    inf.readEoln();\n\n    inf.readInts(m, 1, k);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, k);\n    inf.readEoln();\n\n    inf.readInts(m, 1, k);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, k);\n    inf.readEoln();\n\n    inf.readInts(m, 1, k);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    vector<int> alice_fish(n);\n    vector<int> bob_fish(m);\n\n    if (type == \"random\") {\n        // Generate random fish types for Alice and Bob\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = rnd.next(1, k);\n    } else if (type == \"alice_unique\") {\n        // Alice has fish types that Bob doesn't have\n        // Divide the k species into two disjoint subsets\n        int k1 = k / 2; // Alice's fish species from 1 to k1\n        int k2 = k - k1; // Bob's fish species from k1+1 to k\n\n        if (k1 == 0) { // Handle case when k is 1\n            for (int i = 0; i < n; ++i)\n                alice_fish[i] = 1;\n            for (int i = 0; i < m; ++i)\n                bob_fish[i] = 1;\n        } else {\n            for (int i = 0; i < n; ++i)\n                alice_fish[i] = rnd.next(1, k1);\n            for (int i = 0; i < m; ++i)\n                bob_fish[i] = rnd.next(k1 + 1, k);\n        }\n    } else if (type == \"bob_superset\") {\n        // Bob has all of Alice's fish types and more\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = rnd.next(1, k);\n        // Ensure Bob has all of Alice's fish types\n        for (int i = 0; i < min(n, m); ++i)\n            bob_fish[i] = alice_fish[i];\n    } else if (type == \"same_types\") {\n        // Alice and Bob have the same fish types, counts may vary\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = alice_fish[rnd.next(0, n - 1)];\n    } else if (type == \"same_counts\") {\n        // Alice and Bob have exactly the same fish types and counts\n        if (n != m) {\n            fprintf(stderr, \"For type same_counts, n must equal m\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            alice_fish[i] = bob_fish[i] = rnd.next(1, k);\n        }\n    } else if (type == \"alice_heavier\") {\n        // Alice has more of the higher-indexed fish types\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(k / 2 + 1, k);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = rnd.next(1, k / 2);\n    } else if (type == \"bob_heavier\") {\n        // Bob has more of the higher-indexed fish types\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(1, k / 2);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = rnd.next(k / 2 + 1, k);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output Alice's fish types\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", alice_fish[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output Bob's fish types\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", bob_fish[i], i + 1 == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    vector<int> alice_fish(n);\n    vector<int> bob_fish(m);\n\n    if (type == \"random\") {\n        // Generate random fish types for Alice and Bob\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = rnd.next(1, k);\n    } else if (type == \"alice_unique\") {\n        // Alice has fish types that Bob doesn't have\n        // Divide the k species into two disjoint subsets\n        int k1 = k / 2; // Alice's fish species from 1 to k1\n        int k2 = k - k1; // Bob's fish species from k1+1 to k\n\n        if (k1 == 0) { // Handle case when k is 1\n            for (int i = 0; i < n; ++i)\n                alice_fish[i] = 1;\n            for (int i = 0; i < m; ++i)\n                bob_fish[i] = 1;\n        } else {\n            for (int i = 0; i < n; ++i)\n                alice_fish[i] = rnd.next(1, k1);\n            for (int i = 0; i < m; ++i)\n                bob_fish[i] = rnd.next(k1 + 1, k);\n        }\n    } else if (type == \"bob_superset\") {\n        // Bob has all of Alice's fish types and more\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = rnd.next(1, k);\n        // Ensure Bob has all of Alice's fish types\n        for (int i = 0; i < min(n, m); ++i)\n            bob_fish[i] = alice_fish[i];\n    } else if (type == \"same_types\") {\n        // Alice and Bob have the same fish types, counts may vary\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = alice_fish[rnd.next(0, n - 1)];\n    } else if (type == \"same_counts\") {\n        // Alice and Bob have exactly the same fish types and counts\n        if (n != m) {\n            fprintf(stderr, \"For type same_counts, n must equal m\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            alice_fish[i] = bob_fish[i] = rnd.next(1, k);\n        }\n    } else if (type == \"alice_heavier\") {\n        // Alice has more of the higher-indexed fish types\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(k / 2 + 1, k);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = rnd.next(1, k / 2);\n    } else if (type == \"bob_heavier\") {\n        // Bob has more of the higher-indexed fish types\n        for (int i = 0; i < n; ++i)\n            alice_fish[i] = rnd.next(1, k / 2);\n        for (int i = 0; i < m; ++i)\n            bob_fish[i] = rnd.next(k / 2 + 1, k);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output Alice's fish types\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", alice_fish[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output Bob's fish types\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", bob_fish[i], i + 1 == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 10 -k 5 -type random\n./gen -n 100 -m 100 -k 20 -type random\n./gen -n 1000 -m 1000 -k 100 -type random\n./gen -n 10000 -m 10000 -k 1000 -type random\n./gen -n 100000 -m 100000 -k 10000 -type random\n\n./gen -n 10 -m 10 -k 10 -type alice_unique\n./gen -n 100 -m 100 -k 200 -type alice_unique\n./gen -n 1000 -m 1000 -k 1000 -type alice_unique\n./gen -n 10000 -m 10000 -k 100000 -type alice_unique\n./gen -n 100000 -m 100000 -k 1000000000 -type alice_unique\n\n./gen -n 10 -m 20 -k 10 -type bob_superset\n./gen -n 100 -m 200 -k 20 -type bob_superset\n./gen -n 1000 -m 2000 -k 100 -type bob_superset\n./gen -n 10000 -m 20000 -k 1000 -type bob_superset\n./gen -n 100000 -m 200000 -k 10000 -type bob_superset\n\n./gen -n 10 -m 10 -k 5 -type same_types\n./gen -n 50 -m 50 -k 10 -type same_types\n./gen -n 1000 -m 1000 -k 100 -type same_types\n./gen -n 50000 -m 50000 -k 1000 -type same_types\n./gen -n 100000 -m 100000 -k 10000 -type same_types\n\n./gen -n 10 -m 10 -k 5 -type same_counts\n./gen -n 100 -m 100 -k 20 -type same_counts\n./gen -n 1000 -m 1000 -k 100 -type same_counts\n./gen -n 10000 -m 10000 -k 1000 -type same_counts\n./gen -n 100000 -m 100000 -k 10000 -type same_counts\n\n./gen -n 10 -m 10 -k 10 -type alice_heavier\n./gen -n 100 -m 100 -k 20 -type alice_heavier\n./gen -n 1000 -m 1000 -k 100 -type alice_heavier\n./gen -n 10000 -m 10000 -k 1000 -type alice_heavier\n./gen -n 100000 -m 100000 -k 10000 -type alice_heavier\n\n./gen -n 10 -m 10 -k 10 -type bob_heavier\n./gen -n 100 -m 200 -k 20 -type bob_heavier\n./gen -n 1000 -m 5000 -k 100 -type bob_heavier\n./gen -n 10000 -m 50000 -k 1000 -type bob_heavier\n./gen -n 100000 -m 100000 -k 10000 -type bob_heavier\n\n./gen -n 1 -m 1 -k 1 -type random\n./gen -n 1 -m 100000 -k 1 -type random\n./gen -n 100000 -m 1 -k 1 -type random\n\n# Edge cases with minimal k\n./gen -n 1000 -m 1000 -k 1 -type random\n\n# Edge cases with maximal k\n./gen -n 1000 -m 1000 -k 1000000000 -type random\n\n# Maximal n and m with random type\n./gen -n 100000 -m 100000 -k 1000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:07.645369",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "297/C",
      "title": "C. Splitting the Uniqueness",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 105).The second line contains n distinct integers s1, s2, ... sn (0 ≤ si ≤ 109).",
      "output_spec": "OutputIf it is possible to make Alice and Bob happy (if you can split the given array), print \"YES\" (without quotes) in the first line. In the second line, print the array a. In the third line, print the array b. There may be more than one solution. Any of them will be accepted.If it is impossible to split s into almost unique arrays a and b, print \"NO\" (without quotes) in the first line.",
      "sample_tests": "ExamplesInputCopy612 5 8 3 11 9OutputCopyYES6 2 6 0 2 46 3 2 3 9 5",
      "description": "C. Splitting the Uniqueness\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 105).The second line contains n distinct integers s1, s2, ... sn (0 ≤ si ≤ 109).\n\nOutputIf it is possible to make Alice and Bob happy (if you can split the given array), print \"YES\" (without quotes) in the first line. In the second line, print the array a. In the third line, print the array b. There may be more than one solution. Any of them will be accepted.If it is impossible to split s into almost unique arrays a and b, print \"NO\" (without quotes) in the first line.\n\nInputCopy612 5 8 3 11 9OutputCopyYES6 2 6 0 2 46 3 2 3 9 5\n\nInputCopy612 5 8 3 11 9\n\nOutputCopyYES6 2 6 0 2 46 3 2 3 9 5\n\nNoteIn the sample, we can remove the first two entries from a and the second entry from b to make them both unique.",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 297 和字母"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 297\\s*C"
          },
          "content_length": 4179
        },
        {
          "title": "Codeforces Round #180 Div 1 Problem E - Codeforces",
          "content": "Solution of round #180 Div 1 Problem E -- Mystic carvingsFor any three lines, they can intersect in one of the following 5 ways:The problem is asking for the number of Type 2 or Type 5. Some of these configs are easy to count (e.g. Type 1), some are not. To count the number of Type 1, we can exhaust the middle line with index i, and count the number of lines on the right of the middle line (let it be xi) and on the left of the middle line (let it be yi), then the number of Type 1 with that middle line is given by xiyi. There are several methods to calculate xi efficiently. One of them is to process the endpoints in counter clockwise order (let the current endpoint be k), and use a segment tree or binary indexed tree to keep track of the number of lines (ai, bi), ai < bi with l ≤ ai < bi ≤ k for different l. Let j be the line with bj = k, then to find the number of lines with aj < ai < bi < bj, we just need to query the count at aj, then update the binary indexed tree by adding one to the position aj. In the actual implementation, we need to consider that the endpoints are wrapped circularly as well.Unfortunately, Type 2 and Type 5 are the difficult ones. But we are only asked to find the total number of Type 2 and Type 5, which is (number of triples of lines) — (number of Type 1, 3 and 4). The problem then reduces to finding the total number of Type 3 and 4 (namely \"We cannot give a 囧 without an XD and a HA\"). Note that Type 3 and 4 shares a characteristic that two of the lines (the X in Type 3, and the two vertical lines in Type 4) has exactly one intersection with one of the other two lines. Therefore we can find the number of Type 3 and 4 by iterating through the lines, then count the number of lines on the right (xi), on the left (yi), and intersecting the considered line (zi = n - 1 - xi - yi), and give the number of Type 3 and 4 as the sum of zi(xi + yi). After removing double counting, we can get the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1948
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, 0, 1000000000, \"s\");\n    inf.readEoln();\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"Array s must contain distinct integers\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, 0, 1000000000, \"s\");\n    inf.readEoln();\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"Array s must contain distinct integers\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, 0, 1000000000, \"s\");\n    inf.readEoln();\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"Array s must contain distinct integers\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from input file\n    int n = inf.readInt(1, 100000, \"n\");\n    vector<long long> s(n);\n    for (int i = 0; i < n; ++i) {\n        s[i] = inf.readLong(0LL, 1000000000LL, format(\"s[%d]\", i + 1).c_str());\n    }\n\n    // Read judge's answer\n    string jur_ans = ans.readToken();\n\n    // Read participant's answer\n    string part_ans = ouf.readToken();\n\n    if (jur_ans != \"YES\" && jur_ans != \"NO\") {\n        quitf(_fail, \"Jury's answer is neither YES nor NO: \\\"%s\\\"\", jur_ans.c_str());\n    }\n\n    if (part_ans != \"YES\" && part_ans != \"NO\") {\n        quitf(_pe, \"Participant's answer is neither YES nor NO: \\\"%s\\\"\", part_ans.c_str());\n    }\n\n    if (jur_ans == \"NO\") {\n        if (part_ans == \"NO\") {\n            quitf(_ok, \"Correctly answered NO\");\n        } else {\n            quitf(_wa, \"Participant claimed YES while correct answer is NO\");\n        }\n    } else { // jur_ans == \"YES\"\n        if (part_ans == \"NO\") {\n            quitf(_wa, \"Participant claimed NO while correct answer is YES\");\n        } else { // part_ans == \"YES\"\n            // Read arrays a and b from participant's output\n            vector<long long> a = ouf.readLongs(n, 0LL, 1000000000LL, \"a\");\n            vector<long long> b = ouf.readLongs(n, 0LL, 1000000000LL, \"b\");\n\n            if ((int)a.size() != n) {\n                quitf(_wa, \"Array a length is %d, expected %d\", (int)a.size(), n);\n            }\n            if ((int)b.size() != n) {\n                quitf(_wa, \"Array b length is %d, expected %d\", (int)b.size(), n);\n            }\n\n            for (int i = 0; i < n; ++i) {\n                if (a[i] + b[i] != s[i]) {\n                    quitf(_wa, \"At position %d, a + b != s: %lld + %lld != %lld\", i + 1, a[i], b[i], s[i]);\n                }\n            }\n\n            auto isAlmostUnique = [](const vector<long long>& arr) -> bool {\n                int n = arr.size();\n                int duplicates = n - (int)unordered_set<long long>(arr.begin(), arr.end()).size();\n                return duplicates <= n / 2;\n            };\n\n            if (!isAlmostUnique(a)) {\n                quitf(_wa, \"Array a is not almost unique\");\n            }\n\n            if (!isAlmostUnique(b)) {\n                quitf(_wa, \"Array b is not almost unique\");\n            }\n\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        // Generate n unique random integers between 0 and 1e9\n        set<int> used;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (used.count(x)) continue;\n            used.insert(x);\n            s[i++] = x;\n        }\n    } else if (type == \"max_numbers\") {\n        // Generate n unique integers close to 1e9\n        int maxStart = int(1e9) - n + 1;\n        for (int i = 0; i < n; ++i) {\n            s[i] = maxStart + i;\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"min_numbers\") {\n        // Generate n unique integers starting from 0\n        for (int i = 0; i < n; ++i) {\n            s[i] = i;\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"sequential\") {\n        // Generate s_i = i\n        for (int i = 0; i < n; ++i) {\n            s[i] = i;\n        }\n    } else if (type == \"reverse_sequential\") {\n        // Generate s_i = n - i\n        for (int i = 0; i < n; ++i) {\n            s[i] = n - i;\n        }\n    } else if (type == \"small_gaps\") {\n        // Generate integers with small increments\n        int start = rnd.next(0, int(1e9) - n * 10);\n        for (int i = 0; i < n; ++i) {\n            s[i] = start + i * rnd.next(1, 10);\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"arithmetic_progression\") {\n        // Generate an arithmetic progression\n        int start = rnd.next(0, int(1e9) / 2);\n        int diff = rnd.next(1, int(1e5));\n        for (int i = 0; i < n; ++i) {\n            s[i] = start + diff * i;\n            if (s[i] > int(1e9)) s[i] -= int(1e9);\n        }\n        shuffle(s.begin(), s.end());\n    } else {\n        // Default to random unique integers\n        set<int> used;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (used.count(x)) continue;\n            used.insert(x);\n            s[i++] = x;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output s_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", s[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        // Generate n unique random integers between 0 and 1e9\n        set<int> used;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (used.count(x)) continue;\n            used.insert(x);\n            s[i++] = x;\n        }\n    } else if (type == \"max_numbers\") {\n        // Generate n unique integers close to 1e9\n        int maxStart = int(1e9) - n + 1;\n        for (int i = 0; i < n; ++i) {\n            s[i] = maxStart + i;\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"min_numbers\") {\n        // Generate n unique integers starting from 0\n        for (int i = 0; i < n; ++i) {\n            s[i] = i;\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"sequential\") {\n        // Generate s_i = i\n        for (int i = 0; i < n; ++i) {\n            s[i] = i;\n        }\n    } else if (type == \"reverse_sequential\") {\n        // Generate s_i = n - i\n        for (int i = 0; i < n; ++i) {\n            s[i] = n - i;\n        }\n    } else if (type == \"small_gaps\") {\n        // Generate integers with small increments\n        int start = rnd.next(0, int(1e9) - n * 10);\n        for (int i = 0; i < n; ++i) {\n            s[i] = start + i * rnd.next(1, 10);\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"arithmetic_progression\") {\n        // Generate an arithmetic progression\n        int start = rnd.next(0, int(1e9) / 2);\n        int diff = rnd.next(1, int(1e5));\n        for (int i = 0; i < n; ++i) {\n            s[i] = start + diff * i;\n            if (s[i] > int(1e9)) s[i] -= int(1e9);\n        }\n        shuffle(s.begin(), s.end());\n    } else {\n        // Default to random unique integers\n        set<int> used;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (used.count(x)) continue;\n            used.insert(x);\n            s[i++] = x;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output s_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", s[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random values\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n\n# Small n, sequential values\n./gen -n 5 -type sequential\n./gen -n 5 -type reverse_sequential\n\n# Medium n, random values\n./gen -n 100 -type random\n./gen -n 100 -type max_numbers\n./gen -n 100 -type min_numbers\n\n# Medium n, special patterns\n./gen -n 100 -type sequential\n./gen -n 100 -type reverse_sequential\n./gen -n 100 -type arithmetic_progression\n\n# Large n, random values\n./gen -n 1000 -type random\n./gen -n 1000 -type small_gaps\n./gen -n 1000 -type arithmetic_progression\n\n# Larger n, special patterns\n./gen -n 10000 -type random\n./gen -n 10000 -type max_numbers\n./gen -n 10000 -type min_numbers\n./gen -n 10000 -type small_gaps\n./gen -n 10000 -type arithmetic_progression\n\n# Maximum n, random values\n./gen -n 100000 -type random\n./gen -n 100000 -type max_numbers\n./gen -n 100000 -type min_numbers\n./gen -n 100000 -type sequential\n./gen -n 100000 -type reverse_sequential\n./gen -n 100000 -type small_gaps\n./gen -n 100000 -type arithmetic_progression\n\n# Edge cases\n./gen -n 99999 -type random\n./gen -n 100000 -type random\n./gen -n 1 -type sequential\n\n# Additional tests with varying patterns\n./gen -n 50000 -type random\n./gen -n 50000 -type small_gaps\n./gen -n 50000 -type arithmetic_progression\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:09.855129",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "297/D",
      "title": "D. Color the Carpet",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers h, w, k (2 ≤ h, w ≤ 1000, 1 ≤ k ≤ w·h).The next 2h - 1 lines describe the color constraints from top to bottom, left to right. They contain w - 1, w, w - 1, w, ..., w - 1 characters respectively. Each color constraint is represented by a character \"E\" or \"N\", where \"E\" means \" = \" and \"N\" means \" ≠ \".The color constraints listed in the order they are depicted on the picture.",
      "output_spec": "OutputIf there is a coloring that satisfies at least  of the color constraints, print \"YES\" (without quotes) in the first line. In each of the next h lines, print w integers describing the coloring.Otherwise, print \"NO\" (without quotes).",
      "sample_tests": "ExamplesInputCopy3 4 4ENENNEENEEENENENNOutputCopyYES1 1 2 23 4 1 13 3 2 4",
      "description": "D. Color the Carpet\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers h, w, k (2 ≤ h, w ≤ 1000, 1 ≤ k ≤ w·h).The next 2h - 1 lines describe the color constraints from top to bottom, left to right. They contain w - 1, w, w - 1, w, ..., w - 1 characters respectively. Each color constraint is represented by a character \"E\" or \"N\", where \"E\" means \" = \" and \"N\" means \" ≠ \".The color constraints listed in the order they are depicted on the picture.\n\nOutputIf there is a coloring that satisfies at least  of the color constraints, print \"YES\" (without quotes) in the first line. In each of the next h lines, print w integers describing the coloring.Otherwise, print \"NO\" (without quotes).\n\nInputCopy3 4 4ENENNEENEEENENENNOutputCopyYES1 1 2 23 4 1 13 3 2 4\n\nInputCopy3 4 4ENENNEENEEENENENN\n\nOutputCopyYES1 1 2 23 4 1 13 3 2 4",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 297 和字母"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 297\\s*D"
          },
          "content_length": 4179
        },
        {
          "title": "Codeforces Round #180 Div 1 Problem E - Codeforces",
          "content": "Solution of round #180 Div 1 Problem E -- Mystic carvingsFor any three lines, they can intersect in one of the following 5 ways:The problem is asking for the number of Type 2 or Type 5. Some of these configs are easy to count (e.g. Type 1), some are not. To count the number of Type 1, we can exhaust the middle line with index i, and count the number of lines on the right of the middle line (let it be xi) and on the left of the middle line (let it be yi), then the number of Type 1 with that middle line is given by xiyi. There are several methods to calculate xi efficiently. One of them is to process the endpoints in counter clockwise order (let the current endpoint be k), and use a segment tree or binary indexed tree to keep track of the number of lines (ai, bi), ai < bi with l ≤ ai < bi ≤ k for different l. Let j be the line with bj = k, then to find the number of lines with aj < ai < bi < bj, we just need to query the count at aj, then update the binary indexed tree by adding one to the position aj. In the actual implementation, we need to consider that the endpoints are wrapped circularly as well.Unfortunately, Type 2 and Type 5 are the difficult ones. But we are only asked to find the total number of Type 2 and Type 5, which is (number of triples of lines) — (number of Type 1, 3 and 4). The problem then reduces to finding the total number of Type 3 and 4 (namely \"We cannot give a 囧 without an XD and a HA\"). Note that Type 3 and 4 shares a characteristic that two of the lines (the X in Type 3, and the two vertical lines in Type 4) has exactly one intersection with one of the other two lines. Therefore we can find the number of Type 3 and 4 by iterating through the lines, then count the number of lines on the right (xi), on the left (yi), and intersecting the considered line (zi = n - 1 - xi - yi), and give the number of Type 3 and 4 as the sum of zi(xi + yi). After removing double counting, we can get the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1948
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(2, 1000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(2, 1000, \"w\");\n    inf.readSpace();\n    int k = inf.readInt(1, h * w, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < 2 * h - 1; i++) {\n        string pattern;\n        if (i % 2 == 0) {\n            pattern = \"[EN]{\" + to_string(w - 1) + \"}\";\n        } else {\n            pattern = \"[EN]{\" + to_string(w) + \"}\";\n        }\n        string line = inf.readLine(pattern, \"constraints_line_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(2, 1000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(2, 1000, \"w\");\n    inf.readSpace();\n    int k = inf.readInt(1, h * w, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < 2 * h - 1; i++) {\n        string pattern;\n        if (i % 2 == 0) {\n            pattern = \"[EN]{\" + to_string(w - 1) + \"}\";\n        } else {\n            pattern = \"[EN]{\" + to_string(w) + \"}\";\n        }\n        string line = inf.readLine(pattern, \"constraints_line_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(2, 1000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(2, 1000, \"w\");\n    inf.readSpace();\n    int k = inf.readInt(1, h * w, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < 2 * h - 1; i++) {\n        string pattern;\n        if (i % 2 == 0) {\n            pattern = \"[EN]{\" + to_string(w - 1) + \"}\";\n        } else {\n            pattern = \"[EN]{\" + to_string(w) + \"}\";\n        }\n        string line = inf.readLine(pattern, \"constraints_line_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w, k;\nvector<string> constraints;\n\nint readAns(InStream& stream, vector<vector<int>>& coloring, int& satisfiedConstraints) {\n    string verdict = stream.readToken();\n    if (verdict != \"YES\" && verdict != \"NO\") {\n        stream.quitf(_fail, \"Expected 'YES' or 'NO', found '%s'\", verdict.c_str());\n    }\n    if (verdict == \"NO\") {\n        return 0; // No acceptable coloring\n    } else { // \"YES\"\n        coloring.resize(h, vector<int>(w));\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                coloring[i][j] = stream.readInt(1, k, format(\"color[%d][%d]\", i+1, j+1).c_str());\n            }\n        }\n        // Now check how many constraints are satisfied\n        int totalConstraints = 0;\n        int satisfied = 0;\n        for (int i = 0; i < 2*h-1; i++) {\n            string line = constraints[i];\n            if (i%2 == 0) { // horizontal constraints\n                for (int j = 0; j < w-1; j++) {\n                    char c = line[j];\n                    totalConstraints++;\n                    if (c == 'E') {\n                        if (coloring[i/2][j] == coloring[i/2][j+1]) satisfied++;\n                    } else if (c == 'N') {\n                        if (coloring[i/2][j] != coloring[i/2][j+1]) satisfied++;\n                    }\n                }\n            } else { // vertical constraints\n                for (int j = 0; j < w; j++) {\n                    char c = line[j];\n                    totalConstraints++;\n                    if (c == 'E') {\n                        if (coloring[(i-1)/2][j] == coloring[(i+1)/2][j]) satisfied++;\n                    } else if (c == 'N') {\n                        if (coloring[(i-1)/2][j] != coloring[(i+1)/2][j]) satisfied++;\n                    }\n                }\n            }\n        }\n        satisfiedConstraints = satisfied;\n        return 1; // Yes, acceptable coloring\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    h = inf.readInt(); w = inf.readInt(); k = inf.readInt();\n    constraints.resize(2*h - 1);\n    for (int i = 0; i < 2*h - 1; i++) {\n        constraints[i] = inf.readToken();\n    }\n    int jurySatisfied = 0, participantSatisfied = 0;\n    vector<vector<int>> juryColoring, participantColoring;\n\n    int juryHasColoring = readAns(ans, juryColoring, jurySatisfied);\n    int participantHasColoring = readAns(ouf, participantColoring, participantSatisfied);\n\n    if (juryHasColoring == 0 && participantHasColoring == 1) {\n        quitf(_fail, \"Participant found a coloring, but jury says there is none\");\n    } else if (juryHasColoring == 1 && participantHasColoring == 0) {\n        quitf(_wa, \"Participant failed to find a coloring\");\n    } else if (juryHasColoring == 0 && participantHasColoring == 0) {\n        quitf(_ok, \"No acceptable coloring exists\");\n    } else {\n        // Both have coloring, need to check whether participant's coloring is acceptable\n        int totalConstraints = 0;\n        for (int i = 0; i < 2*h -1; i++) {\n            string line = constraints[i];\n            if (i % 2 == 0) {\n                totalConstraints += w - 1;\n            } else {\n                totalConstraints += w;\n            }\n        }\n        int requiredSatisfied = totalConstraints / 2; // floor(M / 2)\n        if (participantSatisfied >= requiredSatisfied) {\n            quitf(_ok, \"Participant's coloring satisfies %d constraints, required %d\", participantSatisfied, requiredSatisfied);\n        } else {\n            quitf(_wa, \"Participant's coloring satisfies only %d constraints, required %d\", participantSatisfied, requiredSatisfied);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int h = opt<int>(\"h\");\n    int w = opt<int>(\"w\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> constraints(2 * h - 1);\n    // Now generate the constraints depending on type\n\n    if(type == \"all_equal\"){\n        // All constraints are 'E'\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = string(len, 'E');\n        }\n    } else if(type == \"all_not_equal\"){\n        // All constraints are 'N'\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = string(len, 'N');\n        }\n    } else if(type == \"random\"){\n        // Random constraints of 'E' or 'N'\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = \"\";\n            for(int j = 0; j < len; ++j){\n                if(rnd.next(2))\n                    constraints[i] += 'E';\n                else\n                    constraints[i] += 'N';\n            }\n        }\n    } else if(type == \"unsat\"){\n        // Generate test cases that are likely unsatisfiable\n        int total_constraints = 2 * h * w - h - w;\n        int num_unsat_constraints = total_constraints - floor(0.999 * total_constraints) + 1;\n\n        // Initialize constraints to 'N'\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = string(len, 'N');\n        }\n\n        // Now we need to change num_unsat_constraints constraints to 'E'\n\n        vector<pair<int, int> > positions;\n\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = constraints[i].size();\n            for(int j = 0; j < len; ++j){\n                positions.push_back(make_pair(i, j));\n            }\n        }\n\n        shuffle(positions.begin(), positions.end());\n\n        for(int i = 0; i < num_unsat_constraints; ++i){\n            int x = positions[i].first;\n            int y = positions[i].second;\n            constraints[x][y] = 'E';\n        }\n\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = \"\";\n            for(int j = 0; j < len; ++j){\n                if(rnd.next(2))\n                    constraints[i] += 'E';\n                else\n                    constraints[i] += 'N';\n            }\n        }\n    }\n\n    // Print h, w, k\n    printf(\"%d %d %d\\n\", h, w, k);\n\n    for(int i = 0; i < constraints.size(); ++i){\n        printf(\"%s\\n\", constraints[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int h = opt<int>(\"h\");\n    int w = opt<int>(\"w\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> constraints(2 * h - 1);\n    // Now generate the constraints depending on type\n\n    if(type == \"all_equal\"){\n        // All constraints are 'E'\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = string(len, 'E');\n        }\n    } else if(type == \"all_not_equal\"){\n        // All constraints are 'N'\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = string(len, 'N');\n        }\n    } else if(type == \"random\"){\n        // Random constraints of 'E' or 'N'\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = \"\";\n            for(int j = 0; j < len; ++j){\n                if(rnd.next(2))\n                    constraints[i] += 'E';\n                else\n                    constraints[i] += 'N';\n            }\n        }\n    } else if(type == \"unsat\"){\n        // Generate test cases that are likely unsatisfiable\n        int total_constraints = 2 * h * w - h - w;\n        int num_unsat_constraints = total_constraints - floor(0.999 * total_constraints) + 1;\n\n        // Initialize constraints to 'N'\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = string(len, 'N');\n        }\n\n        // Now we need to change num_unsat_constraints constraints to 'E'\n\n        vector<pair<int, int> > positions;\n\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = constraints[i].size();\n            for(int j = 0; j < len; ++j){\n                positions.push_back(make_pair(i, j));\n            }\n        }\n\n        shuffle(positions.begin(), positions.end());\n\n        for(int i = 0; i < num_unsat_constraints; ++i){\n            int x = positions[i].first;\n            int y = positions[i].second;\n            constraints[x][y] = 'E';\n        }\n\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < 2 * h - 1; ++i){\n            int len = (i % 2 == 0) ? w - 1 : w;\n            constraints[i] = \"\";\n            for(int j = 0; j < len; ++j){\n                if(rnd.next(2))\n                    constraints[i] += 'E';\n                else\n                    constraints[i] += 'N';\n            }\n        }\n    }\n\n    // Print h, w, k\n    printf(\"%d %d %d\\n\", h, w, k);\n\n    for(int i = 0; i < constraints.size(); ++i){\n        printf(\"%s\\n\", constraints[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -h 2 -w 2 -k 1 -type all_equal\n./gen -h 2 -w 2 -k 2 -type all_not_equal\n./gen -h 2 -w 2 -k 2 -type random\n\n./gen -h 3 -w 3 -k 2 -type all_not_equal\n./gen -h 3 -w 3 -k 3 -type random\n./gen -h 3 -w 3 -k 1 -type all_equal\n\n./gen -h 10 -w 10 -k 1 -type all_equal\n./gen -h 10 -w 10 -k 2 -type all_not_equal\n./gen -h 10 -w 10 -k 5 -type random\n\n./gen -h 100 -w 100 -k 2 -type all_not_equal\n./gen -h 100 -w 100 -k 100 -type random\n./gen -h 100 -w 100 -k 1 -type all_equal\n\n./gen -h 500 -w 500 -k 2 -type all_not_equal\n./gen -h 500 -w 500 -k 500 -type random\n./gen -h 500 -w 500 -k 1 -type all_equal\n\n./gen -h 1000 -w 1000 -k 2 -type all_not_equal\n./gen -h 1000 -w 1000 -k 1000000 -type random\n./gen -h 1000 -w 1000 -k 1 -type all_equal\n\n./gen -h 1000 -w 1000 -k 2 -type unsat\n./gen -h 1000 -w 1000 -k 100 -type unsat\n\n./gen -h 1000 -w 1000 -k 2 -type random\n\n./gen -h 999 -w 1000 -k 2 -type all_not_equal\n./gen -h 1000 -w 999 -k 2 -type all_not_equal\n\n./gen -h 2 -w 1000 -k 2 -type all_not_equal\n./gen -h 1000 -w 2 -k 2 -type all_not_equal\n\n./gen -h 1000 -w 1000 -k 3 -type all_not_equal\n\n./gen -h 1000 -w 1000 -k 2 -type all_equal\n\n./gen -h 1000 -w 1000 -k 1000000 -type random\n\n./gen -h 1000 -w 1000 -k 2 -type random\n\n./gen -h 1000 -w 1000 -k 1 -type unsat\n\n./gen -h 10 -w 10 -k 1 -type unsat\n\n./gen -h 500 -w 500 -k 2 -type unsat\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:12.015453",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "297/E",
      "title": "E. Mystic Carvings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n(3 ≤ n ≤ 105) — the number of lines.Each of the following n lines contains two integers ai, bi (1 ≤ ai, bi ≤ 2n), which means that there is a line carved on the ice connecting the ai–th and bi–th endpoint. It's guaranteed that each endpoints touches exactly one line.",
      "output_spec": "OutputPrint the number of ways to build the caves.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy45 41 26 78 3OutputCopy2InputCopy81 72 43 95 116 810 1613 1514 12OutputCopy6",
      "description": "E. Mystic Carvings\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n(3 ≤ n ≤ 105) — the number of lines.Each of the following n lines contains two integers ai, bi (1 ≤ ai, bi ≤ 2n), which means that there is a line carved on the ice connecting the ai–th and bi–th endpoint. It's guaranteed that each endpoints touches exactly one line.\n\nOutputPrint the number of ways to build the caves.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy45 41 26 78 3OutputCopy2InputCopy81 72 43 95 116 810 1613 1514 12OutputCopy6\n\nInputCopy45 41 26 78 3\n\nOutputCopy2\n\nInputCopy81 72 43 95 116 810 1613 1514 12\n\nOutputCopy6\n\nNoteThe second sample corresponds to the figure in the problem statement.",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 297\\s*E"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 297\\s*E"
          },
          "content_length": 4179
        },
        {
          "title": "Codeforces Round #180 Div 1 Problem E - Codeforces",
          "content": "Solution of round #180 Div 1 Problem E -- Mystic carvingsFor any three lines, they can intersect in one of the following 5 ways:The problem is asking for the number of Type 2 or Type 5. Some of these configs are easy to count (e.g. Type 1), some are not. To count the number of Type 1, we can exhaust the middle line with index i, and count the number of lines on the right of the middle line (let it be xi) and on the left of the middle line (let it be yi), then the number of Type 1 with that middle line is given by xiyi. There are several methods to calculate xi efficiently. One of them is to process the endpoints in counter clockwise order (let the current endpoint be k), and use a segment tree or binary indexed tree to keep track of the number of lines (ai, bi), ai < bi with l ≤ ai < bi ≤ k for different l. Let j be the line with bj = k, then to find the number of lines with aj < ai < bi < bj, we just need to query the count at aj, then update the binary indexed tree by adding one to the position aj. In the actual implementation, we need to consider that the endpoints are wrapped circularly as well.Unfortunately, Type 2 and Type 5 are the difficult ones. But we are only asked to find the total number of Type 2 and Type 5, which is (number of triples of lines) — (number of Type 1, 3 and 4). The problem then reduces to finding the total number of Type 3 and 4 (namely \"We cannot give a 囧 without an XD and a HA\"). Note that Type 3 and 4 shares a characteristic that two of the lines (the X in Type 3, and the two vertical lines in Type 4) has exactly one intersection with one of the other two lines. Therefore we can find the number of Type 3 and 4 by iterating through the lines, then count the number of lines on the right (xi), on the left (yi), and intersecting the considered line (zi = n - 1 - xi - yi), and give the number of Type 3 and 4 as the sum of zi(xi + yi). After removing double counting, we can get the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1948
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000); // Read n in [3, 1e5]\n    inf.readEoln();\n\n    int max_endpoint = 2 * n;\n    vector<bool> used(max_endpoint + 1, false); // Index from 0 to 2n\n\n    for (int i = 0; i < n; i++) {\n        int a_i = inf.readInt(1, max_endpoint); // Read a_i in [1, 2n]\n        inf.readSpace();\n        int b_i = inf.readInt(1, max_endpoint); // Read b_i in [1, 2n]\n        inf.readEoln();\n\n        ensuref(a_i != b_i, \"Endpoint cannot be connected to itself at line %d\", i + 2);\n\n        ensuref(!used[a_i], \"Endpoint %d appears more than once\", a_i);\n        used[a_i] = true;\n\n        ensuref(!used[b_i], \"Endpoint %d appears more than once\", b_i);\n        used[b_i] = true;\n    }\n\n    for (int endpoint = 1; endpoint <= max_endpoint; endpoint++) {\n        ensuref(used[endpoint], \"Endpoint %d was not used\", endpoint);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000); // Read n in [3, 1e5]\n    inf.readEoln();\n\n    int max_endpoint = 2 * n;\n    vector<bool> used(max_endpoint + 1, false); // Index from 0 to 2n\n\n    for (int i = 0; i < n; i++) {\n        int a_i = inf.readInt(1, max_endpoint); // Read a_i in [1, 2n]\n        inf.readSpace();\n        int b_i = inf.readInt(1, max_endpoint); // Read b_i in [1, 2n]\n        inf.readEoln();\n\n        ensuref(a_i != b_i, \"Endpoint cannot be connected to itself at line %d\", i + 2);\n\n        ensuref(!used[a_i], \"Endpoint %d appears more than once\", a_i);\n        used[a_i] = true;\n\n        ensuref(!used[b_i], \"Endpoint %d appears more than once\", b_i);\n        used[b_i] = true;\n    }\n\n    for (int endpoint = 1; endpoint <= max_endpoint; endpoint++) {\n        ensuref(used[endpoint], \"Endpoint %d was not used\", endpoint);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000); // Read n in [3, 1e5]\n    inf.readEoln();\n\n    int max_endpoint = 2 * n;\n    vector<bool> used(max_endpoint + 1, false); // Index from 0 to 2n\n\n    for (int i = 0; i < n; i++) {\n        int a_i = inf.readInt(1, max_endpoint); // Read a_i in [1, 2n]\n        inf.readSpace();\n        int b_i = inf.readInt(1, max_endpoint); // Read b_i in [1, 2n]\n        inf.readEoln();\n\n        ensuref(a_i != b_i, \"Endpoint cannot be connected to itself at line %d\", i + 2);\n\n        ensuref(!used[a_i], \"Endpoint %d appears more than once\", a_i);\n        used[a_i] = true;\n\n        ensuref(!used[b_i], \"Endpoint %d appears more than once\", b_i);\n        used[b_i] = true;\n    }\n\n    for (int endpoint = 1; endpoint <= max_endpoint; endpoint++) {\n        ensuref(used[endpoint], \"Endpoint %d was not used\", endpoint);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> lines;\n    vector<int> endpoints(2 * n);\n    for(int i = 0; i < 2 * n; ++i)\n        endpoints[i] = i + 1;\n\n    if(type == \"adjacent\") {\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[2*i];\n            int b = endpoints[2*i+1];\n            lines.push_back({a, b});\n        }\n    } else if(type == \"nested\") {\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[i];\n            int b = endpoints[2*n - i -1];\n            lines.push_back({a, b});\n        }\n    } else if(type == \"opposite\") {\n        ensuref(n % 2 == 0, \"n must be even for opposite type\");\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[i];\n            int b = endpoints[(i + n) % (2 * n)];\n            lines.push_back({a, b});\n        }\n    } else if(type == \"maxcross\") {\n        ensuref(n % 2 == 0, \"n must be even for maxcross type\");\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[i];\n            int b = endpoints[(i + n / 2) % (2 * n)];\n            lines.push_back({a, b});\n        }\n    } else if(type == \"random\") {\n        shuffle(endpoints.begin(), endpoints.end());\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[2 * i];\n            int b = endpoints[2 * i + 1];\n            lines.push_back({a, b});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Shuffle lines\n    shuffle(lines.begin(), lines.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output lines\n    for(auto p : lines) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> lines;\n    vector<int> endpoints(2 * n);\n    for(int i = 0; i < 2 * n; ++i)\n        endpoints[i] = i + 1;\n\n    if(type == \"adjacent\") {\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[2*i];\n            int b = endpoints[2*i+1];\n            lines.push_back({a, b});\n        }\n    } else if(type == \"nested\") {\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[i];\n            int b = endpoints[2*n - i -1];\n            lines.push_back({a, b});\n        }\n    } else if(type == \"opposite\") {\n        ensuref(n % 2 == 0, \"n must be even for opposite type\");\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[i];\n            int b = endpoints[(i + n) % (2 * n)];\n            lines.push_back({a, b});\n        }\n    } else if(type == \"maxcross\") {\n        ensuref(n % 2 == 0, \"n must be even for maxcross type\");\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[i];\n            int b = endpoints[(i + n / 2) % (2 * n)];\n            lines.push_back({a, b});\n        }\n    } else if(type == \"random\") {\n        shuffle(endpoints.begin(), endpoints.end());\n        for(int i = 0; i < n; ++i) {\n            int a = endpoints[2 * i];\n            int b = endpoints[2 * i + 1];\n            lines.push_back({a, b});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Shuffle lines\n    shuffle(lines.begin(), lines.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output lines\n    for(auto p : lines) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type adjacent\n./gen -n 3 -type nested\n./gen -n 3 -type random\n\n./gen -n 5 -type adjacent\n./gen -n 5 -type nested\n./gen -n 5 -type random\n\n./gen -n 10 -type adjacent\n./gen -n 10 -type nested\n./gen -n 10 -type random\n./gen -n 10 -type opposite\n./gen -n 10 -type maxcross\n\n./gen -n 100 -type adjacent\n./gen -n 100 -type nested\n./gen -n 100 -type random\n./gen -n 100 -type opposite\n./gen -n 100 -type maxcross\n\n./gen -n 1000 -type adjacent\n./gen -n 1000 -type nested\n./gen -n 1000 -type random\n./gen -n 1000 -type opposite\n./gen -n 1000 -type maxcross\n\n./gen -n 10000 -type adjacent\n./gen -n 10000 -type nested\n./gen -n 10000 -type random\n./gen -n 10000 -type opposite\n./gen -n 10000 -type maxcross\n\n./gen -n 50000 -type adjacent\n./gen -n 50000 -type nested\n./gen -n 50000 -type random\n./gen -n 50000 -type opposite\n./gen -n 50000 -type maxcross\n\n./gen -n 99999 -type adjacent\n./gen -n 99999 -type nested\n./gen -n 99999 -type random\n\n./gen -n 100000 -type adjacent\n./gen -n 100000 -type nested\n./gen -n 100000 -type random\n./gen -n 100000 -type opposite\n./gen -n 100000 -type maxcross\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:14.371675",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "298/A",
      "title": "A. Snow Footprints",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (3 ≤ n ≤ 1000).The second line contains the description of the road — the string that consists of n characters. Each character will be either \".\" (a block without footprint), or \"L\" (a block with a left footprint), \"R\" (a block with a right footprint).It's guaranteed that the given string contains at least one character not equal to \".\". Also, the first and the last character will always be \".\". It's guaranteed that a solution exists.",
      "output_spec": "OutputPrint two space-separated integers — the values of s and t. If there are several possible solutions you can print any of them.",
      "sample_tests": "ExamplesInputCopy9..RRLL...OutputCopy3 4InputCopy11.RRRLLLLL..OutputCopy7 5",
      "description": "A. Snow Footprints\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (3 ≤ n ≤ 1000).The second line contains the description of the road — the string that consists of n characters. Each character will be either \".\" (a block without footprint), or \"L\" (a block with a left footprint), \"R\" (a block with a right footprint).It's guaranteed that the given string contains at least one character not equal to \".\". Also, the first and the last character will always be \".\". It's guaranteed that a solution exists.\n\nOutputPrint two space-separated integers — the values of s and t. If there are several possible solutions you can print any of them.\n\nInputCopy9..RRLL...OutputCopy3 4InputCopy11.RRRLLLLL..OutputCopy7 5\n\nInputCopy9..RRLL...\n\nOutputCopy3 4\n\nInputCopy11.RRRLLLLL..\n\nOutputCopy7 5\n\nNoteThe first test sample is the one in the picture.",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 298\\s*A"
          },
          "content_length": 4179
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of the string must be n\");\n    ensuref(s[0] == '.', \"The first character must be '.'\");\n    ensuref(s[n - 1] == '.', \"The last character must be '.'\");\n    bool has_non_dot = false;\n    for (int i = 0; i < n; i++) {\n        ensuref(s[i] == '.' || s[i] == 'L' || s[i] == 'R', \"Invalid character at position %d\", i + 1);\n        if (s[i] != '.')\n            has_non_dot = true;\n    }\n    ensuref(has_non_dot, \"The string must contain at least one character not equal to '.'\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of the string must be n\");\n    ensuref(s[0] == '.', \"The first character must be '.'\");\n    ensuref(s[n - 1] == '.', \"The last character must be '.'\");\n    bool has_non_dot = false;\n    for (int i = 0; i < n; i++) {\n        ensuref(s[i] == '.' || s[i] == 'L' || s[i] == 'R', \"Invalid character at position %d\", i + 1);\n        if (s[i] != '.')\n            has_non_dot = true;\n    }\n    ensuref(has_non_dot, \"The string must contain at least one character not equal to '.'\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of the string must be n\");\n    ensuref(s[0] == '.', \"The first character must be '.'\");\n    ensuref(s[n - 1] == '.', \"The last character must be '.'\");\n    bool has_non_dot = false;\n    for (int i = 0; i < n; i++) {\n        ensuref(s[i] == '.' || s[i] == 'L' || s[i] == 'R', \"Invalid character at position %d\", i + 1);\n        if (s[i] != '.')\n            has_non_dot = true;\n    }\n    ensuref(has_non_dot, \"The string must contain at least one character not equal to '.'\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring footprints;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read n and footprints from the input file\n    n = inf.readInt();\n    inf.readEoln();\n    footprints = inf.readString();\n    if ((int)footprints.length() != n) {\n        quitf(_fail, \"Invalid footprints length: expected %d, found %d\", n, (int)footprints.length());\n    }\n    \n    // Read s and t from the participant's output\n    int s = ouf.readInt(1, n, \"s\");\n    int t = ouf.readInt(1, n, \"t\");\n    \n    // Build the graph according to the footprints\n    vector<vector<int>> adj(n + 1); // Nodes are from 1 to n\n    for (int i = 1; i <= n; i++) {\n        if (footprints[i - 1] == 'R' && i + 1 <= n)\n            adj[i].push_back(i + 1); // Edge from i to i+1\n        if (footprints[i - 1] == 'L' && i - 1 >= 1)\n            adj[i].push_back(i - 1); // Edge from i to i-1\n    }\n    \n    // Perform BFS from s to check if t is reachable\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        if (u == t) {\n            quitf(_ok, \"Valid s and t: s = %d, t = %d\", s, t);\n        }\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    quitf(_wa, \"No valid path from s = %d to t = %d following the footprints\", s, t);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 3 || n > 1000) {\n        cerr << \"n must be between 3 and 1000\\n\";\n        return 1;\n    }\n\n    vector<char> footprints(n, '.');\n\n    int s, t;\n    vector<int> positions;\n\n    if (type == \"random\") {\n        /* Random path from s to t */\n        s = rnd.next(1, n);\n        t = rnd.next(1, n);\n        int steps = rnd.next(1, 3 * n);\n\n        positions.push_back(s);\n        int pos = s;\n\n        for (int i = 0; i < steps; ++i) {\n            int dir = rnd.next(0, 1); // 0 for left, 1 for right\n            if (pos == 1) dir = 1;    // can't move left\n            if (pos == n) dir = 0;    // can't move right\n            if (dir == 0) pos--;\n            else pos++;\n            positions.push_back(pos);\n        }\n\n        t = pos; // End position\n\n    } else if (type == \"maxL\") {\n        /* Path that produces maximum 'L' footprints */\n        s = n;\n        t = 1;\n\n        positions.push_back(s);\n        int pos = s;\n        while (pos > t) {\n            int v = pos - 1;\n            positions.push_back(v);\n            pos = v;\n        }\n\n    } else if (type == \"maxR\") {\n        /* Path that produces maximum 'R' footprints */\n        s = 1;\n        t = n;\n\n        positions.push_back(s);\n        int pos = s;\n        while (pos < t) {\n            int v = pos + 1;\n            positions.push_back(v);\n            pos = v;\n        }\n\n    } else if (type == \"single_move\") {\n        /* Path with a single move */\n        s = rnd.next(2, n - 1);\n        if (rnd.next(0, 1)) {\n            t = s + 1;\n        } else {\n            t = s - 1;\n        }\n\n        positions.push_back(s);\n        positions.push_back(t);\n\n    } else if (type == \"overlap\") {\n        /* Path where footprints are overwritten multiple times */\n        s = rnd.next(1, n);\n        int moves = rnd.next(n, 3 * n);\n\n        positions.push_back(s);\n        int pos = s;\n\n        for (int i = 0; i < moves; ++i) {\n            int dir = rnd.next(0, 1); // 0 for left, 1 for right\n            if (pos == 1) dir = 1;    // can't move left\n            if (pos == n) dir = 0;    // can't move right\n            if (dir == 0) pos--;\n            else pos++;\n            positions.push_back(pos);\n        }\n\n        t = pos; // End position\n\n    } else if (type == \"s_eq_t\") {\n        /* s equals t, with at least one move */\n        s = rnd.next(1, n);\n        t = s;\n\n        positions.push_back(s);\n\n        int dir;\n        if (s == 1) dir = 1;\n        else if (s == n) dir = 0;\n        else dir = rnd.next(0, 1);\n\n        int pos = s;\n        if (dir == 0) {\n            pos--;\n            positions.push_back(pos);\n        } else {\n            pos++;\n            positions.push_back(pos);\n        }\n\n        positions.push_back(s);\n\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    /* Compute footprints based on the path */\n    for (int i = 0; i < (int)positions.size() - 1; ++i) {\n        int u = positions[i];\n        int v = positions[i + 1];\n        if (v == u + 1) {\n            /* Moved right, leave 'R' at position u */\n            footprints[u - 1] = 'R';\n        } else if (v == u - 1) {\n            /* Moved left, leave 'L' at position u */\n            footprints[u - 1] = 'L';\n        } else {\n            cerr << \"Invalid move from \" << u << \" to \" << v << endl;\n            return 1;\n        }\n    }\n\n    /* Ensure the first and last characters are '.' */\n    footprints[0] = '.';\n    footprints[n - 1] = '.';\n\n    /* Ensure at least one footprint is present */\n    bool has_footprint = false;\n    for (int i = 0; i < n; ++i) {\n        if (footprints[i] != '.') {\n            has_footprint = true;\n            break;\n        }\n    }\n\n    if (!has_footprint) {\n        int idx = rnd.next(1, n - 2);\n        footprints[idx] = 'R';\n    }\n\n    /* Output n and the footprints string */\n    printf(\"%d\\n\", n);\n    for (char c : footprints) {\n        printf(\"%c\", c);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 3 || n > 1000) {\n        cerr << \"n must be between 3 and 1000\\n\";\n        return 1;\n    }\n\n    vector<char> footprints(n, '.');\n\n    int s, t;\n    vector<int> positions;\n\n    if (type == \"random\") {\n        /* Random path from s to t */\n        s = rnd.next(1, n);\n        t = rnd.next(1, n);\n        int steps = rnd.next(1, 3 * n);\n\n        positions.push_back(s);\n        int pos = s;\n\n        for (int i = 0; i < steps; ++i) {\n            int dir = rnd.next(0, 1); // 0 for left, 1 for right\n            if (pos == 1) dir = 1;    // can't move left\n            if (pos == n) dir = 0;    // can't move right\n            if (dir == 0) pos--;\n            else pos++;\n            positions.push_back(pos);\n        }\n\n        t = pos; // End position\n\n    } else if (type == \"maxL\") {\n        /* Path that produces maximum 'L' footprints */\n        s = n;\n        t = 1;\n\n        positions.push_back(s);\n        int pos = s;\n        while (pos > t) {\n            int v = pos - 1;\n            positions.push_back(v);\n            pos = v;\n        }\n\n    } else if (type == \"maxR\") {\n        /* Path that produces maximum 'R' footprints */\n        s = 1;\n        t = n;\n\n        positions.push_back(s);\n        int pos = s;\n        while (pos < t) {\n            int v = pos + 1;\n            positions.push_back(v);\n            pos = v;\n        }\n\n    } else if (type == \"single_move\") {\n        /* Path with a single move */\n        s = rnd.next(2, n - 1);\n        if (rnd.next(0, 1)) {\n            t = s + 1;\n        } else {\n            t = s - 1;\n        }\n\n        positions.push_back(s);\n        positions.push_back(t);\n\n    } else if (type == \"overlap\") {\n        /* Path where footprints are overwritten multiple times */\n        s = rnd.next(1, n);\n        int moves = rnd.next(n, 3 * n);\n\n        positions.push_back(s);\n        int pos = s;\n\n        for (int i = 0; i < moves; ++i) {\n            int dir = rnd.next(0, 1); // 0 for left, 1 for right\n            if (pos == 1) dir = 1;    // can't move left\n            if (pos == n) dir = 0;    // can't move right\n            if (dir == 0) pos--;\n            else pos++;\n            positions.push_back(pos);\n        }\n\n        t = pos; // End position\n\n    } else if (type == \"s_eq_t\") {\n        /* s equals t, with at least one move */\n        s = rnd.next(1, n);\n        t = s;\n\n        positions.push_back(s);\n\n        int dir;\n        if (s == 1) dir = 1;\n        else if (s == n) dir = 0;\n        else dir = rnd.next(0, 1);\n\n        int pos = s;\n        if (dir == 0) {\n            pos--;\n            positions.push_back(pos);\n        } else {\n            pos++;\n            positions.push_back(pos);\n        }\n\n        positions.push_back(s);\n\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    /* Compute footprints based on the path */\n    for (int i = 0; i < (int)positions.size() - 1; ++i) {\n        int u = positions[i];\n        int v = positions[i + 1];\n        if (v == u + 1) {\n            /* Moved right, leave 'R' at position u */\n            footprints[u - 1] = 'R';\n        } else if (v == u - 1) {\n            /* Moved left, leave 'L' at position u */\n            footprints[u - 1] = 'L';\n        } else {\n            cerr << \"Invalid move from \" << u << \" to \" << v << endl;\n            return 1;\n        }\n    }\n\n    /* Ensure the first and last characters are '.' */\n    footprints[0] = '.';\n    footprints[n - 1] = '.';\n\n    /* Ensure at least one footprint is present */\n    bool has_footprint = false;\n    for (int i = 0; i < n; ++i) {\n        if (footprints[i] != '.') {\n            has_footprint = true;\n            break;\n        }\n    }\n\n    if (!has_footprint) {\n        int idx = rnd.next(1, n - 2);\n        footprints[idx] = 'R';\n    }\n\n    /* Output n and the footprints string */\n    printf(\"%d\\n\", n);\n    for (char c : footprints) {\n        printf(\"%c\", c);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type single_move\n./gen -n 3 -type maxL\n./gen -n 3 -type maxR\n./gen -n 3 -type overlap\n./gen -n 3 -type s_eq_t\n\n./gen -n 4 -type random\n./gen -n 4 -type single_move\n./gen -n 4 -type s_eq_t\n\n./gen -n 10 -type random\n./gen -n 10 -type single_move\n./gen -n 10 -type maxL\n./gen -n 10 -type maxR\n./gen -n 10 -type overlap\n./gen -n 10 -type s_eq_t\n\n./gen -n 100 -type random\n./gen -n 100 -type single_move\n./gen -n 100 -type maxL\n./gen -n 100 -type maxR\n./gen -n 100 -type overlap\n./gen -n 100 -type s_eq_t\n\n./gen -n 500 -type random\n./gen -n 500 -type single_move\n./gen -n 500 -type overlap\n\n./gen -n 999 -type random\n./gen -n 999 -type maxL\n./gen -n 999 -type maxR\n\n./gen -n 1000 -type random\n./gen -n 1000 -type single_move\n./gen -n 1000 -type maxL\n./gen -n 1000 -type maxR\n./gen -n 1000 -type overlap\n./gen -n 1000 -type s_eq_t\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:16.568375",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}