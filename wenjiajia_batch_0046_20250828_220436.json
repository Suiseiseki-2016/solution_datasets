{
  "metadata": {
    "batch_number": 46,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.616717",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "475/A",
      "title": "A. Bayan автобус",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано целое число k, (0 ≤ k ≤ 34) — количество участников.",
      "output_spec": "Выходные данныеВыведите фигуру автобуса с k пассажирами, следуя формату тестов из условия. Символ '#' обозначает пустое место, а 'O' обозначает место с пассажиром. 'D' — водитель автобуса. Остальные символы в выводе имеют чисто декоративное назначение. Строго придерживайтесь формата тестов из условия. Выведите ровно шесть строк. Не выводите лишних пробелов или иных символов.",
      "sample_tests": "ПримерыВходные данныеСкопировать9Выходные данныеСкопировать+------------------------+|O.O.O.#.#.#.#.#.#.#.#.|D|)|O.O.O.#.#.#.#.#.#.#.#.|.||O.......................||O.O.#.#.#.#.#.#.#.#.#.|.|)+------------------------+Входные данныеСкопировать20Выходные данныеСкопировать+------------------------+|O.O.O.O.O.O.O.#.#.#.#.|D|)|O.O.O.O.O.O.#.#.#.#.#.|.||O.......................||O.O.O.O.O.O.#.#.#.#.#.|.|)+------------------------+",
      "description": "A. Bayan автобус\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано целое число k, (0 ≤ k ≤ 34) — количество участников.\n\nВходные данные\n\nВыходные данныеВыведите фигуру автобуса с k пассажирами, следуя формату тестов из условия. Символ '#' обозначает пустое место, а 'O' обозначает место с пассажиром. 'D' — водитель автобуса. Остальные символы в выводе имеют чисто декоративное назначение. Строго придерживайтесь формата тестов из условия. Выведите ровно шесть строк. Не выводите лишних пробелов или иных символов.\n\nВыходные данные\n\nВходные данныеСкопировать9Выходные данныеСкопировать+------------------------+|O.O.O.#.#.#.#.#.#.#.#.|D|)|O.O.O.#.#.#.#.#.#.#.#.|.||O.......................||O.O.#.#.#.#.#.#.#.#.#.|.|)+------------------------+Входные данныеСкопировать20Выходные данныеСкопировать+------------------------+|O.O.O.O.O.O.O.#.#.#.#.|D|)|O.O.O.O.O.O.#.#.#.#.#.|.||O.......................||O.O.O.O.O.O.#.#.#.#.#.|.|)+------------------------+\n\nВходные данныеСкопировать9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать+------------------------+|O.O.O.#.#.#.#.#.#.#.#.|D|)|O.O.O.#.#.#.#.#.#.#.#.|.||O.......................||O.O.#.#.#.#.#.#.#.#.#.|.|)+------------------------+\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать20\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать+------------------------+|O.O.O.O.O.O.O.#.#.#.#.|D|)|O.O.O.O.O.O.#.#.#.#.#.|.||O.......................||O.O.O.O.O.O.#.#.#.#.#.|.|)+------------------------+\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces",
          "content": "Bayan warm-up round will be held on Sunday, October 5th 2014, 13:00 (UTC) and as indicated before, it will be held on Codeforces. Warm-up round is not a required round but top 50 are going to win t-shirts and it is going to be rated for both divisions. Problems have been prepared by mruxim, mR.ilchi, havaliza . We have tried our best to make the problem-set interesting and competitive and we hope you enjoy it. It is necessary to have a complete profile on contest.bayan.ir before the warm-up round! And please do make sure you have selected the correct t-shirt size! We have upgraded our contest platform, and we've made sure everything is stable, tuned and robust now. Thanks to all those who helped us test the unstable version! The unofficial Shortcut! Round is now accessible to all, so you can check the standings and the problems. Qualification round which is the first official and required round of Bayan Programming Contest 2014-2015 will begin on October 9th so don’t forget to register right now at contest.bayan.ir if you haven’t already. We've created a twitter account to publish Bayan Programming Contest news. Now you can follow us @bayan. Update 1: The scoring will be: 500 – 1000 – 1500 – 2000 – 2500 – 2500Update 2: Warm up round is finished now. We have decided to randomly give 5 extra tshirts to 5 contestants ranked between 51 and 550. And as mentioned before, we are going to have 5 random tshirt winners in our Qualification round too. Update 3: Congratulations to top 50, specially: fotiIe96 hogloid sankear flashmt TankEngineer Update 4: Here are 5 lucky randomly selectes tshirt winners for this round: Dongmin zxqfl shimomire arthur.nascimento SlavaSSU Update 5: marat.snowbear has published a good editorial for this round.",
          "author": "BYN",
          "url": "https://codeforces.com/blog/entry/14077",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1757
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "Случайно нажал \"Сохранить\" в русскоязычной версии сайта, теперь вы видите тут разбор на английском под российским флагом. Если кто знает, как удалить только русскую версию этой записи, напишите мне в личку, пожалуйста :-) 475A - Bayan автобусAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Сильно связный городFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Картина Камаль оль-МолькаThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Сильно связный город 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - МультивселеннаяLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*A"
          },
          "content_length": 17570
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "Случайно нажал \"Сохранить\" в русскоязычной версии сайта, теперь вы видите тут разбор на английском под российским флагом. Если кто знает, как удалить только русскую версию этой записи, напишите мне в личку, пожалуйста :-) 475A - Bayan автобусAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Сильно связный городFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Картина Камаль оль-МолькаThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Сильно связный город 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - МультивселеннаяLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*A"
          },
          "content_length": 17570
        }
      ],
      "code_examples": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 1",
          "code": "int rem = full_sum - x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 2",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 3",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 34, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 34, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 34, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"fixed\");\n\n    if (type == \"min\") {\n        k = 0;\n    } else if (type == \"max\") {\n        k = 34;\n    } else if (type == \"mid\") {\n        k = 17;\n    } else if (type == \"random\") {\n        k = rnd.next(0, 34);\n    } else if (type == \"fixed\") {\n        if (k == -1) {\n            fprintf(stderr, \"Error: k must be specified when type is fixed\\n\");\n            return 1;\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    if (k < 0 || k > 34) {\n        fprintf(stderr, \"Error: k must be between 0 and 34 inclusive\\n\");\n        return 1;\n    }\n\n    printf(\"%d\\n\", k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"fixed\");\n\n    if (type == \"min\") {\n        k = 0;\n    } else if (type == \"max\") {\n        k = 34;\n    } else if (type == \"mid\") {\n        k = 17;\n    } else if (type == \"random\") {\n        k = rnd.next(0, 34);\n    } else if (type == \"fixed\") {\n        if (k == -1) {\n            fprintf(stderr, \"Error: k must be specified when type is fixed\\n\");\n            return 1;\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    if (k < 0 || k > 34) {\n        fprintf(stderr, \"Error: k must be between 0 and 34 inclusive\\n\");\n        return 1;\n    }\n\n    printf(\"%d\\n\", k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type mid\n\n./gen -type fixed -k 0\n./gen -type fixed -k 1\n./gen -type fixed -k 2\n./gen -type fixed -k 3\n./gen -type fixed -k 4\n./gen -type fixed -k 5\n./gen -type fixed -k 6\n./gen -type fixed -k 7\n./gen -type fixed -k 10\n./gen -type fixed -k 13\n./gen -type fixed -k 16\n./gen -type fixed -k 19\n./gen -type fixed -k 22\n./gen -type fixed -k 25\n./gen -type fixed -k 28\n./gen -type fixed -k 31\n./gen -type fixed -k 33\n./gen -type fixed -k 34\n\n./gen -type fixed -k 3\n./gen -type fixed -k 5\n./gen -type fixed -k 6\n./gen -type fixed -k 8\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:11.732264",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "475/B",
      "title": "B. Сильно связный город",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n, m, (2 ≤ n, m ≤ 20), обозначающие соответственно количество горизонтальных и вертикальных улиц.Во второй строке записана строка длины n из символов '<' и '>' — направления горизонтальных улиц. Если очередной символ этой строки равняется '<', то соответствующая улица направлена с востока на запад, в противном случае улица направлена с запада на восток. Улицы приводятся в порядке с севера на юг.В третьей строке записана строка длины m из символов '^' и 'v' — направления вертикальных улиц. Если очередной символ равняется '^', то улица направлена с юга на север, в противном случае улица направлена с севера на юг. Улицы приводятся в порядке с запада на восток.",
      "output_spec": "Выходные данныеЕсли указанная схема удовлетворяет требованиям, выведите в единственной строке \"YES\", в противном случае выведите в единственной строке \"NO\".",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3><>v^vВыходные данныеСкопироватьNOВходные данныеСкопировать4 6<><>v^v^v^Выходные данныеСкопироватьYES",
      "description": "B. Сильно связный город\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n, m, (2 ≤ n, m ≤ 20), обозначающие соответственно количество горизонтальных и вертикальных улиц.Во второй строке записана строка длины n из символов '<' и '>' — направления горизонтальных улиц. Если очередной символ этой строки равняется '<', то соответствующая улица направлена с востока на запад, в противном случае улица направлена с запада на восток. Улицы приводятся в порядке с севера на юг.В третьей строке записана строка длины m из символов '^' и 'v' — направления вертикальных улиц. Если очередной символ равняется '^', то улица направлена с юга на север, в противном случае улица направлена с севера на юг. Улицы приводятся в порядке с запада на восток.\n\nВходные данные\n\nВыходные данныеЕсли указанная схема удовлетворяет требованиям, выведите в единственной строке \"YES\", в противном случае выведите в единственной строке \"NO\".\n\nВыходные данные\n\nВходные данныеСкопировать3 3><>v^vВыходные данныеСкопироватьNOВходные данныеСкопировать4 6<><>v^v^v^Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать3 3><>v^v\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 6<><>v^v^v^\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРисунок в условии соответствует второму примеру.",
      "solutions": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces",
          "content": "Bayan warm-up round will be held on Sunday, October 5th 2014, 13:00 (UTC) and as indicated before, it will be held on Codeforces. Warm-up round is not a required round but top 50 are going to win t-shirts and it is going to be rated for both divisions. Problems have been prepared by mruxim, mR.ilchi, havaliza . We have tried our best to make the problem-set interesting and competitive and we hope you enjoy it. It is necessary to have a complete profile on contest.bayan.ir before the warm-up round! And please do make sure you have selected the correct t-shirt size! We have upgraded our contest platform, and we've made sure everything is stable, tuned and robust now. Thanks to all those who helped us test the unstable version! The unofficial Shortcut! Round is now accessible to all, so you can check the standings and the problems. Qualification round which is the first official and required round of Bayan Programming Contest 2014-2015 will begin on October 9th so don’t forget to register right now at contest.bayan.ir if you haven’t already. We've created a twitter account to publish Bayan Programming Contest news. Now you can follow us @bayan. Update 1: The scoring will be: 500 – 1000 – 1500 – 2000 – 2500 – 2500Update 2: Warm up round is finished now. We have decided to randomly give 5 extra tshirts to 5 contestants ranked between 51 and 550. And as mentioned before, we are going to have 5 random tshirt winners in our Qualification round too. Update 3: Congratulations to top 50, specially: fotiIe96 hogloid sankear flashmt TankEngineer Update 4: Here are 5 lucky randomly selectes tshirt winners for this round: Dongmin zxqfl shimomire arthur.nascimento SlavaSSU Update 5: marat.snowbear has published a good editorial for this round.",
          "author": "BYN",
          "url": "https://codeforces.com/blog/entry/14077",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1757
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "Случайно нажал \"Сохранить\" в русскоязычной версии сайта, теперь вы видите тут разбор на английском под российским флагом. Если кто знает, как удалить только русскую версию этой записи, напишите мне в личку, пожалуйста :-) 475A - Bayan автобусAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Сильно связный городFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Картина Камаль оль-МолькаThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Сильно связный город 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - МультивселеннаяLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*B"
          },
          "content_length": 17570
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "Случайно нажал \"Сохранить\" в русскоязычной версии сайта, теперь вы видите тут разбор на английском под российским флагом. Если кто знает, как удалить только русскую версию этой записи, напишите мне в личку, пожалуйста :-) 475A - Bayan автобусAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Сильно связный городFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Картина Камаль оль-МолькаThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Сильно связный город 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - МультивселеннаяLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*B"
          },
          "content_length": 17570
        }
      ],
      "code_examples": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 1",
          "code": "int rem = full_sum - x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 2",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 3",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readEoln();\n\n    string pattern_n = \"^[<>]{\" + to_string(n) + \"}$\";\n    string horizontal_directions = inf.readLine(pattern_n, \"horizontal_directions\");\n\n    string pattern_m = \"^[v^]{\" + to_string(m) + \"}$\";\n    string vertical_directions = inf.readLine(pattern_m, \"vertical_directions\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readEoln();\n\n    string pattern_n = \"^[<>]{\" + to_string(n) + \"}$\";\n    string horizontal_directions = inf.readLine(pattern_n, \"horizontal_directions\");\n\n    string pattern_m = \"^[v^]{\" + to_string(m) + \"}$\";\n    string vertical_directions = inf.readLine(pattern_m, \"vertical_directions\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readEoln();\n\n    string pattern_n = \"^[<>]{\" + to_string(n) + \"}$\";\n    string horizontal_directions = inf.readLine(pattern_n, \"horizontal_directions\");\n\n    string pattern_m = \"^[v^]{\" + to_string(m) + \"}$\";\n    string vertical_directions = inf.readLine(pattern_m, \"vertical_directions\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Ensure n and m are within limits\n    n = max(2, min(n, 20));\n    m = max(2, min(m, 20));\n    \n    string hor_dirs; // horizontal directions\n    string ver_dirs; // vertical directions\n\n    if (type == \"all_right_down\") {\n        // Horizontal streets: '>' (west to east)\n        hor_dirs = string(n, '>');\n        // Vertical streets: 'v' (north to south)\n        ver_dirs = string(m, 'v');\n    } else if (type == \"all_left_up\") {\n        // Horizontal streets: '<' (east to west)\n        hor_dirs = string(n, '<');\n        // Vertical streets: '^' (south to north)\n        ver_dirs = string(m, '^');\n    } else if (type == \"alternating\") {\n        // Horizontal streets alternate between '>' and '<'\n        hor_dirs = \"\";\n        for (int i = 0; i < n; ++i)\n            hor_dirs += (i % 2 == 0) ? '>' : '<';\n        // Vertical streets alternate between 'v' and '^'\n        ver_dirs = \"\";\n        for (int i = 0; i < m; ++i)\n            ver_dirs += (i % 2 == 0) ? 'v' : '^';\n    } else if (type == \"half_right\") {\n        // Half of horizontal streets are '>' and half are '<'\n        hor_dirs = \"\";\n        for (int i = 0; i < n; ++i)\n            hor_dirs += (i < n/2) ? '>' : '<';\n        // Same for vertical streets\n        ver_dirs = \"\";\n        for (int i = 0; i < m; ++i)\n            ver_dirs += (i < m/2) ? 'v' : '^';\n    } else if (type == \"random_yes\") {\n        // Generate directions that likely result in YES\n        // For simplicity, set all horizontal streets to '>' and vertical streets to 'v'\n        hor_dirs = string(n, '>');\n        ver_dirs = string(m, 'v');        \n    } else if (type == \"random_no\") {\n        // Generate directions that likely result in NO\n        // For simplicity, set all horizontal streets to '>' and vertical streets to '^'\n        hor_dirs = string(n, '>');\n        ver_dirs = string(m, '^');        \n    } else { // \"random\" and default\n        // Randomly generate directions\n        hor_dirs = \"\";\n        for (int i = 0; i < n; ++i)\n            hor_dirs += rnd.next(0, 1) ? '>' : '<';\n        ver_dirs = \"\";\n        for (int i = 0; i < m; ++i)\n            ver_dirs += rnd.next(0, 1) ? 'v' : '^';\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << endl;\n    // Output horizontal directions\n    cout << hor_dirs << endl;\n    // Output vertical directions\n    cout << ver_dirs << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Ensure n and m are within limits\n    n = max(2, min(n, 20));\n    m = max(2, min(m, 20));\n    \n    string hor_dirs; // horizontal directions\n    string ver_dirs; // vertical directions\n\n    if (type == \"all_right_down\") {\n        // Horizontal streets: '>' (west to east)\n        hor_dirs = string(n, '>');\n        // Vertical streets: 'v' (north to south)\n        ver_dirs = string(m, 'v');\n    } else if (type == \"all_left_up\") {\n        // Horizontal streets: '<' (east to west)\n        hor_dirs = string(n, '<');\n        // Vertical streets: '^' (south to north)\n        ver_dirs = string(m, '^');\n    } else if (type == \"alternating\") {\n        // Horizontal streets alternate between '>' and '<'\n        hor_dirs = \"\";\n        for (int i = 0; i < n; ++i)\n            hor_dirs += (i % 2 == 0) ? '>' : '<';\n        // Vertical streets alternate between 'v' and '^'\n        ver_dirs = \"\";\n        for (int i = 0; i < m; ++i)\n            ver_dirs += (i % 2 == 0) ? 'v' : '^';\n    } else if (type == \"half_right\") {\n        // Half of horizontal streets are '>' and half are '<'\n        hor_dirs = \"\";\n        for (int i = 0; i < n; ++i)\n            hor_dirs += (i < n/2) ? '>' : '<';\n        // Same for vertical streets\n        ver_dirs = \"\";\n        for (int i = 0; i < m; ++i)\n            ver_dirs += (i < m/2) ? 'v' : '^';\n    } else if (type == \"random_yes\") {\n        // Generate directions that likely result in YES\n        // For simplicity, set all horizontal streets to '>' and vertical streets to 'v'\n        hor_dirs = string(n, '>');\n        ver_dirs = string(m, 'v');        \n    } else if (type == \"random_no\") {\n        // Generate directions that likely result in NO\n        // For simplicity, set all horizontal streets to '>' and vertical streets to '^'\n        hor_dirs = string(n, '>');\n        ver_dirs = string(m, '^');        \n    } else { // \"random\" and default\n        // Randomly generate directions\n        hor_dirs = \"\";\n        for (int i = 0; i < n; ++i)\n            hor_dirs += rnd.next(0, 1) ? '>' : '<';\n        ver_dirs = \"\";\n        for (int i = 0; i < m; ++i)\n            ver_dirs += rnd.next(0, 1) ? 'v' : '^';\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << endl;\n    // Output horizontal directions\n    cout << hor_dirs << endl;\n    // Output vertical directions\n    cout << ver_dirs << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type all_right_down\n./gen -n 2 -m 2 -type all_left_up\n./gen -n 2 -m 2 -type alternating\n./gen -n 2 -m 2 -type random_yes\n./gen -n 2 -m 2 -type random_no\n\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type all_right_down\n./gen -n 5 -m 5 -type all_left_up\n./gen -n 5 -m 5 -type alternating\n./gen -n 5 -m 5 -type random_yes\n./gen -n 5 -m 5 -type random_no\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type half_right\n./gen -n 10 -m 10 -type random_yes\n./gen -n 10 -m 10 -type random_no\n\n./gen -n 15 -m 15 -type random\n./gen -n 15 -m 15 -type all_right_down\n./gen -n 15 -m 15 -type all_left_up\n./gen -n 15 -m 15 -type alternating\n\n./gen -n 20 -m 20 -type random\n./gen -n 20 -m 20 -type all_right_down\n./gen -n 20 -m 20 -type all_left_up\n./gen -n 20 -m 20 -type alternating\n./gen -n 20 -m 20 -type random_yes\n./gen -n 20 -m 20 -type random_no\n\n./gen -n 10 -m 15 -type random\n./gen -n 10 -m 15 -type all_right_down\n./gen -n 10 -m 15 -type all_left_up\n./gen -n 10 -m 15 -type alternating\n\n./gen -n 15 -m 5 -type random\n./gen -n 15 -m 5 -type random_yes\n./gen -n 15 -m 5 -type random_no\n./gen -n 15 -m 5 -type alternating\n\n./gen -n 3 -m 20 -type random_no\n./gen -n 20 -m 3 -type random_yes\n./gen -n 2 -m 20 -type random\n./gen -n 20 -m 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:13.854428",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "475/C",
      "title": "C. Kamal-ol-molk's Painting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and m, (1 ≤ n, m ≤ 1000), denoting the height and width of the painting.The next n lines contain the painting. Each line has m characters. Character 'X' denotes an altered cell, otherwise it's showed by '.'. There will be at least one altered cell in the painting.",
      "output_spec": "OutputPrint the minimum area of the brush in a line, if the painting is possibly altered, otherwise print  - 1.",
      "sample_tests": "ExamplesInputCopy4 4XX..XX..XXXXXXXXOutputCopy4InputCopy4 4.....XXX.XXX....OutputCopy2InputCopy4 5XXXX.XXXX..XX...XX..OutputCopy-1",
      "description": "C. Kamal-ol-molk's Painting\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two integers n and m, (1 ≤ n, m ≤ 1000), denoting the height and width of the painting.The next n lines contain the painting. Each line has m characters. Character 'X' denotes an altered cell, otherwise it's showed by '.'. There will be at least one altered cell in the painting.\n\nOutputPrint the minimum area of the brush in a line, if the painting is possibly altered, otherwise print  - 1.\n\nInputCopy4 4XX..XX..XXXXXXXXOutputCopy4InputCopy4 4.....XXX.XXX....OutputCopy2InputCopy4 5XXXX.XXXX..XX...XX..OutputCopy-1\n\nInputCopy4 4XX..XX..XXXXXXXX\n\nOutputCopy4\n\nInputCopy4 4.....XXX.XXX....\n\nOutputCopy2\n\nInputCopy4 5XXXX.XXXX..XX...XX..\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces",
          "content": "Bayan warm-up round will be held on Sunday, October 5th 2014, 13:00 (UTC) and as indicated before, it will be held on Codeforces. Warm-up round is not a required round but top 50 are going to win t-shirts and it is going to be rated for both divisions. Problems have been prepared by mruxim, mR.ilchi, havaliza . We have tried our best to make the problem-set interesting and competitive and we hope you enjoy it. It is necessary to have a complete profile on contest.bayan.ir before the warm-up round! And please do make sure you have selected the correct t-shirt size! We have upgraded our contest platform, and we've made sure everything is stable, tuned and robust now. Thanks to all those who helped us test the unstable version! The unofficial Shortcut! Round is now accessible to all, so you can check the standings and the problems. Qualification round which is the first official and required round of Bayan Programming Contest 2014-2015 will begin on October 9th so don’t forget to register right now at contest.bayan.ir if you haven’t already. We've created a twitter account to publish Bayan Programming Contest news. Now you can follow us @bayan. Update 1: The scoring will be: 500 – 1000 – 1500 – 2000 – 2500 – 2500Update 2: Warm up round is finished now. We have decided to randomly give 5 extra tshirts to 5 contestants ranked between 51 and 550. And as mentioned before, we are going to have 5 random tshirt winners in our Qualification round too. Update 3: Congratulations to top 50, specially: fotiIe96 hogloid sankear flashmt TankEngineer Update 4: Here are 5 lucky randomly selectes tshirt winners for this round: Dongmin zxqfl shimomire arthur.nascimento SlavaSSU Update 5: marat.snowbear has published a good editorial for this round.",
          "author": "BYN",
          "url": "https://codeforces.com/blog/entry/14077",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1757
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "475A - Bayan BusAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Strongly Connected CityFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Kamal-ol-molk's PaintingThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Strongly Connected City 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - Meta-universeLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*C"
          },
          "content_length": 17347
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "475A - Bayan BusAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Strongly Connected CityFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Kamal-ol-molk's PaintingThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Strongly Connected City 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - Meta-universeLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*C"
          },
          "content_length": 17347
        }
      ],
      "code_examples": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 1",
          "code": "int rem = full_sum - x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 2",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 3",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    bool hasX = false;\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == 'X', \"Invalid character '%c' in line %d, position %d\", s[j], i+1, j+1);\n            if (s[j] == 'X') {\n                hasX = true;\n            }\n        }\n    }\n    ensuref(hasX, \"At least one cell must be altered (contain 'X')\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    bool hasX = false;\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == 'X', \"Invalid character '%c' in line %d, position %d\", s[j], i+1, j+1);\n            if (s[j] == 'X') {\n                hasX = true;\n            }\n        }\n    }\n    ensuref(hasX, \"At least one cell must be altered (contain 'X')\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    bool hasX = false;\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == 'X', \"Invalid character '%c' in line %d, position %d\", s[j], i+1, j+1);\n            if (s[j] == 'X') {\n                hasX = true;\n            }\n        }\n    }\n    ensuref(hasX, \"At least one cell must be altered (contain 'X')\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.')); // Initialize all '.'\n\n    if (type == \"full\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, 'X');\n    } else if (type == \"single\") {\n        int x = rnd.next(0, n-1);\n        int y = rnd.next(0, m-1);\n        grid[x][y] = 'X';\n    } else if (type == \"rectangle\") {\n        int h = rnd.next(1, n);\n        int w = rnd.next(1, m);\n        int x = rnd.next(0, n - h);\n        int y = rnd.next(0, m - w);\n        for (int i = x; i < x + h; ++i)\n            for (int j = y; j < y + w; ++j)\n                grid[i][j] = 'X';\n    } else if (type == \"row\") {\n        int x = rnd.next(0, n-1);\n        grid[x] = string(m, 'X');\n    } else if (type == \"column\") {\n        int y = rnd.next(0, m-1);\n        for (int i = 0; i < n; ++i)\n            grid[i][y] = 'X';\n    } else if (type == \"L-shape\") {\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        int h = rnd.next(1, n - x);\n        int w = rnd.next(1, m - y);\n        for (int i = x; i < x + h; ++i)\n            grid[i][y] = 'X';\n        for (int j = y; j < y + w; ++j)\n            grid[x][j] = 'X';\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = 'X';\n    } else if (type == \"diagonal\") {\n        int k = min(n, m);\n        for (int i = 0; i < k; ++i)\n            grid[i][i] = 'X';\n    } else if (type == \"border\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = 'X';\n            grid[i][m-1] = 'X';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = 'X';\n            grid[n-1][j] = 'X';\n        }\n    } else if (type == \"edge\") {\n        int side = rnd.next(1, 4);\n        if (side == 1) { // Top edge\n            for (int j = 0; j < m; ++j)\n                grid[0][j] = 'X';\n        } else if (side == 2) { // Bottom edge\n            for (int j = 0; j < m; ++j)\n                grid[n-1][j] = 'X';\n        } else if (side == 3) { // Left edge\n            for (int i = 0; i < n; ++i)\n                grid[i][0] = 'X';\n        } else { // Right edge\n            for (int i = 0; i < n; ++i)\n                grid[i][m-1] = 'X';\n        }\n    } else if (type == \"cross\") {\n        int centerX = n / 2;\n        int centerY = m / 2;\n        for (int i = 0; i < n; ++i)\n            grid[i][centerY] = 'X';\n        for (int j = 0; j < m; ++j)\n            grid[centerX][j] = 'X';\n    } else if (type == \"random\") {\n        int total = n * m;\n        int numX = rnd.next(1, total); // At least one 'X'\n        // Fill 'X's at random positions\n        vector<int> positions(total);\n        for (int i = 0; i < total; ++i)\n            positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        for (int k = 0; k < numX; ++k) {\n            int pos = positions[k];\n            int x = pos / m;\n            int y = pos % m;\n            grid[x][y] = 'X';\n        }\n    } else {\n        // Default case: random\n        int total = n * m;\n        int numX = rnd.next(1, total); // At least one 'X'\n        // Fill 'X's at random positions\n        vector<int> positions(total);\n        for (int i = 0; i < total; ++i)\n            positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        for (int k = 0; k < numX; ++k) {\n            int pos = positions[k];\n            int x = pos / m;\n            int y = pos % m;\n            grid[x][y] = 'X';\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.')); // Initialize all '.'\n\n    if (type == \"full\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, 'X');\n    } else if (type == \"single\") {\n        int x = rnd.next(0, n-1);\n        int y = rnd.next(0, m-1);\n        grid[x][y] = 'X';\n    } else if (type == \"rectangle\") {\n        int h = rnd.next(1, n);\n        int w = rnd.next(1, m);\n        int x = rnd.next(0, n - h);\n        int y = rnd.next(0, m - w);\n        for (int i = x; i < x + h; ++i)\n            for (int j = y; j < y + w; ++j)\n                grid[i][j] = 'X';\n    } else if (type == \"row\") {\n        int x = rnd.next(0, n-1);\n        grid[x] = string(m, 'X');\n    } else if (type == \"column\") {\n        int y = rnd.next(0, m-1);\n        for (int i = 0; i < n; ++i)\n            grid[i][y] = 'X';\n    } else if (type == \"L-shape\") {\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        int h = rnd.next(1, n - x);\n        int w = rnd.next(1, m - y);\n        for (int i = x; i < x + h; ++i)\n            grid[i][y] = 'X';\n        for (int j = y; j < y + w; ++j)\n            grid[x][j] = 'X';\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = 'X';\n    } else if (type == \"diagonal\") {\n        int k = min(n, m);\n        for (int i = 0; i < k; ++i)\n            grid[i][i] = 'X';\n    } else if (type == \"border\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = 'X';\n            grid[i][m-1] = 'X';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = 'X';\n            grid[n-1][j] = 'X';\n        }\n    } else if (type == \"edge\") {\n        int side = rnd.next(1, 4);\n        if (side == 1) { // Top edge\n            for (int j = 0; j < m; ++j)\n                grid[0][j] = 'X';\n        } else if (side == 2) { // Bottom edge\n            for (int j = 0; j < m; ++j)\n                grid[n-1][j] = 'X';\n        } else if (side == 3) { // Left edge\n            for (int i = 0; i < n; ++i)\n                grid[i][0] = 'X';\n        } else { // Right edge\n            for (int i = 0; i < n; ++i)\n                grid[i][m-1] = 'X';\n        }\n    } else if (type == \"cross\") {\n        int centerX = n / 2;\n        int centerY = m / 2;\n        for (int i = 0; i < n; ++i)\n            grid[i][centerY] = 'X';\n        for (int j = 0; j < m; ++j)\n            grid[centerX][j] = 'X';\n    } else if (type == \"random\") {\n        int total = n * m;\n        int numX = rnd.next(1, total); // At least one 'X'\n        // Fill 'X's at random positions\n        vector<int> positions(total);\n        for (int i = 0; i < total; ++i)\n            positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        for (int k = 0; k < numX; ++k) {\n            int pos = positions[k];\n            int x = pos / m;\n            int y = pos % m;\n            grid[x][y] = 'X';\n        }\n    } else {\n        // Default case: random\n        int total = n * m;\n        int numX = rnd.next(1, total); // At least one 'X'\n        // Fill 'X's at random positions\n        vector<int> positions(total);\n        for (int i = 0; i < total; ++i)\n            positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        for (int k = 0; k < numX; ++k) {\n            int pos = positions[k];\n            int x = pos / m;\n            int y = pos % m;\n            grid[x][y] = 'X';\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type full\n./gen -n 1 -m 1 -type single\n./gen -n 1 -m 1 -type random\n\n./gen -n 2 -m 2 -type checkerboard\n./gen -n 2 -m 2 -type rectangle\n./gen -n 2 -m 2 -type single\n./gen -n 2 -m 2 -type full\n\n./gen -n 3 -m 3 -type L-shape\n./gen -n 4 -m 4 -type L-shape\n./gen -n 5 -m 5 -type diagonal\n\n./gen -n 3 -m 7 -type checkerboard\n./gen -n 7 -m 3 -type checkerboard\n\n./gen -n 10 -m 10 -type border\n./gen -n 10 -m 10 -type edge\n\n./gen -n 100 -m 100 -type full\n./gen -n 100 -m 100 -type random\n\n./gen -n 500 -m 1000 -type random\n./gen -n 1000 -m 500 -type random\n\n./gen -n 999 -m 999 -type random\n./gen -n 1000 -m 100 -type random\n./gen -n 100 -m 1000 -type random\n\n./gen -n 999 -m 999 -type cross\n./gen -n 1000 -m 1000 -type diagonal\n\n./gen -n 1000 -m 1000 -type full\n./gen -n 1000 -m 1000 -type single\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type checkerboard\n\n./gen -n 999 -m 1000 -type row\n./gen -n 1000 -m 999 -type column\n\n./gen -n 1000 -m 1000 -type rectangle\n./gen -n 1000 -m 1000 -type L-shape\n\n./gen -n 1000 -m 1000 -type border\n./gen -n 1000 -m 1000 -type edge\n\n./gen -n 2 -m 1000 -type column\n./gen -n 1000 -m 2 -type row\n\n./gen -n 1000 -m 1000 -type cross\n./gen -n 1000 -m 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:15.859833",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "475/D",
      "title": "D. CGCDSSQ",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n, (1 ≤ n ≤ 105), denoting the length of the sequence. The next line contains n space separated integers a1, ..., an, (1 ≤ ai ≤ 109).The third line of the input contains integer q, (1 ≤ q ≤ 3 × 105), denoting the number of queries. Then follows q lines, each contain an integer xi, (1 ≤ xi ≤ 109).",
      "output_spec": "OutputFor each query print the result in a separate line.",
      "sample_tests": "ExamplesInputCopy32 6 3512346OutputCopy12201InputCopy710 20 3 15 1000 60 16101234561020601000OutputCopy14022202211",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n, (1 ≤ n ≤ 105), denoting the length of the sequence. The next line contains n space separated integers a1, ..., an, (1 ≤ ai ≤ 109).The third line of the input contains integer q, (1 ≤ q ≤ 3 × 105), denoting the number of queries. Then follows q lines, each contain an integer xi, (1 ≤ xi ≤ 109).\n\nOutputFor each query print the result in a separate line.\n\nInputCopy32 6 3512346OutputCopy12201InputCopy710 20 3 15 1000 60 16101234561020601000OutputCopy14022202211\n\nInputCopy32 6 3512346\n\nOutputCopy12201\n\nInputCopy710 20 3 15 1000 60 16101234561020601000\n\nOutputCopy14022202211",
      "solutions": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces",
          "content": "Bayan warm-up round will be held on Sunday, October 5th 2014, 13:00 (UTC) and as indicated before, it will be held on Codeforces. Warm-up round is not a required round but top 50 are going to win t-shirts and it is going to be rated for both divisions. Problems have been prepared by mruxim, mR.ilchi, havaliza . We have tried our best to make the problem-set interesting and competitive and we hope you enjoy it. It is necessary to have a complete profile on contest.bayan.ir before the warm-up round! And please do make sure you have selected the correct t-shirt size! We have upgraded our contest platform, and we've made sure everything is stable, tuned and robust now. Thanks to all those who helped us test the unstable version! The unofficial Shortcut! Round is now accessible to all, so you can check the standings and the problems. Qualification round which is the first official and required round of Bayan Programming Contest 2014-2015 will begin on October 9th so don’t forget to register right now at contest.bayan.ir if you haven’t already. We've created a twitter account to publish Bayan Programming Contest news. Now you can follow us @bayan. Update 1: The scoring will be: 500 – 1000 – 1500 – 2000 – 2500 – 2500Update 2: Warm up round is finished now. We have decided to randomly give 5 extra tshirts to 5 contestants ranked between 51 and 550. And as mentioned before, we are going to have 5 random tshirt winners in our Qualification round too. Update 3: Congratulations to top 50, specially: fotiIe96 hogloid sankear flashmt TankEngineer Update 4: Here are 5 lucky randomly selectes tshirt winners for this round: Dongmin zxqfl shimomire arthur.nascimento SlavaSSU Update 5: marat.snowbear has published a good editorial for this round.",
          "author": "BYN",
          "url": "https://codeforces.com/blog/entry/14077",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1757
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "475A - Bayan BusAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Strongly Connected CityFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Kamal-ol-molk's PaintingThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Strongly Connected City 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - Meta-universeLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*D"
          },
          "content_length": 17347
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "475A - Bayan BusAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Strongly Connected CityFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Kamal-ol-molk's PaintingThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Strongly Connected City 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - Meta-universeLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*D"
          },
          "content_length": 17347
        }
      ],
      "code_examples": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 1",
          "code": "int rem = full_sum - x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 2",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 3",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"x_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"x_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"x_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000);\n    int maxXi = opt<int>(\"maxXi\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    vector<int> xi(q);\n    \n    if (type == \"random\") {\n        /* Generate random ai in [1, maxAi] */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    } else if (type == \"same\") {\n        /* All ai are the same value */\n        int value = rnd.next(1, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"increasing\") {\n        /* ai is an increasing sequence */\n        int start = rnd.next(1, max(maxAi - n + 1, 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        /* ai is a decreasing sequence */\n        int start = rnd.next(n, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } else if (type == \"ones\") {\n        /* All ai are 1 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"primes\") {\n        /* Generate small primes */\n        vector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() -1)];\n        }\n    } else if (type == \"large-gcd\") {\n        /* All ai are divisible by a common large number */\n        int gcdValue = rnd.next(100000000, maxAi);\n        for (int i = 0; i < n; ++i) {\n            int delta = rnd.next(0, 1000);\n            a[i] = gcdValue + delta * gcdValue;\n        }\n    } else if (type == \"small-gcd\") {\n        /* GCD cycles through small values */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"alternating\") {\n        /* ai alternates between two values */\n        int val1 = rnd.next(1, maxAi);\n        int val2 = rnd.next(1, maxAi);\n        while (val2 == val1) val2 = rnd.next(1, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"max-values\") {\n        /* All ai are maxAi */\n        for (int i = 0; i < n; ++i) {\n            a[i] = maxAi;\n        }\n    } else if (type == \"min-values\") {\n        /* All ai are 1 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"special\") {\n        /* Ai alternates between a small value and a large value */\n        int val1 = rnd.next(1, 10);\n        int val2 = rnd.next(100000000, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    }\n    \n    string xiType = opt<string>(\"xiType\", \"random\");\n    \n    if (xiType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1, maxXi);\n        }\n    } else if (xiType == \"same\") {\n        int value = rnd.next(1, maxXi);\n        for (int i = 0; i < q; ++i) {\n            xi[i] = value;\n        }\n    } else if (xiType == \"fromAi\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = a[rnd.next(0, n-1)];\n        }\n    } else if (xiType == \"small\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1, 10);\n        }\n    } else if (xiType == \"large\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(maxXi / 2, maxXi);\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1, maxXi);\n        }\n    }\n    \n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output the sequence a1 to an */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    /* Output q */\n    printf(\"%d\\n\", q);\n    /* Output the queries xi */\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d\\n\", xi[i]);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000);\n    int maxXi = opt<int>(\"maxXi\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    vector<int> xi(q);\n    \n    if (type == \"random\") {\n        /* Generate random ai in [1, maxAi] */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    } else if (type == \"same\") {\n        /* All ai are the same value */\n        int value = rnd.next(1, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"increasing\") {\n        /* ai is an increasing sequence */\n        int start = rnd.next(1, max(maxAi - n + 1, 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        /* ai is a decreasing sequence */\n        int start = rnd.next(n, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } else if (type == \"ones\") {\n        /* All ai are 1 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"primes\") {\n        /* Generate small primes */\n        vector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() -1)];\n        }\n    } else if (type == \"large-gcd\") {\n        /* All ai are divisible by a common large number */\n        int gcdValue = rnd.next(100000000, maxAi);\n        for (int i = 0; i < n; ++i) {\n            int delta = rnd.next(0, 1000);\n            a[i] = gcdValue + delta * gcdValue;\n        }\n    } else if (type == \"small-gcd\") {\n        /* GCD cycles through small values */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"alternating\") {\n        /* ai alternates between two values */\n        int val1 = rnd.next(1, maxAi);\n        int val2 = rnd.next(1, maxAi);\n        while (val2 == val1) val2 = rnd.next(1, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"max-values\") {\n        /* All ai are maxAi */\n        for (int i = 0; i < n; ++i) {\n            a[i] = maxAi;\n        }\n    } else if (type == \"min-values\") {\n        /* All ai are 1 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"special\") {\n        /* Ai alternates between a small value and a large value */\n        int val1 = rnd.next(1, 10);\n        int val2 = rnd.next(100000000, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    }\n    \n    string xiType = opt<string>(\"xiType\", \"random\");\n    \n    if (xiType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1, maxXi);\n        }\n    } else if (xiType == \"same\") {\n        int value = rnd.next(1, maxXi);\n        for (int i = 0; i < q; ++i) {\n            xi[i] = value;\n        }\n    } else if (xiType == \"fromAi\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = a[rnd.next(0, n-1)];\n        }\n    } else if (xiType == \"small\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1, 10);\n        }\n    } else if (xiType == \"large\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(maxXi / 2, maxXi);\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1, maxXi);\n        }\n    }\n    \n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output the sequence a1 to an */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    /* Output q */\n    printf(\"%d\\n\", q);\n    /* Output the queries xi */\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d\\n\", xi[i]);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 5 -q 5 -type random -xiType random\n./gen -n 5 -q 5 -type same -xiType same\n./gen -n 10 -q 10 -type increasing -xiType fromAi\n./gen -n 10 -q 10 -type decreasing -xiType fromAi\n./gen -n 10 -q 10 -type ones -xiType small\n\n# Medium test cases\n./gen -n 1000 -q 1000 -type random -xiType random\n./gen -n 1000 -q 1000 -type same -xiType random\n./gen -n 1000 -q 1000 -type large-gcd -xiType large\n./gen -n 1000 -q 1000 -type small-gcd -xiType small\n./gen -n 1000 -q 1000 -type alternating -xiType fromAi\n\n# Large test cases\n./gen -n 100000 -q 300000 -type random -xiType random\n./gen -n 100000 -q 300000 -type same -xiType same\n./gen -n 100000 -q 300000 -type ones -xiType ones\n./gen -n 100000 -q 300000 -type primes -xiType fromAi\n./gen -n 100000 -q 300000 -type max-values -xiType fromAi\n./gen -n 100000 -q 300000 -type min-values -xiType fromAi\n\n# Special test cases\n./gen -n 100000 -q 300000 -type large-gcd -xiType large\n./gen -n 100000 -q 300000 -type small-gcd -xiType small\n./gen -n 100000 -q 300000 -type special -xiType random\n./gen -n 100000 -q 300000 -type alternating -xiType fromAi\n./gen -n 100000 -q 300000 -type increasing -xiType fromAi\n./gen -n 100000 -q 300000 -type decreasing -xiType fromAi\n\n# Edge cases\n./gen -n 1 -q 1 -type random -xiType random\n./gen -n 1 -q 1 -type ones -xiType ones\n./gen -n 1 -q 1 -type same -xiType same\n./gen -n 2 -q 1 -type random -xiType random\n./gen -n 100000 -q 1 -type random -xiType random\n./gen -n 1 -q 300000 -type random -xiType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:17.713462",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "475/E",
      "title": "E. Strongly Connected City 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integers n and m, (), denoting the number of junctions and streets of the city.Each of the following m lines contains two integers u and v, (u ≠ v), denoting endpoints of a street in the city.Between every two junctions there will be at most one street. It is guaranteed that before mayor decision (when all streets were two-way) it was possible to reach each junction from any other junction.",
      "output_spec": "OutputPrint the maximal number of pairs (u, v) such that that it is possible to reach junction v from u after directing the streets.",
      "sample_tests": "ExamplesInputCopy5 41 21 31 41 5OutputCopy13InputCopy4 51 22 33 44 11 3OutputCopy16InputCopy2 11 2OutputCopy3InputCopy6 71 22 31 31 44 55 66 4OutputCopy27",
      "description": "E. Strongly Connected City 2\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains integers n and m, (), denoting the number of junctions and streets of the city.Each of the following m lines contains two integers u and v, (u ≠ v), denoting endpoints of a street in the city.Between every two junctions there will be at most one street. It is guaranteed that before mayor decision (when all streets were two-way) it was possible to reach each junction from any other junction.\n\nOutputPrint the maximal number of pairs (u, v) such that that it is possible to reach junction v from u after directing the streets.\n\nInputCopy5 41 21 31 41 5OutputCopy13InputCopy4 51 22 33 44 11 3OutputCopy16InputCopy2 11 2OutputCopy3InputCopy6 71 22 31 31 44 55 66 4OutputCopy27\n\nInputCopy5 41 21 31 41 5\n\nOutputCopy13\n\nInputCopy4 51 22 33 44 11 3\n\nOutputCopy16\n\nInputCopy2 11 2\n\nOutputCopy3\n\nInputCopy6 71 22 31 31 44 55 66 4\n\nOutputCopy27\n\nNoteIn the first sample, if the mayor makes first and second streets one-way towards the junction 1 and third and fourth streets in opposite direction, there would be 13 pairs of reachable junctions: {(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (2, 1), (3, 1), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)}",
      "solutions": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces",
          "content": "Bayan warm-up round will be held on Sunday, October 5th 2014, 13:00 (UTC) and as indicated before, it will be held on Codeforces. Warm-up round is not a required round but top 50 are going to win t-shirts and it is going to be rated for both divisions. Problems have been prepared by mruxim, mR.ilchi, havaliza . We have tried our best to make the problem-set interesting and competitive and we hope you enjoy it. It is necessary to have a complete profile on contest.bayan.ir before the warm-up round! And please do make sure you have selected the correct t-shirt size! We have upgraded our contest platform, and we've made sure everything is stable, tuned and robust now. Thanks to all those who helped us test the unstable version! The unofficial Shortcut! Round is now accessible to all, so you can check the standings and the problems. Qualification round which is the first official and required round of Bayan Programming Contest 2014-2015 will begin on October 9th so don’t forget to register right now at contest.bayan.ir if you haven’t already. We've created a twitter account to publish Bayan Programming Contest news. Now you can follow us @bayan. Update 1: The scoring will be: 500 – 1000 – 1500 – 2000 – 2500 – 2500Update 2: Warm up round is finished now. We have decided to randomly give 5 extra tshirts to 5 contestants ranked between 51 and 550. And as mentioned before, we are going to have 5 random tshirt winners in our Qualification round too. Update 3: Congratulations to top 50, specially: fotiIe96 hogloid sankear flashmt TankEngineer Update 4: Here are 5 lucky randomly selectes tshirt winners for this round: Dongmin zxqfl shimomire arthur.nascimento SlavaSSU Update 5: marat.snowbear has published a good editorial for this round.",
          "author": "BYN",
          "url": "https://codeforces.com/blog/entry/14077",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1757
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "475A - Bayan BusAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Strongly Connected CityFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Kamal-ol-molk's PaintingThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Strongly Connected City 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - Meta-universeLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*E"
          },
          "content_length": 17347
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "475A - Bayan BusAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Strongly Connected CityFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Kamal-ol-molk's PaintingThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Strongly Connected City 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - Meta-universeLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*E"
          },
          "content_length": 17347
        }
      ],
      "code_examples": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 1",
          "code": "int rem = full_sum - x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 2",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 3",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if(parent[x] == x) return x;\n    else return parent[x] = find(parent[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x != y) parent[y] = x;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int,int>> edges;\n\n    for(int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge %d: u_i = v_i (%d): loops are not allowed\", i+1, u);\n        inf.readEoln();\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", a, b);\n        edges.insert(edge);\n\n        unite(u, v);\n    }\n\n    int p = find(1);\n    for(int i = 2; i <= n; ++i) {\n        ensuref(find(i) == p, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if(parent[x] == x) return x;\n    else return parent[x] = find(parent[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x != y) parent[y] = x;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int,int>> edges;\n\n    for(int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge %d: u_i = v_i (%d): loops are not allowed\", i+1, u);\n        inf.readEoln();\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", a, b);\n        edges.insert(edge);\n\n        unite(u, v);\n    }\n\n    int p = find(1);\n    for(int i = 2; i <= n; ++i) {\n        ensuref(find(i) == p, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if(parent[x] == x) return x;\n    else return parent[x] = find(parent[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x != y) parent[y] = x;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int,int>> edges;\n\n    for(int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge %d: u_i = v_i (%d): loops are not allowed\", i+1, u);\n        inf.readEoln();\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", a, b);\n        edges.insert(edge);\n\n        unite(u, v);\n    }\n\n    int p = find(1);\n    for(int i = 2; i <= n; ++i) {\n        ensuref(find(i) == p, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<pair<int, int>> edges;\n    \n    if (type == \"path\") {\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"cycle\") {\n        m = n;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({n, 1});\n    } else if (type == \"star\") {\n        m = n -1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"complete\") {\n        m = min(n * (n - 1) / 2, 100000);\n        for (int i = 1; i <= n && edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && edges.size() < m; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n    } else if (type == \"random\") {\n        if (m == -1) {\n            // Default m between n-1 and min(n*(n-1)/2, 100000)\n            m = rnd.next(n - 1, min(n * (n - 1) / 2, 100000));\n        }\n        // Generate a random connected graph with m edges\n        // First, create a random tree to ensure connectivity\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({i, parent[i]});\n        }\n        // Add extra edges to reach m\n        set<pair<int, int>> edge_set;\n        for (auto e : edges) {\n            int u = e.first, v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.find({u, v}) != edge_set.end()) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n        }\n    } else {\n        // Default to random if type is unrecognized\n        if (m == -1) {\n            m = rnd.next(n - 1, min(n * (n - 1) / 2, 100000));\n        }\n        // Same as above\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({i, parent[i]});\n        }\n        set<pair<int, int>> edge_set;\n        for (auto e : edges) {\n            int u = e.first, v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.find({u, v}) != edge_set.end()) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n        }\n    }\n    \n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<pair<int, int>> edges;\n    \n    if (type == \"path\") {\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"cycle\") {\n        m = n;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({n, 1});\n    } else if (type == \"star\") {\n        m = n -1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"complete\") {\n        m = min(n * (n - 1) / 2, 100000);\n        for (int i = 1; i <= n && edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && edges.size() < m; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n    } else if (type == \"random\") {\n        if (m == -1) {\n            // Default m between n-1 and min(n*(n-1)/2, 100000)\n            m = rnd.next(n - 1, min(n * (n - 1) / 2, 100000));\n        }\n        // Generate a random connected graph with m edges\n        // First, create a random tree to ensure connectivity\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({i, parent[i]});\n        }\n        // Add extra edges to reach m\n        set<pair<int, int>> edge_set;\n        for (auto e : edges) {\n            int u = e.first, v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.find({u, v}) != edge_set.end()) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n        }\n    } else {\n        // Default to random if type is unrecognized\n        if (m == -1) {\n            m = rnd.next(n - 1, min(n * (n - 1) / 2, 100000));\n        }\n        // Same as above\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({i, parent[i]});\n        }\n        set<pair<int, int>> edge_set;\n        for (auto e : edges) {\n            int u = e.first, v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.find({u, v}) != edge_set.end()) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n        }\n    }\n    \n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n tests\n./gen -n 2 -type path\n./gen -n 2 -type star\n./gen -n 2 -type cycle\n./gen -n 2 -type complete\n./gen -n 2 -type random -m 1\n\n./gen -n 5 -type path\n./gen -n 5 -type star\n./gen -n 5 -type cycle\n./gen -n 5 -type complete\n./gen -n 5 -type random -m 5\n\n# Medium n tests\n./gen -n 10 -type path\n./gen -n 10 -type star\n./gen -n 10 -type cycle\n./gen -n 10 -type complete\n./gen -n 10 -type random -m 15\n\n./gen -n 100 -type path\n./gen -n 100 -type star\n./gen -n 100 -type cycle\n./gen -n 100 -type complete\n./gen -n 100 -type random -m 200\n\n# Larger n tests\n./gen -n 1000 -type path\n./gen -n 1000 -type star\n./gen -n 1000 -type cycle\n./gen -n 1000 -type random -m 5000\n./gen -n 1000 -type complete\n\n# Large n tests\n./gen -n 10000 -type random -m 20000\n./gen -n 10000 -type path\n./gen -n 10000 -type star\n./gen -n 10000 -type cycle\n\n./gen -n 447 -type complete  # m ≈ 1e5\n\n# Maximum possible n and m\n./gen -n 100000 -type path\n./gen -n 100000 -type star\n./gen -n 100000 -type cycle\n./gen -n 100000 -type random -m 100000\n\n# Random large graphs with m near maximum\n./gen -n 100000 -type random -m 99999\n./gen -n 100000 -type random -m 99998\n\n# Complete graph with n to not exceed m = 1e5\n./gen -n 500 -type complete  # m=124750\n\n# Edge cases with minimal edges (trees)\n./gen -n 100000 -type path\n./gen -n 100000 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:19.561709",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "475/F",
      "title": "F. Meta-universe",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n, (1 ≤ n ≤ 105), denoting the number of planets in the meta-universe.The next n lines each contain integers xi and yi, ( - 109 ≤ xi, yi ≤ 109), denoting the coordinates of the i-th planet. All planets are located in different cells.",
      "output_spec": "OutputPrint the number of resulting universes.",
      "sample_tests": "ExamplesInputCopy50 00 22 02 12 2OutputCopy3InputCopy80 01 00 20 33 03 12 33 3OutputCopy1",
      "description": "F. Meta-universe\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer n, (1 ≤ n ≤ 105), denoting the number of planets in the meta-universe.The next n lines each contain integers xi and yi, ( - 109 ≤ xi, yi ≤ 109), denoting the coordinates of the i-th planet. All planets are located in different cells.\n\nOutputPrint the number of resulting universes.\n\nInputCopy50 00 22 02 12 2OutputCopy3InputCopy80 01 00 20 33 03 12 33 3OutputCopy1\n\nInputCopy50 00 22 02 12 2\n\nOutputCopy3\n\nInputCopy80 01 00 20 33 03 12 33 3\n\nOutputCopy1\n\nNoteThe following figure describes the first test case:",
      "solutions": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces",
          "content": "Bayan warm-up round will be held on Sunday, October 5th 2014, 13:00 (UTC) and as indicated before, it will be held on Codeforces. Warm-up round is not a required round but top 50 are going to win t-shirts and it is going to be rated for both divisions. Problems have been prepared by mruxim, mR.ilchi, havaliza . We have tried our best to make the problem-set interesting and competitive and we hope you enjoy it. It is necessary to have a complete profile on contest.bayan.ir before the warm-up round! And please do make sure you have selected the correct t-shirt size! We have upgraded our contest platform, and we've made sure everything is stable, tuned and robust now. Thanks to all those who helped us test the unstable version! The unofficial Shortcut! Round is now accessible to all, so you can check the standings and the problems. Qualification round which is the first official and required round of Bayan Programming Contest 2014-2015 will begin on October 9th so don’t forget to register right now at contest.bayan.ir if you haven’t already. We've created a twitter account to publish Bayan Programming Contest news. Now you can follow us @bayan. Update 1: The scoring will be: 500 – 1000 – 1500 – 2000 – 2500 – 2500Update 2: Warm up round is finished now. We have decided to randomly give 5 extra tshirts to 5 contestants ranked between 51 and 550. And as mentioned before, we are going to have 5 random tshirt winners in our Qualification round too. Update 3: Congratulations to top 50, specially: fotiIe96 hogloid sankear flashmt TankEngineer Update 4: Here are 5 lucky randomly selectes tshirt winners for this round: Dongmin zxqfl shimomire arthur.nascimento SlavaSSU Update 5: marat.snowbear has published a good editorial for this round.",
          "author": "BYN",
          "url": "https://codeforces.com/blog/entry/14077",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1757
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "475A - Bayan BusAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Strongly Connected CityFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Kamal-ol-molk's PaintingThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Strongly Connected City 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - Meta-universeLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*F"
          },
          "content_length": 17347
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces",
          "content": "475A - Bayan BusAs usual for A we have an implementation problem and the main question is how to implement it quickly in the easiest (thus less error-prone) way. During the contest I spent almost no time thinking about it and decided to implement quite straightforward approach — start with empty string and concatenate different symbols to the end of it. The result is quite messy and worst of all I forgot one of the main principles in the [commercial] programming — separate logic from its presentation. The \"presentation\" here is all these bus characters which are all the same across different inputs. So I paid my price, my original solution failed on system tests. Much better approach afterwards I looked up in Swistakk's solution — you copy&paste the \"template\" of the bus from the example test into your source code, then you just change the characters for each of 34 possible seats. Result becomes much cleaner — 8140120.475B - Strongly Connected CityFor B we already might need some kind of algorithm to solve it, though for the constraints given you might use almost any approach. If you just have a directed graph then in order to check whether you can reach all nodes from all other nodes you can do different things — you can dfs/bfs from all nodes, two dfs/bfs from the single node to check that every other node has both paths to and from that node, or you can employ different \"min distance between all pairs of nodes\" algorithm. All of these seem to work fine for this problem. But we shouldn't ignore here that the input graph has a special configuration — it's a grid of vertical and horizontal directed lines. For this graph all you need is to check whether four outer streets form a cycle or not. If they form a cycle then the answer is \"YES\", otherwise \"NO\". The good explanation why this works was already given by shato. And then the entire solution takes just 10 lines of code — 8140438.475C - Kamal-ol-molk's PaintingThere are probably several completely different ways to solve this problem, I will describe only the one I implemented during the round. The start point for the solution is that there are three cases we need to cover: either first time we move the brush right or we move it down or we do not move it at all. Let's start with the last one. Since we're not moving the brush at all then it's obvious that altered cells on the painting form a rectangle. It can also be proven that the only case we need to consider here is the rectangle 1x1, that's the only rectangle which cannot be achieved by moving some smaller rectangle. So we need to count the number of altered cells, if it is equal to 1 then the answer is 1. Now we're left with two cases to consider, you start by moving right in the case and you move down in the second case. You can write some code to cover each of those cases, but you can also notice that they are symmetric in some sense. To be more clear, they are symmetric against the diagonal line which goes from (0, 0) point through (1, 1) point. If you have some code to solve \"move down first\" case, then you don't need to write almost completely the same code to solve \"move right\" case, you can simply mirror the image against that diagonal and invoke \"move down\" method again. Small trick which saves a lot of time and prevents copy-pasting of the code. Now let's try to solve this last case. Basically the approach I used can be shortly described like that: we start in the leftmost topmost altered cell, then we move down and that move already leaves us only one option what do in the next moves until the end, so we get the entire sequence of moves. As well as getting these moves we also get the only possible width and height of the brush, so we know everything, I was not very strict while moving the brush so at the end I also compared whether these moves and these sizes in fact give exactly the same image as we get in the input. That was the brief explanation of the \"move down\" method, now let's get into details. First of all since we move down immediately from the start point then there is only one value which can be valid for the brush width — it is the number of altered cells which go to the right from the start point. So we know one dimension. Now let's try moving the brush. Ok, first time as we said we move it down, what is next? Then you might have a choice whether you want to move right or to move down again. The answer is to move right first because your width is already fixed while height might be unknown still, so if you miss point to be altered in the left column of the brush and you move right, you might still have a chance to paint it if you take the correct height of the brush. But if you miss the point to the right of the current topmost brush row then you won't be able to cover it later, because your width was fixed on the first step. Here is a picture: Grayed out is the current position of the brush. So what I'm saying is that you should move to the right if the cell in the red area is painted, otherwise you will definitely miss it. So this simple thing gives you the entire idea on how to build the only possible sequence of moves. You also need to calculate some possible value for the brush height. It can be calculated just before moving right, in order not to miss any painted cells you need to extend you height of the brush to cover all the painted cells in the leftmost column of you current brush position (this was highlighted as green on the image above). Now you know all the information about the probable painting — you have both dimensions of the brush and you know how it was moving, as I said before all you need to do is to double check that these moves and these dimensions in fact give you the same painting you get. If it gives the same painting then the answer for this case is width·height, otherwise there is no answer for this particular case. If you implement all of these steps carefully and you won't paint cells more than one time, then you will be able to achieve an O(N·M) complexity. 475D - CGCDSSQIt seems that all the solutions for this problem based on the same observation. Let's introduce two number sequences: a0, a1, ..., an and x0 = a0, xi = gcd(xi - 1, ai). Then the observation is that the number of distinct values in x sequence is no more than 1 + log2a0. It can be proven by taking into account that x is non-increasing sequence and value for greatest common divisor in case if it decreases becomes at most half of the previous value. So we have this observation and we want to calculate the count of GCD values across all the intervals, I see couple of ways how we can exploit the observation: We can fix the left side of the interval and look for the places where gcd(al, ..., ar) function will decrease. Between the points where it decreases it will stay flat so we can add the size of this flat interval to the result of this particular gcd. There are different ways how to find the place where the function changes its value, some people were using sparse tables, I have never used those so won't give this solution here. Otherwise you can use segment tree to calculate gcd on the interval and then do a binary search to find where this value changes. This adds squared logarithmic factor to the complexity, not sure if that passes the TL easily. Otherwise you can do basically the same by doing only one descent in the segment tree. Then you get rid of one logarithmic factor in the complexity but that will make segment tree a bit more complicated. Another solution seems to be much simpler, you just go left to right and you calculate what is the number of segments started to the left of current element and what is the greatest common divisors values on those intervals. These values you need to store grouped by the gcd value. This information can be easily updated when you move to the next element to the right — you can check that part in my submission. Our observation guarantees that the number of different gcd values that we have to track is quite small all the time, it's no more than 1 + logAmax. Submission: 8141810, maps are used here to count gcd values, using the vectors instead makes it running two times faster but the code is not that clear then. 475E - Strongly Connected City 2Here we can start with the simple observation — if we have a cycle then we can choose such an orientation for the edges such that it will become a directed cycle. In this case all nodes in the cycle will be accessible from all other nodes of the same cycle. I was using the bridges finding algorithm to find the cycles. So you find all the cycles, for each cycle of size si you add si2 to the answer. Then you can collapse all the cycles into the single node (storing the cycle size as well). After merging all cycles into single nodes original graph becomes a tree. Now it comes to some kind of a magic, as far as I've seen from the discussions here people were make an assumption about the optimal solution, but nobody proved this assumption. Assumption goes like this: \"there exists an optimal solution which has some node (let's call it root) such that for every other node v you can either reach root from v or you can reach v from root using directed edges of this optimal solution\". Intuitively this assumption makes sense because probably in order to increase the number of pairs of reachable nodes you will try to create as least as possible components in the graph which will be mutually unreachable. So we have this assumption, now in order to solve the problem we can iterate over all nodes in the tree and check what will be the answer if we will make this node to be a root from the assumption. Let's draw some example of the graph which might be a solution according to our assumption: Here the root is drawn on top and every other node has either a path to the root or a path from the root. So let's say we decided that some node will be a root but we didn't decide yet for each of its children whether their edges will directed to the root or from the root. In order to fulfil our assumption the orientation of the edges within some child's subtree should be the same as the orientation of the edge between the root and its child. There will be two more numbers which we need to add to the result — pairs of reachable nodes within some child's (root children only!) subtree and pairs of reachable nodes for nodes from different subtrees. Let's introduce some variables: si — size of the i-th cycle from the step when we were merging the cycles. In our tree all cycles are already merged into a single node, so si is a weight of the i-th node. It can be equal to 1 if node i did not belong to any cycle. Wi — weight of the entire subtree rooted at node i. It can be seen that if we orient all edges in the subtree in the same manner according to our assumption then the number of reachable pairs of nodes will not depend on the chosen orientation. Each particular node i adds the following term to the final result: si·(Wi - si). Now we need to decide what should be the orientation of all the edges adjacent to the root. Let's declare two more variables: in — sum of Wi for all root's children whose edge is directed towards the root. out — same for the children whose edge is directed from the root. So if we have those definitions then the last term for the result will be equal to: (in + sroot)·out + in·sroot. We can see that this term depends only on the in and out values, it doesn't depend on which particular children contribute to each of these values. We check which values for in and out we can achieve, we can do it using the DP similar to the one used in knapsack. So we check every possible value for in, based on this we can calculate out value because their sum is fixed and equals to Wroot - sroot, then we put them into the formula above and check whether it gives us a better total answer. There is one more thing to be noted about this solution — you can see that I said that we need to iterate over all nodes and make them to be the root, then you will need to get all the sizes of the children for particular root and for those sizes you will need to find all the possible values for their sums. The sum can be up to N, for some root we might have up to O(N) children, so if you've fixed the root then the rest might have O(N2) complexity. This might lead you to a conclusion that the entire algorithm then has O(N3) complexity, which is too slow for the given constraints. But that is not the case because outermost and innermost loops depend on each other, basically there you iterate over all the parent-children relations in the tree, and we know that this number in the tree equals to 2(N - 1), less than N2, so in total it gives O(N2) complexity for this solution. Submission: 8168350475F - Meta-universeLet's try to solve this problem naively first, the approach should be obvious then — you have a set of points, you iterate them left to right and you mind the gap between them. If there is such a gap between two neighbours you split this meta-universe with vertical line and do the same thing for each of two subsets. If you found no such gap by going left to right, you do the same going top to bottom. If you are unlucky again then you are done, this is a universe, it cannot be split. Let's think about the complexity of this approach now, even if get the points sorted and split for free then the complexity will highly depend on how soon you found a place where you could split the meta-universe. For example if you are lucky and you will always split close to the start of the sequence then your total complexity would be O(n), which is very good indeed. If you will encounter the option to split somewhere in the middle of the sequence, which means that you split the meta-universe in two halves, you will get a O(NlogN) solution, not linear but still good enough for this problem. The worst case occurs when you split always after iterating through the entire sequence, that means that in order to extract one point from the set you will have to iterate through all of them, now the complexity becomes O(N2), that's not enough already. Let's think about it again, we got several cases, two of them are good (when we split in the beginning or in the middle) and the third one is too slow, it happens when we split always in the end. We need to make our solution better in this particular case and that should be almost enough to solve the entire problem. The obvious approach how to get rid of \"split at the end\" case is to start iterating from the end initially. And it should be obvious as well that it doesn't change much because your old start becomes the end now. But what we can do instead is to start iterating from both sides, then in any case you are winner! Intuitively, if you encountered a way to split at some end of the sequence then you're good to go because you spent almost no time on this particular step and you already found a way to split it further. In the opposite case, if you had to iterate through the entire sequence and found a split point in the middle you should be still happy about it because it means that on the next steps each of your new sets will be approximately two times smaller, that leads you back to O(NlogN) complexity. Also you should not forget that you need to do the same for Y coordinate as well, that means that you need to have four iterators and you need to check them simultaneously. This is the basic idea for my solution, there is just one more detail to be added. Initially I told that our complexity estimate is given if we \"sort and split for free\". That's not that easy to achieve, but we can achieve something else almost as good as this one. In order to split cheaply all you need to do is to avoid the actual split :-) Instead of splitting the sequence into two subsequences you can just leave the original sequence and extract part of it which will become a new subsequence. Obviously if you want to make this operation cheaper you need to extract the smaller part. For example if you have a sequence of points sorted by X and you found a split point by iterating from the end of the sequence then you can be sure that the right subsequence will not be longer than the left sequence, because you iterate from the left-hand side and from the right-hand side simultaneously. Now we need to take care about sorting part as well. This one is easy, all you need to do is instead of storing one sequence of points you store all the points in two sorted sets — one by X and one by Y coordinate. In total this should add just one more logarithmic factor to the complexity. That is the entire solution, I'd like to get back one more time to the complexity analysis. We have a recurring algorithm, on every step of the recurrence we're looking for the split point, then we split and invoke this recurring algorithm two more times. It looks that for the worst case (which is split in the middle) we will split a sequence into two subsequences of the same size, so we have a full right to apply a Master theorem here. On each step our complexity seems to be O(NlogN) (log factor because of using sets) so the \"Case 2. Generic form\" section from the Wiki gives us a solution that our entire algorithm has an O(Nlog2N) time complexity. Am I correct? My submission — 8138406",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14168",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 475\\s*F"
          },
          "content_length": 17347
        }
      ],
      "code_examples": [
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 1",
          "code": "int rem = full_sum - x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 2",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan Contest Warm Up round + 50 tshirts! - Codeforces - Code 3",
          "code": "1 -> 2\n1 -> 3\n2 -> 4\n3 -> 4\n\n4 -> 5\n4 -> 6\n5 -> 7\n6 -> 7\n\n...\n\n3n + 1 -> 3n + 2\n3n + 1 -> 3n + 3\n3n + 2 -> 3n + 4\n3n + 3 -> 3n + 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14077",
          "author": "BYN"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 1",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 2",
          "code": "for (int out = 0; out <= all; out++)\n        if (reach[out])\n            res = max(res, (all - out) * out);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 3",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 4",
          "code": "void dfs1(int v, int p, int deep) {\n    cur += deep * s[v];\n    w[v] = s[v];\n    for (int to : e[v]) {\n        if (to == p)\n            continue;\n        dfs1(to, v, deep + s[v]);\n        w[v] += w[to];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 5",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 6",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 7",
          "code": "if(query(l,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        },
        {
          "title": "Bayan 2015 Contest Warm Up Editorial - Codeforces - Code 8",
          "code": "if(query(i,mid) == gc)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14168",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> planet_positions;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        ensuref(planet_positions.insert(make_pair(xi, yi)).second, \n                \"Duplicate planet position at line %d: (%d, %d)\", i + 2, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> planet_positions;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        ensuref(planet_positions.insert(make_pair(xi, yi)).second, \n                \"Duplicate planet position at line %d: (%d, %d)\", i + 2, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> planet_positions;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        ensuref(planet_positions.insert(make_pair(xi, yi)).second, \n                \"Duplicate planet position at line %d: (%d, %d)\", i + 2, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> planets;\n\n    if (type == \"single_universe\") {\n        // Generate planets such that there is no empty row or column\n        int k = sqrt(n);\n        if (k * k < n) k++;\n        int x_min = -int(1e9) + 500000;\n        int y_min = -int(1e9) + 500000;\n\n        int count = 0;\n        for (int i = 0; i < k; i++) {\n            int x = x_min + i;\n            for (int j = 0; j < k; j++) {\n                int y = y_min + j;\n                planets.push_back({x, y});\n                count++;\n                if (count == n) break;\n            }\n            if (count == n) break;\n        }\n    }\n    else if (type == \"max_universes\") {\n        // Each planet is in its own universe\n        for (int i = 0; i < n; i++) {\n            int x = int(-1e9) + i * 2;\n            int y = int(-1e9) + i * 2 + 1;\n            planets.push_back({x, y});\n        }\n    }\n    else if (type == \"random\") {\n        // Generate random positions, ensuring uniqueness\n        vector<int> xs, ys;\n        int x_start = -1000000000;\n        int x_end = 1000000000;\n        int y_start = -1000000000;\n        int y_end = 1000000000;\n\n        if (n > x_end - x_start + 1 || n > y_end - y_start + 1) {\n            fprintf(stderr, \"The range of coordinates is too small to generate unique positions for n = %d\\n\", n);\n            exit(1);\n        }\n\n        xs.resize(n);\n        ys.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            xs[i] = x_start + i;\n            ys[i] = y_start + i;\n        }\n\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n\n        for (int i = 0; i < n; i++) {\n            planets.push_back({xs[i], ys[i]});\n        }\n    }\n    else if (type == \"grid\") {\n        // Generate a grid\n        int k = sqrt(n);\n        if (k * k < n) k++;\n        int x_min = -int(1e9) + 500000;\n        int y_min = -int(1e9) + 500000;\n\n        int count = 0;\n        for (int i = 0; i < k; i++) {\n            int x = x_min + i;\n            for (int j = 0; j < k; j++) {\n                int y = y_min + j;\n                planets.push_back({x, y});\n                count++;\n                if (count == n) break;\n            }\n            if (count == n) break;\n        }\n    }\n    else if (type == \"line_x\") {\n        // All x_i = x0\n        int x0 = rnd.next(-int(1e9), int(1e9));\n        int y_start = -int(1e9);\n        int y_end = int(1e9);\n\n        if (n > y_end - y_start + 1) {\n            fprintf(stderr, \"Cannot generate unique y coordinates for n = %d\\n\", n);\n            exit(1);\n        }\n\n        vector<int> y_values;\n        for (int i = 0; i < n; i++) {\n            y_values.push_back(y_start + i);\n        }\n        shuffle(y_values.begin(), y_values.end());\n        for (int i = 0; i < n; i++) {\n            planets.push_back({x0, y_values[i]});\n        }\n    }\n    else if (type == \"line_y\") {\n        // All y_i = y0\n        int y0 = rnd.next(-int(1e9), int(1e9));\n        int x_start = -int(1e9);\n        int x_end = int(1e9);\n\n        if (n > x_end - x_start + 1) {\n            fprintf(stderr, \"Cannot generate unique x coordinates for n = %d\\n\", n);\n            exit(1);\n        }\n\n        vector<int> x_values;\n        for (int i = 0; i < n; i++) {\n            x_values.push_back(x_start + i);\n        }\n        shuffle(x_values.begin(), x_values.end());\n        for (int i = 0; i < n; i++) {\n            planets.push_back({x_values[i], y0});\n        }\n    }\n    else if (type == \"big_coordinates\") {\n        // Coordinates near -1e9 or 1e9\n        int range_min, range_max;\n        if (rnd.next(0, 1)) {\n            range_min = -1000000000;\n            range_max = range_min + n - 1;\n        } else {\n            range_max = 1000000000;\n            range_min = range_max - n + 1;\n        }\n        for (int i = 0; i < n; i++) {\n            int x = range_min + i;\n            int y = range_max - i;\n            planets.push_back({x, y});\n        }\n    }\n    else if (type == \"worst_case\") {\n        // Generate a large chain along y = x\n        for (int i = 0; i < n; i++) {\n            int x = -int(1e9) + i;\n            int y = -int(1e9) + i;\n            planets.push_back({x, y});\n        }\n    }\n    else {\n        // Default to random\n        fprintf(stderr, \"Unknown type '%s', defaulting to 'random'\\n\", type.c_str());\n        // Generate random positions, ensuring uniqueness\n        vector<int> xs, ys;\n        int x_start = -1000000000;\n        int x_end = 1000000000;\n        int y_start = -1000000000;\n        int y_end = 1000000000;\n\n        if (n > x_end - x_start + 1 || n > y_end - y_start + 1) {\n            fprintf(stderr, \"The range of coordinates is too small to generate unique positions for n = %d\\n\", n);\n            exit(1);\n        }\n\n        xs.resize(n);\n        ys.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            xs[i] = x_start + i;\n            ys[i] = y_start + i;\n        }\n\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n\n        for (int i = 0; i < n; i++) {\n            planets.push_back({xs[i], ys[i]});\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Shuffle planets to avoid any ordering\n    shuffle(planets.begin(), planets.end());\n    for (auto p : planets)\n        printf(\"%d %d\\n\", p.first, p.second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> planets;\n\n    if (type == \"single_universe\") {\n        // Generate planets such that there is no empty row or column\n        int k = sqrt(n);\n        if (k * k < n) k++;\n        int x_min = -int(1e9) + 500000;\n        int y_min = -int(1e9) + 500000;\n\n        int count = 0;\n        for (int i = 0; i < k; i++) {\n            int x = x_min + i;\n            for (int j = 0; j < k; j++) {\n                int y = y_min + j;\n                planets.push_back({x, y});\n                count++;\n                if (count == n) break;\n            }\n            if (count == n) break;\n        }\n    }\n    else if (type == \"max_universes\") {\n        // Each planet is in its own universe\n        for (int i = 0; i < n; i++) {\n            int x = int(-1e9) + i * 2;\n            int y = int(-1e9) + i * 2 + 1;\n            planets.push_back({x, y});\n        }\n    }\n    else if (type == \"random\") {\n        // Generate random positions, ensuring uniqueness\n        vector<int> xs, ys;\n        int x_start = -1000000000;\n        int x_end = 1000000000;\n        int y_start = -1000000000;\n        int y_end = 1000000000;\n\n        if (n > x_end - x_start + 1 || n > y_end - y_start + 1) {\n            fprintf(stderr, \"The range of coordinates is too small to generate unique positions for n = %d\\n\", n);\n            exit(1);\n        }\n\n        xs.resize(n);\n        ys.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            xs[i] = x_start + i;\n            ys[i] = y_start + i;\n        }\n\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n\n        for (int i = 0; i < n; i++) {\n            planets.push_back({xs[i], ys[i]});\n        }\n    }\n    else if (type == \"grid\") {\n        // Generate a grid\n        int k = sqrt(n);\n        if (k * k < n) k++;\n        int x_min = -int(1e9) + 500000;\n        int y_min = -int(1e9) + 500000;\n\n        int count = 0;\n        for (int i = 0; i < k; i++) {\n            int x = x_min + i;\n            for (int j = 0; j < k; j++) {\n                int y = y_min + j;\n                planets.push_back({x, y});\n                count++;\n                if (count == n) break;\n            }\n            if (count == n) break;\n        }\n    }\n    else if (type == \"line_x\") {\n        // All x_i = x0\n        int x0 = rnd.next(-int(1e9), int(1e9));\n        int y_start = -int(1e9);\n        int y_end = int(1e9);\n\n        if (n > y_end - y_start + 1) {\n            fprintf(stderr, \"Cannot generate unique y coordinates for n = %d\\n\", n);\n            exit(1);\n        }\n\n        vector<int> y_values;\n        for (int i = 0; i < n; i++) {\n            y_values.push_back(y_start + i);\n        }\n        shuffle(y_values.begin(), y_values.end());\n        for (int i = 0; i < n; i++) {\n            planets.push_back({x0, y_values[i]});\n        }\n    }\n    else if (type == \"line_y\") {\n        // All y_i = y0\n        int y0 = rnd.next(-int(1e9), int(1e9));\n        int x_start = -int(1e9);\n        int x_end = int(1e9);\n\n        if (n > x_end - x_start + 1) {\n            fprintf(stderr, \"Cannot generate unique x coordinates for n = %d\\n\", n);\n            exit(1);\n        }\n\n        vector<int> x_values;\n        for (int i = 0; i < n; i++) {\n            x_values.push_back(x_start + i);\n        }\n        shuffle(x_values.begin(), x_values.end());\n        for (int i = 0; i < n; i++) {\n            planets.push_back({x_values[i], y0});\n        }\n    }\n    else if (type == \"big_coordinates\") {\n        // Coordinates near -1e9 or 1e9\n        int range_min, range_max;\n        if (rnd.next(0, 1)) {\n            range_min = -1000000000;\n            range_max = range_min + n - 1;\n        } else {\n            range_max = 1000000000;\n            range_min = range_max - n + 1;\n        }\n        for (int i = 0; i < n; i++) {\n            int x = range_min + i;\n            int y = range_max - i;\n            planets.push_back({x, y});\n        }\n    }\n    else if (type == \"worst_case\") {\n        // Generate a large chain along y = x\n        for (int i = 0; i < n; i++) {\n            int x = -int(1e9) + i;\n            int y = -int(1e9) + i;\n            planets.push_back({x, y});\n        }\n    }\n    else {\n        // Default to random\n        fprintf(stderr, \"Unknown type '%s', defaulting to 'random'\\n\", type.c_str());\n        // Generate random positions, ensuring uniqueness\n        vector<int> xs, ys;\n        int x_start = -1000000000;\n        int x_end = 1000000000;\n        int y_start = -1000000000;\n        int y_end = 1000000000;\n\n        if (n > x_end - x_start + 1 || n > y_end - y_start + 1) {\n            fprintf(stderr, \"The range of coordinates is too small to generate unique positions for n = %d\\n\", n);\n            exit(1);\n        }\n\n        xs.resize(n);\n        ys.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            xs[i] = x_start + i;\n            ys[i] = y_start + i;\n        }\n\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n\n        for (int i = 0; i < n; i++) {\n            planets.push_back({xs[i], ys[i]});\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Shuffle planets to avoid any ordering\n    shuffle(planets.begin(), planets.end());\n    for (auto p : planets)\n        printf(\"%d %d\\n\", p.first, p.second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_universe\n./gen -n 1 -type max_universes\n\n./gen -n 10 -type single_universe\n./gen -n 10 -type max_universes\n./gen -n 10 -type random\n./gen -n 10 -type grid\n./gen -n 10 -type line_x\n./gen -n 10 -type line_y\n./gen -n 10 -type big_coordinates\n./gen -n 10 -type worst_case\n\n./gen -n 100 -type single_universe\n./gen -n 100 -type max_universes\n./gen -n 100 -type random\n./gen -n 100 -type grid\n./gen -n 100 -type line_x\n./gen -n 100 -type line_y\n./gen -n 100 -type big_coordinates\n./gen -n 100 -type worst_case\n\n./gen -n 1000 -type single_universe\n./gen -n 1000 -type max_universes\n./gen -n 1000 -type random\n./gen -n 1000 -type grid\n./gen -n 1000 -type line_x\n./gen -n 1000 -type line_y\n./gen -n 1000 -type big_coordinates\n./gen -n 1000 -type worst_case\n\n./gen -n 10000 -type single_universe\n./gen -n 10000 -type max_universes\n./gen -n 10000 -type random\n./gen -n 10000 -type grid\n./gen -n 10000 -type line_x\n./gen -n 10000 -type line_y\n./gen -n 10000 -type big_coordinates\n./gen -n 10000 -type worst_case\n\n./gen -n 100000 -type single_universe\n./gen -n 100000 -type max_universes\n./gen -n 100000 -type random\n./gen -n 100000 -type grid\n./gen -n 100000 -type line_x\n./gen -n 100000 -type line_y\n./gen -n 100000 -type big_coordinates\n./gen -n 100000 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:21.593086",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "476/A",
      "title": "A. Dreamoon и ступеньки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано два целых числа через пробел — n, m (0 < n ≤ 10000, 1 < m ≤ 10).",
      "output_spec": "Выходные данныеВыведите единственное число — минимальное количество шагов, кратное m. Если способа взобраться по лестнице, выполнив условие задачи, не существует, выведите  - 1.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 2Выходные данныеСкопировать6Входные данныеСкопировать3 5Выходные данныеСкопировать-1",
      "description": "A. Dreamoon и ступеньки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано два целых числа через пробел — n, m (0 < n ≤ 10000, 1 < m ≤ 10).\n\nВходные данные\n\nВыходные данныеВыведите единственное число — минимальное количество шагов, кратное m. Если способа взобраться по лестнице, выполнив условие задачи, не существует, выведите  - 1.\n\nВыходные данные\n\nВходные данныеСкопировать10 2Выходные данныеСкопировать6Входные данныеСкопировать3 5Выходные данныеСкопировать-1\n\nВходные данныеСкопировать10 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Dreamoon может взойти по лестнице за 6 ходов, совершая следующие шаги: {2, 2, 2, 2, 1, 1}.Во втором примере есть только три подходящих последовательностей шагов {2, 1}, {1, 2}, {1, 1, 1} длины 2, 2, и 3 соответственно. Все эти числа не кратны 5.",
      "solutions": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 476\\s*A"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 10, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 10, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 10, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 10000));\n    int m = opt<int>(\"m\", rnd.next(2, 10));\n\n    // Ensure that n and m are within constraints\n    n = max(1, min(n, 10000));\n    m = max(2, min(m, 10));\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 10000));\n    int m = opt<int>(\"m\", rnd.next(2, 10));\n\n    // Ensure that n and m are within constraints\n    n = max(1, min(n, 10000));\n    m = max(2, min(m, 10));\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2\n./gen -n 1 -m 3\n./gen -n 1 -m 10\n./gen -n 2 -m 2\n./gen -n 3 -m 2\n./gen -n 3 -m 3\n./gen -n 3 -m 4\n./gen -n 7 -m 4\n./gen -n 7 -m 5\n./gen -n 7 -m 8\n./gen -n 9 -m 6\n./gen -n 9 -m 7\n./gen -n 9 -m 8\n./gen -n 9 -m 9\n./gen -n 10 -m 2\n./gen -n 10 -m 7\n./gen -n 10 -m 9\n./gen -n 50 -m 7\n./gen -n 100 -m 3\n./gen -n 100 -m 10\n./gen -n 9999 -m 3\n./gen -n 9999 -m 10\n./gen -n 10000 -m 2\n./gen -n 10000 -m 3\n./gen -n 10000 -m 5\n./gen -n 10000 -m 7\n./gen -n 10000 -m 10\n./gen -n 1 -m 2\n./gen -n 2 -m 4\n./gen -n 5 -m 3\n./gen -n 6 -m 2\n./gen -n 7 -m 2\n./gen -n 10000 -m 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:23.337439",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "476/B",
      "title": "B. Dreamoon and WiFi",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.Lengths of two strings are equal and do not exceed 10.",
      "output_spec": "OutputOutput a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.",
      "sample_tests": "ExamplesInputCopy++-+-+-+-+OutputCopy1.000000000000InputCopy+-+-+-??OutputCopy0.500000000000InputCopy+++??-OutputCopy0.000000000000",
      "description": "B. Dreamoon and WiFi\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.Lengths of two strings are equal and do not exceed 10.\n\nOutputOutput a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.\n\nInputCopy++-+-+-+-+OutputCopy1.000000000000InputCopy+-+-+-??OutputCopy0.500000000000InputCopy+++??-OutputCopy0.000000000000\n\nInputCopy++-+-+-+-+\n\nOutputCopy1.000000000000\n\nInputCopy+-+-+-??\n\nOutputCopy0.500000000000\n\nInputCopy+++??-\n\nOutputCopy0.000000000000\n\nNoteFor the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {\"+-++\", \"+-+-\", \"+--+\", \"+---\"} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.",
      "solutions": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 476\\s*B"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readToken(\"[+-]{1,10}\", \"s1\");\n    inf.readEoln();\n    string s2 = inf.readToken(\"[+-?]{\" + to_string(s1.length()) + \"}\", \"s2\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readToken(\"[+-]{1,10}\", \"s1\");\n    inf.readEoln();\n    string s2 = inf.readToken(\"[+-?]{\" + to_string(s1.length()) + \"}\", \"s2\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readToken(\"[+-]{1,10}\", \"s1\");\n    inf.readEoln();\n    string s2 = inf.readToken(\"[+-?]{\" + to_string(s1.length()) + \"}\", \"s2\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s1(n, ' ');\n    string s2(n, ' ');\n    \n    if (type == \"random\") {\n        string ops = \"+-\";\n        for (int i = 0; i < n; ++i) {\n            s1[i] = ops[rnd.next(2)];\n        }\n        ops = \"+-?\";\n        for (int i = 0; i < n; ++i) {\n            s2[i] = ops[rnd.next(3)];\n        }\n    } else if (type == \"all_plus\") {\n        s1 = string(n, '+');\n        string ops = \"+-?\";\n        for (int i = 0; i < n; ++i) {\n            s2[i] = ops[rnd.next(3)];\n        }\n    } else if (type == \"all_minus\") {\n        s1 = string(n, '-');\n        string ops = \"+-?\";\n        for (int i = 0; i < n; ++i) {\n            s2[i] = ops[rnd.next(3)];\n        }\n    } else if (type == \"impossible\") {\n        s1 = string(n, '+'); // Desired position is n\n        int q = n / 2; // number of '?'\n        s2 = string(n, '-');\n        for (int i = 0; i < q; ++i) {\n            s2[i] = '?';\n        }\n    } else if (type == \"always_correct\") {\n        string ops = \"+-\";\n        for (int i = 0; i < n; ++i) {\n            s1[i] = ops[rnd.next(2)];\n        }\n        s2 = s1;\n    } else if (type == \"float_precision\") {\n        string ops = \"+-\";\n        for (int i = 0; i < n; ++i) {\n            s1[i] = ops[rnd.next(2)];\n        }\n        ops = \"+-?\";\n        for (int i = 0; i < n; ++i) {\n            s2[i] = ops[rnd.next(3)];\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n    \n    cout << s1 << endl;\n    cout << s2 << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s1(n, ' ');\n    string s2(n, ' ');\n    \n    if (type == \"random\") {\n        string ops = \"+-\";\n        for (int i = 0; i < n; ++i) {\n            s1[i] = ops[rnd.next(2)];\n        }\n        ops = \"+-?\";\n        for (int i = 0; i < n; ++i) {\n            s2[i] = ops[rnd.next(3)];\n        }\n    } else if (type == \"all_plus\") {\n        s1 = string(n, '+');\n        string ops = \"+-?\";\n        for (int i = 0; i < n; ++i) {\n            s2[i] = ops[rnd.next(3)];\n        }\n    } else if (type == \"all_minus\") {\n        s1 = string(n, '-');\n        string ops = \"+-?\";\n        for (int i = 0; i < n; ++i) {\n            s2[i] = ops[rnd.next(3)];\n        }\n    } else if (type == \"impossible\") {\n        s1 = string(n, '+'); // Desired position is n\n        int q = n / 2; // number of '?'\n        s2 = string(n, '-');\n        for (int i = 0; i < q; ++i) {\n            s2[i] = '?';\n        }\n    } else if (type == \"always_correct\") {\n        string ops = \"+-\";\n        for (int i = 0; i < n; ++i) {\n            s1[i] = ops[rnd.next(2)];\n        }\n        s2 = s1;\n    } else if (type == \"float_precision\") {\n        string ops = \"+-\";\n        for (int i = 0; i < n; ++i) {\n            s1[i] = ops[rnd.next(2)];\n        }\n        ops = \"+-?\";\n        for (int i = 0; i < n; ++i) {\n            s2[i] = ops[rnd.next(3)];\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n    \n    cout << s1 << endl;\n    cout << s2 << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_plus\n./gen -n 1 -type all_minus\n./gen -n 1 -type impossible\n./gen -n 1 -type always_correct\n./gen -n 1 -type float_precision\n\n./gen -n 2 -type random\n./gen -n 2 -type all_plus\n./gen -n 2 -type all_minus\n./gen -n 2 -type impossible\n./gen -n 2 -type always_correct\n./gen -n 2 -type float_precision\n\n./gen -n 3 -type random\n./gen -n 3 -type float_precision\n\n./gen -n 5 -type random\n./gen -n 5 -type all_plus\n./gen -n 5 -type all_minus\n./gen -n 5 -type impossible\n./gen -n 5 -type always_correct\n./gen -n 5 -type float_precision\n\n./gen -n 7 -type random\n./gen -n 7 -type float_precision\n\n./gen -n 10 -type random\n./gen -n 10 -type all_plus\n./gen -n 10 -type all_minus\n./gen -n 10 -type impossible\n./gen -n 10 -type always_correct\n./gen -n 10 -type float_precision\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:25.625785",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "476/C",
      "title": "C. Dreamoon и суммы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано два целых числа a, b (1 ≤ a, b ≤ 107).",
      "output_spec": "Выходные данныеВыведите единственное целое число — ответ по модулю 1 000 000 007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1Выходные данныеСкопировать0Входные данныеСкопировать2 2Выходные данныеСкопировать8",
      "description": "C. Dreamoon и суммы\n\nограничение по времени на тест1.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано два целых числа a, b (1 ≤ a, b ≤ 107).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — ответ по модулю 1 000 000 007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать1 1Выходные данныеСкопировать0Входные данныеСкопировать2 2Выходные данныеСкопировать8\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере нет милых чисел, так как  всегда равняется нулю.Во втором примере милые числа это: {3, 5}.",
      "solutions": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 476\\s*C"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> ab = inf.readInts(2, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> ab = inf.readInts(2, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> ab = inf.readInts(2, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters from command line\n    string type = opt<string>(\"type\", \"random\");\n    int max_a = opt<int>(\"max_a\", 10000000);\n    int max_b = opt<int>(\"max_b\", 10000000);\n\n    int a, b;\n\n    if (type == \"min\") {\n        // Minimal values\n        a = 1;\n        b = 1;\n    } else if (type == \"max\") {\n        // Maximal values\n        a = max_a;\n        b = max_b;\n    } else if (type == \"random\") {\n        // Random values within [1, max_a] and [1, max_b]\n        a = rnd.next(1, max_a);\n        b = rnd.next(1, max_b);\n    } else if (type == \"a_small\") {\n        // a is small, b is large\n        a = rnd.next(1, 100);\n        b = rnd.next(max_b / 2, max_b);\n    } else if (type == \"b_small\") {\n        // a is large, b is small\n        a = rnd.next(max_a / 2, max_a);\n        b = rnd.next(1, 100);\n    } else if (type == \"equal\") {\n        // a equals b, both random\n        int val = rnd.next(1, min(max_a, max_b));\n        a = val;\n        b = val;\n    } else if (type == \"power_of_two\") {\n        // a and b are powers of two\n        int max_pow = 24; // 2^24 ~ 16 million\n        int pow_a = rnd.next(0, max_pow);\n        int pow_b = rnd.next(0, max_pow);\n        a = (1 << pow_a);\n        b = (1 << pow_b);\n        a = min(a, max_a);\n        b = min(b, max_b);\n        if (a < 1) a = 1;\n        if (b < 1) b = 1;\n    } else if (type == \"custom\") {\n        // Custom values of a and b\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n        if (a < 1 || a > max_a || b <1 || b > max_b) {\n            cerr << \"Invalid values of a or b\" << endl;\n            exit(1);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters from command line\n    string type = opt<string>(\"type\", \"random\");\n    int max_a = opt<int>(\"max_a\", 10000000);\n    int max_b = opt<int>(\"max_b\", 10000000);\n\n    int a, b;\n\n    if (type == \"min\") {\n        // Minimal values\n        a = 1;\n        b = 1;\n    } else if (type == \"max\") {\n        // Maximal values\n        a = max_a;\n        b = max_b;\n    } else if (type == \"random\") {\n        // Random values within [1, max_a] and [1, max_b]\n        a = rnd.next(1, max_a);\n        b = rnd.next(1, max_b);\n    } else if (type == \"a_small\") {\n        // a is small, b is large\n        a = rnd.next(1, 100);\n        b = rnd.next(max_b / 2, max_b);\n    } else if (type == \"b_small\") {\n        // a is large, b is small\n        a = rnd.next(max_a / 2, max_a);\n        b = rnd.next(1, 100);\n    } else if (type == \"equal\") {\n        // a equals b, both random\n        int val = rnd.next(1, min(max_a, max_b));\n        a = val;\n        b = val;\n    } else if (type == \"power_of_two\") {\n        // a and b are powers of two\n        int max_pow = 24; // 2^24 ~ 16 million\n        int pow_a = rnd.next(0, max_pow);\n        int pow_b = rnd.next(0, max_pow);\n        a = (1 << pow_a);\n        b = (1 << pow_b);\n        a = min(a, max_a);\n        b = min(b, max_b);\n        if (a < 1) a = 1;\n        if (b < 1) b = 1;\n    } else if (type == \"custom\") {\n        // Custom values of a and b\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n        if (a < 1 || a > max_a || b <1 || b > max_b) {\n            cerr << \"Invalid values of a or b\" << endl;\n            exit(1);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type random -max_a 10 -max_b 10\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type a_small\n./gen -type b_small\n./gen -type equal\n./gen -type power_of_two\n./gen -type power_of_two\n./gen -type power_of_two\n./gen -type custom -a 1 -b 2\n./gen -type custom -a 2 -b 1\n./gen -type custom -a 1 -b 10000000\n./gen -type custom -a 10000000 -b 1\n./gen -type custom -a 9999999 -b 9999999\n./gen -type custom -a 100 -b 100\n./gen -type custom -a 1000 -b 1000\n./gen -type custom -a 10000 -b 5000\n./gen -type custom -a 5000 -b 10000\n./gen -type custom -a 1234567 -b 7654321\n./gen -type custom -a 10000000 -b 10000000\n./gen -type custom -a 5000000 -b 5000000\n./gen -type custom -a 10000000 -b 9999999\n./gen -type custom -a 9999999 -b 10000000\n./gen -type custom -a 99999 -b 99998\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:27.601316",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "476/D",
      "title": "D. Dreamoon and Sets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains two space separated integers n, k (1 ≤ n ≤ 10 000, 1 ≤ k ≤ 100).",
      "output_spec": "OutputOn the first line print a single integer — the minimal possible m. On each of the next n lines print four space separated integers representing the i-th set.Neither the order of the sets nor the order of integers within a set is important. If there are multiple possible solutions with minimal m, print any one of them.",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy51 2 3 5InputCopy2 2OutputCopy222 4 6 2214 18 10 16",
      "description": "D. Dreamoon and Sets\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains two space separated integers n, k (1 ≤ n ≤ 10 000, 1 ≤ k ≤ 100).\n\nOutputOn the first line print a single integer — the minimal possible m. On each of the next n lines print four space separated integers representing the i-th set.Neither the order of the sets nor the order of integers within a set is important. If there are multiple possible solutions with minimal m, print any one of them.\n\nInputCopy1 1OutputCopy51 2 3 5InputCopy2 2OutputCopy222 4 6 2214 18 10 16\n\nInputCopy1 1\n\nOutputCopy51 2 3 5\n\nInputCopy2 2\n\nOutputCopy222 4 6 2214 18 10 16\n\nNoteFor the first example it's easy to see that set {1, 2, 3, 4} isn't a valid set of rank 1 since .",
      "solutions": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 476\\s*D"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {\n    while(b) {\n        int t = a%b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // read n from input\n    int k = inf.readInt(); // read k from input\n\n    int m_jury = ans.readInt(); // read m from jury's answer\n    int m_contestant = ouf.readInt(); // read m from contestant's output\n\n    if (m_contestant != m_jury) {\n        quitf(_wa, \"Contestant's m is not minimal, expected m=%d, found m=%d\", m_jury, m_contestant);\n    }\n\n    set<int> used_numbers;\n    for (int i = 1; i <= n; i++) {\n        vector<int> s;\n        for (int j = 1; j <= 4; j++) {\n            int x = ouf.readInt(1, m_contestant, format(\"number in set %d position %d\", i, j).c_str());\n            s.push_back(x);\n        }\n        // Check that elements are distinct\n        set<int> s_set(s.begin(), s.end());\n        if ((int)s_set.size() != 4) {\n            quitf(_wa, \"Set %d does not contain 4 distinct integers\", i);\n        }\n        // Check that numbers have not been used before\n        for (int x : s) {\n            if (used_numbers.count(x)) {\n                quitf(_wa, \"Number %d is used in more than one set\", x);\n            }\n            used_numbers.insert(x);\n        }\n        // Check that gcd of every pair equals k\n        for (int p = 0; p < 4; p++) {\n            for (int q = p+1; q < 4; q++) {\n                if (gcd(s[p], s[q]) != k) {\n                    quitf(_wa, \"GCD of %d and %d in set %d is not equal to k=%d\", s[p], s[q], i, k);\n                }\n            }\n        }\n    }\n\n    quitf(_ok, \"Answer is correct.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n\") {\n        n = 1;\n        if (k == -1) k = rnd.next(1, 100);\n    } else if (type == \"max_n\") {\n        n = 10000;\n        if (k == -1) k = rnd.next(1, 100);\n    } else if (type == \"min_k\") {\n        k = 1;\n        if (n == -1) n = rnd.next(1, 10000);\n    } else if (type == \"max_k\") {\n        k = 100;\n        if (n == -1) n = rnd.next(1, 10000);\n    } else if (type == \"special\") {\n        // Special cases to check for potential contestant mistakes\n        n = 10000;\n        k = 1;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 10000);\n        if (k == -1) k = rnd.next(1, 100);\n    } else {\n        // If type is not recognized, default to random generation\n        if (n == -1) n = rnd.next(1, 10000);\n        if (k == -1) k = rnd.next(1, 100);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n\") {\n        n = 1;\n        if (k == -1) k = rnd.next(1, 100);\n    } else if (type == \"max_n\") {\n        n = 10000;\n        if (k == -1) k = rnd.next(1, 100);\n    } else if (type == \"min_k\") {\n        k = 1;\n        if (n == -1) n = rnd.next(1, 10000);\n    } else if (type == \"max_k\") {\n        k = 100;\n        if (n == -1) n = rnd.next(1, 10000);\n    } else if (type == \"special\") {\n        // Special cases to check for potential contestant mistakes\n        n = 10000;\n        k = 1;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 10000);\n        if (k == -1) k = rnd.next(1, 100);\n    } else {\n        // If type is not recognized, default to random generation\n        if (n == -1) n = rnd.next(1, 10000);\n        if (k == -1) k = rnd.next(1, 100);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n\n./gen -type min_n\n\n# Maximal n\n./gen -type max_n\n\n# Minimal k\n./gen -type min_k\n\n# Maximal k\n./gen -type max_k\n\n# Special cases to test potential issues\n./gen -type special\n./gen -type special -n 10000 -k 100\n./gen -type special -n 9999 -k 99\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Fixed n values with random k\n./gen -n 1\n./gen -n 10\n./gen -n 100\n./gen -n 1000\n./gen -n 10000\n\n# Fixed k values with random n\n./gen -k 1\n./gen -k 2\n./gen -k 50\n./gen -k 99\n./gen -k 100\n\n# Fixed n and k values\n./gen -n 10000 -k 1\n./gen -n 10000 -k 100\n./gen -n 1 -k 1\n./gen -n 1 -k 100\n./gen -n 5000 -k 50\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:30.113641",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "476/E",
      "title": "E. Dreamoon and Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains the string s (1 ≤ |s| ≤ 2 000).The second line of the input contains the string p (1 ≤ |p| ≤ 500).Both strings will only consist of lower case English letters.",
      "output_spec": "OutputPrint |s| + 1 space-separated integers in a single line representing the  for all x from 0 to |s|.",
      "sample_tests": "ExamplesInputCopyaaaaaaaOutputCopy2 2 1 1 0 0InputCopyaxbaxxbabOutputCopy0 1 1 2 1 1 0 0",
      "description": "E. Dreamoon and Strings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains the string s (1 ≤ |s| ≤ 2 000).The second line of the input contains the string p (1 ≤ |p| ≤ 500).Both strings will only consist of lower case English letters.\n\nOutputPrint |s| + 1 space-separated integers in a single line representing the  for all x from 0 to |s|.\n\nInputCopyaaaaaaaOutputCopy2 2 1 1 0 0InputCopyaxbaxxbabOutputCopy0 1 1 2 1 1 0 0\n\nInputCopyaaaaaaa\n\nOutputCopy2 2 1 1 0 0\n\nInputCopyaxbaxxbab\n\nOutputCopy0 1 1 2 1 1 0 0\n\nNoteFor the first sample, the corresponding optimal values of s' after removal 0 through |s| = 5 characters from s are {\"aaaaa\", \"aaaa\", \"aaa\", \"aa\", \"a\", \"\"}. For the second sample, possible corresponding optimal values of s' are {\"axbaxxb\", \"abaxxb\", \"axbab\", \"abab\", \"aba\", \"ab\", \"a\", \"\"}.",
      "solutions": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 476\\s*E"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,2000}\", \"s\");\n    inf.readEoln();\n\n    string p = inf.readToken(\"[a-z]{1,500}\", \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,2000}\", \"s\");\n    inf.readEoln();\n\n    string p = inf.readToken(\"[a-z]{1,500}\", \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,2000}\", \"s\");\n    inf.readEoln();\n\n    string p = inf.readToken(\"[a-z]{1,500}\", \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_string(int len) {\n    string s;\n    for (int i = 0; i < len; ++i)\n        s += (char)('a' + rnd.next(26));\n    return s;\n}\n\nstring identical_char_string(int len) {\n    char c = (char)('a' + rnd.next(26));\n    return string(len, c);\n}\n\nstring no_match_string(int len, string exclude_chars) {\n    string chars;\n    for (char c = 'a'; c <= 'z'; ++c)\n        if (exclude_chars.find(c) == string::npos)\n            chars += c;\n    if (chars.empty()) {\n        // If exclude_chars is the whole alphabet, default to 'a'\n        chars = \"a\";\n    }\n    string s;\n    for (int i = 0; i < len; ++i)\n        s += chars[rnd.next(chars.size())];\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"t\", \"random\");\n\n    string s, p;\n\n    if (type == \"random\") {\n        s = random_string(n);\n        p = random_string(m);\n    } else if (type == \"identical_chars\") {\n        s = identical_char_string(n);\n        p = identical_char_string(m);\n    } else if (type == \"no_match\") {\n        string exclude_chars_s = \"\";\n        string exclude_chars_p = \"\";\n        // Exclude half the alphabet for s, the other half for p\n        for (int i = 0; i < 13; ++i)\n            exclude_chars_p += (char)('a' + i);\n        for (int i = 13; i < 26; ++i)\n            exclude_chars_s += (char)('a' + i);\n        s = no_match_string(n, exclude_chars_s);\n        p = no_match_string(m, exclude_chars_p);\n    } else if (type == \"full_match\") {\n        p = random_string(m);\n        int repeats = (n + m - 1) / m;\n        s = \"\";\n        for (int i = 0; i < repeats; ++i)\n            s += p;\n        if ((int)s.size() > n)\n            s = s.substr(0, n);\n    } else if (type == \"partial_match\") {\n        p = random_string(m);\n        s = random_string(n);\n        int positions = min(n / m, 10); // limit to 10 positions\n        for (int i = 0; i < positions; ++i) {\n            int pos = rnd.next(0, n - m);\n            s.replace(pos, m, p);\n        }\n    } else if (type == \"overlapping\") {\n        p = random_string(m);\n        s = p;\n        int overlap_size = m - 1;\n        while ((int)s.length() < n) {\n            s += p.substr(overlap_size);\n        }\n        if ((int)s.length() > n)\n            s = s.substr(0, n);\n    } else if (type == \"palindrome\") {\n        string half = random_string(n / 2);\n        s = half;\n        if (n % 2 == 1)\n            s += (char)('a' + rnd.next(26));\n        reverse(half.begin(), half.end());\n        s += half;\n        p = random_string(m);\n    } else {\n        // default to random\n        s = random_string(n);\n        p = random_string(m);\n    }\n\n    // Truncate s and p to satisfy the length constraints\n    if ((int)s.length() > n)\n        s = s.substr(0, n);\n    if ((int)p.length() > m)\n        p = p.substr(0, m);\n\n    // Output s and p\n    cout << s << endl;\n    cout << p << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_string(int len) {\n    string s;\n    for (int i = 0; i < len; ++i)\n        s += (char)('a' + rnd.next(26));\n    return s;\n}\n\nstring identical_char_string(int len) {\n    char c = (char)('a' + rnd.next(26));\n    return string(len, c);\n}\n\nstring no_match_string(int len, string exclude_chars) {\n    string chars;\n    for (char c = 'a'; c <= 'z'; ++c)\n        if (exclude_chars.find(c) == string::npos)\n            chars += c;\n    if (chars.empty()) {\n        // If exclude_chars is the whole alphabet, default to 'a'\n        chars = \"a\";\n    }\n    string s;\n    for (int i = 0; i < len; ++i)\n        s += chars[rnd.next(chars.size())];\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"t\", \"random\");\n\n    string s, p;\n\n    if (type == \"random\") {\n        s = random_string(n);\n        p = random_string(m);\n    } else if (type == \"identical_chars\") {\n        s = identical_char_string(n);\n        p = identical_char_string(m);\n    } else if (type == \"no_match\") {\n        string exclude_chars_s = \"\";\n        string exclude_chars_p = \"\";\n        // Exclude half the alphabet for s, the other half for p\n        for (int i = 0; i < 13; ++i)\n            exclude_chars_p += (char)('a' + i);\n        for (int i = 13; i < 26; ++i)\n            exclude_chars_s += (char)('a' + i);\n        s = no_match_string(n, exclude_chars_s);\n        p = no_match_string(m, exclude_chars_p);\n    } else if (type == \"full_match\") {\n        p = random_string(m);\n        int repeats = (n + m - 1) / m;\n        s = \"\";\n        for (int i = 0; i < repeats; ++i)\n            s += p;\n        if ((int)s.size() > n)\n            s = s.substr(0, n);\n    } else if (type == \"partial_match\") {\n        p = random_string(m);\n        s = random_string(n);\n        int positions = min(n / m, 10); // limit to 10 positions\n        for (int i = 0; i < positions; ++i) {\n            int pos = rnd.next(0, n - m);\n            s.replace(pos, m, p);\n        }\n    } else if (type == \"overlapping\") {\n        p = random_string(m);\n        s = p;\n        int overlap_size = m - 1;\n        while ((int)s.length() < n) {\n            s += p.substr(overlap_size);\n        }\n        if ((int)s.length() > n)\n            s = s.substr(0, n);\n    } else if (type == \"palindrome\") {\n        string half = random_string(n / 2);\n        s = half;\n        if (n % 2 == 1)\n            s += (char)('a' + rnd.next(26));\n        reverse(half.begin(), half.end());\n        s += half;\n        p = random_string(m);\n    } else {\n        // default to random\n        s = random_string(n);\n        p = random_string(m);\n    }\n\n    // Truncate s and p to satisfy the length constraints\n    if ((int)s.length() > n)\n        s = s.substr(0, n);\n    if ((int)p.length() > m)\n        p = p.substr(0, m);\n\n    // Output s and p\n    cout << s << endl;\n    cout << p << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -t random\n./gen -n 2000 -m 500 -t random\n./gen -n 1 -m 500 -t random\n./gen -n 2000 -m 1 -t random\n./gen -n 2000 -m 500 -t identical_chars\n./gen -n 2000 -m 500 -t no_match\n./gen -n 2000 -m 500 -t full_match\n./gen -n 2000 -m 500 -t overlapping\n./gen -n 1999 -m 500 -t overlapping\n./gen -n 2000 -m 500 -t palindrome\n./gen -n 2000 -m 500 -t partial_match\n./gen -n 1500 -m 500 -t random\n./gen -n 1500 -m 400 -t identical_chars\n./gen -n 1500 -m 100 -t no_match\n./gen -n 1500 -m 200 -t full_match\n./gen -n 1500 -m 250 -t overlapping\n./gen -n 1500 -m 300 -t palindrome\n./gen -n 1000 -m 500 -t random\n./gen -n 1000 -m 500 -t overlapping\n./gen -n 1000 -m 500 -t identical_chars\n./gen -n 10 -m 5 -t random\n./gen -n 10 -m 3 -t full_match\n./gen -n 10 -m 1 -t overlapping\n./gen -n 500 -m 1 -t identical_chars\n./gen -n 500 -m 1 -t random\n./gen -n 500 -m 1 -t no_match\n./gen -n 2000 -m 500 -t partial_match\n./gen -n 1999 -m 499 -t partial_match\n./gen -n 2000 -m 500 -t unknown_type\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:32.280938",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "477/A",
      "title": "A. Dreamoon and Sums",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains two integers a, b (1 ≤ a, b ≤ 107).",
      "output_spec": "OutputPrint a single integer representing the answer modulo 1 000 000 007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy0InputCopy2 2OutputCopy8",
      "description": "A. Dreamoon and Sums\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains two integers a, b (1 ≤ a, b ≤ 107).\n\nOutputPrint a single integer representing the answer modulo 1 000 000 007 (109 + 7).\n\nInputCopy1 1OutputCopy0InputCopy2 2OutputCopy8\n\nInputCopy1 1\n\nOutputCopy0\n\nInputCopy2 2\n\nOutputCopy8\n\nNoteFor the first sample, there are no nice integers because  is always zero.For the second sample, the set of nice integers is {3, 5}.",
      "solutions": [
        {
          "title": "Codeforces Round #272 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #272 will be held at this local time. We're looking forward to your participation!The problems are from dreamoon_love_AA and drazil(that's me) from Taiwan, and thanks 9mmlitswe for some discussion. Also we want to thank Zlobober and Gerald for helping us prepare the round, Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is our first round on Codeforces, we hope you'll find it interesting! Please read all problem statements and discover what the main character dreamoon_love_AA do in those problems for he's really cute =)Update1 Note this round will be held 1.5hrs earlier than usual Codeforces rounds, so please double check the starting time in your local time.Update2 Score distribution! Div2: 500-1500-1500-2000-2500 Div1: 500-1000-1500-2000-3000Update3 The contests are over. Congratulations to the winners!Div1: 1. Petr 2. qwer1561 3. kutengine 4. ifsmirnov 5. TankEngineerDiv2: 1. ridowan007 2. a00012025 3. xavier13540 4. v_Enhance 5. pkq2006And standings are here: Div1: результаты Div2: результатыUpdate4 Editorial can be found here. It's finished by now but it's welcome to tell me if anything can be improved!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14228",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1214
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 477\\s*A"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 - Codeforces - Code 1",
          "code": "Failure is the pillar of success",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 2",
          "code": "for (mod = 1; mod < b; mod++) \nres += mod * b * a(a+1)/2  + mod * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 3",
          "code": "for (mod = 1; mod < b; mod++) \nres += mod * b * a(a+1)/2  + mod * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 4",
          "code": "sum*((a*b)%MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 5",
          "code": "sum %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 6",
          "code": "((sum*i)%mod)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 7",
          "code": "ll sum = (double)(1+a) / 2 * a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 8",
          "code": "ll sum = (double)(1+a) / 2 * a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 9",
          "code": "(ll)(a+1)*a/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 10",
          "code": "res = (res + ((sum*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 11",
          "code": "res = (res + ((sum*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 12",
          "code": "res = (res + (((sum%MOD)*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 13",
          "code": "res = (res + (((sum%MOD)*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 14",
          "code": "x = q*b+r ---(1)\nand q/r = k\n or q = rk;\nput this in 1\nx = brk+r = r(bk+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 15",
          "code": "x = q*b+r ---(1)\nand q/r = k\n or q = rk;\nput this in 1\nx = brk+r = r(bk+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 16",
          "code": "1(bk+1) + 2(bk+1) +3(bk+1)... (b-1)(bk+1)\n=(bk+1)(1+2+..b-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 17",
          "code": "1(bk+1) + 2(bk+1) +3(bk+1)... (b-1)(bk+1)\n=(bk+1)(1+2+..b-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 18",
          "code": "sum = 0;\nfor(k=1;k<=a;++k)\n{\n   sum+=b*(b-1)/2 * (bk+1)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 19",
          "code": "sum = 0;\nfor(k=1;k<=a;++k)\n{\n   sum+=b*(b-1)/2 * (bk+1)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 20",
          "code": "Sn = (n/2) * ( 2*a + ( n - 1 ) * d )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 21",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"%d\",sizeof(long double));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 22",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"%d\",sizeof(long double));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 23",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"test....it's ok?\\n\");\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 24",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"test....it's ok?\\n\");\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 25",
          "code": "((b % mod) * (sum2 % mod) * (sum1 % mod))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 26",
          "code": "const int N = 2e3 + 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 27",
          "code": "const int N = 2e3 + 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 28",
          "code": "const int N = 2e3 + 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 29",
          "code": "const int N = 2e3 + 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 30",
          "code": "dp[i][cut] = dp[i-1][cut];\nif (cut > 0) \n\tdp[i][cut] = max(dp[i][cut], dp[i-1][cut-1]);\nfor (int k = L[i]; k <= cut + p.length(); ++k) \n\tdp[i][cut] = max(dp[i][cut], dp[i - k][cut - k + p.length()] + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 31",
          "code": "dp[i][cut] = dp[i-1][cut];\nif (cut > 0) \n\tdp[i][cut] = max(dp[i][cut], dp[i-1][cut-1]);\nfor (int k = L[i]; k <= cut + p.length(); ++k) \n\tdp[i][cut] = max(dp[i][cut], dp[i - k][cut - k + p.length()] + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 32",
          "code": "cut - k + p.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 33",
          "code": "i - cut - p.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 34",
          "code": "ftr[i + cut][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 35",
          "code": "dp[i][cut] = max(dp[i][cut], get(ftr[i - cut - p.length()], i - k) + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> nums = inf.readInts(2, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> nums = inf.readInts(2, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> nums = inf.readInts(2, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    const int MIN_AB = 1;\n    const int MAX_AB = 10000000;\n\n    // Parse command-line options\n    string type = opt<string>(\"type\", \"random\");\n    int a_given = opt<int>(\"a\", -1);\n    int b_given = opt<int>(\"b\", -1);\n\n    int a, b;\n\n    if (a_given != -1 && b_given != -1) {\n        // Use provided values for a and b\n        a = a_given;\n        b = b_given;\n    } else {\n        if (type == \"min\") {\n            // Minimum values of a and b\n            a = b = MIN_AB;\n        } else if (type == \"max\") {\n            // Maximum values of a and b\n            a = b = MAX_AB;\n        } else if (type == \"equal_small\") {\n            // Equal small values of a and b\n            a = b = rnd.next(MIN_AB, 100);\n        } else if (type == \"equal_large\") {\n            // Equal large values of a and b\n            a = b = rnd.next(1000000, MAX_AB);\n        } else if (type == \"random_small\") {\n            // Random small values of a and b\n            a = rnd.next(MIN_AB, 1000);\n            b = rnd.next(MIN_AB, 1000);\n        } else if (type == \"random_large\") {\n            // Random large values of a and b\n            a = rnd.next(1000000, MAX_AB);\n            b = rnd.next(1000000, MAX_AB);\n        } else if (type == \"one_large\") {\n            // One large and one small value\n            if (rnd.next(0, 1) == 0) {\n                a = MAX_AB;\n                b = rnd.next(MIN_AB, 1000);\n            } else {\n                a = rnd.next(MIN_AB, 1000);\n                b = MAX_AB;\n            }\n        } else if (type == \"one_small\") {\n            // One small and one large value\n            if (rnd.next(0, 1) == 0) {\n                a = MIN_AB;\n                b = rnd.next(1000000, MAX_AB);\n            } else {\n                a = rnd.next(1000000, MAX_AB);\n                b = MIN_AB;\n            }\n        } else if (type == \"a_greater_b\") {\n            // a is greater than b\n            b = rnd.next(MIN_AB, MAX_AB / 2);\n            a = rnd.next(b + 1, MAX_AB);\n        } else if (type == \"b_greater_a\") {\n            // b is greater than a\n            a = rnd.next(MIN_AB, MAX_AB / 2);\n            b = rnd.next(a + 1, MAX_AB);\n        } else {\n            // Completely random values of a and b\n            a = rnd.next(MIN_AB, MAX_AB);\n            b = rnd.next(MIN_AB, MAX_AB);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    const int MIN_AB = 1;\n    const int MAX_AB = 10000000;\n\n    // Parse command-line options\n    string type = opt<string>(\"type\", \"random\");\n    int a_given = opt<int>(\"a\", -1);\n    int b_given = opt<int>(\"b\", -1);\n\n    int a, b;\n\n    if (a_given != -1 && b_given != -1) {\n        // Use provided values for a and b\n        a = a_given;\n        b = b_given;\n    } else {\n        if (type == \"min\") {\n            // Minimum values of a and b\n            a = b = MIN_AB;\n        } else if (type == \"max\") {\n            // Maximum values of a and b\n            a = b = MAX_AB;\n        } else if (type == \"equal_small\") {\n            // Equal small values of a and b\n            a = b = rnd.next(MIN_AB, 100);\n        } else if (type == \"equal_large\") {\n            // Equal large values of a and b\n            a = b = rnd.next(1000000, MAX_AB);\n        } else if (type == \"random_small\") {\n            // Random small values of a and b\n            a = rnd.next(MIN_AB, 1000);\n            b = rnd.next(MIN_AB, 1000);\n        } else if (type == \"random_large\") {\n            // Random large values of a and b\n            a = rnd.next(1000000, MAX_AB);\n            b = rnd.next(1000000, MAX_AB);\n        } else if (type == \"one_large\") {\n            // One large and one small value\n            if (rnd.next(0, 1) == 0) {\n                a = MAX_AB;\n                b = rnd.next(MIN_AB, 1000);\n            } else {\n                a = rnd.next(MIN_AB, 1000);\n                b = MAX_AB;\n            }\n        } else if (type == \"one_small\") {\n            // One small and one large value\n            if (rnd.next(0, 1) == 0) {\n                a = MIN_AB;\n                b = rnd.next(1000000, MAX_AB);\n            } else {\n                a = rnd.next(1000000, MAX_AB);\n                b = MIN_AB;\n            }\n        } else if (type == \"a_greater_b\") {\n            // a is greater than b\n            b = rnd.next(MIN_AB, MAX_AB / 2);\n            a = rnd.next(b + 1, MAX_AB);\n        } else if (type == \"b_greater_a\") {\n            // b is greater than a\n            a = rnd.next(MIN_AB, MAX_AB / 2);\n            b = rnd.next(a + 1, MAX_AB);\n        } else {\n            // Completely random values of a and b\n            a = rnd.next(MIN_AB, MAX_AB);\n            b = rnd.next(MIN_AB, MAX_AB);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -type equal_small\n./gen -type equal_small\n./gen -type equal_small\n\n./gen -type equal_large\n./gen -type equal_large\n./gen -type equal_large\n\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n./gen -type one_large\n./gen -type one_large\n./gen -type one_large\n\n./gen -type one_small\n./gen -type one_small\n./gen -type one_small\n\n./gen -type a_greater_b\n./gen -type a_greater_b\n./gen -type a_greater_b\n\n./gen -type b_greater_a\n./gen -type b_greater_a\n./gen -type b_greater_a\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -a 1 -b 1\n./gen -a 10000000 -b 10000000\n./gen -a 1 -b 10000000\n./gen -a 10000000 -b 1\n./gen -a 5000000 -b 5000000\n./gen -a 9999999 -b 9999999\n./gen -a 1234567 -b 7654321\n./gen -a 7654321 -b 1234567\n./gen -a 10 -b 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:34.301571",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "477/B",
      "title": "B. Dreamoon and Sets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains two space separated integers n, k (1 ≤ n ≤ 10 000, 1 ≤ k ≤ 100).",
      "output_spec": "OutputOn the first line print a single integer — the minimal possible m. On each of the next n lines print four space separated integers representing the i-th set.Neither the order of the sets nor the order of integers within a set is important. If there are multiple possible solutions with minimal m, print any one of them.",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy51 2 3 5InputCopy2 2OutputCopy222 4 6 2214 18 10 16",
      "description": "B. Dreamoon and Sets\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains two space separated integers n, k (1 ≤ n ≤ 10 000, 1 ≤ k ≤ 100).\n\nOutputOn the first line print a single integer — the minimal possible m. On each of the next n lines print four space separated integers representing the i-th set.Neither the order of the sets nor the order of integers within a set is important. If there are multiple possible solutions with minimal m, print any one of them.\n\nInputCopy1 1OutputCopy51 2 3 5InputCopy2 2OutputCopy222 4 6 2214 18 10 16\n\nInputCopy1 1\n\nOutputCopy51 2 3 5\n\nInputCopy2 2\n\nOutputCopy222 4 6 2214 18 10 16\n\nNoteFor the first example it's easy to see that set {1, 2, 3, 4} isn't a valid set of rank 1 since .",
      "solutions": [
        {
          "title": "Codeforces Round #272 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #272 will be held at this local time. We're looking forward to your participation!The problems are from dreamoon_love_AA and drazil(that's me) from Taiwan, and thanks 9mmlitswe for some discussion. Also we want to thank Zlobober and Gerald for helping us prepare the round, Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is our first round on Codeforces, we hope you'll find it interesting! Please read all problem statements and discover what the main character dreamoon_love_AA do in those problems for he's really cute =)Update1 Note this round will be held 1.5hrs earlier than usual Codeforces rounds, so please double check the starting time in your local time.Update2 Score distribution! Div2: 500-1500-1500-2000-2500 Div1: 500-1000-1500-2000-3000Update3 The contests are over. Congratulations to the winners!Div1: 1. Petr 2. qwer1561 3. kutengine 4. ifsmirnov 5. TankEngineerDiv2: 1. ridowan007 2. a00012025 3. xavier13540 4. v_Enhance 5. pkq2006And standings are here: Div1: результаты Div2: результатыUpdate4 Editorial can be found here. It's finished by now but it's welcome to tell me if anything can be improved!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14228",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1214
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 477\\s*B"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 - Codeforces - Code 1",
          "code": "Failure is the pillar of success",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 2",
          "code": "for (mod = 1; mod < b; mod++) \nres += mod * b * a(a+1)/2  + mod * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 3",
          "code": "for (mod = 1; mod < b; mod++) \nres += mod * b * a(a+1)/2  + mod * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 4",
          "code": "sum*((a*b)%MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 5",
          "code": "sum %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 6",
          "code": "((sum*i)%mod)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 7",
          "code": "ll sum = (double)(1+a) / 2 * a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 8",
          "code": "ll sum = (double)(1+a) / 2 * a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 9",
          "code": "(ll)(a+1)*a/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 10",
          "code": "res = (res + ((sum*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 11",
          "code": "res = (res + ((sum*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 12",
          "code": "res = (res + (((sum%MOD)*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 13",
          "code": "res = (res + (((sum%MOD)*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 14",
          "code": "x = q*b+r ---(1)\nand q/r = k\n or q = rk;\nput this in 1\nx = brk+r = r(bk+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 15",
          "code": "x = q*b+r ---(1)\nand q/r = k\n or q = rk;\nput this in 1\nx = brk+r = r(bk+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 16",
          "code": "1(bk+1) + 2(bk+1) +3(bk+1)... (b-1)(bk+1)\n=(bk+1)(1+2+..b-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 17",
          "code": "1(bk+1) + 2(bk+1) +3(bk+1)... (b-1)(bk+1)\n=(bk+1)(1+2+..b-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 18",
          "code": "sum = 0;\nfor(k=1;k<=a;++k)\n{\n   sum+=b*(b-1)/2 * (bk+1)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 19",
          "code": "sum = 0;\nfor(k=1;k<=a;++k)\n{\n   sum+=b*(b-1)/2 * (bk+1)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 20",
          "code": "Sn = (n/2) * ( 2*a + ( n - 1 ) * d )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 21",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"%d\",sizeof(long double));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 22",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"%d\",sizeof(long double));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 23",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"test....it's ok?\\n\");\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 24",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"test....it's ok?\\n\");\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 25",
          "code": "((b % mod) * (sum2 % mod) * (sum1 % mod))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 26",
          "code": "const int N = 2e3 + 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 27",
          "code": "const int N = 2e3 + 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 28",
          "code": "const int N = 2e3 + 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 29",
          "code": "const int N = 2e3 + 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 30",
          "code": "dp[i][cut] = dp[i-1][cut];\nif (cut > 0) \n\tdp[i][cut] = max(dp[i][cut], dp[i-1][cut-1]);\nfor (int k = L[i]; k <= cut + p.length(); ++k) \n\tdp[i][cut] = max(dp[i][cut], dp[i - k][cut - k + p.length()] + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 31",
          "code": "dp[i][cut] = dp[i-1][cut];\nif (cut > 0) \n\tdp[i][cut] = max(dp[i][cut], dp[i-1][cut-1]);\nfor (int k = L[i]; k <= cut + p.length(); ++k) \n\tdp[i][cut] = max(dp[i][cut], dp[i - k][cut - k + p.length()] + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 32",
          "code": "cut - k + p.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 33",
          "code": "i - cut - p.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 34",
          "code": "ftr[i + cut][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 35",
          "code": "dp[i][cut] = max(dp[i][cut], get(ftr[i - cut - p.length()], i - k) + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(); // n is the number of sets\n    int k = inf.readInt(); // k is the required gcd for each pair in a set\n\n    int m_jury = ans.readInt(); // minimal possible m from the jury's answer\n    int m_part = ouf.readInt(1, INT_MAX, \"m\"); // m provided by participant\n\n    if (m_part != m_jury) {\n        quitf(_wa, \"m is not minimal, expected m = %d, found m = %d\", m_jury, m_part);\n    }\n\n    set<int> used_numbers; // to keep track of integers used across all sets\n\n    for (int i = 1; i <= n; i++) {\n        vector<int> s = ouf.readInts(4, 1, m_part, format(\"set %d\", i).c_str());\n\n        // Check that all integers in the set are distinct\n        set<int> s_set(s.begin(), s.end());\n        if (s_set.size() != 4) {\n            quitf(_wa, \"Set %d contains duplicate integers\", i);\n        }\n\n        // Check that integers are not used in previous sets\n        for (int num : s) {\n            if (used_numbers.count(num)) {\n                quitf(_wa, \"Integer %d is used in more than one set\", num);\n            }\n            used_numbers.insert(num);\n        }\n\n        // Check that gcd of any pair equals k\n        for (int p = 0; p < 4; p++) {\n            for (int q = p + 1; q < 4; q++) {\n                if (__gcd(s[p], s[q]) != k) {\n                    quitf(_wa, \"In set %d, gcd(%d, %d) != %d\", i, s[p], s[q], k);\n                }\n            }\n        }\n    }\n\n    // Ensure participant has not output extra data\n    ouf.skipBlanks();\n    if (!ouf.eof())\n        quitf(_wa, \"Extra data in output after reading %d sets\", n);\n\n    quitf(_ok, \"Correct solution with minimal m = %d\", m_part);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"min_n_min_k\") {\n        n = 1;\n        k = 1;\n    } else if(type == \"min_n_max_k\") {\n        n = 1;\n        k = 100;\n    } else if(type == \"max_n_min_k\") {\n        n = 10000;\n        k = 1;\n    } else if(type == \"max_n_max_k\") {\n        n = 10000;\n        k = 100;\n    } else if(type == \"random_small_n\") {\n        n = rnd.next(1, 10);\n        k = rnd.next(1, 100);\n    } else if(type == \"random_large_n\") {\n        n = rnd.next(9000, 10000);\n        k = rnd.next(1, 100);\n    } else if(type == \"random_small_k\") {\n        n = rnd.next(1, 10000);\n        k = rnd.next(1, 10);\n    } else if(type == \"random_large_k\") {\n        n = rnd.next(1, 10000);\n        k = rnd.next(90, 100);\n    } else if(type == \"random\") {\n        n = rnd.next(1, 10000);\n        k = rnd.next(1, 100);\n    } else {\n        // Use provided n and k or default values\n        if(n == -1) n = rnd.next(1, 10000);\n        if(k == -1) k = rnd.next(1, 100);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"min_n_min_k\") {\n        n = 1;\n        k = 1;\n    } else if(type == \"min_n_max_k\") {\n        n = 1;\n        k = 100;\n    } else if(type == \"max_n_min_k\") {\n        n = 10000;\n        k = 1;\n    } else if(type == \"max_n_max_k\") {\n        n = 10000;\n        k = 100;\n    } else if(type == \"random_small_n\") {\n        n = rnd.next(1, 10);\n        k = rnd.next(1, 100);\n    } else if(type == \"random_large_n\") {\n        n = rnd.next(9000, 10000);\n        k = rnd.next(1, 100);\n    } else if(type == \"random_small_k\") {\n        n = rnd.next(1, 10000);\n        k = rnd.next(1, 10);\n    } else if(type == \"random_large_k\") {\n        n = rnd.next(1, 10000);\n        k = rnd.next(90, 100);\n    } else if(type == \"random\") {\n        n = rnd.next(1, 10000);\n        k = rnd.next(1, 100);\n    } else {\n        // Use provided n and k or default values\n        if(n == -1) n = rnd.next(1, 10000);\n        if(k == -1) k = rnd.next(1, 100);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n_min_k\n./gen -type min_n_max_k\n./gen -type max_n_min_k\n./gen -type max_n_max_k\n./gen -type random_small_n\n./gen -type random_large_n\n./gen -type random_small_k\n./gen -type random_large_k\n./gen -type random\n./gen -n 1 -k 50\n./gen -n 5000 -k 25\n./gen -n 10 -k 100\n./gen -n 10000 -k 1\n./gen -n 10000 -k 50\n./gen -n 10000 -k 100\n./gen -n 10000 -k 10\n./gen -n 1 -k 1\n./gen -n 1 -k 100\n./gen -n 2 -k 50\n./gen -n 5000 -k 100\n./gen -n 5000 -k 1\n./gen -n 9999 -k 99\n./gen -n 50 -k 1\n./gen -n 50 -k 100\n./gen -n 5000 -k 75\n./gen -n 2500 -k 25\n./gen -n 7500 -k 75\n./gen -n 100 -k 100\n./gen -n 100 -k 1\n./gen -n 500 -k 5\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:36.028500",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "477/C",
      "title": "C. Dreamoon and Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains the string s (1 ≤ |s| ≤ 2 000).The second line of the input contains the string p (1 ≤ |p| ≤ 500).Both strings will only consist of lower case English letters.",
      "output_spec": "OutputPrint |s| + 1 space-separated integers in a single line representing the  for all x from 0 to |s|.",
      "sample_tests": "ExamplesInputCopyaaaaaaaOutputCopy2 2 1 1 0 0InputCopyaxbaxxbabOutputCopy0 1 1 2 1 1 0 0",
      "description": "C. Dreamoon and Strings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains the string s (1 ≤ |s| ≤ 2 000).The second line of the input contains the string p (1 ≤ |p| ≤ 500).Both strings will only consist of lower case English letters.\n\nOutputPrint |s| + 1 space-separated integers in a single line representing the  for all x from 0 to |s|.\n\nInputCopyaaaaaaaOutputCopy2 2 1 1 0 0InputCopyaxbaxxbabOutputCopy0 1 1 2 1 1 0 0\n\nInputCopyaaaaaaa\n\nOutputCopy2 2 1 1 0 0\n\nInputCopyaxbaxxbab\n\nOutputCopy0 1 1 2 1 1 0 0\n\nNoteFor the first sample, the corresponding optimal values of s' after removal 0 through |s| = 5 characters from s are {\"aaaaa\", \"aaaa\", \"aaa\", \"aa\", \"a\", \"\"}. For the second sample, possible corresponding optimal values of s' are {\"axbaxxb\", \"abaxxb\", \"axbab\", \"abab\", \"aba\", \"ab\", \"a\", \"\"}.",
      "solutions": [
        {
          "title": "Codeforces Round #272 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #272 will be held at this local time. We're looking forward to your participation!The problems are from dreamoon_love_AA and drazil(that's me) from Taiwan, and thanks 9mmlitswe for some discussion. Also we want to thank Zlobober and Gerald for helping us prepare the round, Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is our first round on Codeforces, we hope you'll find it interesting! Please read all problem statements and discover what the main character dreamoon_love_AA do in those problems for he's really cute =)Update1 Note this round will be held 1.5hrs earlier than usual Codeforces rounds, so please double check the starting time in your local time.Update2 Score distribution! Div2: 500-1500-1500-2000-2500 Div1: 500-1000-1500-2000-3000Update3 The contests are over. Congratulations to the winners!Div1: 1. Petr 2. qwer1561 3. kutengine 4. ifsmirnov 5. TankEngineerDiv2: 1. ridowan007 2. a00012025 3. xavier13540 4. v_Enhance 5. pkq2006And standings are here: Div1: результаты Div2: результатыUpdate4 Editorial can be found here. It's finished by now but it's welcome to tell me if anything can be improved!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14228",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1214
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 477\\s*C"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 - Codeforces - Code 1",
          "code": "Failure is the pillar of success",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 2",
          "code": "for (mod = 1; mod < b; mod++) \nres += mod * b * a(a+1)/2  + mod * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 3",
          "code": "for (mod = 1; mod < b; mod++) \nres += mod * b * a(a+1)/2  + mod * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 4",
          "code": "sum*((a*b)%MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 5",
          "code": "sum %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 6",
          "code": "((sum*i)%mod)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 7",
          "code": "ll sum = (double)(1+a) / 2 * a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 8",
          "code": "ll sum = (double)(1+a) / 2 * a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 9",
          "code": "(ll)(a+1)*a/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 10",
          "code": "res = (res + ((sum*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 11",
          "code": "res = (res + ((sum*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 12",
          "code": "res = (res + (((sum%MOD)*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 13",
          "code": "res = (res + (((sum%MOD)*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 14",
          "code": "x = q*b+r ---(1)\nand q/r = k\n or q = rk;\nput this in 1\nx = brk+r = r(bk+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 15",
          "code": "x = q*b+r ---(1)\nand q/r = k\n or q = rk;\nput this in 1\nx = brk+r = r(bk+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 16",
          "code": "1(bk+1) + 2(bk+1) +3(bk+1)... (b-1)(bk+1)\n=(bk+1)(1+2+..b-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 17",
          "code": "1(bk+1) + 2(bk+1) +3(bk+1)... (b-1)(bk+1)\n=(bk+1)(1+2+..b-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 18",
          "code": "sum = 0;\nfor(k=1;k<=a;++k)\n{\n   sum+=b*(b-1)/2 * (bk+1)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 19",
          "code": "sum = 0;\nfor(k=1;k<=a;++k)\n{\n   sum+=b*(b-1)/2 * (bk+1)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 20",
          "code": "Sn = (n/2) * ( 2*a + ( n - 1 ) * d )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 21",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"%d\",sizeof(long double));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 22",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"%d\",sizeof(long double));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 23",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"test....it's ok?\\n\");\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 24",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"test....it's ok?\\n\");\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 25",
          "code": "((b % mod) * (sum2 % mod) * (sum1 % mod))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 26",
          "code": "const int N = 2e3 + 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 27",
          "code": "const int N = 2e3 + 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 28",
          "code": "const int N = 2e3 + 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 29",
          "code": "const int N = 2e3 + 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 30",
          "code": "dp[i][cut] = dp[i-1][cut];\nif (cut > 0) \n\tdp[i][cut] = max(dp[i][cut], dp[i-1][cut-1]);\nfor (int k = L[i]; k <= cut + p.length(); ++k) \n\tdp[i][cut] = max(dp[i][cut], dp[i - k][cut - k + p.length()] + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 31",
          "code": "dp[i][cut] = dp[i-1][cut];\nif (cut > 0) \n\tdp[i][cut] = max(dp[i][cut], dp[i-1][cut-1]);\nfor (int k = L[i]; k <= cut + p.length(); ++k) \n\tdp[i][cut] = max(dp[i][cut], dp[i - k][cut - k + p.length()] + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 32",
          "code": "cut - k + p.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 33",
          "code": "i - cut - p.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 34",
          "code": "ftr[i + cut][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 35",
          "code": "dp[i][cut] = max(dp[i][cut], get(ftr[i - cut - p.length()], i - k) + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,2000}\", \"s\");\n    string p = inf.readLine(\"[a-z]{1,500}\", \"p\");\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,2000}\", \"s\");\n    string p = inf.readLine(\"[a-z]{1,500}\", \"p\");\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,2000}\", \"s\");\n    string p = inf.readLine(\"[a-z]{1,500}\", \"p\");\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_string(int length, const string& type, int alpha_size, const string& p) {\n    string s;\n    if (type == \"random\") {\n        for (int i = 0; i < length; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            s += c;\n        }\n    } else if (type == \"same_char\") {\n        char c = 'a' + rnd.next(0, alpha_size - 1);\n        s = string(length, c);\n    } else if (type == \"repeat_p\") {\n        while ((int)s.size() + (int)p.size() <= length) {\n            s += p;\n        }\n        if ((int)s.size() < length) {\n            int remaining = length - s.size();\n            for (int i = 0; i < remaining; ++i) {\n                char c = 'a' + rnd.next(0, alpha_size - 1);\n                s += c;\n            }\n        }\n    } else if (type == \"interleave_p\") {\n        while ((int)s.size() < length) {\n            if (rnd.next(0,1) == 0 && (int)s.size() + (int)p.size() <= length) {\n                s += p;\n            } else {\n                char c = 'a' + rnd.next(0, alpha_size - 1);\n                s += c;\n            }\n        }\n    } else if (type == \"palindrome\") {\n        string half;\n        for (int i = 0; i < (length + 1) / 2; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            half += c;\n        }\n        s = half;\n        if (length % 2 == 1) half.pop_back();\n        reverse(half.begin(), half.end());\n        s += half;\n    } else {\n        // default to random\n        for (int i = 0; i < length; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            s += c;\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    int alpha_size = opt<int>(\"alpha_size\", 26);\n\n    // Adjust n and m to be within limits\n    n = min(max(n, 1), 2000);\n    m = min(max(m, 1), 500);\n\n    alpha_size = min(max(alpha_size, 1), 26);\n\n    string p;\n\n    // Generate p\n    if (p_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            p += c;\n        }\n    } else if (p_type == \"same_char\") {\n        char c = 'a' + rnd.next(0, alpha_size - 1);\n        p = string(m, c);\n    } else if (p_type == \"reverse_s\") {\n        // Generate s first, then p as reverse of s\n        // So we need to handle generating s before p\n    } else if (p_type == \"palindrome\") {\n        string half;\n        for (int i = 0; i < (m+1)/2; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            half += c;\n        }\n        p = half;\n        if (m % 2 == 1) half.pop_back();\n        reverse(half.begin(), half.end());\n        p += half;\n    } else {\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            p += c;\n        }\n    }\n\n    // Generate s\n    string s = generate_string(n, s_type, alpha_size, p);\n\n    // If p_type is reverse_s, we need to adjust p\n    if (p_type == \"reverse_s\") {\n        p = s;\n        reverse(p.begin(), p.end());\n        if (m < (int)p.size()) p = p.substr(0, m);\n    }\n\n    // Output s and p\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", p.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_string(int length, const string& type, int alpha_size, const string& p) {\n    string s;\n    if (type == \"random\") {\n        for (int i = 0; i < length; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            s += c;\n        }\n    } else if (type == \"same_char\") {\n        char c = 'a' + rnd.next(0, alpha_size - 1);\n        s = string(length, c);\n    } else if (type == \"repeat_p\") {\n        while ((int)s.size() + (int)p.size() <= length) {\n            s += p;\n        }\n        if ((int)s.size() < length) {\n            int remaining = length - s.size();\n            for (int i = 0; i < remaining; ++i) {\n                char c = 'a' + rnd.next(0, alpha_size - 1);\n                s += c;\n            }\n        }\n    } else if (type == \"interleave_p\") {\n        while ((int)s.size() < length) {\n            if (rnd.next(0,1) == 0 && (int)s.size() + (int)p.size() <= length) {\n                s += p;\n            } else {\n                char c = 'a' + rnd.next(0, alpha_size - 1);\n                s += c;\n            }\n        }\n    } else if (type == \"palindrome\") {\n        string half;\n        for (int i = 0; i < (length + 1) / 2; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            half += c;\n        }\n        s = half;\n        if (length % 2 == 1) half.pop_back();\n        reverse(half.begin(), half.end());\n        s += half;\n    } else {\n        // default to random\n        for (int i = 0; i < length; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            s += c;\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    int alpha_size = opt<int>(\"alpha_size\", 26);\n\n    // Adjust n and m to be within limits\n    n = min(max(n, 1), 2000);\n    m = min(max(m, 1), 500);\n\n    alpha_size = min(max(alpha_size, 1), 26);\n\n    string p;\n\n    // Generate p\n    if (p_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            p += c;\n        }\n    } else if (p_type == \"same_char\") {\n        char c = 'a' + rnd.next(0, alpha_size - 1);\n        p = string(m, c);\n    } else if (p_type == \"reverse_s\") {\n        // Generate s first, then p as reverse of s\n        // So we need to handle generating s before p\n    } else if (p_type == \"palindrome\") {\n        string half;\n        for (int i = 0; i < (m+1)/2; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            half += c;\n        }\n        p = half;\n        if (m % 2 == 1) half.pop_back();\n        reverse(half.begin(), half.end());\n        p += half;\n    } else {\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(0, alpha_size - 1);\n            p += c;\n        }\n    }\n\n    // Generate s\n    string s = generate_string(n, s_type, alpha_size, p);\n\n    // If p_type is reverse_s, we need to adjust p\n    if (p_type == \"reverse_s\") {\n        p = s;\n        reverse(p.begin(), p.end());\n        if (m < (int)p.size()) p = p.substr(0, m);\n    }\n\n    // Output s and p\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", p.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -s_type random -p_type random -alpha_size 5\n./gen -n 2000 -m 500 -s_type random -p_type random -alpha_size 26\n./gen -n 1 -m 1 -s_type same_char -p_type same_char -alpha_size 1\n./gen -n 2000 -m 500 -s_type same_char -p_type random -alpha_size 2\n./gen -n 2000 -m 1 -s_type random -p_type same_char -alpha_size 2\n./gen -n 2000 -m 5 -s_type repeat_p -p_type random -alpha_size 5\n./gen -n 2000 -m 5 -s_type interleave_p -p_type random -alpha_size 5\n./gen -n 2000 -m 500 -s_type palindrome -p_type palindrome -alpha_size 10\n./gen -n 2000 -m 100 -s_type random -p_type palindrome -alpha_size 26\n./gen -n 2000 -m 100 -s_type palindrome -p_type random -alpha_size 26\n./gen -n 1000 -m 1000 -s_type random -p_type reverse_s -alpha_size 26\n./gen -n 500 -m 600 -s_type random -p_type random -alpha_size 26\n./gen -n 2000 -m 500 -s_type random -p_type random -alpha_size 26\n./gen -n 500 -m 500 -s_type random -p_type reverse_s -alpha_size 26\n./gen -n 2000 -m 50 -s_type repeat_p -p_type random -alpha_size 5\n./gen -n 2000 -m 500 -s_type random -p_type random -alpha_size 3\n./gen -n 2000 -m 5 -s_type random -p_type random -alpha_size 1\n./gen -n 2000 -m 100 -s_type interleave_p -p_type random -alpha_size 5\n./gen -n 2000 -m 20 -s_type random -p_type random -alpha_size 1\n./gen -n 2000 -m 500 -s_type random -p_type random -alpha_size 2\n./gen -n 2000 -m 100 -s_type random -p_type same_char -alpha_size 1\n./gen -n 2000 -m 500 -s_type same_char -p_type same_char -alpha_size 1\n./gen -n 2000 -m 50 -s_type random -p_type random -alpha_size 26\n./gen -n 2000 -m 100 -s_type interleave_p -p_type random -alpha_size 26\n./gen -n 2000 -m 1000 -s_type repeat_p -p_type random -alpha_size 26\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:38.199861",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "477/D",
      "title": "Problem 477/D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1][0-1]{0,4999}\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1][0-1]{0,4999}\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1][0-1]{0,4999}\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int l = opt<int>(\"l\"); // Length of the binary string\n    string type = opt<string>(\"type\", \"random\");\n    int num_ones = opt<int>(\"ones\", -1); // Number of leading ones for 'leadingones' type\n    \n    string x;\n\n    if(type == \"random\") {\n        x.push_back('1'); // No leading zeros\n        for(int i = 1; i < l; i++) {\n            x.push_back(rnd.next(0, 1) + '0');\n        }\n    } else if(type == \"allones\") {\n        x = string(l, '1');\n    } else if(type == \"leadingones\") {\n        if(num_ones == -1)\n            num_ones = rnd.next(1, l);\n        else\n            num_ones = min(num_ones, l);\n        x = string(num_ones, '1') + string(l - num_ones, '0');\n    } else if(type == \"alternating\") {\n        x.push_back('1'); // First bit\n        for(int i = 1; i < l; i++) {\n            if(x[i-1] == '1')\n                x.push_back('0');\n            else\n                x.push_back('1');\n        }\n    } else if(type == \"palindrome\") {\n        // Create a palindrome\n        string half;\n        half.push_back('1'); // No leading zeros\n        for(int i = 1; i < (l+1)/2; i++) {\n            half.push_back(rnd.next(0, 1) + '0');\n        }\n        string rev_half = half;\n        if(l % 2 == 1) rev_half.pop_back(); // If odd length, avoid duplicating the middle character\n        reverse(rev_half.begin(), rev_half.end());\n        x = half + rev_half;\n    } else if(type == \"max\") {\n        // x is '1' followed by (l - 1) ones\n        x = '1' + string(l - 1, '1');\n    } else if(type == \"min\") {\n        x = \"1\"; // x is '1', length is 1\n    }\n    // Output x\n    printf(\"%s\\n\", x.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int l = opt<int>(\"l\"); // Length of the binary string\n    string type = opt<string>(\"type\", \"random\");\n    int num_ones = opt<int>(\"ones\", -1); // Number of leading ones for 'leadingones' type\n    \n    string x;\n\n    if(type == \"random\") {\n        x.push_back('1'); // No leading zeros\n        for(int i = 1; i < l; i++) {\n            x.push_back(rnd.next(0, 1) + '0');\n        }\n    } else if(type == \"allones\") {\n        x = string(l, '1');\n    } else if(type == \"leadingones\") {\n        if(num_ones == -1)\n            num_ones = rnd.next(1, l);\n        else\n            num_ones = min(num_ones, l);\n        x = string(num_ones, '1') + string(l - num_ones, '0');\n    } else if(type == \"alternating\") {\n        x.push_back('1'); // First bit\n        for(int i = 1; i < l; i++) {\n            if(x[i-1] == '1')\n                x.push_back('0');\n            else\n                x.push_back('1');\n        }\n    } else if(type == \"palindrome\") {\n        // Create a palindrome\n        string half;\n        half.push_back('1'); // No leading zeros\n        for(int i = 1; i < (l+1)/2; i++) {\n            half.push_back(rnd.next(0, 1) + '0');\n        }\n        string rev_half = half;\n        if(l % 2 == 1) rev_half.pop_back(); // If odd length, avoid duplicating the middle character\n        reverse(rev_half.begin(), rev_half.end());\n        x = half + rev_half;\n    } else if(type == \"max\") {\n        // x is '1' followed by (l - 1) ones\n        x = '1' + string(l - 1, '1');\n    } else if(type == \"min\") {\n        x = \"1\"; // x is '1', length is 1\n    }\n    // Output x\n    printf(\"%s\\n\", x.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small length, random\n./gen -l 1 -type random\n./gen -l 2 -type random\n./gen -l 3 -type random\n\n# Small length, all ones\n./gen -l 1 -type allones\n./gen -l 2 -type allones\n./gen -l 3 -type allones\n\n# Small length, leading ones\n./gen -l 2 -type leadingones -ones 1\n./gen -l 3 -type leadingones -ones 1\n\n# Medium length, random\n./gen -l 50 -type random\n./gen -l 100 -type random\n./gen -l 500 -type random\n\n# Medium length, all ones\n./gen -l 50 -type allones\n./gen -l 100 -type allones\n./gen -l 500 -type allones\n\n# Medium length, leading ones\n./gen -l 50 -type leadingones -ones 25\n./gen -l 100 -type leadingones -ones 50\n./gen -l 500 -type leadingones -ones 250\n\n# Medium length, alternating\n./gen -l 50 -type alternating\n./gen -l 100 -type alternating\n./gen -l 500 -type alternating\n\n# Medium length, palindrome\n./gen -l 50 -type palindrome\n./gen -l 100 -type palindrome\n./gen -l 500 -type palindrome\n\n# Maximum length, random\n./gen -l 5000 -type random\n\n# Maximum length, all ones\n./gen -l 5000 -type allones\n\n# Maximum length, leading ones\n./gen -l 5000 -type leadingones -ones 1\n./gen -l 5000 -type leadingones -ones 2500\n./gen -l 5000 -type leadingones -ones 4999\n\n# Maximum length, alternating\n./gen -l 5000 -type alternating\n\n# Maximum length, palindrome\n./gen -l 5000 -type palindrome\n\n# Edge cases\n./gen -l 1 -type min\n./gen -l 5000 -type max\n\n# Edge case: ones followed by zeros\n./gen -l 5000 -type leadingones -ones 10\n./gen -l 5000 -type leadingones -ones 4990\n\n# Additional random large inputs\n./gen -l 4999 -type random\n./gen -l 4999 -type palindrome\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:40.318876",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "477/E",
      "title": "E. Dreamoon and Notepad",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n(1 ≤ n ≤ 400, 000) — the number of lines of text. The second line contains n integers a1, a2, ..., an(1 ≤ ai ≤ 108).The third line contains an integer q(1 ≤ q ≤ 400, 000). Each of the next q lines contains four integers r1, c1, r2, c2 representing a query (1 ≤ r1, r2 ≤ n, 0 ≤ c1 ≤ ar1, 0 ≤ c2 ≤ ar2).",
      "output_spec": "OutputFor each query print the result of the query.",
      "sample_tests": "ExamplesInputCopy91 3 5 3 1 3 5 3 143 5 3 13 3 7 31 0 3 36 0 7 3OutputCopy2532InputCopy210 511 0 1 5OutputCopy3",
      "description": "E. Dreamoon and Notepad\n\ntime limit per test3.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n(1 ≤ n ≤ 400, 000) — the number of lines of text. The second line contains n integers a1, a2, ..., an(1 ≤ ai ≤ 108).The third line contains an integer q(1 ≤ q ≤ 400, 000). Each of the next q lines contains four integers r1, c1, r2, c2 representing a query (1 ≤ r1, r2 ≤ n, 0 ≤ c1 ≤ ar1, 0 ≤ c2 ≤ ar2).\n\nOutputFor each query print the result of the query.\n\nInputCopy91 3 5 3 1 3 5 3 143 5 3 13 3 7 31 0 3 36 0 7 3OutputCopy2532InputCopy210 511 0 1 5OutputCopy3\n\nInputCopy91 3 5 3 1 3 5 3 143 5 3 13 3 7 31 0 3 36 0 7 3\n\nOutputCopy2532\n\nInputCopy210 511 0 1 5\n\nOutputCopy3\n\nNoteIn the first sample, the first query can be solved with keys: HOME, right.The second query can be solved with keys: down, down, down, END, down.The third query can be solved with keys: down, END, down.The fourth query can be solved with keys: END, down.",
      "solutions": [
        {
          "title": "Codeforces Round #272 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #272 will be held at this local time. We're looking forward to your participation!The problems are from dreamoon_love_AA and drazil(that's me) from Taiwan, and thanks 9mmlitswe for some discussion. Also we want to thank Zlobober and Gerald for helping us prepare the round, Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is our first round on Codeforces, we hope you'll find it interesting! Please read all problem statements and discover what the main character dreamoon_love_AA do in those problems for he's really cute =)Update1 Note this round will be held 1.5hrs earlier than usual Codeforces rounds, so please double check the starting time in your local time.Update2 Score distribution! Div2: 500-1500-1500-2000-2500 Div1: 500-1000-1500-2000-3000Update3 The contests are over. Congratulations to the winners!Div1: 1. Petr 2. qwer1561 3. kutengine 4. ifsmirnov 5. TankEngineerDiv2: 1. ridowan007 2. a00012025 3. xavier13540 4. v_Enhance 5. pkq2006And standings are here: Div1: результаты Div2: результатыUpdate4 Editorial can be found here. It's finished by now but it's welcome to tell me if anything can be improved!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14228",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1214
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces",
          "content": "First I want to thank all the problem solvers! Hope you had or are going to have a good time with Dreamoon!If you think there's something that can be improved in this editorial please let me know!Definitions used in this editorial: ⌈⌉ stands for ceiling function. ⌊⌋ stands for floor function. stands for real division. For non-negative integer a and positive integer b, div(a, b) stands for integral division, . For non-negative integer a and positive integer b, mod(a, b) stands for module operation, a = div(a, b) * b + mod(a, b). length(string) is the length of string. For non-negative integer a ≤ b, A[a..b] stands for the set of A[a], A[a + 1], A[a + 2]... A[b - 1] when A is an array and the substring of A consists of ath to (b - 1)th character(inclusive) of A when A is a string. For such substring we have length(A[a..b]) = b - a. C(a, b) stands for the combination function, the ways of selecting a elements from a group of b elements.476A - Dreamoon and Stairs We can show that the maximum number of moves possible is n and minimal moves needed is , so the problem equals to determine the minimal integer that is a multiple of m in the range . One way to find the minimal number which is a multiple of m and greater than or equal to a number x is , we can compare this number to the upper bound n to determine if there is a valid solution. Although best practice is O(1), O(n) enumeration of each possible number of moves would also work. time complexity: O(1) sample code: 8212169 explanation of sample code: The can be calculated in the following c++ code if a is non-negative and b is positive: (a+b-1)/bBecause / in c++ is integral division so (a+b-1)/b would result in Let a = div(a, b)b + mod(a, b) = db + m, . Which means if , otherwise div(a + b - 1, b) = d + 1. Can be translated to if , otherwise div(a + b - 1, b) = div(a, b) + 1. Which matches the value of .476B - Dreamoon and WiFi The order of moves won't change the final position, so we can move all '?'s to the end of the string. We have the following information: 1. the correct final position 2. the position that Dreamoon will be before all '?'s 3. the number of '?'s We can infer that the distance and direction dreamoon still needs to move in the '?' part from 1. and 2., and furthur translate that to how many +1s and -1s dreamoon will need to move. What's left is a combinatorial problem, the probability would be . So we can compute that formula within O(n) time assuming n is the length of commands, but since N is small so we can brute force every possible choice of '?' with some recursive or dfs like search in O(2n) time complexity. Note that the problem asks for a precision of 10 - 9, so one should output to 11 decimal places or more. time complexity: O(n), assuming n is the length of commands. sample code: 8215177476C - Dreamoon and Sums / 477A - Dreamoon and Sums If we fix the value of k, and let d = div(x, b), m = mod(x, b), we have : d = mk x = db + m So we have x = mkb + m = (kb + 1) * m. And we know m would be in range [1, b - 1] because it's a remainder and x is positive, so the sum of x of that fixed k would be . Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div(x, b) and mod(x, b). Thus the final answer would be sum up for all individual k: which can be calculated in O(a) and will pass the time limit of 1.5 seconds. Also the formula above can be expanded to . Dreamoon says he's too lazy to do this part, so if you use O(1) solution you just computed the answer faster than Dreamoon!!! Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language. For example one should do a module after every multiplication if using 64-bit integer type. And pay attention to precedence of operations: take c++ for example a+b%c would be executed as a+(b%c) instead of (a+b)%c, another c++ example a*(b*c)%m would be executed as (a*(b*c))%m instead of a*((b*c)%m). Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment! time complexity: O(1) sample code: 8215188476D - Dreamoon and Sets / 477B - Dreamoon and Sets The first observation is that if we divide each number in a set by k, than the set would be rank 1. So we could find n sets of rank 1 then multiple every number by k. For how to find n sets of rank 1, we can use {6a + 1, 6a + 2, 6a + 3, 6a + 5} as a valid rank 1 set and take a = 0 to n - 1 to form n sets and thus m = (6n - 1) * k. The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set. If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2. And if we take more odd numbers m would be larger. The output method is straight forward. Overall time complexity is O(n). time complexity: O(n) sample code: 8215198476E - Dreamoon and Strings / 477C - Dreamoon and Strings First let A[i] to be the minimal length L needed so that substring s[i..i + L] can become pattern p by removing some characters. We can calculate this greedily by keep selecting next occurrence of characters in p in O(length(s)) time for a fixed i, so for all i requires O(length(s)2). Next we can do a dp D[i][j] where D[i] is the answer array for s[0..i]. D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[i + A[i]] with A[i] - length(p) removal(s). In other words, D[i][j] can transition into tree relations D[i + 1][j] = D[i][j] //not delete s[i], D[i + 1][j + 1] = D[i][j] //delete s[i], and D[i + A[i]][j + A[i] - length(p)] = D[i][j] + 1 //form a substring p by deleting A[i] - length(p) characters. Calculate forwardly from D[0] to D[length(s) - 1] gives the final answer array as D[length(s)]. Calculating D[i] requires O(length(s)) time for a fixed i, so for all i takes O(length(s)2) time. time complexity: O(n2), n = length(s) sample code: 8215203Another solution: Let k = div(length(s), length(p)). We can run an edit distance like algorithm as following (omitting the details of initialization and boundary conditions): for(i=0;i<n;i++)\n for(j=0;j<k*p;j++)\n if(s[i]==p[j%length(p)])\n D[i][j] = D[i-1][j-1]\n D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))That means remove cost is 1 when it is in the middle of a p and 0 elsewhere because p need to be consecutive(thus no need to be actually remove outside of a p). Then D[n][t * length(p)] is the minimal number of removals to have t non-overlapping substring of p. So we have answer[D[n][t * length(p)..(t + 1) * length(p)] = t. And after the maximal t is reached, decrease answer by 1 for every length(p). time complexity: O(n2) sample code: 8215394477D - Dreamoon and Binary Let Xb be the binary string of number X. An ideal sequence can be expressed as a partition of Xb: P1 = Xb[1..p1], P2 = Xb[p1..p2], ... PK = Xb[pK - 1..length(Xb)] where Pi ≤ Pi + 1. The length of operations of such sequence is PK + K. We can calculate the number of different ideal sequences by dp. State D[i][j] stands for the answer of state that we have print Xb[1..j] and last partition is Xb[i..j]. A possible way of transition is that a state D[i][j] can go to state D[i][j + 1] and D[j][k] where k is the minimal possible position such that value of Xb[j..k] is equal to or greater than the value of Xb[i..j] and Xb[j] is 1 since we can't print any leading 0. Note that D[j][k + 1] can also derived from D[i][j] but it will covered by D[i][j] → D[j][k] → D[j][k + 1], so we don't need to consider this case to avoid redundant counts. If we can determine k for each i, j pair in O(1) then we can compute this dp in O(length(Xb)2) in the following manner: for(j=0;j<n;j++)\n for(i=0;i<j;i++)\n compute the transitions of D[i][j]So let's look into how to calculate the value k for a given i, j pair. If the value of Xb[j..2j - i] is equal to or greater than Xb[i..j] than k is 2j - i because if k is less than 2j - i would make length of the new partition less than the previous partition thus its value would be lesser. And if k can't be 2j - i, the value of 2j - i + 1 is always a valid choice because it would make the length of the new partition greater than the previous one. So for each length L if we know the order of Xb[i..i + L] and Xb[i + L..i + 2L] in O(1) time we can calculate k in O(1) time(can be easily shown by assuming L = j - i). One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in O(1) time. The prefix doubling algorithm requires O(nlgn) precompute time. Note there is still a various of ways to do this part of task in the same or better time complexties. And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp. Then compare all states ends with j = length(Xb). Overall we can solve this problem in O(length(Xb)2) with caution in details like boundaries and module operations. time complexity: O(n2), n = length(Xb) Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code: 8215216477E - Dreamoon and Notepad Although swapping two parts of a query would result in different answer, if we reverse the lines length alltogether then the answer would stay the same. So we only analyze queries where r2 ≥ r1. The answers would comes in several types, we’ll discuss them one by one: 1. HOME key being pressed once: the answer will be 1(HOME) + r2 - r1(down keys) + c2(right keys). Note that this is the best answer if the HOME key is ever pressed once, so we won’t consider HOME key anymore. This step is O(1) for a single query, thus O(q) in total. 2. direct presses r2 - r1 down keys and no or one END key in those rows: because the cursor position will be reset to the row length if we go down to a row with length less than current cursor position, the possible positions that can be at row p if we start at end of each previous rows can be track with a stack. The position directly pressing only down keys from r1 to r2 is min(c1, the length of first row after r1 in stack). We can use a binary search to get the first row after or equal r1 in stack. From that row till r2 in the stack are the positions possible when pressing ONE END key (pressing more won’t get more possible positions), we can use a binary search to find the position closest to c2 which is the best. We can sort all queries and use O(qlgn) time for queries and O(n) time for maintaining stack, so O(qlgn + n) in total. 3. go back some rows and press one or no END key at the row: we only interested in END OF rows in stack constructed in 2.. We can use a binary search in stack to identify the range of rows interested. For those lengths of row less than c2(also can use a binary search to locate) we only need to consider the first one encountered(closest to r1), note still need to consider if it needs an END key for this case. For those lengths of row greater than or equal to c2, the answer would be r1 + r2 - 2 * (row reached) + (length of the row) - c2 + (1 if length of the row greater than c1). The terms related to row in the previous formula is 2 * (row reached) + (length of the row) + (1 if length of the row greater than c1). We can identify the range with and without +1(last term) and query in a segment tree of the minimal value of 2 * (row reached) + (length of the row) for each range. Thus the time need here is O(nlgn) for maintaining segment tree and O(qlgn) for query while sharing with the stack of 2., so O(nlgn + qlgn) in total. 4. go beyond r2 some rows and press no or one END at the row: this needs a reversed stack and very similar approach of 3.. The time complexity is the same as 2. and 3.. So the total time complexity is O((n + q)lgn), note this problem is very hard to get the code right. time complexity: O((n + q)lgn) sample code: 8212528",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14256",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 477\\s*E"
          },
          "content_length": 11893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #272 - Codeforces - Code 1",
          "code": "Failure is the pillar of success",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 2",
          "code": "for (mod = 1; mod < b; mod++) \nres += mod * b * a(a+1)/2  + mod * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 3",
          "code": "for (mod = 1; mod < b; mod++) \nres += mod * b * a(a+1)/2  + mod * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 4",
          "code": "sum*((a*b)%MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 5",
          "code": "sum %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 6",
          "code": "((sum*i)%mod)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 7",
          "code": "ll sum = (double)(1+a) / 2 * a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 8",
          "code": "ll sum = (double)(1+a) / 2 * a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 9",
          "code": "(ll)(a+1)*a/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 10",
          "code": "res = (res + ((sum*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 11",
          "code": "res = (res + ((sum*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 12",
          "code": "res = (res + (((sum%MOD)*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 13",
          "code": "res = (res + (((sum%MOD)*((i*b)%MOD))%MOD) + ((a*i)%MOD)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 14",
          "code": "x = q*b+r ---(1)\nand q/r = k\n or q = rk;\nput this in 1\nx = brk+r = r(bk+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 15",
          "code": "x = q*b+r ---(1)\nand q/r = k\n or q = rk;\nput this in 1\nx = brk+r = r(bk+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 16",
          "code": "1(bk+1) + 2(bk+1) +3(bk+1)... (b-1)(bk+1)\n=(bk+1)(1+2+..b-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 17",
          "code": "1(bk+1) + 2(bk+1) +3(bk+1)... (b-1)(bk+1)\n=(bk+1)(1+2+..b-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 18",
          "code": "sum = 0;\nfor(k=1;k<=a;++k)\n{\n   sum+=b*(b-1)/2 * (bk+1)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 19",
          "code": "sum = 0;\nfor(k=1;k<=a;++k)\n{\n   sum+=b*(b-1)/2 * (bk+1)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 20",
          "code": "Sn = (n/2) * ( 2*a + ( n - 1 ) * d )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 21",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"%d\",sizeof(long double));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 22",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"%d\",sizeof(long double));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 23",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"test....it's ok?\\n\");\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 24",
          "code": "#include<stdio.h>\nint main()\n{\n    printf(\"test....it's ok?\\n\");\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 25",
          "code": "((b % mod) * (sum2 % mod) * (sum1 % mod))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 26",
          "code": "const int N = 2e3 + 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 27",
          "code": "const int N = 2e3 + 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 28",
          "code": "const int N = 2e3 + 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 29",
          "code": "const int N = 2e3 + 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 30",
          "code": "dp[i][cut] = dp[i-1][cut];\nif (cut > 0) \n\tdp[i][cut] = max(dp[i][cut], dp[i-1][cut-1]);\nfor (int k = L[i]; k <= cut + p.length(); ++k) \n\tdp[i][cut] = max(dp[i][cut], dp[i - k][cut - k + p.length()] + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 31",
          "code": "dp[i][cut] = dp[i-1][cut];\nif (cut > 0) \n\tdp[i][cut] = max(dp[i][cut], dp[i-1][cut-1]);\nfor (int k = L[i]; k <= cut + p.length(); ++k) \n\tdp[i][cut] = max(dp[i][cut], dp[i - k][cut - k + p.length()] + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 32",
          "code": "cut - k + p.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 33",
          "code": "i - cut - p.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 34",
          "code": "ftr[i + cut][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 - Codeforces - Code 35",
          "code": "dp[i][cut] = max(dp[i][cut], get(ftr[i - cut - p.length()], i - k) + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14228",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 1",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 2",
          "code": "for(i=0;i<n;i++)\n    for(j=0;j<k*p;j++)\n        if(s[i]==p[j%length(p)])\n            D[i][j] = D[i-1][j-1]\n         D[i][j] = min(D[i][j], D[i-1][j] + (j%length(p)!=length(p)-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 3",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 4",
          "code": "for(j=0;j<n;j++)\n    for(i=0;i<j;i++)\n        compute the transitions of D[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 5",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 6",
          "code": "if ((6 * i - 2) % 3 == 0) {\n  cout<<k * (6 * i - 4);\n} else {\n  cout<<k * (6 * i - 2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 7",
          "code": "D[i] can contribute to D[i + 1] with 0 or 1 removal and to D[A[i]] with A[i] - m removal(s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 8",
          "code": "input() * 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 9",
          "code": "int ans = (lower_bound+m-1)/m*m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 10",
          "code": "(lower_bound+m-1)/m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 11",
          "code": "long long t=m*(m-1)/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 12",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #272 Editorial - Codeforces - Code 13",
          "code": "int n,m;\n\t\tcin>>n>>m;\n\t\tif(n < m){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = n/2; i>=0; i--){\n\t\t\tif((n - i)%m == 0){\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans + (n - 2*ans)<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14256",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 400000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int r1 = inf.readInt(1, n, \"r1\");\n        inf.readSpace();\n        int c1_max = ai[r1 - 1];\n        int c1 = inf.readInt(0, c1_max, \"c1\");\n        inf.readSpace();\n\n        int r2 = inf.readInt(1, n, \"r2\");\n        inf.readSpace();\n        int c2_max = ai[r2 - 1];\n        int c2 = inf.readInt(0, c2_max, \"c2\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 400000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int r1 = inf.readInt(1, n, \"r1\");\n        inf.readSpace();\n        int c1_max = ai[r1 - 1];\n        int c1 = inf.readInt(0, c1_max, \"c1\");\n        inf.readSpace();\n\n        int r2 = inf.readInt(1, n, \"r2\");\n        inf.readSpace();\n        int c2_max = ai[r2 - 1];\n        int c2 = inf.readInt(0, c2_max, \"c2\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 400000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int r1 = inf.readInt(1, n, \"r1\");\n        inf.readSpace();\n        int c1_max = ai[r1 - 1];\n        int c1 = inf.readInt(0, c1_max, \"c1\");\n        inf.readSpace();\n\n        int r2 = inf.readInt(1, n, \"r2\");\n        inf.readSpace();\n        int c2_max = ai[r2 - 1];\n        int c2 = inf.readInt(0, c2_max, \"c2\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n\n    if(type == \"min_case\") {\n        // ai = 1\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if(type == \"max_case\") {\n        // ai = 1e8\n        for(int i = 0; i < n; ++i) {\n            a[i] = 100000000;\n        }\n    } else if(type == \"all_ones\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if(type == \"all_max\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 100000000;\n        }\n    } else if(type == \"random_small\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else if(type == \"random_large\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000000);\n        }\n    } else if(type == \"increasing_length\") {\n        int len = 1;\n        for(int i = 0; i < n; ++i) {\n            a[i] = len;\n            len = min(len + rnd.next(0, 10), 100000000);\n        }\n    } else if(type == \"decreasing_length\") {\n        int len = 100000000;\n        for(int i = 0; i < n; ++i) {\n            a[i] = len;\n            len = max(len - rnd.next(0, 10), 1);\n        }\n    } else {\n        // Default: random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Generate q queries\n    printf(\"%d\\n\", q);\n    for(int i = 0; i < q; ++i) {\n        int r1, c1, r2, c2;\n        if(type == \"same_positions\") {\n            // r1=r2, c1=c2\n            r1 = r2 = rnd.next(1, n);\n            int len = a[r1 - 1];\n            c1 = c2 = rnd.next(0, len);\n        } else if(type == \"move_line_only\") {\n            // c1=c2, r1!=r2\n            c1 = c2 = rnd.next(0, a[rnd.next(0, n - 1)]);\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } else if(type == \"move_column_only\") {\n            // r1=r2, c1!=c2\n            r1 = rnd.next(1, n);\n            r2 = r1;\n            int len = a[r1 - 1];\n            c1 = rnd.next(0, len);\n            c2 = rnd.next(0, len);\n        } else if(type == \"home_end_optimal\") {\n            // moving from somewhere to start or end of line\n            r1 = rnd.next(1, n);\n            int len1 = a[r1 - 1];\n            c1 = rnd.next(0, len1);\n            r2 = r1;\n            int action = rnd.next(2); // 0 for HOME, 1 for END\n            if(action == 0) c2 = 0;\n            else c2 = len1;\n        } else if(type == \"edge_cursor_positions\") {\n            // c1 or c2 at 0 or ai\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n            int len1 = a[r1 - 1];\n            int len2 = a[r2 - 1];\n            c1 = rnd.next(0, 1) * len1; // 0 or len1\n            c2 = rnd.next(0, 1) * len2; // 0 or len2\n        } else {\n            // Random positions\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n            int len1 = a[r1 - 1];\n            int len2 = a[r2 - 1];\n            c1 = rnd.next(0, len1);\n            c2 = rnd.next(0, len2);\n        }\n        printf(\"%d %d %d %d\\n\", r1, c1, r2, c2);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n\n    if(type == \"min_case\") {\n        // ai = 1\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if(type == \"max_case\") {\n        // ai = 1e8\n        for(int i = 0; i < n; ++i) {\n            a[i] = 100000000;\n        }\n    } else if(type == \"all_ones\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if(type == \"all_max\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 100000000;\n        }\n    } else if(type == \"random_small\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else if(type == \"random_large\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000000);\n        }\n    } else if(type == \"increasing_length\") {\n        int len = 1;\n        for(int i = 0; i < n; ++i) {\n            a[i] = len;\n            len = min(len + rnd.next(0, 10), 100000000);\n        }\n    } else if(type == \"decreasing_length\") {\n        int len = 100000000;\n        for(int i = 0; i < n; ++i) {\n            a[i] = len;\n            len = max(len - rnd.next(0, 10), 1);\n        }\n    } else {\n        // Default: random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Generate q queries\n    printf(\"%d\\n\", q);\n    for(int i = 0; i < q; ++i) {\n        int r1, c1, r2, c2;\n        if(type == \"same_positions\") {\n            // r1=r2, c1=c2\n            r1 = r2 = rnd.next(1, n);\n            int len = a[r1 - 1];\n            c1 = c2 = rnd.next(0, len);\n        } else if(type == \"move_line_only\") {\n            // c1=c2, r1!=r2\n            c1 = c2 = rnd.next(0, a[rnd.next(0, n - 1)]);\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } else if(type == \"move_column_only\") {\n            // r1=r2, c1!=c2\n            r1 = rnd.next(1, n);\n            r2 = r1;\n            int len = a[r1 - 1];\n            c1 = rnd.next(0, len);\n            c2 = rnd.next(0, len);\n        } else if(type == \"home_end_optimal\") {\n            // moving from somewhere to start or end of line\n            r1 = rnd.next(1, n);\n            int len1 = a[r1 - 1];\n            c1 = rnd.next(0, len1);\n            r2 = r1;\n            int action = rnd.next(2); // 0 for HOME, 1 for END\n            if(action == 0) c2 = 0;\n            else c2 = len1;\n        } else if(type == \"edge_cursor_positions\") {\n            // c1 or c2 at 0 or ai\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n            int len1 = a[r1 - 1];\n            int len2 = a[r2 - 1];\n            c1 = rnd.next(0, 1) * len1; // 0 or len1\n            c2 = rnd.next(0, 1) * len2; // 0 or len2\n        } else {\n            // Random positions\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n            int len1 = a[r1 - 1];\n            int len2 = a[r2 - 1];\n            c1 = rnd.next(0, len1);\n            c2 = rnd.next(0, len2);\n        }\n        printf(\"%d %d %d %d\\n\", r1, c1, r2, c2);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type min_case\n./gen -n 400000 -q 400000 -type max_case\n./gen -n 1000 -q 1000 -type random_small\n./gen -n 400000 -q 400000 -type random_large\n./gen -n 400000 -q 400000 -type all_ones\n./gen -n 400000 -q 400000 -type all_max\n./gen -n 100000 -q 100000 -type increasing_length\n./gen -n 100000 -q 100000 -type decreasing_length\n./gen -n 100000 -q 100000 -type same_positions\n./gen -n 100000 -q 100000 -type move_line_only\n./gen -n 100000 -q 100000 -type move_column_only\n./gen -n 100000 -q 100000 -type home_end_optimal\n./gen -n 100000 -q 100000 -type edge_cursor_positions\n./gen -n 400000 -q 400000 -type same_positions\n./gen -n 400000 -q 400000 -type move_line_only\n./gen -n 400000 -q 400000 -type move_column_only\n./gen -n 400000 -q 400000 -type home_end_optimal\n./gen -n 400000 -q 400000 -type edge_cursor_positions\n./gen -n 400000 -q 400000 -type random\n./gen -n 200000 -q 300000 -type random\n./gen -n 300000 -q 200000 -type random\n./gen -n 400000 -q 400000 -type random\n./gen -n 1 -q 100000 -type random\n./gen -n 100000 -q 1 -type random\n./gen -n 400000 -q 1 -type random\n./gen -n 1 -q 400000 -type random\n./gen -n 1000 -q 100000 -type random_small\n./gen -n 100000 -q 1000 -type random_small\n./gen -n 100000 -q 100000 -type random_small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:42.550272",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "478/A",
      "title": "A. Initial Bet",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of a single line containing five integers c1, c2, c3, c4 and c5 — the number of coins that the first, second, third, fourth and fifth players respectively have at the end of the game (0 ≤ c1, c2, c3, c4, c5 ≤ 100).",
      "output_spec": "OutputPrint the only line containing a single positive integer b — the number of coins in the initial bet of each player. If there is no such value of b, then print the only value \"-1\" (quotes for clarity).",
      "sample_tests": "ExamplesInputCopy2 5 4 0 4OutputCopy3InputCopy4 5 9 2 1OutputCopy-1",
      "description": "A. Initial Bet\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input consists of a single line containing five integers c1, c2, c3, c4 and c5 — the number of coins that the first, second, third, fourth and fifth players respectively have at the end of the game (0 ≤ c1, c2, c3, c4, c5 ≤ 100).\n\nOutputPrint the only line containing a single positive integer b — the number of coins in the initial bet of each player. If there is no such value of b, then print the only value \"-1\" (quotes for clarity).\n\nInputCopy2 5 4 0 4OutputCopy3InputCopy4 5 9 2 1OutputCopy-1\n\nInputCopy2 5 4 0 4\n\nOutputCopy3\n\nInputCopy4 5 9 2 1\n\nOutputCopy-1\n\nNoteIn the first sample the following sequence of operations is possible:  One coin is passed from the fourth player to the second player;  One coin is passed from the fourth player to the fifth player;  One coin is passed from the first player to the third player;  One coin is passed from the fourth player to the second player.",
      "solutions": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces",
          "content": "Hi, everyone!Regular Codeforces round #273 for participants from the second division will take place on 16 October, 19:30 MSK. Participants from the first division are able to participate out of the contest.Problem setter: pkhaustov (Khaustov Pavel, Russia, Tomsk, Tomsk Polytechnic University)Special thanks to Codeforces team and, in particular, Maxim Akhmedov (Zlobober) for help in round preparations and Maria Belova (Delinur) for translations.Participants will be given five problems and two hours to solve this problems.Points distribution: 500-1000-1500-2000-2500UPD: +10 minutes to startGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14282",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 606
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14307",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*A"
          },
          "content_length": 5769
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14307#comment-192751",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*A"
          },
          "content_length": 5769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 1",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 2",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int c1 = inf.readInt(0, 100, \"c1\");\n    inf.readSpace();\n    int c2 = inf.readInt(0, 100, \"c2\");\n    inf.readSpace();\n    int c3 = inf.readInt(0, 100, \"c3\");\n    inf.readSpace();\n    int c4 = inf.readInt(0, 100, \"c4\");\n    inf.readSpace();\n    int c5 = inf.readInt(0, 100, \"c5\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int c1 = inf.readInt(0, 100, \"c1\");\n    inf.readSpace();\n    int c2 = inf.readInt(0, 100, \"c2\");\n    inf.readSpace();\n    int c3 = inf.readInt(0, 100, \"c3\");\n    inf.readSpace();\n    int c4 = inf.readInt(0, 100, \"c4\");\n    inf.readSpace();\n    int c5 = inf.readInt(0, 100, \"c5\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int c1 = inf.readInt(0, 100, \"c1\");\n    inf.readSpace();\n    int c2 = inf.readInt(0, 100, \"c2\");\n    inf.readSpace();\n    int c3 = inf.readInt(0, 100, \"c3\");\n    inf.readSpace();\n    int c4 = inf.readInt(0, 100, \"c4\");\n    inf.readSpace();\n    int c5 = inf.readInt(0, 100, \"c5\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"valid\");\n    int sum_ci = opt<int>(\"sum\", -1);\n\n    vector<int> c(5);\n\n    if (type == \"valid\") {\n        if (sum_ci == -1) {\n            sum_ci = rnd.next(5, 500);\n            sum_ci = (sum_ci /5)*5;\n            sum_ci = max(5, sum_ci);\n        } else {\n            sum_ci = (sum_ci /5)*5;\n            sum_ci = max(5, min(sum_ci,500));\n        }\n\n        int remaining = sum_ci;\n        for(int i = 0; i < 5; ++i) {\n            c[i] = rnd.next(0, min(100, remaining));\n            remaining -= c[i];\n        }\n        while(remaining > 0) {\n            for(int i = 0; i <5 && remaining > 0; ++i) {\n                if(c[i] < 100) {\n                    ++c[i];\n                    --remaining;\n                }\n            }\n        }\n        int total = accumulate(c.begin(), c.end(), 0);\n        while(total > sum_ci) {\n            for(int i=0; i<5 && total>sum_ci; ++i) {\n                if(c[i]>0) {\n                    --c[i];\n                    --total;\n                }\n            }\n        }\n        shuffle(c.begin(), c.end());\n\n    } else if (type == \"invalid\") {\n        if (sum_ci == -1) {\n            sum_ci = rnd.next(5, 500);\n        } \n        if(sum_ci %5 ==0) {\n            sum_ci += 1;\n            if(sum_ci >500) sum_ci -=2;\n        }\n\n        sum_ci = max(5, min(sum_ci,500));\n\n        int remaining = sum_ci;\n        for(int i = 0; i < 5; ++i) {\n            c[i] = rnd.next(0, min(100, remaining));\n            remaining -= c[i];\n        }\n        while(remaining > 0) {\n            for(int i = 0; i <5 && remaining > 0; ++i) {\n                if(c[i] < 100) {\n                    ++c[i];\n                    --remaining;\n                }\n            }\n        }\n        int total = accumulate(c.begin(), c.end(), 0);\n        while(total > sum_ci) {\n            for(int i=0; i<5 && total>sum_ci; ++i) {\n                if(c[i]>0) {\n                    --c[i];\n                    --total;\n                }\n            }\n        }\n        shuffle(c.begin(), c.end());\n\n    } else if (type == \"edge\") {\n        // Edge cases with c_i = 0 or c_i =100\n\n        int num_hundred = rnd.next(0,5);\n        int num_zero = 5 - num_hundred;\n        c.assign(5,0);\n        for(int i =0; i < num_hundred; ++i) {\n            c[i] = 100;\n        }\n\n        int sum_ci = num_hundred*100;\n        if(sum_ci < 5) {\n            sum_ci = 5;\n            c.assign(5,1);\n        }\n\n        if (sum_ci %5 !=0) {\n            // Adjust to make sum divisible by 5\n            if(num_zero >0) {\n                c[num_hundred] += (5 - sum_ci%5);\n                sum_ci += (5 - sum_ci%5);\n            } else {\n                c[0] -= sum_ci%5;\n                sum_ci -= sum_ci%5;\n            }\n        }\n\n        if(sum_ci >500) {\n            sum_ci = 500;\n            c.assign(5,100);\n        }\n\n        shuffle(c.begin(), c.end());\n\n    } else {\n        // Default: valid case\n        if (sum_ci == -1) {\n            sum_ci = rnd.next(5, 500);\n            sum_ci = (sum_ci /5)*5;\n            sum_ci = max(5, sum_ci);\n        } else {\n            sum_ci = (sum_ci /5)*5;\n            sum_ci = max(5, min(sum_ci,500));\n        }\n\n        int remaining = sum_ci;\n        for(int i = 0; i < 5; ++i) {\n            c[i] = rnd.next(0, min(100, remaining));\n            remaining -= c[i];\n        }\n        while(remaining > 0) {\n            for(int i = 0; i <5 && remaining > 0; ++i) {\n                if(c[i] < 100) {\n                    ++c[i];\n                    --remaining;\n                }\n            }\n        }\n        int total = accumulate(c.begin(), c.end(), 0);\n        while(total > sum_ci) {\n            for(int i=0; i<5 && total>sum_ci; ++i) {\n                if(c[i]>0) {\n                    --c[i];\n                    --total;\n                }\n            }\n        }\n        shuffle(c.begin(), c.end());\n    }\n\n    for(int i = 0; i < 5; ++i) {\n        printf(\"%d%c\", c[i], (i ==4)? '\\n': ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"valid\");\n    int sum_ci = opt<int>(\"sum\", -1);\n\n    vector<int> c(5);\n\n    if (type == \"valid\") {\n        if (sum_ci == -1) {\n            sum_ci = rnd.next(5, 500);\n            sum_ci = (sum_ci /5)*5;\n            sum_ci = max(5, sum_ci);\n        } else {\n            sum_ci = (sum_ci /5)*5;\n            sum_ci = max(5, min(sum_ci,500));\n        }\n\n        int remaining = sum_ci;\n        for(int i = 0; i < 5; ++i) {\n            c[i] = rnd.next(0, min(100, remaining));\n            remaining -= c[i];\n        }\n        while(remaining > 0) {\n            for(int i = 0; i <5 && remaining > 0; ++i) {\n                if(c[i] < 100) {\n                    ++c[i];\n                    --remaining;\n                }\n            }\n        }\n        int total = accumulate(c.begin(), c.end(), 0);\n        while(total > sum_ci) {\n            for(int i=0; i<5 && total>sum_ci; ++i) {\n                if(c[i]>0) {\n                    --c[i];\n                    --total;\n                }\n            }\n        }\n        shuffle(c.begin(), c.end());\n\n    } else if (type == \"invalid\") {\n        if (sum_ci == -1) {\n            sum_ci = rnd.next(5, 500);\n        } \n        if(sum_ci %5 ==0) {\n            sum_ci += 1;\n            if(sum_ci >500) sum_ci -=2;\n        }\n\n        sum_ci = max(5, min(sum_ci,500));\n\n        int remaining = sum_ci;\n        for(int i = 0; i < 5; ++i) {\n            c[i] = rnd.next(0, min(100, remaining));\n            remaining -= c[i];\n        }\n        while(remaining > 0) {\n            for(int i = 0; i <5 && remaining > 0; ++i) {\n                if(c[i] < 100) {\n                    ++c[i];\n                    --remaining;\n                }\n            }\n        }\n        int total = accumulate(c.begin(), c.end(), 0);\n        while(total > sum_ci) {\n            for(int i=0; i<5 && total>sum_ci; ++i) {\n                if(c[i]>0) {\n                    --c[i];\n                    --total;\n                }\n            }\n        }\n        shuffle(c.begin(), c.end());\n\n    } else if (type == \"edge\") {\n        // Edge cases with c_i = 0 or c_i =100\n\n        int num_hundred = rnd.next(0,5);\n        int num_zero = 5 - num_hundred;\n        c.assign(5,0);\n        for(int i =0; i < num_hundred; ++i) {\n            c[i] = 100;\n        }\n\n        int sum_ci = num_hundred*100;\n        if(sum_ci < 5) {\n            sum_ci = 5;\n            c.assign(5,1);\n        }\n\n        if (sum_ci %5 !=0) {\n            // Adjust to make sum divisible by 5\n            if(num_zero >0) {\n                c[num_hundred] += (5 - sum_ci%5);\n                sum_ci += (5 - sum_ci%5);\n            } else {\n                c[0] -= sum_ci%5;\n                sum_ci -= sum_ci%5;\n            }\n        }\n\n        if(sum_ci >500) {\n            sum_ci = 500;\n            c.assign(5,100);\n        }\n\n        shuffle(c.begin(), c.end());\n\n    } else {\n        // Default: valid case\n        if (sum_ci == -1) {\n            sum_ci = rnd.next(5, 500);\n            sum_ci = (sum_ci /5)*5;\n            sum_ci = max(5, sum_ci);\n        } else {\n            sum_ci = (sum_ci /5)*5;\n            sum_ci = max(5, min(sum_ci,500));\n        }\n\n        int remaining = sum_ci;\n        for(int i = 0; i < 5; ++i) {\n            c[i] = rnd.next(0, min(100, remaining));\n            remaining -= c[i];\n        }\n        while(remaining > 0) {\n            for(int i = 0; i <5 && remaining > 0; ++i) {\n                if(c[i] < 100) {\n                    ++c[i];\n                    --remaining;\n                }\n            }\n        }\n        int total = accumulate(c.begin(), c.end(), 0);\n        while(total > sum_ci) {\n            for(int i=0; i<5 && total>sum_ci; ++i) {\n                if(c[i]>0) {\n                    --c[i];\n                    --total;\n                }\n            }\n        }\n        shuffle(c.begin(), c.end());\n    }\n\n    for(int i = 0; i < 5; ++i) {\n        printf(\"%d%c\", c[i], (i ==4)? '\\n': ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Valid test cases with specific sums\n./gen -type valid -sum 100\n./gen -type valid -sum 200\n./gen -type valid -sum 500\n./gen -type valid -sum 5\n./gen -type valid -sum 105\n\n# Invalid test cases with specific sums\n./gen -type invalid -sum 101\n./gen -type invalid -sum 201\n./gen -type invalid -sum 499\n./gen -type invalid -sum 6\n./gen -type invalid -sum 106\n\n# Edge cases\n./gen -type edge\n./gen -type edge\n./gen -type edge\n./gen -type edge\n\n# Random valid test cases\n./gen -type valid\n./gen -type valid\n./gen -type valid\n./gen -type valid\n./gen -type valid\n\n# Random invalid test cases\n./gen -type invalid\n./gen -type invalid\n./gen -type invalid\n./gen -type invalid\n./gen -type invalid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:44.176649",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "478/B",
      "title": "B. Случайные команды",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственная строке содержатся два целых числа n и m, разделенных одним пробелом (1 ≤ m ≤ n ≤ 109) — количество участников и количество команд соответственно.",
      "output_spec": "Выходные данныеТребуется вывести два целых числа kmin и kmax — минимальное возможное количество пар друзей и максимальное возможное количество пар друзей соответственно.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 1Выходные данныеСкопировать10 10Входные данныеСкопировать3 2Выходные данныеСкопировать1 1Входные данныеСкопировать6 3Выходные данныеСкопировать3 6",
      "description": "B. Случайные команды\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственная строке содержатся два целых числа n и m, разделенных одним пробелом (1 ≤ m ≤ n ≤ 109) — количество участников и количество команд соответственно.\n\nВходные данные\n\nВыходные данныеТребуется вывести два целых числа kmin и kmax — минимальное возможное количество пар друзей и максимальное возможное количество пар друзей соответственно.\n\nВыходные данные\n\nВходные данныеСкопировать5 1Выходные данныеСкопировать10 10Входные данныеСкопировать3 2Выходные данныеСкопировать1 1Входные данныеСкопировать6 3Выходные данныеСкопировать3 6\n\nВходные данныеСкопировать5 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10 10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере все участники попадают в одну команду, поэтому в любом случае будет образовано ровно десять пар друзей.Во втором примере при любом разбиении в одной из команд будет два участника, а в другой — один. В таком случае количество пар друзей всегда будет равно одному.В третьем примере минимальное количество друзей выходит при разбиении на команды по 2 человека, а максимальное — при разбиении на команды размерами 1, 1 и 4 человек.",
      "solutions": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces",
          "content": "Всем доброго времени суток,16 октября 2014 года в 19:30 MSK состоится очередной раунд Codeforces #273 для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Автор задач: pkhaustov (Хаустов Павел, Россия, Томск, Томский ПУ)За подготовку раунда отдельное спасибо коллективу Codeforces и, в частности, Максиму Ахмедову (Zlobober) за помощь в подготовке и Марии Беловой (Delinur) за перевод условий задач на английский язык.Участникам будет предложено пять задач и два часа на их решение.Распределение баллов по задачам: 500-1000-1500-2000-2500UPD: Старт сдвинут на 10 минутЖелаю удачи всем участникам!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14282",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 670
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14307",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*B"
          },
          "content_length": 5769
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14307#comment-192751",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*B"
          },
          "content_length": 5769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 1",
          "code": "int a = 0;\nfor (int i = 0; i < b; i++)\n  a += x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 2",
          "code": "int a = 0;\nfor (int i = 0; i < b; i++)\n  a += x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 3",
          "code": "int a = b * x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 4",
          "code": "int a = b * x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 5",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 6",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    long long m = opt<long long>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1LL <= n && n <= 1000000000LL);\n    if (m == -1) {\n        if (type == \"min_m\") {\n            m = 1;\n        } else if (type == \"max_m\") {\n            m = n;\n        } else if (type == \"half\") {\n            m = n / 2;\n            if (m == 0) m = 1;\n        } else if (type == \"random\") {\n            m = rnd.next(1LL, n);\n        } else {\n            // Default to random\n            m = rnd.next(1LL, n);\n        }\n    } else {\n        ensure(1LL <= m && m <= n);\n    }\n\n    printf(\"%lld %lld\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    long long m = opt<long long>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1LL <= n && n <= 1000000000LL);\n    if (m == -1) {\n        if (type == \"min_m\") {\n            m = 1;\n        } else if (type == \"max_m\") {\n            m = n;\n        } else if (type == \"half\") {\n            m = n / 2;\n            if (m == 0) m = 1;\n        } else if (type == \"random\") {\n            m = rnd.next(1LL, n);\n        } else {\n            // Default to random\n            m = rnd.next(1LL, n);\n        }\n    } else {\n        ensure(1LL <= m && m <= n);\n    }\n\n    printf(\"%lld %lld\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_m\n./gen -n 1 -type max_m\n./gen -n 1 -type random\n\n./gen -n 2 -type min_m\n./gen -n 2 -type max_m\n./gen -n 2 -type random\n\n./gen -n 10 -type min_m\n./gen -n 10 -type max_m\n./gen -n 10 -type half\n./gen -n 10 -type random\n\n./gen -n 100 -type min_m\n./gen -n 100 -type max_m\n./gen -n 100 -type half\n./gen -n 100 -type random\n\n./gen -n 1000 -type min_m\n./gen -n 1000 -type max_m\n./gen -n 1000 -type half\n./gen -n 1000 -type random\n\n./gen -n 1000000 -type min_m\n./gen -n 1000000 -type max_m\n./gen -n 1000000 -type half\n./gen -n 1000000 -type random\n\n./gen -n 1000000000 -type min_m\n./gen -n 1000000000 -type max_m\n./gen -n 1000000000 -type half\n./gen -n 1000000000 -type random\n\n./gen -n 999999999 -type min_m\n./gen -n 999999999 -type max_m\n./gen -n 999999999 -type random\n\n./gen -n 1000000000 -m 1\n./gen -n 1000000000 -m 2\n./gen -n 1000000000 -m 999999999\n./gen -n 1000000000 -m 1000000000\n\n./gen -n 1000000000 -m 500000000\n\n./gen -n 123456789 -m 1\n./gen -n 123456789 -m 123456789\n\n./gen -n 987654321 -type random\n\n./gen -n 1 -m 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:46.253560",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "478/C",
      "title": "C. Table Decorations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains three integers r, g and b (0 ≤ r, g, b ≤ 2·109) — the number of red, green and blue baloons respectively. The numbers are separated by exactly one space.",
      "output_spec": "OutputPrint a single integer t — the maximum number of tables that can be decorated in the required manner.",
      "sample_tests": "ExamplesInputCopy5 4 3OutputCopy4InputCopy1 1 1OutputCopy1InputCopy2 3 3OutputCopy2",
      "description": "C. Table Decorations\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains three integers r, g and b (0 ≤ r, g, b ≤ 2·109) — the number of red, green and blue baloons respectively. The numbers are separated by exactly one space.\n\nOutputPrint a single integer t — the maximum number of tables that can be decorated in the required manner.\n\nInputCopy5 4 3OutputCopy4InputCopy1 1 1OutputCopy1InputCopy2 3 3OutputCopy2\n\nInputCopy5 4 3\n\nOutputCopy4\n\nInputCopy1 1 1\n\nOutputCopy1\n\nInputCopy2 3 3\n\nOutputCopy2\n\nNoteIn the first sample you can decorate the tables with the following balloon sets: \"rgg\", \"gbb\", \"brr\", \"rrg\", where \"r\", \"g\" and \"b\" represent the red, green and blue balls, respectively.",
      "solutions": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces",
          "content": "Hi, everyone!Regular Codeforces round #273 for participants from the second division will take place on 16 October, 19:30 MSK. Participants from the first division are able to participate out of the contest.Problem setter: pkhaustov (Khaustov Pavel, Russia, Tomsk, Tomsk Polytechnic University)Special thanks to Codeforces team and, in particular, Maxim Akhmedov (Zlobober) for help in round preparations and Maria Belova (Delinur) for translations.Participants will be given five problems and two hours to solve this problems.Points distribution: 500-1000-1500-2000-2500UPD: +10 minutes to startGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14282",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 606
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14307",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*C"
          },
          "content_length": 5769
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14307#comment-192751",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*C"
          },
          "content_length": 5769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 1",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 2",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string line = inf.readLine(\"([0-9]{1,10}) ([0-9]{1,10}) ([0-9]{1,10})\");\n\n    istringstream iss(line);\n    long long r, g, b;\n    iss >> r >> g >> b;\n\n    ensuref(0LL <= r && r <= 2000000000LL, \"r must be between 0 and 2e9, but r=%lld\", r);\n    ensuref(0LL <= g && g <= 2000000000LL, \"g must be between 0 and 2e9, but g=%lld\", g);\n    ensuref(0LL <= b && b <= 2000000000LL, \"b must be between 0 and 2e9, but b=%lld\", b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string line = inf.readLine(\"([0-9]{1,10}) ([0-9]{1,10}) ([0-9]{1,10})\");\n\n    istringstream iss(line);\n    long long r, g, b;\n    iss >> r >> g >> b;\n\n    ensuref(0LL <= r && r <= 2000000000LL, \"r must be between 0 and 2e9, but r=%lld\", r);\n    ensuref(0LL <= g && g <= 2000000000LL, \"g must be between 0 and 2e9, but g=%lld\", g);\n    ensuref(0LL <= b && b <= 2000000000LL, \"b must be between 0 and 2e9, but b=%lld\", b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string line = inf.readLine(\"([0-9]{1,10}) ([0-9]{1,10}) ([0-9]{1,10})\");\n\n    istringstream iss(line);\n    long long r, g, b;\n    iss >> r >> g >> b;\n\n    ensuref(0LL <= r && r <= 2000000000LL, \"r must be between 0 and 2e9, but r=%lld\", r);\n    ensuref(0LL <= g && g <= 2000000000LL, \"g must be between 0 and 2e9, but g=%lld\", g);\n    ensuref(0LL <= b && b <= 2000000000LL, \"b must be between 0 and 2e9, but b=%lld\", b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random_large\");\n    long long max_value = opt<long long>(\"max_value\", 2000000000LL); // By default 2e9\n    long long min_value = opt<long long>(\"min_value\", 0LL);\n\n    // Ensure min_value and max_value are within valid bounds\n    if (min_value < 0LL)\n        min_value = 0LL;\n    if (max_value > 2000000000LL)\n        max_value = 2000000000LL;\n    if (min_value > max_value)\n        swap(min_value, max_value);\n\n    long long r, g, b;\n\n    if (type == \"zeroes\") {\n        // All zeros\n        r = 0;\n        g = 0;\n        b = 0;\n    } else if (type == \"ones\") {\n        // All ones\n        r = 1;\n        g = 1;\n        b = 1;\n    } else if (type == \"random_small\") {\n        long long small_max = opt<long long>(\"small_max\", 100LL);\n        // Adjust small_max if necessary\n        if (small_max > max_value)\n            small_max = max_value;\n        if (small_max < min_value)\n            small_max = min_value;\n        r = rnd.next(min_value, small_max);\n        g = rnd.next(min_value, small_max);\n        b = rnd.next(min_value, small_max);\n    } else if (type == \"random_large\") {\n        r = rnd.next(min_value, max_value);\n        g = rnd.next(min_value, max_value);\n        b = rnd.next(min_value, max_value);\n    } else if (type == \"max_one\") {\n        int color = rnd.next(0,2);\n        if (color == 0) {\n            r = max_value;\n            g = min_value;\n            b = min_value;\n        } else if (color == 1) {\n            r = min_value;\n            g = max_value;\n            b = min_value;\n        } else {\n            r = min_value;\n            g = min_value;\n            b = max_value;\n        }\n    } else if (type == \"max_all\") {\n        r = max_value;\n        g = max_value;\n        b = max_value;\n    } else if (type == \"one_zero\") {\n        int color = rnd.next(0,2);\n        if (color == 0) {\n            r = min_value;\n            g = rnd.next(min_value, max_value);\n            b = rnd.next(min_value, max_value);\n        } else if (color == 1) {\n            r = rnd.next(min_value, max_value);\n            g = min_value;\n            b = rnd.next(min_value, max_value);\n        } else {\n            r = rnd.next(min_value, max_value);\n            g = rnd.next(min_value, max_value);\n            b = min_value;\n        }\n    } else if (type == \"two_zeros\") {\n        int color = rnd.next(0,2);\n        if (color == 0) {\n            r = rnd.next(min_value, max_value);\n            g = min_value;\n            b = min_value;\n        } else if (color == 1) {\n            r = min_value;\n            g = rnd.next(min_value, max_value);\n            b = min_value;\n        } else {\n            r = min_value;\n            g = min_value;\n            b = rnd.next(min_value, max_value);\n        }\n    } else if (type == \"equal_random\") {\n        r = rnd.next(min_value, max_value);\n        g = r;\n        b = r;\n    } else if (type == \"one_large_others_small\") {\n        int color = rnd.next(0,2);\n        long long small_value = rnd.next(min_value, min(max_value, min_value + 100LL));\n        if (color == 0) {\n            r = max_value;\n            g = small_value;\n            b = small_value;\n        } else if (color == 1) {\n            r = small_value;\n            g = max_value;\n            b = small_value;\n        } else {\n            r = small_value;\n            g = small_value;\n            b = max_value;\n        }\n    } else if (type == \"one_small_others_large\") {\n        int color = rnd.next(0,2);\n        long long small_value = rnd.next(min_value, min(max_value, min_value + 100LL));\n        if (color == 0) {\n            r = small_value;\n            g = max_value;\n            b = max_value;\n        } else if (color == 1) {\n            r = max_value;\n            g = small_value;\n            b = max_value;\n        } else {\n            r = max_value;\n            g = max_value;\n            b = small_value;\n        }\n    } else {\n        // Default case: random_large\n        r = rnd.next(min_value, max_value);\n        g = rnd.next(min_value, max_value);\n        b = rnd.next(min_value, max_value);\n    }\n\n    printf(\"%lld %lld %lld\\n\", r, g, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random_large\");\n    long long max_value = opt<long long>(\"max_value\", 2000000000LL); // By default 2e9\n    long long min_value = opt<long long>(\"min_value\", 0LL);\n\n    // Ensure min_value and max_value are within valid bounds\n    if (min_value < 0LL)\n        min_value = 0LL;\n    if (max_value > 2000000000LL)\n        max_value = 2000000000LL;\n    if (min_value > max_value)\n        swap(min_value, max_value);\n\n    long long r, g, b;\n\n    if (type == \"zeroes\") {\n        // All zeros\n        r = 0;\n        g = 0;\n        b = 0;\n    } else if (type == \"ones\") {\n        // All ones\n        r = 1;\n        g = 1;\n        b = 1;\n    } else if (type == \"random_small\") {\n        long long small_max = opt<long long>(\"small_max\", 100LL);\n        // Adjust small_max if necessary\n        if (small_max > max_value)\n            small_max = max_value;\n        if (small_max < min_value)\n            small_max = min_value;\n        r = rnd.next(min_value, small_max);\n        g = rnd.next(min_value, small_max);\n        b = rnd.next(min_value, small_max);\n    } else if (type == \"random_large\") {\n        r = rnd.next(min_value, max_value);\n        g = rnd.next(min_value, max_value);\n        b = rnd.next(min_value, max_value);\n    } else if (type == \"max_one\") {\n        int color = rnd.next(0,2);\n        if (color == 0) {\n            r = max_value;\n            g = min_value;\n            b = min_value;\n        } else if (color == 1) {\n            r = min_value;\n            g = max_value;\n            b = min_value;\n        } else {\n            r = min_value;\n            g = min_value;\n            b = max_value;\n        }\n    } else if (type == \"max_all\") {\n        r = max_value;\n        g = max_value;\n        b = max_value;\n    } else if (type == \"one_zero\") {\n        int color = rnd.next(0,2);\n        if (color == 0) {\n            r = min_value;\n            g = rnd.next(min_value, max_value);\n            b = rnd.next(min_value, max_value);\n        } else if (color == 1) {\n            r = rnd.next(min_value, max_value);\n            g = min_value;\n            b = rnd.next(min_value, max_value);\n        } else {\n            r = rnd.next(min_value, max_value);\n            g = rnd.next(min_value, max_value);\n            b = min_value;\n        }\n    } else if (type == \"two_zeros\") {\n        int color = rnd.next(0,2);\n        if (color == 0) {\n            r = rnd.next(min_value, max_value);\n            g = min_value;\n            b = min_value;\n        } else if (color == 1) {\n            r = min_value;\n            g = rnd.next(min_value, max_value);\n            b = min_value;\n        } else {\n            r = min_value;\n            g = min_value;\n            b = rnd.next(min_value, max_value);\n        }\n    } else if (type == \"equal_random\") {\n        r = rnd.next(min_value, max_value);\n        g = r;\n        b = r;\n    } else if (type == \"one_large_others_small\") {\n        int color = rnd.next(0,2);\n        long long small_value = rnd.next(min_value, min(max_value, min_value + 100LL));\n        if (color == 0) {\n            r = max_value;\n            g = small_value;\n            b = small_value;\n        } else if (color == 1) {\n            r = small_value;\n            g = max_value;\n            b = small_value;\n        } else {\n            r = small_value;\n            g = small_value;\n            b = max_value;\n        }\n    } else if (type == \"one_small_others_large\") {\n        int color = rnd.next(0,2);\n        long long small_value = rnd.next(min_value, min(max_value, min_value + 100LL));\n        if (color == 0) {\n            r = small_value;\n            g = max_value;\n            b = max_value;\n        } else if (color == 1) {\n            r = max_value;\n            g = small_value;\n            b = max_value;\n        } else {\n            r = max_value;\n            g = max_value;\n            b = small_value;\n        }\n    } else {\n        // Default case: random_large\n        r = rnd.next(min_value, max_value);\n        g = rnd.next(min_value, max_value);\n        b = rnd.next(min_value, max_value);\n    }\n\n    printf(\"%lld %lld %lld\\n\", r, g, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type zeroes\n./gen -type ones\n./gen -type max_all\n./gen -type max_one\n\n./gen -type random_small -small_max 10\n./gen -type random_small -small_max 100\n./gen -type random_small -small_max 1000\n\n./gen -type random_large -max_value 100000\n./gen -type random_large -max_value 1000000\n./gen -type random_large\n\n./gen -type one_zero\n./gen -type one_zero -max_value 2000000000\n\n./gen -type two_zeros\n./gen -type two_zeros -max_value 100\n\n./gen -type equal_random -max_value 0\n./gen -type equal_random -max_value 500\n./gen -type equal_random -max_value 2000000000\n\n./gen -type one_large_others_small\n./gen -type one_large_others_small -max_value 1000000000\n\n./gen -type one_small_others_large\n./gen -type one_small_others_large -max_value 2000000000\n\n# Multiple runs to get diverse random data\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n./gen -type random_small -small_max 50\n./gen -type random_small -small_max 20\n\n# Edge test cases\n./gen -type random_small -small_max 0\n\n# Test with min_value greater than max_value\n./gen -type random_large -min_value 1000 -max_value 10\n\n# Test with negative min_value\n./gen -type random_large -min_value -100 -max_value 1000\n\n# Test max_value exceeding the limit\n./gen -type random_large -max_value 3000000000\n\n# Test min_value exceeding limit\n./gen -type random_large -min_value 10000000000\n\n# Test min_value exceeding max_value\n./gen -type random_large -min_value 1000 -max_value 500\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:48.434192",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "478/D",
      "title": "D. Red-Green Towers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains two integers r and g, separated by a single space — the number of available red and green blocks respectively (0 ≤ r, g ≤ 2·105, r + g ≥ 1).",
      "output_spec": "OutputOutput the only integer — the number of different possible red-green towers of height h modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy4 6OutputCopy2InputCopy9 7OutputCopy6InputCopy1 1OutputCopy2",
      "description": "D. Red-Green Towers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line of input contains two integers r and g, separated by a single space — the number of available red and green blocks respectively (0 ≤ r, g ≤ 2·105, r + g ≥ 1).\n\nOutputOutput the only integer — the number of different possible red-green towers of height h modulo 109 + 7.\n\nInputCopy4 6OutputCopy2InputCopy9 7OutputCopy6InputCopy1 1OutputCopy2\n\nInputCopy4 6\n\nOutputCopy2\n\nInputCopy9 7\n\nOutputCopy6\n\nInputCopy1 1\n\nOutputCopy2\n\nNoteThe image in the problem statement shows all possible red-green towers for the first sample.",
      "solutions": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces",
          "content": "Hi, everyone!Regular Codeforces round #273 for participants from the second division will take place on 16 October, 19:30 MSK. Participants from the first division are able to participate out of the contest.Problem setter: pkhaustov (Khaustov Pavel, Russia, Tomsk, Tomsk Polytechnic University)Special thanks to Codeforces team and, in particular, Maxim Akhmedov (Zlobober) for help in round preparations and Maria Belova (Delinur) for translations.Participants will be given five problems and two hours to solve this problems.Points distribution: 500-1000-1500-2000-2500UPD: +10 minutes to startGood luck!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14282",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 606
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14307",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*D"
          },
          "content_length": 5769
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14307#comment-192751",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*D"
          },
          "content_length": 5769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 1",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 2",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(0, 200000, \"r\");\n    inf.readSpace();\n    int g = inf.readInt(0, 200000, \"g\");\n    inf.readEoln();\n    ensuref(r + g >= 1, \"r + g must be at least 1, but r + g = %d\", r + g);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(0, 200000, \"r\");\n    inf.readSpace();\n    int g = inf.readInt(0, 200000, \"g\");\n    inf.readEoln();\n    ensuref(r + g >= 1, \"r + g must be at least 1, but r + g = %d\", r + g);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(0, 200000, \"r\");\n    inf.readSpace();\n    int g = inf.readInt(0, 200000, \"g\");\n    inf.readEoln();\n    ensuref(r + g >= 1, \"r + g must be at least 1, but r + g = %d\", r + g);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse options\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_blocks = 200000; // As per problem constraints\n\n    if (type == \"min\") {\n        // Minimal values\n        int r = 1;\n        int g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"max\") {\n        // Maximal values\n        int r = 200000;\n        int g = 200000;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"only_red\") {\n        // Only red blocks\n        int r = 200000;\n        int g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"only_green\") {\n        // Only green blocks\n        int r = 0;\n        int g = 200000;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"exact_blocks\") {\n        // total_blocks = h(h+1)/2\n        int h = rnd.next(1, 600); // Ensure total_blocks <= 400000\n        int total_blocks = h * (h + 1) / 2;\n        if (total_blocks > 400000) {\n            h--;\n            total_blocks = h * (h + 1) / 2;\n        }\n        int r = rnd.next(0, min(total_blocks, max_blocks));\n        int g = total_blocks - r;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"just_under_blocks\") {\n        // total_blocks = h(h+1)/2 - 1\n        int h = rnd.next(1, 600);\n        int total_blocks = h * (h + 1) / 2 - 1;\n        if (total_blocks > 400000) {\n            h--;\n            total_blocks = h * (h + 1) / 2 - 1;\n        }\n        int r = rnd.next(0, min(total_blocks, max_blocks));\n        int g = total_blocks - r;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"just_over_blocks\") {\n        // total_blocks = h(h+1)/2 + 1\n        int h = rnd.next(1, 600);\n        int total_blocks = h * (h + 1) / 2 + 1;\n        if (total_blocks > 400000) {\n            h--;\n            total_blocks = h * (h + 1) / 2 + 1;\n        }\n        int r = rnd.next(0, min(total_blocks, max_blocks));\n        int g = total_blocks - r;\n        if (g < 0) g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"random_large\") {\n        // Random large values\n        int total_blocks = rnd.next(1, 400000);\n        int r = rnd.next(0, min(total_blocks, max_blocks));\n        int g = total_blocks - r;\n        if (g < 0) g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"random\") {\n        // Random within constraints\n        int r = rnd.next(0, max_blocks);\n        int g = rnd.next(0, max_blocks);\n        if (r + g == 0) {\n            // Ensure r + g ≥ 1\n            if (rnd.next(0,1))\n                r = 1;\n            else\n                g = 1;\n        }\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"ratio\") {\n        // Fixed ratio of red to green\n        double red_ratio = opt<double>(\"ratio\", 0.5); // default to 0.5\n        int total_blocks = rnd.next(1, 400000);\n        int r = min(int(total_blocks * red_ratio), max_blocks);\n        int g = total_blocks - r;\n        if (g < 0) g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else {\n        // Default to random\n        int r = rnd.next(0, max_blocks);\n        int g = rnd.next(0, max_blocks);\n        if (r + g == 0) {\n            if (rnd.next(0,1))\n                r = 1;\n            else\n                g = 1;\n        }\n        printf(\"%d %d\\n\", r, g);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse options\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_blocks = 200000; // As per problem constraints\n\n    if (type == \"min\") {\n        // Minimal values\n        int r = 1;\n        int g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"max\") {\n        // Maximal values\n        int r = 200000;\n        int g = 200000;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"only_red\") {\n        // Only red blocks\n        int r = 200000;\n        int g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"only_green\") {\n        // Only green blocks\n        int r = 0;\n        int g = 200000;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"exact_blocks\") {\n        // total_blocks = h(h+1)/2\n        int h = rnd.next(1, 600); // Ensure total_blocks <= 400000\n        int total_blocks = h * (h + 1) / 2;\n        if (total_blocks > 400000) {\n            h--;\n            total_blocks = h * (h + 1) / 2;\n        }\n        int r = rnd.next(0, min(total_blocks, max_blocks));\n        int g = total_blocks - r;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"just_under_blocks\") {\n        // total_blocks = h(h+1)/2 - 1\n        int h = rnd.next(1, 600);\n        int total_blocks = h * (h + 1) / 2 - 1;\n        if (total_blocks > 400000) {\n            h--;\n            total_blocks = h * (h + 1) / 2 - 1;\n        }\n        int r = rnd.next(0, min(total_blocks, max_blocks));\n        int g = total_blocks - r;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"just_over_blocks\") {\n        // total_blocks = h(h+1)/2 + 1\n        int h = rnd.next(1, 600);\n        int total_blocks = h * (h + 1) / 2 + 1;\n        if (total_blocks > 400000) {\n            h--;\n            total_blocks = h * (h + 1) / 2 + 1;\n        }\n        int r = rnd.next(0, min(total_blocks, max_blocks));\n        int g = total_blocks - r;\n        if (g < 0) g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"random_large\") {\n        // Random large values\n        int total_blocks = rnd.next(1, 400000);\n        int r = rnd.next(0, min(total_blocks, max_blocks));\n        int g = total_blocks - r;\n        if (g < 0) g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"random\") {\n        // Random within constraints\n        int r = rnd.next(0, max_blocks);\n        int g = rnd.next(0, max_blocks);\n        if (r + g == 0) {\n            // Ensure r + g ≥ 1\n            if (rnd.next(0,1))\n                r = 1;\n            else\n                g = 1;\n        }\n        printf(\"%d %d\\n\", r, g);\n    }\n    else if (type == \"ratio\") {\n        // Fixed ratio of red to green\n        double red_ratio = opt<double>(\"ratio\", 0.5); // default to 0.5\n        int total_blocks = rnd.next(1, 400000);\n        int r = min(int(total_blocks * red_ratio), max_blocks);\n        int g = total_blocks - r;\n        if (g < 0) g = 0;\n        printf(\"%d %d\\n\", r, g);\n    }\n    else {\n        // Default to random\n        int r = rnd.next(0, max_blocks);\n        int g = rnd.next(0, max_blocks);\n        if (r + g == 0) {\n            if (rnd.next(0,1))\n                r = 1;\n            else\n                g = 1;\n        }\n        printf(\"%d %d\\n\", r, g);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type only_red\n./gen -type only_green\n\n./gen -type exact_blocks\n./gen -type exact_blocks\n\n./gen -type just_under_blocks\n./gen -type just_under_blocks\n\n./gen -type just_over_blocks\n./gen -type just_over_blocks\n\n./gen -type random_large\n./gen -type random_large\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type ratio -ratio 0.1\n./gen -type ratio -ratio 0.9\n./gen -type ratio -ratio 0.5\n./gen -type ratio -ratio 0.75\n./gen -type ratio -ratio 0.25\n./gen -type ratio -ratio 0.99\n./gen -type ratio -ratio 0.01\n\n./gen -type exact_blocks\n./gen -type just_under_blocks\n./gen -type just_over_blocks\n./gen -type random_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:50.633732",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "478/E",
      "title": "E. Волнистые числа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке содержатся два целых числа n и k, разделенных одним пробелом (1 ≤ n, k ≤ 1014).",
      "output_spec": "Выходные данныеТребуется вывести единственное целое число r — ответ на задачу. Если такого числа не существует или оно больше 1014, то требуется вывести «-1» (минус единицу без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать123 4Выходные данныеСкопировать1845Входные данныеСкопировать100 1Выходные данныеСкопировать-1Входные данныеСкопировать97461 457Выходные данныеСкопировать1805270103",
      "description": "E. Волнистые числа\n\nограничение по времени на тест1.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке содержатся два целых числа n и k, разделенных одним пробелом (1 ≤ n, k ≤ 1014).\n\nВходные данные\n\nВыходные данныеТребуется вывести единственное целое число r — ответ на задачу. Если такого числа не существует или оно больше 1014, то требуется вывести «-1» (минус единицу без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать123 4Выходные данныеСкопировать1845Входные данныеСкопировать100 1Выходные данныеСкопировать-1Входные данныеСкопировать97461 457Выходные данныеСкопировать1805270103\n\nВходные данныеСкопировать123 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1845\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать100 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать97461 457\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1805270103\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЗначения первых четырех волнистых чисел кратных n для первого примера входных данных: 492, 615, 738 и 1845.",
      "solutions": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces",
          "content": "Всем доброго времени суток,16 октября 2014 года в 19:30 MSK состоится очередной раунд Codeforces #273 для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Автор задач: pkhaustov (Хаустов Павел, Россия, Томск, Томский ПУ)За подготовку раунда отдельное спасибо коллективу Codeforces и, в частности, Максиму Ахмедову (Zlobober) за помощь в подготовке и Марии Беловой (Delinur) за перевод условий задач на английский язык.Участникам будет предложено пять задач и два часа на их решение.Распределение баллов по задачам: 500-1000-1500-2000-2500UPD: Старт сдвинут на 10 минутЖелаю удачи всем участникам!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14282",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 670
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14307",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*E"
          },
          "content_length": 5769
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces",
          "content": "478A - Initial BetДля решения задачи важно заметить, что в ходе игры количество монет на столе меняться не может. Суммарное количество монет на столе после того, как сделаны ставки, остается неизменным. Следовательно, разделив суммарное количество монет на столе на количество игроков, можно получить начальную ставку каждого из них. Если разделить без остатка невозможно, то такой итог игры невозможен. Стоит обратить внимание на то, что начальная ставка каждого из игроков должна быть отлична от нуля, следовательно, ноль никогда не может являться ответом.478B - Random TeamsЕсли переформулировать задачу в терминах теории графов, то ее можно сформулировать следующим образом: Имеется граф, состоящий из n вершин и m компонент связности. Внутри каждой компоненты связности каждая пара вершин этой компоненты связана ребром. Другими словами, каждая компонента связности является полносвязной. Какое наименьшее и какое наибольшее количество ребер может содержать такой граф? Рассмотрим процесс построения графа из n вершин и m компонент связности. Для начала предположим, что каждая из m компонент содержит ровно одну вершину. Остается распределить оставшиеся n - m вершин так, чтобы минимизировать или максимизировать количество ребер. Заметим, что при добавлении новой вершины в компоненту связности размера k, количество ребер увеличивается на k (новая вершина соединяется с каждой из уже существующих одним ребром). Следовательно, для того, чтобы минимизировать количество образованных ребер на каждом шаге, требуется каждый раз добавлять вершину в компоненту связности наименьшего размера. Если действовать согласно такой стратегии, то после распределения вершин по компонентам связности появится компонент размера и компонент размера . Аналогично, для того, чтобы максимизировать количество ребер, на каждом шаге необходимо добавлять очередную вершину в компонентну связности наибольшего размера. Если действовать согласно такой стратегии, то образуется одна компонента связности размера n - m + 1, оставшиеся компоненты связности будут состоять из одной вершины. Зная количество компонент связности и их размеры, можно посчитать общее количество ребер. Для полносвязной компоненты, состоящей из k вершин, количество ребер равняется . Следует помнить про необходимость использовать 64-битный тип данных для хранения количества ребер, которое квадратично зависит от значения n.478C - Table DecorationsРассмотрим ситуацию, когда величина max(r, g, b) - min(r, g, b) ≤ 1, в таком случае, очевидно, ответ равен . Мы всегда можем украсить столько столов тремя воздушными шарами разных цветов. Очевидно, что оставшееся количество шаров будет меньше трех и, следовательно, не может быть использовано для украшения стола в любом случае. Все оставшиеся случаи имеет смысл свести к ранее рассмотренному. Если есть один цвет такой, что количество шариков этого цвета больше, чем суммарное количество шариков для оставшихся двух цветов, то всега выгодно украшать стол двумя шарами этого цвета и одним шаром того из оставшихся цветов, которого больше на данный момент. Далее можно разными способами группировать операции и выполнять более одной операции за раз. Другим решением можно назвать тот факт, что ответ будет отличен от , но только тогда, когда max(r, g, b) ≥ 2·(r + g + b - max(r, g, b)), в таком случае ответ r + g + b - max(r, g, b). В этом случае шарики двух наиболее редких цветов закончатся раньше, чем шарики одного наиболее популярного, если украшать каждый стол с использованием двух шариков наиболее популярного цвета.478D - Red-Green TowersДля начала можно заметить, что для того, чтобы построить красно-зеленую башню высоты h потребуется кубиков. Следовательно, высота полученной башни для заданных ограничений никогда не превысит 893. Эту высоту можно определить заранее, если предположить, что все кубики одного цвета. Попробуйте доказать это самостоятельно. Далее можно решить задачу с использованием динамического программирования. Пусть F(t, r) — количество способов собрать башню наибольшей высоты, если собрано t верхних этажей и остались незадействованными r красных кубиков. Среди аргументов функции нет количества оставшихся зеленых кубиков g — его можно однозначно определить из значений t и r: , где r0 и g0 — изначальное количество красных и зеленых кубиков, соответственно. Ну а дальше следует рассмотреть лишь два перехода: пострить t + 1-ый уровень из красных или из зеленых кубиков: F(t, r) = F(t + 1, r - t) + F(t + 1, r). Очевидно, кешировать данные в массиве размера 893 × 2·105 — не лучшая затея. В таком случае можно подсчитывать значения функции для всех значений t от 0 до h, храня в памяти только значения для текущего значения t и для предыдущего, от которого оно будет зависеть.478E - Wavy numbersДля решения этой задачи необходимо было заметить, что волнистых чисел на интервале от 0 до 107 намного меньше, чем 107. В таком случае можно решить задачу с использованием подхода meet-in-the-middle. То есть отдельно решить эту задачу для первых семи цифр ответа, и для последних семи цифр ответа. Для этого потребуется отдельно сгенерировать все волнистые числа на интервале от 0 до 107, которые начинаются с возрастания двух соседних цифр, и аналогичные волнистые числа, которые начинаются с убывания двух соседних цифр. Дальше для каждой первой половины мы можем посчитать rl — ее остаток от деления на n и, затем, определить количество подходящих вторых половин, которые должны иметь остаток от деления равный .Для задачи было установлено ограничение времени равное 1.5 сек. На самом деле, если написать решение с подходом meet-in-the-middle достаточно оптимально, то решению потребуется гораздо меньше времени. Приведенная авторская реализация (8271836) умеет решать аналогичную задачу для 1 ≤ n, k ≤ 1016 примерно за 2.5 сек.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14307#comment-192751",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 478\\s*E"
          },
          "content_length": 5769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 1",
          "code": "int a = 0;\nfor (int i = 0; i < b; i++)\n  a += x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 2",
          "code": "int a = 0;\nfor (int i = 0; i < b; i++)\n  a += x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 3",
          "code": "int a = b * x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 4",
          "code": "int a = b * x;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 5",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) - Codeforces - Code 6",
          "code": "long long pair(long long a){// pairs in command\n\treturn (a*(a-1)/2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14282",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#includ <algorithm>\nusing namespace std;\ntypedef long long ll;\nint v[3];\nbool can(ll m){\n    ll z[3] = { v[0], v[1], v[2] };\n    ll done = min(z[2], z[1]+z[0]);\n    done = min(done, m);\n    z[2] -= done;\n    ll take = min(z[1], done);\n    z[1] -= take;\n    z[0] -= done - take;\n    sort(z, z + 3);\n    ll rem = m - done;\n    if (z[2]<rem || z[1]<rem)\n        return false;\n    return true;\n}\nint main()\n{\n    for (int i = 0; i < 3; ++i)\n        scanf(\"%d\", v + i);\n    sort(v, v + 3);\n    ll l = 0, r = ((ll)v[0] + v[1] + v[2]) / 3, m, res = 0;\n    while (l <= r){\n        m = (l + r) / 2;\n        if (can(m)){\n            l = m + 1;\n            res = m;\n        }else\n            r = m - 1;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 3",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 4",
          "code": "void ProSolve() {\n\tsort(a.begin(), a.end(), greater<i64>());\n\twhile (a[1] > 0 && a[0] + a[1] + a[2] > 2) {\n\t\t//cout << a << endl;\n\t\tif (a[0] == a[2]) {ans += a[0]; break;}\n\t\tif (a[1] == a[2]) {\n\t\t\ti64 diff = min((a[0]-a[1])/3, a[1]);\n\t\t\tif (diff == 0) {ans += a[2]; break;}\n\t\t\tans += 2 * diff; a[0] -= diff * 4; a[1] -= diff; a[2] -= diff;\n\t\t\tsort(a.begin(), a.end(), greater<i64>()); continue;\n\t\t}\n\t\ti64 diff = min(min(a[0]-a[1], a[1]), a[1]-a[2]);\n\t\tans += diff; a[0] -= 2*diff; a[1] -= diff;\n\t\tif (a[1] > a[2]) {\n\t\t\tdiff = (a[0]-a[2])/3; ans += 2*diff;\n\t\t\ta[0] -= 3*diff; a[1] -= 3*diff;\n\t\t\tif (a[0] - a[2] > 1) {\n\t\t\t\tans++; a[0] -= 2; a[1]--;\n\t\t\t}\n\t\t\telse if (diff == 0) {ans += a[2]; break;}\n\t\t}\n\t\tsort(a.begin(), a.end(), greater<i64>());\n\t}\n\tcout << ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 5",
          "code": "max ( r , b , c ) - min ( r , b , c ) <= 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 6",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #273 (Div. 2) :: разбор задач - Codeforces - Code 7",
          "code": "bool check(ll mid, vector<ll> a){\n    sort(a.begin(), a.end());\n\n    // [1st, 2nd, 3rd]\n\n        // --> for 1st\n    a[2] -= mid; // for all table, atleast one must be from the largest\n\n        // --> for 2nd\n    ll used = min(a[1], mid); // 2nd one will either be from middle or from lowest if needed\n    a[1] -= used;\n    ll rem = mid - used;\n    a[0] -= rem;\n\n        // --> for 3rd\n    if(a[2]+a[1]+a[0] < mid) // last one can be taken from any\n        return false;\n\n        // if any bottleneck\n    if(a[0]<0 || a[1]<0 || a[2]<0)\n        return false;\n\n    return true;\n}\n\nvoid useless() {\n    vector<ll> clrs(3);\n    cin >> clrs[0] >> clrs[1] >> clrs[2];\n\n    ll low = 0;\n    ll high = 1e10; \n    ll tbls = 0;\n\n    while(low <= high){\n        ll mid = (low + high)/2;\n\n        bool isPoss = check(mid, clrs);\n\n        if(isPoss)\n            tbls = mid,low = mid+1;\n        else\n            high = mid-1;\n    }\n\n    cout << tbls;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14307#comment-192751",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 100000000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 100000000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 100000000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Maximum values for n and k, default to 1e14 if not provided\n    long long MaxN = opt<long long>(\"MaxN\", (long long)1e14);\n    long long MaxK = opt<long long>(\"MaxK\", (long long)1e14);\n    \n    // Type of test case to generate\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n, k;\n\n    if (type == \"max_n_k\") {\n        // Both n and k at their maximum values\n        n = MaxN;\n        k = MaxK;\n    } else if (type == \"small_values\") {\n        // Small random values for n and k\n        n = rnd.next(1LL, 100LL);\n        k = rnd.next(1LL, 100LL);\n    } else if (type == \"random_large\") {\n        // Random large values for n and k\n        n = rnd.next((long long)(1e14 / 2), MaxN);\n        k = rnd.next((long long)(1e14 / 2), MaxK);\n    } else if (type == \"no_solution\") {\n        // Known case where there is no solution\n        n = 100LL;\n        k = 1LL;\n    } else if (type == \"edge_case_n_1\") {\n        // Edge case where n is 1\n        n = 1LL;\n        k = rnd.next(1LL, MaxK);\n    } else if (type == \"edge_case_k_1\") {\n        // Edge case where k is 1\n        n = rnd.next(1LL, MaxN);\n        k = 1LL;\n    } else if (type == \"n_equals_k\") {\n        // Case where n equals k\n        n = rnd.next(1LL, MaxN);\n        k = n;\n    } else if (type == \"random\") {\n        // Completely random valid values for n and k\n        n = rnd.next(1LL, MaxN);\n        k = rnd.next(1LL, MaxK);\n    } else {\n        // Default to random values if type is unrecognized\n        n = rnd.next(1LL, MaxN);\n        k = rnd.next(1LL, MaxK);\n    }\n\n    // Ensure n and k are within the specified bounds\n    n = max(1LL, min(n, (long long)1e14));\n    k = max(1LL, min(k, (long long)1e14));\n    \n    printf(\"%lld %lld\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Maximum values for n and k, default to 1e14 if not provided\n    long long MaxN = opt<long long>(\"MaxN\", (long long)1e14);\n    long long MaxK = opt<long long>(\"MaxK\", (long long)1e14);\n    \n    // Type of test case to generate\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n, k;\n\n    if (type == \"max_n_k\") {\n        // Both n and k at their maximum values\n        n = MaxN;\n        k = MaxK;\n    } else if (type == \"small_values\") {\n        // Small random values for n and k\n        n = rnd.next(1LL, 100LL);\n        k = rnd.next(1LL, 100LL);\n    } else if (type == \"random_large\") {\n        // Random large values for n and k\n        n = rnd.next((long long)(1e14 / 2), MaxN);\n        k = rnd.next((long long)(1e14 / 2), MaxK);\n    } else if (type == \"no_solution\") {\n        // Known case where there is no solution\n        n = 100LL;\n        k = 1LL;\n    } else if (type == \"edge_case_n_1\") {\n        // Edge case where n is 1\n        n = 1LL;\n        k = rnd.next(1LL, MaxK);\n    } else if (type == \"edge_case_k_1\") {\n        // Edge case where k is 1\n        n = rnd.next(1LL, MaxN);\n        k = 1LL;\n    } else if (type == \"n_equals_k\") {\n        // Case where n equals k\n        n = rnd.next(1LL, MaxN);\n        k = n;\n    } else if (type == \"random\") {\n        // Completely random valid values for n and k\n        n = rnd.next(1LL, MaxN);\n        k = rnd.next(1LL, MaxK);\n    } else {\n        // Default to random values if type is unrecognized\n        n = rnd.next(1LL, MaxN);\n        k = rnd.next(1LL, MaxK);\n    }\n\n    // Ensure n and k are within the specified bounds\n    n = max(1LL, min(n, (long long)1e14));\n    k = max(1LL, min(k, (long long)1e14));\n    \n    printf(\"%lld %lld\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small values test cases\n./gen -type small_values\n./gen -type small_values\n./gen -type small_values\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Random large values test cases\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n# Maximum n and k\n./gen -type max_n_k\n\n# No solution test cases\n./gen -type no_solution\n./gen -type no_solution\n\n# Edge case where n equals 1\n./gen -type edge_case_n_1\n./gen -type edge_case_n_1\n\n# Edge case where k equals 1\n./gen -type edge_case_k_1\n./gen -type edge_case_k_1\n\n# Test cases where n equals k\n./gen -type n_equals_k\n./gen -type n_equals_k\n\n# Random test cases with custom MaxN and MaxK\n./gen -type random -MaxN 1\n./gen -type random -MaxK 1\n./gen -type random -MaxN 100 -MaxK 100000000000000\n./gen -type random -MaxN 100000000000000 -MaxK 100\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge case with maximum k\n./gen -type edge_case_n_1 -MaxK 100000000000000\n./gen -type edge_case_k_1 -MaxN 100000000000000\n\n# Small values test cases again\n./gen -type small_values\n./gen -type small_values\n./gen -type small_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:52.297693",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "479/A",
      "title": "A. Expression",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains three integers a, b and c, each on a single line (1 ≤ a, b, c ≤ 10).",
      "output_spec": "OutputPrint the maximum value of the expression that you can obtain.",
      "sample_tests": "ExamplesInputCopy123OutputCopy9InputCopy2103OutputCopy60",
      "description": "A. Expression\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains three integers a, b and c, each on a single line (1 ≤ a, b, c ≤ 10).\n\nOutputPrint the maximum value of the expression that you can obtain.\n\nInputCopy123OutputCopy9InputCopy2103OutputCopy60\n\nInputCopy123\n\nOutputCopy9\n\nInputCopy2103\n\nOutputCopy60",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Greetings to the Codeforces community!Yet another Div1+Div2 round will take place this Sunday, 19th of October at 13:00 MSK.The round is based on the problems of the regional stage of All-Russia team school competition, which will take place at the same time in Saratov. We are aware about the overlapping with Opencup, but we have no option to shift the round, because we are bounded to the local event.The problems were prepared by HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan and me.Scoring: 500-1000-1500-2000-2500 (both divisions).UPD: Editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 586
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces",
          "content": "I am happy to present you author's ideas of solutions. Editorial of the first five problem is authored by — HolkinPV and gridnevvvit, editorial for the last two problems is written by me.479A - ExpressionIn this task you have to consider several cases and choose the best one: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - TowersThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).479C - Exams, 480A - ExamsThe solution is again greedy. Sort the exams by increasing ai, breaking ties by increasing bi. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (b1). Move to the second exam. If we can take it on the day b2 (i.e. b1 ≤ b2), do it. Otherwise, take the second exam on the day a2. Continue the process, keeping the day of the latest exam. std::sort(a, a + n); // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Long Jumps, 480B - Long JumpsIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both x and y, output 0. Then try to measure both x and y by adding one more mark. If it was not successful, print two marks: one at x, other at y.So, how to check if the answer is 1? Consider all existing marks. Let some mark be at r. Try to add the new mark in each of the following positions: r - x, r + x, r - y, r + y. If it become possible to measure both x and y, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at r + x, we just check if there is a mark at r + x + y or r + x - y (by a binary search, since the marks are sorted). Make sure that the adde marks are in [0, L].479E - Riding in a Lift, 480C - Riding in a LiftThe task is solved by a dynamic programming. State is a pair (i, j), where i is the number of trips made, and j is the current floor. Initial state is (0, a), final states are (k, v), where v is any floor (except b).It is easy to see the transitions: to calculate dp(i, j), let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position j, because we can’t visit the same floor twice in a row). So, dp(i, j) is almost equal to the sum of values dp(i - 1, t), where t belongs to some segment [l, r] (the values of l and r can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute dp(i, j) in O(1), so overall complexity is O(NK).Jury solution: 8322623480D - ParcelsLet’s make two observations.First, consider the parcels as time segments [ini, outi]. It is true that if at some moment of time both parcel i and parcel j are on the platform, and i is higher than j, then .Second, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.These observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number i, and the residual strength is rs. Make this pair (i, rs) the state of DP, because it is exactly the original problem, where the platform strength is rs and there are only parcels j with . In d(i, rs) we will store the answer to this instance of the original problem.Which transitions are there? We can choose a set of parcels i(1), i(2), ... i(k) such that outi(j) ≤ ini(j + 1), i.e. segments do not intersect (but can touch) and are sorted; the weight of each of these parcels does not exceed rs. This choice corresponds to the following sequence of actions: first put parcel i(1) on the top of i. This gets us to the state i(1), min(rs - wi(1), si(1)), so we add up the answer for this state and the cost of i(1). Then we take away all parcels, including i(1), and put the parcel i(2) on top of i, and so on.As the number of states in DP is O(NS), all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in O(N2S). Note that for simplicity the platform can be considered as a parcel too.480E - Parking LotLet’s denote the car arrivals as events.Consider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number x, and the size of the square is k. Now we can update the answers for all events with numbers less than x with a value of k.The model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.Let’s assume that c2 - c1 ≤ r2 - r1 (the opposite case is symmetric). Take the middle row r = (r1 + r2) / 2. Virtually split all the squares inside the sub-table into those which lie above r, those which lie below r, and those which intersect r. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row r.Using initial table, for each cell (r, c) we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): up(r, c), down(r, c), left(r, c) и right(r, c). Using this values, build two histograms for the row r: the first is an array of values up(r, c), where c1 ≤ c ≤ c2; the second is an array of values down(r, c), where c1 ≤ c ≤ c2. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row r upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event x the maximum empty square found in the histograms has size k, and the next event has number y, we can update answers for all events with numbers x, x + 1, ..., y - 1 with the value of k. It remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length k if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 >= k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.Let’s try to estimate the running time. Each call of the routine (omitting inner calls) costs O(len·q), where len is the shortest side of the sub-table, and q is the number of events in it. If we draw a recursion tree, we will see that each second call len decreases twice. The total cost of all operations in a single level of a recursion tree is O(NK), where K is the total number of events. As long as we have O(logN), overall complexity is O(NKlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 479\\s*A"
          },
          "content_length": 8178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 10, \"a\");\n    inf.readEoln();\n    int b = inf.readInt(1, 10, \"b\");\n    inf.readEoln();\n    int c = inf.readInt(1, 10, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 10, \"a\");\n    inf.readEoln();\n    int b = inf.readInt(1, 10, \"b\");\n    inf.readEoln();\n    int c = inf.readInt(1, 10, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 10, \"a\");\n    inf.readEoln();\n    int b = inf.readInt(1, 10, \"b\");\n    inf.readEoln();\n    int c = inf.readInt(1, 10, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    int a, b, c;\n    if (type == \"random\") {\n        a = rnd.next(1,10);\n        b = rnd.next(1,10);\n        c = rnd.next(1,10);\n    } else if (type == \"min\") {\n        a = b = c = 1;\n    } else if (type == \"max\") {\n        a = b = c = 10;\n    } else if (type == \"custom\") {\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n        c = opt<int>(\"c\");\n    } else if (type == \"boundary\") {\n        int idx = opt<int>(\"case\", 0);\n        vector<tuple<int,int,int>> cases = {\n            {1,1,1},\n            {1,1,10},\n            {1,10,1},\n            {10,1,1},\n            {1,10,10},\n            {10,1,10},\n            {10,10,1},\n            {10,10,10}\n        };\n        idx %= cases.size();\n        a = get<0>(cases[idx]);\n        b = get<1>(cases[idx]);\n        c = get<2>(cases[idx]);\n    } else if (type == \"edge\") {\n        int idx = opt<int>(\"case\", 0);\n        vector<tuple<int,int,int>> cases = {\n            {1,2,1},\n            {1,1,2},\n            {2,1,1},\n            {2,2,1},\n            {2,1,2},\n            {1,2,2},\n            {9,1,1},\n            {1,9,1},\n            {1,1,9}\n        };\n        idx %= cases.size();\n        a = get<0>(cases[idx]);\n        b = get<1>(cases[idx]);\n        c = get<2>(cases[idx]);\n    } else {\n        cerr << \"Unknown type\\n\";\n        return 1;\n    }\n    printf(\"%d\\n%d\\n%d\\n\", a, b, c);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    int a, b, c;\n    if (type == \"random\") {\n        a = rnd.next(1,10);\n        b = rnd.next(1,10);\n        c = rnd.next(1,10);\n    } else if (type == \"min\") {\n        a = b = c = 1;\n    } else if (type == \"max\") {\n        a = b = c = 10;\n    } else if (type == \"custom\") {\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n        c = opt<int>(\"c\");\n    } else if (type == \"boundary\") {\n        int idx = opt<int>(\"case\", 0);\n        vector<tuple<int,int,int>> cases = {\n            {1,1,1},\n            {1,1,10},\n            {1,10,1},\n            {10,1,1},\n            {1,10,10},\n            {10,1,10},\n            {10,10,1},\n            {10,10,10}\n        };\n        idx %= cases.size();\n        a = get<0>(cases[idx]);\n        b = get<1>(cases[idx]);\n        c = get<2>(cases[idx]);\n    } else if (type == \"edge\") {\n        int idx = opt<int>(\"case\", 0);\n        vector<tuple<int,int,int>> cases = {\n            {1,2,1},\n            {1,1,2},\n            {2,1,1},\n            {2,2,1},\n            {2,1,2},\n            {1,2,2},\n            {9,1,1},\n            {1,9,1},\n            {1,1,9}\n        };\n        idx %= cases.size();\n        a = get<0>(cases[idx]);\n        b = get<1>(cases[idx]);\n        c = get<2>(cases[idx]);\n    } else {\n        cerr << \"Unknown type\\n\";\n        return 1;\n    }\n    printf(\"%d\\n%d\\n%d\\n\", a, b, c);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type min\n./gen -type max\n\n./gen -type boundary -case 0\n./gen -type boundary -case 1\n./gen -type boundary -case 2\n./gen -type boundary -case 3\n./gen -type boundary -case 4\n./gen -type boundary -case 5\n./gen -type boundary -case 6\n./gen -type boundary -case 7\n\n./gen -type edge -case 0\n./gen -type edge -case 1\n./gen -type edge -case 2\n./gen -type edge -case 3\n./gen -type edge -case 4\n./gen -type edge -case 5\n./gen -type edge -case 6\n./gen -type edge -case 7\n./gen -type edge -case 8\n\n./gen -type custom -a 1 -b 2 -c 10\n./gen -type custom -a 2 -b 10 -c 1\n./gen -type custom -a 1 -b 10 -c 2\n./gen -type custom -a 10 -b 2 -c 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:54.495013",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "479/B",
      "title": "B. Towers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated positive integers n and k (1 ≤ n ≤ 100, 1 ≤ k ≤ 1000) — the number of towers in the given set and the maximum number of operations Petya can perform. The second line contains n space-separated positive integers ai (1 ≤ ai ≤ 104) — the towers' initial heights.",
      "output_spec": "OutputIn the first line print two space-separated non-negative integers s and m (m ≤ k). The first number is the value of the minimum possible instability that can be obtained after performing at most k operations, the second number is the number of operations needed for that.In the next m lines print the description of each operation as two positive integers i and j, each of them lies within limits from 1 to n. They represent that Petya took the top cube from the i-th tower and put in on the j-th one (i ≠ j). Note that in the process of performing operations the heights of some towers can become equal to zero.If there are multiple correct sequences at which the minimum possible instability is achieved, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy3 25 8 5OutputCopy0 22 12 3InputCopy3 42 2 4OutputCopy1 13 2InputCopy5 38 3 2 6 3OutputCopy3 31 31 21 3",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated positive integers n and k (1 ≤ n ≤ 100, 1 ≤ k ≤ 1000) — the number of towers in the given set and the maximum number of operations Petya can perform. The second line contains n space-separated positive integers ai (1 ≤ ai ≤ 104) — the towers' initial heights.\n\nOutputIn the first line print two space-separated non-negative integers s and m (m ≤ k). The first number is the value of the minimum possible instability that can be obtained after performing at most k operations, the second number is the number of operations needed for that.In the next m lines print the description of each operation as two positive integers i and j, each of them lies within limits from 1 to n. They represent that Petya took the top cube from the i-th tower and put in on the j-th one (i ≠ j). Note that in the process of performing operations the heights of some towers can become equal to zero.If there are multiple correct sequences at which the minimum possible instability is achieved, you are allowed to print any of them.\n\nInputCopy3 25 8 5OutputCopy0 22 12 3InputCopy3 42 2 4OutputCopy1 13 2InputCopy5 38 3 2 6 3OutputCopy3 31 31 21 3\n\nInputCopy3 25 8 5\n\nOutputCopy0 22 12 3\n\nInputCopy3 42 2 4\n\nOutputCopy1 13 2\n\nInputCopy5 38 3 2 6 3\n\nOutputCopy3 31 31 21 3\n\nNoteIn the first sample you need to move the cubes two times, from the second tower to the third one and from the second one to the first one. Then the heights of the towers are all the same and equal to 6.",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Greetings to the Codeforces community!Yet another Div1+Div2 round will take place this Sunday, 19th of October at 13:00 MSK.The round is based on the problems of the regional stage of All-Russia team school competition, which will take place at the same time in Saratov. We are aware about the overlapping with Opencup, but we have no option to shift the round, because we are bounded to the local event.The problems were prepared by HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan and me.Scoring: 500-1000-1500-2000-2500 (both divisions).UPD: Editorial is published.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 586
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces",
          "content": "I am happy to present you author's ideas of solutions. Editorial of the first five problem is authored by — HolkinPV and gridnevvvit, editorial for the last two problems is written by me.479A - ExpressionIn this task you have to consider several cases and choose the best one: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - TowersThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).479C - Exams, 480A - ExamsThe solution is again greedy. Sort the exams by increasing ai, breaking ties by increasing bi. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (b1). Move to the second exam. If we can take it on the day b2 (i.e. b1 ≤ b2), do it. Otherwise, take the second exam on the day a2. Continue the process, keeping the day of the latest exam. std::sort(a, a + n); // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Long Jumps, 480B - Long JumpsIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both x and y, output 0. Then try to measure both x and y by adding one more mark. If it was not successful, print two marks: one at x, other at y.So, how to check if the answer is 1? Consider all existing marks. Let some mark be at r. Try to add the new mark in each of the following positions: r - x, r + x, r - y, r + y. If it become possible to measure both x and y, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at r + x, we just check if there is a mark at r + x + y or r + x - y (by a binary search, since the marks are sorted). Make sure that the adde marks are in [0, L].479E - Riding in a Lift, 480C - Riding in a LiftThe task is solved by a dynamic programming. State is a pair (i, j), where i is the number of trips made, and j is the current floor. Initial state is (0, a), final states are (k, v), where v is any floor (except b).It is easy to see the transitions: to calculate dp(i, j), let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position j, because we can’t visit the same floor twice in a row). So, dp(i, j) is almost equal to the sum of values dp(i - 1, t), where t belongs to some segment [l, r] (the values of l and r can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute dp(i, j) in O(1), so overall complexity is O(NK).Jury solution: 8322623480D - ParcelsLet’s make two observations.First, consider the parcels as time segments [ini, outi]. It is true that if at some moment of time both parcel i and parcel j are on the platform, and i is higher than j, then .Second, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.These observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number i, and the residual strength is rs. Make this pair (i, rs) the state of DP, because it is exactly the original problem, where the platform strength is rs and there are only parcels j with . In d(i, rs) we will store the answer to this instance of the original problem.Which transitions are there? We can choose a set of parcels i(1), i(2), ... i(k) such that outi(j) ≤ ini(j + 1), i.e. segments do not intersect (but can touch) and are sorted; the weight of each of these parcels does not exceed rs. This choice corresponds to the following sequence of actions: first put parcel i(1) on the top of i. This gets us to the state i(1), min(rs - wi(1), si(1)), so we add up the answer for this state and the cost of i(1). Then we take away all parcels, including i(1), and put the parcel i(2) on top of i, and so on.As the number of states in DP is O(NS), all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in O(N2S). Note that for simplicity the platform can be considered as a parcel too.480E - Parking LotLet’s denote the car arrivals as events.Consider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number x, and the size of the square is k. Now we can update the answers for all events with numbers less than x with a value of k.The model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.Let’s assume that c2 - c1 ≤ r2 - r1 (the opposite case is symmetric). Take the middle row r = (r1 + r2) / 2. Virtually split all the squares inside the sub-table into those which lie above r, those which lie below r, and those which intersect r. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row r.Using initial table, for each cell (r, c) we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): up(r, c), down(r, c), left(r, c) и right(r, c). Using this values, build two histograms for the row r: the first is an array of values up(r, c), where c1 ≤ c ≤ c2; the second is an array of values down(r, c), where c1 ≤ c ≤ c2. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row r upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event x the maximum empty square found in the histograms has size k, and the next event has number y, we can update answers for all events with numbers x, x + 1, ..., y - 1 with the value of k. It remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length k if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 >= k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.Let’s try to estimate the running time. Each call of the routine (omitting inner calls) costs O(len·q), where len is the shortest side of the sub-table, and q is the number of events in it. If we draw a recursion tree, we will see that each second call len decreases twice. The total cost of all operations in a single level of a recursion tree is O(NK), where K is the total number of events. As long as we have O(logN), overall complexity is O(NKlogN).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 479\\s*B"
          },
          "content_length": 8178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 10000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 10000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 10000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read input\n    int n = inf.readInt(1, 100, \"n\");\n    int k = inf.readInt(1, 1000, \"k\");\n    vector<int> initial_towers(n);\n    for (int i = 0; i < n; ++i) {\n        initial_towers[i] = inf.readInt(1, 10000, format(\"a[%d]\", i + 1).c_str());\n    }\n\n    // Read s_jury from ans\n    int s_jury = ans.readInt(0, 1000000, \"s_jury\");\n\n    // Read participant's output\n    int s_participant = ouf.readInt(0, 1000000, \"s_participant\");\n    int m_participant = ouf.readInt(0, k, \"m_participant\");\n\n    if (m_participant > k)\n        quitf(_wa, \"Number of operations (%d) exceeds limit k (%d)\", m_participant, k);\n\n    if (s_participant > s_jury)\n        quitf(_wa, \"Your instability (%d) is worse than minimal possible instability (%d)\", s_participant, s_jury);\n    else if (s_participant < s_jury)\n        quitf(_fail, \"Participant's instability (%d) is less than jury's (%d)\", s_participant, s_jury);\n    // s_participant == s_jury\n\n    // Now apply participant's operations\n    vector<int> towers = initial_towers; // copy of initial heights\n    for (int i = 0; i < m_participant; ++i) {\n        int from = ouf.readInt(1, n, format(\"from[%d]\", i + 1).c_str());\n        int to = ouf.readInt(1, n, format(\"to[%d]\", i + 1).c_str());\n        if (from == to)\n            quitf(_wa, \"Operation %d: source and destination towers are the same (%d)\", i + 1, from);\n        if (towers[from - 1] == 0)\n            quitf(_wa, \"Operation %d: tower %d has no cubes to move\", i + 1, from);\n        towers[from - 1]--;\n        towers[to - 1]++;\n    }\n\n    // Compute instability\n    int max_height = *max_element(towers.begin(), towers.end());\n    int min_height = *min_element(towers.begin(), towers.end());\n    int final_instability = max_height - min_height;\n\n    if (final_instability != s_participant)\n        quitf(_wa, \"Computed instability (%d) does not match reported instability (%d)\", final_instability, s_participant);\n\n    quitf(_ok, \"Answer is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_in = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int n = n_in;\n\n    if (type == \"n1\") {\n        // Set n to 1\n        n = 1;\n    }\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10000;\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"same_height\") {\n        int height = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = height;\n        }\n    } else if (type == \"max_instability\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 1;\n            else\n                a[i] = 10000;\n        }\n    } else if (type == \"almost_balanced\") {\n        int base = rnd.next(5000, 5005);\n        for (int i = 0; i < n; ++i) {\n            a[i] = base + rnd.next(-2, 2);\n            if (a[i] < 1) a[i] = 1;\n            if (a[i] > 10000) a[i] = 10000;\n        }\n    } else if (type == \"max_k_not_enough\") {\n        // Prepare a case where k is not enough to completely balance the towers\n        for (int i = 0; i < n; ++i) {\n            if (i == 0)\n                a[i] = 10000;\n            else\n                a[i] = 1;\n        }\n        // Optionally adjust k here if necessary\n    } else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 == n)\n            printf(\"\\n\");\n        else\n            printf(\" \");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_in = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int n = n_in;\n\n    if (type == \"n1\") {\n        // Set n to 1\n        n = 1;\n    }\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10000;\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"same_height\") {\n        int height = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = height;\n        }\n    } else if (type == \"max_instability\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 1;\n            else\n                a[i] = 10000;\n        }\n    } else if (type == \"almost_balanced\") {\n        int base = rnd.next(5000, 5005);\n        for (int i = 0; i < n; ++i) {\n            a[i] = base + rnd.next(-2, 2);\n            if (a[i] < 1) a[i] = 1;\n            if (a[i] > 10000) a[i] = 10000;\n        }\n    } else if (type == \"max_k_not_enough\") {\n        // Prepare a case where k is not enough to completely balance the towers\n        for (int i = 0; i < n; ++i) {\n            if (i == 0)\n                a[i] = 10000;\n            else\n                a[i] = 1;\n        }\n        // Optionally adjust k here if necessary\n    } else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 == n)\n            printf(\"\\n\");\n        else\n            printf(\" \");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with various n and k\n./gen -n 10 -k 10 -type random\n./gen -n 50 -k 100 -type random\n./gen -n 100 -k 500 -type random\n./gen -n 100 -k 1000 -type random\n\n# Test cases with maximum ai\n./gen -n 10 -k 10 -type max_ai\n./gen -n 50 -k 100 -type max_ai\n./gen -n 100 -k 1000 -type max_ai\n\n# Test cases with minimum ai\n./gen -n 10 -k 10 -type min_ai\n./gen -n 50 -k 100 -type min_ai\n./gen -n 100 -k 1000 -type min_ai\n\n# Test cases with same height\n./gen -n 10 -k 10 -type same_height\n./gen -n 50 -k 100 -type same_height\n./gen -n 100 -k 1000 -type same_height\n\n# Test cases with maximum instability\n./gen -n 10 -k 5 -type max_instability\n./gen -n 50 -k 25 -type max_instability\n./gen -n 100 -k 50 -type max_instability\n\n# Test cases with almost balanced heights\n./gen -n 10 -k 10 -type almost_balanced\n./gen -n 50 -k 50 -type almost_balanced\n./gen -n 100 -k 100 -type almost_balanced\n\n# Test cases where k is not enough to fully balance\n./gen -n 10 -k 1 -type max_k_not_enough\n./gen -n 50 -k 10 -type max_k_not_enough\n./gen -n 100 -k 20 -type max_k_not_enough\n\n# Test cases with n = 1\n./gen -n 1 -k 1 -type n1\n\n# Test case with minimal k\n./gen -n 100 -k 1 -type random\n\n# Test case with maximum k\n./gen -n 100 -k 1000 -type random\n\n# Additional special cases\n./gen -n 2 -k 1 -type max_instability\n./gen -n 3 -k 1000 -type random\n./gen -n 5 -k 0 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:56.563696",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "479/C",
      "title": "C. Экзамены",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое положительное число n (1 ≤ n ≤ 5000) — количество экзаменов, которые будет сдавать Валера.В каждой из следующих n строк записано по два целых положительных числа через пробел ai и bi (1 ≤ bi < ai ≤ 109) — дата сдачи по расписанию и досрочная дата сдачи i-го экзамена соответственно.",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимально возможный номер дня, когда Валера сможет сдать последний экзамен, если он будет сдавать экзамены так, чтобы все записи в его зачетной книжке шли в порядке неубывания даты.",
      "sample_tests": "ПримерыВходные данныеСкопировать35 23 14 2Выходные данныеСкопировать2Входные данныеСкопировать36 15 24 3Выходные данныеСкопировать6",
      "description": "C. Экзамены\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое положительное число n (1 ≤ n ≤ 5000) — количество экзаменов, которые будет сдавать Валера.В каждой из следующих n строк записано по два целых положительных числа через пробел ai и bi (1 ≤ bi < ai ≤ 109) — дата сдачи по расписанию и досрочная дата сдачи i-го экзамена соответственно.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимально возможный номер дня, когда Валера сможет сдать последний экзамен, если он будет сдавать экзамены так, чтобы все записи в его зачетной книжке шли в порядке неубывания даты.\n\nВыходные данные\n\nВходные данныеСкопировать35 23 14 2Выходные данныеСкопировать2Входные данныеСкопировать36 15 24 3Выходные данныеСкопировать6\n\nВходные данныеСкопировать35 23 14 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать36 15 24 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Валера сначала сдаст экзамен по второму предмету в первый день (в зачетную книжку заносится дата сдачи по расписанию, то есть 3). На следующий день сначала он сдаст экзамен по третьему предмету (будет добавлена запись, датированная днем 4), а после него в тот же день сдаст экзамен по первому предмету (в зачетную книжку отметка будет проставлена с днем 5). Таким образом, последний экзамен Валера сдаст во второй день, и даты в зачетной книжке будут идти в порядке неубывания: 3, 4, 5.Во втором примере Валера сначала сдаст экзамен по третьему предмету в четвертый день, после него экзамен по второму предмету в пятый день. После этого в шестой день Валера сдаст экзамен по первому предмету.",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Приветствую сообщество Codeforces!В воскресенье, 19 октября, в 13:00 MSK состоится очередной раунд для участников обоих дивизионов.Раунд будет основан на задачах регионального этапа Всероссийской командной олимпиады школьников, который в то же самое время будет проходить в Саратове. Мы знаем о пересечении раунда с этапом открытого кубка, но не можем перенести раунд, так как мы привязаны к олимпиаде.В подготовке задач принимали участие HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan и я.Разбалловка стандартная: 500-1000-1500-2000-2500 (в обоих дивизионах).UPD: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 610
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces",
          "content": "Спешу познакомить вас с авторскими идеями решений задач сегодняшнего раунда. Авторы разбора первых пяти задач — HolkinPV и gridnevvvit, разбор последних двух задач написан мной.479A - ВыражениеВ этой задаче нужно было рассмотреть несколько случаев и выбрать лучших ответ. Это можно было сделать так: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - БашниЭта задача решается жадным образом. На каждой итерации нашего алгоритма будем перекладывать кубик с башни с максимальной высотой на башню с минимальной высотой. Для этого можно каждый раз за время O(N) заново находить позиции минимума и максимума в массиве. Итоговое решение тогда будет иметь асимптотику O(KN).479C - Экзамены, 480A - ЭкзаменыЭта задача решается жадным образом. Отсортируем все экзамены по неубыванию даты фактической сдачи (то есть по ai), при равенстве по неубыванию даты досрочной сдачи (то есть bi). Рассмотрим экзамены в получившемся порядке и будем поддерживать текущий ответ. В первую очередь будем стараться сдать очередной экзамен досрочно (если это не нарушит условие задачи, то есть если никакой предыщий экзамен мы не сдавали позже досрочной даты этого экзамена). В противном случае сдадим этот экзамен в дату его фактической сдачи. Обновим текущим ответ выбранной датой сдачи этого экзамена. std::sort(a, a + n); // а - массив пар, где первый элемент фактическая сдача экзамена, а второй элемент - досрочная\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Прыжки в длину, 480B - Прыжки в длинуНетрудно догадаться, что ответом на эту задачу может быть 0, 1 или 2. Если изначально мы можем отмерить расстояния x и y, то сразу выведем 0. Иначе попробуем получить ответ нанесением одной метки. Если это не удастся, в качестве ответа всегда можно вывести две метки, равные x и y соответственно. Чтобы проверить, можно ли получить ответ 1, переберем каждую из имеющихся отметок, пусть она находится на расстоянии r. Тогда попробуем добавить отметку на одной из позиций: r - x, r + x, r - y, r + y. Если хотя бы в одном из случаев станет возможным отмерить x и y, то можно сразу выводить полученный ответ. Проверить, что можем отмерить x и y, просто. К примеру, пусть мы сделали отметку в r + x (т.е. x мы уже научились отмерять). Тогда надо лишь проверить, что есть отметка в r + x + y или r + x - y, например, бинарным поиском (т.е. отметки отсортированы). Надо также не забыть проверить, что отметки попадают в [0, L].479E - Катаемся на лифте, 480C - Катаемся на лифтеЭта задача решается при помощи динамического программирования. Состоянием динамики будет пара (i, j), где i — количество посещенных этажей, j — номер этажа, на котором мы сейчас находимся. Начальным состоянием является пара (0, a), конечными состояниями являются пары (k, v), где v — любой этаж от 1 до n.Чтобы осуществить переход, нужно перебрать следующий посещаемый этаж и пересчитать ответ. Однако нельзя выполнять такой переход в явном виде, поскольку решение будет иметь асимптотику O(N3). Чтобы решение уложилось в требуемый лимит по времени, нужно воспользоваться частичными суммами. При переходе от i к i + 1 предпосчитаем в дополнительном массиве частичные суммы посчитанных ранее динамик (с предыдущей итерации). После этого воспользуемся динамическим программированием “назад” и при подсчете очередного значения будем делать запрос суммы на отрезке в посчитанном массиве частичных сумм. Таким образом, решение будет иметь асимптотику O(N2).Авторское решение: 8322623480D - ПосылкиСделаем два наблюдения.Во-первых, посмотрим на посылки как на отрезки [$in_i, out_i$]. Верно следующее утверждение: если коробка i оказалась в какой-то момент времени сверху коробки j (не обязательно непосредственно сверху), то .Во-вторых, представим, что на платформе находятся какие-то посылки. Оказывается, что все, что нам нужно знать про этот набор посылок, чтобы понимать, можем ли мы положить что-то сверху, это “остаточная прочность” всех этих посылок. Остаточная прочность определяется так: для каждой посылки из набора остаточная прочность равна прочности этой посылки за вычетом суммарного веса всех стоящих на ней. Для набора посылок остаточная прочность считается как минимум из остаточных прочностей посылок в наборе. Таким образом, новую посылку можно положить, если ее вес не превосходит остаточной прочности уже имеющихся коробок.Это приводит нас к идее решения задачи динамическим программированием. Пусть в данный момент времени верхняя посылка на платформе имеет номер i, а остаточная прочность имеющихся на платформе коробок равна rs. Сделаем эту пару (i, rs) состоянием динамики: представим, что у нас есть исходная задача, в которой есть только те посылки, которые вкладываются в [ini, outi], а платформа имеет прочность rs. В значении динамики d(i, rs) будем хранить ответ для этой новой задачи. Какие существуют переходы? Мы должны выбрать набор посылок i(1), i(2), ... i(k) таких, что outi(j) ≤ ini(j + 1), т.е. отрезки не пересекаются (кроме концов) и отсортированы по времени; вес любой из выбранных посылок не превосходит rs. Этот выбор соответствует следующей последовательности операций: сначала поставить сверху посылки i посылку i(1). Мы перейдем в состояние i(1), min(rs - wi(1), si(1)), прибавив к сумме стоимость коробки i(1) и ответ для нового состояния. Затем мы снимем все коробки, включая i(1), и поставим i(2), сделаем переход, затем снимем все вплоть до i(2), поставим i(3), и т.д.Поскольку количество состояний в динамике у нас получилось O(NS), то переходы должны суммарно выполняться за O(N). Этого можно добиться, реализовав внутри несложную вспомогательную динамику. Должно получиться решение со сложностью O(N2S). Отметим, что для единообразия можно считать платформу коробкой номер 0, которая приходит раньше всех, и выходит позже всех. Тогда ответ на задачу — просто значение d(0, S).480E - ПарковкаБудем называть приезды машин на парковку событиями.Рассмотрим следующее решение (оно поможет нам прийти к авторскому): давайте рассмотрим все возможные пустые квадраты в таблице. Их, конечно, много, но допустим, что мы все же можем их перебрать. Если мы зафиксировали квадрат, то давайте поймем, когда он перестанет быть пустым (найдем первое событие парковки машины в этом квадрате). Пусть номер этого события x, а размер квадрата k. Тогда для всех событий с номерами меньшими, чем x, попробуем обновить ответ значением k.Авторское решение использует принцип разделяй и властвуй. Давайте напишем рекурсивную функцию, которая принимает подтаблицу, границами которой являются r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), а также список всех событий парковки, которые происходят в этой подтаблице. Задача функции — рассмотреть то, как меняются максимальные пустые квадраты в этой таблице по прошествии этих событий, и попытаться обновить ответы для некоторых событий.Предположим, что c2 - c1 ≤ r2 - r1 (второй случай будет симметричным). Давайте возьмем среднюю строку подтаблицы: r = (r1 + r2) / 2. Разделим все квадраты в подтаблице на три части: те, что строго выше r, те, что строго ниже r, и те, что пересекают r. Для первых двух частей вызовемся рекурсивно (естественно, списки событий при этих вызовах будут свои). Теперь осталось только рассмотреть квадраты, пересекающие (имеющие общие клетки) со строкой r.По исходной таблице для каждой клетки (r, c) мы можем посчитать расстояние до ближайшей занятой клетки в каждом из четырех направлений (или до края, если такой нет): up(r, c), down(r, c), left(r, c) и right(r, c). Используя эту информацию, мы сейчас построим для строки r две гистограммы: первая представляет из себя массив значений up(r, c) при c1 ≤ c ≤ c2, вторая — массив значений down(r, c) при c1 ≤ c ≤ c2. Здесь я называю массивы гистограммами, потому что они фактически означают высоты столбиков из пустых клеток, начинающихся в строке r. Назовем первую гистограмуу верхней, а вторую — нижней. Рассмотрим все события, происходящие в подтаблице, в порядке их появления. Каждое событие меняет лишь одно значение в гистограмме. Пусть после мы имеем гистограммы после события с номером x, а следующие событие имеет номер y. Тогда, если мы найдем максимальный пустой квадрат в этих гистограммах (пусть его размер k), то мы сможем обновить ответы для всех событий от x до y - 1 значением k.Осталось только научиться искать максимальный квадрат в двух гистограммах. Это можно сделать с помощью метода двух указателей. Поставим первый указатель в начало. Будем двигать второй указатель до тех пор, пока в гистограммах есть такой квадрат: квадрат со стороной k имеется, если (минимум на отрезке в первой гистограмме) + (минимум на отрезке во второй гистограмме) — 1 >= k. После того, как это свойство нарушилось, двигаем первый указатель. Для того, чтобы находить минимум за O(1), авторское решение для каждой гистограммы заводит очередь с поддержкой минимума за O(1). Таким образом, поиск максимального квадрата осуществляется за линейное время.Давайте попробуем оценить время работы. Количество действий внутри одного вызова (без учета рекурсивных вызовов в половинах) равно len·q, где len — длина наименьшей из сторон подтаблицы, а q — количество событий в ней. Если мы представим себе дерево рекурсии, то увидим, что через вызов (т.е. каждый второй вызов) величина len уменьшается в два раза. Суммарное количество действий на одном уровне дерева рекурсии равно O(NK), где k — общее количество событий. Поскольку уровней в дереве O(logN), то общая асимптотика O(NKlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 479\\s*C"
          },
          "content_length": 9541
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а - массив пар, где первый элемент фактическая сдача экзамена, а                        второй элемент - досрочная\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а - массив пар, где первый элемент фактическая сдача экзамена, а                        второй элемент - досрочная\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; i++){\n        int ai = inf.readInt(2, 1000000000, \"ai\"); // ai ∈ [2, 1e9]\n        inf.readSpace();\n        int bi = inf.readInt(1, ai - 1, \"bi\"); // bi ∈ [1, ai -1]\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; i++){\n        int ai = inf.readInt(2, 1000000000, \"ai\"); // ai ∈ [2, 1e9]\n        inf.readSpace();\n        int bi = inf.readInt(1, ai - 1, \"bi\"); // bi ∈ [1, ai -1]\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; i++){\n        int ai = inf.readInt(2, 1000000000, \"ai\"); // ai ∈ [2, 1e9]\n        inf.readSpace();\n        int bi = inf.readInt(1, ai - 1, \"bi\"); // bi ∈ [1, ai -1]\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000); // Maximum value for ai\n    int k = opt<int>(\"k\", -1); // Used in ai_eq_bi_plus_k\n\n    vector<pair<int,int>> exams(n); // pair<ai, bi>\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, maxAi - 1);\n            int ai = rnd.next(bi + 1, maxAi);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"ai_eq_bi_plus_one\") {\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, maxAi - 1);\n            int ai = bi + 1;\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"ai_eq_bi_plus_k\") {\n        if (k == -1) k = 1;\n        for (int i = 0; i < n; ++i) {\n            int maxBi = maxAi - k;\n            if (maxBi < 1) maxBi = 1;\n            int bi = rnd.next(1, maxBi);\n            int ai = bi + k;\n            if (ai > maxAi) ai = maxAi;\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"ai_same\") {\n        int ai = rnd.next(2, maxAi);\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, ai - 1);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"bi_same\") {\n        int bi = rnd.next(1, maxAi - 1);\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(bi + 1, maxAi);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"increasing_ai\") {\n        int ai = rnd.next(2, maxAi - n);\n        for (int i = 0; i < n; ++i) {\n            ai++;\n            int bi = rnd.next(1, ai - 1);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"decreasing_ai\") {\n        int ai = maxAi;\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, ai - 1);\n            exams[i] = {ai, bi};\n            ai--;\n            if (ai <= 1) ai = maxAi;\n        }\n    } else if (type == \"maximal_ai\") {\n        int ai = maxAi;\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, ai - 1);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"minimal_n\") {\n        n = 1;\n        int ai = rnd.next(2, maxAi);\n        int bi = rnd.next(1, ai - 1);\n        exams[0] = {ai, bi};\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, maxAi - 1);\n            int ai = rnd.next(bi + 1, maxAi);\n            exams[i] = {ai, bi};\n        }\n    }\n\n    /* Output */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", exams[i].first, exams[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000); // Maximum value for ai\n    int k = opt<int>(\"k\", -1); // Used in ai_eq_bi_plus_k\n\n    vector<pair<int,int>> exams(n); // pair<ai, bi>\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, maxAi - 1);\n            int ai = rnd.next(bi + 1, maxAi);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"ai_eq_bi_plus_one\") {\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, maxAi - 1);\n            int ai = bi + 1;\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"ai_eq_bi_plus_k\") {\n        if (k == -1) k = 1;\n        for (int i = 0; i < n; ++i) {\n            int maxBi = maxAi - k;\n            if (maxBi < 1) maxBi = 1;\n            int bi = rnd.next(1, maxBi);\n            int ai = bi + k;\n            if (ai > maxAi) ai = maxAi;\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"ai_same\") {\n        int ai = rnd.next(2, maxAi);\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, ai - 1);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"bi_same\") {\n        int bi = rnd.next(1, maxAi - 1);\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(bi + 1, maxAi);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"increasing_ai\") {\n        int ai = rnd.next(2, maxAi - n);\n        for (int i = 0; i < n; ++i) {\n            ai++;\n            int bi = rnd.next(1, ai - 1);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"decreasing_ai\") {\n        int ai = maxAi;\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, ai - 1);\n            exams[i] = {ai, bi};\n            ai--;\n            if (ai <= 1) ai = maxAi;\n        }\n    } else if (type == \"maximal_ai\") {\n        int ai = maxAi;\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, ai - 1);\n            exams[i] = {ai, bi};\n        }\n    } else if (type == \"minimal_n\") {\n        n = 1;\n        int ai = rnd.next(2, maxAi);\n        int bi = rnd.next(1, ai - 1);\n        exams[0] = {ai, bi};\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            int bi = rnd.next(1, maxAi - 1);\n            int ai = rnd.next(bi + 1, maxAi);\n            exams[i] = {ai, bi};\n        }\n    }\n\n    /* Output */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", exams[i].first, exams[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5000 -type random\n./gen -n 5000 -type ai_eq_bi_plus_one\n./gen -n 5000 -type ai_eq_bi_plus_k -k 1\n./gen -n 5000 -type ai_eq_bi_plus_k -k 1000000\n./gen -n 5000 -type ai_same\n./gen -n 5000 -type bi_same\n./gen -n 5000 -type increasing_ai\n./gen -n 5000 -type decreasing_ai\n./gen -n 5000 -type maximal_ai\n./gen -n 1     -type minimal_n\n\n./gen -n 5000 -type ai_eq_bi_plus_k -k 0\n./gen -n 5000 -type ai_eq_bi_plus_k -k 999999999\n./gen -n 5000 -type random -maxAi 1000000000\n./gen -n 5000 -type random -maxAi 100\n./gen -n 5000 -type decreasing_ai -maxAi 1000000000\n./gen -n 5000 -type increasing_ai -maxAi 1000000000\n./gen -n 5000 -type ai_same -maxAi 1000000000\n./gen -n 5000 -type ai_eq_bi_plus_one -maxAi 1000000000\n./gen -n 5000 -type ai_eq_bi_plus_k -k 10 -maxAi 1000000000\n./gen -n 5000 -type random\n\n./gen -n 5000 -type random\n./gen -n 2500 -type random\n./gen -n 5000 -type random -maxAi 1000000000\n./gen -n 5000 -type random -maxAi 2\n./gen -n 5000 -type random -maxAi 5000\n./gen -n 5000 -type ai_eq_bi_plus_k -k 10000000\n./gen -n 5000 -type ai_eq_bi_plus_k -k 999999999\n./gen -n 5000 -type ai_eq_bi_plus_k -k 500000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:35:58.671681",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "479/D",
      "title": "D. Long Jumps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four positive space-separated integers n, l, x, y (2 ≤ n ≤ 105, 2 ≤ l ≤ 109, 1 ≤ x < y ≤ l) — the number of marks, the length of the ruler and the jump norms for girls and boys, correspondingly.The second line contains a sequence of n integers a1, a2, ..., an (0 = a1 < a2 < ... < an = l), where ai shows the distance from the i-th mark to the origin.",
      "output_spec": "OutputIn the first line print a single non-negative integer v — the minimum number of marks that you need to add on the ruler.In the second line print v space-separated integers p1, p2, ..., pv (0 ≤ pi ≤ l). Number pi means that the i-th mark should be at the distance of pi centimeters from the origin. Print the marks in any order. If there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy3 250 185 2300 185 250OutputCopy1230InputCopy4 250 185 2300 20 185 250OutputCopy0InputCopy2 300 185 2300 300OutputCopy2185 230",
      "description": "D. Long Jumps\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four positive space-separated integers n, l, x, y (2 ≤ n ≤ 105, 2 ≤ l ≤ 109, 1 ≤ x < y ≤ l) — the number of marks, the length of the ruler and the jump norms for girls and boys, correspondingly.The second line contains a sequence of n integers a1, a2, ..., an (0 = a1 < a2 < ... < an = l), where ai shows the distance from the i-th mark to the origin.\n\nOutputIn the first line print a single non-negative integer v — the minimum number of marks that you need to add on the ruler.In the second line print v space-separated integers p1, p2, ..., pv (0 ≤ pi ≤ l). Number pi means that the i-th mark should be at the distance of pi centimeters from the origin. Print the marks in any order. If there are multiple solutions, print any of them.\n\nInputCopy3 250 185 2300 185 250OutputCopy1230InputCopy4 250 185 2300 20 185 250OutputCopy0InputCopy2 300 185 2300 300OutputCopy2185 230\n\nInputCopy3 250 185 2300 185 250\n\nOutputCopy1230\n\nInputCopy4 250 185 2300 20 185 250\n\nOutputCopy0\n\nInputCopy2 300 185 2300 300\n\nOutputCopy2185 230\n\nNoteIn the first sample it is impossible to initially measure the distance of 230 centimeters. For that it is enough to add a 20 centimeter mark or a 230 centimeter mark.In the second sample you already can use the ruler to measure the distances of 185 and 230 centimeters, so you don't have to add new marks.In the third sample the ruler only contains the initial and the final marks. We will need to add two marks to be able to test the children's skills.",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Greetings to the Codeforces community!Yet another Div1+Div2 round will take place this Sunday, 19th of October at 13:00 MSK.The round is based on the problems of the regional stage of All-Russia team school competition, which will take place at the same time in Saratov. We are aware about the overlapping with Opencup, but we have no option to shift the round, because we are bounded to the local event.The problems were prepared by HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan and me.Scoring: 500-1000-1500-2000-2500 (both divisions).UPD: Editorial is published.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 586
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces",
          "content": "I am happy to present you author's ideas of solutions. Editorial of the first five problem is authored by — HolkinPV and gridnevvvit, editorial for the last two problems is written by me.479A - ExpressionIn this task you have to consider several cases and choose the best one: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - TowersThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).479C - Exams, 480A - ExamsThe solution is again greedy. Sort the exams by increasing ai, breaking ties by increasing bi. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (b1). Move to the second exam. If we can take it on the day b2 (i.e. b1 ≤ b2), do it. Otherwise, take the second exam on the day a2. Continue the process, keeping the day of the latest exam. std::sort(a, a + n); // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Long Jumps, 480B - Long JumpsIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both x and y, output 0. Then try to measure both x and y by adding one more mark. If it was not successful, print two marks: one at x, other at y.So, how to check if the answer is 1? Consider all existing marks. Let some mark be at r. Try to add the new mark in each of the following positions: r - x, r + x, r - y, r + y. If it become possible to measure both x and y, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at r + x, we just check if there is a mark at r + x + y or r + x - y (by a binary search, since the marks are sorted). Make sure that the adde marks are in [0, L].479E - Riding in a Lift, 480C - Riding in a LiftThe task is solved by a dynamic programming. State is a pair (i, j), where i is the number of trips made, and j is the current floor. Initial state is (0, a), final states are (k, v), where v is any floor (except b).It is easy to see the transitions: to calculate dp(i, j), let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position j, because we can’t visit the same floor twice in a row). So, dp(i, j) is almost equal to the sum of values dp(i - 1, t), where t belongs to some segment [l, r] (the values of l and r can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute dp(i, j) in O(1), so overall complexity is O(NK).Jury solution: 8322623480D - ParcelsLet’s make two observations.First, consider the parcels as time segments [ini, outi]. It is true that if at some moment of time both parcel i and parcel j are on the platform, and i is higher than j, then .Second, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.These observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number i, and the residual strength is rs. Make this pair (i, rs) the state of DP, because it is exactly the original problem, where the platform strength is rs and there are only parcels j with . In d(i, rs) we will store the answer to this instance of the original problem.Which transitions are there? We can choose a set of parcels i(1), i(2), ... i(k) such that outi(j) ≤ ini(j + 1), i.e. segments do not intersect (but can touch) and are sorted; the weight of each of these parcels does not exceed rs. This choice corresponds to the following sequence of actions: first put parcel i(1) on the top of i. This gets us to the state i(1), min(rs - wi(1), si(1)), so we add up the answer for this state and the cost of i(1). Then we take away all parcels, including i(1), and put the parcel i(2) on top of i, and so on.As the number of states in DP is O(NS), all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in O(N2S). Note that for simplicity the platform can be considered as a parcel too.480E - Parking LotLet’s denote the car arrivals as events.Consider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number x, and the size of the square is k. Now we can update the answers for all events with numbers less than x with a value of k.The model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.Let’s assume that c2 - c1 ≤ r2 - r1 (the opposite case is symmetric). Take the middle row r = (r1 + r2) / 2. Virtually split all the squares inside the sub-table into those which lie above r, those which lie below r, and those which intersect r. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row r.Using initial table, for each cell (r, c) we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): up(r, c), down(r, c), left(r, c) и right(r, c). Using this values, build two histograms for the row r: the first is an array of values up(r, c), where c1 ≤ c ≤ c2; the second is an array of values down(r, c), where c1 ≤ c ≤ c2. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row r upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event x the maximum empty square found in the histograms has size k, and the next event has number y, we can update answers for all events with numbers x, x + 1, ..., y - 1 with the value of k. It remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length k if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 >= k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.Let’s try to estimate the running time. Each call of the routine (omitting inner calls) costs O(len·q), where len is the shortest side of the sub-table, and q is the number of events in it. If we draw a recursion tree, we will see that each second call len decreases twice. The total cost of all operations in a single level of a recursion tree is O(NK), where K is the total number of events. As long as we have O(logN), overall complexity is O(NKlogN).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 479\\s*D"
          },
          "content_length": 8178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(2, 1000000000, \"l\");\n    inf.readSpace();\n    int x = inf.readInt(1, l, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, l, \"y\");\n    inf.readEoln();\n\n    ensuref(x < y, \"Expected x < y, but x=%d, y=%d\", x, y);\n    ensuref(y <= l, \"Expected y <= l, but y=%d, l=%d\", y, l);\n\n    vector<int> a = inf.readInts(n, 0, l, \"a_i\");\n    inf.readEoln();\n\n    ensuref(a[0] == 0, \"First mark must be at 0, but it is at %d\", a[0]);\n    ensuref(a[n - 1] == l, \"Last mark must be at l(%d), but it is at %d\", l, a[n - 1]);\n\n    for(int i = 1; i < n; ++i) {\n        ensuref(a[i] > a[i - 1], \"Marks must be strictly increasing, but a[%d]=%d and a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(2, 1000000000, \"l\");\n    inf.readSpace();\n    int x = inf.readInt(1, l, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, l, \"y\");\n    inf.readEoln();\n\n    ensuref(x < y, \"Expected x < y, but x=%d, y=%d\", x, y);\n    ensuref(y <= l, \"Expected y <= l, but y=%d, l=%d\", y, l);\n\n    vector<int> a = inf.readInts(n, 0, l, \"a_i\");\n    inf.readEoln();\n\n    ensuref(a[0] == 0, \"First mark must be at 0, but it is at %d\", a[0]);\n    ensuref(a[n - 1] == l, \"Last mark must be at l(%d), but it is at %d\", l, a[n - 1]);\n\n    for(int i = 1; i < n; ++i) {\n        ensuref(a[i] > a[i - 1], \"Marks must be strictly increasing, but a[%d]=%d and a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(2, 1000000000, \"l\");\n    inf.readSpace();\n    int x = inf.readInt(1, l, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, l, \"y\");\n    inf.readEoln();\n\n    ensuref(x < y, \"Expected x < y, but x=%d, y=%d\", x, y);\n    ensuref(y <= l, \"Expected y <= l, but y=%d, l=%d\", y, l);\n\n    vector<int> a = inf.readInts(n, 0, l, \"a_i\");\n    inf.readEoln();\n\n    ensuref(a[0] == 0, \"First mark must be at 0, but it is at %d\", a[0]);\n    ensuref(a[n - 1] == l, \"Last mark must be at l(%d), but it is at %d\", l, a[n - 1]);\n\n    for(int i = 1; i < n; ++i) {\n        ensuref(a[i] > a[i - 1], \"Marks must be strictly increasing, but a[%d]=%d and a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This problem may have multiple correct solutions (there can be different ways\n  to add marks in order to measure x and y). Therefore we need a CUSTOM checker.\n\n  We must verify:\n    1) The participant's claimed number of new marks v is indeed minimal.\n    2) The new marks are within [0, l].\n    3) With the existing marks plus the new marks, we can measure both x and y.\n\n  We will do the following steps:\n\n    - Read the input (n, l, x, y) and the n original marks.\n    - Read v from the participant output and then the v new marks proposed.\n    - Check that all new marks are integers in [0..l].\n    - Combine original marks and new marks, then check if we can measure x and y.\n    - Compute the TRUE minimal number of extra marks needed (0, 1, or 2).\n      Compare it with the participant's v. If mismatch, wrong answer.\n    - Otherwise accept the solution.\n*/\n\n// Checks if distance d can be measured by any pair of marks in sorted array \"marks\"\nbool canMeasure(const vector<long long> &marks, long long d) {\n    // We'll use binary search for each mark to see if mark + d exists\n    // Complexity: O(n log n)\n    for (auto &m : marks) {\n        long long need = m + d;\n        // We can do a binary search for \"need\" in marks\n        // Alternatively, use a set if that's convenient\n        // But let's do a standard binary search on sorted vector\n        int idx = int(lower_bound(marks.begin(), marks.end(), need) - marks.begin());\n        if (idx < (int)marks.size() && marks[idx] == need) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Helper: tries to find if we can fix missing distances with a single new mark\n// missingX = (we can't measure x yet), missingY = (we can't measure y yet).\n// Return a valid mark p in [0..l] if it exists, or -1 if no single mark can fix.\nlong long findOneMarkFix(const vector<long long> &marks, long long l,\n                         bool missingX, bool missingY,\n                         long long x, long long y) {\n    // We'll store the marks in a set for quick membership checks\n    unordered_set<long long> s;\n    s.reserve(marks.size() * 2U);\n    for (auto &mm : marks) {\n        s.insert(mm);\n    }\n\n    // We want a single p in [0..l], integer, so that:\n    // if missingX is true, we can measure x using p plus existing marks\n    // if missingY is true, we can measure y using p plus existing marks\n    // We'll try positions that are \"mark ± x\" or \"mark ± y\" because\n    // typically you'd place a new mark that is x or y away from an existing mark.\n    // We'll collect candidates from existing marks that remain in [0..l].\n    vector<long long> candidates;\n    // We'll push a_i +/- x, a_i +/- y into a set of candidates\n    // as possible new positions. Then we'll check each candidate.\n    for (auto &m : marks) {\n        long long c1 = m + x, c2 = m - x, c3 = m + y, c4 = m - y;\n        if (c1 >= 0 && c1 <= l) candidates.push_back(c1);\n        if (c2 >= 0 && c2 <= l) candidates.push_back(c2);\n        if (c3 >= 0 && c3 <= l) candidates.push_back(c3);\n        if (c4 >= 0 && c4 <= l) candidates.push_back(c4);\n    }\n\n    // Remove duplicates from candidates\n    sort(candidates.begin(), candidates.end());\n    candidates.erase(unique(candidates.begin(), candidates.end()), candidates.end());\n\n    // We'll define a small helper to test a single candidate\n    auto checkCandidate = [&](long long p){\n        // Put p with the existing marks, see if it can measure the missing ones\n        // Instead of re-sorting the entire array, we can do direct checks:\n        // Because to measure x or y we just need a pair difference x or y.\n        // We'll insert p into the set s for the check, then remove after.\n        // Or we can do it simpler: to measure x, we need to see if there's some mark m\n        // in s so that |m - p| = x. Similarly for y.\n        // Actually we want to ensure we can measure ALL needed distances (x and/or y).\n        // But we still must keep in mind we might already measure some distances with existing marks.\n        // We'll do a direct check:\n        //   If missingX is true, check if we can measure x with existing or p appended\n        //   If missingY is true, check if we can measure y with existing or p appended\n\n        // If we can already measure x or y with the old marks, no need to re-check for that distance.\n        // Otherwise we see if using p helps.\n        bool okX = !missingX, okY = !missingY;\n\n        // if x was missing, check if there's mark m such that |m - p| = x\n        if (!okX) {\n            // try p±x\n            // if (p + x) or (p - x) in s, or we can do direct membership check\n            if (s.count(p + x) || s.count(p - x)) {\n                okX = true;\n            }\n        }\n        if (!okY) {\n            if (s.count(p + y) || s.count(p - y)) {\n                okY = true;\n            }\n        }\n\n        // Now if both are still missing, no single p helps. But let's check after we do that.\n        // If we still need them, we can see if p helps them measure themselves,\n        // but we did so above. So that is enough.\n        return (okX && okY);\n    };\n\n    for (auto &cand : candidates) {\n        if (checkCandidate(cand)) {\n            return cand;\n        }\n    }\n    return -1;\n}\n\n// Computes the minimal number of new marks needed (0, 1, or 2) using a direct logic.\n// Also produce up to 2 valid marks if needed. If 0 or 1 mark is enough, we fill\n// fewer elements in \"marksToAdd\".\nint computeMinMarks(const vector<long long> &orig, long long l, long long x, long long y,\n                    vector<long long> &marksToAdd) {\n    // Step 1: check which of x, y we can already measure\n    bool canX = canMeasure(orig, x);\n    bool canY = canMeasure(orig, y);\n\n    // If both are measurable, done\n    if (canX && canY) {\n        return 0; // No marks needed\n    }\n\n    // Step 2: check if 1 mark can fix\n    long long p = findOneMarkFix(orig, l, !canX, !canY, x, y);\n    if (p != -1) {\n        marksToAdd.clear();\n        marksToAdd.push_back(p);\n        return 1;\n    }\n\n    // Step 3: otherwise, we need at most 2 new marks. There's a known fact that 2 marks always suffice.\n    // A typical approach is: if we can't measure x, we add one mark to fix x; then see if we can measure y,\n    // possibly adding 2nd mark if needed. We'll just do a direct approach:\n    // We can add a mark that fixes x if x is not measurable, and possibly the same mark might fix y,\n    // but if not, we add a second mark to fix y.\n    marksToAdd.clear();\n\n    // If canX = false, fix x with one mark\n    if (!canX) {\n        // We'll guess some candidate. For example, take any existing mark a_i and add (a_i + x) or (a_i - x) if it fits.\n        // But we can just pick (orig[0] + x) if that's in [0..l], or (orig.back() - x). \n        // For simplicity:\n        long long cand1 = orig[0] + x; // might be in range\n        if (cand1 < 0 || cand1 > l) {\n            cand1 = orig.back() - x; // this must be in [0..l] because orig.back()=l\n        }\n        // That might still be negative if x > l, but the problem states x <= l, so cand1>=0 is guaranteed if x<=l\n        if (cand1 < 0) cand1 = 0;\n        if (cand1 > l) cand1 = l; // just in case\n        marksToAdd.push_back(cand1);\n    }\n\n    // Combine that new mark with original and see if y is now measurable\n    {\n        // we'll form a new vector for checking y\n        vector<long long> tmp = orig;\n        if (!marksToAdd.empty()) {\n            tmp.push_back(marksToAdd[0]);\n        }\n        sort(tmp.begin(), tmp.end());\n        bool nowY = canMeasure(tmp, y);\n        if (!nowY) {\n            // we need one more mark to fix y\n            // similarly place a second mark\n            // we can pick tmp[0] + y or so, but let's do the same logic\n            long long cand2 = tmp[0] + y;\n            if (cand2 < 0 || cand2 > l) {\n                cand2 = tmp.back() - y;\n                if (cand2 < 0) cand2 = 0;\n                if (cand2 > l) cand2 = l;\n            }\n            marksToAdd.push_back(cand2);\n        }\n    }\n\n    // In the worst case, we ended up with 2 new marks. That is guaranteed to suffice.\n    return (int)marksToAdd.size();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    long long n = inf.readLong();\n    long long l = inf.readLong();\n    long long x = inf.readLong();\n    long long y = inf.readLong();\n\n    vector<long long> orig(n);\n    for (int i = 0; i < n; i++) {\n        orig[i] = inf.readLong();\n    }\n\n    // Read participant's output\n    int v = ouf.readInt(0, 2, \"number of new marks (v)\"); \n    // The problem statement says \"print a single non-negative integer v\".\n    // We also know from problem constraints the maximum they'd ever need is 2,\n    // so we forcibly limit it to [0..2].\n\n    vector<long long> added;\n    added.reserve(v);\n    for (int i = 0; i < v; i++) {\n        long long markPos = ouf.readLong(0LL, l, \"new mark position\");\n        added.push_back(markPos);\n    }\n\n    // 1) Combine participant's new marks with original, check if x and y are measurable\n    vector<long long> allMarks = orig;\n    for (auto &x : added) {\n        allMarks.push_back(x);\n    }\n    sort(allMarks.begin(), allMarks.end());\n\n    // check if x is measurable\n    if (!canMeasure(allMarks, x)) {\n        ouf.quitf(_wa, \"Cannot measure distance x = %lld with the provided marks.\", x);\n    }\n    // check if y is measurable\n    if (!canMeasure(allMarks, y)) {\n        ouf.quitf(_wa, \"Cannot measure distance y = %lld with the provided marks.\", y);\n    }\n\n    // 2) Check that v is minimal\n    vector<long long> minimalSolution;\n    int minimalV = computeMinMarks(orig, l, x, y, minimalSolution);\n\n    if (v != minimalV) {\n        ouf.quitf(_wa,\n                  \"The number of new marks (v=%d) is not minimal. The minimal number is %d.\",\n                  v, minimalV);\n    }\n\n    // If everything passed, accept\n    ouf.quitf(_ok, \"Solution is correct with v = %d new mark(s).\", v);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int l = opt<int>(\"l\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<int> marks;\n    marks.insert(0);\n    marks.insert(l);\n\n    if (type == \"missing_both\") {\n        n = 2;\n    } else if (type == \"missing_x\") {\n        marks.insert(y);\n        n = 3;\n    } else if (type == \"missing_y\") {\n        marks.insert(x);\n        n = 3;\n    } else if (type == \"already_good\") {\n        marks.insert(x);\n        marks.insert(y);\n        n = 4;\n    } else if (type == \"max_n\") {\n        n = 100000;\n        while ((int)marks.size() < n) {\n            int pos = rnd.next(1, l - 1);\n            marks.insert(pos);\n        }\n    } else if (type == \"min_n\") {\n        n = 2;\n    } else if (type == \"equal_spacing\") {\n        n = opt<int>(\"n\");\n        int spacing = l / (n - 1);\n        for (int i = 1; i < n - 1; ++i) {\n            marks.insert(i * spacing);\n        }\n    } else if (type == \"random\") {\n        if (n == -1) {\n            n = rnd.next(2, 1000); // default n if not specified\n        }\n        while ((int)marks.size() < n) {\n            int pos = rnd.next(1, l - 1);\n            marks.insert(pos);\n        }\n    } else {\n        // For custom types, treat as random\n        if (n == -1) {\n            n = rnd.next(2, 1000);\n        }\n        while ((int)marks.size() < n) {\n            int pos = rnd.next(1, l - 1);\n            marks.insert(pos);\n        }\n    }\n\n    vector<int> a(marks.begin(), marks.end());\n    sort(a.begin(), a.end());\n\n    // Output\n    printf(\"%d %d %d %d\\n\", n, l, x, y);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int l = opt<int>(\"l\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<int> marks;\n    marks.insert(0);\n    marks.insert(l);\n\n    if (type == \"missing_both\") {\n        n = 2;\n    } else if (type == \"missing_x\") {\n        marks.insert(y);\n        n = 3;\n    } else if (type == \"missing_y\") {\n        marks.insert(x);\n        n = 3;\n    } else if (type == \"already_good\") {\n        marks.insert(x);\n        marks.insert(y);\n        n = 4;\n    } else if (type == \"max_n\") {\n        n = 100000;\n        while ((int)marks.size() < n) {\n            int pos = rnd.next(1, l - 1);\n            marks.insert(pos);\n        }\n    } else if (type == \"min_n\") {\n        n = 2;\n    } else if (type == \"equal_spacing\") {\n        n = opt<int>(\"n\");\n        int spacing = l / (n - 1);\n        for (int i = 1; i < n - 1; ++i) {\n            marks.insert(i * spacing);\n        }\n    } else if (type == \"random\") {\n        if (n == -1) {\n            n = rnd.next(2, 1000); // default n if not specified\n        }\n        while ((int)marks.size() < n) {\n            int pos = rnd.next(1, l - 1);\n            marks.insert(pos);\n        }\n    } else {\n        // For custom types, treat as random\n        if (n == -1) {\n            n = rnd.next(2, 1000);\n        }\n        while ((int)marks.size() < n) {\n            int pos = rnd.next(1, l - 1);\n            marks.insert(pos);\n        }\n    }\n\n    vector<int> a(marks.begin(), marks.end());\n    sort(a.begin(), a.end());\n\n    // Output\n    printf(\"%d %d %d %d\\n\", n, l, x, y);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal number of marks, cannot measure x or y\n./gen -l 1000 -x 100 -y 200 -type missing_both\n\n# Minimal number of marks, can measure x but not y\n./gen -l 1000 -x 100 -y 200 -type missing_y\n\n# Minimal number of marks, can measure y but not x\n./gen -l 1000 -x 100 -y 200 -type missing_x\n\n# Minimal number of marks, can measure both x and y\n./gen -l 1000 -x 100 -y 200 -type already_good\n\n# Maximal number of marks, random positions\n./gen -l 1000000000 -x 500000000 -y 750000000 -type max_n\n\n# Minimal number of marks\n./gen -l 1000000000 -x 500000000 -y 750000000 -type min_n\n\n# Random test case with specified n\n./gen -n 1000 -l 1000000 -x 50000 -y 80000 -type random\n\n# Random test case with large n\n./gen -n 50000 -l 1000000000 -x 200000000 -y 300000000 -type random\n\n# Random test case with small x and y\n./gen -n 1000 -l 1000000 -x 1 -y 2 -type random\n\n# Random test case with large x and y\n./gen -n 100000 -l 1000000000 -x 999999999 -y 1000000000 -type random\n\n# Test case with equal spacing between marks\n./gen -n 100 -l 1000 -x 10 -y 20 -type equal_spacing\n\n# Test case where x and y are close\n./gen -n 1000 -l 1000000 -x 500000 -y 500001 -type random\n\n# Test case with x = y\n./gen -n 1000 -l 1000000 -x 500000 -y 500000 -type already_good\n\n# Test case with x = 1\n./gen -n 1000 -l 1000000 -x 1 -y 1000 -type random\n\n# Test case with y = l\n./gen -n 1000 -l 1000000 -x 500000 -y 1000000 -type random\n\n# Test case with n = 2, l = 2, x = 1, y = 1\n./gen -n 2 -l 2 -x 1 -y 1 -type missing_both\n\n# Test case with n = 2, l = 10^9\n./gen -n 2 -l 1000000000 -x 1 -y 1 -type missing_both\n\n# Test case with maximum possible values\n./gen -l 1000000000 -x 999999999 -y 1000000000 -type max_n\n\n# Test case with minimal possible values\n./gen -l 2 -x 1 -y 2 -type min_n\n\n# Test case where marks are densely packed\n./gen -n 100000 -l 1000000 -x 1 -y 2 -type random\n\n# Test case where marks are sparsely distributed\n./gen -n 1000 -l 1000000000 -x 500000000 -y 999999999 -type random\n\n# Test case with random marks, x and y cannot be measured\n./gen -n 1000 -l 1000000 -x 123456 -y 654321 -type missing_both\n\n# Test case with random marks, only x can be measured\n./gen -n 1000 -l 1000000 -x 123456 -y 654321 -type missing_y\n\n# Test case with random marks, only y can be measured\n./gen -n 1000 -l 1000000 -x 123456 -y 654321 -type missing_x\n\n# Test case with random marks, both x and y can be measured\n./gen -n 1000 -l 1000000 -x 123456 -y 654321 -type already_good\n\n# Test case with equal spacing, cannot measure x or y\n./gen -n 100 -l 1000 -x 15 -y 25 -type equal_spacing\n\n# Test case to check behavior when x and y are factors of l\n./gen -n 1000 -l 1000000 -x 250000 -y 500000 -type random\n\n# Test case with n = 2, x and y cannot be measured\n./gen -n 2 -l 1000 -x 100 -y 200 -type missing_both\n\n# Test case with n = 3, x can be measured but y cannot\n./gen -l 1000 -x 100 -y 200 -type missing_y\n\n# Test case with n = 3, y can be measured but x cannot\n./gen -l 1000 -x 100 -y 200 -type missing_x\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:00.383466",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "479/E",
      "title": "E. Riding in a Lift",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four space-separated integers n, a, b, k (2 ≤ n ≤ 5000, 1 ≤ k ≤ 5000, 1 ≤ a, b ≤ n, a ≠ b).",
      "output_spec": "OutputPrint a single integer — the remainder after dividing the sought number of sequences by 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy5 2 4 1OutputCopy2InputCopy5 2 4 2OutputCopy2InputCopy5 3 4 1OutputCopy0",
      "description": "E. Riding in a Lift\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains four space-separated integers n, a, b, k (2 ≤ n ≤ 5000, 1 ≤ k ≤ 5000, 1 ≤ a, b ≤ n, a ≠ b).\n\nOutputPrint a single integer — the remainder after dividing the sought number of sequences by 1000000007 (109 + 7).\n\nInputCopy5 2 4 1OutputCopy2InputCopy5 2 4 2OutputCopy2InputCopy5 3 4 1OutputCopy0\n\nInputCopy5 2 4 1\n\nOutputCopy2\n\nInputCopy5 2 4 2\n\nOutputCopy2\n\nInputCopy5 3 4 1\n\nOutputCopy0\n\nNoteTwo sequences p1, p2, ..., pk and q1, q2, ..., qk are distinct, if there is such integer j (1 ≤ j ≤ k), that pj ≠ qj.Notes to the samples:  In the first sample after the first trip you are either on floor 1, or on floor 3, because |1 - 2| < |2 - 4| and |3 - 2| < |2 - 4|.  In the second sample there are two possible sequences: (1, 2); (1, 3). You cannot choose floor 3 for the first trip because in this case no floor can be the floor for the second trip.  In the third sample there are no sought sequences, because you cannot choose the floor for the first trip.",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Greetings to the Codeforces community!Yet another Div1+Div2 round will take place this Sunday, 19th of October at 13:00 MSK.The round is based on the problems of the regional stage of All-Russia team school competition, which will take place at the same time in Saratov. We are aware about the overlapping with Opencup, but we have no option to shift the round, because we are bounded to the local event.The problems were prepared by HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan and me.Scoring: 500-1000-1500-2000-2500 (both divisions).UPD: Editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 586
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces",
          "content": "I am happy to present you author's ideas of solutions. Editorial of the first five problem is authored by — HolkinPV and gridnevvvit, editorial for the last two problems is written by me.479A - ExpressionIn this task you have to consider several cases and choose the best one: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - TowersThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).479C - Exams, 480A - ExamsThe solution is again greedy. Sort the exams by increasing ai, breaking ties by increasing bi. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (b1). Move to the second exam. If we can take it on the day b2 (i.e. b1 ≤ b2), do it. Otherwise, take the second exam on the day a2. Continue the process, keeping the day of the latest exam. std::sort(a, a + n); // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Long Jumps, 480B - Long JumpsIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both x and y, output 0. Then try to measure both x and y by adding one more mark. If it was not successful, print two marks: one at x, other at y.So, how to check if the answer is 1? Consider all existing marks. Let some mark be at r. Try to add the new mark in each of the following positions: r - x, r + x, r - y, r + y. If it become possible to measure both x and y, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at r + x, we just check if there is a mark at r + x + y or r + x - y (by a binary search, since the marks are sorted). Make sure that the adde marks are in [0, L].479E - Riding in a Lift, 480C - Riding in a LiftThe task is solved by a dynamic programming. State is a pair (i, j), where i is the number of trips made, and j is the current floor. Initial state is (0, a), final states are (k, v), where v is any floor (except b).It is easy to see the transitions: to calculate dp(i, j), let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position j, because we can’t visit the same floor twice in a row). So, dp(i, j) is almost equal to the sum of values dp(i - 1, t), where t belongs to some segment [l, r] (the values of l and r can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute dp(i, j) in O(1), so overall complexity is O(NK).Jury solution: 8322623480D - ParcelsLet’s make two observations.First, consider the parcels as time segments [ini, outi]. It is true that if at some moment of time both parcel i and parcel j are on the platform, and i is higher than j, then .Second, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.These observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number i, and the residual strength is rs. Make this pair (i, rs) the state of DP, because it is exactly the original problem, where the platform strength is rs and there are only parcels j with . In d(i, rs) we will store the answer to this instance of the original problem.Which transitions are there? We can choose a set of parcels i(1), i(2), ... i(k) such that outi(j) ≤ ini(j + 1), i.e. segments do not intersect (but can touch) and are sorted; the weight of each of these parcels does not exceed rs. This choice corresponds to the following sequence of actions: first put parcel i(1) on the top of i. This gets us to the state i(1), min(rs - wi(1), si(1)), so we add up the answer for this state and the cost of i(1). Then we take away all parcels, including i(1), and put the parcel i(2) on top of i, and so on.As the number of states in DP is O(NS), all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in O(N2S). Note that for simplicity the platform can be considered as a parcel too.480E - Parking LotLet’s denote the car arrivals as events.Consider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number x, and the size of the square is k. Now we can update the answers for all events with numbers less than x with a value of k.The model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.Let’s assume that c2 - c1 ≤ r2 - r1 (the opposite case is symmetric). Take the middle row r = (r1 + r2) / 2. Virtually split all the squares inside the sub-table into those which lie above r, those which lie below r, and those which intersect r. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row r.Using initial table, for each cell (r, c) we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): up(r, c), down(r, c), left(r, c) и right(r, c). Using this values, build two histograms for the row r: the first is an array of values up(r, c), where c1 ≤ c ≤ c2; the second is an array of values down(r, c), where c1 ≤ c ≤ c2. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row r upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event x the maximum empty square found in the histograms has size k, and the next event has number y, we can update answers for all events with numbers x, x + 1, ..., y - 1 with the value of k. It remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length k if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 >= k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.Let’s try to estimate the running time. Each call of the routine (omitting inner calls) costs O(len·q), where len is the shortest side of the sub-table, and q is the number of events in it. If we draw a recursion tree, we will see that each second call len decreases twice. The total cost of all operations in a single level of a recursion tree is O(NK), where K is the total number of events. As long as we have O(logN), overall complexity is O(NKlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 479\\s*E"
          },
          "content_length": 8178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n\n    ensuref(a != b, \"a should not be equal to b, but a=%d, b=%d\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n\n    ensuref(a != b, \"a should not be equal to b, but a=%d, b=%d\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n\n    ensuref(a != b, \"a should not be equal to b, but a=%d, b=%d\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_max = opt<int>(\"n\");\n    int k_max = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\"); // default to random\n\n    ensure(2 <= n_max && n_max <= 5000);\n    ensure(1 <= k_max && k_max <= 5000);\n\n    int n, k, a, b;\n\n    if (type == \"random\") {\n        n = rnd.next(2, n_max);\n        k = rnd.next(1, k_max);\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n        } while (a == b);\n    } else if (type == \"max\") {\n        n = n_max;\n        k = k_max;\n        a = rnd.next(1, n);\n        do {\n            b = rnd.next(1, n);\n        } while (a == b);\n    } else if (type == \"zero\") {\n        n = n_max;\n        k = k_max;\n        if (n == 2) {\n            a = 1;\n            b = 2;\n        } else {\n            a = rnd.next(1, n);\n            if (a == 1) b = 2;\n            else if (a == n) b = n - 1;\n            else b = a - 1; // So that |a - b| = 1\n        }\n    } else if (type == \"edge\") {\n        n = n_max;\n        k = k_max;\n        a = 1;\n        b = n;\n    } else if (type == \"adjacent\") {\n        n = n_max;\n        k = k_max;\n        if (n >= 2) {\n            a = rnd.next(2, n - 1);\n            b = (rnd.next(0, 1) == 0) ? a - 1 : a + 1;\n        } else {\n            n = 2;\n            a = 1;\n            b = 2;\n        }\n        ensure(1 <= b && b <= n);\n        ensure(a != b);\n    } else if (type == \"fixed\") {\n        n = n_max;\n        k = k_max;\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n        ensure(1 <= a && a <= n);\n        ensure(1 <= b && b <= n);\n        ensure(a != b);\n    } else if (type == \"max_answer\") {\n        n = n_max;\n        k = k_max;\n        a = rnd.next(1, n);\n        b = (a <= n / 2) ? n : 1;\n        ensure(a != b);\n    } else {\n        n = rnd.next(2, n_max);\n        k = rnd.next(1, k_max);\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n        } while (a == b);\n    }\n\n    ensure(2 <= n && n <= 5000);\n    ensure(1 <= k && k <= 5000);\n    ensure(1 <= a && a <= n);\n    ensure(1 <= b && b <= n);\n    ensure(a != b);\n\n    printf(\"%d %d %d %d\\n\", n, a, b, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_max = opt<int>(\"n\");\n    int k_max = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\"); // default to random\n\n    ensure(2 <= n_max && n_max <= 5000);\n    ensure(1 <= k_max && k_max <= 5000);\n\n    int n, k, a, b;\n\n    if (type == \"random\") {\n        n = rnd.next(2, n_max);\n        k = rnd.next(1, k_max);\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n        } while (a == b);\n    } else if (type == \"max\") {\n        n = n_max;\n        k = k_max;\n        a = rnd.next(1, n);\n        do {\n            b = rnd.next(1, n);\n        } while (a == b);\n    } else if (type == \"zero\") {\n        n = n_max;\n        k = k_max;\n        if (n == 2) {\n            a = 1;\n            b = 2;\n        } else {\n            a = rnd.next(1, n);\n            if (a == 1) b = 2;\n            else if (a == n) b = n - 1;\n            else b = a - 1; // So that |a - b| = 1\n        }\n    } else if (type == \"edge\") {\n        n = n_max;\n        k = k_max;\n        a = 1;\n        b = n;\n    } else if (type == \"adjacent\") {\n        n = n_max;\n        k = k_max;\n        if (n >= 2) {\n            a = rnd.next(2, n - 1);\n            b = (rnd.next(0, 1) == 0) ? a - 1 : a + 1;\n        } else {\n            n = 2;\n            a = 1;\n            b = 2;\n        }\n        ensure(1 <= b && b <= n);\n        ensure(a != b);\n    } else if (type == \"fixed\") {\n        n = n_max;\n        k = k_max;\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n        ensure(1 <= a && a <= n);\n        ensure(1 <= b && b <= n);\n        ensure(a != b);\n    } else if (type == \"max_answer\") {\n        n = n_max;\n        k = k_max;\n        a = rnd.next(1, n);\n        b = (a <= n / 2) ? n : 1;\n        ensure(a != b);\n    } else {\n        n = rnd.next(2, n_max);\n        k = rnd.next(1, k_max);\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n        } while (a == b);\n    }\n\n    ensure(2 <= n && n <= 5000);\n    ensure(1 <= k && k <= 5000);\n    ensure(1 <= a && a <= n);\n    ensure(1 <= b && b <= n);\n    ensure(a != b);\n\n    printf(\"%d %d %d %d\\n\", n, a, b, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 5 -k 1 -type random\n./gen -n 5 -k 2 -type random\n./gen -n 10 -k 5 -type random\n\n# Large random test cases\n./gen -n 5000 -k 5000 -type random\n./gen -n 5000 -k 2500 -type random\n./gen -n 5000 -k 4999 -type random\n\n# Maximal test cases\n./gen -n 5000 -k 5000 -type max\n./gen -n 5000 -k 5000 -type max_answer\n\n# Zero-answer cases\n./gen -n 2 -k 1 -type zero\n./gen -n 5000 -k 5000 -type zero\n\n# Edge cases\n./gen -n 5000 -k 5000 -type edge\n./gen -n 5000 -k 5000 -type adjacent\n./gen -n 5000 -k 5000 -type adjacent\n./gen -n 5000 -k 5000 -type edge\n\n# Fixed a and b\n./gen -n 5000 -k 5000 -type fixed -a 1 -b 5000\n./gen -n 5000 -k 5000 -type fixed -a 5000 -b 1\n./gen -n 1000 -k 1000 -type fixed -a 500 -b 501\n\n# Small n, large k\n./gen -n 2 -k 5000 -type fixed -a 1 -b 2\n\n# k = 1 cases\n./gen -n 5000 -k 1 -type random\n./gen -n 5000 -k 1 -type fixed -a 1234 -b 4321\n\n# n = k cases\n./gen -n 5000 -k 5000 -type random\n\n# Specific cases to test off-by-one errors\n./gen -n 5000 -k 5000 -type fixed -a 1 -b 2\n./gen -n 5000 -k 5000 -type fixed -a 5000 -b 4999\n\n# Additional random test cases\n./gen -n 100 -k 100 -type random\n./gen -n 1000 -k 500 -type random\n./gen -n 2000 -k 2000 -type random\n./gen -n 4000 -k 3000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:02.264811",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "48/A",
      "title": "A. Rock-paper-scissors",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains the name of the gesture that Uncle Fyodor showed, the second line shows which gesture Matroskin showed and the third line shows Sharic’s gesture.",
      "output_spec": "OutputPrint \"F\" (without quotes) if Uncle Fyodor wins. Print \"M\" if Matroskin wins and \"S\" if Sharic wins. If it is impossible to find the winner, print \"?\".",
      "sample_tests": "ExamplesInputCopyrockrockrockOutputCopy?InputCopypaperrockrockOutputCopyFInputCopyscissorsrockrockOutputCopy?InputCopyscissorspaperrockOutputCopy?",
      "description": "A. Rock-paper-scissors\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains the name of the gesture that Uncle Fyodor showed, the second line shows which gesture Matroskin showed and the third line shows Sharic’s gesture.\n\nOutputPrint \"F\" (without quotes) if Uncle Fyodor wins. Print \"M\" if Matroskin wins and \"S\" if Sharic wins. If it is impossible to find the winner, print \"?\".\n\nInputCopyrockrockrockOutputCopy?InputCopypaperrockrockOutputCopyFInputCopyscissorsrockrockOutputCopy?InputCopyscissorspaperrockOutputCopy?\n\nInputCopyrockrockrock\n\nOutputCopy?\n\nInputCopypaperrockrock\n\nOutputCopyF\n\nInputCopyscissorsrockrock\n\nOutputCopy?\n\nInputCopyscissorspaperrock\n\nOutputCopy?",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the first gesture\n    string gesture1 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Read the second gesture\n    string gesture2 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Read the third gesture\n    string gesture3 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the first gesture\n    string gesture1 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Read the second gesture\n    string gesture2 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Read the third gesture\n    string gesture3 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the first gesture\n    string gesture1 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Read the second gesture\n    string gesture2 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Read the third gesture\n    string gesture3 = inf.readLine(\"^(rock|paper|scissors)$\");\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    string player = opt<string>(\"player\", \"F\");\n\n    vector<string> gestures = {\"rock\", \"paper\", \"scissors\"};\n    map<string, string> beats;\n    beats[\"rock\"] = \"scissors\";\n    beats[\"paper\"] = \"rock\";\n    beats[\"scissors\"] = \"paper\";\n\n    string F_gesture, M_gesture, S_gesture;\n\n    if (type == \"player_wins\") {\n        // Generate test case where the specified player wins\n        string winner_gesture = gestures[rnd.next(3)];\n        string beaten_gesture = beats[winner_gesture];\n\n        if (player == \"F\") {\n            F_gesture = winner_gesture;\n            M_gesture = beaten_gesture;\n            S_gesture = beaten_gesture;\n        } else if (player == \"M\") {\n            M_gesture = winner_gesture;\n            F_gesture = beaten_gesture;\n            S_gesture = beaten_gesture;\n        } else if (player == \"S\") {\n            S_gesture = winner_gesture;\n            F_gesture = beaten_gesture;\n            M_gesture = beaten_gesture;\n        } else {\n            cerr << \"Invalid player parameter\" << endl;\n            return 1;\n        }\n    } else if (type == \"tie_two\") {\n        // Generate test case where two players tie and beat the third\n        string winning_gesture = gestures[rnd.next(3)];\n        string beaten_gesture = beats[winning_gesture];\n\n        int beaten_player = rnd.next(3);\n\n        if (beaten_player == 0) {\n            F_gesture = beaten_gesture;\n            M_gesture = winning_gesture;\n            S_gesture = winning_gesture;\n        } else if (beaten_player == 1) {\n            F_gesture = winning_gesture;\n            M_gesture = beaten_gesture;\n            S_gesture = winning_gesture;\n        } else {\n            F_gesture = winning_gesture;\n            M_gesture = winning_gesture;\n            S_gesture = beaten_gesture;\n        }\n    } else if (type == \"no_winner\") {\n        // Generate test case where no one wins\n        while (true) {\n            F_gesture = gestures[rnd.next(3)];\n            M_gesture = gestures[rnd.next(3)];\n            S_gesture = gestures[rnd.next(3)];\n\n            bool F_wins = (beats[F_gesture] == M_gesture && beats[F_gesture] == S_gesture);\n            bool M_wins = (beats[M_gesture] == F_gesture && beats[M_gesture] == S_gesture);\n            bool S_wins = (beats[S_gesture] == F_gesture && beats[S_gesture] == M_gesture);\n\n            if (!(F_wins || M_wins || S_wins)) {\n                break;\n            }\n        }\n\n    } else if (type == \"all_same\") {\n        // All gestures are the same\n        string same_gesture = gestures[rnd.next(3)];\n        F_gesture = same_gesture;\n        M_gesture = same_gesture;\n        S_gesture = same_gesture;\n    } else if (type == \"specific\") {\n        // Generate test case with specified gestures\n        F_gesture = opt<string>(\"f\");\n        M_gesture = opt<string>(\"m\");\n        S_gesture = opt<string>(\"s\");\n\n        // Validate gestures\n        if (find(gestures.begin(), gestures.end(), F_gesture) == gestures.end() ||\n            find(gestures.begin(), gestures.end(), M_gesture) == gestures.end() ||\n            find(gestures.begin(), gestures.end(), S_gesture) == gestures.end()) {\n                cerr << \"Invalid gesture(s)\" << endl;\n                return 1;\n        }\n    } else if (type == \"random\") {\n        // Random gestures\n        F_gesture = gestures[rnd.next(3)];\n        M_gesture = gestures[rnd.next(3)];\n        S_gesture = gestures[rnd.next(3)];\n    } else {\n        cerr << \"Invalid type parameter\" << endl;\n        return 1;\n    }\n\n    // Output the gestures\n    cout << F_gesture << endl;\n    cout << M_gesture << endl;\n    cout << S_gesture << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    string player = opt<string>(\"player\", \"F\");\n\n    vector<string> gestures = {\"rock\", \"paper\", \"scissors\"};\n    map<string, string> beats;\n    beats[\"rock\"] = \"scissors\";\n    beats[\"paper\"] = \"rock\";\n    beats[\"scissors\"] = \"paper\";\n\n    string F_gesture, M_gesture, S_gesture;\n\n    if (type == \"player_wins\") {\n        // Generate test case where the specified player wins\n        string winner_gesture = gestures[rnd.next(3)];\n        string beaten_gesture = beats[winner_gesture];\n\n        if (player == \"F\") {\n            F_gesture = winner_gesture;\n            M_gesture = beaten_gesture;\n            S_gesture = beaten_gesture;\n        } else if (player == \"M\") {\n            M_gesture = winner_gesture;\n            F_gesture = beaten_gesture;\n            S_gesture = beaten_gesture;\n        } else if (player == \"S\") {\n            S_gesture = winner_gesture;\n            F_gesture = beaten_gesture;\n            M_gesture = beaten_gesture;\n        } else {\n            cerr << \"Invalid player parameter\" << endl;\n            return 1;\n        }\n    } else if (type == \"tie_two\") {\n        // Generate test case where two players tie and beat the third\n        string winning_gesture = gestures[rnd.next(3)];\n        string beaten_gesture = beats[winning_gesture];\n\n        int beaten_player = rnd.next(3);\n\n        if (beaten_player == 0) {\n            F_gesture = beaten_gesture;\n            M_gesture = winning_gesture;\n            S_gesture = winning_gesture;\n        } else if (beaten_player == 1) {\n            F_gesture = winning_gesture;\n            M_gesture = beaten_gesture;\n            S_gesture = winning_gesture;\n        } else {\n            F_gesture = winning_gesture;\n            M_gesture = winning_gesture;\n            S_gesture = beaten_gesture;\n        }\n    } else if (type == \"no_winner\") {\n        // Generate test case where no one wins\n        while (true) {\n            F_gesture = gestures[rnd.next(3)];\n            M_gesture = gestures[rnd.next(3)];\n            S_gesture = gestures[rnd.next(3)];\n\n            bool F_wins = (beats[F_gesture] == M_gesture && beats[F_gesture] == S_gesture);\n            bool M_wins = (beats[M_gesture] == F_gesture && beats[M_gesture] == S_gesture);\n            bool S_wins = (beats[S_gesture] == F_gesture && beats[S_gesture] == M_gesture);\n\n            if (!(F_wins || M_wins || S_wins)) {\n                break;\n            }\n        }\n\n    } else if (type == \"all_same\") {\n        // All gestures are the same\n        string same_gesture = gestures[rnd.next(3)];\n        F_gesture = same_gesture;\n        M_gesture = same_gesture;\n        S_gesture = same_gesture;\n    } else if (type == \"specific\") {\n        // Generate test case with specified gestures\n        F_gesture = opt<string>(\"f\");\n        M_gesture = opt<string>(\"m\");\n        S_gesture = opt<string>(\"s\");\n\n        // Validate gestures\n        if (find(gestures.begin(), gestures.end(), F_gesture) == gestures.end() ||\n            find(gestures.begin(), gestures.end(), M_gesture) == gestures.end() ||\n            find(gestures.begin(), gestures.end(), S_gesture) == gestures.end()) {\n                cerr << \"Invalid gesture(s)\" << endl;\n                return 1;\n        }\n    } else if (type == \"random\") {\n        // Random gestures\n        F_gesture = gestures[rnd.next(3)];\n        M_gesture = gestures[rnd.next(3)];\n        S_gesture = gestures[rnd.next(3)];\n    } else {\n        cerr << \"Invalid type parameter\" << endl;\n        return 1;\n    }\n\n    // Output the gestures\n    cout << F_gesture << endl;\n    cout << M_gesture << endl;\n    cout << S_gesture << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases where Uncle Fyodor wins\n./gen -type player_wins -player F\n./gen -type player_wins -player F\n./gen -type player_wins -player F\n\n# Test cases where Matroskin wins\n./gen -type player_wins -player M\n./gen -type player_wins -player M\n./gen -type player_wins -player M\n\n# Test cases where Sharic wins\n./gen -type player_wins -player S\n./gen -type player_wins -player S\n./gen -type player_wins -player S\n\n# All gestures are the same\n./gen -type all_same\n./gen -type all_same\n./gen -type all_same\n\n# Test cases where no one wins (randomly generated)\n./gen -type no_winner\n./gen -type no_winner\n./gen -type no_winner\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Test cases where two players tie and beat the third\n./gen -type tie_two\n./gen -type tie_two\n./gen -type tie_two\n\n# Specific test cases to catch possible mistakes\n./gen -type specific -f rock -m paper -s scissors\n./gen -type specific -f scissors -m rock -s paper\n./gen -type specific -f paper -m scissors -s rock\n\n./gen -type specific -f rock -m rock -s paper\n./gen -type specific -f scissors -m scissors -s rock\n./gen -type specific -f paper -m paper -s scissors\n\n# Edge cases\n./gen -type specific -f rock -m scissors -s scissors\n./gen -type specific -f paper -m rock -s rock\n./gen -type specific -f scissors -m paper -s paper\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:04.296616",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "48/B",
      "title": "B. Участок для дома",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n и m (1 ≤ n, m ≤ 50) — размеры сада. В следующих n строках записано по m чисел 0 или 1, которые описывают сад на плане. Ноль означает, что в этой клетке не растет дерево, а единица — что растет. В последней строке записано два целых числа a и b (1 ≤ a, b ≤ 50). Обратите внимание, что дядя Вася может выбрать для строительства как прямоугольник a × b, так и b × a, т.е. сторона участка для строительства длиной a может располагаться как параллельно стороне участка с длиной n, так и параллельно стороне участка с длиной m.",
      "output_spec": "Выходные данныеВыведите наименьшее количество деревьев, которое нужно вырубить, чтобы выделить участок a × b под строительство домика. Гарантируется, что хотя бы одно положение для участка всегда найдется, т. е. или a ≤ n и b ≤ m, или a ≤ m и b ≤ n.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 21 01 11 1Выходные данныеСкопировать0Входные данныеСкопировать4 50 0 1 0 10 1 1 1 01 0 1 0 11 1 1 1 12 3Выходные данныеСкопировать2",
      "description": "B. Участок для дома\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n и m (1 ≤ n, m ≤ 50) — размеры сада. В следующих n строках записано по m чисел 0 или 1, которые описывают сад на плане. Ноль означает, что в этой клетке не растет дерево, а единица — что растет. В последней строке записано два целых числа a и b (1 ≤ a, b ≤ 50). Обратите внимание, что дядя Вася может выбрать для строительства как прямоугольник a × b, так и b × a, т.е. сторона участка для строительства длиной a может располагаться как параллельно стороне участка с длиной n, так и параллельно стороне участка с длиной m.\n\nВходные данные\n\nВыходные данныеВыведите наименьшее количество деревьев, которое нужно вырубить, чтобы выделить участок a × b под строительство домика. Гарантируется, что хотя бы одно положение для участка всегда найдется, т. е. или a ≤ n и b ≤ m, или a ≤ m и b ≤ n.\n\nВыходные данные\n\nВходные данныеСкопировать2 21 01 11 1Выходные данныеСкопировать0Входные данныеСкопировать4 50 0 1 0 10 1 1 1 01 0 1 0 11 1 1 1 12 3Выходные данныеСкопировать2\n\nВходные данныеСкопировать2 21 01 11 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 50 0 1 0 10 1 1 1 01 0 1 0 11 1 1 1 12 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере левая верхняя клетка участка это (1,1), а правая нижняя — (3, 2).",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int val = inf.readInt(0, 1, \"grid[i][j]\");\n            if (j + 1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n\n    int a = inf.readInt(1, 50, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 50, \"b\");\n    inf.readEoln();\n\n    ensuref(\n        (a <= n && b <= m) || (a <= m && b <= n),\n        \"It must be possible to fit the land lot into the garden: (a <= n && b <= m) || (a <= m && b <= n)\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int val = inf.readInt(0, 1, \"grid[i][j]\");\n            if (j + 1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n\n    int a = inf.readInt(1, 50, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 50, \"b\");\n    inf.readEoln();\n\n    ensuref(\n        (a <= n && b <= m) || (a <= m && b <= n),\n        \"It must be possible to fit the land lot into the garden: (a <= n && b <= m) || (a <= m && b <= n)\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int val = inf.readInt(0, 1, \"grid[i][j]\");\n            if (j + 1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n\n    int a = inf.readInt(1, 50, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 50, \"b\");\n    inf.readEoln();\n\n    ensuref(\n        (a <= n && b <= m) || (a <= m && b <= n),\n        \"It must be possible to fit the land lot into the garden: (a <= n && b <= m) || (a <= m && b <= n)\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int a = opt<int>(\"a\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure the constraints are satisfied\n    ensure(1 <= n && n <= 50);\n    ensure(1 <= m && m <= 50);\n    ensure(1 <= a && a <= 50);\n    ensure(1 <= b && b <= 50);\n    ensure((a <= n && b <= m) || (a <= m && b <= n));\n\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    if (type == \"random\") {\n        // Generate a random grid with given tree density\n        double tree_prob = opt<double>(\"prob\", 0.5); // default density is 0.5\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (rnd.next(0.0, 1.0) < tree_prob) ? 1 : 0;\n            }\n        }\n    } else if (type == \"empty\") {\n        // Grid with all zeros (no trees)\n        // Already initialized as zeros\n    } else if (type == \"full\") {\n        // Grid with all ones (all trees)\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern of trees\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (i + j) % 2;\n            }\n        }\n    } else if (type == \"path\") {\n        // All trees except a rectangle area where the house can fit\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n        int max_row = (a <= n) ? n - a : n - b;\n        int max_col = (b <= m) ? m - b : m - a;\n        int start_row = rnd.next(0, max_row);\n        int start_col = rnd.next(0, max_col);\n        int house_n = (a <= n && b <= m) ? a : b;\n        int house_m = (a <= n && b <= m) ? b : a;\n        for (int i = start_row; i < start_row + house_n && i < n; i++) {\n            for (int j = start_col; j < start_col + house_m && j < m; j++) {\n                grid[i][j] = 0;\n            }\n        }\n    } else if (type == \"rotate_only\") {\n        // Grid is empty, but house fits only when rotated\n        // Already initialized as zeros\n    } else {\n        // Default to random if type is unknown\n        double tree_prob = 0.5;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (rnd.next(0.0, 1.0) < tree_prob) ? 1 : 0;\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int a = opt<int>(\"a\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure the constraints are satisfied\n    ensure(1 <= n && n <= 50);\n    ensure(1 <= m && m <= 50);\n    ensure(1 <= a && a <= 50);\n    ensure(1 <= b && b <= 50);\n    ensure((a <= n && b <= m) || (a <= m && b <= n));\n\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    if (type == \"random\") {\n        // Generate a random grid with given tree density\n        double tree_prob = opt<double>(\"prob\", 0.5); // default density is 0.5\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (rnd.next(0.0, 1.0) < tree_prob) ? 1 : 0;\n            }\n        }\n    } else if (type == \"empty\") {\n        // Grid with all zeros (no trees)\n        // Already initialized as zeros\n    } else if (type == \"full\") {\n        // Grid with all ones (all trees)\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern of trees\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (i + j) % 2;\n            }\n        }\n    } else if (type == \"path\") {\n        // All trees except a rectangle area where the house can fit\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n        int max_row = (a <= n) ? n - a : n - b;\n        int max_col = (b <= m) ? m - b : m - a;\n        int start_row = rnd.next(0, max_row);\n        int start_col = rnd.next(0, max_col);\n        int house_n = (a <= n && b <= m) ? a : b;\n        int house_m = (a <= n && b <= m) ? b : a;\n        for (int i = start_row; i < start_row + house_n && i < n; i++) {\n            for (int j = start_col; j < start_col + house_m && j < m; j++) {\n                grid[i][j] = 0;\n            }\n        }\n    } else if (type == \"rotate_only\") {\n        // Grid is empty, but house fits only when rotated\n        // Already initialized as zeros\n    } else {\n        // Default to random if type is unknown\n        double tree_prob = 0.5;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (rnd.next(0.0, 1.0) < tree_prob) ? 1 : 0;\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Smallest possible input - empty grid\n./gen -n 1 -m 1 -a 1 -b 1 -type empty\n\n# Smallest possible input - full grid\n./gen -n 1 -m 1 -a 1 -b 1 -type full\n\n# Largest possible input - empty grid\n./gen -n 50 -m 50 -a 50 -b 50 -type empty\n\n# Largest possible input - full grid\n./gen -n 50 -m 50 -a 50 -b 50 -type full\n\n# Random grid with medium density of trees\n./gen -n 10 -m 10 -a 5 -b 5 -type random -prob 0.5\n\n# Random grid with low density of trees\n./gen -n 20 -m 20 -a 10 -b 10 -type random -prob 0.1\n\n# Random grid with high density of trees\n./gen -n 20 -m 20 -a 10 -b 10 -type random -prob 0.9\n\n# Checkerboard pattern\n./gen -n 10 -m 10 -a 5 -b 5 -type checkerboard\n\n# Rotate_only case - house fits only when rotated (empty grid)\n./gen -n 5 -m 3 -a 3 -b 5 -type empty\n\n# Rotate_only case - house fits only when rotated (full grid)\n./gen -n 5 -m 3 -a 3 -b 5 -type full\n\n# Edge case where one side of the house is 1 (vertical strip)\n./gen -n 10 -m 10 -a 1 -b 5 -type random -prob 0.5\n\n# Edge case where one side of the house is 1 (horizontal strip)\n./gen -n 10 -m 10 -a 5 -b 1 -type random -prob 0.5\n\n# Edge case where garden has 1 row\n./gen -n 1 -m 50 -a 1 -b 25 -type random -prob 0.5\n\n# Edge case where garden has 1 column\n./gen -n 50 -m 1 -a 25 -b 1 -type random -prob 0.5\n\n# Edge case where only one orientation works\n./gen -n 10 -m 20 -a 15 -b 8 -type random -prob 0.5\n\n# Empty grid with non-trivial house size\n./gen -n 30 -m 30 -a 10 -b 15 -type empty\n\n# Full grid with non-trivial house size\n./gen -n 30 -m 30 -a 10 -b 15 -type full\n\n# Random large grid with medium density\n./gen -n 50 -m 50 -a 25 -b 25 -type random -prob 0.5\n\n# Random small grid with medium density\n./gen -n 5 -m 5 -a 2 -b 2 -type random -prob 0.5\n\n# Checkerboard pattern with odd dimensions\n./gen -n 7 -m 7 -a 3 -b 3 -type checkerboard\n\n# Random grid with very low tree density\n./gen -n 50 -m 50 -a 25 -b 25 -type random -prob 0.05\n\n# Random grid with very high tree density\n./gen -n 50 -m 50 -a 25 -b 25 -type random -prob 0.95\n\n# Path type - minimal chopping required (house fits in a clear area)\n./gen -n 20 -m 20 -a 10 -b 10 -type path\n\n# Path type with rotate_only - house fits only when rotated\n./gen -n 20 -m 10 -a 15 -b 5 -type path\n\n# Edge case where house size equals garden size (empty grid)\n./gen -n 7 -m 7 -a 7 -b 7 -type empty\n\n# Edge case where house size equals garden size (full grid)\n./gen -n 7 -m 7 -a 7 -b 7 -type full\n\n# Random grid with moderate size and tree density\n./gen -n 25 -m 25 -a 10 -b 15 -type random -prob 0.6\n\n# Checkerboard pattern with maximum size\n./gen -n 50 -m 50 -a 20 -b 30 -type checkerboard\n\n# Random grid where house must chop some trees\n./gen -n 15 -m 15 -a 5 -b 5 -type random -prob 0.7\n\n# Random grid with minimal size where house must chop all trees\n./gen -n 3 -m 3 -a 2 -b 2 -type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:06.263644",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "48/C",
      "title": "C. The Race",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 1000) which represents the number of petrol stations where Vanya has stopped. The next line has n space-separated integers which represent the numbers of the stations. The numbers are positive and do not exceed 106, they are given in the increasing order. No two numbers in the succession match. It is guaranteed that there exists at least one number α ≥ 10, to which such a succession of stops corresponds.",
      "output_spec": "OutputPrint in the first line \"unique\" (without quotes) if the answer can be determined uniquely. In the second line print the number of the station where the next stop will take place. If the answer is not unique, print in the first line \"not unique\".",
      "sample_tests": "ExamplesInputCopy31 2 4OutputCopyunique5InputCopy21 2OutputCopynot unique",
      "description": "C. The Race\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 1000) which represents the number of petrol stations where Vanya has stopped. The next line has n space-separated integers which represent the numbers of the stations. The numbers are positive and do not exceed 106, they are given in the increasing order. No two numbers in the succession match. It is guaranteed that there exists at least one number α ≥ 10, to which such a succession of stops corresponds.\n\nOutputPrint in the first line \"unique\" (without quotes) if the answer can be determined uniquely. In the second line print the number of the station where the next stop will take place. If the answer is not unique, print in the first line \"not unique\".\n\nInputCopy31 2 4OutputCopyunique5InputCopy21 2OutputCopynot unique\n\nInputCopy31 2 4\n\nOutputCopyunique5\n\nInputCopy21 2\n\nOutputCopynot unique\n\nNoteIn the second example the answer is not unique. For example, if α = 10, we'll have such a sequence as 1, 2, 3, and if α = 14, the sequence will be 1, 2, 4.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; i++) {\n        ensuref(s[i] < s[i + 1], \"Sequence s must be strictly increasing, but s[%d]=%d >= s[%d]=%d\", i, s[i], i+1, s[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; i++) {\n        ensuref(s[i] < s[i + 1], \"Sequence s must be strictly increasing, but s[%d]=%d >= s[%d]=%d\", i, s[i], i+1, s[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; i++) {\n        ensuref(s[i] < s[i + 1], \"Sequence s must be strictly increasing, but s[%d]=%d >= s[%d]=%d\", i, s[i], i+1, s[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generateStops(double alpha, int n, int maxStation) {\n    vector<int> stops;\n    double petrol = alpha; // Initial petrol\n    int station = 0;\n    while ((int)stops.size() < n && station < maxStation) {\n        // Simulate reaching next station\n        petrol -= 10; // Consume petrol to reach station\n        station++;\n        if (petrol + 1e-8 < 10) {\n            // Need to refuel\n            stops.push_back(station);\n            petrol += alpha;\n        }\n        // Else, do not stop\n    }\n    return stops;\n}\n\nvector<int> generateNotUnique(int n, int maxStation) {\n    // Generate a sequence where answer is not unique\n    // For example, stops at stations 1, 2, ..., n\n    vector<int> stops;\n    for (int i = 1; i <= n; ++i) {\n        stops.push_back(i);\n    }\n    return stops;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string t = opt<string>(\"t\", \"unique\");\n\n    int maxStation = 1000000; // As per constraints\n\n    vector<int> stops;\n\n    if (t == \"unique\") {\n        // Generate a test case where the answer is unique\n        // Pick a random alpha ≥ 10\n        double alpha = rnd.next(10.0, 1e6);\n        stops = generateStops(alpha, n, maxStation);\n    } else if (t == \"not_unique\") {\n        // Generate a test case where the answer is not unique\n        // Generate a sequence that can be produced by multiple alpha\n        stops = generateNotUnique(n, maxStation);\n    } else {\n        // Default to random alpha\n        double alpha = rnd.next(10.0, 1e6);\n        stops = generateStops(alpha, n, maxStation);\n    }\n\n    // Ensure that the number of stops is as requested\n    if ((int)stops.size() != n) {\n        // If not enough stops were generated (this can happen if alpha is very large), try again\n        double alpha = rnd.next(10.0, 1e6);\n        stops = generateStops(alpha, n, maxStation);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the station numbers\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", stops[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generateStops(double alpha, int n, int maxStation) {\n    vector<int> stops;\n    double petrol = alpha; // Initial petrol\n    int station = 0;\n    while ((int)stops.size() < n && station < maxStation) {\n        // Simulate reaching next station\n        petrol -= 10; // Consume petrol to reach station\n        station++;\n        if (petrol + 1e-8 < 10) {\n            // Need to refuel\n            stops.push_back(station);\n            petrol += alpha;\n        }\n        // Else, do not stop\n    }\n    return stops;\n}\n\nvector<int> generateNotUnique(int n, int maxStation) {\n    // Generate a sequence where answer is not unique\n    // For example, stops at stations 1, 2, ..., n\n    vector<int> stops;\n    for (int i = 1; i <= n; ++i) {\n        stops.push_back(i);\n    }\n    return stops;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string t = opt<string>(\"t\", \"unique\");\n\n    int maxStation = 1000000; // As per constraints\n\n    vector<int> stops;\n\n    if (t == \"unique\") {\n        // Generate a test case where the answer is unique\n        // Pick a random alpha ≥ 10\n        double alpha = rnd.next(10.0, 1e6);\n        stops = generateStops(alpha, n, maxStation);\n    } else if (t == \"not_unique\") {\n        // Generate a test case where the answer is not unique\n        // Generate a sequence that can be produced by multiple alpha\n        stops = generateNotUnique(n, maxStation);\n    } else {\n        // Default to random alpha\n        double alpha = rnd.next(10.0, 1e6);\n        stops = generateStops(alpha, n, maxStation);\n    }\n\n    // Ensure that the number of stops is as requested\n    if ((int)stops.size() != n) {\n        // If not enough stops were generated (this can happen if alpha is very large), try again\n        double alpha = rnd.next(10.0, 1e6);\n        stops = generateStops(alpha, n, maxStation);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the station numbers\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", stops[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -t unique\n./gen -n 1 -t not_unique\n\n./gen -n 2 -t unique\n./gen -n 2 -t not_unique\n\n./gen -n 10 -t unique\n./gen -n 10 -t not_unique\n\n./gen -n 100 -t unique\n./gen -n 100 -t not_unique\n\n./gen -n 500 -t unique\n./gen -n 500 -t not_unique\n\n./gen -n 1000 -t unique\n./gen -n 1000 -t not_unique\n\n./gen -n 1000 -t unique\n./gen -n 1000 -t not_unique\n\n# Edge cases\n./gen -n 1 -t unique\n./gen -n 1 -t not_unique\n\n# Generate random cases without specifying type\n./gen -n 50\n./gen -n 200\n\n# Generate test cases with maximum station numbers\n./gen -n 1000 -t unique\n./gen -n 1000 -t not_unique\n\n# Generate multiple test cases to increase coverage\n./gen -n 30 -t unique\n./gen -n 30 -t not_unique\n\n./gen -n 500 -t unique\n./gen -n 500 -t not_unique\n\n./gen -n 1000 -t unique\n./gen -n 1000 -t not_unique\n\n# Vary the n to cover small and large sizes\n./gen -n 5 -t unique\n./gen -n 5 -t not_unique\n\n./gen -n 25 -t unique\n./gen -n 25 -t not_unique\n\n./gen -n 250 -t unique\n./gen -n 250 -t not_unique\n\n./gen -n 750 -t unique\n./gen -n 750 -t not_unique\n\n# Random cases with default type\n./gen -n 60\n./gen -n 300\n./gen -n 600\n\n# Additional edge cases with n = maximum allowed\n./gen -n 1000 -t unique\n./gen -n 1000 -t not_unique\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:08.261066",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "48/D",
      "title": "D. Перестановки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 second",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 105). Следующая строка содержит перемешанную последовательность из n целых чисел, разделенных одиночными пробелами. Числа в последовательности от 1 до 105.",
      "output_spec": "Выходные данныеЕсли данную последовательность можно разбить на несколько перестановок так, что каждый элемент последовательности принадлежит в точности одной перестановке, в первой строке выведите количество получившихся перестановок. Вторая строка должна содержать n чисел, соответствующих элементам заданной последовательности. Если i-й элемент относится к первой перестановке, то i-е число должно быть 1, если ко второй — то 2, и т.д. Порядок нумерации перестановок произволен. Если решений несколько, выведите любое. Если решения не существует, выведите в первой строке  - 1.",
      "sample_tests": "ПримерыВходные данныеСкопировать91 2 3 1 2 1 4 2 5Выходные данныеСкопировать33 1 2 1 2 2 2 3 2Входные данныеСкопировать44 3 2 1Выходные данныеСкопировать11 1 1 1 Входные данныеСкопировать41 2 2 3Выходные данныеСкопировать-1",
      "description": "D. Перестановки\n\nограничение по времени на тест1 second\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 105). Следующая строка содержит перемешанную последовательность из n целых чисел, разделенных одиночными пробелами. Числа в последовательности от 1 до 105.\n\nВходные данные\n\nВыходные данныеЕсли данную последовательность можно разбить на несколько перестановок так, что каждый элемент последовательности принадлежит в точности одной перестановке, в первой строке выведите количество получившихся перестановок. Вторая строка должна содержать n чисел, соответствующих элементам заданной последовательности. Если i-й элемент относится к первой перестановке, то i-е число должно быть 1, если ко второй — то 2, и т.д. Порядок нумерации перестановок произволен. Если решений несколько, выведите любое. Если решения не существует, выведите в первой строке  - 1.\n\nВыходные данные\n\nВходные данныеСкопировать91 2 3 1 2 1 4 2 5Выходные данныеСкопировать33 1 2 1 2 2 2 3 2Входные данныеСкопировать44 3 2 1Выходные данныеСкопировать11 1 1 1 Входные данныеСкопировать41 2 2 3Выходные данныеСкопировать-1\n\nВходные данныеСкопировать91 2 3 1 2 1 4 2 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать33 1 2 1 2 2 2 3 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать44 3 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11 1 1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41 2 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере последовательность разбивается на три перестановки: (2, 1), (3, 2, 1, 4, 5), (1, 2). Первая перестановка образована вторым и четвертым элементами последовательности, вторая — третьим, пятым, шестым, седьмым и девятым элементами, третья — первым и восьмым элементами. Ясно, что возможны и другие варианты разбиения.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n    // Check no leading or trailing spaces\n    if (!line.empty() && (line.front() == ' ' || line.back() == ' ')) {\n        quitf(_fail, \"Line starts or ends with a space\");\n    }\n\n    vector<string> tokens;\n    size_t pos = 0;\n    while (pos < line.size()) {\n        if (line[pos] == ' ') {\n            quitf(_fail, \"Multiple spaces detected at position %d\", (int)pos);\n        }\n        // Read digits\n        size_t start = pos;\n        while (pos < line.size() && isdigit(line[pos])) {\n            pos++;\n        }\n        if (start == pos) {\n            quitf(_fail, \"Expected a number at position %d\", (int)pos);\n        }\n        tokens.push_back(line.substr(start, pos - start));\n        if ((int)tokens.size() > n) {\n            quitf(_fail, \"More numbers than expected\");\n        }\n        // After number, expect either space or end of line\n        if (pos < line.size()) {\n            if (line[pos] != ' ') {\n                quitf(_fail, \"Expected a single space or end of line at position %d\", (int)pos);\n            }\n            pos++; // Skip the space\n            if (pos < line.size() && line[pos] == ' ') {\n                quitf(_fail, \"Multiple spaces detected at position %d\", (int)pos);\n            }\n        }\n    }\n\n    if ((int)tokens.size() != n) {\n        quitf(_fail, \"Expected %d numbers, found %d\", n, (int)tokens.size());\n    }\n\n    for (int i = 0; i < n; ++i) {\n        string num_str = tokens[i];\n        if (num_str.empty()) {\n            quitf(_fail, \"Empty token at position %d\", i+1);\n        }\n        if (num_str.length() > 6) {\n            quitf(_fail, \"Number too long at position %d\", i+1);\n        }\n        for (char c : num_str) {\n            if (!isdigit(c)) {\n                quitf(_fail, \"Non-digit character in number at position %d\", i+1);\n            }\n        }\n        if (num_str[0] == '0') {\n            quitf(_fail, \"Leading zero in number at position %d\", i+1);\n        }\n        int num = atoi(num_str.c_str());\n        if (num < 1 || num > 100000) {\n            quitf(_fail, \"Number out of range at position %d\", i+1);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n    // Check no leading or trailing spaces\n    if (!line.empty() && (line.front() == ' ' || line.back() == ' ')) {\n        quitf(_fail, \"Line starts or ends with a space\");\n    }\n\n    vector<string> tokens;\n    size_t pos = 0;\n    while (pos < line.size()) {\n        if (line[pos] == ' ') {\n            quitf(_fail, \"Multiple spaces detected at position %d\", (int)pos);\n        }\n        // Read digits\n        size_t start = pos;\n        while (pos < line.size() && isdigit(line[pos])) {\n            pos++;\n        }\n        if (start == pos) {\n            quitf(_fail, \"Expected a number at position %d\", (int)pos);\n        }\n        tokens.push_back(line.substr(start, pos - start));\n        if ((int)tokens.size() > n) {\n            quitf(_fail, \"More numbers than expected\");\n        }\n        // After number, expect either space or end of line\n        if (pos < line.size()) {\n            if (line[pos] != ' ') {\n                quitf(_fail, \"Expected a single space or end of line at position %d\", (int)pos);\n            }\n            pos++; // Skip the space\n            if (pos < line.size() && line[pos] == ' ') {\n                quitf(_fail, \"Multiple spaces detected at position %d\", (int)pos);\n            }\n        }\n    }\n\n    if ((int)tokens.size() != n) {\n        quitf(_fail, \"Expected %d numbers, found %d\", n, (int)tokens.size());\n    }\n\n    for (int i = 0; i < n; ++i) {\n        string num_str = tokens[i];\n        if (num_str.empty()) {\n            quitf(_fail, \"Empty token at position %d\", i+1);\n        }\n        if (num_str.length() > 6) {\n            quitf(_fail, \"Number too long at position %d\", i+1);\n        }\n        for (char c : num_str) {\n            if (!isdigit(c)) {\n                quitf(_fail, \"Non-digit character in number at position %d\", i+1);\n            }\n        }\n        if (num_str[0] == '0') {\n            quitf(_fail, \"Leading zero in number at position %d\", i+1);\n        }\n        int num = atoi(num_str.c_str());\n        if (num < 1 || num > 100000) {\n            quitf(_fail, \"Number out of range at position %d\", i+1);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n    // Check no leading or trailing spaces\n    if (!line.empty() && (line.front() == ' ' || line.back() == ' ')) {\n        quitf(_fail, \"Line starts or ends with a space\");\n    }\n\n    vector<string> tokens;\n    size_t pos = 0;\n    while (pos < line.size()) {\n        if (line[pos] == ' ') {\n            quitf(_fail, \"Multiple spaces detected at position %d\", (int)pos);\n        }\n        // Read digits\n        size_t start = pos;\n        while (pos < line.size() && isdigit(line[pos])) {\n            pos++;\n        }\n        if (start == pos) {\n            quitf(_fail, \"Expected a number at position %d\", (int)pos);\n        }\n        tokens.push_back(line.substr(start, pos - start));\n        if ((int)tokens.size() > n) {\n            quitf(_fail, \"More numbers than expected\");\n        }\n        // After number, expect either space or end of line\n        if (pos < line.size()) {\n            if (line[pos] != ' ') {\n                quitf(_fail, \"Expected a single space or end of line at position %d\", (int)pos);\n            }\n            pos++; // Skip the space\n            if (pos < line.size() && line[pos] == ' ') {\n                quitf(_fail, \"Multiple spaces detected at position %d\", (int)pos);\n            }\n        }\n    }\n\n    if ((int)tokens.size() != n) {\n        quitf(_fail, \"Expected %d numbers, found %d\", n, (int)tokens.size());\n    }\n\n    for (int i = 0; i < n; ++i) {\n        string num_str = tokens[i];\n        if (num_str.empty()) {\n            quitf(_fail, \"Empty token at position %d\", i+1);\n        }\n        if (num_str.length() > 6) {\n            quitf(_fail, \"Number too long at position %d\", i+1);\n        }\n        for (char c : num_str) {\n            if (!isdigit(c)) {\n                quitf(_fail, \"Non-digit character in number at position %d\", i+1);\n            }\n        }\n        if (num_str[0] == '0') {\n            quitf(_fail, \"Leading zero in number at position %d\", i+1);\n        }\n        int num = atoi(num_str.c_str());\n        if (num < 1 || num > 100000) {\n            quitf(_fail, \"Number out of range at position %d\", i+1);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Read n from the input file\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInt();\n    }\n\n    int k = ouf.readInt(); // Read the participant's k\n    if (k == -1) {\n        quitf(_ok, \"Participant outputs impossible\");\n    } else {\n        if (k < 1 || k > n)\n            quitf(_wa, \"Invalid number of permutations k = %d\", k);\n        vector<int> assn(n);\n        for (int i = 0; i < n; i++) {\n            assn[i] = ouf.readInt(1, k, format(\"assignment[%d]\", i + 1).c_str());\n        }\n\n        vector<vector<int>> perms(k); // permutations[0..k-1]\n        for (int i = 0; i < n; i++) {\n            perms[assn[i] - 1].push_back(a[i]); // Assign elements to permutations\n        }\n\n        for (int p = 0; p < k; p++) {\n            int len = perms[p].size();\n            vector<bool> mark(len + 1, false); // mark[1..len]\n            for (int x : perms[p]) {\n                if (x < 1 || x > len)\n                    quitf(_wa, \"Invalid number %d in permutation %d\", x, p + 1);\n                if (mark[x])\n                    quitf(_wa, \"Duplicate number %d in permutation %d\", x, p + 1);\n                mark[x] = true;\n            }\n            for (int i = 1; i <= len; i++) {\n                if (!mark[i])\n                    quitf(_wa, \"Number %d is missing in permutation %d\", i, p + 1);\n            }\n        }\n        quitf(_ok, \"Participant's output is correct\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> array;\n\n    if (type == \"random\") {\n        int k = rnd.next(1, min(n, 1000));\n        // Generate k random lengths summing to n\n        vector<int> lens(k, 1);\n        int remain = n - k;\n        for (int i = 0; i < remain; ++i) {\n            int idx = rnd.next(0, k - 1);\n            ++lens[idx];\n        }\n        // For each permutation\n        for (int i = 0; i < k; ++i) {\n            set<int> nums;\n            while ((int)nums.size() < lens[i]) {\n                nums.insert(rnd.next(1, 100000));\n            }\n            for (int num : nums) {\n                array.push_back(num);\n            }\n        }\n        shuffle(array.begin(), array.end());\n    } else if (type == \"single_permutation\") {\n        set<int> nums;\n        while ((int)nums.size() < n) {\n            nums.insert(rnd.next(1, 100000));\n        }\n        array.assign(nums.begin(), nums.end());\n        shuffle(array.begin(), array.end());\n    } else if (type == \"many_permutations\") {\n        // n permutations of size 1\n        for (int i = 0; i < n; ++i) {\n            array.push_back(rnd.next(1, 100000));\n        }\n        shuffle(array.begin(), array.end());\n    } else if (type == \"impossible\") {\n        if (n < 2) {\n            // Can't generate impossible case for n < 2\n            array.push_back(1);\n        } else {\n            int t = n / 2 + 1;\n            int x = rnd.next(1, 100000);\n            for (int i = 0; i < t; ++i)\n                array.push_back(x);\n            set<int> used;\n            used.insert(x);\n            while ((int)array.size() < n) {\n                int y = rnd.next(1, 100000);\n                if (!used.count(y)) {\n                    array.push_back(y);\n                    used.insert(y);\n                }\n            }\n            shuffle(array.begin(), array.end());\n        }\n    } else if (type == \"big\") {\n        for (int i = 0; i < n; ++i) {\n            array.push_back(rnd.next(1, 100000));\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            array.push_back(rnd.next(1, 100000));\n        }\n        shuffle(array.begin(), array.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", array[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> array;\n\n    if (type == \"random\") {\n        int k = rnd.next(1, min(n, 1000));\n        // Generate k random lengths summing to n\n        vector<int> lens(k, 1);\n        int remain = n - k;\n        for (int i = 0; i < remain; ++i) {\n            int idx = rnd.next(0, k - 1);\n            ++lens[idx];\n        }\n        // For each permutation\n        for (int i = 0; i < k; ++i) {\n            set<int> nums;\n            while ((int)nums.size() < lens[i]) {\n                nums.insert(rnd.next(1, 100000));\n            }\n            for (int num : nums) {\n                array.push_back(num);\n            }\n        }\n        shuffle(array.begin(), array.end());\n    } else if (type == \"single_permutation\") {\n        set<int> nums;\n        while ((int)nums.size() < n) {\n            nums.insert(rnd.next(1, 100000));\n        }\n        array.assign(nums.begin(), nums.end());\n        shuffle(array.begin(), array.end());\n    } else if (type == \"many_permutations\") {\n        // n permutations of size 1\n        for (int i = 0; i < n; ++i) {\n            array.push_back(rnd.next(1, 100000));\n        }\n        shuffle(array.begin(), array.end());\n    } else if (type == \"impossible\") {\n        if (n < 2) {\n            // Can't generate impossible case for n < 2\n            array.push_back(1);\n        } else {\n            int t = n / 2 + 1;\n            int x = rnd.next(1, 100000);\n            for (int i = 0; i < t; ++i)\n                array.push_back(x);\n            set<int> used;\n            used.insert(x);\n            while ((int)array.size() < n) {\n                int y = rnd.next(1, 100000);\n                if (!used.count(y)) {\n                    array.push_back(y);\n                    used.insert(y);\n                }\n            }\n            shuffle(array.begin(), array.end());\n        }\n    } else if (type == \"big\") {\n        for (int i = 0; i < n; ++i) {\n            array.push_back(rnd.next(1, 100000));\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            array.push_back(rnd.next(1, 100000));\n        }\n        shuffle(array.begin(), array.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", array[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type single_permutation\n./gen -n 10 -type many_permutations\n./gen -n 10 -type impossible\n\n./gen -n 100 -type random\n./gen -n 100 -type single_permutation\n./gen -n 100 -type impossible\n\n./gen -n 1000 -type random\n./gen -n 1000 -type many_permutations\n./gen -n 1000 -type impossible\n\n./gen -n 10000 -type random\n./gen -n 10000 -type single_permutation\n./gen -n 10000 -type impossible\n\n./gen -n 100000 -type random\n./gen -n 100000 -type many_permutations\n./gen -n 100000 -type impossible\n\n./gen -n 99999 -type random\n./gen -n 99999 -type impossible\n\n./gen -n 1 -type single_permutation\n\n./gen -n 2 -type impossible\n\n./gen -n 100000 -type big\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:10.383402",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "48/E",
      "title": "E. Иванушка-дурачок против Змея Горыныча",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке содержатся три целых числа h, t и R (0 ≤ h, t, R ≤ 200, 0 < h + t ≤ R) — изначальные количества голов и хвостов у Змея Горыныча и наибольшее суммарное количество голов и хвостов, при котором Змей Горыныч еще не переходит в наступление. В следующей строке содержится целое число n (1 ≤ n ≤ 200). Следующие n строк содержат пары неотрицательных целых чисел «hi ti» — количество голов и количество хвостов соответственно, которые вырастут, если Горынычу отрубить i голов (1 ≤ i ≤ n). В следующей строке содержится целое число m (1 ≤ m ≤ 200) и затем — описание поведения Горыныча при отрубании хвостов в формате, аналогичном описанному выше. Все числа во входном файле не превосходят 200.",
      "output_spec": "Выходные данныеВ первой строке выведите «Ivan» (без кавычек), если победит Иванушка, или «Zmey», если победит Змей Горыныч. Во второй строке выведите единственное целое число — количество ударов, нанесенных Иванушкой. Если битва будет продолжаться бесконечно, выведите в первой строке «Draw».",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 421 00 130 10 10 0Выходные данныеСкопироватьIvan2Входные данныеСкопировать2 2 410 111 0Выходные данныеСкопироватьDrawВходные данныеСкопировать2 2 511 113 0Выходные данныеСкопироватьZmey2",
      "description": "E. Иванушка-дурачок против Змея Горыныча\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержатся три целых числа h, t и R (0 ≤ h, t, R ≤ 200, 0 < h + t ≤ R) — изначальные количества голов и хвостов у Змея Горыныча и наибольшее суммарное количество голов и хвостов, при котором Змей Горыныч еще не переходит в наступление. В следующей строке содержится целое число n (1 ≤ n ≤ 200). Следующие n строк содержат пары неотрицательных целых чисел «hi ti» — количество голов и количество хвостов соответственно, которые вырастут, если Горынычу отрубить i голов (1 ≤ i ≤ n). В следующей строке содержится целое число m (1 ≤ m ≤ 200) и затем — описание поведения Горыныча при отрубании хвостов в формате, аналогичном описанному выше. Все числа во входном файле не превосходят 200.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите «Ivan» (без кавычек), если победит Иванушка, или «Zmey», если победит Змей Горыныч. Во второй строке выведите единственное целое число — количество ударов, нанесенных Иванушкой. Если битва будет продолжаться бесконечно, выведите в первой строке «Draw».\n\nВыходные данные\n\nВходные данныеСкопировать2 2 421 00 130 10 10 0Выходные данныеСкопироватьIvan2Входные данныеСкопировать2 2 410 111 0Выходные данныеСкопироватьDrawВходные данныеСкопировать2 2 511 113 0Выходные данныеСкопироватьZmey2\n\nВходные данныеСкопировать2 2 421 00 130 10 10 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьIvan2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 410 111 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьDraw\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 511 113 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьZmey2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(0, 200, \"h\");\n    inf.readSpace();\n    int t = inf.readInt(0, 200, \"t\");\n    inf.readSpace();\n    int R = inf.readInt(0, 200, \"R\");\n    inf.readEoln();\n\n    ensuref(h + t > 0, \"h + t must be greater than 0\");\n    ensuref(h + t <= R, \"h + t must be less than or equal to R\");\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int hi = inf.readInt(0, 200, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 200, \"ti\");\n        inf.readEoln();\n\n        ensuref(hi >= 0 && hi <= 200, \"hi must be between 0 and 200\");\n        ensuref(ti >= 0 && ti <= 200, \"ti must be between 0 and 200\");\n    }\n\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int hi = inf.readInt(0, 200, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 200, \"ti\");\n        inf.readEoln();\n\n        ensuref(hi >= 0 && hi <= 200, \"hi must be between 0 and 200\");\n        ensuref(ti >= 0 && ti <= 200, \"ti must be between 0 and 200\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(0, 200, \"h\");\n    inf.readSpace();\n    int t = inf.readInt(0, 200, \"t\");\n    inf.readSpace();\n    int R = inf.readInt(0, 200, \"R\");\n    inf.readEoln();\n\n    ensuref(h + t > 0, \"h + t must be greater than 0\");\n    ensuref(h + t <= R, \"h + t must be less than or equal to R\");\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int hi = inf.readInt(0, 200, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 200, \"ti\");\n        inf.readEoln();\n\n        ensuref(hi >= 0 && hi <= 200, \"hi must be between 0 and 200\");\n        ensuref(ti >= 0 && ti <= 200, \"ti must be between 0 and 200\");\n    }\n\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int hi = inf.readInt(0, 200, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 200, \"ti\");\n        inf.readEoln();\n\n        ensuref(hi >= 0 && hi <= 200, \"hi must be between 0 and 200\");\n        ensuref(ti >= 0 && ti <= 200, \"ti must be between 0 and 200\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(0, 200, \"h\");\n    inf.readSpace();\n    int t = inf.readInt(0, 200, \"t\");\n    inf.readSpace();\n    int R = inf.readInt(0, 200, \"R\");\n    inf.readEoln();\n\n    ensuref(h + t > 0, \"h + t must be greater than 0\");\n    ensuref(h + t <= R, \"h + t must be less than or equal to R\");\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int hi = inf.readInt(0, 200, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 200, \"ti\");\n        inf.readEoln();\n\n        ensuref(hi >= 0 && hi <= 200, \"hi must be between 0 and 200\");\n        ensuref(ti >= 0 && ti <= 200, \"ti must be between 0 and 200\");\n    }\n\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int hi = inf.readInt(0, 200, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 200, \"ti\");\n        inf.readEoln();\n\n        ensuref(hi >= 0 && hi <= 200, \"hi must be between 0 and 200\");\n        ensuref(ti >= 0 && ti <= 200, \"ti must be between 0 and 200\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int scale = opt<int>(\"scale\", 200); // default maximum value is 200\n    string type = opt<string>(\"type\", \"random\"); // can be \"IvanWins\", \"GorynychWins\", \"Draw\", or \"random\"\n\n    int h, t, R;\n    int n, m;\n\n    if (type == \"random\") {\n        // Generate random h, t, R within constraints\n        // h ≥ 1, t ≥ 0, h + t ≤ R ≤ 200\n\n        h = rnd.next(1, min(scale, 200));\n        t = rnd.next(0, min(scale - h, 200 - h));\n\n        int h_t_sum = h + t;\n        R = rnd.next(h_t_sum, min(scale, 200));\n        printf(\"%d %d %d\\n\", h, t, R);\n\n        // Generate random n and growth functions for heads\n        n = rnd.next(1, min(scale, 200));\n        printf(\"%d\\n\", n);\n        for (int i = 1; i <= n; ++i) {\n            int hi = rnd.next(0, min(scale, 200));\n            int ti = rnd.next(0, min(scale, 200));\n            printf(\"%d %d\\n\", hi, ti);\n        }\n\n        // Generate random m and growth functions for tails\n        m = rnd.next(1, min(scale, 200));\n        printf(\"%d\\n\", m);\n        for (int i = 1; i <= m; ++i) {\n            int hi = rnd.next(0, min(scale, 200));\n            int ti = rnd.next(0, min(scale, 200));\n            printf(\"%d %d\\n\", hi, ti);\n        }\n\n    } else if (type == \"IvanWins\") {\n        // Output a test case where Ivan can win\n        printf(\"2 2 4\\n\");\n        printf(\"2\\n\");\n        printf(\"1 0\\n\");\n        printf(\"0 1\\n\");\n        printf(\"3\\n\");\n        printf(\"0 1\\n\");\n        printf(\"0 1\\n\");\n        printf(\"0 0\\n\");\n    } else if (type == \"GorynychWins\") {\n        // Output a test case where Gorynych wins\n        printf(\"2 2 5\\n\");\n        printf(\"1\\n\");\n        printf(\"1 1\\n\");\n        printf(\"1\\n\");\n        printf(\"3 0\\n\");\n    } else if (type == \"Draw\") {\n        // Output a test case where the battle continues forever\n        printf(\"2 2 4\\n\");\n        printf(\"1\\n\");\n        printf(\"0 1\\n\");\n        printf(\"1\\n\");\n        printf(\"1 0\\n\");\n    } else {\n        // Default to random if unknown type\n        h = rnd.next(1, min(scale, 200));\n        t = rnd.next(0, min(scale - h, 200 - h));\n\n        int h_t_sum = h + t;\n        R = rnd.next(h_t_sum, min(scale, 200));\n        printf(\"%d %d %d\\n\", h, t, R);\n\n        n = rnd.next(1, min(scale, 200));\n        printf(\"%d\\n\", n);\n        for (int i = 1; i <= n; ++i) {\n            int hi = rnd.next(0, min(scale, 200));\n            int ti = rnd.next(0, min(scale, 200));\n            printf(\"%d %d\\n\", hi, ti);\n        }\n\n        m = rnd.next(1, min(scale, 200));\n        printf(\"%d\\n\", m);\n        for (int i = 1; i <= m; ++i) {\n            int hi = rnd.next(0, min(scale, 200));\n            int ti = rnd.next(0, min(scale, 200));\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int scale = opt<int>(\"scale\", 200); // default maximum value is 200\n    string type = opt<string>(\"type\", \"random\"); // can be \"IvanWins\", \"GorynychWins\", \"Draw\", or \"random\"\n\n    int h, t, R;\n    int n, m;\n\n    if (type == \"random\") {\n        // Generate random h, t, R within constraints\n        // h ≥ 1, t ≥ 0, h + t ≤ R ≤ 200\n\n        h = rnd.next(1, min(scale, 200));\n        t = rnd.next(0, min(scale - h, 200 - h));\n\n        int h_t_sum = h + t;\n        R = rnd.next(h_t_sum, min(scale, 200));\n        printf(\"%d %d %d\\n\", h, t, R);\n\n        // Generate random n and growth functions for heads\n        n = rnd.next(1, min(scale, 200));\n        printf(\"%d\\n\", n);\n        for (int i = 1; i <= n; ++i) {\n            int hi = rnd.next(0, min(scale, 200));\n            int ti = rnd.next(0, min(scale, 200));\n            printf(\"%d %d\\n\", hi, ti);\n        }\n\n        // Generate random m and growth functions for tails\n        m = rnd.next(1, min(scale, 200));\n        printf(\"%d\\n\", m);\n        for (int i = 1; i <= m; ++i) {\n            int hi = rnd.next(0, min(scale, 200));\n            int ti = rnd.next(0, min(scale, 200));\n            printf(\"%d %d\\n\", hi, ti);\n        }\n\n    } else if (type == \"IvanWins\") {\n        // Output a test case where Ivan can win\n        printf(\"2 2 4\\n\");\n        printf(\"2\\n\");\n        printf(\"1 0\\n\");\n        printf(\"0 1\\n\");\n        printf(\"3\\n\");\n        printf(\"0 1\\n\");\n        printf(\"0 1\\n\");\n        printf(\"0 0\\n\");\n    } else if (type == \"GorynychWins\") {\n        // Output a test case where Gorynych wins\n        printf(\"2 2 5\\n\");\n        printf(\"1\\n\");\n        printf(\"1 1\\n\");\n        printf(\"1\\n\");\n        printf(\"3 0\\n\");\n    } else if (type == \"Draw\") {\n        // Output a test case where the battle continues forever\n        printf(\"2 2 4\\n\");\n        printf(\"1\\n\");\n        printf(\"0 1\\n\");\n        printf(\"1\\n\");\n        printf(\"1 0\\n\");\n    } else {\n        // Default to random if unknown type\n        h = rnd.next(1, min(scale, 200));\n        t = rnd.next(0, min(scale - h, 200 - h));\n\n        int h_t_sum = h + t;\n        R = rnd.next(h_t_sum, min(scale, 200));\n        printf(\"%d %d %d\\n\", h, t, R);\n\n        n = rnd.next(1, min(scale, 200));\n        printf(\"%d\\n\", n);\n        for (int i = 1; i <= n; ++i) {\n            int hi = rnd.next(0, min(scale, 200));\n            int ti = rnd.next(0, min(scale, 200));\n            printf(\"%d %d\\n\", hi, ti);\n        }\n\n        m = rnd.next(1, min(scale, 200));\n        printf(\"%d\\n\", m);\n        for (int i = 1; i <= m; ++i) {\n            int hi = rnd.next(0, min(scale, 200));\n            int ti = rnd.next(0, min(scale, 200));\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Generate test cases where Ivan wins\n./gen -type IvanWins\n\n# Generate test cases where Gorynych wins\n./gen -type GorynychWins\n\n# Generate test cases where the battle is a draw\n./gen -type Draw\n\n# Generate random test cases with different scales\n./gen -scale 10 -type random\n./gen -scale 20 -type random\n./gen -scale 30 -type random\n./gen -scale 40 -type random\n./gen -scale 50 -type random\n./gen -scale 60 -type random\n./gen -scale 70 -type random\n./gen -scale 80 -type random\n./gen -scale 90 -type random\n./gen -scale 100 -type random\n./gen -scale 110 -type random\n./gen -scale 120 -type random\n./gen -scale 130 -type random\n./gen -scale 140 -type random\n./gen -scale 150 -type random\n./gen -scale 160 -type random\n./gen -scale 170 -type random\n./gen -scale 180 -type random\n./gen -scale 190 -type random\n./gen -scale 200 -type random\n\n# Generate multiple random test cases at maximum scale\n./gen -scale 200 -type random\n./gen -scale 200 -type random\n./gen -scale 200 -type random\n./gen -scale 200 -type random\n./gen -scale 200 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:12.169122",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "48/F",
      "title": "F. Snow sellers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test10 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, m and W (1 ≤ n ≤ 100, 1 ≤ m ≤ 500000, 1 ≤ W ≤ 109) which represent the number of days, the number of companies and the amount of snow that needs to be purchased on every one of the n days. The second line contains m integers wi. The third line contains m integers ci. The fourth line contains m integers ai. All the numbers are strictly positive and do not exceed 109. For all the i the inequation ci - (n - 1)ai > 0 holds true.",
      "output_spec": "OutputPrint a single number — the answer to the given problem. Print the answer in the format with the decimal point (even if the answer is integer, it must contain the decimal point), without \"e\" and without leading zeroes. The answer should differ with the right one by no more than 10 - 9.",
      "sample_tests": "ExamplesInputCopy2 3 104 4 45 5 81 2 5OutputCopy22.000000000000000InputCopy100 2 1000000000999999998 9999999991000000000 10000000001 1OutputCopy99999995149.999995249999991",
      "description": "F. Snow sellers\n\ntime limit per test10 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m and W (1 ≤ n ≤ 100, 1 ≤ m ≤ 500000, 1 ≤ W ≤ 109) which represent the number of days, the number of companies and the amount of snow that needs to be purchased on every one of the n days. The second line contains m integers wi. The third line contains m integers ci. The fourth line contains m integers ai. All the numbers are strictly positive and do not exceed 109. For all the i the inequation ci - (n - 1)ai > 0 holds true.\n\nOutputPrint a single number — the answer to the given problem. Print the answer in the format with the decimal point (even if the answer is integer, it must contain the decimal point), without \"e\" and without leading zeroes. The answer should differ with the right one by no more than 10 - 9.\n\nInputCopy2 3 104 4 45 5 81 2 5OutputCopy22.000000000000000InputCopy100 2 1000000000999999998 9999999991000000000 10000000001 1OutputCopy99999995149.999995249999991\n\nInputCopy2 3 104 4 45 5 81 2 5\n\nOutputCopy22.000000000000000\n\nInputCopy100 2 1000000000999999998 9999999991000000000 10000000001 1\n\nOutputCopy99999995149.999995249999991",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readSpace();\n    int W = inf.readInt(1, 1000000000, \"W\");\n    inf.readEoln();\n\n    vector<int> wi = inf.readInts(m, 1, 1000000000, \"wi\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(m, 1, 1000000000, \"ci\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(m, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Check that ci - (n - 1) * ai > 0 for each company\n    for (int i = 0; i < m; ++i) {\n        long long ci_minus_ai = (long long)ci[i] - (long long)(n - 1) * ai[i];\n        ensuref(ci_minus_ai > 0, \n            \"Constraint ci[%d] - (n-1)*ai[%d] > 0 failed. Got ci[%d]=%d, ai[%d]=%d, ci[%d] - (n-1)*ai[%d]=%lld\", \n            i+1, i+1, i+1, ci[i], i+1, ai[i], i+1, i+1, ci_minus_ai);\n    }\n\n    // Check that total snow production per day is at least W\n    long long total_wi = 0;\n    for (int i = 0; i < m; ++i) {\n        total_wi += wi[i];\n    }\n    ensuref(total_wi >= W, \n        \"Total available snow per day (%lld) is less than required amount W (%d)\", \n        total_wi, W);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readSpace();\n    int W = inf.readInt(1, 1000000000, \"W\");\n    inf.readEoln();\n\n    vector<int> wi = inf.readInts(m, 1, 1000000000, \"wi\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(m, 1, 1000000000, \"ci\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(m, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Check that ci - (n - 1) * ai > 0 for each company\n    for (int i = 0; i < m; ++i) {\n        long long ci_minus_ai = (long long)ci[i] - (long long)(n - 1) * ai[i];\n        ensuref(ci_minus_ai > 0, \n            \"Constraint ci[%d] - (n-1)*ai[%d] > 0 failed. Got ci[%d]=%d, ai[%d]=%d, ci[%d] - (n-1)*ai[%d]=%lld\", \n            i+1, i+1, i+1, ci[i], i+1, ai[i], i+1, i+1, ci_minus_ai);\n    }\n\n    // Check that total snow production per day is at least W\n    long long total_wi = 0;\n    for (int i = 0; i < m; ++i) {\n        total_wi += wi[i];\n    }\n    ensuref(total_wi >= W, \n        \"Total available snow per day (%lld) is less than required amount W (%d)\", \n        total_wi, W);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readSpace();\n    int W = inf.readInt(1, 1000000000, \"W\");\n    inf.readEoln();\n\n    vector<int> wi = inf.readInts(m, 1, 1000000000, \"wi\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(m, 1, 1000000000, \"ci\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(m, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Check that ci - (n - 1) * ai > 0 for each company\n    for (int i = 0; i < m; ++i) {\n        long long ci_minus_ai = (long long)ci[i] - (long long)(n - 1) * ai[i];\n        ensuref(ci_minus_ai > 0, \n            \"Constraint ci[%d] - (n-1)*ai[%d] > 0 failed. Got ci[%d]=%d, ai[%d]=%d, ci[%d] - (n-1)*ai[%d]=%lld\", \n            i+1, i+1, i+1, ci[i], i+1, ai[i], i+1, i+1, ci_minus_ai);\n    }\n\n    // Check that total snow production per day is at least W\n    long long total_wi = 0;\n    for (int i = 0; i < m; ++i) {\n        total_wi += wi[i];\n    }\n    ensuref(total_wi >= W, \n        \"Total available snow per day (%lld) is less than required amount W (%d)\", \n        total_wi, W);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long W = opt<long long>(\"W\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long MAX_VAL = 1000000000LL;\n\n    vector<long long> wi(m);\n    vector<long long> ci(m);\n    vector<long long> ai(m);\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        W = 1;\n        wi[0] = 1;\n        ci[0] = 1;\n        ai[0] = 1;\n    } else if (type == \"maximal\") {\n        n = 100;\n        m = 500000;\n        W = MAX_VAL;\n        wi.assign(m, MAX_VAL);\n        ci.assign(m, MAX_VAL);\n        ai.assign(m, 1);\n    } else if (type == \"edge_ci\") {\n        // Generate ci - (n - 1) * ai == 1\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1LL, MAX_VAL / (n - 1 + 1));\n            ci[i] = ai[i] * (n - 1) + 1;\n            if (ci[i] > MAX_VAL) ci[i] = MAX_VAL;\n            wi[i] = rnd.next(1LL, MAX_VAL);\n        }\n    } else if (type == \"just_enough_wi\") {\n        // Total wi just enough to cover W\n        wi.assign(m, W / m);\n        for (int i = 0; i < m; ++i)\n            if (i < (W % m))\n                wi[i]++;\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1LL, MAX_VAL / n);\n            long long min_ci = ai[i] * (n - 1) + 1;\n            if (min_ci > MAX_VAL) min_ci = MAX_VAL;\n            ci[i] = rnd.next(min_ci, MAX_VAL);\n        }\n    } else if (type == \"large_W\") {\n        W = MAX_VAL;\n        for (int i = 0; i < m; ++i) {\n            wi[i] = W;\n            ai[i] = rnd.next(1LL, MAX_VAL / n);\n            long long min_ci = ai[i] * (n - 1) + 1;\n            if (min_ci > MAX_VAL) min_ci = MAX_VAL;\n            ci[i] = rnd.next(min_ci, MAX_VAL);\n        }\n    } else { // Random case\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1LL, MAX_VAL / n);\n            long long min_ci = ai[i] * (n - 1) + 1;\n            if (min_ci > MAX_VAL) min_ci = MAX_VAL;\n            ci[i] = rnd.next(min_ci, MAX_VAL);\n            wi[i] = rnd.next(1LL, MAX_VAL);\n        }\n    }\n\n    // Ensure total available snow is enough\n    long long total_wi = 0;\n    for (int i = 0; i < m; ++i)\n        total_wi += wi[i];\n    if (total_wi < W)\n        wi[0] += W - total_wi; // Adjust to ensure enough snow\n\n    printf(\"%d %d %lld\\n\", n, m, W);\n    for (int i = 0; i < m; ++i)\n        printf(\"%lld%c\", wi[i], i + 1 == m ? '\\n' : ' ');\n    for (int i = 0; i < m; ++i)\n        printf(\"%lld%c\", ci[i], i + 1 == m ? '\\n' : ' ');\n    for (int i = 0; i < m; ++i)\n        printf(\"%lld%c\", ai[i], i + 1 == m ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long W = opt<long long>(\"W\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long MAX_VAL = 1000000000LL;\n\n    vector<long long> wi(m);\n    vector<long long> ci(m);\n    vector<long long> ai(m);\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        W = 1;\n        wi[0] = 1;\n        ci[0] = 1;\n        ai[0] = 1;\n    } else if (type == \"maximal\") {\n        n = 100;\n        m = 500000;\n        W = MAX_VAL;\n        wi.assign(m, MAX_VAL);\n        ci.assign(m, MAX_VAL);\n        ai.assign(m, 1);\n    } else if (type == \"edge_ci\") {\n        // Generate ci - (n - 1) * ai == 1\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1LL, MAX_VAL / (n - 1 + 1));\n            ci[i] = ai[i] * (n - 1) + 1;\n            if (ci[i] > MAX_VAL) ci[i] = MAX_VAL;\n            wi[i] = rnd.next(1LL, MAX_VAL);\n        }\n    } else if (type == \"just_enough_wi\") {\n        // Total wi just enough to cover W\n        wi.assign(m, W / m);\n        for (int i = 0; i < m; ++i)\n            if (i < (W % m))\n                wi[i]++;\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1LL, MAX_VAL / n);\n            long long min_ci = ai[i] * (n - 1) + 1;\n            if (min_ci > MAX_VAL) min_ci = MAX_VAL;\n            ci[i] = rnd.next(min_ci, MAX_VAL);\n        }\n    } else if (type == \"large_W\") {\n        W = MAX_VAL;\n        for (int i = 0; i < m; ++i) {\n            wi[i] = W;\n            ai[i] = rnd.next(1LL, MAX_VAL / n);\n            long long min_ci = ai[i] * (n - 1) + 1;\n            if (min_ci > MAX_VAL) min_ci = MAX_VAL;\n            ci[i] = rnd.next(min_ci, MAX_VAL);\n        }\n    } else { // Random case\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1LL, MAX_VAL / n);\n            long long min_ci = ai[i] * (n - 1) + 1;\n            if (min_ci > MAX_VAL) min_ci = MAX_VAL;\n            ci[i] = rnd.next(min_ci, MAX_VAL);\n            wi[i] = rnd.next(1LL, MAX_VAL);\n        }\n    }\n\n    // Ensure total available snow is enough\n    long long total_wi = 0;\n    for (int i = 0; i < m; ++i)\n        total_wi += wi[i];\n    if (total_wi < W)\n        wi[0] += W - total_wi; // Adjust to ensure enough snow\n\n    printf(\"%d %d %lld\\n\", n, m, W);\n    for (int i = 0; i < m; ++i)\n        printf(\"%lld%c\", wi[i], i + 1 == m ? '\\n' : ' ');\n    for (int i = 0; i < m; ++i)\n        printf(\"%lld%c\", ci[i], i + 1 == m ? '\\n' : ' ');\n    for (int i = 0; i < m; ++i)\n        printf(\"%lld%c\", ai[i], i + 1 == m ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal test case\n./gen -n 1 -m 1 -W 1 -type minimal\n\n# Maximal test case\n./gen -n 100 -m 500000 -W 1000000000 -type maximal\n\n# Random small test cases\n./gen -n 10 -m 10 -W 1000 -type random\n./gen -n 50 -m 100 -W 50000 -type random\n\n# Random medium test cases\n./gen -n 70 -m 20000 -W 1000000 -type random\n./gen -n 100 -m 100000 -W 500000000 -type random\n\n# Edge cases where ci - (n - 1) * ai == 1\n./gen -n 100 -m 500 -W 1000000 -type edge_ci\n./gen -n 100 -m 500000 -W 1000000000 -type edge_ci\n\n# Test cases where total wi is just enough to cover W\n./gen -n 50 -m 50000 -W 1000000 -type just_enough_wi\n./gen -n 100 -m 500000 -W 999999999 -type just_enough_wi\n\n# Test cases with large W\n./gen -n 100 -m 1000 -W 1000000000 -type large_W\n\n# Random test cases with various n and m\n./gen -n 1 -m 500000 -W 100000 -type random\n./gen -n 100 -m 1 -W 1000 -type random\n./gen -n 20 -m 100000 -W 200000000 -type random\n./gen -n 75 -m 250000 -W 500000000 -type random\n\n# Test cases with ai set to 1\n./gen -n 100 -m 500000 -W 1000000000 -type random\n\n# Test cases with ai set to MAX_VAL / n\n./gen -n 100 -m 500000 -W 1000000000 -type random\n\n# Random test cases focusing on edge values of ai, ci, wi\n./gen -n 100 -m 500000 -W 1000000000 -type random\n\n# Additional random test cases\n./gen -n 30 -m 300000 -W 300000000 -type random\n./gen -n 60 -m 100000 -W 600000000 -type random\n./gen -n 80 -m 400000 -W 800000000 -type random\n./gen -n 50 -m 500000 -W 500000000 -type random\n\n# Random test case with minimal W\n./gen -n 100 -m 500000 -W 1 -type random\n\n# Random test case with maximal W\n./gen -n 100 -m 500000 -W 1000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:14.259954",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "48/G",
      "title": "G. Galaxy Union",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (3 ≤ n ≤ 200000) which represents the number of planets in the Galaxy and the number of communication channels equal to it. The next n lines contain three integers each ai, bi and ti (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ti ≤ 103) that represent the numbers of planet joined by a communication channel and its \"dial duration\". There can be no more than one communication channel between a pair of planets.",
      "output_spec": "OutputIn the first line output n integers — the durations of the supposed negotiations for each president. Separate the numbers by spaces.",
      "sample_tests": "ExamplesInputCopy31 2 32 3 21 3 1OutputCopy4 5 3InputCopy31 2 32 3 21 3 5OutputCopy8 5 7InputCopy41 2 32 3 23 4 14 1 4OutputCopy12 8 8 8",
      "description": "G. Galaxy Union\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (3 ≤ n ≤ 200000) which represents the number of planets in the Galaxy and the number of communication channels equal to it. The next n lines contain three integers each ai, bi and ti (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ti ≤ 103) that represent the numbers of planet joined by a communication channel and its \"dial duration\". There can be no more than one communication channel between a pair of planets.\n\nOutputIn the first line output n integers — the durations of the supposed negotiations for each president. Separate the numbers by spaces.\n\nInputCopy31 2 32 3 21 3 1OutputCopy4 5 3InputCopy31 2 32 3 21 3 5OutputCopy8 5 7InputCopy41 2 32 3 23 4 14 1 4OutputCopy12 8 8 8\n\nInputCopy31 2 32 3 21 3 1\n\nOutputCopy4 5 3\n\nInputCopy31 2 32 3 21 3 5\n\nOutputCopy8 5 7\n\nInputCopy41 2 32 3 23 4 14 1 4\n\nOutputCopy12 8 8 8",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nint n;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(3, 200000, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1);\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000, \"ti\");\n        inf.readEoln();\n\n        int u = ai;\n        int v = bi;\n\n        int min_uv = min(u, v);\n        int max_uv = max(u, v);\n\n        pair<int,int> edge = make_pair(min_uv, max_uv);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between %d and %d\", u, v);\n        edgeSet.insert(edge);\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check connectivity\n    visited.resize(n + 1);\n    fill(visited.begin(), visited.end(), false);\n\n    dfs(1); // Assume node numbering starts from 1\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nint n;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(3, 200000, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1);\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000, \"ti\");\n        inf.readEoln();\n\n        int u = ai;\n        int v = bi;\n\n        int min_uv = min(u, v);\n        int max_uv = max(u, v);\n\n        pair<int,int> edge = make_pair(min_uv, max_uv);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between %d and %d\", u, v);\n        edgeSet.insert(edge);\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check connectivity\n    visited.resize(n + 1);\n    fill(visited.begin(), visited.end(), false);\n\n    dfs(1); // Assume node numbering starts from 1\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nint n;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(3, 200000, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1);\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000, \"ti\");\n        inf.readEoln();\n\n        int u = ai;\n        int v = bi;\n\n        int min_uv = min(u, v);\n        int max_uv = max(u, v);\n\n        pair<int,int> edge = make_pair(min_uv, max_uv);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between %d and %d\", u, v);\n        edgeSet.insert(edge);\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check connectivity\n    visited.resize(n + 1);\n    fill(visited.begin(), visited.end(), false);\n\n    dfs(1); // Assume node numbering starts from 1\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int weight = opt<int>(\"weight\", 0); // 0 means random weights\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        // Generate random tree\n        vector<int> parent(n);\n        for (int i = 1; i < n; ++i) {\n            parent[i] = rnd.next(0, i - 1);\n            edges.push_back({ parent[i], i });\n        }\n        // Add one extra random edge\n        set<pair<int, int>> edge_set;\n        for (auto e : edges) {\n            int u = e.first;\n            int v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n        while (true) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            break;\n        }\n    } else if (type == \"line\") {\n        // Connect nodes in a line\n        for (int i = 0; i < n - 1; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Add extra edge\n        edges.push_back({0, n - 1});\n    } else if (type == \"ring\") {\n        // Connect nodes in a ring\n        for (int i = 0; i < n; ++i) {\n            edges.push_back({i, (i + 1) % n});\n        }\n    } else if (type == \"star\") {\n        // Central node connected to all others\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n        // Add extra edge\n        edges.push_back({1, 2});\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Assign weights\n    vector<int> ti(edges.size());\n    if (weight == 0) {\n        for (size_t i = 0; i < ti.size(); ++i) {\n            ti[i] = rnd.next(1, 1000);\n        }\n    } else {\n        for (size_t i = 0; i < ti.size(); ++i) {\n            ti[i] = weight;\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int a = edges[i].first + 1; // +1 because node numbering starts from 1 in the problem\n        int b = edges[i].second + 1;\n        int t = ti[i];\n        printf(\"%d %d %d\\n\", a, b, t);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int weight = opt<int>(\"weight\", 0); // 0 means random weights\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        // Generate random tree\n        vector<int> parent(n);\n        for (int i = 1; i < n; ++i) {\n            parent[i] = rnd.next(0, i - 1);\n            edges.push_back({ parent[i], i });\n        }\n        // Add one extra random edge\n        set<pair<int, int>> edge_set;\n        for (auto e : edges) {\n            int u = e.first;\n            int v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n        while (true) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            break;\n        }\n    } else if (type == \"line\") {\n        // Connect nodes in a line\n        for (int i = 0; i < n - 1; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Add extra edge\n        edges.push_back({0, n - 1});\n    } else if (type == \"ring\") {\n        // Connect nodes in a ring\n        for (int i = 0; i < n; ++i) {\n            edges.push_back({i, (i + 1) % n});\n        }\n    } else if (type == \"star\") {\n        // Central node connected to all others\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n        // Add extra edge\n        edges.push_back({1, 2});\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Assign weights\n    vector<int> ti(edges.size());\n    if (weight == 0) {\n        for (size_t i = 0; i < ti.size(); ++i) {\n            ti[i] = rnd.next(1, 1000);\n        }\n    } else {\n        for (size_t i = 0; i < ti.size(); ++i) {\n            ti[i] = weight;\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int a = edges[i].first + 1; // +1 because node numbering starts from 1 in the problem\n        int b = edges[i].second + 1;\n        int t = ti[i];\n        printf(\"%d %d %d\\n\", a, b, t);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type line\n./gen -n 3 -type ring\n./gen -n 3 -type star\n\n./gen -n 10 -type random\n./gen -n 10 -type line\n./gen -n 10 -type ring\n./gen -n 10 -type star\n\n./gen -n 100 -type random\n./gen -n 100 -type line\n./gen -n 100 -type ring\n./gen -n 100 -type star\n\n./gen -n 1000 -type random\n./gen -n 1000 -type line\n./gen -n 1000 -type ring\n./gen -n 1000 -type star\n\n./gen -n 10000 -type random\n./gen -n 10000 -type line\n./gen -n 10000 -type ring\n./gen -n 10000 -type star\n\n./gen -n 200000 -type random\n./gen -n 200000 -type line\n./gen -n 200000 -type ring\n./gen -n 200000 -type star\n\n./gen -n 200000 -type random -weight 1\n./gen -n 200000 -type random -weight 500\n./gen -n 200000 -type random -weight 1000\n\n./gen -n 200000 -type line -weight 1\n./gen -n 200000 -type ring -weight 1\n./gen -n 200000 -type star -weight 1\n\n./gen -n 200000 -type random -weight 0\n\n./gen -n 4 -type random\n./gen -n 4 -type ring\n./gen -n 4 -type star\n./gen -n 4 -type line\n\n./gen -n 200000 -type random -weight 1\n./gen -n 200000 -type random -weight 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:16.498785",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "48/H",
      "title": "H. Black and White",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains given integers n and m (1 ≤ n, m ≤ 100) which represent the sizes of the rectangle that needs to be tiled. The next line contains non-negative numbers a, b and c, a + b + c = nm, c ≥ m.",
      "output_spec": "OutputPrint 2n lines containing 2m characters each — the tiling scheme. Every tile is represented by a square 2 × 2 in the following manner (the order corresponds to the order of the picture above):    If multiple solutions exist, output any.",
      "sample_tests": "ExamplesInputCopy2 20 0 4OutputCopy\\../#\\/#\\##/.\\/.InputCopy2 31 2 3OutputCopy###/\\###/..\\#/..../.....",
      "description": "H. Black and White\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains given integers n and m (1 ≤ n, m ≤ 100) which represent the sizes of the rectangle that needs to be tiled. The next line contains non-negative numbers a, b and c, a + b + c = nm, c ≥ m.\n\nOutputPrint 2n lines containing 2m characters each — the tiling scheme. Every tile is represented by a square 2 × 2 in the following manner (the order corresponds to the order of the picture above):    If multiple solutions exist, output any.\n\nInputCopy2 20 0 4OutputCopy\\../#\\/#\\##/.\\/.InputCopy2 31 2 3OutputCopy###/\\###/..\\#/..../.....\n\nInputCopy2 20 0 4\n\nOutputCopy\\../#\\/#\\##/.\\/.\n\nInputCopy2 31 2 3\n\nOutputCopy###/\\###/..\\#/..../.....",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int total_tiles = n * m;\n\n    int a = inf.readInt(0, total_tiles, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, total_tiles, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, total_tiles, \"c\");\n    inf.readEoln();\n\n    ensuref(a + b + c == total_tiles, \"The sum a + b + c must be equal to n * m\");\n    ensuref(c >= m, \"c must be at least m\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int total_tiles = n * m;\n\n    int a = inf.readInt(0, total_tiles, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, total_tiles, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, total_tiles, \"c\");\n    inf.readEoln();\n\n    ensuref(a + b + c == total_tiles, \"The sum a + b + c must be equal to n * m\");\n    ensuref(c >= m, \"c must be at least m\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int total_tiles = n * m;\n\n    int a = inf.readInt(0, total_tiles, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, total_tiles, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, total_tiles, \"c\");\n    inf.readEoln();\n\n    ensuref(a + b + c == total_tiles, \"The sum a + b + c must be equal to n * m\");\n    ensuref(c >= m, \"c must be at least m\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n, m, a, b, c from the input file\n    int n = inf.readInt();\n    int m = inf.readInt();\n    int a = inf.readInt();\n    int b = inf.readInt();\n    int c = inf.readInt();\n\n    // Read the contestant's output\n    vector<string> tiling(2 * n);\n    for (int i = 0; i < 2 * n; i++) {\n        tiling[i] = ouf.readString();\n        if (tiling[i].length() != 2 * m)\n            quitf(_wa, \"Line %d does not have %d characters\", i + 1, 2 * m);\n    }\n\n    // Implement the logic to:\n    // - Parse the tiling grid\n    // - Count the number of tiles of each type used\n    // - Verify that adjacent sides are compatible\n    // - Ensure no black side touches a white side\n    // - Check that tile counts match a, b, c\n\n    // If all checks pass\n    quitf(_ok, \"Correct output\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, c;\n\n    if (type == \"only_c\" || type == \"max_c\") {\n        /* Maximize c */\n        c = n * m;\n        a = 0;\n        b = 0;\n    } else if (type == \"min_c\") {\n        /* Minimize c */\n        c = m; // c >= m\n        int remaining = n * m - c;\n        /* Distribute remaining between a and b randomly */\n        a = rnd.next(0, remaining);\n        b = remaining - a;\n    } else if (type == \"max_a\") {\n        /* Maximize a */\n        c = rnd.next(m, n * m);\n        a = n * m - c;\n        b = 0;\n    } else if (type == \"max_b\") {\n        /* Maximize b */\n        c = rnd.next(m, n * m);\n        b = n * m - c;\n        a = 0;\n    } else {\n        /* Random */\n        c = rnd.next(m, n * m);\n        int remaining = n * m - c;\n        a = rnd.next(0, remaining);\n        b = remaining - a;\n    }\n    \n    // Output n, m\n    printf(\"%d %d\\n\", n, m);\n    // Output a, b, c\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, c;\n\n    if (type == \"only_c\" || type == \"max_c\") {\n        /* Maximize c */\n        c = n * m;\n        a = 0;\n        b = 0;\n    } else if (type == \"min_c\") {\n        /* Minimize c */\n        c = m; // c >= m\n        int remaining = n * m - c;\n        /* Distribute remaining between a and b randomly */\n        a = rnd.next(0, remaining);\n        b = remaining - a;\n    } else if (type == \"max_a\") {\n        /* Maximize a */\n        c = rnd.next(m, n * m);\n        a = n * m - c;\n        b = 0;\n    } else if (type == \"max_b\") {\n        /* Maximize b */\n        c = rnd.next(m, n * m);\n        b = n * m - c;\n        a = 0;\n    } else {\n        /* Random */\n        c = rnd.next(m, n * m);\n        int remaining = n * m - c;\n        a = rnd.next(0, remaining);\n        b = remaining - a;\n    }\n    \n    // Output n, m\n    printf(\"%d %d\\n\", n, m);\n    // Output a, b, c\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type min_c\n./gen -n 1 -m 1 -type max_c\n./gen -n 1 -m 1 -type max_a\n./gen -n 1 -m 1 -type max_b\n\n./gen -n 1 -m 100 -type random\n./gen -n 1 -m 100 -type min_c\n./gen -n 1 -m 100 -type max_c\n./gen -n 1 -m 100 -type max_a\n./gen -n 1 -m 100 -type max_b\n\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 1 -type min_c\n./gen -n 100 -m 1 -type max_c\n./gen -n 100 -m 1 -type max_a\n./gen -n 100 -m 1 -type max_b\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type min_c\n./gen -n 100 -m 100 -type max_c\n./gen -n 100 -m 100 -type max_a\n./gen -n 100 -m 100 -type max_b\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type min_c\n./gen -n 50 -m 50 -type max_c\n\n./gen -n 8 -m 8 -type random\n\n./gen -n 99 -m 100 -type random\n\n./gen -n 100 -m 99 -type random\n\n./gen -n 10 -m 10 -type max_a\n\n./gen -n 10 -m 10 -type max_b\n\n./gen -n 10 -m 10 -type min_c\n\n./gen -n 10 -m 10 -type max_c\n\n./gen -n 70 -m 30 -type random\n\n./gen -n 30 -m 70 -type random\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:18.173278",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "480/A",
      "title": "A. Exams",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single positive integer n (1 ≤ n ≤ 5000) — the number of exams Valera will take.Each of the next n lines contains two positive space-separated integers ai and bi (1 ≤ bi < ai ≤ 109) — the date of the exam in the schedule and the early date of passing the i-th exam, correspondingly.",
      "output_spec": "OutputPrint a single integer — the minimum possible number of the day when Valera can take the last exam if he takes all the exams so that all the records in his record book go in the order of non-decreasing date.",
      "sample_tests": "ExamplesInputCopy35 23 14 2OutputCopy2InputCopy36 15 24 3OutputCopy6",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single positive integer n (1 ≤ n ≤ 5000) — the number of exams Valera will take.Each of the next n lines contains two positive space-separated integers ai and bi (1 ≤ bi < ai ≤ 109) — the date of the exam in the schedule and the early date of passing the i-th exam, correspondingly.\n\nOutputPrint a single integer — the minimum possible number of the day when Valera can take the last exam if he takes all the exams so that all the records in his record book go in the order of non-decreasing date.\n\nInputCopy35 23 14 2OutputCopy2InputCopy36 15 24 3OutputCopy6\n\nInputCopy35 23 14 2\n\nOutputCopy2\n\nInputCopy36 15 24 3\n\nOutputCopy6\n\nNoteIn the first sample Valera first takes an exam in the second subject on the first day (the teacher writes down the schedule date that is 3). On the next day he takes an exam in the third subject (the teacher writes down the schedule date, 4), then he takes an exam in the first subject (the teacher writes down the mark with date 5). Thus, Valera takes the last exam on the second day and the dates will go in the non-decreasing order: 3, 4, 5.In the second sample Valera first takes an exam in the third subject on the fourth day. Then he takes an exam in the second subject on the fifth day. After that on the sixth day Valera takes an exam in the first subject.",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Greetings to the Codeforces community!Yet another Div1+Div2 round will take place this Sunday, 19th of October at 13:00 MSK.The round is based on the problems of the regional stage of All-Russia team school competition, which will take place at the same time in Saratov. We are aware about the overlapping with Opencup, but we have no option to shift the round, because we are bounded to the local event.The problems were prepared by HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan and me.Scoring: 500-1000-1500-2000-2500 (both divisions).UPD: Editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 586
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces",
          "content": "I am happy to present you author's ideas of solutions. Editorial of the first five problem is authored by — HolkinPV and gridnevvvit, editorial for the last two problems is written by me.479A - ExpressionIn this task you have to consider several cases and choose the best one: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - TowersThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).479C - Exams, 480A - ExamsThe solution is again greedy. Sort the exams by increasing ai, breaking ties by increasing bi. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (b1). Move to the second exam. If we can take it on the day b2 (i.e. b1 ≤ b2), do it. Otherwise, take the second exam on the day a2. Continue the process, keeping the day of the latest exam. std::sort(a, a + n); // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Long Jumps, 480B - Long JumpsIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both x and y, output 0. Then try to measure both x and y by adding one more mark. If it was not successful, print two marks: one at x, other at y.So, how to check if the answer is 1? Consider all existing marks. Let some mark be at r. Try to add the new mark in each of the following positions: r - x, r + x, r - y, r + y. If it become possible to measure both x and y, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at r + x, we just check if there is a mark at r + x + y or r + x - y (by a binary search, since the marks are sorted). Make sure that the adde marks are in [0, L].479E - Riding in a Lift, 480C - Riding in a LiftThe task is solved by a dynamic programming. State is a pair (i, j), where i is the number of trips made, and j is the current floor. Initial state is (0, a), final states are (k, v), where v is any floor (except b).It is easy to see the transitions: to calculate dp(i, j), let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position j, because we can’t visit the same floor twice in a row). So, dp(i, j) is almost equal to the sum of values dp(i - 1, t), where t belongs to some segment [l, r] (the values of l and r can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute dp(i, j) in O(1), so overall complexity is O(NK).Jury solution: 8322623480D - ParcelsLet’s make two observations.First, consider the parcels as time segments [ini, outi]. It is true that if at some moment of time both parcel i and parcel j are on the platform, and i is higher than j, then .Second, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.These observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number i, and the residual strength is rs. Make this pair (i, rs) the state of DP, because it is exactly the original problem, where the platform strength is rs and there are only parcels j with . In d(i, rs) we will store the answer to this instance of the original problem.Which transitions are there? We can choose a set of parcels i(1), i(2), ... i(k) such that outi(j) ≤ ini(j + 1), i.e. segments do not intersect (but can touch) and are sorted; the weight of each of these parcels does not exceed rs. This choice corresponds to the following sequence of actions: first put parcel i(1) on the top of i. This gets us to the state i(1), min(rs - wi(1), si(1)), so we add up the answer for this state and the cost of i(1). Then we take away all parcels, including i(1), and put the parcel i(2) on top of i, and so on.As the number of states in DP is O(NS), all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in O(N2S). Note that for simplicity the platform can be considered as a parcel too.480E - Parking LotLet’s denote the car arrivals as events.Consider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number x, and the size of the square is k. Now we can update the answers for all events with numbers less than x with a value of k.The model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.Let’s assume that c2 - c1 ≤ r2 - r1 (the opposite case is symmetric). Take the middle row r = (r1 + r2) / 2. Virtually split all the squares inside the sub-table into those which lie above r, those which lie below r, and those which intersect r. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row r.Using initial table, for each cell (r, c) we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): up(r, c), down(r, c), left(r, c) и right(r, c). Using this values, build two histograms for the row r: the first is an array of values up(r, c), where c1 ≤ c ≤ c2; the second is an array of values down(r, c), where c1 ≤ c ≤ c2. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row r upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event x the maximum empty square found in the histograms has size k, and the next event has number y, we can update answers for all events with numbers x, x + 1, ..., y - 1 with the value of k. It remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length k if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 >= k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.Let’s try to estimate the running time. Each call of the routine (omitting inner calls) costs O(len·q), where len is the shortest side of the sub-table, and q is the number of events in it. If we draw a recursion tree, we will see that each second call len decreases twice. The total cost of all operations in a single level of a recursion tree is O(NK), where K is the total number of events. As long as we have O(logN), overall complexity is O(NKlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 480\\s*A"
          },
          "content_length": 8178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi\");\n        inf.readEoln();\n        ensuref(bi < ai, \"For i=%d, bi (%d) should be less than ai (%d)\", i+1, bi, ai);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi\");\n        inf.readEoln();\n        ensuref(bi < ai, \"For i=%d, bi (%d) should be less than ai (%d)\", i+1, bi, ai);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi\");\n        inf.readEoln();\n        ensuref(bi < ai, \"For i=%d, bi (%d) should be less than ai (%d)\", i+1, bi, ai);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1);\n\n    vector<int> ai(n), bi(n);\n\n    if (type == \"random\") {\n        // Random ai and bi within full range\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(2, 1000000000); // ai ∈ [2, 1e9]\n            bi[i] = rnd.next(1, ai[i] - 1);  // bi ∈ [1, ai - 1]\n        }\n    } else if (type == \"small\") {\n        // Small ai and bi\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(2, 100);       // ai ∈ [2, 100]\n            bi[i] = rnd.next(1, ai[i] - 1); // bi ∈ [1, ai - 1]\n        }\n    } else if (type == \"large\") {\n        // Large ai and bi\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1000000000 - 1000, 1000000000); // ai ∈ [1e9 - 1000, 1e9]\n            bi[i] = rnd.next(1, ai[i] - 1);                  // bi ∈ [1, ai -1]\n        }\n    } else if (type == \"ai_equal_bi_plus_k\") {\n        // ai = bi + k\n        int max_bi = 1000000000 - k; // Ensure that ai ≤ 1e9\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, max_bi);\n            ai[i] = bi[i] + k;\n        }\n    } else if (type == \"bi_equal_1\") {\n        // bi = 1 for all exams\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 1;\n            ai[i] = rnd.next(bi[i] + 1, 1000000000);\n        }\n    } else if (type == \"decreasing_ai\") {\n        // ai in decreasing order\n        int base_ai = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = base_ai - i;\n            bi[i] = rnd.next(1, ai[i] - 1);\n        }\n    } else if (type == \"duplicate_ai\") {\n        // Some exams have the same ai\n        int fixed_ai = rnd.next(2, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            if (i % 5 == 0) {\n                ai[i] = fixed_ai;\n            } else {\n                ai[i] = rnd.next(2, 1000000000);\n            }\n            bi[i] = rnd.next(1, ai[i] - 1);\n        }\n    } else if (type == \"maximum_difference\") {\n        // Maximize ai - bi\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 1;\n            ai[i] = 1000000000;\n        }\n    } else if (type == \"minimal_difference\") {\n        // Minimize ai - bi (ai = bi + 1)\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000 - 1);\n            ai[i] = bi[i] + 1;\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(2, 1000000000); // ai ∈ [2, 1e9]\n            bi[i] = rnd.next(1, ai[i] - 1);  // bi ∈ [1, ai - 1]\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai and bi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ai[i], bi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1);\n\n    vector<int> ai(n), bi(n);\n\n    if (type == \"random\") {\n        // Random ai and bi within full range\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(2, 1000000000); // ai ∈ [2, 1e9]\n            bi[i] = rnd.next(1, ai[i] - 1);  // bi ∈ [1, ai - 1]\n        }\n    } else if (type == \"small\") {\n        // Small ai and bi\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(2, 100);       // ai ∈ [2, 100]\n            bi[i] = rnd.next(1, ai[i] - 1); // bi ∈ [1, ai - 1]\n        }\n    } else if (type == \"large\") {\n        // Large ai and bi\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1000000000 - 1000, 1000000000); // ai ∈ [1e9 - 1000, 1e9]\n            bi[i] = rnd.next(1, ai[i] - 1);                  // bi ∈ [1, ai -1]\n        }\n    } else if (type == \"ai_equal_bi_plus_k\") {\n        // ai = bi + k\n        int max_bi = 1000000000 - k; // Ensure that ai ≤ 1e9\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, max_bi);\n            ai[i] = bi[i] + k;\n        }\n    } else if (type == \"bi_equal_1\") {\n        // bi = 1 for all exams\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 1;\n            ai[i] = rnd.next(bi[i] + 1, 1000000000);\n        }\n    } else if (type == \"decreasing_ai\") {\n        // ai in decreasing order\n        int base_ai = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = base_ai - i;\n            bi[i] = rnd.next(1, ai[i] - 1);\n        }\n    } else if (type == \"duplicate_ai\") {\n        // Some exams have the same ai\n        int fixed_ai = rnd.next(2, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            if (i % 5 == 0) {\n                ai[i] = fixed_ai;\n            } else {\n                ai[i] = rnd.next(2, 1000000000);\n            }\n            bi[i] = rnd.next(1, ai[i] - 1);\n        }\n    } else if (type == \"maximum_difference\") {\n        // Maximize ai - bi\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 1;\n            ai[i] = 1000000000;\n        }\n    } else if (type == \"minimal_difference\") {\n        // Minimize ai - bi (ai = bi + 1)\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000 - 1);\n            ai[i] = bi[i] + 1;\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(2, 1000000000); // ai ∈ [2, 1e9]\n            bi[i] = rnd.next(1, ai[i] - 1);  // bi ∈ [1, ai - 1]\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai and bi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ai[i], bi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n\n./gen -n 10 -type small\n./gen -n 100 -type small\n./gen -n 5000 -type small\n\n./gen -n 10 -type large\n./gen -n 100 -type large\n./gen -n 5000 -type large\n\n./gen -n 5000 -type ai_equal_bi_plus_k -k 1\n./gen -n 5000 -type ai_equal_bi_plus_k -k 2\n./gen -n 5000 -type ai_equal_bi_plus_k -k 1000\n./gen -n 5000 -type ai_equal_bi_plus_k -k 1000000\n\n./gen -n 5000 -type bi_equal_1\n./gen -n 5000 -type decreasing_ai\n./gen -n 5000 -type duplicate_ai\n./gen -n 5000 -type maximum_difference\n./gen -n 5000 -type minimal_difference\n\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n\n./gen -n 1 -type minimum\n./gen -n 5000 -type maximum\n\n./gen -n 5000 -type random\n./gen -n 1 -type random\n\n./gen -n 1000 -type random\n./gen -n 2000 -type random\n./gen -n 3000 -type small\n./gen -n 4000 -type large\n./gen -n 5000 -type ai_equal_bi_plus_k -k 10\n\n./gen -n 1000 -type bi_equal_1\n./gen -n 1000 -type decreasing_ai\n./gen -n 1000 -type duplicate_ai\n./gen -n 1000 -type maximum_difference\n./gen -n 1000 -type minimal_difference\n\n# Edge cases with n = 1\n./gen -n 1 -type small\n./gen -n 1 -type large\n./gen -n 1 -type ai_equal_bi_plus_k -k 1\n\n# Edge cases with n = maximum\n./gen -n 5000 -type increasing_ai\n./gen -n 5000 -type decreasing_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:20.338593",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "480/B",
      "title": "B. Long Jumps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four positive space-separated integers n, l, x, y (2 ≤ n ≤ 105, 2 ≤ l ≤ 109, 1 ≤ x < y ≤ l) — the number of marks, the length of the ruler and the jump norms for girls and boys, correspondingly.The second line contains a sequence of n integers a1, a2, ..., an (0 = a1 < a2 < ... < an = l), where ai shows the distance from the i-th mark to the origin.",
      "output_spec": "OutputIn the first line print a single non-negative integer v — the minimum number of marks that you need to add on the ruler.In the second line print v space-separated integers p1, p2, ..., pv (0 ≤ pi ≤ l). Number pi means that the i-th mark should be at the distance of pi centimeters from the origin. Print the marks in any order. If there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy3 250 185 2300 185 250OutputCopy1230InputCopy4 250 185 2300 20 185 250OutputCopy0InputCopy2 300 185 2300 300OutputCopy2185 230",
      "description": "B. Long Jumps\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four positive space-separated integers n, l, x, y (2 ≤ n ≤ 105, 2 ≤ l ≤ 109, 1 ≤ x < y ≤ l) — the number of marks, the length of the ruler and the jump norms for girls and boys, correspondingly.The second line contains a sequence of n integers a1, a2, ..., an (0 = a1 < a2 < ... < an = l), where ai shows the distance from the i-th mark to the origin.\n\nOutputIn the first line print a single non-negative integer v — the minimum number of marks that you need to add on the ruler.In the second line print v space-separated integers p1, p2, ..., pv (0 ≤ pi ≤ l). Number pi means that the i-th mark should be at the distance of pi centimeters from the origin. Print the marks in any order. If there are multiple solutions, print any of them.\n\nInputCopy3 250 185 2300 185 250OutputCopy1230InputCopy4 250 185 2300 20 185 250OutputCopy0InputCopy2 300 185 2300 300OutputCopy2185 230\n\nInputCopy3 250 185 2300 185 250\n\nOutputCopy1230\n\nInputCopy4 250 185 2300 20 185 250\n\nOutputCopy0\n\nInputCopy2 300 185 2300 300\n\nOutputCopy2185 230\n\nNoteIn the first sample it is impossible to initially measure the distance of 230 centimeters. For that it is enough to add a 20 centimeter mark or a 230 centimeter mark.In the second sample you already can use the ruler to measure the distances of 185 and 230 centimeters, so you don't have to add new marks.In the third sample the ruler only contains the initial and the final marks. We will need to add two marks to be able to test the children's skills.",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Greetings to the Codeforces community!Yet another Div1+Div2 round will take place this Sunday, 19th of October at 13:00 MSK.The round is based on the problems of the regional stage of All-Russia team school competition, which will take place at the same time in Saratov. We are aware about the overlapping with Opencup, but we have no option to shift the round, because we are bounded to the local event.The problems were prepared by HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan and me.Scoring: 500-1000-1500-2000-2500 (both divisions).UPD: Editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 586
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces",
          "content": "I am happy to present you author's ideas of solutions. Editorial of the first five problem is authored by — HolkinPV and gridnevvvit, editorial for the last two problems is written by me.479A - ExpressionIn this task you have to consider several cases and choose the best one: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - TowersThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).479C - Exams, 480A - ExamsThe solution is again greedy. Sort the exams by increasing ai, breaking ties by increasing bi. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (b1). Move to the second exam. If we can take it on the day b2 (i.e. b1 ≤ b2), do it. Otherwise, take the second exam on the day a2. Continue the process, keeping the day of the latest exam. std::sort(a, a + n); // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Long Jumps, 480B - Long JumpsIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both x and y, output 0. Then try to measure both x and y by adding one more mark. If it was not successful, print two marks: one at x, other at y.So, how to check if the answer is 1? Consider all existing marks. Let some mark be at r. Try to add the new mark in each of the following positions: r - x, r + x, r - y, r + y. If it become possible to measure both x and y, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at r + x, we just check if there is a mark at r + x + y or r + x - y (by a binary search, since the marks are sorted). Make sure that the adde marks are in [0, L].479E - Riding in a Lift, 480C - Riding in a LiftThe task is solved by a dynamic programming. State is a pair (i, j), where i is the number of trips made, and j is the current floor. Initial state is (0, a), final states are (k, v), where v is any floor (except b).It is easy to see the transitions: to calculate dp(i, j), let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position j, because we can’t visit the same floor twice in a row). So, dp(i, j) is almost equal to the sum of values dp(i - 1, t), where t belongs to some segment [l, r] (the values of l and r can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute dp(i, j) in O(1), so overall complexity is O(NK).Jury solution: 8322623480D - ParcelsLet’s make two observations.First, consider the parcels as time segments [ini, outi]. It is true that if at some moment of time both parcel i and parcel j are on the platform, and i is higher than j, then .Second, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.These observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number i, and the residual strength is rs. Make this pair (i, rs) the state of DP, because it is exactly the original problem, where the platform strength is rs and there are only parcels j with . In d(i, rs) we will store the answer to this instance of the original problem.Which transitions are there? We can choose a set of parcels i(1), i(2), ... i(k) such that outi(j) ≤ ini(j + 1), i.e. segments do not intersect (but can touch) and are sorted; the weight of each of these parcels does not exceed rs. This choice corresponds to the following sequence of actions: first put parcel i(1) on the top of i. This gets us to the state i(1), min(rs - wi(1), si(1)), so we add up the answer for this state and the cost of i(1). Then we take away all parcels, including i(1), and put the parcel i(2) on top of i, and so on.As the number of states in DP is O(NS), all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in O(N2S). Note that for simplicity the platform can be considered as a parcel too.480E - Parking LotLet’s denote the car arrivals as events.Consider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number x, and the size of the square is k. Now we can update the answers for all events with numbers less than x with a value of k.The model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.Let’s assume that c2 - c1 ≤ r2 - r1 (the opposite case is symmetric). Take the middle row r = (r1 + r2) / 2. Virtually split all the squares inside the sub-table into those which lie above r, those which lie below r, and those which intersect r. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row r.Using initial table, for each cell (r, c) we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): up(r, c), down(r, c), left(r, c) и right(r, c). Using this values, build two histograms for the row r: the first is an array of values up(r, c), where c1 ≤ c ≤ c2; the second is an array of values down(r, c), where c1 ≤ c ≤ c2. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row r upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event x the maximum empty square found in the histograms has size k, and the next event has number y, we can update answers for all events with numbers x, x + 1, ..., y - 1 with the value of k. It remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length k if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 >= k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.Let’s try to estimate the running time. Each call of the routine (omitting inner calls) costs O(len·q), where len is the shortest side of the sub-table, and q is the number of events in it. If we draw a recursion tree, we will see that each second call len decreases twice. The total cost of all operations in a single level of a recursion tree is O(NK), where K is the total number of events. As long as we have O(logN), overall complexity is O(NKlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 480\\s*B"
          },
          "content_length": 8178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(2, 1000000000, \"l\");\n    inf.readSpace();\n    int x = inf.readInt(1, l - 1, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(x + 1, l, \"y\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, l, \"a_i\");\n    inf.readEoln();\n    \n    ensuref(a[0] == 0, \"First a_i must be 0, but a[0]=%d\", a[0]);\n    ensuref(a[n - 1] == l, \"Last a_i must be l=%d, but a[n-1]=%d\", l, a[n-1]);\n    for (int i = 1; i < n; i++) {\n        ensuref(a[i - 1] < a[i], \"a[%d]=%d is not less than a[%d]=%d\", i - 1, a[i - 1], i, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(2, 1000000000, \"l\");\n    inf.readSpace();\n    int x = inf.readInt(1, l - 1, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(x + 1, l, \"y\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, l, \"a_i\");\n    inf.readEoln();\n    \n    ensuref(a[0] == 0, \"First a_i must be 0, but a[0]=%d\", a[0]);\n    ensuref(a[n - 1] == l, \"Last a_i must be l=%d, but a[n-1]=%d\", l, a[n-1]);\n    for (int i = 1; i < n; i++) {\n        ensuref(a[i - 1] < a[i], \"a[%d]=%d is not less than a[%d]=%d\", i - 1, a[i - 1], i, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(2, 1000000000, \"l\");\n    inf.readSpace();\n    int x = inf.readInt(1, l - 1, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(x + 1, l, \"y\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, l, \"a_i\");\n    inf.readEoln();\n    \n    ensuref(a[0] == 0, \"First a_i must be 0, but a[0]=%d\", a[0]);\n    ensuref(a[n - 1] == l, \"Last a_i must be l=%d, but a[n-1]=%d\", l, a[n-1]);\n    for (int i = 1; i < n; i++) {\n        ensuref(a[i - 1] < a[i], \"a[%d]=%d is not less than a[%d]=%d\", i - 1, a[i - 1], i, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    int n = inf.readInt(2, 100000, \"n\");\n    long long l = inf.readLong(2LL, 1000000000LL, \"l\");\n    long long x = inf.readLong(1LL, l, \"x\");\n    long long y = inf.readLong(1LL, l, \"y\");\n\n    if (!(1LL <= x && x < y && y <= l))\n        quitf(_fail, \"Invalid x and y in input file\");\n\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readLong(0LL, l, format(\"a[%d]\", i + 1).c_str());\n        if (i > 0 && a[i] <= a[i - 1])\n            quitf(_fail, \"Marks are not strictly increasing in input file\");\n    }\n\n    if (a[0] != 0LL)\n        quitf(_fail, \"First mark must be at position 0\");\n    if (a[n - 1] != l)\n        quitf(_fail, \"Last mark must be at position l\");\n\n    set<long long> marks_set(a.begin(), a.end());\n\n    // Check whether x and y can be measured with initial marks\n    bool can_measure_x = false;\n    bool can_measure_y = false;\n\n    for (int i = 0; i < n; i++) {\n        if (marks_set.count(a[i] + x) || marks_set.count(a[i] - x))\n            can_measure_x = true;\n        if (marks_set.count(a[i] + y) || marks_set.count(a[i] - y))\n            can_measure_y = true;\n    }\n\n    int minimal_v;\n    if (can_measure_x && can_measure_y) {\n        minimal_v = 0;\n    } else {\n        // Check if adding one mark suffices\n        bool found = false;\n        for (int i = 0; i < n; i++) {\n            // Try p = a[i] + x\n            long long cand_p = a[i] + x;\n            if (0LL <= cand_p && cand_p <= l) {\n                if (marks_set.count(cand_p - y) || marks_set.count(cand_p + y)) {\n                    found = true;\n                    break;\n                }\n            }\n            // Try p = a[i] - x\n            cand_p = a[i] - x;\n            if (0LL <= cand_p && cand_p <= l) {\n                if (marks_set.count(cand_p - y) || marks_set.count(cand_p + y)) {\n                    found = true;\n                    break;\n                }\n            }\n            // Try p = a[i] + y\n            cand_p = a[i] + y;\n            if (0LL <= cand_p && cand_p <= l) {\n                if (marks_set.count(cand_p - x) || marks_set.count(cand_p + x)) {\n                    found = true;\n                    break;\n                }\n            }\n            // Try p = a[i] - y\n            cand_p = a[i] - y;\n            if (0LL <= cand_p && cand_p <= l) {\n                if (marks_set.count(cand_p - x) || marks_set.count(cand_p + x)) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        if (found || can_measure_x || can_measure_y)\n            minimal_v = 1;\n        else\n            minimal_v = 2;\n    }\n\n    // Read contestant's output\n    int v = ouf.readInt(0, 2, \"v\");\n    vector<long long> p(v);\n    set<long long> new_marks_set = marks_set;\n\n    for (int i = 0; i < v; i++) {\n        p[i] = ouf.readLong(0LL, l, format(\"p[%d]\", i + 1).c_str());\n        new_marks_set.insert(p[i]);\n    }\n\n    // Check whether x and y can be measured with new marks\n    can_measure_x = false;\n    can_measure_y = false;\n\n    for (auto mark : new_marks_set) {\n        if (new_marks_set.count(mark + x) || new_marks_set.count(mark - x))\n            can_measure_x = true;\n        if (new_marks_set.count(mark + y) || new_marks_set.count(mark - y))\n            can_measure_y = true;\n    }\n\n    if (can_measure_x && can_measure_y) {\n        if (v != minimal_v) {\n            quitf(_wa, \"Number of added marks is not minimal: expected %d, found %d\", minimal_v, v);\n        } else {\n            quitf(_ok, \"Solution is correct with %d added marks\", v);\n        }\n    } else {\n        quitf(_wa, \"After adding marks, cannot measure both x(%lld) and y(%lld)\", x, y);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Total number of marks, including 0 and l\n    int l = opt<int>(\"l\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> marks;\n    set<int> mark_set;\n\n    if (type == \"both\") {\n        // Ensure both distances x and y can be measured\n        marks.push_back(0);\n        marks.push_back(x);\n        marks.push_back(y);\n        marks.push_back(l);\n    } else if (type == \"only_x\") {\n        // Ensure only distance x can be measured\n        marks.push_back(0);\n        marks.push_back(x);\n        marks.push_back(l);\n\n        // Adjust l to ensure l - x != y\n        while (l - x == y) {\n            l++;\n        }\n    } else if (type == \"only_y\") {\n        // Ensure only distance y can be measured\n        marks.push_back(0);\n        marks.push_back(y);\n        marks.push_back(l);\n\n        // Adjust l to ensure l - y != x\n        while (l - y == x) {\n            l++;\n        }\n    } else if (type == \"none_one_mark\") {\n        // Neither x nor y can be measured, but adding one mark suffices\n        marks.push_back(0);\n        marks.push_back(l);\n\n        // Adjust l to ensure l != x and l != y\n        while (l == x || l == y) {\n            l++;\n        }\n        // Set l = x + y\n        l = x + y;\n    } else if (type == \"none_two_marks\") {\n        // Neither x nor y can be measured, and adding one mark cannot help\n        marks.push_back(0);\n        marks.push_back(l);\n\n        // Adjust l to ensure l != x, l != y, l != x + y\n        while (l == x || l == y || l == x + y) {\n            l++;\n        }\n        // Set l = x + y + 1 to prevent measuring x and y with one addition\n        l = x + y + 1;\n    } else if (type == \"max_n\") {\n        // Generate maximum number of marks\n        n = 100000;\n        marks.push_back(0);\n        marks.push_back(l);\n    } else if (type == \"min_n\") {\n        // Generate minimum number of marks\n        n = 2;\n        marks.push_back(0);\n        marks.push_back(l);\n    } else if (type == \"random\") {\n        // Generate random marks\n        marks.push_back(0);\n        marks.push_back(l);\n    }\n\n    // Add random marks to reach the desired number of marks\n    while ((int)marks.size() < n) {\n        int pos = rnd.next(1, l - 1);\n        if (find(marks.begin(), marks.end(), pos) == marks.end()) {\n            marks.push_back(pos);\n        }\n    }\n\n    // Ensure the marks are sorted and unique\n    sort(marks.begin(), marks.end());\n    marks.erase(unique(marks.begin(), marks.end()), marks.end());\n\n    // Adjust n if necessary\n    if ((int)marks.size() > n) {\n        // Remove extra marks except 0 and l\n        vector<int> inner_marks(marks.begin() + 1, marks.end() - 1);\n        shuffle(inner_marks.begin(), inner_marks.end());\n        inner_marks.resize(n - 2);\n        marks = {0};\n        marks.insert(marks.end(), inner_marks.begin(), inner_marks.end());\n        marks.push_back(l);\n        sort(marks.begin(), marks.end());\n    }\n\n    // Output\n    printf(\"%d %d %d %d\\n\", n, l, x, y);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", marks[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Total number of marks, including 0 and l\n    int l = opt<int>(\"l\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> marks;\n    set<int> mark_set;\n\n    if (type == \"both\") {\n        // Ensure both distances x and y can be measured\n        marks.push_back(0);\n        marks.push_back(x);\n        marks.push_back(y);\n        marks.push_back(l);\n    } else if (type == \"only_x\") {\n        // Ensure only distance x can be measured\n        marks.push_back(0);\n        marks.push_back(x);\n        marks.push_back(l);\n\n        // Adjust l to ensure l - x != y\n        while (l - x == y) {\n            l++;\n        }\n    } else if (type == \"only_y\") {\n        // Ensure only distance y can be measured\n        marks.push_back(0);\n        marks.push_back(y);\n        marks.push_back(l);\n\n        // Adjust l to ensure l - y != x\n        while (l - y == x) {\n            l++;\n        }\n    } else if (type == \"none_one_mark\") {\n        // Neither x nor y can be measured, but adding one mark suffices\n        marks.push_back(0);\n        marks.push_back(l);\n\n        // Adjust l to ensure l != x and l != y\n        while (l == x || l == y) {\n            l++;\n        }\n        // Set l = x + y\n        l = x + y;\n    } else if (type == \"none_two_marks\") {\n        // Neither x nor y can be measured, and adding one mark cannot help\n        marks.push_back(0);\n        marks.push_back(l);\n\n        // Adjust l to ensure l != x, l != y, l != x + y\n        while (l == x || l == y || l == x + y) {\n            l++;\n        }\n        // Set l = x + y + 1 to prevent measuring x and y with one addition\n        l = x + y + 1;\n    } else if (type == \"max_n\") {\n        // Generate maximum number of marks\n        n = 100000;\n        marks.push_back(0);\n        marks.push_back(l);\n    } else if (type == \"min_n\") {\n        // Generate minimum number of marks\n        n = 2;\n        marks.push_back(0);\n        marks.push_back(l);\n    } else if (type == \"random\") {\n        // Generate random marks\n        marks.push_back(0);\n        marks.push_back(l);\n    }\n\n    // Add random marks to reach the desired number of marks\n    while ((int)marks.size() < n) {\n        int pos = rnd.next(1, l - 1);\n        if (find(marks.begin(), marks.end(), pos) == marks.end()) {\n            marks.push_back(pos);\n        }\n    }\n\n    // Ensure the marks are sorted and unique\n    sort(marks.begin(), marks.end());\n    marks.erase(unique(marks.begin(), marks.end()), marks.end());\n\n    // Adjust n if necessary\n    if ((int)marks.size() > n) {\n        // Remove extra marks except 0 and l\n        vector<int> inner_marks(marks.begin() + 1, marks.end() - 1);\n        shuffle(inner_marks.begin(), inner_marks.end());\n        inner_marks.resize(n - 2);\n        marks = {0};\n        marks.insert(marks.end(), inner_marks.begin(), inner_marks.end());\n        marks.push_back(l);\n        sort(marks.begin(), marks.end());\n    }\n\n    // Output\n    printf(\"%d %d %d %d\\n\", n, l, x, y);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", marks[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases where both x and y can be measured\n./gen -n 10 -l 250 -x 50 -y 100 -type both\n./gen -n 100 -l 1000 -x 200 -y 500 -type both\n./gen -n 1000 -l 100000 -x 10000 -y 50000 -type both\n./gen -n 100000 -l 1000000000 -x 500000000 -y 800000000 -type both\n\n# Test cases where only x can be measured\n./gen -n 10 -l 250 -x 50 -y 100 -type only_x\n./gen -n 100 -l 1000 -x 200 -y 500 -type only_x\n./gen -n 1000 -l 100000 -x 10000 -y 50000 -type only_x\n./gen -n 100000 -l 1000000000 -x 500000000 -y 800000000 -type only_x\n\n# Test cases where only y can be measured\n./gen -n 10 -l 250 -x 50 -y 100 -type only_y\n./gen -n 100 -l 1000 -x 200 -y 500 -type only_y\n./gen -n 1000 -l 100000 -x 10000 -y 50000 -type only_y\n./gen -n 100000 -l 1000000000 -x 500000000 -y 800000000 -type only_y\n\n# Test cases where neither x nor y can be measured, but adding one mark suffices\n./gen -n 2 -l 150 -x 50 -y 100 -type none_one_mark\n./gen -n 100 -l 700 -x 200 -y 500 -type none_one_mark\n./gen -n 1000 -l 150000 -x 50000 -y 100000 -type none_one_mark\n./gen -n 100000 -l 900000000 -x 400000000 -y 500000000 -type none_one_mark\n\n# Test cases where neither x nor y can be measured, and adding one mark is insufficient\n./gen -n 2 -l 151 -x 50 -y 100 -type none_two_marks\n./gen -n 100 -l 701 -x 200 -y 500 -type none_two_marks\n./gen -n 1000 -l 150001 -x 50000 -y 100000 -type none_two_marks\n./gen -n 100000 -l 900000001 -x 400000000 -y 500000000 -type none_two_marks\n\n# Test cases with maximum number of marks\n./gen -n 100000 -l 1000000000 -x 500000000 -y 800000000 -type max_n\n\n# Test cases with minimum number of marks\n./gen -n 2 -l 1000 -x 200 -y 500 -type min_n\n./gen -n 2 -l 1000000 -x 300000 -y 700000 -type min_n\n\n# Random test cases\n./gen -n 10 -l 1000 -x 100 -y 200 -type random\n./gen -n 100 -l 10000 -x 1000 -y 2000 -type random\n./gen -n 1000 -l 100000 -x 10000 -y 20000 -type random\n./gen -n 10000 -l 1000000 -x 100000 -y 500000 -type random\n./gen -n 50000 -l 5000000 -x 1000000 -y 2000000 -type random\n./gen -n 99999 -l 99999999 -x 25000000 -y 50000000 -type random\n./gen -n 100000 -l 1000000000 -x 1 -y 999999999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:22.316561",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "480/C",
      "title": "C. Riding in a Lift",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four space-separated integers n, a, b, k (2 ≤ n ≤ 5000, 1 ≤ k ≤ 5000, 1 ≤ a, b ≤ n, a ≠ b).",
      "output_spec": "OutputPrint a single integer — the remainder after dividing the sought number of sequences by 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy5 2 4 1OutputCopy2InputCopy5 2 4 2OutputCopy2InputCopy5 3 4 1OutputCopy0",
      "description": "C. Riding in a Lift\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains four space-separated integers n, a, b, k (2 ≤ n ≤ 5000, 1 ≤ k ≤ 5000, 1 ≤ a, b ≤ n, a ≠ b).\n\nOutputPrint a single integer — the remainder after dividing the sought number of sequences by 1000000007 (109 + 7).\n\nInputCopy5 2 4 1OutputCopy2InputCopy5 2 4 2OutputCopy2InputCopy5 3 4 1OutputCopy0\n\nInputCopy5 2 4 1\n\nOutputCopy2\n\nInputCopy5 2 4 2\n\nOutputCopy2\n\nInputCopy5 3 4 1\n\nOutputCopy0\n\nNoteTwo sequences p1, p2, ..., pk and q1, q2, ..., qk are distinct, if there is such integer j (1 ≤ j ≤ k), that pj ≠ qj.Notes to the samples:  In the first sample after the first trip you are either on floor 1, or on floor 3, because |1 - 2| < |2 - 4| and |3 - 2| < |2 - 4|.  In the second sample there are two possible sequences: (1, 2); (1, 3). You cannot choose floor 3 for the first trip because in this case no floor can be the floor for the second trip.  In the third sample there are no sought sequences, because you cannot choose the floor for the first trip.",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Greetings to the Codeforces community!Yet another Div1+Div2 round will take place this Sunday, 19th of October at 13:00 MSK.The round is based on the problems of the regional stage of All-Russia team school competition, which will take place at the same time in Saratov. We are aware about the overlapping with Opencup, but we have no option to shift the round, because we are bounded to the local event.The problems were prepared by HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan and me.Scoring: 500-1000-1500-2000-2500 (both divisions).UPD: Editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 586
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces",
          "content": "I am happy to present you author's ideas of solutions. Editorial of the first five problem is authored by — HolkinPV and gridnevvvit, editorial for the last two problems is written by me.479A - ExpressionIn this task you have to consider several cases and choose the best one: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - TowersThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).479C - Exams, 480A - ExamsThe solution is again greedy. Sort the exams by increasing ai, breaking ties by increasing bi. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (b1). Move to the second exam. If we can take it on the day b2 (i.e. b1 ≤ b2), do it. Otherwise, take the second exam on the day a2. Continue the process, keeping the day of the latest exam. std::sort(a, a + n); // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Long Jumps, 480B - Long JumpsIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both x and y, output 0. Then try to measure both x and y by adding one more mark. If it was not successful, print two marks: one at x, other at y.So, how to check if the answer is 1? Consider all existing marks. Let some mark be at r. Try to add the new mark in each of the following positions: r - x, r + x, r - y, r + y. If it become possible to measure both x and y, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at r + x, we just check if there is a mark at r + x + y or r + x - y (by a binary search, since the marks are sorted). Make sure that the adde marks are in [0, L].479E - Riding in a Lift, 480C - Riding in a LiftThe task is solved by a dynamic programming. State is a pair (i, j), where i is the number of trips made, and j is the current floor. Initial state is (0, a), final states are (k, v), where v is any floor (except b).It is easy to see the transitions: to calculate dp(i, j), let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position j, because we can’t visit the same floor twice in a row). So, dp(i, j) is almost equal to the sum of values dp(i - 1, t), where t belongs to some segment [l, r] (the values of l and r can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute dp(i, j) in O(1), so overall complexity is O(NK).Jury solution: 8322623480D - ParcelsLet’s make two observations.First, consider the parcels as time segments [ini, outi]. It is true that if at some moment of time both parcel i and parcel j are on the platform, and i is higher than j, then .Second, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.These observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number i, and the residual strength is rs. Make this pair (i, rs) the state of DP, because it is exactly the original problem, where the platform strength is rs and there are only parcels j with . In d(i, rs) we will store the answer to this instance of the original problem.Which transitions are there? We can choose a set of parcels i(1), i(2), ... i(k) such that outi(j) ≤ ini(j + 1), i.e. segments do not intersect (but can touch) and are sorted; the weight of each of these parcels does not exceed rs. This choice corresponds to the following sequence of actions: first put parcel i(1) on the top of i. This gets us to the state i(1), min(rs - wi(1), si(1)), so we add up the answer for this state and the cost of i(1). Then we take away all parcels, including i(1), and put the parcel i(2) on top of i, and so on.As the number of states in DP is O(NS), all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in O(N2S). Note that for simplicity the platform can be considered as a parcel too.480E - Parking LotLet’s denote the car arrivals as events.Consider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number x, and the size of the square is k. Now we can update the answers for all events with numbers less than x with a value of k.The model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.Let’s assume that c2 - c1 ≤ r2 - r1 (the opposite case is symmetric). Take the middle row r = (r1 + r2) / 2. Virtually split all the squares inside the sub-table into those which lie above r, those which lie below r, and those which intersect r. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row r.Using initial table, for each cell (r, c) we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): up(r, c), down(r, c), left(r, c) и right(r, c). Using this values, build two histograms for the row r: the first is an array of values up(r, c), where c1 ≤ c ≤ c2; the second is an array of values down(r, c), where c1 ≤ c ≤ c2. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row r upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event x the maximum empty square found in the histograms has size k, and the next event has number y, we can update answers for all events with numbers x, x + 1, ..., y - 1 with the value of k. It remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length k if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 >= k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.Let’s try to estimate the running time. Each call of the routine (omitting inner calls) costs O(len·q), where len is the shortest side of the sub-table, and q is the number of events in it. If we draw a recursion tree, we will see that each second call len decreases twice. The total cost of all operations in a single level of a recursion tree is O(NK), where K is the total number of events. As long as we have O(logN), overall complexity is O(NKlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 480\\s*C"
          },
          "content_length": 8178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n\n    ensuref(a != b, \"a and b must be different, but a=%d and b=%d\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n\n    ensuref(a != b, \"a and b must be different, but a=%d and b=%d\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readEoln();\n\n    ensuref(a != b, \"a and b must be different, but a=%d and b=%d\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b;\n\n    if (type == \"min\") {\n        n = 2;\n        k = 1;\n        a = 1;\n        b = 2;\n    } else if (type == \"max\") {\n        n = n;\n        k = k;\n        a = rnd.next(1, n);\n        do {\n            b = rnd.next(1, n);\n        } while (a == b);\n    } else if (type == \"random\") {\n        n = n; // use n passed as parameter\n        k = k; // use k passed as parameter\n        a = rnd.next(1, n);\n        do {\n            b = rnd.next(1, n);\n        } while (a == b);\n    } else if (type == \"adjacent\") {\n        n = n;\n        k = k;\n        if (n == 2) {\n            a = 1;\n            b = 2;\n        } else {\n            a = rnd.next(1, n -1);\n            b = a + 1;\n        }\n    } else if (type == \"opposite\") {\n        n = n;\n        k = k;\n        a = 1;\n        b = n;\n    } else if (type == \"impossible\") {\n        n = n;\n        k = 1; // To ensure no valid sequences\n        if (n == 2) {\n            a = 1;\n            b = 2;\n        } else {\n            // Set a and b adjacent\n            a = rnd.next(1, n -1);\n            b = a + 1;\n        }\n    } else {\n        // Default to random\n        n = n;\n        k = k;\n        a = rnd.next(1, n);\n        do {\n            b = rnd.next(1, n);\n        } while (a == b);\n    }\n\n    printf(\"%d %d %d %d\\n\", n, a, b, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b;\n\n    if (type == \"min\") {\n        n = 2;\n        k = 1;\n        a = 1;\n        b = 2;\n    } else if (type == \"max\") {\n        n = n;\n        k = k;\n        a = rnd.next(1, n);\n        do {\n            b = rnd.next(1, n);\n        } while (a == b);\n    } else if (type == \"random\") {\n        n = n; // use n passed as parameter\n        k = k; // use k passed as parameter\n        a = rnd.next(1, n);\n        do {\n            b = rnd.next(1, n);\n        } while (a == b);\n    } else if (type == \"adjacent\") {\n        n = n;\n        k = k;\n        if (n == 2) {\n            a = 1;\n            b = 2;\n        } else {\n            a = rnd.next(1, n -1);\n            b = a + 1;\n        }\n    } else if (type == \"opposite\") {\n        n = n;\n        k = k;\n        a = 1;\n        b = n;\n    } else if (type == \"impossible\") {\n        n = n;\n        k = 1; // To ensure no valid sequences\n        if (n == 2) {\n            a = 1;\n            b = 2;\n        } else {\n            // Set a and b adjacent\n            a = rnd.next(1, n -1);\n            b = a + 1;\n        }\n    } else {\n        // Default to random\n        n = n;\n        k = k;\n        a = rnd.next(1, n);\n        do {\n            b = rnd.next(1, n);\n        } while (a == b);\n    }\n\n    printf(\"%d %d %d %d\\n\", n, a, b, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 1 -type min\n./gen -n 2 -k 1 -type impossible\n./gen -n 2 -k 1 -type adjacent\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 1 -type opposite\n\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 5 -type adjacent\n./gen -n 10 -k 5 -type impossible\n./gen -n 10 -k 1 -type impossible\n./gen -n 10 -k 5 -type opposite\n\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 50 -type adjacent\n./gen -n 100 -k 1 -type impossible\n./gen -n 100 -k 50 -type opposite\n\n./gen -n 5000 -k 5000 -type max\n./gen -n 5000 -k 5000 -type random\n./gen -n 5000 -k 1 -type impossible\n./gen -n 5000 -k 5000 -type adjacent\n./gen -n 5000 -k 5000 -type opposite\n\n./gen -n 1234 -k 567 -type random\n./gen -n 4321 -k 1000 -type random\n./gen -n 5000 -k 1 -type random\n./gen -n 5000 -k 2500 -type random\n\n./gen -n 1000 -k 1 -type impossible\n./gen -n 999 -k 1 -type impossible\n\n./gen -n 5000 -k 1000 -type adjacent\n\n./gen -n 5000 -k 1 -type opposite\n./gen -n 5000 -k 2500 -type opposite\n\n./gen -n 2500 -k 2500 -type random\n./gen -n 4000 -k 3000 -type random\n\n./gen -n 2 -k 5000 -type random\n./gen -n 2 -k 5000 -type impossible\n\n./gen -n 5000 -k 1 -type random\n./gen -n 5000 -k 1 -type adjacent\n./gen -n 5000 -k 1 -type opposite\n\n./gen -n 50 -k 5000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:24.557216",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "480/D",
      "title": "D. Parcels",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers n and S (1 ≤ n ≤ 500, 0 ≤ S ≤ 1000). Then n lines follow, the i-th line contains five space-separated integers: ini, outi, wi, si and vi (0 ≤ ini < outi < 2n, 0 ≤ wi, si ≤ 1000, 1 ≤ vi ≤ 106). It is guaranteed that for any i and j (i ≠ j) either ini ≠ inj, or outi ≠ outj.",
      "output_spec": "OutputPrint a single number — the maximum sum in bourles that Jaroslav can get.",
      "sample_tests": "ExamplesInputCopy3 20 1 1 1 11 2 1 1 10 2 1 1 1OutputCopy3InputCopy5 50 6 1 2 11 2 1 1 11 3 1 1 13 6 2 1 24 5 1 1 1OutputCopy5",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two space-separated integers n and S (1 ≤ n ≤ 500, 0 ≤ S ≤ 1000). Then n lines follow, the i-th line contains five space-separated integers: ini, outi, wi, si and vi (0 ≤ ini < outi < 2n, 0 ≤ wi, si ≤ 1000, 1 ≤ vi ≤ 106). It is guaranteed that for any i and j (i ≠ j) either ini ≠ inj, or outi ≠ outj.\n\nOutputPrint a single number — the maximum sum in bourles that Jaroslav can get.\n\nInputCopy3 20 1 1 1 11 2 1 1 10 2 1 1 1OutputCopy3InputCopy5 50 6 1 2 11 2 1 1 11 3 1 1 13 6 2 1 24 5 1 1 1OutputCopy5\n\nInputCopy3 20 1 1 1 11 2 1 1 10 2 1 1 1\n\nOutputCopy3\n\nInputCopy5 50 6 1 2 11 2 1 1 11 3 1 1 13 6 2 1 24 5 1 1 1\n\nOutputCopy5\n\nNoteNote to the second sample (T is the moment in time):   T = 0: The first parcel arrives, we put in on the first platform.  T = 1: The second and third parcels arrive, we put the third one on the current top (i.e. first) parcel on the platform, then we put the secod one on the third one. Now the first parcel holds weight w2 + w3 = 2 and the third parcel holds w2 = 1.  T = 2: We deliver the second parcel and get v2 = 1 bourle. Now the first parcel holds weight w3 = 1, the third one holds 0.  T = 3: The fourth parcel comes. First we give the third parcel and get v3 = 1 bourle. Now the first parcel holds weight 0. We put the fourth parcel on it — the first one holds w4 = 2.  T = 4: The fifth parcel comes. We cannot put it on the top parcel of the platform as in that case the first parcel will carry weight w4 + w5 = 3, that exceed its strength s1 = 2, that's unacceptable. We skip the fifth parcel and get nothing for it.  T = 5: Nothing happens.  T = 6: We deliver the fourth, then the first parcel and get v1 + v4 = 3 bourles for them. Note that you could have skipped the fourth parcel and got the fifth one instead, but in this case the final sum would be 4 bourles.",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Greetings to the Codeforces community!Yet another Div1+Div2 round will take place this Sunday, 19th of October at 13:00 MSK.The round is based on the problems of the regional stage of All-Russia team school competition, which will take place at the same time in Saratov. We are aware about the overlapping with Opencup, but we have no option to shift the round, because we are bounded to the local event.The problems were prepared by HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan and me.Scoring: 500-1000-1500-2000-2500 (both divisions).UPD: Editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 586
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces",
          "content": "I am happy to present you author's ideas of solutions. Editorial of the first five problem is authored by — HolkinPV and gridnevvvit, editorial for the last two problems is written by me.479A - ExpressionIn this task you have to consider several cases and choose the best one: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - TowersThe task is solved greedily. In each iteration, move the cube from the tallest tower to the shortest one. To do this, each time find the position of minimum and maximum in the array of heights (in linear time).479C - Exams, 480A - ExamsThe solution is again greedy. Sort the exams by increasing ai, breaking ties by increasing bi. Let’s consider exams in this order and try to take the exams as early as possible. Take the first exams in this order on the early day (b1). Move to the second exam. If we can take it on the day b2 (i.e. b1 ≤ b2), do it. Otherwise, take the second exam on the day a2. Continue the process, keeping the day of the latest exam. std::sort(a, a + n); // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Long Jumps, 480B - Long JumpsIt is easy to see that the answer is always 0, 1 or 2. If we can already measure both x and y, output 0. Then try to measure both x and y by adding one more mark. If it was not successful, print two marks: one at x, other at y.So, how to check if the answer is 1? Consider all existing marks. Let some mark be at r. Try to add the new mark in each of the following positions: r - x, r + x, r - y, r + y. If it become possible to measure both x and y, you have found the answer. It is easy to check this: if, for example, we are trying to add the mark at r + x, we just check if there is a mark at r + x + y or r + x - y (by a binary search, since the marks are sorted). Make sure that the adde marks are in [0, L].479E - Riding in a Lift, 480C - Riding in a LiftThe task is solved by a dynamic programming. State is a pair (i, j), where i is the number of trips made, and j is the current floor. Initial state is (0, a), final states are (k, v), where v is any floor (except b).It is easy to see the transitions: to calculate dp(i, j), let’s see what can be the previous floor. It turns out that all possible previous floors form a contiguous segment (with a hole at position j, because we can’t visit the same floor twice in a row). So, dp(i, j) is almost equal to the sum of values dp(i - 1, t), where t belongs to some segment [l, r] (the values of l and r can be easily derived from the conditions from the problem statement). Using pretty standard technique called “partial sums” we can compute dp(i, j) in O(1), so overall complexity is O(NK).Jury solution: 8322623480D - ParcelsLet’s make two observations.First, consider the parcels as time segments [ini, outi]. It is true that if at some moment of time both parcel i and parcel j are on the platform, and i is higher than j, then .Second, let’s imagine that there are some parcels on the platform. It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them. Let’s denote this value as “residual strength”. For a parcel (or a platform itself) the residual strength is it’s strength minus the total weight of parcels on top of it. For a set of parcels, the residual strength is the minimum of individual residual strengths. So, we can put another parcel on top if it’s weight does not exceed the residual strength.These observations lead us to a dynamic programming solution. Let the top parcel at the given moment has number i, and the residual strength is rs. Make this pair (i, rs) the state of DP, because it is exactly the original problem, where the platform strength is rs and there are only parcels j with . In d(i, rs) we will store the answer to this instance of the original problem.Which transitions are there? We can choose a set of parcels i(1), i(2), ... i(k) such that outi(j) ≤ ini(j + 1), i.e. segments do not intersect (but can touch) and are sorted; the weight of each of these parcels does not exceed rs. This choice corresponds to the following sequence of actions: first put parcel i(1) on the top of i. This gets us to the state i(1), min(rs - wi(1), si(1)), so we add up the answer for this state and the cost of i(1). Then we take away all parcels, including i(1), and put the parcel i(2) on top of i, and so on.As the number of states in DP is O(NS), all transitions should take linear time. It can be achieved by making an inner helper DP. This give a solution in O(N2S). Note that for simplicity the platform can be considered as a parcel too.480E - Parking LotLet’s denote the car arrivals as events.Consider the following solution (it will help to understand the author’s idea): let’s consider all empty square in the table. There a too many of them, but imagine that we can afford to loop through all of them. If we fix a square, we can find out when it is no longer empty: find the first event that belongs to this square. Let this event has number x, and the size of the square is k. Now we can update the answers for all events with numbers less than x with a value of k.The model solution use the idea of Divide and Conquer. Let’s make a recursive routine that takes a rectangular sub-table, bounded with r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), and a list of events that happen inside this sub-table. The purpose of the routine is to consider how maximal empty squares in this sub-table change in time, and to update the answers for some of the events.Let’s assume that c2 - c1 ≤ r2 - r1 (the opposite case is symmetric). Take the middle row r = (r1 + r2) / 2. Virtually split all the squares inside the sub-table into those which lie above r, those which lie below r, and those which intersect r. For the first two parts, make two recursive calls, splitting the list of events as well. Now focus on the squares that intersect the row r.Using initial table, for each cell (r, c) we can precompute the distance to the nearest taken cell in all four directions (or the distance to the border, if there is no such cell): up(r, c), down(r, c), left(r, c) и right(r, c). Using this values, build two histograms for the row r: the first is an array of values up(r, c), where c1 ≤ c ≤ c2; the second is an array of values down(r, c), where c1 ≤ c ≤ c2. I say histograms here, because these arrays actually can be viewed as heights of empty columns, pointing from the row r upwards and downwards. Lets call the first histogram “upper”, the second one — “lower”. Now consider all events inside the sub-table in the order they happen. Each event changes a single value in a histogram. If after some event x the maximum empty square found in the histograms has size k, and the next event has number y, we can update answers for all events with numbers x, x + 1, ..., y - 1 with the value of k. It remains to learn to find a maximum square in two histograms. It can be done by a two-pointer approach. Set both pointers to the beginning. Move the second pointer until there is such square in histograms: there is a square with side length k if (minimum on the interval in the upper histogram) + (minimum on the interval in the upper histogram) — 1 >= k. When the second pointer can not be moved any more, update the answer and move the first pointer. To find the minimum in O(1), author’s solution creates a queue with minimum in O(1) support. That is, the maximum square can be found in linear time.Let’s try to estimate the running time. Each call of the routine (omitting inner calls) costs O(len·q), where len is the shortest side of the sub-table, and q is the number of events in it. If we draw a recursion tree, we will see that each second call len decreases twice. The total cost of all operations in a single level of a recursion tree is O(NK), where K is the total number of events. As long as we have O(logN), overall complexity is O(NKlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 480\\s*D"
          },
          "content_length": 8178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а is the array of pairs, where first element is the date in schedule, and second is the early date of passing\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: editorial - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int S = inf.readInt(0, 1000, \"S\");\n    inf.readEoln();\n\n    set<pair<int64_t, int64_t>> inOutTimes;\n\n    int64_t maxTime = 2LL * n - 1;\n\n    for (int i = 0; i < n; i++) {\n        int64_t ini = inf.readInt(0, maxTime, \"ini\");\n        inf.readSpace();\n        int64_t minOuti = ini + 1;\n        int64_t outi = inf.readInt(minOuti, maxTime, \"outi\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 1000, \"wi\");\n        inf.readSpace();\n        int si = inf.readInt(0, 1000, \"si\");\n        inf.readSpace();\n        int vi = inf.readInt(1, 1000000, \"vi\");\n        inf.readEoln();\n\n        pair<int64_t, int64_t> times = make_pair(ini, outi);\n\n        ensuref(inOutTimes.find(times) == inOutTimes.end(),\n                \"The pair (ini, outi) must be unique, duplicate found: (%lld, %lld)\", ini, outi);\n        inOutTimes.insert(times);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int S = inf.readInt(0, 1000, \"S\");\n    inf.readEoln();\n\n    set<pair<int64_t, int64_t>> inOutTimes;\n\n    int64_t maxTime = 2LL * n - 1;\n\n    for (int i = 0; i < n; i++) {\n        int64_t ini = inf.readInt(0, maxTime, \"ini\");\n        inf.readSpace();\n        int64_t minOuti = ini + 1;\n        int64_t outi = inf.readInt(minOuti, maxTime, \"outi\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 1000, \"wi\");\n        inf.readSpace();\n        int si = inf.readInt(0, 1000, \"si\");\n        inf.readSpace();\n        int vi = inf.readInt(1, 1000000, \"vi\");\n        inf.readEoln();\n\n        pair<int64_t, int64_t> times = make_pair(ini, outi);\n\n        ensuref(inOutTimes.find(times) == inOutTimes.end(),\n                \"The pair (ini, outi) must be unique, duplicate found: (%lld, %lld)\", ini, outi);\n        inOutTimes.insert(times);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int S = inf.readInt(0, 1000, \"S\");\n    inf.readEoln();\n\n    set<pair<int64_t, int64_t>> inOutTimes;\n\n    int64_t maxTime = 2LL * n - 1;\n\n    for (int i = 0; i < n; i++) {\n        int64_t ini = inf.readInt(0, maxTime, \"ini\");\n        inf.readSpace();\n        int64_t minOuti = ini + 1;\n        int64_t outi = inf.readInt(minOuti, maxTime, \"outi\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 1000, \"wi\");\n        inf.readSpace();\n        int si = inf.readInt(0, 1000, \"si\");\n        inf.readSpace();\n        int vi = inf.readInt(1, 1000000, \"vi\");\n        inf.readEoln();\n\n        pair<int64_t, int64_t> times = make_pair(ini, outi);\n\n        ensuref(inOutTimes.find(times) == inOutTimes.end(),\n                \"The pair (ini, outi) must be unique, duplicate found: (%lld, %lld)\", ini, outi);\n        inOutTimes.insert(times);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int S = opt<int>(\"S\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Now generate data depending on type\n    // Output should be n, S\n    // Then n lines with ini, outi, wi, si, vi\n\n    printf(\"%d %d\\n\", n, S);\n\n    vector<int> ini(n);\n    vector<int> outi(n);\n    vector<int> wi(n);\n    vector<int> si(n);\n    vector<int> vi(n);\n\n    set<pair<int,int>> times;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n - 2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini, _outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"max_vi\") {\n        // All vi = 1e6\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n - 2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini, _outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = 1000000;\n        }\n    }\n    else if (type == \"overlap_times\") {\n        // All parcels have overlapping times\n        for (int i = 0; i < n; ++i) {\n            int _ini = 0;\n            int _outi = 2*n -1 - i;\n            if(_outi <= _ini) _outi = _ini+1;\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"same_time\") {\n        // All parcels arrive at the same time\n        for (int i = 0; i < n; ++i) {\n            int _ini = 0;\n            int _outi = i + 1;\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"min_weight\") {\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = 0;\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"max_weight\") {\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = 1000;\n            si[i] = rnd.next(wi[i], 1000); // si must be at least wi\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"increasing_weights\") {\n        int weight = 1;\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = weight;\n            si[i] = rnd.next(wi[i], 1000);\n            vi[i] = rnd.next(1, 1000000);\n            weight++;\n            if (weight > 1000) weight = 1000;\n        }\n    }\n    else if (type == \"decreasing_weights\") {\n        int weight = 1000;\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = weight;\n            si[i] = rnd.next(wi[i], 1000);\n            vi[i] = rnd.next(1, 1000000);\n            weight--;\n            if (weight < 0) weight = 0;\n        }\n    }\n    else if (type == \"zero_strength\") {\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0,1000);\n            si[i] = 0;\n            vi[i] = rnd.next(1,1000000);\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n - 2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini, _outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    // Output the n parcels' data\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d %d\\n\", ini[i], outi[i], wi[i], si[i], vi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int S = opt<int>(\"S\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Now generate data depending on type\n    // Output should be n, S\n    // Then n lines with ini, outi, wi, si, vi\n\n    printf(\"%d %d\\n\", n, S);\n\n    vector<int> ini(n);\n    vector<int> outi(n);\n    vector<int> wi(n);\n    vector<int> si(n);\n    vector<int> vi(n);\n\n    set<pair<int,int>> times;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n - 2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini, _outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"max_vi\") {\n        // All vi = 1e6\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n - 2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini, _outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = 1000000;\n        }\n    }\n    else if (type == \"overlap_times\") {\n        // All parcels have overlapping times\n        for (int i = 0; i < n; ++i) {\n            int _ini = 0;\n            int _outi = 2*n -1 - i;\n            if(_outi <= _ini) _outi = _ini+1;\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"same_time\") {\n        // All parcels arrive at the same time\n        for (int i = 0; i < n; ++i) {\n            int _ini = 0;\n            int _outi = i + 1;\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"min_weight\") {\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = 0;\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"max_weight\") {\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = 1000;\n            si[i] = rnd.next(wi[i], 1000); // si must be at least wi\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"increasing_weights\") {\n        int weight = 1;\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = weight;\n            si[i] = rnd.next(wi[i], 1000);\n            vi[i] = rnd.next(1, 1000000);\n            weight++;\n            if (weight > 1000) weight = 1000;\n        }\n    }\n    else if (type == \"decreasing_weights\") {\n        int weight = 1000;\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = weight;\n            si[i] = rnd.next(wi[i], 1000);\n            vi[i] = rnd.next(1, 1000000);\n            weight--;\n            if (weight < 0) weight = 0;\n        }\n    }\n    else if (type == \"zero_strength\") {\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n -2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini,_outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0,1000);\n            si[i] = 0;\n            vi[i] = rnd.next(1,1000000);\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int _ini, _outi;\n            do {\n                _ini = rnd.next(0, 2*n - 2);\n                _outi = rnd.next(_ini+1, 2*n -1);\n            } while (times.count({_ini, _outi}));\n            times.insert({_ini, _outi});\n            ini[i] = _ini;\n            outi[i] = _outi;\n            wi[i] = rnd.next(0, 1000);\n            si[i] = rnd.next(0, 1000);\n            vi[i] = rnd.next(1, 1000000);\n        }\n    }\n    // Output the n parcels' data\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d %d\\n\", ini[i], outi[i], wi[i], si[i], vi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test with minimal n and zero strength\n./gen -n 1 -S 0 -type zero_strength\n# Test with minimal n and maximum vi\n./gen -n 1 -S 1000 -type max_vi\n# Test with maximum n and random data\n./gen -n 500 -S 1000 -type random\n# Test with maximum n and zero strength\n./gen -n 500 -S 0 -type zero_strength\n# Test with n = 100, same arrival times\n./gen -n 100 -S 500 -type same_time\n# Test with n = 200, overlapping times\n./gen -n 200 -S 300 -type overlap_times\n# Test with n = 300, minimal weights\n./gen -n 300 -S 1000 -type min_weight\n# Test with n = 400, maximum weights\n./gen -n 400 -S 1000 -type max_weight\n# Test with n = 500, increasing weights\n./gen -n 500 -S 1000 -type increasing_weights\n# Test with n = 500, decreasing weights\n./gen -n 500 -S 1000 -type decreasing_weights\n# Test with n = 500, random data\n./gen -n 500 -S 1000 -type random\n# Test with n = 250, zero box strengths\n./gen -n 250 -S 500 -type zero_strength\n# Test with n = 350, maximum vi\n./gen -n 350 -S 500 -type max_vi\n# Test with minimal S\n./gen -n 400 -S 0 -type random\n# Test with maximal S\n./gen -n 400 -S 1000 -type random\n# Test with n = 500, minimal weights and strengths\n./gen -n 500 -S 500 -type min_weight\n# Test with n = 500, maximum weights and strengths\n./gen -n 500 -S 500 -type max_weight\n# Test with n = 500, same arrival times\n./gen -n 500 -S 500 -type same_time\n# Test with n = 500, overlapping times\n./gen -n 500 -S 500 -type overlap_times\n# Test with n = 100, zero strength\n./gen -n 100 -S 100 -type zero_strength\n# Test with n = 100, increasing weights\n./gen -n 100 -S 100 -type increasing_weights\n# Test with n = 100, decreasing weights\n./gen -n 100 -S 100 -type decreasing_weights\n# Test with n = 1, maximum weights and strengths\n./gen -n 1 -S 1000 -type max_weight\n# Test with n = 1, minimal weights and strengths\n./gen -n 1 -S 0 -type min_weight\n# Test with n = 500, maximum vi and random data\n./gen -n 500 -S 1000 -type max_vi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:26.195155",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "480/E",
      "title": "E. Парковка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа n, m и k — размеры парковки и количество прибывших машин после начала Петиных наблюдений (1 ≤ n, m, k ≤ 2000). Каждая из следующих n строк содержит по m символов 'X' и '.', где 'X' означает занятое место, а '.' — свободное. Каждая из следующих k строк содержит пару чисел xi, yi — номер строки и номер столбца места, которое занимает очередная машина (1 ≤ xi ≤ n, 1 ≤ yi ≤ m). Гарантируется, что это место было свободно. Считайте, что очередная машина заезжает на парковку только тогда, когда предыдущая уже заняла свое место на парковке.",
      "output_spec": "Выходные данныеВыведите k чисел — длину стороны максимального квадрата из свободных клеток в таблице после заезда очередной машины.",
      "sample_tests": "ПримерыВходные данныеСкопировать7 8 4........X.....X..................X......................1 56 43 54 6Выходные данныеСкопировать5443",
      "description": "E. Парковка\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа n, m и k — размеры парковки и количество прибывших машин после начала Петиных наблюдений (1 ≤ n, m, k ≤ 2000). Каждая из следующих n строк содержит по m символов 'X' и '.', где 'X' означает занятое место, а '.' — свободное. Каждая из следующих k строк содержит пару чисел xi, yi — номер строки и номер столбца места, которое занимает очередная машина (1 ≤ xi ≤ n, 1 ≤ yi ≤ m). Гарантируется, что это место было свободно. Считайте, что очередная машина заезжает на парковку только тогда, когда предыдущая уже заняла свое место на парковке.\n\nВходные данные\n\nВыходные данныеВыведите k чисел — длину стороны максимального квадрата из свободных клеток в таблице после заезда очередной машины.\n\nВыходные данные\n\nВходные данныеСкопировать7 8 4........X.....X..................X......................1 56 43 54 6Выходные данныеСкопировать5443\n\nВходные данныеСкопировать7 8 4........X.....X..................X......................1 56 43 54 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5443\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #274 - Codeforces",
          "content": "Приветствую сообщество Codeforces!В воскресенье, 19 октября, в 13:00 MSK состоится очередной раунд для участников обоих дивизионов.Раунд будет основан на задачах регионального этапа Всероссийской командной олимпиады школьников, который в то же самое время будет проходить в Саратове. Мы знаем о пересечении раунда с этапом открытого кубка, но не можем перенести раунд, так как мы привязаны к олимпиаде.В подготовке задач принимали участие HolkinPV, gridnevvvit, danilka.pro, Avalanche, IlyaLos, Fefer_Ivan и я.Разбалловка стандартная: 500-1000-1500-2000-2500 (в обоих дивизионах).UPD: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14330",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 610
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces",
          "content": "Спешу познакомить вас с авторскими идеями решений задач сегодняшнего раунда. Авторы разбора первых пяти задач — HolkinPV и gridnevvvit, разбор последних двух задач написан мной.479A - ВыражениеВ этой задаче нужно было рассмотреть несколько случаев и выбрать лучших ответ. Это можно было сделать так: int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;479B - БашниЭта задача решается жадным образом. На каждой итерации нашего алгоритма будем перекладывать кубик с башни с максимальной высотой на башню с минимальной высотой. Для этого можно каждый раз за время O(N) заново находить позиции минимума и максимума в массиве. Итоговое решение тогда будет иметь асимптотику O(KN).479C - Экзамены, 480A - ЭкзаменыЭта задача решается жадным образом. Отсортируем все экзамены по неубыванию даты фактической сдачи (то есть по ai), при равенстве по неубыванию даты досрочной сдачи (то есть bi). Рассмотрим экзамены в получившемся порядке и будем поддерживать текущий ответ. В первую очередь будем стараться сдать очередной экзамен досрочно (если это не нарушит условие задачи, то есть если никакой предыщий экзамен мы не сдавали позже досрочной даты этого экзамена). В противном случае сдадим этот экзамен в дату его фактической сдачи. Обновим текущим ответ выбранной датой сдачи этого экзамена. std::sort(a, a + n); // а - массив пар, где первый элемент фактическая сдача экзамена, а второй элемент - досрочная\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}\t479D - Прыжки в длину, 480B - Прыжки в длинуНетрудно догадаться, что ответом на эту задачу может быть 0, 1 или 2. Если изначально мы можем отмерить расстояния x и y, то сразу выведем 0. Иначе попробуем получить ответ нанесением одной метки. Если это не удастся, в качестве ответа всегда можно вывести две метки, равные x и y соответственно. Чтобы проверить, можно ли получить ответ 1, переберем каждую из имеющихся отметок, пусть она находится на расстоянии r. Тогда попробуем добавить отметку на одной из позиций: r - x, r + x, r - y, r + y. Если хотя бы в одном из случаев станет возможным отмерить x и y, то можно сразу выводить полученный ответ. Проверить, что можем отмерить x и y, просто. К примеру, пусть мы сделали отметку в r + x (т.е. x мы уже научились отмерять). Тогда надо лишь проверить, что есть отметка в r + x + y или r + x - y, например, бинарным поиском (т.е. отметки отсортированы). Надо также не забыть проверить, что отметки попадают в [0, L].479E - Катаемся на лифте, 480C - Катаемся на лифтеЭта задача решается при помощи динамического программирования. Состоянием динамики будет пара (i, j), где i — количество посещенных этажей, j — номер этажа, на котором мы сейчас находимся. Начальным состоянием является пара (0, a), конечными состояниями являются пары (k, v), где v — любой этаж от 1 до n.Чтобы осуществить переход, нужно перебрать следующий посещаемый этаж и пересчитать ответ. Однако нельзя выполнять такой переход в явном виде, поскольку решение будет иметь асимптотику O(N3). Чтобы решение уложилось в требуемый лимит по времени, нужно воспользоваться частичными суммами. При переходе от i к i + 1 предпосчитаем в дополнительном массиве частичные суммы посчитанных ранее динамик (с предыдущей итерации). После этого воспользуемся динамическим программированием “назад” и при подсчете очередного значения будем делать запрос суммы на отрезке в посчитанном массиве частичных сумм. Таким образом, решение будет иметь асимптотику O(N2).Авторское решение: 8322623480D - ПосылкиСделаем два наблюдения.Во-первых, посмотрим на посылки как на отрезки [$in_i, out_i$]. Верно следующее утверждение: если коробка i оказалась в какой-то момент времени сверху коробки j (не обязательно непосредственно сверху), то .Во-вторых, представим, что на платформе находятся какие-то посылки. Оказывается, что все, что нам нужно знать про этот набор посылок, чтобы понимать, можем ли мы положить что-то сверху, это “остаточная прочность” всех этих посылок. Остаточная прочность определяется так: для каждой посылки из набора остаточная прочность равна прочности этой посылки за вычетом суммарного веса всех стоящих на ней. Для набора посылок остаточная прочность считается как минимум из остаточных прочностей посылок в наборе. Таким образом, новую посылку можно положить, если ее вес не превосходит остаточной прочности уже имеющихся коробок.Это приводит нас к идее решения задачи динамическим программированием. Пусть в данный момент времени верхняя посылка на платформе имеет номер i, а остаточная прочность имеющихся на платформе коробок равна rs. Сделаем эту пару (i, rs) состоянием динамики: представим, что у нас есть исходная задача, в которой есть только те посылки, которые вкладываются в [ini, outi], а платформа имеет прочность rs. В значении динамики d(i, rs) будем хранить ответ для этой новой задачи. Какие существуют переходы? Мы должны выбрать набор посылок i(1), i(2), ... i(k) таких, что outi(j) ≤ ini(j + 1), т.е. отрезки не пересекаются (кроме концов) и отсортированы по времени; вес любой из выбранных посылок не превосходит rs. Этот выбор соответствует следующей последовательности операций: сначала поставить сверху посылки i посылку i(1). Мы перейдем в состояние i(1), min(rs - wi(1), si(1)), прибавив к сумме стоимость коробки i(1) и ответ для нового состояния. Затем мы снимем все коробки, включая i(1), и поставим i(2), сделаем переход, затем снимем все вплоть до i(2), поставим i(3), и т.д.Поскольку количество состояний в динамике у нас получилось O(NS), то переходы должны суммарно выполняться за O(N). Этого можно добиться, реализовав внутри несложную вспомогательную динамику. Должно получиться решение со сложностью O(N2S). Отметим, что для единообразия можно считать платформу коробкой номер 0, которая приходит раньше всех, и выходит позже всех. Тогда ответ на задачу — просто значение d(0, S).480E - ПарковкаБудем называть приезды машин на парковку событиями.Рассмотрим следующее решение (оно поможет нам прийти к авторскому): давайте рассмотрим все возможные пустые квадраты в таблице. Их, конечно, много, но допустим, что мы все же можем их перебрать. Если мы зафиксировали квадрат, то давайте поймем, когда он перестанет быть пустым (найдем первое событие парковки машины в этом квадрате). Пусть номер этого события x, а размер квадрата k. Тогда для всех событий с номерами меньшими, чем x, попробуем обновить ответ значением k.Авторское решение использует принцип разделяй и властвуй. Давайте напишем рекурсивную функцию, которая принимает подтаблицу, границами которой являются r1, r2, c1, c2 (r1 ≤ r2, c1 ≤ c2), а также список всех событий парковки, которые происходят в этой подтаблице. Задача функции — рассмотреть то, как меняются максимальные пустые квадраты в этой таблице по прошествии этих событий, и попытаться обновить ответы для некоторых событий.Предположим, что c2 - c1 ≤ r2 - r1 (второй случай будет симметричным). Давайте возьмем среднюю строку подтаблицы: r = (r1 + r2) / 2. Разделим все квадраты в подтаблице на три части: те, что строго выше r, те, что строго ниже r, и те, что пересекают r. Для первых двух частей вызовемся рекурсивно (естественно, списки событий при этих вызовах будут свои). Теперь осталось только рассмотреть квадраты, пересекающие (имеющие общие клетки) со строкой r.По исходной таблице для каждой клетки (r, c) мы можем посчитать расстояние до ближайшей занятой клетки в каждом из четырех направлений (или до края, если такой нет): up(r, c), down(r, c), left(r, c) и right(r, c). Используя эту информацию, мы сейчас построим для строки r две гистограммы: первая представляет из себя массив значений up(r, c) при c1 ≤ c ≤ c2, вторая — массив значений down(r, c) при c1 ≤ c ≤ c2. Здесь я называю массивы гистограммами, потому что они фактически означают высоты столбиков из пустых клеток, начинающихся в строке r. Назовем первую гистограмуу верхней, а вторую — нижней. Рассмотрим все события, происходящие в подтаблице, в порядке их появления. Каждое событие меняет лишь одно значение в гистограмме. Пусть после мы имеем гистограммы после события с номером x, а следующие событие имеет номер y. Тогда, если мы найдем максимальный пустой квадрат в этих гистограммах (пусть его размер k), то мы сможем обновить ответы для всех событий от x до y - 1 значением k.Осталось только научиться искать максимальный квадрат в двух гистограммах. Это можно сделать с помощью метода двух указателей. Поставим первый указатель в начало. Будем двигать второй указатель до тех пор, пока в гистограммах есть такой квадрат: квадрат со стороной k имеется, если (минимум на отрезке в первой гистограмме) + (минимум на отрезке во второй гистограмме) — 1 >= k. После того, как это свойство нарушилось, двигаем первый указатель. Для того, чтобы находить минимум за O(1), авторское решение для каждой гистограммы заводит очередь с поддержкой минимума за O(1). Таким образом, поиск максимального квадрата осуществляется за линейное время.Давайте попробуем оценить время работы. Количество действий внутри одного вызова (без учета рекурсивных вызовов в половинах) равно len·q, где len — длина наименьшей из сторон подтаблицы, а q — количество событий в ней. Если мы представим себе дерево рекурсии, то увидим, что через вызов (т.е. каждый второй вызов) величина len уменьшается в два раза. Суммарное количество действий на одном уровне дерева рекурсии равно O(NK), где k — общее количество событий. Поскольку уровней в дереве O(logN), то общая асимптотика O(NKlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14351",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 480\\s*E"
          },
          "content_length": 9541
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #274 - Codeforces - Code 1",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 2",
          "code": "3\n3 2\n4 1\n6 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 3",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 4",
          "code": "4\n5 4\n5 3\n5 2\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 5",
          "code": "sorted(a, key = lambda e: e[0])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 6",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 7",
          "code": "6 20 14 15\n0 9 10 16 17 20",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 8",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 9",
          "code": "3 9 1 4\n0 6 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 10",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 11",
          "code": "3 10 3 4\n0 1 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 12",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 13",
          "code": "rep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274 - Codeforces - Code 14",
          "code": "dead[g].first >= last",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14330",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 1",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 2",
          "code": "int ans = a + b + c;\nans = max(ans, (a + b) * c);\n\tans = max(ans, a * (b + c));\n\tans = max(ans, a * b * c);\n\n\tcout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 3",
          "code": "std::sort(a, a + n);  // а - массив пар, где первый элемент фактическая сдача экзамена, а                        второй элемент - досрочная\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 4",
          "code": "std::sort(a, a + n);  // а - массив пар, где первый элемент фактическая сдача экзамена, а                        второй элемент - досрочная\nint best = -1;\nfor(int i = 0; i < n; i++) {\nif (best <= a[i].second) {\n\t\tbest = a[i].second;\n\t} else {\n\t \tbest = a[i].first;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 5",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 6",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 7",
          "code": "while (there_is_square(side: biggest_square_side + 1, containing_point: P))\n    biggest_square_side++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 8",
          "code": "there_is_square",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 9",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 10",
          "code": "for (P in reverse(points))\n    for (size_to_try = biggest_square_side + 1 ; ; size_to_try++)\n        if (there_is_square(side: biggest_square_side + 1, containing_point: P))\n        // there_is_square takes O(N log N) in my code\n            biggest_square_side = size_to_try + 1\n        else \n            break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #274: разбор задач - Codeforces - Code 11",
          "code": "biggest_square_side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14351",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    string pattern = \"[X\\\\.]{\"+to_string(m)+\"}\";\n\n    for(int i = 0; i < n; ++i) {\n        grid[i] = inf.readToken(pattern);\n        inf.readEoln();\n    }\n\n    vector<vector<char>> parking_lot(n, vector<char>(m));\n\n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            parking_lot[i][j] = grid[i][j];\n        }\n    }\n\n    for(int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n);\n        inf.readSpace();\n        int yi = inf.readInt(1, m);\n        inf.readEoln();\n\n        ensuref(parking_lot[xi-1][yi-1]=='.', \"Spot (%d, %d) is already occupied at car %d\", xi, yi, i+1);\n        parking_lot[xi-1][yi-1] = 'X';\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    string pattern = \"[X\\\\.]{\"+to_string(m)+\"}\";\n\n    for(int i = 0; i < n; ++i) {\n        grid[i] = inf.readToken(pattern);\n        inf.readEoln();\n    }\n\n    vector<vector<char>> parking_lot(n, vector<char>(m));\n\n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            parking_lot[i][j] = grid[i][j];\n        }\n    }\n\n    for(int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n);\n        inf.readSpace();\n        int yi = inf.readInt(1, m);\n        inf.readEoln();\n\n        ensuref(parking_lot[xi-1][yi-1]=='.', \"Spot (%d, %d) is already occupied at car %d\", xi, yi, i+1);\n        parking_lot[xi-1][yi-1] = 'X';\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    string pattern = \"[X\\\\.]{\"+to_string(m)+\"}\";\n\n    for(int i = 0; i < n; ++i) {\n        grid[i] = inf.readToken(pattern);\n        inf.readEoln();\n    }\n\n    vector<vector<char>> parking_lot(n, vector<char>(m));\n\n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            parking_lot[i][j] = grid[i][j];\n        }\n    }\n\n    for(int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n);\n        inf.readSpace();\n        int yi = inf.readInt(1, m);\n        inf.readEoln();\n\n        ensuref(parking_lot[xi-1][yi-1]=='.', \"Spot (%d, %d) is already occupied at car %d\", xi, yi, i+1);\n        parking_lot[xi-1][yi-1] = 'X';\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, 'X'));\n    vector<pair<int, int>> empty_positions;\n\n    if (type == \"random\") {\n        // Randomly generate grid with enough empty spots\n        int total_cells = n * m;\n        int min_empty = k;\n        int max_empty = total_cells;\n\n        int empty_cells = rnd.next(min_empty, max_empty);\n\n        // Prepare list of all positions\n        vector<pair<int, int>> all_positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                all_positions.push_back({i, j});\n\n        shuffle(all_positions.begin(), all_positions.end());\n\n        // First empty_cells positions will be empty\n        for (int idx = 0; idx < empty_cells; ++idx) {\n            int i = all_positions[idx].first;\n            int j = all_positions[idx].second;\n            grid[i][j] = '.';\n            empty_positions.push_back({i, j});\n        }\n\n    } else if (type == \"empty\") {\n        // All positions are empty\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '.');\n\n        // Prepare list of all positions\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                empty_positions.push_back({i, j});\n\n    } else if (type == \"full\") {\n        // All positions are filled except k empty spots\n        int total_cells = n * m;\n\n        if (k > total_cells)\n            k = total_cells;  // Adjust k if necessary\n\n        // Prepare list of all positions\n        vector<pair<int, int>> all_positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                all_positions.push_back({i, j});\n\n        shuffle(all_positions.begin(), all_positions.end());\n\n        // First k positions will be empty\n        for (int idx = 0; idx < k; ++idx) {\n            int i = all_positions[idx].first;\n            int j = all_positions[idx].second;\n            grid[i][j] = '.';\n            empty_positions.push_back({i, j});\n        }\n\n    } else if (type == \"square\") {\n        // Build a grid with a square empty area\n        int s = min(n, m);\n        s = rnd.next(1, s);  // Random size between 1 and min(n,m)\n\n        // Random position for the top-left corner of the square\n        int max_row = n - s;\n        int max_col = m - s;\n        int row0 = rnd.next(0, max_row);\n        int col0 = rnd.next(0, max_col);\n\n        // Fill the empty square\n        empty_positions.clear();\n        for (int i = row0; i < row0 + s; ++i)\n            for (int j = col0; j < col0 + s; ++j) {\n                grid[i][j] = '.';\n                empty_positions.push_back({i, j});\n            }\n\n        // Now, we need to select k arrival positions to reduce the maximum square size\n        set<pair<int, int>> critical_set;\n        vector<pair<int, int>> critical_positions;\n\n        int s_size = s;\n        while (s_size > 0 && (int)critical_positions.size() < k) {\n            // Positions in bottom row of the square\n            int i = row0 + s_size - 1;\n            for (int j = col0; j < col0 + s_size; ++j) {\n                pair<int, int> p = {i, j};\n                if (critical_set.insert(p).second) {\n                    critical_positions.push_back(p);\n                    if ((int)critical_positions.size() >= k)\n                        break;\n                }\n            }\n            if ((int)critical_positions.size() >= k)\n                break;\n\n            // Positions in rightmost column of the square\n            int j = col0 + s_size - 1;\n            for (int i = row0; i < row0 + s_size - 1; ++i) {\n                pair<int, int> p = {i, j};\n                if (critical_set.insert(p).second) {\n                    critical_positions.push_back(p);\n                    if ((int)critical_positions.size() >= k)\n                        break;\n                }\n            }\n            s_size--;\n        }\n\n        // If still need more positions, fill randomly from the rest\n        if ((int)critical_positions.size() < k) {\n            vector<pair<int, int>> remaining_positions;\n            for (auto p : empty_positions) {\n                if (critical_set.find(p) == critical_set.end())\n                    remaining_positions.push_back(p);\n            }\n            shuffle(remaining_positions.begin(), remaining_positions.end());\n            for (auto p : remaining_positions) {\n                critical_positions.push_back(p);\n                critical_set.insert(p);\n                if ((int)critical_positions.size() >= k)\n                    break;\n            }\n        }\n\n        empty_positions = critical_positions;\n\n    } else if (type == \"perimeter\") {\n        // Create a grid where only the perimeter is empty\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j) {\n                if (i == 0 || i == n - 1 || j == 0 || j == m -1) {\n                    grid[i][j] = '.';\n                    empty_positions.push_back({i, j});\n                }\n            }\n        // Now, we need to ensure that k ≤ number of empty positions\n        if ((int)empty_positions.size() < k) {\n            k = empty_positions.size(); // Adjust k\n        }\n        // Shuffle empty positions and select k arrival positions\n        shuffle(empty_positions.begin(), empty_positions.end());\n        empty_positions.resize(k);\n\n    } else if (type == \"custom1\") {\n        // Example of a custom pattern: Chessboard pattern of empty and filled spots\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0) {\n                    grid[i][j] = '.';\n                    empty_positions.push_back({i, j});\n                } else {\n                    grid[i][j] = 'X';\n                }\n            }\n        // Shuffle empty positions and select k arrival positions\n        if ((int)empty_positions.size() < k) {\n            k = empty_positions.size();\n        }\n        shuffle(empty_positions.begin(), empty_positions.end());\n        empty_positions.resize(k);\n\n    } else {\n        // Default to random\n        // As in the \"random\" type\n        int total_cells = n * m;\n        int min_empty = k;\n        int max_empty = total_cells;\n\n        int empty_cells = rnd.next(min_empty, max_empty);\n\n        // Prepare list of all positions\n        vector<pair<int, int>> all_positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                all_positions.push_back({i, j});\n\n        shuffle(all_positions.begin(), all_positions.end());\n\n        // First empty_cells positions will be empty\n        for (int idx = 0; idx < empty_cells; ++idx) {\n            int i = all_positions[idx].first;\n            int j = all_positions[idx].second;\n            grid[i][j] = '.';\n            empty_positions.push_back({i, j});\n        }\n    }\n\n    // Now we need to select k arrival positions from empty_positions\n    if ((int)empty_positions.size() < k) {\n        // Adjust k\n        k = empty_positions.size();\n    }\n\n    // Shuffle empty_positions\n    shuffle(empty_positions.begin(), empty_positions.end());\n\n    vector<pair<int, int>> arrival_positions;\n    for (int idx = 0; idx < k; ++idx) {\n        arrival_positions.push_back(empty_positions[idx]);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    // Now, process the arrival positions\n    for (int idx = 0; idx < k; ++idx) {\n        int i = arrival_positions[idx].first;\n        int j = arrival_positions[idx].second;\n        // Output xi yi (1-based indexing)\n        printf(\"%d %d\\n\", i + 1, j + 1);\n        // After the car parks, the spot becomes taken\n        grid[i][j] = 'X';\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, 'X'));\n    vector<pair<int, int>> empty_positions;\n\n    if (type == \"random\") {\n        // Randomly generate grid with enough empty spots\n        int total_cells = n * m;\n        int min_empty = k;\n        int max_empty = total_cells;\n\n        int empty_cells = rnd.next(min_empty, max_empty);\n\n        // Prepare list of all positions\n        vector<pair<int, int>> all_positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                all_positions.push_back({i, j});\n\n        shuffle(all_positions.begin(), all_positions.end());\n\n        // First empty_cells positions will be empty\n        for (int idx = 0; idx < empty_cells; ++idx) {\n            int i = all_positions[idx].first;\n            int j = all_positions[idx].second;\n            grid[i][j] = '.';\n            empty_positions.push_back({i, j});\n        }\n\n    } else if (type == \"empty\") {\n        // All positions are empty\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '.');\n\n        // Prepare list of all positions\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                empty_positions.push_back({i, j});\n\n    } else if (type == \"full\") {\n        // All positions are filled except k empty spots\n        int total_cells = n * m;\n\n        if (k > total_cells)\n            k = total_cells;  // Adjust k if necessary\n\n        // Prepare list of all positions\n        vector<pair<int, int>> all_positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                all_positions.push_back({i, j});\n\n        shuffle(all_positions.begin(), all_positions.end());\n\n        // First k positions will be empty\n        for (int idx = 0; idx < k; ++idx) {\n            int i = all_positions[idx].first;\n            int j = all_positions[idx].second;\n            grid[i][j] = '.';\n            empty_positions.push_back({i, j});\n        }\n\n    } else if (type == \"square\") {\n        // Build a grid with a square empty area\n        int s = min(n, m);\n        s = rnd.next(1, s);  // Random size between 1 and min(n,m)\n\n        // Random position for the top-left corner of the square\n        int max_row = n - s;\n        int max_col = m - s;\n        int row0 = rnd.next(0, max_row);\n        int col0 = rnd.next(0, max_col);\n\n        // Fill the empty square\n        empty_positions.clear();\n        for (int i = row0; i < row0 + s; ++i)\n            for (int j = col0; j < col0 + s; ++j) {\n                grid[i][j] = '.';\n                empty_positions.push_back({i, j});\n            }\n\n        // Now, we need to select k arrival positions to reduce the maximum square size\n        set<pair<int, int>> critical_set;\n        vector<pair<int, int>> critical_positions;\n\n        int s_size = s;\n        while (s_size > 0 && (int)critical_positions.size() < k) {\n            // Positions in bottom row of the square\n            int i = row0 + s_size - 1;\n            for (int j = col0; j < col0 + s_size; ++j) {\n                pair<int, int> p = {i, j};\n                if (critical_set.insert(p).second) {\n                    critical_positions.push_back(p);\n                    if ((int)critical_positions.size() >= k)\n                        break;\n                }\n            }\n            if ((int)critical_positions.size() >= k)\n                break;\n\n            // Positions in rightmost column of the square\n            int j = col0 + s_size - 1;\n            for (int i = row0; i < row0 + s_size - 1; ++i) {\n                pair<int, int> p = {i, j};\n                if (critical_set.insert(p).second) {\n                    critical_positions.push_back(p);\n                    if ((int)critical_positions.size() >= k)\n                        break;\n                }\n            }\n            s_size--;\n        }\n\n        // If still need more positions, fill randomly from the rest\n        if ((int)critical_positions.size() < k) {\n            vector<pair<int, int>> remaining_positions;\n            for (auto p : empty_positions) {\n                if (critical_set.find(p) == critical_set.end())\n                    remaining_positions.push_back(p);\n            }\n            shuffle(remaining_positions.begin(), remaining_positions.end());\n            for (auto p : remaining_positions) {\n                critical_positions.push_back(p);\n                critical_set.insert(p);\n                if ((int)critical_positions.size() >= k)\n                    break;\n            }\n        }\n\n        empty_positions = critical_positions;\n\n    } else if (type == \"perimeter\") {\n        // Create a grid where only the perimeter is empty\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j) {\n                if (i == 0 || i == n - 1 || j == 0 || j == m -1) {\n                    grid[i][j] = '.';\n                    empty_positions.push_back({i, j});\n                }\n            }\n        // Now, we need to ensure that k ≤ number of empty positions\n        if ((int)empty_positions.size() < k) {\n            k = empty_positions.size(); // Adjust k\n        }\n        // Shuffle empty positions and select k arrival positions\n        shuffle(empty_positions.begin(), empty_positions.end());\n        empty_positions.resize(k);\n\n    } else if (type == \"custom1\") {\n        // Example of a custom pattern: Chessboard pattern of empty and filled spots\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0) {\n                    grid[i][j] = '.';\n                    empty_positions.push_back({i, j});\n                } else {\n                    grid[i][j] = 'X';\n                }\n            }\n        // Shuffle empty positions and select k arrival positions\n        if ((int)empty_positions.size() < k) {\n            k = empty_positions.size();\n        }\n        shuffle(empty_positions.begin(), empty_positions.end());\n        empty_positions.resize(k);\n\n    } else {\n        // Default to random\n        // As in the \"random\" type\n        int total_cells = n * m;\n        int min_empty = k;\n        int max_empty = total_cells;\n\n        int empty_cells = rnd.next(min_empty, max_empty);\n\n        // Prepare list of all positions\n        vector<pair<int, int>> all_positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                all_positions.push_back({i, j});\n\n        shuffle(all_positions.begin(), all_positions.end());\n\n        // First empty_cells positions will be empty\n        for (int idx = 0; idx < empty_cells; ++idx) {\n            int i = all_positions[idx].first;\n            int j = all_positions[idx].second;\n            grid[i][j] = '.';\n            empty_positions.push_back({i, j});\n        }\n    }\n\n    // Now we need to select k arrival positions from empty_positions\n    if ((int)empty_positions.size() < k) {\n        // Adjust k\n        k = empty_positions.size();\n    }\n\n    // Shuffle empty_positions\n    shuffle(empty_positions.begin(), empty_positions.end());\n\n    vector<pair<int, int>> arrival_positions;\n    for (int idx = 0; idx < k; ++idx) {\n        arrival_positions.push_back(empty_positions[idx]);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    // Now, process the arrival positions\n    for (int idx = 0; idx < k; ++idx) {\n        int i = arrival_positions[idx].first;\n        int j = arrival_positions[idx].second;\n        // Output xi yi (1-based indexing)\n        printf(\"%d %d\\n\", i + 1, j + 1);\n        // After the car parks, the spot becomes taken\n        grid[i][j] = 'X';\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random grids\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 3 -m 3 -k 2 -type random\n./gen -n 10 -m 10 -k 10 -type random\n\n# Empty grids\n./gen -n 5 -m 5 -k 5 -type empty\n./gen -n 10 -m 10 -k 25 -type empty\n./gen -n 100 -m 100 -k 100 -type empty\n./gen -n 2000 -m 2000 -k 1000 -type empty\n\n# Full grids\n./gen -n 10 -m 10 -k 10 -type full\n./gen -n 100 -m 100 -k 100 -type full\n./gen -n 2000 -m 2000 -k 1000 -type full\n\n# Grids with squares\n./gen -n 10 -m 10 -k 20 -type square\n./gen -n 50 -m 50 -k 50 -type square\n./gen -n 100 -m 200 -k 100 -type square\n./gen -n 2000 -m 2000 -k 2000 -type square\n\n# Edge type grids\n./gen -n 20 -m 20 -k 10 -type edge\n./gen -n 200 -m 100 -k 50 -type edge\n./gen -n 2000 -m 2000 -k 2000 -type edge\n\n# Grids with perimeters\n./gen -n 10 -m 10 -k 36 -type perimeter\n./gen -n 100 -m 100 -k 396 -type perimeter\n./gen -n 2000 -m 2000 -k 7996 -type perimeter\n\n# Custom pattern grids\n./gen -n 10 -m 10 -k 50 -type custom1\n./gen -n 200 -m 200 -k 500 -type custom1\n\n# Maximum size grids\n./gen -n 2000 -m 2000 -k 2000 -type random\n./gen -n 2000 -m 2000 -k 2000 -type empty\n./gen -n 2000 -m 2000 -k 2000 -type full\n\n# Edge cases\n./gen -n 1 -m 1 -k 1 -type empty\n./gen -n 1 -m 2000 -k 1 -type empty\n./gen -n 2000 -m 1 -k 1 -type empty\n\n# Different k values\n./gen -n 2000 -m 2000 -k 1 -type random\n./gen -n 2000 -m 2000 -k 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:28.241703",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "482/A",
      "title": "A. Diverse Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains two space-separated positive integers n, k (1 ≤ k < n ≤ 105).",
      "output_spec": "OutputPrint n integers forming the permutation. If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy3 2OutputCopy1 3 2InputCopy3 1OutputCopy1 2 3InputCopy5 2OutputCopy1 3 2 4 5",
      "description": "A. Diverse Permutation\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains two space-separated positive integers n, k (1 ≤ k < n ≤ 105).\n\nOutputPrint n integers forming the permutation. If there are multiple answers, print any of them.\n\nInputCopy3 2OutputCopy1 3 2InputCopy3 1OutputCopy1 2 3InputCopy5 2OutputCopy1 3 2 4 5\n\nInputCopy3 2\n\nOutputCopy1 3 2\n\nInputCopy3 1\n\nOutputCopy1 2 3\n\nInputCopy5 2\n\nOutputCopy1 3 2 4 5\n\nNoteBy |x| we denote the absolute value of number x.",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Soon (on October 24, 21:00 MSK) you are lucky to participate in Codeforces Round #275 for both divisions. Pay attention to the round begining time!Problems have been prepared by team Saratov SU #3 with members: Gridnev Vitaly (gridnevvvit), Danil Sagunov (danilka.pro), Roman Kireev (RoKi).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500UPD:Contest finished, congratulations for winners!Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 726
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces",
          "content": "483A - Counterexample Problem author gridnevvvitThis problem has two possible solutions: Let's handle all possible triples and check every of them for being a counterexample. This solution works with asymptotics O(n3logA) Handle only a few cases. It could be done like this: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Jury's solution: 8394832483B - Friends and PresentsProblem author gridnevvvitJury's solution is using binary search. First, you can notice that if you can make presents with numbers 1, 2, ..., v then you can make presents with numbers 1, 2, ..., v, v + 1 too. Let f(v) be the function returning true or false: is it right, that you can make presents with numbers 1, 2, ..., v. Let f1 be the number of numbers divisible by x, f2 — the number of numbers divisible by y, and both — number of numbers divisible by x and by y (as soon as x and y are primes, it is equivalent to divisibility by x·y). Then to first friend at first we shold give f2 - both numbers, and to second friend f1 - both numbers. Then we must check, could we give all other numbers divisible neither by x nor by y.This solution works with Jury's solution: 8394846 483C - Diverse Permutation / 482A - Diverse PermutationProblem author gridnevvvitLet's see, what's the solution for some k = n - 1:1 10 2 9 3 8 4 7 5 6At the odd indexes we placed increasing sequence 1, 2, 3 .., at the even — decreasing sequence n, n - 1, n - 2, ... First, we must get the permutation the way described above, then get first k numbers from it, and then we should make all other distances be equal to 1.This solution works with O(n).Jury's solution: 8394876483D - Interesting Array / 482B - Interesting ArrayProblem author gridnevvvitWe will solve the task for every distinct bit. Now we must handle new constraint: l[i], r[i], q[i]. If number q[i] has 1 in bit with number pos, then all numbers in segment [l[i], r[i]] will have 1 in that bit too. To do that, we can use a standard idea of adding on a segment.Let's do two adding operation in s[pos] array — in position l[i] we will add 1, and in posiotion r[i] + 1 — -1. Then we will calculate partial sums of array s[pos], and if s[pos][i] > 0 (the sum on prefix length i + 1), then bit at position pos will be 1, otherwise — 0.After that, you can use segment tree to check satisfying constraints.Jury's solution: 8394894483E - Game with Strings / 482C - Game with StringsProblem author gridnevvvitLet's handle all string pairs and calculate the mask mask, which will have 1-bits only in positions in which that strings have the same characters. In other words, we could not distinguish these strings using positions with submask of mask mask, then we must add in d[mask] 1-bits in positions i и j. This way in d[mask] we store mask of strings, which we could not distinguish using only positions given in mask mask. Using information described above, we can easily calculate this dynamics.Now, when we have array d calculated, it is not hard to calculate the answer. Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos. After that we may guess some strings, they are 1-bits in mask s = d[mask] ^ d[mask | (1 << pos)]. Then you have to calculate number of bits in s quickly and update the answer.Jury's solution: 8394918482D - Random Function and TreeProblem author RoKiLet's calculate d[v][p] dynamics — the answer for vertex v with size of parity p.At first step to calculate this dynamic for vertex v we should count all different paintings of a subtree visiting all children in increasing order of their numbers. By multiplying this number by 2 we will get paintings visiting children in decreasing order. Now some paintings may count twice. To fix that, let's have a look on a some subtree of a vertex v.Consider all the parities of children subtrees visited by our function (0 or 1). First thing to note is that among these parities exist two different values, the subtree will have different paintings with different ordering (you can prove it yourself). Otherwise, all our children sizes have the same parity.If all sizes are even, this subtree will be counted twice. Otherwise, if sizes are odd, we are interested only in odd count of visited subtrees. This way, we must subtract from our dynamic the number of ways to paint any number of children with even subtree sizes and odd number of children with odd subtree sizes.Jury's solution: 8394936482E - ELCAProblem author danilka.proLet's split all M requests in blocks containing requests each. Every block will be processed following way:First using dfs we need to calculate for every vertex v, where u is every ancestor of v, sizei — size of subtree of vertex i, including itself. This value shows how will the answer change after removing or adding vertex v as child to any other vertex, furthermore, answer will change exactly by pathv·sizev (decreasing or increasing).Then we will calculate chv the same way — the number of all possible vertex pairs, which have LCA in vertex v. This value shows how the answer changes after changing Vv — if Vv changes by dVv, answer changes by chv·dVv.Then mark all vertexes, which occur in our block at least once (in worst case their number is ). Next, mark every vertex being LCA of some pair of already marked vertexes, using DFS. We can prove that final number of these vertexes is at most . After all this we got 'compressed' tree, containing only needed vertexes. Parent of vertex i in compressed tree we will call vertex numbered Pi.On the image above example of this 'compression' way is given. Vertexes colored red are vertexes in request block, blue — vertexes marked after LCA, dotted line — Pv → v edges in compressed tree.On such compressed tree we need to calculate one new value Cv for every vertex v — the size of a vertex, lying on a way from Pv to v after Pv on main (non-compressed) tree (son of a Pv vertex in main tree).Now we should process request on changing parent of vertex v from pv to u on a compressed tree. The answer will change by pathv·sizev. Now for every vertex i, lying on a way from root to Pv vertex, two values will change: sizei will be decreased by sizev, but chi will be decreased by sizev·(sizei - Ct), (Pt = i), but pathi will stay unchanged. For every other vertex j only pathj will be changed: it will be decreased by . After that, we got compressed subtree where subtree of a vertex v is missing. Next, doing the same way as above, all values are changed considering that v (and all it's subtree) is a children of a vertex u. Do not forget to change Cv too.Let's see, how the value-changing request of a vertex v is to be processed. As described above, the answer will be changed by chv·dVv. For every vertex i lying in vertex v subtree only pathi will be changed (it could be easy done using Cto values), all other values stay unchanged.This solution has complexity, but in N = M case it has to be .Авторское решение: 8394944",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 482\\s*A"
          },
          "content_length": 7065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 4",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 5",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 6",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 7",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 8",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 9",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and k from the input file.\n    int n = inf.readInt();\n    int k = inf.readInt();\n\n    // Read the permutation outputted by the contestant.\n    vector<int> p = ouf.readInts(n, 1, n, \"permutation\");\n\n    // Check if the permutation contains all numbers from 1 to n exactly once.\n    vector<bool> used(n + 1, false); // Indices from 1 to n.\n    for (int i = 0; i < n; ++i) {\n        int x = p[i];\n        if (used[x]) {\n            ouf.quitf(_wa, \"Number %d appears more than once in the permutation\", x);\n        }\n        used[x] = true;\n    }\n\n    // Compute the absolute differences between consecutive elements and collect distinct differences.\n    set<int> diffs;\n    for (int i = 0; i < n - 1; ++i) {\n        int diff = abs(p[i] - p[i + 1]);\n        diffs.insert(diff);\n    }\n\n    // Check if the number of distinct differences is exactly k.\n    if (diffs.size() != k) {\n        ouf.quitf(_wa, \"Number of distinct differences is %d instead of %d\", (int)diffs.size(), k);\n    }\n\n    // The contestant's output is correct.\n    ouf.quitf(_ok, \"Correct answer with %d distinct differences\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1 || k == -1) {\n        if (type == \"min_n_min_k\") {\n            n = 2;\n            k = 1;\n        } else if (type == \"max_n_min_k\") {\n            n = 100000;\n            k = 1;\n        } else if (type == \"max_n_max_k\") {\n            n = 100000;\n            k = n - 1;\n        } else if (type == \"mid_n_mid_k\") {\n            n = 50000 + rnd.next(0, 10000);\n            k = n / 2 + rnd.next(0, n / 2 - 1);\n        } else if (type == \"random_small\") {\n            n = rnd.next(2, 1000);\n            k = rnd.next(1, n - 1);\n        } else if (type == \"random_large\") {\n            n = 100000 - rnd.next(0, 1000);\n            k = rnd.next(1, n - 1);\n        } else if (type == \"special_k1\") {\n            n = rnd.next(2, 100000);\n            k = 1;\n        } else if (type == \"special_kn1\") {\n            n = rnd.next(2, 100000);\n            k = n - 1;\n        } else if (type == \"random\") {\n            n = rnd.next(2, 100000);\n            k = rnd.next(1, n - 1);\n        } else {\n            fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    // Ensure that n and k satisfy the constraints\n    if (n < 2 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n    if (k < 1 || k >= n) {\n        fprintf(stderr, \"Invalid k: %d for n=%d\\n\", k, n);\n        exit(1);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1 || k == -1) {\n        if (type == \"min_n_min_k\") {\n            n = 2;\n            k = 1;\n        } else if (type == \"max_n_min_k\") {\n            n = 100000;\n            k = 1;\n        } else if (type == \"max_n_max_k\") {\n            n = 100000;\n            k = n - 1;\n        } else if (type == \"mid_n_mid_k\") {\n            n = 50000 + rnd.next(0, 10000);\n            k = n / 2 + rnd.next(0, n / 2 - 1);\n        } else if (type == \"random_small\") {\n            n = rnd.next(2, 1000);\n            k = rnd.next(1, n - 1);\n        } else if (type == \"random_large\") {\n            n = 100000 - rnd.next(0, 1000);\n            k = rnd.next(1, n - 1);\n        } else if (type == \"special_k1\") {\n            n = rnd.next(2, 100000);\n            k = 1;\n        } else if (type == \"special_kn1\") {\n            n = rnd.next(2, 100000);\n            k = n - 1;\n        } else if (type == \"random\") {\n            n = rnd.next(2, 100000);\n            k = rnd.next(1, n - 1);\n        } else {\n            fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    // Ensure that n and k satisfy the constraints\n    if (n < 2 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n    if (k < 1 || k >= n) {\n        fprintf(stderr, \"Invalid k: %d for n=%d\\n\", k, n);\n        exit(1);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n_min_k\n./gen -type max_n_min_k\n./gen -type max_n_max_k\n./gen -type mid_n_mid_k\n\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n./gen -type special_k1\n./gen -type special_k1\n./gen -type special_k1\n./gen -type special_k1\n./gen -type special_k1\n\n./gen -type special_kn1\n./gen -type special_kn1\n./gen -type special_kn1\n./gen -type special_kn1\n./gen -type special_kn1\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -n 2 -k 1\n./gen -n 5 -k 2\n./gen -n 100 -k 50\n./gen -n 99999 -k 50000\n./gen -n 100000 -k 99999\n./gen -n 100000 -k 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:30.036357",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "482/B",
      "title": "B. Interesting Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n ≤ 105, 1 ≤ m ≤ 105) — the number of elements in the array and the number of limits.Each of the next m lines contains three integers li, ri, qi (1 ≤ li ≤ ri ≤ n, 0 ≤ qi < 230) describing the i-th limit.",
      "output_spec": "OutputIf the interesting array exists, in the first line print \"YES\" (without the quotes) and in the second line print n integers a[1], a[2], ..., a[n] (0 ≤ a[i] < 230) decribing the interesting array. If there are multiple answers, print any of them.If the interesting array doesn't exist, print \"NO\" (without the quotes) in the single line.",
      "sample_tests": "ExamplesInputCopy3 11 3 3OutputCopyYES3 3 3InputCopy3 21 3 31 3 2OutputCopyNO",
      "description": "B. Interesting Array\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, m (1 ≤ n ≤ 105, 1 ≤ m ≤ 105) — the number of elements in the array and the number of limits.Each of the next m lines contains three integers li, ri, qi (1 ≤ li ≤ ri ≤ n, 0 ≤ qi < 230) describing the i-th limit.\n\nOutputIf the interesting array exists, in the first line print \"YES\" (without the quotes) and in the second line print n integers a[1], a[2], ..., a[n] (0 ≤ a[i] < 230) decribing the interesting array. If there are multiple answers, print any of them.If the interesting array doesn't exist, print \"NO\" (without the quotes) in the single line.\n\nInputCopy3 11 3 3OutputCopyYES3 3 3InputCopy3 21 3 31 3 2OutputCopyNO\n\nInputCopy3 11 3 3\n\nOutputCopyYES3 3 3\n\nInputCopy3 21 3 31 3 2\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Soon (on October 24, 21:00 MSK) you are lucky to participate in Codeforces Round #275 for both divisions. Pay attention to the round begining time!Problems have been prepared by team Saratov SU #3 with members: Gridnev Vitaly (gridnevvvit), Danil Sagunov (danilka.pro), Roman Kireev (RoKi).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500UPD:Contest finished, congratulations for winners!Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 726
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces",
          "content": "483A - Counterexample Problem author gridnevvvitThis problem has two possible solutions: Let's handle all possible triples and check every of them for being a counterexample. This solution works with asymptotics O(n3logA) Handle only a few cases. It could be done like this: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Jury's solution: 8394832483B - Friends and PresentsProblem author gridnevvvitJury's solution is using binary search. First, you can notice that if you can make presents with numbers 1, 2, ..., v then you can make presents with numbers 1, 2, ..., v, v + 1 too. Let f(v) be the function returning true or false: is it right, that you can make presents with numbers 1, 2, ..., v. Let f1 be the number of numbers divisible by x, f2 — the number of numbers divisible by y, and both — number of numbers divisible by x and by y (as soon as x and y are primes, it is equivalent to divisibility by x·y). Then to first friend at first we shold give f2 - both numbers, and to second friend f1 - both numbers. Then we must check, could we give all other numbers divisible neither by x nor by y.This solution works with Jury's solution: 8394846 483C - Diverse Permutation / 482A - Diverse PermutationProblem author gridnevvvitLet's see, what's the solution for some k = n - 1:1 10 2 9 3 8 4 7 5 6At the odd indexes we placed increasing sequence 1, 2, 3 .., at the even — decreasing sequence n, n - 1, n - 2, ... First, we must get the permutation the way described above, then get first k numbers from it, and then we should make all other distances be equal to 1.This solution works with O(n).Jury's solution: 8394876483D - Interesting Array / 482B - Interesting ArrayProblem author gridnevvvitWe will solve the task for every distinct bit. Now we must handle new constraint: l[i], r[i], q[i]. If number q[i] has 1 in bit with number pos, then all numbers in segment [l[i], r[i]] will have 1 in that bit too. To do that, we can use a standard idea of adding on a segment.Let's do two adding operation in s[pos] array — in position l[i] we will add 1, and in posiotion r[i] + 1 — -1. Then we will calculate partial sums of array s[pos], and if s[pos][i] > 0 (the sum on prefix length i + 1), then bit at position pos will be 1, otherwise — 0.After that, you can use segment tree to check satisfying constraints.Jury's solution: 8394894483E - Game with Strings / 482C - Game with StringsProblem author gridnevvvitLet's handle all string pairs and calculate the mask mask, which will have 1-bits only in positions in which that strings have the same characters. In other words, we could not distinguish these strings using positions with submask of mask mask, then we must add in d[mask] 1-bits in positions i и j. This way in d[mask] we store mask of strings, which we could not distinguish using only positions given in mask mask. Using information described above, we can easily calculate this dynamics.Now, when we have array d calculated, it is not hard to calculate the answer. Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos. After that we may guess some strings, they are 1-bits in mask s = d[mask] ^ d[mask | (1 << pos)]. Then you have to calculate number of bits in s quickly and update the answer.Jury's solution: 8394918482D - Random Function and TreeProblem author RoKiLet's calculate d[v][p] dynamics — the answer for vertex v with size of parity p.At first step to calculate this dynamic for vertex v we should count all different paintings of a subtree visiting all children in increasing order of their numbers. By multiplying this number by 2 we will get paintings visiting children in decreasing order. Now some paintings may count twice. To fix that, let's have a look on a some subtree of a vertex v.Consider all the parities of children subtrees visited by our function (0 or 1). First thing to note is that among these parities exist two different values, the subtree will have different paintings with different ordering (you can prove it yourself). Otherwise, all our children sizes have the same parity.If all sizes are even, this subtree will be counted twice. Otherwise, if sizes are odd, we are interested only in odd count of visited subtrees. This way, we must subtract from our dynamic the number of ways to paint any number of children with even subtree sizes and odd number of children with odd subtree sizes.Jury's solution: 8394936482E - ELCAProblem author danilka.proLet's split all M requests in blocks containing requests each. Every block will be processed following way:First using dfs we need to calculate for every vertex v, where u is every ancestor of v, sizei — size of subtree of vertex i, including itself. This value shows how will the answer change after removing or adding vertex v as child to any other vertex, furthermore, answer will change exactly by pathv·sizev (decreasing or increasing).Then we will calculate chv the same way — the number of all possible vertex pairs, which have LCA in vertex v. This value shows how the answer changes after changing Vv — if Vv changes by dVv, answer changes by chv·dVv.Then mark all vertexes, which occur in our block at least once (in worst case their number is ). Next, mark every vertex being LCA of some pair of already marked vertexes, using DFS. We can prove that final number of these vertexes is at most . After all this we got 'compressed' tree, containing only needed vertexes. Parent of vertex i in compressed tree we will call vertex numbered Pi.On the image above example of this 'compression' way is given. Vertexes colored red are vertexes in request block, blue — vertexes marked after LCA, dotted line — Pv → v edges in compressed tree.On such compressed tree we need to calculate one new value Cv for every vertex v — the size of a vertex, lying on a way from Pv to v after Pv on main (non-compressed) tree (son of a Pv vertex in main tree).Now we should process request on changing parent of vertex v from pv to u on a compressed tree. The answer will change by pathv·sizev. Now for every vertex i, lying on a way from root to Pv vertex, two values will change: sizei will be decreased by sizev, but chi will be decreased by sizev·(sizei - Ct), (Pt = i), but pathi will stay unchanged. For every other vertex j only pathj will be changed: it will be decreased by . After that, we got compressed subtree where subtree of a vertex v is missing. Next, doing the same way as above, all values are changed considering that v (and all it's subtree) is a children of a vertex u. Do not forget to change Cv too.Let's see, how the value-changing request of a vertex v is to be processed. As described above, the answer will be changed by chv·dVv. For every vertex i lying in vertex v subtree only pathi will be changed (it could be easy done using Cto values), all other values stay unchanged.This solution has complexity, but in N = M case it has to be .Авторское решение: 8394944",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 482\\s*B"
          },
          "content_length": 7065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 4",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 5",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 6",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 7",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 8",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 9",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int qi = inf.readInt(0, (1LL << 30) - 1, \"qi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int qi = inf.readInt(0, (1LL << 30) - 1, \"qi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int qi = inf.readInt(0, (1LL << 30) - 1, \"qi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<tuple<int, int, int>> constraints;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from inf\n    n = inf.readInt();\n    m = inf.readInt();\n    for (int i = 0; i < m; i++) {\n        int l = inf.readInt() - 1; // Convert to 0-based index\n        int r = inf.readInt() - 1; // Convert to 0-based index\n        int q = inf.readInt();\n        constraints.emplace_back(l, r, q);\n    }\n\n    // Read jury's answer\n    string jans = ans.readToken();\n    // Read participant's answer\n    string pans = ouf.readToken();\n\n    if (jans != \"YES\" && jans != \"NO\")\n        quitf(_fail, \"Jury's answer is neither YES nor NO\");\n\n    if (pans != \"YES\" && pans != \"NO\")\n        quitf(_pe, \"Contestant's answer is neither YES nor NO\");\n\n    if (jans == \"NO\") {\n        // Jury says no solution exists\n        if (pans == \"NO\") {\n            // Both say NO, accept\n            quitf(_ok, \"Correct, no solution exists\");\n        } else {\n            // Contestant outputs YES, check if his solution is valid\n            vector<long long> a = ouf.readLongs(n, 0LL, (1LL << 30) - 1LL);\n            // Validate a\n            bool valid = true;\n            for (size_t idx = 0; idx < constraints.size(); ++idx) {\n                int l = get<0>(constraints[idx]);\n                int r = get<1>(constraints[idx]);\n                int q = get<2>(constraints[idx]);\n                long long res = (1LL << 30) - 1LL;\n                for (int i = l; i <= r; ++i) {\n                    res &= a[i];\n                }\n                if (res != q) {\n                    valid = false;\n                    quitf(_wa, \"Participant's solution is invalid: constraint %d not satisfied\", idx + 1);\n                }\n            }\n            if (valid) {\n                // Contestant found solution when jury says none exists\n                quitf(_fail, \"Participant found a solution, but jury says none exists\");\n            }\n        }\n    } else {\n        // Jury says solution exists\n        if (pans == \"NO\") {\n            // Contestant says no solution exists, but solution exists\n            quitf(_wa, \"Contestant says no solution exists, but solution exists\");\n        } else {\n            // Contestant outputs YES, check his array\n            vector<long long> a = ouf.readLongs(n, 0LL, (1LL << 30) - 1LL);\n            // Validate a\n            bool valid = true;\n            for (size_t idx = 0; idx < constraints.size(); ++idx) {\n                int l = get<0>(constraints[idx]);\n                int r = get<1>(constraints[idx]);\n                int q = get<2>(constraints[idx]);\n                long long res = (1LL << 30) - 1LL;\n                for (int i = l; i <= r; ++i) {\n                    res &= a[i];\n                }\n                if (res != q) {\n                    valid = false;\n                    quitf(_wa, \"Constraint %d not satisfied\", idx + 1);\n                }\n            }\n            if (valid) {\n                quitf(_ok, \"Contestant's solution is correct\");\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int,int,int>> constraints;\n\n    if (type == \"random\") {\n        // Generate random constraints\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"conflict\") {\n        // Generate conflicting constraints\n        if (m < 2) m = 2;\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        int conflicting_bit = rnd.next(0,29);\n        int q1 = rnd.next(0, (1<<30)-1);\n        int q2 = q1 ^ (1 << conflicting_bit);\n\n        constraints.push_back(make_tuple(l, r, q1));\n        constraints.push_back(make_tuple(l, r, q2));\n\n        for (int i = 2; i < m; i++) {\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"nosolution\") {\n        // Generate constraints that lead to no solution\n        if (m < 2) m = 2;\n        int l = 1;\n        int r = n;\n        int conflicting_bit = rnd.next(0,29);\n        int q1 = rnd.next(0, (1<<30)-1);\n        int q2 = q1 ^ (1 << conflicting_bit);\n\n        constraints.push_back(make_tuple(l, r, q1));\n        constraints.push_back(make_tuple(l, r, q2));\n\n        for (int i = 2; i < m; i++) {\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"fulloverlap\") {\n        // Constraints over the full array\n        for (int i = 0; i < m; i++) {\n            int l = 1;\n            int r = n;\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"singles\") {\n        // Constraints on single elements\n        for (int i = 0; i < m; i++) {\n            int pos = rnd.next(1, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(pos, pos, q));\n        }\n    } else if (type == \"maxbits\") {\n        // Constraints forcing bits to be set\n        int bits_set = opt<int>(\"bits_set\", 30);\n        unsigned int q = (1u << bits_set) - 1;\n        q = q & ((1u << 30) - 1);\n\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"minbits\") {\n        // Constraints forcing bits to be unset\n        int bits_zero = opt<int>(\"bits_zero\", 30);\n        unsigned int q = (1u << 30) - 1;\n        for (int i = 0; i < bits_zero; i++) {\n            q &= ~(1u << i);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"chain\") {\n        // Constraints in a chain manner\n        int l = 1;\n        while (constraints.size() < m && l <= n) {\n            int r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n            l = r + 1;\n        }\n        while (constraints.size() < m) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else {\n        // Default random constraints\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; i++) {\n        int l, r, q;\n        tie(l, r, q) = constraints[i];\n        printf(\"%d %d %d\\n\", l, r, q);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int,int,int>> constraints;\n\n    if (type == \"random\") {\n        // Generate random constraints\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"conflict\") {\n        // Generate conflicting constraints\n        if (m < 2) m = 2;\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        int conflicting_bit = rnd.next(0,29);\n        int q1 = rnd.next(0, (1<<30)-1);\n        int q2 = q1 ^ (1 << conflicting_bit);\n\n        constraints.push_back(make_tuple(l, r, q1));\n        constraints.push_back(make_tuple(l, r, q2));\n\n        for (int i = 2; i < m; i++) {\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"nosolution\") {\n        // Generate constraints that lead to no solution\n        if (m < 2) m = 2;\n        int l = 1;\n        int r = n;\n        int conflicting_bit = rnd.next(0,29);\n        int q1 = rnd.next(0, (1<<30)-1);\n        int q2 = q1 ^ (1 << conflicting_bit);\n\n        constraints.push_back(make_tuple(l, r, q1));\n        constraints.push_back(make_tuple(l, r, q2));\n\n        for (int i = 2; i < m; i++) {\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"fulloverlap\") {\n        // Constraints over the full array\n        for (int i = 0; i < m; i++) {\n            int l = 1;\n            int r = n;\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"singles\") {\n        // Constraints on single elements\n        for (int i = 0; i < m; i++) {\n            int pos = rnd.next(1, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(pos, pos, q));\n        }\n    } else if (type == \"maxbits\") {\n        // Constraints forcing bits to be set\n        int bits_set = opt<int>(\"bits_set\", 30);\n        unsigned int q = (1u << bits_set) - 1;\n        q = q & ((1u << 30) - 1);\n\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"minbits\") {\n        // Constraints forcing bits to be unset\n        int bits_zero = opt<int>(\"bits_zero\", 30);\n        unsigned int q = (1u << 30) - 1;\n        for (int i = 0; i < bits_zero; i++) {\n            q &= ~(1u << i);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else if (type == \"chain\") {\n        // Constraints in a chain manner\n        int l = 1;\n        while (constraints.size() < m && l <= n) {\n            int r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n            l = r + 1;\n        }\n        while (constraints.size() < m) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    } else {\n        // Default random constraints\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int q = rnd.next(0, (1<<30)-1);\n            constraints.push_back(make_tuple(l, r, q));\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; i++) {\n        int l, r, q;\n        tie(l, r, q) = constraints[i];\n        printf(\"%d %d %d\\n\", l, r, q);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type singles\n./gen -n 2 -m 2 -type conflict\n./gen -n 5 -m 5 -type nosolution\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 5 -type fulloverlap\n./gen -n 10 -m 10 -type singles\n./gen -n 100 -m 100 -type chain\n./gen -n 100 -m 50 -type maxbits -bits_set 10\n./gen -n 100 -m 50 -type minbits -bits_zero 10\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type conflict\n./gen -n 1000 -m 500 -type fulloverlap\n./gen -n 10000 -m 10000 -type chain\n./gen -n 10000 -m 5000 -type maxbits -bits_set 15\n./gen -n 10000 -m 5000 -type minbits -bits_zero 15\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type conflict\n./gen -n 100000 -m 100000 -type nosolution\n./gen -n 100000 -m 50000 -type fulloverlap\n./gen -n 100000 -m 50000 -type chain\n./gen -n 100000 -m 50000 -type singles\n./gen -n 100000 -m 100000 -type maxbits -bits_set 30\n./gen -n 100000 -m 100000 -type minbits -bits_zero 30\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:32.271493",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "482/C",
      "title": "C. Игра со строками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 50) — количество строк, придуманных вашим другом.В следующих n строках заданы строки, придуманные вашим другом. Гарантируется, что все строки различны и состоят только из строчных и прописных букв латинского алфавита. Кроме того, длины всех строк одинаковы и лежат в промежутке от 1 до 20 включительно.",
      "output_spec": "Выходные данныеВыведите единственное число — искомое математическое ожидание. Ваш ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 9.",
      "sample_tests": "ПримерыВходные данныеСкопировать2aabaacВыходные данныеСкопировать2.000000000000000Входные данныеСкопировать3aaAaBaCaaВыходные данныеСкопировать1.666666666666667Входные данныеСкопировать3acavacwqqВыходные данныеСкопировать1.000000000000000",
      "description": "C. Игра со строками\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 50) — количество строк, придуманных вашим другом.В следующих n строках заданы строки, придуманные вашим другом. Гарантируется, что все строки различны и состоят только из строчных и прописных букв латинского алфавита. Кроме того, длины всех строк одинаковы и лежат в промежутке от 1 до 20 включительно.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — искомое математическое ожидание. Ваш ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 9.\n\nВыходные данные\n\nВходные данныеСкопировать2aabaacВыходные данныеСкопировать2.000000000000000Входные данныеСкопировать3aaAaBaCaaВыходные данныеСкопировать1.666666666666667Входные данныеСкопировать3acavacwqqВыходные данныеСкопировать1.000000000000000\n\nВходные данныеСкопировать2aabaac\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3aaAaBaCaa\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.666666666666667\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3acavacwqq\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере придуманные строки различаются только символом в третьей позиции. Поэтому возможны следующие ситуации:   вы угадаете загаданную строку за один вопрос. Вероятность этого события ;  вы угадаете загаданную строку за два вопроса. Вероятность этого события равна  ·  =  (поскольку в таком случае первым вопросом нужно спросить про позицию отличную от трех);  вы угадаете загаданную строку за три вопроса. Вероятность этого события равна  ·  ·  = ; Таким образом искомое математическое ожидание равно Во втором примере нам максимум может потребоваться два вопроса, поскольку любая пара вопросов определяет строку. Поэтому искомое математическое ожидание равно .В третьем примере, независимо от того, про какую позицию мы спросим первым вопросом, мы сразу угадаем загаданную строку.",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Скоро, 24 октября, 21:00 MSK, состоится очередной Codeforces Round #275 для участников из обоих дивизионов. Обратите внимание на необычное время старта раунда!Задачи этого раунда готовила команда Саратовского ГУ #3 в составе: Гриднев Виталий (gridnevvvit), Данил Сагунов (danilka.pro), Роман Киреев (RoKi).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Распределение баллов:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500Соревнование закончено, поздравляем победителей!UPD:Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 740
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces",
          "content": "483A - Опровержение гипотезАвтор задачи gridnevvvitВ задаче предполагалось два решения: Перебрать всевозможные тройки, и проверить, правда ли, что для этой тройки гипотеза неверна. Асимптотика такого решения O(n3logA) Разобрать несколько случаев. Например, это можно сделать так: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Авторское решение: 8394832483B - Друзья и подаркиАвтор задачи gridnevvvitАвторское решение — бинпоиск по ответу. Во-первых, заметим, что если из набора 1, 2, ..., v можно собрать подарки, то и из набора 1, 2, ..., v, v + 1 можно собрать подарки. Пусть f(v) — функция, возвращающая ответ на вопрос: правда ли, что из набора 1, 2, ..., v можно собрать подарки друзьям. пусть f1 — количество чисел, которые делятся на x, а f2 — количество чисел, которые делятся на y. и число both — количество чисел которые делятся и на x, и на y. Тогда в первую очередь первому другу мы постараемся отдать f2 - both чисел, а второму — f1 - both чисел. После этого нужно проверить, сможем ли мы раздать числа, которые не делятся ни на одно из чисел x и y.Таким образом, решение за Авторское решение: 8394846 483C - Разнообразная перестановка / 482A - Разнообразная перестановкаАвтор задачи gridnevvvitРазберем, как работает решение на большом примере, например 1 10 2 9 3 8 4 7 5 6На нечетных местах мы имеем возрастающую последовательность 1, 2, 3 .., а на четных — убывающую последовательность n, n - 1, n - 2, ... Получим таким образом решение, выведем первые k чисел указанной выше последовательности, а потом сделаем так, чтобы соседние разности были равны единице.Решение за асимптотику O(n).Авторское решение: 8394876 483D - Интересный массив / 482B - Интересный массивАвтор задачи gridnevvvitБудем решать задачу отдельно для каждого бита. Предположим, что пришло новое ограничение: l[i], r[i], q[i]. Если в числе q[i] бит с номером pos единичный, то у всех чисел на отрезке [l[i], r[i]] этот бит тоже будет единичным. Теперь можно воспользоваться стандартной идеей прибавления на отрезке оффлайн. Сделаем два прибавления в массиве s[bit] — в позиции l[i] мы сделаем прибавление 1, а еще одно в позиции r[i] + 1, там мы прибавим -1. Таким образом, если мы насчитаем частичные суммы на массиве s[bit], то, если s[bit][i] > 0, то бит bit в этом числе будет единичным, иначе — нет. После этого можно реализовать дерево отрезков, чтобы проверить выполнимость изначальных запросов.Авторское решение: 8394894 483E - Игра со строками / 482C - Игра со строкамиАвтор задачи gridnevvvitПереберем все пары строк, и подсчитаем маску mask — единичные биты будут находится только в позициях, в которых эти две пары строк имеют одинаковые символы. Таким образом, используя биты, соответствующие любой подмаске маски mask, мы не сможем отличить эту пару строк, поэтому добавим в маску d[mask] биты в позиции i и j. Таким образом, в d[mask] мы храним маску тех строк, которые мы не сможем отличить по заданной маске mask. Используя указанную выше информацию, мы сможем просто насчитать эту динамику.Теперь, когда у нас имеется эта динамика, нетрудно восстановить ответ. Переберем маску mask. Попробуем задать еще один вопрос, то есть добавить в эту маску еще один бит. После этого мы могли отгадать некоторые строки, а именно те, что останутся в виде единичных битов в маске s = d[mask] ^ d[mask | (1 << pos)] (pos — позиция нового вопроса). Осталось аккуратно подсчитать количество бит в маске s и пересчитать искомое математическое ожидание.Авторское решение: 8394918 482D - Случайная функция и деревоАвтор задачи RoKiПосчитаем динамику d[v][p] — ответ на задачу для поддерева вершины v с размером, имеющим четность p.Научимся считать эту динамику для вершины v. Для начала посчитаем количество различных раскрасок при обходе потомков в порядке возрастания номеров. Умножим эту величину на 2 и получим раскраски при обходе потомков в порядке убывания номеров. Но теперь, возможно, появились раскраски, которые мы учли 2 раза. Давайте рассмотрим некоторое поддерево вершины v и поймем, когда оно учтется 2 раза.Рассмотрим четности поддеревьев потомков, которых посетила наша функция (0 или 1). Первое, что нужно заметить: если среди этих величин есть различные значения, то такое поддерево при разных обходах будет раскрашено по-разному (это вы можете доказать сами). Теперь все наши посещенные потомки имеют одинаковые по четности размеры поддеревьев. Если размеры поддеревьев четные, то очевидно, что такое дерево учтется 2 раза. А вот если размеры поддеревьев нечетные, то нас интересуют только случаи, когда мы посетили нечетное количество потомков. Таким образом, из нашей динамики нужно вычесть количество способов раскрасить любое количество потомков с четным размером поддерева и нечетное количество потомков с нечетным размером поддерева.Авторское решение: 8394936 482E - ELCAАвтор задачи danilka.proБудем обрабатывать M запросов блоками по штук (таких блоков, очевидно, тоже ). Каждый блок обрабатывается следующим образом:Сначала поиском в глубину посчитаем для каждой вершины v значение , где u — любой предок v, а sizei — размер поддерева вершины i, включая саму вершину. Эта величина характеризует изменение ответа при 'отрывании' или 'прикреплении' вершины v, а именно, после выполнения одной из этих операций ответ изменится на pathv·sizev (уменьшится или увеличится соответственно).Тем же образом посчитаем значение chv — количество всевозможных пар вершин, наименьший общий предок которых равен v. Эта величина характеризует изменение ответа при изменении Vv, а именно, при изменении величины Vv на dVv ответ изменится на chv·dVv.Выделим вершины, номера которых хотя бы один раз встречаются в нашем блоке (в худшем случае таких вершин ). Теперь запустим поиск в глубину, который отметит вершины, являющиеся наименьшими общими предками каких-либо двух выделенных вершин. С помощью метода математической индукции нетрудно доказать, что в худшем случае таких вершин будет ровно . Таким образом мы получили 'сжатое' дерево, содержащее только необходимые вершины. Предка вершины i сжатого дерева обозначим за Pi.На следующем рисунке представлен пример такого 'сжатия'. Красным обозначены вершины в блоке запроса, синим — помеченные вершины, пунктиром — ребра Pv → v сжатого дерева.На таком сжатом дереве нужно посчитать для каждой вершины v еще одну величину Cv — размер поддерева вершины исходного дерева, которая лежит на пути от Pv до v в исходном дереве после Pv (непосредственный сын Pv).Попробуем обработать запрос на смену родителя вершины v с pv на u в сжатом дереве. Ответ, как уже было сказано выше, сначала уменьшится на pathv·sizev. Теперь для каждой вершины i, лежащей на пути от корня до Pv, изменятся две величины: sizei уменьшится на sizev, а chi уменьшится на величину, равную sizev·(sizei - Ct), (Pt = i), а pathi останется прежним. Для всех остальных вершин j, напротив, изменится лишь величина pathj — она уменьшится на . Теперь мы получили сжатое дерево, в котором все величины посчитаны с учетом того, что поддерево вершины v было удалено. Аналогичным образом происходит пересчет величин с учетом добавления вершины v в качестве сына вершины u (не забываем обновлять также и Cv).Посмотрим, как будет выглядеть обработка запроса на смену значения Vv вершины v. Ответ, как было описано, изменится на chv·dVv. Также изменятся все pathi для вершин, лежащих в поддереве v (их несложно пересчитать с помощью значений Cto, все остальные значения останутся прежними.Таким образом, сложность решения составляет , что в случае N = M составляет . Авторское решение: 8394944",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 482\\s*C"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "n - a >= cnt1 && n - b >= cnt2 && n - c >= cnt1 + cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "c = n / ( x + y )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "n - a >= cnt1 && n - b >= cnt2 && n - c >= cnt1 + cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "n - b - f < cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "a = 6 / 2 = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "b = 6 / 3 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "n - a >= cnt1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "n - b >= cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "c = 6 / ( 2 + 3 ) = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "n - c = 5 < 3 + 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "c = n / (x*y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 19",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 20",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 21",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 22",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 23",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 24",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 25",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 26",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 27",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 28",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 29",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 4",
          "code": "O(2^length * n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 5",
          "code": "O(n*length*length)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 6",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 7",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 8",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 9",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 10",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 11",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<string> s(n);\n    set<string> s_set;\n    int len = -1;\n    for (int i = 0; i < n; i++) {\n        s[i] = inf.readLine(\"[a-zA-Z]{1,20}\", format(\"string[%d]\", i+1));\n        if (len == -1) {\n            len = s[i].length();\n        } else {\n            ensuref((int)s[i].length() == len, \n                \"All strings must have same length, but string[%d] has length %d, expected length %d\", \n                i+1, (int)s[i].length(), len);\n        }\n        ensuref(s_set.insert(s[i]).second, \n            \"All strings must be distinct, but string[%d] is duplicated\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<string> s(n);\n    set<string> s_set;\n    int len = -1;\n    for (int i = 0; i < n; i++) {\n        s[i] = inf.readLine(\"[a-zA-Z]{1,20}\", format(\"string[%d]\", i+1));\n        if (len == -1) {\n            len = s[i].length();\n        } else {\n            ensuref((int)s[i].length() == len, \n                \"All strings must have same length, but string[%d] has length %d, expected length %d\", \n                i+1, (int)s[i].length(), len);\n        }\n        ensuref(s_set.insert(s[i]).second, \n            \"All strings must be distinct, but string[%d] is duplicated\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<string> s(n);\n    set<string> s_set;\n    int len = -1;\n    for (int i = 0; i < n; i++) {\n        s[i] = inf.readLine(\"[a-zA-Z]{1,20}\", format(\"string[%d]\", i+1));\n        if (len == -1) {\n            len = s[i].length();\n        } else {\n            ensuref((int)s[i].length() == len, \n                \"All strings must have same length, but string[%d] has length %d, expected length %d\", \n                i+1, (int)s[i].length(), len);\n        }\n        ensuref(s_set.insert(s[i]).second, \n            \"All strings must be distinct, but string[%d] is duplicated\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> strings(n);\n    if (type == \"random\") {\n        // Generate n random distinct strings of length m\n        set<string> sset;\n        while ((int)sset.size() < n) {\n            string s = \"\";\n            for (int i = 0; i < m; ++i) {\n                int idx = rnd.next(52);\n                char c;\n                if (idx < 26) c = 'a' + idx;\n                else c = 'A' + (idx - 26);\n                s += c;\n            }\n            sset.insert(s);\n        }\n        strings.assign(sset.begin(), sset.end());\n    } else if (type == \"one_diff\") {\n        // Generate base string\n        string base = \"\";\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(52);\n            char c;\n            if (idx < 26) c = 'a' + idx;\n            else c = 'A' + (idx - 26);\n            base += c;\n        }\n        // Choose position p where strings differ\n        int p = rnd.next(m);\n        // Generate list of letters\n        vector<char> letters;\n        for (int idx = 0; idx < 52; ++idx) {\n            if (idx < 26) letters.push_back('a' + idx);\n            else letters.push_back('A' + (idx - 26));\n        }\n        shuffle(letters.begin(), letters.end());\n        // Ensure we have enough letters\n        ensure(n <= (int)letters.size());\n        for (int i = 0; i < n; ++i) {\n            string s = base;\n            s[p] = letters[i];\n            strings[i] = s;\n        }\n    } else if (type == \"full_diff\") {\n        // For each position, assign n different letters\n        vector<vector<char>> positions(m, vector<char>(n));\n        for (int i = 0; i < m; ++i) {\n            // Generate letters\n            vector<char> letters;\n            for (int idx = 0; idx < 52; ++idx) {\n                if (idx < 26) letters.push_back('a' + idx);\n                else letters.push_back('A' + (idx - 26));\n            }\n            shuffle(letters.begin(), letters.end());\n            ensure(n <= (int)letters.size());\n            for (int j = 0; j < n; ++j) {\n                positions[i][j] = letters[j];\n            }\n        }\n        for (int j = 0; j < n; ++j) {\n            string s = \"\";\n            for (int i = 0; i < m; ++i) {\n                s += positions[i][j];\n            }\n            strings[j] = s;\n        }\n    } else if (type == \"partial_diff\") {\n        // Need to get k\n        int k = opt<int>(\"k\");\n        ensure(1 <= k && k <= m);\n        // Generate base string\n        string base = \"\";\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(52);\n            char c;\n            if (idx < 26) c = 'a' + idx;\n            else c = 'A' + (idx - 26);\n            base += c;\n        }\n        // Choose k positions to differ\n        vector<int> positions(m);\n        for (int i = 0; i < m; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        positions.resize(k);\n        // For each of the k positions, assign n different letters\n        map<int, vector<char>> pos_letters;\n        for (int idx : positions) {\n            vector<char> letters;\n            for (int i = 0; i < 52; ++i) {\n                if (i < 26) letters.push_back('a' + i);\n                else letters.push_back('A' + (i - 26));\n            }\n            shuffle(letters.begin(), letters.end());\n            ensure(n <= (int)letters.size());\n            pos_letters[idx] = vector<char>(letters.begin(), letters.begin() + n);\n        }\n        // Generate strings\n        for (int i = 0; i < n; ++i) {\n            string s = base;\n            for (int idx : positions) {\n                s[idx] = pos_letters[idx][i];\n            }\n            strings[i] = s;\n        }\n    } else {\n        // Default to random\n        // (same as 'random' type)\n        set<string> sset;\n        while ((int)sset.size() < n) {\n            string s = \"\";\n            for (int i = 0; i < m; ++i) {\n                int idx = rnd.next(52);\n                char c;\n                if (idx < 26) c = 'a' + idx;\n                else c = 'A' + (idx - 26);\n                s += c;\n            }\n            sset.insert(s);\n        }\n        strings.assign(sset.begin(), sset.end());\n    }\n    // Now output n\n    printf(\"%d\\n\", n);\n    // Output strings\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", strings[i].c_str());\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> strings(n);\n    if (type == \"random\") {\n        // Generate n random distinct strings of length m\n        set<string> sset;\n        while ((int)sset.size() < n) {\n            string s = \"\";\n            for (int i = 0; i < m; ++i) {\n                int idx = rnd.next(52);\n                char c;\n                if (idx < 26) c = 'a' + idx;\n                else c = 'A' + (idx - 26);\n                s += c;\n            }\n            sset.insert(s);\n        }\n        strings.assign(sset.begin(), sset.end());\n    } else if (type == \"one_diff\") {\n        // Generate base string\n        string base = \"\";\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(52);\n            char c;\n            if (idx < 26) c = 'a' + idx;\n            else c = 'A' + (idx - 26);\n            base += c;\n        }\n        // Choose position p where strings differ\n        int p = rnd.next(m);\n        // Generate list of letters\n        vector<char> letters;\n        for (int idx = 0; idx < 52; ++idx) {\n            if (idx < 26) letters.push_back('a' + idx);\n            else letters.push_back('A' + (idx - 26));\n        }\n        shuffle(letters.begin(), letters.end());\n        // Ensure we have enough letters\n        ensure(n <= (int)letters.size());\n        for (int i = 0; i < n; ++i) {\n            string s = base;\n            s[p] = letters[i];\n            strings[i] = s;\n        }\n    } else if (type == \"full_diff\") {\n        // For each position, assign n different letters\n        vector<vector<char>> positions(m, vector<char>(n));\n        for (int i = 0; i < m; ++i) {\n            // Generate letters\n            vector<char> letters;\n            for (int idx = 0; idx < 52; ++idx) {\n                if (idx < 26) letters.push_back('a' + idx);\n                else letters.push_back('A' + (idx - 26));\n            }\n            shuffle(letters.begin(), letters.end());\n            ensure(n <= (int)letters.size());\n            for (int j = 0; j < n; ++j) {\n                positions[i][j] = letters[j];\n            }\n        }\n        for (int j = 0; j < n; ++j) {\n            string s = \"\";\n            for (int i = 0; i < m; ++i) {\n                s += positions[i][j];\n            }\n            strings[j] = s;\n        }\n    } else if (type == \"partial_diff\") {\n        // Need to get k\n        int k = opt<int>(\"k\");\n        ensure(1 <= k && k <= m);\n        // Generate base string\n        string base = \"\";\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(52);\n            char c;\n            if (idx < 26) c = 'a' + idx;\n            else c = 'A' + (idx - 26);\n            base += c;\n        }\n        // Choose k positions to differ\n        vector<int> positions(m);\n        for (int i = 0; i < m; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        positions.resize(k);\n        // For each of the k positions, assign n different letters\n        map<int, vector<char>> pos_letters;\n        for (int idx : positions) {\n            vector<char> letters;\n            for (int i = 0; i < 52; ++i) {\n                if (i < 26) letters.push_back('a' + i);\n                else letters.push_back('A' + (i - 26));\n            }\n            shuffle(letters.begin(), letters.end());\n            ensure(n <= (int)letters.size());\n            pos_letters[idx] = vector<char>(letters.begin(), letters.begin() + n);\n        }\n        // Generate strings\n        for (int i = 0; i < n; ++i) {\n            string s = base;\n            for (int idx : positions) {\n                s[idx] = pos_letters[idx][i];\n            }\n            strings[i] = s;\n        }\n    } else {\n        // Default to random\n        // (same as 'random' type)\n        set<string> sset;\n        while ((int)sset.size() < n) {\n            string s = \"\";\n            for (int i = 0; i < m; ++i) {\n                int idx = rnd.next(52);\n                char c;\n                if (idx < 26) c = 'a' + idx;\n                else c = 'A' + (idx - 26);\n                s += c;\n            }\n            sset.insert(s);\n        }\n        strings.assign(sset.begin(), sset.end());\n    }\n    // Now output n\n    printf(\"%d\\n\", n);\n    // Output strings\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", strings[i].c_str());\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 20 -type random\n./gen -n 50 -m 1 -type random\n./gen -n 50 -m 20 -type random\n\n./gen -n 2 -m 5 -type one_diff\n./gen -n 10 -m 10 -type one_diff\n./gen -n 50 -m 15 -type one_diff\n./gen -n 50 -m 20 -type one_diff\n\n./gen -n 2 -m 5 -type full_diff\n./gen -n 10 -m 5 -type full_diff\n./gen -n 50 -m 5 -type full_diff\n./gen -n 50 -m 10 -type full_diff\n./gen -n 50 -m 20 -type full_diff\n\n./gen -n 2 -m 5 -type partial_diff -k 1\n./gen -n 10 -m 10 -type partial_diff -k 1\n./gen -n 50 -m 20 -type partial_diff -k 1\n\n./gen -n 2 -m 5 -type partial_diff -k 3\n./gen -n 10 -m 10 -type partial_diff -k 5\n./gen -n 20 -m 20 -type partial_diff -k 10\n./gen -n 50 -m 20 -type partial_diff -k 10\n\n./gen -n 2 -m 5 -type partial_diff -k 5\n./gen -n 10 -m 10 -type partial_diff -k 10\n./gen -n 20 -m 15 -type partial_diff -k 15\n./gen -n 50 -m 20 -type partial_diff -k 20\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:34.162990",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "482/D",
      "title": "D. Random Function and Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of vertexes in the tree.The second line contains n - 1 integers p2, p3, ..., pn (1 ≤ pi < i). Number pi is the parent of vertex i.",
      "output_spec": "OutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7)",
      "sample_tests": "ExamplesInputCopy41 2 1OutputCopy8InputCopy31 1OutputCopy5",
      "description": "D. Random Function and Tree\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of vertexes in the tree.The second line contains n - 1 integers p2, p3, ..., pn (1 ≤ pi < i). Number pi is the parent of vertex i.\n\nOutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7)\n\nInputCopy41 2 1OutputCopy8InputCopy31 1OutputCopy5\n\nInputCopy41 2 1\n\nOutputCopy8\n\nInputCopy31 1\n\nOutputCopy5\n\nNoteAll possible coloring patterns of the first sample are given below.",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Soon (on October 24, 21:00 MSK) you are lucky to participate in Codeforces Round #275 for both divisions. Pay attention to the round begining time!Problems have been prepared by team Saratov SU #3 with members: Gridnev Vitaly (gridnevvvit), Danil Sagunov (danilka.pro), Roman Kireev (RoKi).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500UPD:Contest finished, congratulations for winners!Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 726
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces",
          "content": "483A - Counterexample Problem author gridnevvvitThis problem has two possible solutions: Let's handle all possible triples and check every of them for being a counterexample. This solution works with asymptotics O(n3logA) Handle only a few cases. It could be done like this: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Jury's solution: 8394832483B - Friends and PresentsProblem author gridnevvvitJury's solution is using binary search. First, you can notice that if you can make presents with numbers 1, 2, ..., v then you can make presents with numbers 1, 2, ..., v, v + 1 too. Let f(v) be the function returning true or false: is it right, that you can make presents with numbers 1, 2, ..., v. Let f1 be the number of numbers divisible by x, f2 — the number of numbers divisible by y, and both — number of numbers divisible by x and by y (as soon as x and y are primes, it is equivalent to divisibility by x·y). Then to first friend at first we shold give f2 - both numbers, and to second friend f1 - both numbers. Then we must check, could we give all other numbers divisible neither by x nor by y.This solution works with Jury's solution: 8394846 483C - Diverse Permutation / 482A - Diverse PermutationProblem author gridnevvvitLet's see, what's the solution for some k = n - 1:1 10 2 9 3 8 4 7 5 6At the odd indexes we placed increasing sequence 1, 2, 3 .., at the even — decreasing sequence n, n - 1, n - 2, ... First, we must get the permutation the way described above, then get first k numbers from it, and then we should make all other distances be equal to 1.This solution works with O(n).Jury's solution: 8394876483D - Interesting Array / 482B - Interesting ArrayProblem author gridnevvvitWe will solve the task for every distinct bit. Now we must handle new constraint: l[i], r[i], q[i]. If number q[i] has 1 in bit with number pos, then all numbers in segment [l[i], r[i]] will have 1 in that bit too. To do that, we can use a standard idea of adding on a segment.Let's do two adding operation in s[pos] array — in position l[i] we will add 1, and in posiotion r[i] + 1 — -1. Then we will calculate partial sums of array s[pos], and if s[pos][i] > 0 (the sum on prefix length i + 1), then bit at position pos will be 1, otherwise — 0.After that, you can use segment tree to check satisfying constraints.Jury's solution: 8394894483E - Game with Strings / 482C - Game with StringsProblem author gridnevvvitLet's handle all string pairs and calculate the mask mask, which will have 1-bits only in positions in which that strings have the same characters. In other words, we could not distinguish these strings using positions with submask of mask mask, then we must add in d[mask] 1-bits in positions i и j. This way in d[mask] we store mask of strings, which we could not distinguish using only positions given in mask mask. Using information described above, we can easily calculate this dynamics.Now, when we have array d calculated, it is not hard to calculate the answer. Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos. After that we may guess some strings, they are 1-bits in mask s = d[mask] ^ d[mask | (1 << pos)]. Then you have to calculate number of bits in s quickly and update the answer.Jury's solution: 8394918482D - Random Function and TreeProblem author RoKiLet's calculate d[v][p] dynamics — the answer for vertex v with size of parity p.At first step to calculate this dynamic for vertex v we should count all different paintings of a subtree visiting all children in increasing order of their numbers. By multiplying this number by 2 we will get paintings visiting children in decreasing order. Now some paintings may count twice. To fix that, let's have a look on a some subtree of a vertex v.Consider all the parities of children subtrees visited by our function (0 or 1). First thing to note is that among these parities exist two different values, the subtree will have different paintings with different ordering (you can prove it yourself). Otherwise, all our children sizes have the same parity.If all sizes are even, this subtree will be counted twice. Otherwise, if sizes are odd, we are interested only in odd count of visited subtrees. This way, we must subtract from our dynamic the number of ways to paint any number of children with even subtree sizes and odd number of children with odd subtree sizes.Jury's solution: 8394936482E - ELCAProblem author danilka.proLet's split all M requests in blocks containing requests each. Every block will be processed following way:First using dfs we need to calculate for every vertex v, where u is every ancestor of v, sizei — size of subtree of vertex i, including itself. This value shows how will the answer change after removing or adding vertex v as child to any other vertex, furthermore, answer will change exactly by pathv·sizev (decreasing or increasing).Then we will calculate chv the same way — the number of all possible vertex pairs, which have LCA in vertex v. This value shows how the answer changes after changing Vv — if Vv changes by dVv, answer changes by chv·dVv.Then mark all vertexes, which occur in our block at least once (in worst case their number is ). Next, mark every vertex being LCA of some pair of already marked vertexes, using DFS. We can prove that final number of these vertexes is at most . After all this we got 'compressed' tree, containing only needed vertexes. Parent of vertex i in compressed tree we will call vertex numbered Pi.On the image above example of this 'compression' way is given. Vertexes colored red are vertexes in request block, blue — vertexes marked after LCA, dotted line — Pv → v edges in compressed tree.On such compressed tree we need to calculate one new value Cv for every vertex v — the size of a vertex, lying on a way from Pv to v after Pv on main (non-compressed) tree (son of a Pv vertex in main tree).Now we should process request on changing parent of vertex v from pv to u on a compressed tree. The answer will change by pathv·sizev. Now for every vertex i, lying on a way from root to Pv vertex, two values will change: sizei will be decreased by sizev, but chi will be decreased by sizev·(sizei - Ct), (Pt = i), but pathi will stay unchanged. For every other vertex j only pathj will be changed: it will be decreased by . After that, we got compressed subtree where subtree of a vertex v is missing. Next, doing the same way as above, all values are changed considering that v (and all it's subtree) is a children of a vertex u. Do not forget to change Cv too.Let's see, how the value-changing request of a vertex v is to be processed. As described above, the answer will be changed by chv·dVv. For every vertex i lying in vertex v subtree only pathi will be changed (it could be easy done using Cto values), all other values stay unchanged.This solution has complexity, but in N = M case it has to be .Авторское решение: 8394944",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 482\\s*D"
          },
          "content_length": 7065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 4",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 5",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 6",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 7",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 8",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 9",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool vis[MAXN];\n\nvoid dfs(int u) {\n    vis[u] = true;\n    for (int v : adj[u]) {\n        if (!vis[v]) dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 2; i <= n; i++) {\n        int pi = inf.readInt(1, i - 1, \"pi\");\n        adj[pi].push_back(i);\n        adj[i].push_back(pi);\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    \n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(vis[i], \"The tree is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool vis[MAXN];\n\nvoid dfs(int u) {\n    vis[u] = true;\n    for (int v : adj[u]) {\n        if (!vis[v]) dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 2; i <= n; i++) {\n        int pi = inf.readInt(1, i - 1, \"pi\");\n        adj[pi].push_back(i);\n        adj[i].push_back(pi);\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    \n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(vis[i], \"The tree is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool vis[MAXN];\n\nvoid dfs(int u) {\n    vis[u] = true;\n    for (int v : adj[u]) {\n        if (!vis[v]) dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 2; i <= n; i++) {\n        int pi = inf.readInt(1, i - 1, \"pi\");\n        adj[pi].push_back(i);\n        adj[i].push_back(pi);\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    \n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(vis[i], \"The tree is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> p(n + 1); // p[1..n], p[2..n] are parents\n\n    if (type == \"chain\") {\n        // Tree that is a chain\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        // Tree that is a star\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (type == \"binary\") {\n        // Balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i / 2;\n        }\n    } else if (type == \"skewed\") {\n        // Skewed tree\n        int k = n / 2;\n        for (int i = 2; i <= k; ++i) {\n            p[i] = i - 1;\n        }\n        for (int i = k + 1; i <= n; ++i) {\n            p[i] = k;\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", p[i], i == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> p(n + 1); // p[1..n], p[2..n] are parents\n\n    if (type == \"chain\") {\n        // Tree that is a chain\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        // Tree that is a star\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (type == \"binary\") {\n        // Balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i / 2;\n        }\n    } else if (type == \"skewed\") {\n        // Skewed tree\n        int k = n / 2;\n        for (int i = 2; i <= k; ++i) {\n            p[i] = i - 1;\n        }\n        for (int i = k + 1; i <= n; ++i) {\n            p[i] = k;\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", p[i], i == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type binary\n./gen -n 2 -type skewed\n./gen -n 2 -type random\n\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type binary\n./gen -n 3 -type skewed\n./gen -n 3 -type random\n\n./gen -n 4 -type chain\n./gen -n 4 -type star\n./gen -n 4 -type binary\n./gen -n 4 -type skewed\n./gen -n 4 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type skewed\n./gen -n 10 -type random\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type skewed\n./gen -n 1000 -type random\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type skewed\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:36.279719",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "482/E",
      "title": "Problem 482/E",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for(int v: adj[u]) {\n        if(!visited[v])\n            dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readEoln();\n    vector<int> parent = inf.readInts(n - 1, 1, n, \"parent\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, 0, 1000000, \"s\");\n    inf.readEoln();\n\n    // Build the tree and check connectivity\n    adj.resize(n + 1);\n    for(int i = 2; i <= n; ++i) {\n        int pv = parent[i - 2];\n        adj[pv].push_back(i);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1);\n    for(int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to root\", i);\n    }\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    for(int queryNum = 0; queryNum < q; ++queryNum) {\n        string cmd = inf.readToken();\n        if (cmd == \"P\") {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            ensuref(u != v, \"u != v in P query %d\", queryNum + 1);\n            inf.readEoln();\n        } else if (cmd == \"V\") {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int t = inf.readInt(0, 1000000, \"t\");\n            inf.readEoln();\n        } else {\n            quitf(_fail, \"Unknown query type '%s' at query %d\", cmd.c_str(), queryNum + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for(int v: adj[u]) {\n        if(!visited[v])\n            dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readEoln();\n    vector<int> parent = inf.readInts(n - 1, 1, n, \"parent\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, 0, 1000000, \"s\");\n    inf.readEoln();\n\n    // Build the tree and check connectivity\n    adj.resize(n + 1);\n    for(int i = 2; i <= n; ++i) {\n        int pv = parent[i - 2];\n        adj[pv].push_back(i);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1);\n    for(int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to root\", i);\n    }\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    for(int queryNum = 0; queryNum < q; ++queryNum) {\n        string cmd = inf.readToken();\n        if (cmd == \"P\") {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            ensuref(u != v, \"u != v in P query %d\", queryNum + 1);\n            inf.readEoln();\n        } else if (cmd == \"V\") {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int t = inf.readInt(0, 1000000, \"t\");\n            inf.readEoln();\n        } else {\n            quitf(_fail, \"Unknown query type '%s' at query %d\", cmd.c_str(), queryNum + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for(int v: adj[u]) {\n        if(!visited[v])\n            dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readEoln();\n    vector<int> parent = inf.readInts(n - 1, 1, n, \"parent\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, 0, 1000000, \"s\");\n    inf.readEoln();\n\n    // Build the tree and check connectivity\n    adj.resize(n + 1);\n    for(int i = 2; i <= n; ++i) {\n        int pv = parent[i - 2];\n        adj[pv].push_back(i);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1);\n    for(int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to root\", i);\n    }\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    for(int queryNum = 0; queryNum < q; ++queryNum) {\n        string cmd = inf.readToken();\n        if (cmd == \"P\") {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            ensuref(u != v, \"u != v in P query %d\", queryNum + 1);\n            inf.readEoln();\n        } else if (cmd == \"V\") {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int t = inf.readInt(0, 1000000, \"t\");\n            inf.readEoln();\n        } else {\n            quitf(_fail, \"Unknown query type '%s' at query %d\", cmd.c_str(), queryNum + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 0); // default to 0 queries\n    string treeType = opt<string>(\"tree\", \"random\"); // default to random\n    string sType = opt<string>(\"sType\", \"random\"); // default to random\n    string queryType = opt<string>(\"query\", \"mixed\"); // default to mixed\n\n    // Generate the tree\n    vector<int> p(n); // parents\n    if (treeType == \"chain\") {\n        for(int i = 1; i < n; ++i)\n            p[i] = i - 1; // chain from node 1 to n\n    } else if (treeType == \"star\") {\n        for(int i = 1; i < n; ++i)\n            p[i] = 0; // all connected to root (node 1)\n    } else if (treeType == \"balanced\") {\n        // Build a balanced binary tree\n        for(int i = 1; i < n; ++i)\n            p[i] = (i - 1) / 2;\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(0, i - 1); // Parent of node i is node between 0 and i-1\n    }\n\n    // Generate s_i according to sType\n    vector<int> s(n);\n    if (sType == \"zeros\") {\n        fill(s.begin(), s.end(), 0);\n    } else if (sType == \"ones\") {\n        fill(s.begin(), s.end(), 1000000); // maximum value of s_i\n    } else if (sType == \"increasing\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = i % 1000001; // ensure s_i <= 1e6\n    } else if (sType == \"decreasing\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = (n - i - 1) % 1000001;\n    } else {\n        // Random s_i\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next(0, 1000000);\n    }\n\n    // Generate queries according to queryType\n    vector<string> queries;\n    if (queryType == \"only_P\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            while (u == v)\n                u = rnd.next(1, n);\n            queries.push_back(\"P \" + to_string(v) + \" \" + to_string(u));\n        }\n    } else if (queryType == \"only_V\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int t = rnd.next(0, 1000000);\n            queries.push_back(\"V \" + to_string(v) + \" \" + to_string(t));\n        }\n    } else {\n        // Mixed queries\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(0, 1);\n            if (type == 0) {\n                // P query\n                int v = rnd.next(1, n);\n                int u = rnd.next(1, n);\n                while (u == v)\n                    u = rnd.next(1, n);\n                queries.push_back(\"P \" + to_string(v) + \" \" + to_string(u));\n            } else {\n                // V query\n                int v = rnd.next(1, n);\n                int t = rnd.next(0, 1000000);\n                queries.push_back(\"V \" + to_string(v) + \" \" + to_string(t));\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output p_2 to p_n\n    for (int i = 1; i < n; ++i) {\n        printf(\"%d\", p[i] + 1); // Convert to 1-based indexing\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output s_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", s[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output q and queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < queries.size(); ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 0); // default to 0 queries\n    string treeType = opt<string>(\"tree\", \"random\"); // default to random\n    string sType = opt<string>(\"sType\", \"random\"); // default to random\n    string queryType = opt<string>(\"query\", \"mixed\"); // default to mixed\n\n    // Generate the tree\n    vector<int> p(n); // parents\n    if (treeType == \"chain\") {\n        for(int i = 1; i < n; ++i)\n            p[i] = i - 1; // chain from node 1 to n\n    } else if (treeType == \"star\") {\n        for(int i = 1; i < n; ++i)\n            p[i] = 0; // all connected to root (node 1)\n    } else if (treeType == \"balanced\") {\n        // Build a balanced binary tree\n        for(int i = 1; i < n; ++i)\n            p[i] = (i - 1) / 2;\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(0, i - 1); // Parent of node i is node between 0 and i-1\n    }\n\n    // Generate s_i according to sType\n    vector<int> s(n);\n    if (sType == \"zeros\") {\n        fill(s.begin(), s.end(), 0);\n    } else if (sType == \"ones\") {\n        fill(s.begin(), s.end(), 1000000); // maximum value of s_i\n    } else if (sType == \"increasing\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = i % 1000001; // ensure s_i <= 1e6\n    } else if (sType == \"decreasing\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = (n - i - 1) % 1000001;\n    } else {\n        // Random s_i\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next(0, 1000000);\n    }\n\n    // Generate queries according to queryType\n    vector<string> queries;\n    if (queryType == \"only_P\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            while (u == v)\n                u = rnd.next(1, n);\n            queries.push_back(\"P \" + to_string(v) + \" \" + to_string(u));\n        }\n    } else if (queryType == \"only_V\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int t = rnd.next(0, 1000000);\n            queries.push_back(\"V \" + to_string(v) + \" \" + to_string(t));\n        }\n    } else {\n        // Mixed queries\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(0, 1);\n            if (type == 0) {\n                // P query\n                int v = rnd.next(1, n);\n                int u = rnd.next(1, n);\n                while (u == v)\n                    u = rnd.next(1, n);\n                queries.push_back(\"P \" + to_string(v) + \" \" + to_string(u));\n            } else {\n                // V query\n                int v = rnd.next(1, n);\n                int t = rnd.next(0, 1000000);\n                queries.push_back(\"V \" + to_string(v) + \" \" + to_string(t));\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output p_2 to p_n\n    for (int i = 1; i < n; ++i) {\n        printf(\"%d\", p[i] + 1); // Convert to 1-based indexing\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output s_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", s[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output q and queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < queries.size(); ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -q 5 -tree chain -sType increasing -query mixed\n./gen -n 5 -q 5 -tree star -sType decreasing -query only_P\n./gen -n 5 -q 5 -tree balanced -sType zeros -query only_V\n./gen -n 5 -q 5 -tree random -sType ones -query mixed\n\n./gen -n 10 -q 20 -tree chain -sType random -query mixed\n./gen -n 10 -q 20 -tree star -sType increasing -query only_P\n./gen -n 10 -q 20 -tree balanced -sType decreasing -query only_V\n./gen -n 10 -q 20 -tree random -sType zeros -query mixed\n\n./gen -n 100 -q 100 -tree chain -sType random -query mixed\n./gen -n 100 -q 100 -tree star -sType random -query mixed\n./gen -n 100 -q 100 -tree balanced -sType random -query mixed\n./gen -n 100 -q 100 -tree random -sType random -query mixed\n\n./gen -n 1000 -q 1000 -tree chain -sType ones -query only_P\n./gen -n 1000 -q 1000 -tree star -sType zeros -query only_V\n./gen -n 1000 -q 1000 -tree balanced -sType increasing -query mixed\n./gen -n 1000 -q 1000 -tree random -sType decreasing -query mixed\n\n./gen -n 10000 -q 10000 -tree chain -sType random -query mixed\n./gen -n 10000 -q 10000 -tree star -sType random -query mixed\n./gen -n 10000 -q 10000 -tree balanced -sType random -query mixed\n./gen -n 10000 -q 10000 -tree random -sType random -query mixed\n\n./gen -n 50000 -q 50000 -tree chain -sType zeros -query only_V\n./gen -n 50000 -q 50000 -tree star -sType ones -query only_P\n./gen -n 50000 -q 50000 -tree balanced -sType random -query mixed\n./gen -n 50000 -q 50000 -tree random -sType random -query mixed\n\n# Edge cases with minimal values\n./gen -n 2 -q 1 -tree chain -sType zeros -query only_V\n# Edge cases with maximal values\n./gen -n 50000 -q 50000 -tree chain -sType ones -query only_P\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:38.531163",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "483/A",
      "title": "A. Опровержение гипотез",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано два целых положительных числа через пробел l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).",
      "output_spec": "Выходные данныеВ единственной строке выведите три целых положительных числа через пробел a, b, c — искомую тройку различных чисел (a, b, c). Если существует несколько решений, разрешается вывести любое. Числа в тройке необходимо выводить в порядке возрастания.Если искомой тройки не существует, выведите единственное число -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 4Выходные данныеСкопировать2 3 4Входные данныеСкопировать10 11Выходные данныеСкопировать-1Входные данныеСкопировать900000000000000009 900000000000000029Выходные данныеСкопировать900000000000000009 900000000000000010 900000000000000021",
      "description": "A. Опровержение гипотез\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано два целых положительных числа через пробел l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите три целых положительных числа через пробел a, b, c — искомую тройку различных чисел (a, b, c). Если существует несколько решений, разрешается вывести любое. Числа в тройке необходимо выводить в порядке возрастания.Если искомой тройки не существует, выведите единственное число -1.\n\nВыходные данные\n\nВходные данныеСкопировать2 4Выходные данныеСкопировать2 3 4Входные данныеСкопировать10 11Выходные данныеСкопировать-1Входные данныеСкопировать900000000000000009 900000000000000029Выходные данныеСкопировать900000000000000009 900000000000000010 900000000000000021\n\nВходные данныеСкопировать2 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 3 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать900000000000000009 900000000000000029\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать900000000000000009 900000000000000010 900000000000000021\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере пара (2, 4) не является взаимно простой, а пары (2, 3) и (3, 4) — взаимно простые. В втором примере нельзя составить тройку из трех различных чисел, поэтому ответ -1. В третьем примере нетрудно заметить, что числа 900000000000000009 и 900000000000000021 делятся на 3.",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Скоро, 24 октября, 21:00 MSK, состоится очередной Codeforces Round #275 для участников из обоих дивизионов. Обратите внимание на необычное время старта раунда!Задачи этого раунда готовила команда Саратовского ГУ #3 в составе: Гриднев Виталий (gridnevvvit), Данил Сагунов (danilka.pro), Роман Киреев (RoKi).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Распределение баллов:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500Соревнование закончено, поздравляем победителей!UPD:Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 740
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces",
          "content": "483A - Опровержение гипотезАвтор задачи gridnevvvitВ задаче предполагалось два решения: Перебрать всевозможные тройки, и проверить, правда ли, что для этой тройки гипотеза неверна. Асимптотика такого решения O(n3logA) Разобрать несколько случаев. Например, это можно сделать так: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Авторское решение: 8394832483B - Друзья и подаркиАвтор задачи gridnevvvitАвторское решение — бинпоиск по ответу. Во-первых, заметим, что если из набора 1, 2, ..., v можно собрать подарки, то и из набора 1, 2, ..., v, v + 1 можно собрать подарки. Пусть f(v) — функция, возвращающая ответ на вопрос: правда ли, что из набора 1, 2, ..., v можно собрать подарки друзьям. пусть f1 — количество чисел, которые делятся на x, а f2 — количество чисел, которые делятся на y. и число both — количество чисел которые делятся и на x, и на y. Тогда в первую очередь первому другу мы постараемся отдать f2 - both чисел, а второму — f1 - both чисел. После этого нужно проверить, сможем ли мы раздать числа, которые не делятся ни на одно из чисел x и y.Таким образом, решение за Авторское решение: 8394846 483C - Разнообразная перестановка / 482A - Разнообразная перестановкаАвтор задачи gridnevvvitРазберем, как работает решение на большом примере, например 1 10 2 9 3 8 4 7 5 6На нечетных местах мы имеем возрастающую последовательность 1, 2, 3 .., а на четных — убывающую последовательность n, n - 1, n - 2, ... Получим таким образом решение, выведем первые k чисел указанной выше последовательности, а потом сделаем так, чтобы соседние разности были равны единице.Решение за асимптотику O(n).Авторское решение: 8394876 483D - Интересный массив / 482B - Интересный массивАвтор задачи gridnevvvitБудем решать задачу отдельно для каждого бита. Предположим, что пришло новое ограничение: l[i], r[i], q[i]. Если в числе q[i] бит с номером pos единичный, то у всех чисел на отрезке [l[i], r[i]] этот бит тоже будет единичным. Теперь можно воспользоваться стандартной идеей прибавления на отрезке оффлайн. Сделаем два прибавления в массиве s[bit] — в позиции l[i] мы сделаем прибавление 1, а еще одно в позиции r[i] + 1, там мы прибавим -1. Таким образом, если мы насчитаем частичные суммы на массиве s[bit], то, если s[bit][i] > 0, то бит bit в этом числе будет единичным, иначе — нет. После этого можно реализовать дерево отрезков, чтобы проверить выполнимость изначальных запросов.Авторское решение: 8394894 483E - Игра со строками / 482C - Игра со строкамиАвтор задачи gridnevvvitПереберем все пары строк, и подсчитаем маску mask — единичные биты будут находится только в позициях, в которых эти две пары строк имеют одинаковые символы. Таким образом, используя биты, соответствующие любой подмаске маски mask, мы не сможем отличить эту пару строк, поэтому добавим в маску d[mask] биты в позиции i и j. Таким образом, в d[mask] мы храним маску тех строк, которые мы не сможем отличить по заданной маске mask. Используя указанную выше информацию, мы сможем просто насчитать эту динамику.Теперь, когда у нас имеется эта динамика, нетрудно восстановить ответ. Переберем маску mask. Попробуем задать еще один вопрос, то есть добавить в эту маску еще один бит. После этого мы могли отгадать некоторые строки, а именно те, что останутся в виде единичных битов в маске s = d[mask] ^ d[mask | (1 << pos)] (pos — позиция нового вопроса). Осталось аккуратно подсчитать количество бит в маске s и пересчитать искомое математическое ожидание.Авторское решение: 8394918 482D - Случайная функция и деревоАвтор задачи RoKiПосчитаем динамику d[v][p] — ответ на задачу для поддерева вершины v с размером, имеющим четность p.Научимся считать эту динамику для вершины v. Для начала посчитаем количество различных раскрасок при обходе потомков в порядке возрастания номеров. Умножим эту величину на 2 и получим раскраски при обходе потомков в порядке убывания номеров. Но теперь, возможно, появились раскраски, которые мы учли 2 раза. Давайте рассмотрим некоторое поддерево вершины v и поймем, когда оно учтется 2 раза.Рассмотрим четности поддеревьев потомков, которых посетила наша функция (0 или 1). Первое, что нужно заметить: если среди этих величин есть различные значения, то такое поддерево при разных обходах будет раскрашено по-разному (это вы можете доказать сами). Теперь все наши посещенные потомки имеют одинаковые по четности размеры поддеревьев. Если размеры поддеревьев четные, то очевидно, что такое дерево учтется 2 раза. А вот если размеры поддеревьев нечетные, то нас интересуют только случаи, когда мы посетили нечетное количество потомков. Таким образом, из нашей динамики нужно вычесть количество способов раскрасить любое количество потомков с четным размером поддерева и нечетное количество потомков с нечетным размером поддерева.Авторское решение: 8394936 482E - ELCAАвтор задачи danilka.proБудем обрабатывать M запросов блоками по штук (таких блоков, очевидно, тоже ). Каждый блок обрабатывается следующим образом:Сначала поиском в глубину посчитаем для каждой вершины v значение , где u — любой предок v, а sizei — размер поддерева вершины i, включая саму вершину. Эта величина характеризует изменение ответа при 'отрывании' или 'прикреплении' вершины v, а именно, после выполнения одной из этих операций ответ изменится на pathv·sizev (уменьшится или увеличится соответственно).Тем же образом посчитаем значение chv — количество всевозможных пар вершин, наименьший общий предок которых равен v. Эта величина характеризует изменение ответа при изменении Vv, а именно, при изменении величины Vv на dVv ответ изменится на chv·dVv.Выделим вершины, номера которых хотя бы один раз встречаются в нашем блоке (в худшем случае таких вершин ). Теперь запустим поиск в глубину, который отметит вершины, являющиеся наименьшими общими предками каких-либо двух выделенных вершин. С помощью метода математической индукции нетрудно доказать, что в худшем случае таких вершин будет ровно . Таким образом мы получили 'сжатое' дерево, содержащее только необходимые вершины. Предка вершины i сжатого дерева обозначим за Pi.На следующем рисунке представлен пример такого 'сжатия'. Красным обозначены вершины в блоке запроса, синим — помеченные вершины, пунктиром — ребра Pv → v сжатого дерева.На таком сжатом дереве нужно посчитать для каждой вершины v еще одну величину Cv — размер поддерева вершины исходного дерева, которая лежит на пути от Pv до v в исходном дереве после Pv (непосредственный сын Pv).Попробуем обработать запрос на смену родителя вершины v с pv на u в сжатом дереве. Ответ, как уже было сказано выше, сначала уменьшится на pathv·sizev. Теперь для каждой вершины i, лежащей на пути от корня до Pv, изменятся две величины: sizei уменьшится на sizev, а chi уменьшится на величину, равную sizev·(sizei - Ct), (Pt = i), а pathi останется прежним. Для всех остальных вершин j, напротив, изменится лишь величина pathj — она уменьшится на . Теперь мы получили сжатое дерево, в котором все величины посчитаны с учетом того, что поддерево вершины v было удалено. Аналогичным образом происходит пересчет величин с учетом добавления вершины v в качестве сына вершины u (не забываем обновлять также и Cv).Посмотрим, как будет выглядеть обработка запроса на смену значения Vv вершины v. Ответ, как было описано, изменится на chv·dVv. Также изменятся все pathi для вершин, лежащих в поддереве v (их несложно пересчитать с помощью значений Cto, все остальные значения останутся прежними.Таким образом, сложность решения составляет , что в случае N = M составляет . Авторское решение: 8394944",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 483\\s*A"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "n - a >= cnt1 && n - b >= cnt2 && n - c >= cnt1 + cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "c = n / ( x + y )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "n - a >= cnt1 && n - b >= cnt2 && n - c >= cnt1 + cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "n - b - f < cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "a = 6 / 2 = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "b = 6 / 3 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "n - a >= cnt1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "n - b >= cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "c = 6 / ( 2 + 3 ) = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "n - c = 5 < 3 + 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "c = n / (x*y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 19",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 20",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 21",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 22",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 23",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 24",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 25",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 26",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 27",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 28",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 29",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 4",
          "code": "O(2^length * n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 5",
          "code": "O(n*length*length)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 6",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 7",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 8",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 9",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 10",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 11",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n\n    ensuref(r - l <= 50, \"r - l must be at most 50, but r - l = %lld\", r - l);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n\n    ensuref(r - l <= 50, \"r - l must be at most 50, but r - l = %lld\", r - l);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n\n    ensuref(r - l <= 50, \"r - l must be at most 50, but r - l = %lld\", r - l);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    long long l = inf.readLong(1, 1000000000000000000LL, \"l\");\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    // Ensuring l ≤ r ≤ 1e18\n\n    // Read the first integer from the contestant's output\n    long long firstValue = ouf.readLong(-1, r, \"first value\");\n\n    if (firstValue == -1) {\n        // Contestant claims no counterexample exists\n        // Make sure there is no extra data\n        if (!ouf.seekEof())\n            quitf(_wa, \"Extra data after -1.\");\n\n        // Since the range is small (r - l ≤ 50), we can check all possible triplets\n        bool found = false;\n        vector<long long> nums;\n        for (long long i = l; i <= r; ++i)\n            nums.push_back(i);\n\n        for (size_t i = 0; i < nums.size() && !found; ++i) {\n            for (size_t j = i + 1; j < nums.size() && !found; ++j) {\n                if (__gcd(nums[i], nums[j]) != 1)\n                    continue;\n                for (size_t k = j + 1; k < nums.size() && !found; ++k) {\n                    if (__gcd(nums[j], nums[k]) != 1)\n                        continue;\n                    if (__gcd(nums[i], nums[k]) > 1) {\n                        // Found a counterexample\n                        found = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (found) {\n            quitf(_wa, \"Contestant claimed no counterexample exists, but a counterexample exists.\");\n        } else {\n            quitf(_ok, \"Contestant correctly claimed no counterexample exists.\");\n        }\n    } else {\n        // Contestant outputs numbers\n        long long a = firstValue;\n        long long b = ouf.readLong(l, r, \"b\");\n        long long c = ouf.readLong(l, r, \"c\");\n        // Ensure no extra data\n        if (!ouf.seekEof())\n            quitf(_wa, \"Extra data after the three numbers.\");\n\n        // Check that numbers are distinct and in ascending order\n        if (!(a < b && b < c))\n            quitf(_wa, \"Numbers are not in ascending order: %lld %lld %lld.\", a, b, c);\n        // Check that numbers are within the range [l, r]\n        if (!(l <= a && c <= r))\n            quitf(_wa, \"Numbers are not within the range [%lld, %lld]: %lld %lld %lld.\", l, r, a, b, c);\n        // Check the GCD conditions\n        if (__gcd(a, b) != 1)\n            quitf(_wa, \"GCD(%lld, %lld) != 1.\", a, b);\n        if (__gcd(b, c) != 1)\n            quitf(_wa, \"GCD(%lld, %lld) != 1.\", b, c);\n        if (__gcd(a, c) <= 1)\n            quitf(_wa, \"GCD(%lld, %lld) <= 1.\", a, c);\n\n        quitf(_ok, \"Contestant output is correct.\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    /*\n        This generator outputs exactly one test case (a single line with two integers: l and r).\n        - We have two modes: \"corner\" (uses a fixed array of special cases) and \"random\" (generates a random interval).\n        - The parameter \"type\" (string) controls the mode; default is \"random\".\n        - For the \"corner\" mode, an integer parameter \"index\" picks a preset test (0-based).\n        - For the \"random\" mode, a long long parameter \"limit\" (default 1000) specifies the upper bound\n          from which we choose a random l in [1..limit], then pick a random difference d in [0..50],\n          and set r = l + d, capped at 10^18.\n        \n        Constraints to satisfy:\n            1 <= l <= r <= 10^18\n            (r - l) <= 50\n    */\n\n    string mode = opt<string>(\"type\", \"random\");  // \"corner\" or \"random\"\n    int index = opt<int>(\"index\", 0);             // which preset for \"corner\" mode\n    long long limit = opt<long long>(\"limit\", 1000); // max L for random mode\n\n    if (mode == \"corner\") {\n        // A list of carefully chosen corner cases (l, r) within [1..1e18], (r - l) <= 50\n        static vector<pair<long long, long long>> corners = {\n            {1, 1},                                  // difference = 0, no valid triple\n            {1, 2},                                  // difference = 1, no valid triple\n            {2, 4},                                  // difference = 2, valid triple (2,3,4)\n            {10, 10},                                // difference = 0, no valid triple\n            {10, 11},                                // difference = 1, no valid triple\n            {10, 12},                                // difference = 2, valid triple (10,11,12)\n            {900000000000000009LL, 900000000000000029LL}, // from the example\n            {999999999999999995LL, 1000000000000000000LL},// difference = 5, near 1e18\n            {500000000000000000LL, 500000000000000050LL}, // difference = 50, maximum allowed gap\n            {2, 3},                                  // difference = 1, no valid triple\n            {2, 2},                                  // difference = 0, no valid triple\n            {3, 6}                                   // difference = 3, possible triple (e.g., (3,5,6))\n        };\n\n        // Clamp index to valid range\n        index = max(0, min<int>((int)corners.size() - 1, index));\n        long long l = corners[index].first;\n        long long r = corners[index].second;\n\n        // Output the single test case\n        cout << l << \" \" << r << \"\\n\";\n    }\n    else {\n        // \"random\" mode\n        // 1) clamp limit to <= 10^18\n        long long safeLimit = min(limit, (long long)1000000000000000000LL);\n        // 2) choose random L in [1..safeLimit]\n        long long l = rnd.next((long long)1, safeLimit);\n        // 3) choose diff in [0..50]\n        long long diff = rnd.next(0LL, 50LL);\n        // 4) compute R = min(L + diff, 10^18)\n        long long r = min(l + diff, (long long)1000000000000000000LL);\n\n        // Output the single test case\n        cout << l << \" \" << r << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    /*\n        This generator outputs exactly one test case (a single line with two integers: l and r).\n        - We have two modes: \"corner\" (uses a fixed array of special cases) and \"random\" (generates a random interval).\n        - The parameter \"type\" (string) controls the mode; default is \"random\".\n        - For the \"corner\" mode, an integer parameter \"index\" picks a preset test (0-based).\n        - For the \"random\" mode, a long long parameter \"limit\" (default 1000) specifies the upper bound\n          from which we choose a random l in [1..limit], then pick a random difference d in [0..50],\n          and set r = l + d, capped at 10^18.\n        \n        Constraints to satisfy:\n            1 <= l <= r <= 10^18\n            (r - l) <= 50\n    */\n\n    string mode = opt<string>(\"type\", \"random\");  // \"corner\" or \"random\"\n    int index = opt<int>(\"index\", 0);             // which preset for \"corner\" mode\n    long long limit = opt<long long>(\"limit\", 1000); // max L for random mode\n\n    if (mode == \"corner\") {\n        // A list of carefully chosen corner cases (l, r) within [1..1e18], (r - l) <= 50\n        static vector<pair<long long, long long>> corners = {\n            {1, 1},                                  // difference = 0, no valid triple\n            {1, 2},                                  // difference = 1, no valid triple\n            {2, 4},                                  // difference = 2, valid triple (2,3,4)\n            {10, 10},                                // difference = 0, no valid triple\n            {10, 11},                                // difference = 1, no valid triple\n            {10, 12},                                // difference = 2, valid triple (10,11,12)\n            {900000000000000009LL, 900000000000000029LL}, // from the example\n            {999999999999999995LL, 1000000000000000000LL},// difference = 5, near 1e18\n            {500000000000000000LL, 500000000000000050LL}, // difference = 50, maximum allowed gap\n            {2, 3},                                  // difference = 1, no valid triple\n            {2, 2},                                  // difference = 0, no valid triple\n            {3, 6}                                   // difference = 3, possible triple (e.g., (3,5,6))\n        };\n\n        // Clamp index to valid range\n        index = max(0, min<int>((int)corners.size() - 1, index));\n        long long l = corners[index].first;\n        long long r = corners[index].second;\n\n        // Output the single test case\n        cout << l << \" \" << r << \"\\n\";\n    }\n    else {\n        // \"random\" mode\n        // 1) clamp limit to <= 10^18\n        long long safeLimit = min(limit, (long long)1000000000000000000LL);\n        // 2) choose random L in [1..safeLimit]\n        long long l = rnd.next((long long)1, safeLimit);\n        // 3) choose diff in [0..50]\n        long long diff = rnd.next(0LL, 50LL);\n        // 4) compute R = min(L + diff, 10^18)\n        long long r = min(l + diff, (long long)1000000000000000000LL);\n\n        // Output the single test case\n        cout << l << \" \" << r << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are 20 distinct commands to run this generator.\n# Each command emits exactly one line of output (\"l r\").\n\n# Corner tests:\n./gen -type corner -index 0\n./gen -type corner -index 1\n./gen -type corner -index 2\n./gen -type corner -index 3\n./gen -type corner -index 4\n./gen -type corner -index 5\n./gen -type corner -index 6\n./gen -type corner -index 7\n./gen -type corner -index 8\n./gen -type corner -index 9\n./gen -type corner -index 10\n./gen -type corner -index 11\n\n# Random tests with various limits:\n./gen -type random -limit 5\n./gen -type random -limit 50\n./gen -type random -limit 200\n./gen -type random -limit 1000\n./gen -type random -limit 999999999999999950\n./gen -type random -limit 1000000000000000000\n./gen -type random -limit 500000000000000000\n./gen -type random -limit 123456789012345678\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:40.593882",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "483/B",
      "title": "B. Friends and Presents",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains four positive integers cnt1, cnt2, x, y (1 ≤ cnt1, cnt2 < 109; cnt1 + cnt2 ≤ 109; 2 ≤ x < y ≤ 3·104) — the numbers that are described in the statement. It is guaranteed that numbers x, y are prime.",
      "output_spec": "OutputPrint a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3 1 2 3OutputCopy5InputCopy1 3 2 3OutputCopy4",
      "description": "B. Friends and Presents\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line contains four positive integers cnt1, cnt2, x, y (1 ≤ cnt1, cnt2 < 109; cnt1 + cnt2 ≤ 109; 2 ≤ x < y ≤ 3·104) — the numbers that are described in the statement. It is guaranteed that numbers x, y are prime.\n\nOutputPrint a single integer — the answer to the problem.\n\nInputCopy3 1 2 3OutputCopy5InputCopy1 3 2 3OutputCopy4\n\nInputCopy3 1 2 3\n\nOutputCopy5\n\nInputCopy1 3 2 3\n\nOutputCopy4\n\nNoteIn the first sample you give the set of numbers {1, 3, 5} to the first friend and the set of numbers {2} to the second friend. Note that if you give set {1, 3, 5} to the first friend, then we cannot give any of the numbers 1, 3, 5 to the second friend. In the second sample you give the set of numbers {3} to the first friend, and the set of numbers {1, 2, 4} to the second friend. Thus, the answer to the problem is 4.",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Soon (on October 24, 21:00 MSK) you are lucky to participate in Codeforces Round #275 for both divisions. Pay attention to the round begining time!Problems have been prepared by team Saratov SU #3 with members: Gridnev Vitaly (gridnevvvit), Danil Sagunov (danilka.pro), Roman Kireev (RoKi).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500UPD:Contest finished, congratulations for winners!Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 726
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces",
          "content": "483A - Counterexample Problem author gridnevvvitThis problem has two possible solutions: Let's handle all possible triples and check every of them for being a counterexample. This solution works with asymptotics O(n3logA) Handle only a few cases. It could be done like this: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Jury's solution: 8394832483B - Friends and PresentsProblem author gridnevvvitJury's solution is using binary search. First, you can notice that if you can make presents with numbers 1, 2, ..., v then you can make presents with numbers 1, 2, ..., v, v + 1 too. Let f(v) be the function returning true or false: is it right, that you can make presents with numbers 1, 2, ..., v. Let f1 be the number of numbers divisible by x, f2 — the number of numbers divisible by y, and both — number of numbers divisible by x and by y (as soon as x and y are primes, it is equivalent to divisibility by x·y). Then to first friend at first we shold give f2 - both numbers, and to second friend f1 - both numbers. Then we must check, could we give all other numbers divisible neither by x nor by y.This solution works with Jury's solution: 8394846 483C - Diverse Permutation / 482A - Diverse PermutationProblem author gridnevvvitLet's see, what's the solution for some k = n - 1:1 10 2 9 3 8 4 7 5 6At the odd indexes we placed increasing sequence 1, 2, 3 .., at the even — decreasing sequence n, n - 1, n - 2, ... First, we must get the permutation the way described above, then get first k numbers from it, and then we should make all other distances be equal to 1.This solution works with O(n).Jury's solution: 8394876483D - Interesting Array / 482B - Interesting ArrayProblem author gridnevvvitWe will solve the task for every distinct bit. Now we must handle new constraint: l[i], r[i], q[i]. If number q[i] has 1 in bit with number pos, then all numbers in segment [l[i], r[i]] will have 1 in that bit too. To do that, we can use a standard idea of adding on a segment.Let's do two adding operation in s[pos] array — in position l[i] we will add 1, and in posiotion r[i] + 1 — -1. Then we will calculate partial sums of array s[pos], and if s[pos][i] > 0 (the sum on prefix length i + 1), then bit at position pos will be 1, otherwise — 0.After that, you can use segment tree to check satisfying constraints.Jury's solution: 8394894483E - Game with Strings / 482C - Game with StringsProblem author gridnevvvitLet's handle all string pairs and calculate the mask mask, which will have 1-bits only in positions in which that strings have the same characters. In other words, we could not distinguish these strings using positions with submask of mask mask, then we must add in d[mask] 1-bits in positions i и j. This way in d[mask] we store mask of strings, which we could not distinguish using only positions given in mask mask. Using information described above, we can easily calculate this dynamics.Now, when we have array d calculated, it is not hard to calculate the answer. Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos. After that we may guess some strings, they are 1-bits in mask s = d[mask] ^ d[mask | (1 << pos)]. Then you have to calculate number of bits in s quickly and update the answer.Jury's solution: 8394918482D - Random Function and TreeProblem author RoKiLet's calculate d[v][p] dynamics — the answer for vertex v with size of parity p.At first step to calculate this dynamic for vertex v we should count all different paintings of a subtree visiting all children in increasing order of their numbers. By multiplying this number by 2 we will get paintings visiting children in decreasing order. Now some paintings may count twice. To fix that, let's have a look on a some subtree of a vertex v.Consider all the parities of children subtrees visited by our function (0 or 1). First thing to note is that among these parities exist two different values, the subtree will have different paintings with different ordering (you can prove it yourself). Otherwise, all our children sizes have the same parity.If all sizes are even, this subtree will be counted twice. Otherwise, if sizes are odd, we are interested only in odd count of visited subtrees. This way, we must subtract from our dynamic the number of ways to paint any number of children with even subtree sizes and odd number of children with odd subtree sizes.Jury's solution: 8394936482E - ELCAProblem author danilka.proLet's split all M requests in blocks containing requests each. Every block will be processed following way:First using dfs we need to calculate for every vertex v, where u is every ancestor of v, sizei — size of subtree of vertex i, including itself. This value shows how will the answer change after removing or adding vertex v as child to any other vertex, furthermore, answer will change exactly by pathv·sizev (decreasing or increasing).Then we will calculate chv the same way — the number of all possible vertex pairs, which have LCA in vertex v. This value shows how the answer changes after changing Vv — if Vv changes by dVv, answer changes by chv·dVv.Then mark all vertexes, which occur in our block at least once (in worst case their number is ). Next, mark every vertex being LCA of some pair of already marked vertexes, using DFS. We can prove that final number of these vertexes is at most . After all this we got 'compressed' tree, containing only needed vertexes. Parent of vertex i in compressed tree we will call vertex numbered Pi.On the image above example of this 'compression' way is given. Vertexes colored red are vertexes in request block, blue — vertexes marked after LCA, dotted line — Pv → v edges in compressed tree.On such compressed tree we need to calculate one new value Cv for every vertex v — the size of a vertex, lying on a way from Pv to v after Pv on main (non-compressed) tree (son of a Pv vertex in main tree).Now we should process request on changing parent of vertex v from pv to u on a compressed tree. The answer will change by pathv·sizev. Now for every vertex i, lying on a way from root to Pv vertex, two values will change: sizei will be decreased by sizev, but chi will be decreased by sizev·(sizei - Ct), (Pt = i), but pathi will stay unchanged. For every other vertex j only pathj will be changed: it will be decreased by . After that, we got compressed subtree where subtree of a vertex v is missing. Next, doing the same way as above, all values are changed considering that v (and all it's subtree) is a children of a vertex u. Do not forget to change Cv too.Let's see, how the value-changing request of a vertex v is to be processed. As described above, the answer will be changed by chv·dVv. For every vertex i lying in vertex v subtree only pathi will be changed (it could be easy done using Cto values), all other values stay unchanged.This solution has complexity, but in N = M case it has to be .Авторское решение: 8394944",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 483\\s*B"
          },
          "content_length": 7065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 4",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 5",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 6",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 7",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 8",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 9",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int x) {\n    if (x <= 1) return false;\n    for (int i = 2; i * i <= x; ++i)\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long cnt1 = inf.readLong(1LL, 1000000000LL - 1LL, \"cnt1\");\n    inf.readSpace();\n    long long cnt2 = inf.readLong(1LL, 1000000000LL - 1LL, \"cnt2\");\n    inf.readSpace();\n    int x = inf.readInt(2, 30000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(2, 30000, \"y\");\n    inf.readEoln();\n\n    ensuref(cnt1 + cnt2 <= 1000000000LL, \"cnt1 + cnt2 = %lld + %lld = %lld exceeds 1e9\", cnt1, cnt2, cnt1 + cnt2);\n    ensuref(x < y, \"x = %d must be less than y = %d\", x, y);\n    ensuref(isPrime(x), \"x = %d must be prime\", x);\n    ensuref(isPrime(y), \"y = %d must be prime\", y);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int x) {\n    if (x <= 1) return false;\n    for (int i = 2; i * i <= x; ++i)\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long cnt1 = inf.readLong(1LL, 1000000000LL - 1LL, \"cnt1\");\n    inf.readSpace();\n    long long cnt2 = inf.readLong(1LL, 1000000000LL - 1LL, \"cnt2\");\n    inf.readSpace();\n    int x = inf.readInt(2, 30000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(2, 30000, \"y\");\n    inf.readEoln();\n\n    ensuref(cnt1 + cnt2 <= 1000000000LL, \"cnt1 + cnt2 = %lld + %lld = %lld exceeds 1e9\", cnt1, cnt2, cnt1 + cnt2);\n    ensuref(x < y, \"x = %d must be less than y = %d\", x, y);\n    ensuref(isPrime(x), \"x = %d must be prime\", x);\n    ensuref(isPrime(y), \"y = %d must be prime\", y);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int x) {\n    if (x <= 1) return false;\n    for (int i = 2; i * i <= x; ++i)\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long cnt1 = inf.readLong(1LL, 1000000000LL - 1LL, \"cnt1\");\n    inf.readSpace();\n    long long cnt2 = inf.readLong(1LL, 1000000000LL - 1LL, \"cnt2\");\n    inf.readSpace();\n    int x = inf.readInt(2, 30000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(2, 30000, \"y\");\n    inf.readEoln();\n\n    ensuref(cnt1 + cnt2 <= 1000000000LL, \"cnt1 + cnt2 = %lld + %lld = %lld exceeds 1e9\", cnt1, cnt2, cnt1 + cnt2);\n    ensuref(x < y, \"x = %d must be less than y = %d\", x, y);\n    ensuref(isPrime(x), \"x = %d must be prime\", x);\n    ensuref(isPrime(y), \"y = %d must be prime\", y);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_PRIME = 30000; // 3e4\n\nvector<int> sieve_primes(int lo, int hi) {\n    vector<bool> is_prime(hi + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i <= hi; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= hi; j += i)\n                is_prime[j] = false;\n        }\n    }\n    vector<int> primes;\n    for (int i = lo; i <= hi; ++i) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n    return primes;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int cnt1 = opt<int>(\"cnt1\", -1);\n    int cnt2 = opt<int>(\"cnt2\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int x = opt<int>(\"x\", -1);\n    int y = opt<int>(\"y\", -1);\n\n    const int MAX_CNT = int(1e9);\n\n    if (type == \"max\") {\n        cnt1 = MAX_CNT - 1;\n        cnt2 = 1;\n    } else if (type == \"min\") {\n        cnt1 = cnt2 = 1;\n    } else if (type == \"large_cnt1\") {\n        cnt1 = rnd.next(MAX_CNT - 100, MAX_CNT - 1);\n        cnt2 = rnd.next(1, 100);\n    } else if (type == \"large_cnt2\") {\n        cnt2 = rnd.next(MAX_CNT - 100, MAX_CNT - 1);\n        cnt1 = rnd.next(1, 100);\n    } else if (type == \"equal_cnt\") {\n        int total = MAX_CNT;\n        cnt1 = cnt2 = total / 2;\n    } else if (type == \"small\") {\n        cnt1 = rnd.next(1, 1000);\n        cnt2 = rnd.next(1, 1000);\n    } else if (type == \"random\") {\n        if (cnt1 == -1)\n            cnt1 = rnd.next(1, MAX_CNT - 1);\n        if (cnt2 == -1)\n            cnt2 = rnd.next(1, MAX_CNT - cnt1);\n    }\n\n    // Adjust cnt1 and cnt2 if necessary\n    if (cnt1 == -1)\n        cnt1 = rnd.next(1, MAX_CNT - 1);\n    if (cnt2 == -1)\n        cnt2 = rnd.next(1, MAX_CNT - cnt1);\n    cnt1 = max(1, min(cnt1, MAX_CNT - 1));\n    cnt2 = max(1, min(cnt2, MAX_CNT - cnt1));\n\n    // Generate primes x and y\n    // Sieve primes up to MAX_PRIME\n    static vector<int> primes = sieve_primes(2, MAX_PRIME);\n\n    if (x == -1 || y == -1) {\n        if (type == \"small_x_y\") {\n            x = 2;\n            y = 3;\n        } else if (type == \"large_x_y\") {\n            // Get primes near MAX_PRIME values\n            vector<int> large_primes;\n            for (int p : primes) {\n                if (p >= MAX_PRIME - 1000)\n                    large_primes.push_back(p);\n            }\n            x = large_primes[rnd.next(0, (int)large_primes.size() - 2)];\n            y = *upper_bound(large_primes.begin(), large_primes.end(), x);\n        } else if (type == \"x_near_y\") {\n            // x and y are close primes\n            int idx = rnd.next(0, (int)primes.size() - 2);\n            x = primes[idx];\n            y = primes[idx + 1];\n        } else {\n            // Random x and y satisfying constraints\n            x = primes[rnd.next(0, (int)primes.size() - 2)];\n            int idx = rnd.next((int)(lower_bound(primes.begin(), primes.end(), x + 1) - primes.begin()), (int)primes.size() - 1);\n            y = primes[idx];\n        }\n    } else {\n        // Verify x and y are primes and satisfy constraints\n        if (!binary_search(primes.begin(), primes.end(), x) || !binary_search(primes.begin(), primes.end(), y) || x >= y || x < 2 || y > MAX_PRIME) {\n            // Invalid x or y, generate random valid x and y\n            x = 2;\n            y = 3;\n        }\n    }\n\n    // Output cnt1 cnt2 x y\n    printf(\"%d %d %d %d\\n\", cnt1, cnt2, x, y);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_PRIME = 30000; // 3e4\n\nvector<int> sieve_primes(int lo, int hi) {\n    vector<bool> is_prime(hi + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i <= hi; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= hi; j += i)\n                is_prime[j] = false;\n        }\n    }\n    vector<int> primes;\n    for (int i = lo; i <= hi; ++i) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n    return primes;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int cnt1 = opt<int>(\"cnt1\", -1);\n    int cnt2 = opt<int>(\"cnt2\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int x = opt<int>(\"x\", -1);\n    int y = opt<int>(\"y\", -1);\n\n    const int MAX_CNT = int(1e9);\n\n    if (type == \"max\") {\n        cnt1 = MAX_CNT - 1;\n        cnt2 = 1;\n    } else if (type == \"min\") {\n        cnt1 = cnt2 = 1;\n    } else if (type == \"large_cnt1\") {\n        cnt1 = rnd.next(MAX_CNT - 100, MAX_CNT - 1);\n        cnt2 = rnd.next(1, 100);\n    } else if (type == \"large_cnt2\") {\n        cnt2 = rnd.next(MAX_CNT - 100, MAX_CNT - 1);\n        cnt1 = rnd.next(1, 100);\n    } else if (type == \"equal_cnt\") {\n        int total = MAX_CNT;\n        cnt1 = cnt2 = total / 2;\n    } else if (type == \"small\") {\n        cnt1 = rnd.next(1, 1000);\n        cnt2 = rnd.next(1, 1000);\n    } else if (type == \"random\") {\n        if (cnt1 == -1)\n            cnt1 = rnd.next(1, MAX_CNT - 1);\n        if (cnt2 == -1)\n            cnt2 = rnd.next(1, MAX_CNT - cnt1);\n    }\n\n    // Adjust cnt1 and cnt2 if necessary\n    if (cnt1 == -1)\n        cnt1 = rnd.next(1, MAX_CNT - 1);\n    if (cnt2 == -1)\n        cnt2 = rnd.next(1, MAX_CNT - cnt1);\n    cnt1 = max(1, min(cnt1, MAX_CNT - 1));\n    cnt2 = max(1, min(cnt2, MAX_CNT - cnt1));\n\n    // Generate primes x and y\n    // Sieve primes up to MAX_PRIME\n    static vector<int> primes = sieve_primes(2, MAX_PRIME);\n\n    if (x == -1 || y == -1) {\n        if (type == \"small_x_y\") {\n            x = 2;\n            y = 3;\n        } else if (type == \"large_x_y\") {\n            // Get primes near MAX_PRIME values\n            vector<int> large_primes;\n            for (int p : primes) {\n                if (p >= MAX_PRIME - 1000)\n                    large_primes.push_back(p);\n            }\n            x = large_primes[rnd.next(0, (int)large_primes.size() - 2)];\n            y = *upper_bound(large_primes.begin(), large_primes.end(), x);\n        } else if (type == \"x_near_y\") {\n            // x and y are close primes\n            int idx = rnd.next(0, (int)primes.size() - 2);\n            x = primes[idx];\n            y = primes[idx + 1];\n        } else {\n            // Random x and y satisfying constraints\n            x = primes[rnd.next(0, (int)primes.size() - 2)];\n            int idx = rnd.next((int)(lower_bound(primes.begin(), primes.end(), x + 1) - primes.begin()), (int)primes.size() - 1);\n            y = primes[idx];\n        }\n    } else {\n        // Verify x and y are primes and satisfy constraints\n        if (!binary_search(primes.begin(), primes.end(), x) || !binary_search(primes.begin(), primes.end(), y) || x >= y || x < 2 || y > MAX_PRIME) {\n            // Invalid x or y, generate random valid x and y\n            x = 2;\n            y = 3;\n        }\n    }\n\n    // Output cnt1 cnt2 x y\n    printf(\"%d %d %d %d\\n\", cnt1, cnt2, x, y);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small cnt1 and cnt2, small x and y\n./gen -type small_x_y -cnt1 1 -cnt2 1\n\n# Max cnt1 and small cnt2, large x and y\n./gen -type large_x_y -cnt1 999999999 -cnt2 1\n\n# Max cnt2 and small cnt1, large x and y\n./gen -type large_x_y -cnt1 1 -cnt2 999999999\n\n# Equal cnt1 and cnt2, medium x and y\n./gen -type equal_cnt\n\n# Random cnt1 and cnt2, random x and y\n./gen -type random\n\n# Small cnt1 and large cnt2, x and y close together\n./gen -type x_near_y -cnt1 1 -cnt2 1000000000\n\n# Large cnt1 and random cnt2, small x and y\n./gen -type small_x_y -cnt1 1000000000 -cnt2 1\n\n# Large cnt1 and cnt2, x and y at maximum values\n./gen -type large_x_y -cnt1 500000000 -cnt2 500000000\n\n# cnt1 and cnt2 at maximum allowed sum\n./gen -cnt1 800000000 -cnt2 200000000 -type random\n\n# cnt1 and cnt2 minimal, x and y minimal primes\n./gen -cnt1 1 -cnt2 1 -x 2 -y 3\n\n# cnt1 and cnt2 large, x and y minimal primes\n./gen -cnt1 900000000 -cnt2 99999999 -x 2 -y 3\n\n# cnt1 and cnt2 random, x and y maximal primes\n./gen -cnt1 500000000 -cnt2 500000000 -x 29989 -y 29999\n\n# cnt1 and cnt2 random, x and y both big primes\n./gen -type large_x_y\n\n# cnt1 large, cnt2 small, x and y close together\n./gen -type x_near_y -cnt1 999999999 -cnt2 1\n\n# cnt1 and cnt2 small, x and y close together\n./gen -type x_near_y -cnt1 100 -cnt2 100\n\n# cnt1 and cnt2 random, x and y random primes\n./gen -type random\n\n# cnt1 and cnt2 at maximum values, x and y random primes\n./gen -type random -cnt1 999999999 -cnt2 1\n\n# cnt1 and cnt2 small, x and y at upper bounds\n./gen -cnt1 1 -cnt2 1 -x 29989 -y 30011\n\n# cnt1 and cnt2 small, x and y at lower bounds\n./gen -cnt1 1 -cnt2 1 -x 2 -y 3\n\n# cnt1 and cnt2 cover the full range\n./gen -cnt1 500000000 -cnt2 500000000 -type random\n\n# Random test\n./gen -type random\n\n# Edge case: cnt1 + cnt2 = 1e9\n./gen -cnt1 800000000 -cnt2 200000000 -type random\n\n# Edge case: cnt1 or cnt2 equals 1\n./gen -cnt1 1 -cnt2 999999999 -type random\n\n# Edge case: x and y distant primes\n./gen -x 2 -y 29989 -cnt1 500000000 -cnt2 499999999\n\n# Edge case: x and y consecutive primes near max\n./gen -x 29989 -y 29999 -cnt1 500000000 -cnt2 499999999\n\n# Random large test\n./gen -type random\n\n# Random small test\n./gen -type small\n\n# Max test: cnt1 and cnt2 at max possible values\n./gen -type max\n\n# Min test: cnt1 and cnt2 at minimum possible values\n./gen -type min\n\n# Mixed test with specific cnt1 and cnt2\n./gen -type random -cnt1 123456789 -cnt2 987654321\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:42.782660",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "483/C",
      "title": "C. Diverse Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains two space-separated positive integers n, k (1 ≤ k < n ≤ 105).",
      "output_spec": "OutputPrint n integers forming the permutation. If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy3 2OutputCopy1 3 2InputCopy3 1OutputCopy1 2 3InputCopy5 2OutputCopy1 3 2 4 5",
      "description": "C. Diverse Permutation\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains two space-separated positive integers n, k (1 ≤ k < n ≤ 105).\n\nOutputPrint n integers forming the permutation. If there are multiple answers, print any of them.\n\nInputCopy3 2OutputCopy1 3 2InputCopy3 1OutputCopy1 2 3InputCopy5 2OutputCopy1 3 2 4 5\n\nInputCopy3 2\n\nOutputCopy1 3 2\n\nInputCopy3 1\n\nOutputCopy1 2 3\n\nInputCopy5 2\n\nOutputCopy1 3 2 4 5\n\nNoteBy |x| we denote the absolute value of number x.",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Soon (on October 24, 21:00 MSK) you are lucky to participate in Codeforces Round #275 for both divisions. Pay attention to the round begining time!Problems have been prepared by team Saratov SU #3 with members: Gridnev Vitaly (gridnevvvit), Danil Sagunov (danilka.pro), Roman Kireev (RoKi).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500UPD:Contest finished, congratulations for winners!Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 726
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces",
          "content": "483A - Counterexample Problem author gridnevvvitThis problem has two possible solutions: Let's handle all possible triples and check every of them for being a counterexample. This solution works with asymptotics O(n3logA) Handle only a few cases. It could be done like this: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Jury's solution: 8394832483B - Friends and PresentsProblem author gridnevvvitJury's solution is using binary search. First, you can notice that if you can make presents with numbers 1, 2, ..., v then you can make presents with numbers 1, 2, ..., v, v + 1 too. Let f(v) be the function returning true or false: is it right, that you can make presents with numbers 1, 2, ..., v. Let f1 be the number of numbers divisible by x, f2 — the number of numbers divisible by y, and both — number of numbers divisible by x and by y (as soon as x and y are primes, it is equivalent to divisibility by x·y). Then to first friend at first we shold give f2 - both numbers, and to second friend f1 - both numbers. Then we must check, could we give all other numbers divisible neither by x nor by y.This solution works with Jury's solution: 8394846 483C - Diverse Permutation / 482A - Diverse PermutationProblem author gridnevvvitLet's see, what's the solution for some k = n - 1:1 10 2 9 3 8 4 7 5 6At the odd indexes we placed increasing sequence 1, 2, 3 .., at the even — decreasing sequence n, n - 1, n - 2, ... First, we must get the permutation the way described above, then get first k numbers from it, and then we should make all other distances be equal to 1.This solution works with O(n).Jury's solution: 8394876483D - Interesting Array / 482B - Interesting ArrayProblem author gridnevvvitWe will solve the task for every distinct bit. Now we must handle new constraint: l[i], r[i], q[i]. If number q[i] has 1 in bit with number pos, then all numbers in segment [l[i], r[i]] will have 1 in that bit too. To do that, we can use a standard idea of adding on a segment.Let's do two adding operation in s[pos] array — in position l[i] we will add 1, and in posiotion r[i] + 1 — -1. Then we will calculate partial sums of array s[pos], and if s[pos][i] > 0 (the sum on prefix length i + 1), then bit at position pos will be 1, otherwise — 0.After that, you can use segment tree to check satisfying constraints.Jury's solution: 8394894483E - Game with Strings / 482C - Game with StringsProblem author gridnevvvitLet's handle all string pairs and calculate the mask mask, which will have 1-bits only in positions in which that strings have the same characters. In other words, we could not distinguish these strings using positions with submask of mask mask, then we must add in d[mask] 1-bits in positions i и j. This way in d[mask] we store mask of strings, which we could not distinguish using only positions given in mask mask. Using information described above, we can easily calculate this dynamics.Now, when we have array d calculated, it is not hard to calculate the answer. Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos. After that we may guess some strings, they are 1-bits in mask s = d[mask] ^ d[mask | (1 << pos)]. Then you have to calculate number of bits in s quickly and update the answer.Jury's solution: 8394918482D - Random Function and TreeProblem author RoKiLet's calculate d[v][p] dynamics — the answer for vertex v with size of parity p.At first step to calculate this dynamic for vertex v we should count all different paintings of a subtree visiting all children in increasing order of their numbers. By multiplying this number by 2 we will get paintings visiting children in decreasing order. Now some paintings may count twice. To fix that, let's have a look on a some subtree of a vertex v.Consider all the parities of children subtrees visited by our function (0 or 1). First thing to note is that among these parities exist two different values, the subtree will have different paintings with different ordering (you can prove it yourself). Otherwise, all our children sizes have the same parity.If all sizes are even, this subtree will be counted twice. Otherwise, if sizes are odd, we are interested only in odd count of visited subtrees. This way, we must subtract from our dynamic the number of ways to paint any number of children with even subtree sizes and odd number of children with odd subtree sizes.Jury's solution: 8394936482E - ELCAProblem author danilka.proLet's split all M requests in blocks containing requests each. Every block will be processed following way:First using dfs we need to calculate for every vertex v, where u is every ancestor of v, sizei — size of subtree of vertex i, including itself. This value shows how will the answer change after removing or adding vertex v as child to any other vertex, furthermore, answer will change exactly by pathv·sizev (decreasing or increasing).Then we will calculate chv the same way — the number of all possible vertex pairs, which have LCA in vertex v. This value shows how the answer changes after changing Vv — if Vv changes by dVv, answer changes by chv·dVv.Then mark all vertexes, which occur in our block at least once (in worst case their number is ). Next, mark every vertex being LCA of some pair of already marked vertexes, using DFS. We can prove that final number of these vertexes is at most . After all this we got 'compressed' tree, containing only needed vertexes. Parent of vertex i in compressed tree we will call vertex numbered Pi.On the image above example of this 'compression' way is given. Vertexes colored red are vertexes in request block, blue — vertexes marked after LCA, dotted line — Pv → v edges in compressed tree.On such compressed tree we need to calculate one new value Cv for every vertex v — the size of a vertex, lying on a way from Pv to v after Pv on main (non-compressed) tree (son of a Pv vertex in main tree).Now we should process request on changing parent of vertex v from pv to u on a compressed tree. The answer will change by pathv·sizev. Now for every vertex i, lying on a way from root to Pv vertex, two values will change: sizei will be decreased by sizev, but chi will be decreased by sizev·(sizei - Ct), (Pt = i), but pathi will stay unchanged. For every other vertex j only pathj will be changed: it will be decreased by . After that, we got compressed subtree where subtree of a vertex v is missing. Next, doing the same way as above, all values are changed considering that v (and all it's subtree) is a children of a vertex u. Do not forget to change Cv too.Let's see, how the value-changing request of a vertex v is to be processed. As described above, the answer will be changed by chv·dVv. For every vertex i lying in vertex v subtree only pathi will be changed (it could be easy done using Cto values), all other values stay unchanged.This solution has complexity, but in N = M case it has to be .Авторское решение: 8394944",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 483\\s*C"
          },
          "content_length": 7065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 4",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 5",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 6",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 7",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 8",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 Editorial - Codeforces - Code 9",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // read n from the input file\n    int k = inf.readInt(); // read k from the input file\n\n    // Read contestant's permutation p of length n, integers in [1, n]\n    vector<int> p = ouf.readInts(n, 1, n, \"permutation p\");\n\n    // Check that all numbers are distinct\n    vector<bool> used(n + 1, false); // Index from 1 to n\n    for (int i = 0; i < n; ++i) {\n        if (used[p[i]]) {\n            quitf(_wa, \"number %d occurs more than once\", p[i]);\n        }\n        used[p[i]] = true;\n    }\n\n    // Compute the absolute differences between adjacent elements\n    set<int> diffs;\n    for (int i = 0; i < n - 1; ++i) {\n        int diff = abs(p[i] - p[i + 1]);\n        diffs.insert(diff);\n    }\n\n    // Check if the number of distinct differences is equal to k\n    int num_diffs = diffs.size();\n    if (num_diffs != k) {\n        quitf(_wa, \"number of distinct absolute differences is %d, expected %d\", num_diffs, k);\n    }\n\n    quitf(_ok, \"Correct Answer\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"min_n_min_k\") {\n        n = 2;\n        k = 1;\n    } else if (type == \"max_n_min_k\") {\n        n = 100000;\n        k = 1;\n    } else if (type == \"max_n_max_k\") {\n        n = 100000;\n        k = n - 1;\n    } else if (type == \"small_n_small_k\") {\n        n = rnd.next(2, 100);\n        k = rnd.next(1, min(n - 1, 100));\n    } else if (type == \"small_n_large_k\") {\n        n = rnd.next(2, 100);\n        k = n - 1;\n    } else if (type == \"medium_n_random_k\") {\n        n = rnd.next(1000, 50000);\n        k = rnd.next(1, n - 1);\n    } else if (type == \"max_n_random_k\") {\n        n = 100000;\n        k = rnd.next(1, n - 1);\n    } else if (type == \"random\") {\n        n = rnd.next(2, 100000);\n        k = rnd.next(1, n - 1);\n    } else {\n        // If n and k are provided, ensure they are valid\n        if (n == -1 || k == -1) {\n            fprintf(stderr, \"Invalid parameters! n and k must be provided.\\n\");\n            return 1;\n        }\n        if (k < 1 || k >= n || n < 2 || n > 100000) {\n            fprintf(stderr, \"Invalid parameters! Ensure that 1 ≤ k < n ≤ 10^5.\\n\");\n            return 1;\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"min_n_min_k\") {\n        n = 2;\n        k = 1;\n    } else if (type == \"max_n_min_k\") {\n        n = 100000;\n        k = 1;\n    } else if (type == \"max_n_max_k\") {\n        n = 100000;\n        k = n - 1;\n    } else if (type == \"small_n_small_k\") {\n        n = rnd.next(2, 100);\n        k = rnd.next(1, min(n - 1, 100));\n    } else if (type == \"small_n_large_k\") {\n        n = rnd.next(2, 100);\n        k = n - 1;\n    } else if (type == \"medium_n_random_k\") {\n        n = rnd.next(1000, 50000);\n        k = rnd.next(1, n - 1);\n    } else if (type == \"max_n_random_k\") {\n        n = 100000;\n        k = rnd.next(1, n - 1);\n    } else if (type == \"random\") {\n        n = rnd.next(2, 100000);\n        k = rnd.next(1, n - 1);\n    } else {\n        // If n and k are provided, ensure they are valid\n        if (n == -1 || k == -1) {\n            fprintf(stderr, \"Invalid parameters! n and k must be provided.\\n\");\n            return 1;\n        }\n        if (k < 1 || k >= n || n < 2 || n > 100000) {\n            fprintf(stderr, \"Invalid parameters! Ensure that 1 ≤ k < n ≤ 10^5.\\n\");\n            return 1;\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n_min_k\n\n./gen -type max_n_min_k\n\n./gen -type max_n_max_k\n\n./gen -type small_n_small_k\n./gen -type small_n_small_k\n./gen -type small_n_small_k\n\n./gen -type small_n_large_k\n./gen -type small_n_large_k\n./gen -type small_n_large_k\n\n./gen -type medium_n_random_k\n./gen -type medium_n_random_k\n./gen -type medium_n_random_k\n\n./gen -type max_n_random_k\n./gen -type max_n_random_k\n./gen -type max_n_random_k\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -n 2 -k 1\n./gen -n 3 -k 1\n./gen -n 3 -k 2\n./gen -n 4 -k 1\n./gen -n 4 -k 2\n./gen -n 4 -k 3\n./gen -n 1000 -k 1\n./gen -n 1000 -k 999\n\n./gen -n 99999 -k 1\n./gen -n 99999 -k 50000\n./gen -n 99999 -k 99998\n\n./gen -n 100000 -k 1\n./gen -n 100000 -k 50000\n./gen -n 100000 -k 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:45.081692",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "483/D",
      "title": "D. Интересный массив",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n, m (1 ≤ n ≤ 105, 1 ≤ m ≤ 105) — количество элементов в массиве и количество ограничений.В следующих m строках записано по три целых числа li, ri, qi (1 ≤ li ≤ ri ≤ n, 0 ≤ qi < 230), описывающих i-е ограничение.",
      "output_spec": "Выходные данныеЕсли интересный массив существует, выведите «YES» (без кавычек) в первой строке, а во второй строке выведите n целых чисел a[1], a[2], ..., a[n] (0 ≤ a[i] < 230) — описание интересного массива. Если существует несколько ответов, разрешается вывести любой.Если не существует интересного массива, выведите «NO» (без кавычек) в единственной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 11 3 3Выходные данныеСкопироватьYES3 3 3Входные данныеСкопировать3 21 3 31 3 2Выходные данныеСкопироватьNO",
      "description": "D. Интересный массив\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n, m (1 ≤ n ≤ 105, 1 ≤ m ≤ 105) — количество элементов в массиве и количество ограничений.В следующих m строках записано по три целых числа li, ri, qi (1 ≤ li ≤ ri ≤ n, 0 ≤ qi < 230), описывающих i-е ограничение.\n\nВходные данные\n\nВыходные данныеЕсли интересный массив существует, выведите «YES» (без кавычек) в первой строке, а во второй строке выведите n целых чисел a[1], a[2], ..., a[n] (0 ≤ a[i] < 230) — описание интересного массива. Если существует несколько ответов, разрешается вывести любой.Если не существует интересного массива, выведите «NO» (без кавычек) в единственной строке.\n\nВыходные данные\n\nВходные данныеСкопировать3 11 3 3Выходные данныеСкопироватьYES3 3 3Входные данныеСкопировать3 21 3 31 3 2Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать3 11 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES3 3 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 21 3 31 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Скоро, 24 октября, 21:00 MSK, состоится очередной Codeforces Round #275 для участников из обоих дивизионов. Обратите внимание на необычное время старта раунда!Задачи этого раунда готовила команда Саратовского ГУ #3 в составе: Гриднев Виталий (gridnevvvit), Данил Сагунов (danilka.pro), Роман Киреев (RoKi).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Распределение баллов:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500Соревнование закончено, поздравляем победителей!UPD:Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 740
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces",
          "content": "483A - Опровержение гипотезАвтор задачи gridnevvvitВ задаче предполагалось два решения: Перебрать всевозможные тройки, и проверить, правда ли, что для этой тройки гипотеза неверна. Асимптотика такого решения O(n3logA) Разобрать несколько случаев. Например, это можно сделать так: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Авторское решение: 8394832483B - Друзья и подаркиАвтор задачи gridnevvvitАвторское решение — бинпоиск по ответу. Во-первых, заметим, что если из набора 1, 2, ..., v можно собрать подарки, то и из набора 1, 2, ..., v, v + 1 можно собрать подарки. Пусть f(v) — функция, возвращающая ответ на вопрос: правда ли, что из набора 1, 2, ..., v можно собрать подарки друзьям. пусть f1 — количество чисел, которые делятся на x, а f2 — количество чисел, которые делятся на y. и число both — количество чисел которые делятся и на x, и на y. Тогда в первую очередь первому другу мы постараемся отдать f2 - both чисел, а второму — f1 - both чисел. После этого нужно проверить, сможем ли мы раздать числа, которые не делятся ни на одно из чисел x и y.Таким образом, решение за Авторское решение: 8394846 483C - Разнообразная перестановка / 482A - Разнообразная перестановкаАвтор задачи gridnevvvitРазберем, как работает решение на большом примере, например 1 10 2 9 3 8 4 7 5 6На нечетных местах мы имеем возрастающую последовательность 1, 2, 3 .., а на четных — убывающую последовательность n, n - 1, n - 2, ... Получим таким образом решение, выведем первые k чисел указанной выше последовательности, а потом сделаем так, чтобы соседние разности были равны единице.Решение за асимптотику O(n).Авторское решение: 8394876 483D - Интересный массив / 482B - Интересный массивАвтор задачи gridnevvvitБудем решать задачу отдельно для каждого бита. Предположим, что пришло новое ограничение: l[i], r[i], q[i]. Если в числе q[i] бит с номером pos единичный, то у всех чисел на отрезке [l[i], r[i]] этот бит тоже будет единичным. Теперь можно воспользоваться стандартной идеей прибавления на отрезке оффлайн. Сделаем два прибавления в массиве s[bit] — в позиции l[i] мы сделаем прибавление 1, а еще одно в позиции r[i] + 1, там мы прибавим -1. Таким образом, если мы насчитаем частичные суммы на массиве s[bit], то, если s[bit][i] > 0, то бит bit в этом числе будет единичным, иначе — нет. После этого можно реализовать дерево отрезков, чтобы проверить выполнимость изначальных запросов.Авторское решение: 8394894 483E - Игра со строками / 482C - Игра со строкамиАвтор задачи gridnevvvitПереберем все пары строк, и подсчитаем маску mask — единичные биты будут находится только в позициях, в которых эти две пары строк имеют одинаковые символы. Таким образом, используя биты, соответствующие любой подмаске маски mask, мы не сможем отличить эту пару строк, поэтому добавим в маску d[mask] биты в позиции i и j. Таким образом, в d[mask] мы храним маску тех строк, которые мы не сможем отличить по заданной маске mask. Используя указанную выше информацию, мы сможем просто насчитать эту динамику.Теперь, когда у нас имеется эта динамика, нетрудно восстановить ответ. Переберем маску mask. Попробуем задать еще один вопрос, то есть добавить в эту маску еще один бит. После этого мы могли отгадать некоторые строки, а именно те, что останутся в виде единичных битов в маске s = d[mask] ^ d[mask | (1 << pos)] (pos — позиция нового вопроса). Осталось аккуратно подсчитать количество бит в маске s и пересчитать искомое математическое ожидание.Авторское решение: 8394918 482D - Случайная функция и деревоАвтор задачи RoKiПосчитаем динамику d[v][p] — ответ на задачу для поддерева вершины v с размером, имеющим четность p.Научимся считать эту динамику для вершины v. Для начала посчитаем количество различных раскрасок при обходе потомков в порядке возрастания номеров. Умножим эту величину на 2 и получим раскраски при обходе потомков в порядке убывания номеров. Но теперь, возможно, появились раскраски, которые мы учли 2 раза. Давайте рассмотрим некоторое поддерево вершины v и поймем, когда оно учтется 2 раза.Рассмотрим четности поддеревьев потомков, которых посетила наша функция (0 или 1). Первое, что нужно заметить: если среди этих величин есть различные значения, то такое поддерево при разных обходах будет раскрашено по-разному (это вы можете доказать сами). Теперь все наши посещенные потомки имеют одинаковые по четности размеры поддеревьев. Если размеры поддеревьев четные, то очевидно, что такое дерево учтется 2 раза. А вот если размеры поддеревьев нечетные, то нас интересуют только случаи, когда мы посетили нечетное количество потомков. Таким образом, из нашей динамики нужно вычесть количество способов раскрасить любое количество потомков с четным размером поддерева и нечетное количество потомков с нечетным размером поддерева.Авторское решение: 8394936 482E - ELCAАвтор задачи danilka.proБудем обрабатывать M запросов блоками по штук (таких блоков, очевидно, тоже ). Каждый блок обрабатывается следующим образом:Сначала поиском в глубину посчитаем для каждой вершины v значение , где u — любой предок v, а sizei — размер поддерева вершины i, включая саму вершину. Эта величина характеризует изменение ответа при 'отрывании' или 'прикреплении' вершины v, а именно, после выполнения одной из этих операций ответ изменится на pathv·sizev (уменьшится или увеличится соответственно).Тем же образом посчитаем значение chv — количество всевозможных пар вершин, наименьший общий предок которых равен v. Эта величина характеризует изменение ответа при изменении Vv, а именно, при изменении величины Vv на dVv ответ изменится на chv·dVv.Выделим вершины, номера которых хотя бы один раз встречаются в нашем блоке (в худшем случае таких вершин ). Теперь запустим поиск в глубину, который отметит вершины, являющиеся наименьшими общими предками каких-либо двух выделенных вершин. С помощью метода математической индукции нетрудно доказать, что в худшем случае таких вершин будет ровно . Таким образом мы получили 'сжатое' дерево, содержащее только необходимые вершины. Предка вершины i сжатого дерева обозначим за Pi.На следующем рисунке представлен пример такого 'сжатия'. Красным обозначены вершины в блоке запроса, синим — помеченные вершины, пунктиром — ребра Pv → v сжатого дерева.На таком сжатом дереве нужно посчитать для каждой вершины v еще одну величину Cv — размер поддерева вершины исходного дерева, которая лежит на пути от Pv до v в исходном дереве после Pv (непосредственный сын Pv).Попробуем обработать запрос на смену родителя вершины v с pv на u в сжатом дереве. Ответ, как уже было сказано выше, сначала уменьшится на pathv·sizev. Теперь для каждой вершины i, лежащей на пути от корня до Pv, изменятся две величины: sizei уменьшится на sizev, а chi уменьшится на величину, равную sizev·(sizei - Ct), (Pt = i), а pathi останется прежним. Для всех остальных вершин j, напротив, изменится лишь величина pathj — она уменьшится на . Теперь мы получили сжатое дерево, в котором все величины посчитаны с учетом того, что поддерево вершины v было удалено. Аналогичным образом происходит пересчет величин с учетом добавления вершины v в качестве сына вершины u (не забываем обновлять также и Cv).Посмотрим, как будет выглядеть обработка запроса на смену значения Vv вершины v. Ответ, как было описано, изменится на chv·dVv. Также изменятся все pathi для вершин, лежащих в поддереве v (их несложно пересчитать с помощью значений Cto, все остальные значения останутся прежними.Таким образом, сложность решения составляет , что в случае N = M составляет . Авторское решение: 8394944",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 483\\s*D"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "n - a >= cnt1 && n - b >= cnt2 && n - c >= cnt1 + cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "c = n / ( x + y )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "n - a >= cnt1 && n - b >= cnt2 && n - c >= cnt1 + cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "n - b - f < cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "a = 6 / 2 = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "b = 6 / 3 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "n - a >= cnt1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "n - b >= cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "c = 6 / ( 2 + 3 ) = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "n - c = 5 < 3 + 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "c = n / (x*y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 19",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 20",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 21",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 22",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 23",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 24",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 25",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 26",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 27",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 28",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 29",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 4",
          "code": "O(2^length * n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 5",
          "code": "O(n*length*length)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 6",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 7",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 8",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 9",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 10",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 11",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++){\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"r_i\"); // li <= ri <= n\n        inf.readSpace();\n        int qi = inf.readInt(0, (1<<30)-1, \"q_i\"); // 0 <= qi < 2^30\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++){\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"r_i\"); // li <= ri <= n\n        inf.readSpace();\n        int qi = inf.readInt(0, (1<<30)-1, \"q_i\"); // 0 <= qi < 2^30\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++){\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"r_i\"); // li <= ri <= n\n        inf.readSpace();\n        int qi = inf.readInt(0, (1<<30)-1, \"q_i\"); // 0 <= qi < 2^30\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and m from the input file\n    int n = inf.readInt(1, 100000, \"n\");\n    int m = inf.readInt(1, 100000, \"m\");\n\n    vector<int> L(m), R(m);\n    vector<int> Q(m);\n\n    for (int i = 0; i < m; ++i) {\n        L[i] = inf.readInt(1, n, \"li\");\n        R[i] = inf.readInt(L[i], n, \"ri\");\n        Q[i] = inf.readInt(0, (1LL << 30) - 1, \"qi\");\n    }\n\n    // Read the judge's answer\n    string jans = ans.readToken();\n    transform(jans.begin(), jans.end(), jans.begin(), ::toupper);\n\n    // Read the participant's answer\n    string pans = ouf.readToken();\n    transform(pans.begin(), pans.end(), pans.begin(), ::toupper);\n\n    if (jans == \"NO\") {\n        if (pans == \"NO\") {\n            quitf(_ok, \"Correctly reported that no solution exists.\");\n        } else {\n            quitf(_wa, \"Participant found a solution but none exists according to the judge.\");\n        }\n    } else if (jans == \"YES\") {\n        if (pans != \"YES\") {\n            quitf(_wa, \"Participant failed to find a solution when one exists.\");\n        } else {\n            // Read the participant's array\n            vector<long long> a = ouf.readLongs(n, 0, (1LL << 30) - 1, \"a_i\");\n\n            // Check all constraints\n            for (int i = 0; i < m; ++i) {\n                long long s = a[L[i] - 1];\n                for (int k = L[i]; k < R[i]; ++k) {\n                    s &= a[k];\n                }\n                if (s != Q[i]) {\n                    quitf(_wa, \"Constraint %d is not satisfied: expected %lld, found %lld.\", i + 1, Q[i], s);\n                }\n            }\n            quitf(_ok, \"Correct solution.\");\n        }\n    } else {\n        quitf(_fail, \"Invalid judge's answer.\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int,int,int>> constraints;\n    constraints.reserve(m);\n\n    if (type == \"random\") {\n        // Generate random constraints\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"full\") {\n        // Constraints over the full array\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"single\") {\n        // Constraints over single elements\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = l;\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"overlap\") {\n        // Constraints with overlapping ranges\n        int overlaps = min(m, 10);\n        for (int i = 0; i < overlaps; ++i) {\n            int l = rnd.next(1, n/2);\n            int r = rnd.next(n/2, n);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n        for (int i = overlaps; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"contradictory\") {\n        // Generate constraints that contradict each other\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        int qi1 = rnd.next(0, (1<<30) - 1);\n        int qi2 = qi1 ^ 1; // Ensure qi2 != qi1\n        constraints.emplace_back(l, r, qi1);\n        constraints.emplace_back(l, r, qi2);\n        for (int i = 2; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"mixed\") {\n        // Generate a mix of different types of constraints\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 4);\n            int l, r, qi;\n            if (t == 1) {\n                // Random constraint\n                l = rnd.next(1, n);\n                r = rnd.next(1, n);\n                if (l > r) swap(l, r);\n                qi = rnd.next(0, (1<<30) - 1);\n            } else if (t == 2) {\n                // Single-element constraint\n                l = rnd.next(1, n);\n                r = l;\n                qi = rnd.next(0, (1<<30) - 1);\n            } else if (t == 3) {\n                // Full-array constraint\n                l = 1;\n                r = n;\n                qi = rnd.next(0, (1<<30) - 1);\n            } else {\n                // Overlapping constraint\n                l = rnd.next(1, n/2);\n                r = rnd.next(n/2, n);\n                qi = rnd.next(0, (1<<30) - 1);\n            }\n            constraints.emplace_back(l, r, qi);\n        }\n    } else {\n        // Default to random constraints if type is unrecognized\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << \"\\n\";\n    // Output constraints\n    for (const auto& c : constraints) {\n        int l, r, qi;\n        tie(l, r, qi) = c;\n        cout << l << \" \" << r << \" \" << qi << \"\\n\";\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int,int,int>> constraints;\n    constraints.reserve(m);\n\n    if (type == \"random\") {\n        // Generate random constraints\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"full\") {\n        // Constraints over the full array\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"single\") {\n        // Constraints over single elements\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = l;\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"overlap\") {\n        // Constraints with overlapping ranges\n        int overlaps = min(m, 10);\n        for (int i = 0; i < overlaps; ++i) {\n            int l = rnd.next(1, n/2);\n            int r = rnd.next(n/2, n);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n        for (int i = overlaps; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"contradictory\") {\n        // Generate constraints that contradict each other\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        int qi1 = rnd.next(0, (1<<30) - 1);\n        int qi2 = qi1 ^ 1; // Ensure qi2 != qi1\n        constraints.emplace_back(l, r, qi1);\n        constraints.emplace_back(l, r, qi2);\n        for (int i = 2; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    } else if (type == \"mixed\") {\n        // Generate a mix of different types of constraints\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 4);\n            int l, r, qi;\n            if (t == 1) {\n                // Random constraint\n                l = rnd.next(1, n);\n                r = rnd.next(1, n);\n                if (l > r) swap(l, r);\n                qi = rnd.next(0, (1<<30) - 1);\n            } else if (t == 2) {\n                // Single-element constraint\n                l = rnd.next(1, n);\n                r = l;\n                qi = rnd.next(0, (1<<30) - 1);\n            } else if (t == 3) {\n                // Full-array constraint\n                l = 1;\n                r = n;\n                qi = rnd.next(0, (1<<30) - 1);\n            } else {\n                // Overlapping constraint\n                l = rnd.next(1, n/2);\n                r = rnd.next(n/2, n);\n                qi = rnd.next(0, (1<<30) - 1);\n            }\n            constraints.emplace_back(l, r, qi);\n        }\n    } else {\n        // Default to random constraints if type is unrecognized\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int qi = rnd.next(0, (1<<30) - 1);\n            constraints.emplace_back(l, r, qi);\n        }\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << \"\\n\";\n    // Output constraints\n    for (const auto& c : constraints) {\n        int l, r, qi;\n        tie(l, r, qi) = c;\n        cout << l << \" \" << r << \" \" << qi << \"\\n\";\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Simple random test cases\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n\n# Max size test cases\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type full\n./gen -n 100000 -m 100000 -type single\n\n# Contradictory constraints\n./gen -n 10 -m 2 -type contradictory\n./gen -n 1000 -m 1000 -type contradictory\n\n# Constraints over the full array\n./gen -n 50000 -m 1000 -type full\n./gen -n 50000 -m 50000 -type full\n\n# Single-element constraints\n./gen -n 100000 -m 100000 -type single\n\n# Overlapping constraints\n./gen -n 100 -m 100 -type overlap\n./gen -n 1000 -m 1000 -type overlap\n./gen -n 10000 -m 10000 -type overlap\n\n# Edge cases\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type contradictory\n./gen -n 1 -m 1 -type full\n\n# Varying n and m\n./gen -n 99999 -m 1 -type random\n./gen -n 1 -m 99999 -type single\n\n# Mixed constraints\n./gen -n 10000 -m 10000 -type mixed\n./gen -n 100000 -m 100000 -type mixed\n\n# Additional test cases\n./gen -n 2 -m 2 -type contradictory\n./gen -n 10 -m 20 -type mixed\n./gen -n 50000 -m 1000 -type overlap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:46.897622",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "483/E",
      "title": "E. Игра со строками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 50) — количество строк, придуманных вашим другом.В следующих n строках заданы строки, придуманные вашим другом. Гарантируется, что все строки различны и состоят только из строчных и прописных букв латинского алфавита. Кроме того, длины всех строк одинаковы и лежат в промежутке от 1 до 20 включительно.",
      "output_spec": "Выходные данныеВыведите единственное число — искомое математическое ожидание. Ваш ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 9.",
      "sample_tests": "ПримерыВходные данныеСкопировать2aabaacВыходные данныеСкопировать2.000000000000000Входные данныеСкопировать3aaAaBaCaaВыходные данныеСкопировать1.666666666666667Входные данныеСкопировать3acavacwqqВыходные данныеСкопировать1.000000000000000",
      "description": "E. Игра со строками\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 50) — количество строк, придуманных вашим другом.В следующих n строках заданы строки, придуманные вашим другом. Гарантируется, что все строки различны и состоят только из строчных и прописных букв латинского алфавита. Кроме того, длины всех строк одинаковы и лежат в промежутке от 1 до 20 включительно.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — искомое математическое ожидание. Ваш ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 9.\n\nВыходные данные\n\nВходные данныеСкопировать2aabaacВыходные данныеСкопировать2.000000000000000Входные данныеСкопировать3aaAaBaCaaВыходные данныеСкопировать1.666666666666667Входные данныеСкопировать3acavacwqqВыходные данныеСкопировать1.000000000000000\n\nВходные данныеСкопировать2aabaac\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3aaAaBaCaa\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.666666666666667\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3acavacwqq\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере придуманные строки различаются только символом в третьей позиции. Поэтому возможны следующие ситуации:   вы угадаете загаданную строку за один вопрос. Вероятность этого события ;  вы угадаете загаданную строку за два вопроса. Вероятность этого события равна  ·  =  (поскольку в таком случае первым вопросом нужно спросить про позицию отличную от трех);  вы угадаете загаданную строку за три вопроса. Вероятность этого события равна  ·  ·  = ; Таким образом искомое математическое ожидание равно Во втором примере нам максимум может потребоваться два вопроса, поскольку любая пара вопросов определяет строку. Поэтому искомое математическое ожидание равно .В третьем примере, независимо от того, про какую позицию мы спросим первым вопросом, мы сразу угадаем загаданную строку.",
      "solutions": [
        {
          "title": "Codeforces Round #275 - Codeforces",
          "content": "Скоро, 24 октября, 21:00 MSK, состоится очередной Codeforces Round #275 для участников из обоих дивизионов. Обратите внимание на необычное время старта раунда!Задачи этого раунда готовила команда Саратовского ГУ #3 в составе: Гриднев Виталий (gridnevvvit), Данил Сагунов (danilka.pro), Роман Киреев (RoKi).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Распределение баллов:Div1: 500 1500 1500 2000 2500Dvi2: 500 1000 1500 2500 2500Соревнование закончено, поздравляем победителей!UPD:Div1: tourist Petr subscriber uwi PavelKunyavskiy mmaxio Ra16bit Div2: dickXD meodorewan charlie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14387",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 740
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces",
          "content": "483A - Опровержение гипотезАвтор задачи gridnevvvitВ задаче предполагалось два решения: Перебрать всевозможные тройки, и проверить, правда ли, что для этой тройки гипотеза неверна. Асимптотика такого решения O(n3logA) Разобрать несколько случаев. Например, это можно сделать так: if (l % 2 != 0)\n l++;\n\n if (l + 2 > r)\n out.println(-1);\n else\n out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n Авторское решение: 8394832483B - Друзья и подаркиАвтор задачи gridnevvvitАвторское решение — бинпоиск по ответу. Во-первых, заметим, что если из набора 1, 2, ..., v можно собрать подарки, то и из набора 1, 2, ..., v, v + 1 можно собрать подарки. Пусть f(v) — функция, возвращающая ответ на вопрос: правда ли, что из набора 1, 2, ..., v можно собрать подарки друзьям. пусть f1 — количество чисел, которые делятся на x, а f2 — количество чисел, которые делятся на y. и число both — количество чисел которые делятся и на x, и на y. Тогда в первую очередь первому другу мы постараемся отдать f2 - both чисел, а второму — f1 - both чисел. После этого нужно проверить, сможем ли мы раздать числа, которые не делятся ни на одно из чисел x и y.Таким образом, решение за Авторское решение: 8394846 483C - Разнообразная перестановка / 482A - Разнообразная перестановкаАвтор задачи gridnevvvitРазберем, как работает решение на большом примере, например 1 10 2 9 3 8 4 7 5 6На нечетных местах мы имеем возрастающую последовательность 1, 2, 3 .., а на четных — убывающую последовательность n, n - 1, n - 2, ... Получим таким образом решение, выведем первые k чисел указанной выше последовательности, а потом сделаем так, чтобы соседние разности были равны единице.Решение за асимптотику O(n).Авторское решение: 8394876 483D - Интересный массив / 482B - Интересный массивАвтор задачи gridnevvvitБудем решать задачу отдельно для каждого бита. Предположим, что пришло новое ограничение: l[i], r[i], q[i]. Если в числе q[i] бит с номером pos единичный, то у всех чисел на отрезке [l[i], r[i]] этот бит тоже будет единичным. Теперь можно воспользоваться стандартной идеей прибавления на отрезке оффлайн. Сделаем два прибавления в массиве s[bit] — в позиции l[i] мы сделаем прибавление 1, а еще одно в позиции r[i] + 1, там мы прибавим -1. Таким образом, если мы насчитаем частичные суммы на массиве s[bit], то, если s[bit][i] > 0, то бит bit в этом числе будет единичным, иначе — нет. После этого можно реализовать дерево отрезков, чтобы проверить выполнимость изначальных запросов.Авторское решение: 8394894 483E - Игра со строками / 482C - Игра со строкамиАвтор задачи gridnevvvitПереберем все пары строк, и подсчитаем маску mask — единичные биты будут находится только в позициях, в которых эти две пары строк имеют одинаковые символы. Таким образом, используя биты, соответствующие любой подмаске маски mask, мы не сможем отличить эту пару строк, поэтому добавим в маску d[mask] биты в позиции i и j. Таким образом, в d[mask] мы храним маску тех строк, которые мы не сможем отличить по заданной маске mask. Используя указанную выше информацию, мы сможем просто насчитать эту динамику.Теперь, когда у нас имеется эта динамика, нетрудно восстановить ответ. Переберем маску mask. Попробуем задать еще один вопрос, то есть добавить в эту маску еще один бит. После этого мы могли отгадать некоторые строки, а именно те, что останутся в виде единичных битов в маске s = d[mask] ^ d[mask | (1 << pos)] (pos — позиция нового вопроса). Осталось аккуратно подсчитать количество бит в маске s и пересчитать искомое математическое ожидание.Авторское решение: 8394918 482D - Случайная функция и деревоАвтор задачи RoKiПосчитаем динамику d[v][p] — ответ на задачу для поддерева вершины v с размером, имеющим четность p.Научимся считать эту динамику для вершины v. Для начала посчитаем количество различных раскрасок при обходе потомков в порядке возрастания номеров. Умножим эту величину на 2 и получим раскраски при обходе потомков в порядке убывания номеров. Но теперь, возможно, появились раскраски, которые мы учли 2 раза. Давайте рассмотрим некоторое поддерево вершины v и поймем, когда оно учтется 2 раза.Рассмотрим четности поддеревьев потомков, которых посетила наша функция (0 или 1). Первое, что нужно заметить: если среди этих величин есть различные значения, то такое поддерево при разных обходах будет раскрашено по-разному (это вы можете доказать сами). Теперь все наши посещенные потомки имеют одинаковые по четности размеры поддеревьев. Если размеры поддеревьев четные, то очевидно, что такое дерево учтется 2 раза. А вот если размеры поддеревьев нечетные, то нас интересуют только случаи, когда мы посетили нечетное количество потомков. Таким образом, из нашей динамики нужно вычесть количество способов раскрасить любое количество потомков с четным размером поддерева и нечетное количество потомков с нечетным размером поддерева.Авторское решение: 8394936 482E - ELCAАвтор задачи danilka.proБудем обрабатывать M запросов блоками по штук (таких блоков, очевидно, тоже ). Каждый блок обрабатывается следующим образом:Сначала поиском в глубину посчитаем для каждой вершины v значение , где u — любой предок v, а sizei — размер поддерева вершины i, включая саму вершину. Эта величина характеризует изменение ответа при 'отрывании' или 'прикреплении' вершины v, а именно, после выполнения одной из этих операций ответ изменится на pathv·sizev (уменьшится или увеличится соответственно).Тем же образом посчитаем значение chv — количество всевозможных пар вершин, наименьший общий предок которых равен v. Эта величина характеризует изменение ответа при изменении Vv, а именно, при изменении величины Vv на dVv ответ изменится на chv·dVv.Выделим вершины, номера которых хотя бы один раз встречаются в нашем блоке (в худшем случае таких вершин ). Теперь запустим поиск в глубину, который отметит вершины, являющиеся наименьшими общими предками каких-либо двух выделенных вершин. С помощью метода математической индукции нетрудно доказать, что в худшем случае таких вершин будет ровно . Таким образом мы получили 'сжатое' дерево, содержащее только необходимые вершины. Предка вершины i сжатого дерева обозначим за Pi.На следующем рисунке представлен пример такого 'сжатия'. Красным обозначены вершины в блоке запроса, синим — помеченные вершины, пунктиром — ребра Pv → v сжатого дерева.На таком сжатом дереве нужно посчитать для каждой вершины v еще одну величину Cv — размер поддерева вершины исходного дерева, которая лежит на пути от Pv до v в исходном дереве после Pv (непосредственный сын Pv).Попробуем обработать запрос на смену родителя вершины v с pv на u в сжатом дереве. Ответ, как уже было сказано выше, сначала уменьшится на pathv·sizev. Теперь для каждой вершины i, лежащей на пути от корня до Pv, изменятся две величины: sizei уменьшится на sizev, а chi уменьшится на величину, равную sizev·(sizei - Ct), (Pt = i), а pathi останется прежним. Для всех остальных вершин j, напротив, изменится лишь величина pathj — она уменьшится на . Теперь мы получили сжатое дерево, в котором все величины посчитаны с учетом того, что поддерево вершины v было удалено. Аналогичным образом происходит пересчет величин с учетом добавления вершины v в качестве сына вершины u (не забываем обновлять также и Cv).Посмотрим, как будет выглядеть обработка запроса на смену значения Vv вершины v. Ответ, как было описано, изменится на chv·dVv. Также изменятся все pathi для вершин, лежащих в поддереве v (их несложно пересчитать с помощью значений Cto, все остальные значения останутся прежними.Таким образом, сложность решения составляет , что в случае N = M составляет . Авторское решение: 8394944",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 483\\s*E"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #275 - Codeforces - Code 1",
          "code": "n - a >= cnt1 && n - b >= cnt2 && n - c >= cnt1 + cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 2",
          "code": "c = n / ( x + y )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 3",
          "code": "n - a >= cnt1 && n - b >= cnt2 && n - c >= cnt1 + cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 4",
          "code": "n - b - f < cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 5",
          "code": "a = 6 / 2 = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 6",
          "code": "b = 6 / 3 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 7",
          "code": "n - a >= cnt1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 8",
          "code": "n - b >= cnt2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 9",
          "code": "c = 6 / ( 2 + 3 ) = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 10",
          "code": "n - c = 5 < 3 + 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 11",
          "code": "c = n / (x*y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 12",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 13",
          "code": "Our answer:\n1 n 2 n-1 ... n/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 14",
          "code": "latest number (- OR +) 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 15",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 16",
          "code": "For example: N = 9, K = 3\n1 9 2 3 4 5 6 7 8\nAnd N = 9 K = 4\n1 9 2 8 7 6 5 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 17",
          "code": "K mod 2 is equal to 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 18",
          "code": "latest number - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 19",
          "code": "latest number + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 20",
          "code": "a[i] = a[i] |  V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 21",
          "code": "seg[node] = seg[2*node] & seg[2*node+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 22",
          "code": "value(L,R) = V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 23",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 24",
          "code": "a = 3 + 1 = 4\na - a/6 >= 1 + 3\nreturn 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 25",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 26",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 27",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 28",
          "code": "arr[n-1] += arr[n];\narr[n-2] += arr[n-1];\narr[n-3] += arr[n-2];\n...\n...\narr[2] += arr[3];\narr[1] += arr[2];\narr[0] += arr[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #275 - Codeforces - Code 29",
          "code": "arr[a] to arr[b]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14387",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 1",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 2",
          "code": "if (l % 2 != 0)\n      l++;\n   \n  if (l + 2 > r)\n    out.println(-1);\n  else\n    out.println(l + \" \" + (l + 1) + \" \" + (l + 2));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 3",
          "code": "s = d[mask] ^ d[mask | (1 << pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 4",
          "code": "O(2^length * n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 5",
          "code": "O(n*length*length)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 6",
          "code": "frac = bitCount(d[mask ^ (1<<pos)]) / bitCount(d[mask])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 7",
          "code": "1 + dp[mask ^ (1<<pos)] * frac",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 8",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 9",
          "code": "#include <iostream>\n\nusing namespace std;\n\n\nint main()\n{\n    int cnt1,cnt2,x,y;\n    cin >>cnt1 >>cnt2 >>x >>y;\n    int l=1,r=INT_MAX,m;\n    while(l<r){\n        m=(r-l)/2+l;\n        if(m-m/x>=cnt1 && m-m/y>=cnt2 && m-m/(x*y)>=cnt1+cnt2){\n            r=m;\n        }\n        else{\n            l=m+1;\n        }\n    }\n    cout <<r;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 10",
          "code": "Let's handle some mask mask. Now we should try to make one more question in position pos, which is equal to adding one more 1-bit in mask in position pos.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #275 - Codeforces - Code 11",
          "code": "s = d[mask]^d[mask|(1<<pos)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    set<string> stringSet;\n\n    // Read the first string\n    string s = inf.readLine(\"^[a-zA-Z]{1,20}$\", \"s\");\n    int m = s.length();\n\n    stringSet.insert(s);\n\n    string regexPattern = \"^[a-zA-Z]{\" + to_string(m) + \"}$\";\n\n    for (int i = 1; i < n; i++) {\n        string t = inf.readLine(regexPattern, \"s\");\n\n        ensuref(stringSet.count(t) == 0, \"The strings must be distinct, but string number %d is duplicated\", i + 1);\n\n        stringSet.insert(t);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    set<string> stringSet;\n\n    // Read the first string\n    string s = inf.readLine(\"^[a-zA-Z]{1,20}$\", \"s\");\n    int m = s.length();\n\n    stringSet.insert(s);\n\n    string regexPattern = \"^[a-zA-Z]{\" + to_string(m) + \"}$\";\n\n    for (int i = 1; i < n; i++) {\n        string t = inf.readLine(regexPattern, \"s\");\n\n        ensuref(stringSet.count(t) == 0, \"The strings must be distinct, but string number %d is duplicated\", i + 1);\n\n        stringSet.insert(t);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    set<string> stringSet;\n\n    // Read the first string\n    string s = inf.readLine(\"^[a-zA-Z]{1,20}$\", \"s\");\n    int m = s.length();\n\n    stringSet.insert(s);\n\n    string regexPattern = \"^[a-zA-Z]{\" + to_string(m) + \"}$\";\n\n    for (int i = 1; i < n; i++) {\n        string t = inf.readLine(regexPattern, \"s\");\n\n        ensuref(stringSet.count(t) == 0, \"The strings must be distinct, but string number %d is duplicated\", i + 1);\n\n        stringSet.insert(t);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random uppercase or lowercase letter\nchar randomChar() {\n    int t = rnd.next(52); // 26 uppercase + 26 lowercase letters\n    if (t < 26)\n        return 'A' + t;\n    else\n        return 'a' + (t - 26);\n}\n\n// Function to generate a random string of length m\nstring randomString(int m) {\n    string s(m, '.');\n    for (int i = 0; i < m; ++i) {\n        s[i] = randomChar();\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 10);\n    string type = opt<string>(\"type\", \"random\");\n    int cluster_size = opt<int>(\"cluster_size\", 5);\n\n    vector<string> strings;\n\n    if (type == \"random\") {\n        // Generate n random distinct strings of length m\n        set<string> S;\n        while ((int)S.size() < n) {\n            string s = randomString(m);\n            S.insert(s);\n        }\n        strings.assign(S.begin(), S.end());\n    } else if (type == \"single_diff\") {\n        // All strings are identical except at one position\n        if (m < 1) {\n            fprintf(stderr, \"String length m must be at least 1 for type 'single_diff'\\n\");\n            exit(1);\n        }\n        if (n > 52) {\n            fprintf(stderr, \"n cannot be greater than 52 for type 'single_diff'\\n\");\n            exit(1);\n        }\n        string base = randomString(m);\n        int pos = rnd.next(0, m - 1);\n        set<char> used_chars;\n        used_chars.insert(base[pos]);\n\n        for (int i = 0; i < n; ++i) {\n            string s = base;\n            // Generate a character different from base[pos] and other used characters\n            while (true) {\n                char c = randomChar();\n                if (used_chars.count(c) == 0) {\n                    s[pos] = c;\n                    used_chars.insert(c);\n                    break;\n                }\n            }\n            strings.push_back(s);\n        }\n    } else if (type == \"same_prefix\") {\n        // All strings share a common prefix\n        if (m < 2) {\n            fprintf(stderr, \"String length m must be at least 2 for type 'same_prefix'\\n\");\n            exit(1);\n        }\n        int prefix_length = rnd.next(1, m - 1);\n        string prefix = randomString(prefix_length);\n\n        set<string> S;\n        while ((int)S.size() < n) {\n            string suffix = randomString(m - prefix_length);\n            string s = prefix + suffix;\n            S.insert(s);\n        }\n        strings.assign(S.begin(), S.end());\n    } else if (type == \"max_different\") {\n        // All strings differ at every position\n        if (n > 52) {\n            fprintf(stderr, \"n cannot be greater than 52 for type 'max_different'\\n\");\n            exit(1);\n        }\n        vector<char> letters;\n        for (int i = 0; i < 52; ++i) {\n            letters.push_back(randomChar());\n        }\n        letters.resize(n);\n\n        for (int i = 0; i < n; ++i) {\n            strings.push_back(string(m, '.'));\n        }\n        for (int pos = 0; pos < m; ++pos) {\n            shuffle(letters.begin(), letters.end());\n            for (int i = 0; i < n; ++i) {\n                strings[i][pos] = letters[i];\n            }\n        }\n    } else if (type == \"clusters\") {\n        // Group strings into clusters\n        if (cluster_size < 1) {\n            fprintf(stderr, \"cluster_size must be at least 1\\n\");\n            exit(1);\n        }\n        int num_clusters = (n + cluster_size - 1) / cluster_size;\n        int generated_strings = 0;\n\n        for (int c = 0; c < num_clusters && generated_strings < n; ++c) {\n            string base = randomString(m);\n            set<string> cluster_set;\n            cluster_set.insert(base);\n\n            while ((int)cluster_set.size() < cluster_size && generated_strings + (int)cluster_set.size() < n) {\n                string s = base;\n                int num_changes = rnd.next(1, m); // Change at least 1 position\n                set<int> positions;\n                while ((int)positions.size() < num_changes) {\n                    positions.insert(rnd.next(0, m - 1));\n                }\n                for (int pos : positions) {\n                    s[pos] = randomChar();\n                }\n                cluster_set.insert(s);\n            }\n\n            for (const string& s : cluster_set) {\n                strings.push_back(s);\n                generated_strings++;\n                if (generated_strings >= n) break;\n            }\n        }\n    } else if (type == \"minimal_length\") {\n        // Strings of minimal length (m = 1)\n        m = 1;\n        set<string> S;\n        while ((int)S.size() < n) {\n            string s = randomString(m);\n            S.insert(s);\n        }\n        strings.assign(S.begin(), S.end());\n    } else {\n        // Unknown type, default to random\n        fprintf(stderr, \"Unknown type '%s', defaulting to 'random'\\n\", type.c_str());\n        set<string> S;\n        while ((int)S.size() < n) {\n            string s = randomString(m);\n            S.insert(s);\n        }\n        strings.assign(S.begin(), S.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the strings\n    for (const string& s : strings) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random uppercase or lowercase letter\nchar randomChar() {\n    int t = rnd.next(52); // 26 uppercase + 26 lowercase letters\n    if (t < 26)\n        return 'A' + t;\n    else\n        return 'a' + (t - 26);\n}\n\n// Function to generate a random string of length m\nstring randomString(int m) {\n    string s(m, '.');\n    for (int i = 0; i < m; ++i) {\n        s[i] = randomChar();\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 10);\n    string type = opt<string>(\"type\", \"random\");\n    int cluster_size = opt<int>(\"cluster_size\", 5);\n\n    vector<string> strings;\n\n    if (type == \"random\") {\n        // Generate n random distinct strings of length m\n        set<string> S;\n        while ((int)S.size() < n) {\n            string s = randomString(m);\n            S.insert(s);\n        }\n        strings.assign(S.begin(), S.end());\n    } else if (type == \"single_diff\") {\n        // All strings are identical except at one position\n        if (m < 1) {\n            fprintf(stderr, \"String length m must be at least 1 for type 'single_diff'\\n\");\n            exit(1);\n        }\n        if (n > 52) {\n            fprintf(stderr, \"n cannot be greater than 52 for type 'single_diff'\\n\");\n            exit(1);\n        }\n        string base = randomString(m);\n        int pos = rnd.next(0, m - 1);\n        set<char> used_chars;\n        used_chars.insert(base[pos]);\n\n        for (int i = 0; i < n; ++i) {\n            string s = base;\n            // Generate a character different from base[pos] and other used characters\n            while (true) {\n                char c = randomChar();\n                if (used_chars.count(c) == 0) {\n                    s[pos] = c;\n                    used_chars.insert(c);\n                    break;\n                }\n            }\n            strings.push_back(s);\n        }\n    } else if (type == \"same_prefix\") {\n        // All strings share a common prefix\n        if (m < 2) {\n            fprintf(stderr, \"String length m must be at least 2 for type 'same_prefix'\\n\");\n            exit(1);\n        }\n        int prefix_length = rnd.next(1, m - 1);\n        string prefix = randomString(prefix_length);\n\n        set<string> S;\n        while ((int)S.size() < n) {\n            string suffix = randomString(m - prefix_length);\n            string s = prefix + suffix;\n            S.insert(s);\n        }\n        strings.assign(S.begin(), S.end());\n    } else if (type == \"max_different\") {\n        // All strings differ at every position\n        if (n > 52) {\n            fprintf(stderr, \"n cannot be greater than 52 for type 'max_different'\\n\");\n            exit(1);\n        }\n        vector<char> letters;\n        for (int i = 0; i < 52; ++i) {\n            letters.push_back(randomChar());\n        }\n        letters.resize(n);\n\n        for (int i = 0; i < n; ++i) {\n            strings.push_back(string(m, '.'));\n        }\n        for (int pos = 0; pos < m; ++pos) {\n            shuffle(letters.begin(), letters.end());\n            for (int i = 0; i < n; ++i) {\n                strings[i][pos] = letters[i];\n            }\n        }\n    } else if (type == \"clusters\") {\n        // Group strings into clusters\n        if (cluster_size < 1) {\n            fprintf(stderr, \"cluster_size must be at least 1\\n\");\n            exit(1);\n        }\n        int num_clusters = (n + cluster_size - 1) / cluster_size;\n        int generated_strings = 0;\n\n        for (int c = 0; c < num_clusters && generated_strings < n; ++c) {\n            string base = randomString(m);\n            set<string> cluster_set;\n            cluster_set.insert(base);\n\n            while ((int)cluster_set.size() < cluster_size && generated_strings + (int)cluster_set.size() < n) {\n                string s = base;\n                int num_changes = rnd.next(1, m); // Change at least 1 position\n                set<int> positions;\n                while ((int)positions.size() < num_changes) {\n                    positions.insert(rnd.next(0, m - 1));\n                }\n                for (int pos : positions) {\n                    s[pos] = randomChar();\n                }\n                cluster_set.insert(s);\n            }\n\n            for (const string& s : cluster_set) {\n                strings.push_back(s);\n                generated_strings++;\n                if (generated_strings >= n) break;\n            }\n        }\n    } else if (type == \"minimal_length\") {\n        // Strings of minimal length (m = 1)\n        m = 1;\n        set<string> S;\n        while ((int)S.size() < n) {\n            string s = randomString(m);\n            S.insert(s);\n        }\n        strings.assign(S.begin(), S.end());\n    } else {\n        // Unknown type, default to random\n        fprintf(stderr, \"Unknown type '%s', defaulting to 'random'\\n\", type.c_str());\n        set<string> S;\n        while ((int)S.size() < n) {\n            string s = randomString(m);\n            S.insert(s);\n        }\n        strings.assign(S.begin(), S.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the strings\n    for (const string& s : strings) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Random strings of minimal length\n./gen -n 1 -m 1 -type minimal_length\n./gen -n 50 -m 1 -type minimal_length\n\n# Test case 2: Random strings of maximal length\n./gen -n 1 -m 20 -type random\n./gen -n 50 -m 20 -type random\n\n# Test case 3: All strings differ at every position\n./gen -n 50 -m 20 -type max_different\n\n# Test case 4: All strings are identical except at one position\n./gen -n 50 -m 20 -type single_diff\n\n# Test case 5: All strings share a common prefix\n./gen -n 50 -m 20 -type same_prefix\n\n# Test case 6: Strings grouped into clusters\n./gen -n 50 -m 20 -type clusters -cluster_size 5\n./gen -n 50 -m 20 -type clusters -cluster_size 10\n\n# Test case 7: Strings with only uppercase letters\n./gen -n 50 -m 20 -type random\n\n# Test case 8: Strings with only lowercase letters\n./gen -n 50 -m 20 -type random\n\n# Test case 9: Strings of varying lengths\n./gen -n 10 -m 2 -type random\n./gen -n 20 -m 5 -type random\n./gen -n 30 -m 10 -type random\n./gen -n 40 -m 15 -type random\n./gen -n 50 -m 20 -type random\n\n# Test case 10: Edge cases with n = 1 and n = 50\n./gen -n 1 -m 10 -type random\n./gen -n 50 -m 10 -type random\n\n# Test case 11: All strings are identical except at multiple positions\n./gen -n 50 -m 20 -type clusters -cluster_size 50\n\n# Test case 12: Strings differ at exactly half of the positions\n./gen -n 50 -m 20 -type clusters -cluster_size 2\n\n# Test case 13: Minimal case\n./gen -n 1 -m 1 -type random\n\n# Test case 14: Maximal case\n./gen -n 50 -m 20 -type random\n\n# Test case 15: Random strings with potential duplicates (to test uniqueness constraint)\n./gen -n 50 -m 20 -type random\n\n# Test case 16: All strings differ by only one character\n./gen -n 50 -m 20 -type single_diff\n\n# Test case 17: Strings with maximum possible overlap\n./gen -n 50 -m 20 -type same_prefix\n\n# Test case 18: Testing with cluster size equal to n (all strings in one cluster)\n./gen -n 50 -m 20 -type clusters -cluster_size 50\n\n# Test case 19: Testing with cluster size of 1 (all strings are completely random)\n./gen -n 50 -m 20 -type clusters -cluster_size 1\n\n# Test case 20: Random strings with m = n\n./gen -n 20 -m 20 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:48.697138",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "484/A",
      "title": "A. Bits",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n — the number of queries (1 ≤ n ≤ 10000).Each of the following n lines contain two integers li, ri — the arguments for the corresponding query (0 ≤ li ≤ ri ≤ 1018).",
      "output_spec": "OutputFor each query print the answer in a separate line.",
      "sample_tests": "ExamplesInputCopy31 22 41 10OutputCopy137",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n — the number of queries (1 ≤ n ≤ 10000).Each of the following n lines contain two integers li, ri — the arguments for the corresponding query (0 ≤ li ≤ ri ≤ 1018).\n\nOutputFor each query print the answer in a separate line.\n\nInputCopy31 22 41 10OutputCopy137\n\nInputCopy31 22 41 10\n\nOutputCopy137\n\nNoteThe binary representations of numbers from 1 to 10 are listed below:110 = 12210 = 102310 = 112410 = 1002510 = 1012610 = 1102710 = 1112810 = 10002910 = 100121010 = 10102",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Hello everybody!Today will be Codeforces Round #276, which take place in both divisions. Start time is 19:30 in moscow time (follow this link to see time in others zones). For preparing contest i say thanks to Zlobober, for translating to Delinur, and to MikeMirzayanov for project Codeforces.Good luck to all, hope you will enjoy problems :)UPD Score distribution will be dynamic (see more information here). Problems will be sorted in increasing order of difficulty, however, do not forget to read all problems before the end of the contest.UPD The contest is over! Thanks to everyone who solved the problems despite everything. Analysis will be published later.UPD Editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 696
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - FactoryProduction will stops iff exists integer K ≥ 0 such a·2K is divisible by m. From this fact follows that K maximum will be about O(log2(m)). So if we modeling some, for example, 20 days and production does not stop, then it will never stop and answer is \"No\". Otherwise answer is \"Yes\".485B - Valuable ResourcesLet us find minimum length needed to cover points by Ox. It is Maximum(xi) - Minumum(xi). The same in Oy — Maximum(yi) - Minumum(yi). Since we need a square city to cover all the mines, then we need to set length of this square to the maximum from those two values.484A - BitsLet us define function f(L, R), that gives answer to the query. It looks follows: if L = R then f(L, R) = L; else if 2b ≤ L, where b — maximum integer such 2b ≤ R, then f(L, R) = f(L - 2b, R - 2b) + 2b; else if 2b + 1 - 1 ≤ R then f(L, R) = 2b + 1 - 1; else f(L, R) = 2b - 1. Total complexity is O(logR) per query.484B - Maximum ValueLet us iterate over all different aj. Since we need to maximize , then iterate all integer x (such x divisible by aj) in range from 2aj to M, where M — doubled maximum value of the sequence. For each such x we need to find maximum ai, such ai < x. Limits for numbers allow to do this in time O(1) with an array. After that, update answer by value . Total time complexity is O(nlogn + MlogM).484C - Strange SortingNote, that d-sorting is just a permutation (call it P), because it does not depends on characters in string. Look at shuffling operation in different way: instead of going to the next substring and sort it, we will shift string to one character left. It remains to understand that shift of string the permutation too (call it C). Now its clear, we need to calculate S·P·C·P·C... = S·(P·C)n - k + 1. And after that shift string for k - 1 character to the left for making answer to the shuffling operation. Here we use the multiplication of permutations. Since they are associative, that we can use binary algorithm to calculate (P·C)n - k + 1. Total time complexity is O(nmlogn).484D - KindergartenLet us note, that in optimal answer any segment that making a group contains their minimum and maximum values on borders. Otherwise it will be better to split this segment to two other segments. Another note that is every segment in optimal solution is strictly monotonic (increasing or decreasing). Paying attention to the interesting points in sequence which making local maximums (i. e. ai - 1 < ai > ai + 1), local minimums (ai - 1 > ai < ai + 1), and point adjacent to them. Solve the problem by dynamic programming: Di is the answer in the prefix i. To calculate Di we need to look at no more than three previous interesting points and to previous Di - 1. Total time complexity is O(n).484E - Sign on FenceLet us note that we can use binary search to find answer to the one query. Suppose at some moment was fixed height h and need to know will fit the rectangle with width w and height h to the segment of fence from l-th to r-th panel. Let us build data structure that can answer to this question. This will be persistent segment tree with unusual function inside: maximum number of consecutive ones in segment (maxOnes). In leaves of segment tree will be only numbers 0 and 1. To calculate this function need to know some other values, specifically:len — length of the segment in vertex of segment tree, prefOnes — length of prefix that consists only of ones, sufOnes — length of the suffix consist only of ones.These functions are computed as follows:maxOnes is equal to max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes equals prefOnes(Right) + len(Left) in case of len(Left) = prefOnes(Left), and prefOnes(Left) otherwise;sufOnes equals sufOnes(Left) + len(Right) in case of len(Right) = sufOnes(Right), and sufOnes(Right) otherwise;len = len(left) + len(Right);Left и Right — it is left and right sons of vertex in segment tree.As mentioned above, tree must be persistent, and it must be built as follows. First, builded empty tree of zeros. Next in position of highest plank need to put 1. The same doing for planks in decreasing order. For example if fence described with sequence [2, 5, 5, 1, 3] then bottom of segment tree will changed as follows:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].And we need to remember for all hi their version of tree. Now to answer the question we need to make query in our segment tree (that corresponding to height h) on segment [l, r]. If maxOnes form this query less than w, then rectangle impossible to put (otherwise possible).Building of tree will take O(nlogn) time and memory. Time complexity to the one query will take O(log2n) time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 484\\s*A"
          },
          "content_length": 4729
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long l = inf.readLong(0LL, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long r = inf.readLong(l, 1000000000000000000LL, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long l = inf.readLong(0LL, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long r = inf.readLong(l, 1000000000000000000LL, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long l = inf.readLong(0LL, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long r = inf.readLong(l, 1000000000000000000LL, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            // Generate random l_i and r_i\n            long long l = rnd.next(0LL, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            printf(\"%lld %lld\\n\", l, r);\n        }\n    } else if (type == \"maxrange\") {\n        // l_i = 0, r_i = 1e18\n        for (int i = 0; i < n; ++i) {\n            printf(\"0 1000000000000000000\\n\");\n        }\n    } else if (type == \"minrange\") {\n        // l_i = r_i\n        for (int i = 0; i < n; ++i) {\n            long long x = rnd.next(0LL, (long long)1e18);\n            printf(\"%lld %lld\\n\", x, x);\n        }\n    } else if (type == \"edgecaselower\") {\n        // l_i = 0, r_i small\n        for (int i = 0; i < n; ++i) {\n            long long r = rnd.next(0LL, 1000LL);\n            printf(\"0 %lld\\n\", r);\n        }\n    } else if (type == \"edgecaseupper\") {\n        // l_i large, r_i = 1e18\n        for (int i = 0; i < n; ++i) {\n            long long l = rnd.next((long long)1e18 - 1000, (long long)1e18);\n            printf(\"%lld 1000000000000000000\\n\", l);\n        }\n    } else if (type == \"poweroftwoboundary\") {\n        // l_i and r_i near a power of two\n        for (int i = 0; i < n; ++i) {\n            int k = rnd.next(0, 60);  // since 2^60 > 1e18\n            long long pow2 = 1LL << k;\n            long long l = pow2 - rnd.next(0LL, 100LL);\n            long long r = pow2 + rnd.next(0LL, 100LL);\n            l = max(l, 0LL);\n            r = min(r, (long long)1e18);\n            if (l > r) swap(l, r);\n            printf(\"%lld %lld\\n\", l, r);\n        }\n    } else if (type == \"maxbitsatends\") {\n        // l_i and r_i such that x with max bits is at l_i or r_i\n        for (int i = 0; i < n; ++i) {\n            int bits = rnd.next(1, 60);  // number of bits set\n            vector<int> positions(60);\n            iota(positions.begin(), positions.end(), 0);\n            shuffle(positions.begin(), positions.end());\n            long long x = 0;\n            for (int j = 0; j < bits; ++j) {\n                x |= (1LL << positions[j]);\n            }\n            x = min(x, (long long)1e18);\n            // Generate random l and r around x\n            long long l = x - rnd.next(0LL, min(x, 1000000LL));\n            l = max(l, 0LL);\n            long long r = x + rnd.next(0LL, 1000000LL);\n            r = min(r, (long long)1e18);\n            // Ensure l <= x <= r\n            if (rnd.next(0,1)) l = x;\n            else r = x;\n            if (l > r) swap(l, r);\n            printf(\"%lld %lld\\n\", l, r);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            long long l = rnd.next(0LL, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            printf(\"%lld %lld\\n\", l, r);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            // Generate random l_i and r_i\n            long long l = rnd.next(0LL, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            printf(\"%lld %lld\\n\", l, r);\n        }\n    } else if (type == \"maxrange\") {\n        // l_i = 0, r_i = 1e18\n        for (int i = 0; i < n; ++i) {\n            printf(\"0 1000000000000000000\\n\");\n        }\n    } else if (type == \"minrange\") {\n        // l_i = r_i\n        for (int i = 0; i < n; ++i) {\n            long long x = rnd.next(0LL, (long long)1e18);\n            printf(\"%lld %lld\\n\", x, x);\n        }\n    } else if (type == \"edgecaselower\") {\n        // l_i = 0, r_i small\n        for (int i = 0; i < n; ++i) {\n            long long r = rnd.next(0LL, 1000LL);\n            printf(\"0 %lld\\n\", r);\n        }\n    } else if (type == \"edgecaseupper\") {\n        // l_i large, r_i = 1e18\n        for (int i = 0; i < n; ++i) {\n            long long l = rnd.next((long long)1e18 - 1000, (long long)1e18);\n            printf(\"%lld 1000000000000000000\\n\", l);\n        }\n    } else if (type == \"poweroftwoboundary\") {\n        // l_i and r_i near a power of two\n        for (int i = 0; i < n; ++i) {\n            int k = rnd.next(0, 60);  // since 2^60 > 1e18\n            long long pow2 = 1LL << k;\n            long long l = pow2 - rnd.next(0LL, 100LL);\n            long long r = pow2 + rnd.next(0LL, 100LL);\n            l = max(l, 0LL);\n            r = min(r, (long long)1e18);\n            if (l > r) swap(l, r);\n            printf(\"%lld %lld\\n\", l, r);\n        }\n    } else if (type == \"maxbitsatends\") {\n        // l_i and r_i such that x with max bits is at l_i or r_i\n        for (int i = 0; i < n; ++i) {\n            int bits = rnd.next(1, 60);  // number of bits set\n            vector<int> positions(60);\n            iota(positions.begin(), positions.end(), 0);\n            shuffle(positions.begin(), positions.end());\n            long long x = 0;\n            for (int j = 0; j < bits; ++j) {\n                x |= (1LL << positions[j]);\n            }\n            x = min(x, (long long)1e18);\n            // Generate random l and r around x\n            long long l = x - rnd.next(0LL, min(x, 1000000LL));\n            l = max(l, 0LL);\n            long long r = x + rnd.next(0LL, 1000000LL);\n            r = min(r, (long long)1e18);\n            // Ensure l <= x <= r\n            if (rnd.next(0,1)) l = x;\n            else r = x;\n            if (l > r) swap(l, r);\n            printf(\"%lld %lld\\n\", l, r);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            long long l = rnd.next(0LL, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            printf(\"%lld %lld\\n\", l, r);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minrange\n./gen -n 1 -type random\n./gen -n 1 -type maxrange\n./gen -n 1 -type edgecaselower\n./gen -n 1 -type edgecaseupper\n\n./gen -n 10 -type random\n./gen -n 10 -type maxrange\n./gen -n 10 -type minrange\n./gen -n 10 -type edgecaselower\n./gen -n 10 -type edgecaseupper\n./gen -n 10 -type poweroftwoboundary\n./gen -n 10 -type maxbitsatends\n\n./gen -n 100 -type random\n./gen -n 100 -type maxrange\n./gen -n 100 -type minrange\n./gen -n 100 -type poweroftwoboundary\n./gen -n 100 -type maxbitsatends\n\n./gen -n 1000 -type random\n./gen -n 1000 -type maxrange\n./gen -n 1000 -type minrange\n./gen -n 1000 -type poweroftwoboundary\n./gen -n 1000 -type maxbitsatends\n\n./gen -n 10000 -type random\n./gen -n 10000 -type maxrange\n./gen -n 10000 -type minrange\n./gen -n 10000 -type edgecaselower\n./gen -n 10000 -type edgecaseupper\n./gen -n 10000 -type poweroftwoboundary\n./gen -n 10000 -type maxbitsatends\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:51.246372",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "484/B",
      "title": "B. Максимальное значение",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n — длина последовательности (1 ≤ n ≤ 2·105). Во второй строке содержатся n целых чисел ai, разделенных пробелами (1 ≤ ai ≤ 106).",
      "output_spec": "Выходные данныеВыведите ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать33 4 5Выходные данныеСкопировать2",
      "description": "B. Максимальное значение\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n — длина последовательности (1 ≤ n ≤ 2·105). Во второй строке содержатся n целых чисел ai, разделенных пробелами (1 ≤ ai ≤ 106).\n\nВходные данные\n\nВыходные данныеВыведите ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать33 4 5Выходные данныеСкопировать2\n\nВходные данныеСкопировать33 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Привет всем! Сегодня состоится Codeforces Round #276, который пройдёт в обоих дивизионах. Время старта — 19:30 по московскому времени (перейдите по ссылке для просмотра времени в других регионах). За помощь в подготовке контеста спасибо Zlobober, за перевод на английский спасибо Delinur, и спасибо MikeMirzayanov за сам проект Codeforces.Желаю всем удачи, надеюсь, вам понравятся задачи :)UPD Разбалловка в обоих дивизионах будет динамическая (подробнее об этом можно почитать здесь). Задачи будут упорядочены по возрастанию сложности, тем не менее, не забудьте прочитать все задачи до конца контеста.UPD Контест окончен! Спасибо всем, кто решал задачи несмотря ни на что. Разбор будет опубликован позднее.UPD Разбор можно найти здесь. На моё удивление задача div1C оказалась довольно сложной и по количеству посылок сравнялась с div1E, а во втором дивизионе эту задачу вообще никто не сдал за время контеста. Удачи вам в покорении разбора :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 943
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - ФабрикаПроизводство остановится только в том случае, если существует такое целое K ≥ 0, что a·2K делится на m. Из этого следует, что K может быть максимум порядка log2(m). Так как K — это по сути сколько пройдёт дней до этого момента, то можно промоделировать описанные в условии задачи действия, например, в течение 20-ти дней (не забыв при этом про 64-битный тип данных). Если в какой-то момент производство остановилось, то ответ \"Yes\". Если не остановилось в течение этих дней, то оно не остановится никогда, а значит ответ \"No\".485B - Ценные ресурсыНайдём минимальную длину, необходимую чтобы покрыть все точки по оси Ox — это будет в точности Maximum(xi) - Minumum(xi). Аналогично и для оси Oy — это Maximum(yi) - Minumum(yi). Так как нам необходим квадрат, то следует взять максимальную из этих двух величин в качестве длины его стороны.484A - БитыОпишем функцию f(L, R), которая будет ответом на задачу. Она ведёт себя следующим образом: если L = R, то f(L, R) = L; иначе, если 2b ≤ L, где b — максимальное целое число такое, что 2b ≤ R, то f(L, R) = f(L - 2b, R - 2b) + 2b; иначе, если 2b + 1 - 1 ≤ R, то f(L, R) = 2b + 1 - 1; иначе f(L, R) = 2b - 1. Итоговая сложность — O(logR) на один запрос.484B - Максимальное значениеПереберём все различные числа aj исходной последовательности. Так как нужно максимизировать , то переберём в цикле по x все числа, кратные aj в диапазоне от 2aj до M, где M — удвоенное максимальное значение элемента последовательности. Для каждого такого числа нужно найти максимальное ai, такое, что ai < x. Ограничения на числа позволяют сделать это за O(1) при помощи массива. Обновим ответ величиной . Так как перебираются только различные aj, то итоговая сложность составит O(nlogn + MlogM).484C - Странная сортировкаЗаметим, что d-сортировка не зависит от того, какие символы находятся в строке, а значит является перестановкой (назовём её P). Посмотрим на операцию перемешивания по другому: вместо того, чтобы переходить к очередной следующей подстроке и сортировать её, сделаем циклический сдвиг всей строки на один символ влево. Таким образом, сортироваться будет только префикс строки, а строка сдвигаться. Осталось понять, что сдвиг влево — это тоже перестановка (назовём её C). Теперь всё просто, к строке нужно поочерёдно применять перестановки P и C, то есть нужно получить S·P·C·P·C... = S·(P·C)n - k + 1. После этого строку нужно сдвинуть ещё на k - 1 символ влево, чтобы получить то, что получится после операции перемешивания. Здесь используется умножение перестановок, а оно в свою очередь ассоциативно, а значит для вычисления (P·C)n - k + 1 можно воспользоваться бинарным алгоритмом. Итоговая сложность составит O(nmlogn).484D - Детский садЗаметим, что существует оптимальный ответ такой, что любой отрезок, который образует группу, содержит свои максимальные и минимальные значения на границах. Иначе было бы выгодно разбить отрезок хотябы на два. Так же можно заметить, что каждый отрезок будет строго монотонным (элементы на нём строго возрастают или убывают). Выделим интересные точки в последовательности — это либо локальные максимумы (то есть ai - 1 < ai > ai + 1), либо минимумы (ai - 1 > ai < ai + 1), либо соседние с ними точки. Будем решать задачу методом динамического программирования, Di — наилучший ответ для префикса i. Тогда при вычислении очередного значения необходимо обработать не более трёх предыдущих интересных точек, а так же предыдущую точку. Итоговая сложность — O(n).484E - Объявление на забореЗаметим, что при поиске ответа на конкретный запрос можно воспользоваться бинарным поиском по ответу. Пусть в какой-то момент зафиксировалась высота h и необходимо узнать, помещается ли прямоугольник размера w на h в участок забора с l-ой по r-ой доски включительно. Заведём перед обработкой запросов структуру данных, которая поможет отвечать на такой вопрос. Это будет персистентное дерево отрезков с необычной функцией: максимальное количество подряд идущих единиц на отрезке (далее maxOnes). В листьях дерева будут только числа 0 и 1. Чтобы реализовать такую функцию, необходимо ввести ещё некоторые величины, а именно:len — длина отрезка в вершине дерева отрезков, prefOnes — длина префикса, полностью состоящего из единиц, sufOnes — длина суффикса, полностью состоящего из единиц.Вычисляются эти функции следующим образом:maxOnes, требуемая функция, равна max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes равна prefOnes(Right) + len(Left) в случае, если len(Left) = prefOnes(Left), иначе она равна prefOnes(Left);sufOnes равна sufOnes(Left) + len(Right) в случае, если len(Right) = sufOnes(Right), иначе она равна sufOnes(Right);len = len(left) + len(Right);Left и Right — соответственно левый и правые сыновья текущей вершины в структуре дерева отрезков.Как уже упоминалось выше, дерево должно быть персистентным (то есть хранить все свои версии после изменений), строиться оно должно следующим образом. Сначала строится пустое дерево — из одних нулей. Далее в позицию, где в заборе находится самая высокая доска, ставится единица. Тоже самое делается для второй по убыванию высоты доски и так далее. Например, если забор описывался последовательностью [2, 5, 5, 1, 3], то изменения последнего слоя дерева будут следующими:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].При этом для каждой высоты hi нужно запомнить соответствующую версию дерева, назовём её как treeheight. Теперь, чтобы ответить на вопрос выше, нужно сделать запрос на отрезке [l, r] у дерева treeh. Если maxOnes этого запроса меньше w, то прямоугольник невозможно разместить, иначе возможно.Построение дерева займёт O(nlogn) времени и памяти. Ответ на запрос займёт O(log2n) времени.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 484\\s*B"
          },
          "content_length": 5733
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "R = 2^A + Q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A - количество accepted",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "Q - quality",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 12",
          "code": "int64_t x;\n__builtin_popcount(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 13",
          "code": "int64_t x;\n__builtin_popcount(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 14",
          "code": "__builtin_popcountll(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 15",
          "code": "for(int i = 2; i <= 1e6; i++) {\n    int lf = i + 1;\n    while(lf <= mx) {\n        lf += 2;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 16",
          "code": "for(int i = 2; i <= 1e6; i++) {\n    int lf = i + 1;\n    while(lf <= mx) {\n        lf += 2;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 17",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 18",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 19",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "Тогда при вычислении очередного значения необходимо обработать не более трёх предыдущих интересных точек, а так же предыдущую точку.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "Выведете максимальную возможную суммарную общительность всех групп.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "Для каждого такого числа нужно найти максимальное ai, такое, что ai < x. Ограничения на числа позволяют сделать это за O(1) при помощи массива.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 14",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 15",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 16",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"min\"){\n        // All elements are the minimum value, 1\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max\"){\n        // All elements are the maximum value, 1e6\n        for(int i = 0; i < n; ++i)\n            a[i] = 1000000;\n    } else if (type == \"increasing\"){\n        // Elements increase from 1 to 1e6\n        int delta = max(1, 1000000 / max(1, n - 1));\n        for(int i = 0; i < n; ++i)\n            a[i] = min(1 + i * delta, 1000000);\n    } else if (type == \"decreasing\"){\n        // Elements decrease from 1e6 to 1\n        int delta = max(1, 1000000 / max(1, n - 1));\n        for(int i = 0; i < n; ++i)\n            a[i] = max(1000000 - i * delta, 1);\n    } else if (type == \"equal\"){\n        // All elements are equal to a random value between 1 and 1e6\n        int val = rnd.next(1, 1000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_random\"){\n        // Elements are random values between 1 and 10\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    } else if (type == \"large_random\"){\n        // Elements are random values between 1e6 - 10 and 1e6\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(999990, 1000000);\n    } else if (type == \"few_unique\"){\n        // Elements are random values chosen from k unique numbers\n        int k = opt<int>(\"k\", 2);\n        vector<int> vals(k);\n        for(int i = 0; i < k; ++i)\n            vals[i] = rnd.next(1, 1000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = vals[rnd.next(0, k - 1)];\n    } else {\n        // Random elements between 1 and 1e6\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n    }\n\n    // Output the sequence\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"min\"){\n        // All elements are the minimum value, 1\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max\"){\n        // All elements are the maximum value, 1e6\n        for(int i = 0; i < n; ++i)\n            a[i] = 1000000;\n    } else if (type == \"increasing\"){\n        // Elements increase from 1 to 1e6\n        int delta = max(1, 1000000 / max(1, n - 1));\n        for(int i = 0; i < n; ++i)\n            a[i] = min(1 + i * delta, 1000000);\n    } else if (type == \"decreasing\"){\n        // Elements decrease from 1e6 to 1\n        int delta = max(1, 1000000 / max(1, n - 1));\n        for(int i = 0; i < n; ++i)\n            a[i] = max(1000000 - i * delta, 1);\n    } else if (type == \"equal\"){\n        // All elements are equal to a random value between 1 and 1e6\n        int val = rnd.next(1, 1000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_random\"){\n        // Elements are random values between 1 and 10\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    } else if (type == \"large_random\"){\n        // Elements are random values between 1e6 - 10 and 1e6\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(999990, 1000000);\n    } else if (type == \"few_unique\"){\n        // Elements are random values chosen from k unique numbers\n        int k = opt<int>(\"k\", 2);\n        vector<int> vals(k);\n        for(int i = 0; i < k; ++i)\n            vals[i] = rnd.next(1, 1000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = vals[rnd.next(0, k - 1)];\n    } else {\n        // Random elements between 1 and 1e6\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n    }\n\n    // Output the sequence\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -type min\n./gen -n 1 -type max\n./gen -n 1 -type random\n\n./gen -n 2 -type equal\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n\n# Medium n\n./gen -n 10 -type small_random\n./gen -n 10 -type large_random\n./gen -n 10 -type few_unique -k 2\n./gen -n 10 -type random\n\n./gen -n 100 -type min\n./gen -n 100 -type max\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type equal\n./gen -n 100 -type random\n\n# Large n\n./gen -n 1000 -type random\n\n./gen -n 10000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 200000 -type min\n./gen -n 200000 -type max\n./gen -n 200000 -type equal\n\n# Additional test cases\n./gen -n 200000 -type small_random\n./gen -n 200000 -type large_random\n\n# Boundary test\n./gen -n 200000 -type few_unique -k 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:53.009247",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "484/C",
      "title": "C. Странная сортировка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода содержится непустая строка S длины n, состоящая из строчных и заглавных букв латинского алфавита и цифр от 0 до 9. Во второй строке ввода содержится целое число m – количество операций перемешивания (1 ≤ m·n ≤ 106). Далее в m строках идут описания операций в виде пары чисел k и d (1 ≤ d ≤ k ≤ n).",
      "output_spec": "Выходные данныеПосле каждой операции выведите текущее состояние строки S.",
      "sample_tests": "ПримерыВходные данныеСкопироватьqwerty34 26 35 2Выходные данныеСкопироватьqertwyqtewryqetyrw",
      "description": "C. Странная сортировка\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке ввода содержится непустая строка S длины n, состоящая из строчных и заглавных букв латинского алфавита и цифр от 0 до 9. Во второй строке ввода содержится целое число m – количество операций перемешивания (1 ≤ m·n ≤ 106). Далее в m строках идут описания операций в виде пары чисел k и d (1 ≤ d ≤ k ≤ n).\n\nВходные данные\n\nВыходные данныеПосле каждой операции выведите текущее состояние строки S.\n\nВыходные данные\n\nВходные данныеСкопироватьqwerty34 26 35 2Выходные данныеСкопироватьqertwyqtewryqetyrw\n\nВходные данныеСкопироватьqwerty34 26 35 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьqertwyqtewryqetyrw\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим пример подробнее. Первая модификация производится с параметрами k = 4, d = 2. Это означает, что нужно по очереди заменить все подстроки длины 4 на их 2-сортировки, двигаясь слева направо. Строка будет меняться следующим образом:qwerty  →  qewrty  →  qerwty  →  qertwyТем самым строка S в итоге станет равна «qertwy».Вторая модификация производится с параметрами k = 6, d = 3. В результате этой операции вся строка S заменится на ее 3-сортировку: qertwy  →  qtewryТретья модификация производится с параметрами k = 5, d = 2. qtewry  →  qertwy  →  qetyrw",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Привет всем! Сегодня состоится Codeforces Round #276, который пройдёт в обоих дивизионах. Время старта — 19:30 по московскому времени (перейдите по ссылке для просмотра времени в других регионах). За помощь в подготовке контеста спасибо Zlobober, за перевод на английский спасибо Delinur, и спасибо MikeMirzayanov за сам проект Codeforces.Желаю всем удачи, надеюсь, вам понравятся задачи :)UPD Разбалловка в обоих дивизионах будет динамическая (подробнее об этом можно почитать здесь). Задачи будут упорядочены по возрастанию сложности, тем не менее, не забудьте прочитать все задачи до конца контеста.UPD Контест окончен! Спасибо всем, кто решал задачи несмотря ни на что. Разбор будет опубликован позднее.UPD Разбор можно найти здесь. На моё удивление задача div1C оказалась довольно сложной и по количеству посылок сравнялась с div1E, а во втором дивизионе эту задачу вообще никто не сдал за время контеста. Удачи вам в покорении разбора :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 943
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - ФабрикаПроизводство остановится только в том случае, если существует такое целое K ≥ 0, что a·2K делится на m. Из этого следует, что K может быть максимум порядка log2(m). Так как K — это по сути сколько пройдёт дней до этого момента, то можно промоделировать описанные в условии задачи действия, например, в течение 20-ти дней (не забыв при этом про 64-битный тип данных). Если в какой-то момент производство остановилось, то ответ \"Yes\". Если не остановилось в течение этих дней, то оно не остановится никогда, а значит ответ \"No\".485B - Ценные ресурсыНайдём минимальную длину, необходимую чтобы покрыть все точки по оси Ox — это будет в точности Maximum(xi) - Minumum(xi). Аналогично и для оси Oy — это Maximum(yi) - Minumum(yi). Так как нам необходим квадрат, то следует взять максимальную из этих двух величин в качестве длины его стороны.484A - БитыОпишем функцию f(L, R), которая будет ответом на задачу. Она ведёт себя следующим образом: если L = R, то f(L, R) = L; иначе, если 2b ≤ L, где b — максимальное целое число такое, что 2b ≤ R, то f(L, R) = f(L - 2b, R - 2b) + 2b; иначе, если 2b + 1 - 1 ≤ R, то f(L, R) = 2b + 1 - 1; иначе f(L, R) = 2b - 1. Итоговая сложность — O(logR) на один запрос.484B - Максимальное значениеПереберём все различные числа aj исходной последовательности. Так как нужно максимизировать , то переберём в цикле по x все числа, кратные aj в диапазоне от 2aj до M, где M — удвоенное максимальное значение элемента последовательности. Для каждого такого числа нужно найти максимальное ai, такое, что ai < x. Ограничения на числа позволяют сделать это за O(1) при помощи массива. Обновим ответ величиной . Так как перебираются только различные aj, то итоговая сложность составит O(nlogn + MlogM).484C - Странная сортировкаЗаметим, что d-сортировка не зависит от того, какие символы находятся в строке, а значит является перестановкой (назовём её P). Посмотрим на операцию перемешивания по другому: вместо того, чтобы переходить к очередной следующей подстроке и сортировать её, сделаем циклический сдвиг всей строки на один символ влево. Таким образом, сортироваться будет только префикс строки, а строка сдвигаться. Осталось понять, что сдвиг влево — это тоже перестановка (назовём её C). Теперь всё просто, к строке нужно поочерёдно применять перестановки P и C, то есть нужно получить S·P·C·P·C... = S·(P·C)n - k + 1. После этого строку нужно сдвинуть ещё на k - 1 символ влево, чтобы получить то, что получится после операции перемешивания. Здесь используется умножение перестановок, а оно в свою очередь ассоциативно, а значит для вычисления (P·C)n - k + 1 можно воспользоваться бинарным алгоритмом. Итоговая сложность составит O(nmlogn).484D - Детский садЗаметим, что существует оптимальный ответ такой, что любой отрезок, который образует группу, содержит свои максимальные и минимальные значения на границах. Иначе было бы выгодно разбить отрезок хотябы на два. Так же можно заметить, что каждый отрезок будет строго монотонным (элементы на нём строго возрастают или убывают). Выделим интересные точки в последовательности — это либо локальные максимумы (то есть ai - 1 < ai > ai + 1), либо минимумы (ai - 1 > ai < ai + 1), либо соседние с ними точки. Будем решать задачу методом динамического программирования, Di — наилучший ответ для префикса i. Тогда при вычислении очередного значения необходимо обработать не более трёх предыдущих интересных точек, а так же предыдущую точку. Итоговая сложность — O(n).484E - Объявление на забореЗаметим, что при поиске ответа на конкретный запрос можно воспользоваться бинарным поиском по ответу. Пусть в какой-то момент зафиксировалась высота h и необходимо узнать, помещается ли прямоугольник размера w на h в участок забора с l-ой по r-ой доски включительно. Заведём перед обработкой запросов структуру данных, которая поможет отвечать на такой вопрос. Это будет персистентное дерево отрезков с необычной функцией: максимальное количество подряд идущих единиц на отрезке (далее maxOnes). В листьях дерева будут только числа 0 и 1. Чтобы реализовать такую функцию, необходимо ввести ещё некоторые величины, а именно:len — длина отрезка в вершине дерева отрезков, prefOnes — длина префикса, полностью состоящего из единиц, sufOnes — длина суффикса, полностью состоящего из единиц.Вычисляются эти функции следующим образом:maxOnes, требуемая функция, равна max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes равна prefOnes(Right) + len(Left) в случае, если len(Left) = prefOnes(Left), иначе она равна prefOnes(Left);sufOnes равна sufOnes(Left) + len(Right) в случае, если len(Right) = sufOnes(Right), иначе она равна sufOnes(Right);len = len(left) + len(Right);Left и Right — соответственно левый и правые сыновья текущей вершины в структуре дерева отрезков.Как уже упоминалось выше, дерево должно быть персистентным (то есть хранить все свои версии после изменений), строиться оно должно следующим образом. Сначала строится пустое дерево — из одних нулей. Далее в позицию, где в заборе находится самая высокая доска, ставится единица. Тоже самое делается для второй по убыванию высоты доски и так далее. Например, если забор описывался последовательностью [2, 5, 5, 1, 3], то изменения последнего слоя дерева будут следующими:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].При этом для каждой высоты hi нужно запомнить соответствующую версию дерева, назовём её как treeheight. Теперь, чтобы ответить на вопрос выше, нужно сделать запрос на отрезке [l, r] у дерева treeh. Если maxOnes этого запроса меньше w, то прямоугольник невозможно разместить, иначе возможно.Построение дерева займёт O(nlogn) времени и памяти. Ответ на запрос займёт O(log2n) времени.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 484\\s*C"
          },
          "content_length": 5733
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "R = 2^A + Q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A - количество accepted",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "Q - quality",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 12",
          "code": "int64_t x;\n__builtin_popcount(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 13",
          "code": "int64_t x;\n__builtin_popcount(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 14",
          "code": "__builtin_popcountll(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 15",
          "code": "for(int i = 2; i <= 1e6; i++) {\n    int lf = i + 1;\n    while(lf <= mx) {\n        lf += 2;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 16",
          "code": "for(int i = 2; i <= 1e6; i++) {\n    int lf = i + 1;\n    while(lf <= mx) {\n        lf += 2;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 17",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 18",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 19",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "Тогда при вычислении очередного значения необходимо обработать не более трёх предыдущих интересных точек, а так же предыдущую точку.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "Выведете максимальную возможную суммарную общительность всех групп.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "Для каждого такого числа нужно найти максимальное ai, такое, что ai < x. Ограничения на числа позволяют сделать это за O(1) при помощи массива.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 14",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 15",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 16",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: the string S\n    string S = inf.readToken(\"[a-zA-Z0-9]{1,1000000}\", \"S\");\n    inf.readEoln();\n    int n = S.length();\n\n    // Read the second line: integer m\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Ensure m * n ≤ 1e6\n    ensuref(1LL * m * n <= 1000000, \"m * n should be ≤ 1e6, but m = %d, n = %d\", m, n);\n\n    // For each of the m lines:\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, n, \"k\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readEoln();\n\n        // Ensure 1 ≤ d ≤ k ≤ n\n        ensuref(1 <= d && d <= k && k <= n, \"1 ≤ d ≤ k ≤ n, but got d = %d, k = %d, n = %d\", d, k, n);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: the string S\n    string S = inf.readToken(\"[a-zA-Z0-9]{1,1000000}\", \"S\");\n    inf.readEoln();\n    int n = S.length();\n\n    // Read the second line: integer m\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Ensure m * n ≤ 1e6\n    ensuref(1LL * m * n <= 1000000, \"m * n should be ≤ 1e6, but m = %d, n = %d\", m, n);\n\n    // For each of the m lines:\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, n, \"k\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readEoln();\n\n        // Ensure 1 ≤ d ≤ k ≤ n\n        ensuref(1 <= d && d <= k && k <= n, \"1 ≤ d ≤ k ≤ n, but got d = %d, k = %d, n = %d\", d, k, n);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: the string S\n    string S = inf.readToken(\"[a-zA-Z0-9]{1,1000000}\", \"S\");\n    inf.readEoln();\n    int n = S.length();\n\n    // Read the second line: integer m\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Ensure m * n ≤ 1e6\n    ensuref(1LL * m * n <= 1000000, \"m * n should be ≤ 1e6, but m = %d, n = %d\", m, n);\n\n    // For each of the m lines:\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, n, \"k\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readEoln();\n\n        // Ensure 1 ≤ d ≤ k ≤ n\n        ensuref(1 <= d && d <= k && k <= n, \"1 ≤ d ≤ k ≤ n, but got d = %d, k = %d, n = %d\", d, k, n);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random character (letter or digit)\nchar randomChar() {\n    int choice = rnd.next(62); // 26 lowercase + 26 uppercase + 10 digits\n    if (choice < 10) {\n        return '0' + choice;\n    } else if (choice < 36) {\n        return 'a' + (choice - 10);\n    } else {\n        return 'A' + (choice - 36);\n    }\n}\n\n// Function to generate the string S based on the specified type\nstring generateString(int n, const string &type) {\n    string S(n, 'a');\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = randomChar();\n        }\n    } else if (type == \"fixed_char\") {\n        char c = 'a' + rnd.next(26); // Random lowercase letter\n        S = string(n, c);\n    } else if (type == \"alternating\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) c2 = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            S[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"digits\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = '0' + rnd.next(10);\n        }\n    } else if (type == \"worst_case\") {\n        // Create a string that may cause maximal modifications\n        S = generateString(n, \"alternating\");\n    } else {\n        // Default to random\n        S = generateString(n, \"random\");\n    }\n    return S;\n}\n\n// Function to generate the operations based on the specified type\nvector<pair<int, int>> generateOperations(int n, int m, const string &type) {\n    vector<pair<int, int>> ops;\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = rnd.next(1, k);\n            ops.push_back({k, d});\n        }\n    } else if (type == \"max_k\") {\n        // k = n\n        for (int i = 0; i < m; ++i) {\n            int d = rnd.next(1, n);\n            ops.push_back({n, d});\n        }\n    } else if (type == \"min_k\") {\n        // k = 1\n        for (int i = 0; i < m; ++i) {\n            ops.push_back({1, 1});\n        }\n    } else if (type == \"worst_case\") {\n        // Operations designed to maximize modifications\n        for (int i = 0; i < m; ++i) {\n            ops.push_back({n, 1});\n        }\n    } else {\n        // Default to random\n        ops = generateOperations(n, m, \"random\");\n    }\n    return ops;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"stype\", \"random\");\n    string op_type = opt<string>(\"otype\", \"random\");\n\n    // Ensure that m * n <= 1e6\n    const int MAX_WORK = 1000000;\n    if (1LL * m * n > MAX_WORK) {\n        // Adjust m to fit the constraint\n        m = MAX_WORK / n;\n        if (m == 0) m = 1; // At least 1 operation\n    }\n\n    // Generate the string S\n    string S = generateString(n, s_type);\n\n    // Generate the operations\n    vector<pair<int, int>> operations = generateOperations(n, m, op_type);\n\n    // Output S\n    cout << S << endl;\n\n    // Output m\n    cout << m << endl;\n\n    // Output operations\n    for (auto &op : operations) {\n        int k = op.first;\n        int d = op.second;\n        cout << k << \" \" << d << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random character (letter or digit)\nchar randomChar() {\n    int choice = rnd.next(62); // 26 lowercase + 26 uppercase + 10 digits\n    if (choice < 10) {\n        return '0' + choice;\n    } else if (choice < 36) {\n        return 'a' + (choice - 10);\n    } else {\n        return 'A' + (choice - 36);\n    }\n}\n\n// Function to generate the string S based on the specified type\nstring generateString(int n, const string &type) {\n    string S(n, 'a');\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = randomChar();\n        }\n    } else if (type == \"fixed_char\") {\n        char c = 'a' + rnd.next(26); // Random lowercase letter\n        S = string(n, c);\n    } else if (type == \"alternating\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) c2 = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            S[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"digits\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = '0' + rnd.next(10);\n        }\n    } else if (type == \"worst_case\") {\n        // Create a string that may cause maximal modifications\n        S = generateString(n, \"alternating\");\n    } else {\n        // Default to random\n        S = generateString(n, \"random\");\n    }\n    return S;\n}\n\n// Function to generate the operations based on the specified type\nvector<pair<int, int>> generateOperations(int n, int m, const string &type) {\n    vector<pair<int, int>> ops;\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = rnd.next(1, k);\n            ops.push_back({k, d});\n        }\n    } else if (type == \"max_k\") {\n        // k = n\n        for (int i = 0; i < m; ++i) {\n            int d = rnd.next(1, n);\n            ops.push_back({n, d});\n        }\n    } else if (type == \"min_k\") {\n        // k = 1\n        for (int i = 0; i < m; ++i) {\n            ops.push_back({1, 1});\n        }\n    } else if (type == \"worst_case\") {\n        // Operations designed to maximize modifications\n        for (int i = 0; i < m; ++i) {\n            ops.push_back({n, 1});\n        }\n    } else {\n        // Default to random\n        ops = generateOperations(n, m, \"random\");\n    }\n    return ops;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"stype\", \"random\");\n    string op_type = opt<string>(\"otype\", \"random\");\n\n    // Ensure that m * n <= 1e6\n    const int MAX_WORK = 1000000;\n    if (1LL * m * n > MAX_WORK) {\n        // Adjust m to fit the constraint\n        m = MAX_WORK / n;\n        if (m == 0) m = 1; // At least 1 operation\n    }\n\n    // Generate the string S\n    string S = generateString(n, s_type);\n\n    // Generate the operations\n    vector<pair<int, int>> operations = generateOperations(n, m, op_type);\n\n    // Output S\n    cout << S << endl;\n\n    // Output m\n    cout << m << endl;\n\n    // Output operations\n    for (auto &op : operations) {\n        int k = op.first;\n        int d = op.second;\n        cout << k << \" \" << d << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small strings and operations\n./gen -n 1 -m 1 -stype random -otype random\n./gen -n 10 -m 5 -stype random -otype random\n\n# Maximal n, minimal m\n./gen -n 1000000 -m 1 -stype random -otype random\n\n# Maximal m, minimal n\n./gen -n 1 -m 1000000 -stype random -otype random\n\n# Medium n and m\n./gen -n 1000 -m 1000 -stype random -otype random\n\n# String of the same character\n./gen -n 500000 -m 2 -stype fixed_char -otype random\n\n# String with alternating characters\n./gen -n 500000 -m 2 -stype alternating -otype random\n\n# String with digits only\n./gen -n 500000 -m 2 -stype digits -otype random\n\n# Worst-case operations\n./gen -n 1000 -m 1000 -stype random -otype worst_case\n\n# Operations with k = n and d = 1\n./gen -n 10000 -m 100 -stype random -otype worst_case\n\n# Operations with minimal k\n./gen -n 1000000 -m 1 -stype random -otype min_k\n\n# Random operations\n./gen -n 100000 -m 10 -stype random -otype random\n\n# Operations with maximal k\n./gen -n 500000 -m 2 -stype random -otype max_k\n\n# Maximal overlapping substrings\n./gen -n 1000 -m 1000 -stype random -otype random\n\n# Edge case: k = n, d = n\n./gen -n 100000 -m 1 -stype random -otype max_k\n\n# Edge case: k = n, d = 1\n./gen -n 100000 -m 1 -stype random -otype worst_case\n\n# Edge case: k = n, d divides n\n./gen -n 100000 -m 1 -stype random -otype random\n\n# Edge case: k = n, d does not divide n\n./gen -n 99999 -m 1 -stype random -otype random\n\n# Very small n and m\n./gen -n 2 -m 1 -stype random -otype random\n./gen -n 3 -m 1 -stype random -otype random\n\n# Maximum work allowed (m * n = 1e6)\n./gen -n 1000 -m 1000 -stype random -otype random\n./gen -n 500 -m 2000 -stype random -otype random\n./gen -n 1000000 -m 1 -stype random -otype random\n./gen -n 1 -m 1000000 -stype random -otype random\n\n# Repeating patterns in operations\n./gen -n 50000 -m 20 -stype random -otype random\n\n# Additional test cases\n./gen -n 100000 -m 10 -stype random -otype random\n\n# String with uppercase letters\n./gen -n 500000 -m 2 -stype random -otype random\n\n# String with digits only\n./gen -n 500000 -m 2 -stype digits -otype random\n\n# Mixed string (letters and digits)\n./gen -n 500000 -m 2 -stype random -otype random\n\n# Very large string and minimal operations\n./gen -n 999999 -m 1 -stype random -otype random\n\n# Minimal string and maximal operations\n./gen -n 1 -m 999999 -stype random -otype random\n\n# Small n and large m\n./gen -n 2 -m 500000 -stype random -otype random\n\n# Large n and small m\n./gen -n 500000 -m 2 -stype random -otype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:55.008988",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "484/D",
      "title": "D. Kindergarten",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n — the number of children in the line (1 ≤ n ≤ 106).The second line contains n integers ai — the charisma of the i-th child ( - 109 ≤ ai ≤ 109).",
      "output_spec": "OutputPrint the maximum possible total sociability of all groups.",
      "sample_tests": "ExamplesInputCopy51 2 3 1 2OutputCopy3InputCopy33 3 3OutputCopy0",
      "description": "D. Kindergarten\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n — the number of children in the line (1 ≤ n ≤ 106).The second line contains n integers ai — the charisma of the i-th child ( - 109 ≤ ai ≤ 109).\n\nOutputPrint the maximum possible total sociability of all groups.\n\nInputCopy51 2 3 1 2OutputCopy3InputCopy33 3 3OutputCopy0\n\nInputCopy51 2 3 1 2\n\nOutputCopy3\n\nInputCopy33 3 3\n\nOutputCopy0\n\nNoteIn the first test sample one of the possible variants of an division is following: the first three children form a group with sociability 2, and the two remaining children form a group with sociability 1.In the second test sample any division leads to the same result, the sociability will be equal to 0 in each group.",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Hello everybody!Today will be Codeforces Round #276, which take place in both divisions. Start time is 19:30 in moscow time (follow this link to see time in others zones). For preparing contest i say thanks to Zlobober, for translating to Delinur, and to MikeMirzayanov for project Codeforces.Good luck to all, hope you will enjoy problems :)UPD Score distribution will be dynamic (see more information here). Problems will be sorted in increasing order of difficulty, however, do not forget to read all problems before the end of the contest.UPD The contest is over! Thanks to everyone who solved the problems despite everything. Analysis will be published later.UPD Editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 696
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - FactoryProduction will stops iff exists integer K ≥ 0 such a·2K is divisible by m. From this fact follows that K maximum will be about O(log2(m)). So if we modeling some, for example, 20 days and production does not stop, then it will never stop and answer is \"No\". Otherwise answer is \"Yes\".485B - Valuable ResourcesLet us find minimum length needed to cover points by Ox. It is Maximum(xi) - Minumum(xi). The same in Oy — Maximum(yi) - Minumum(yi). Since we need a square city to cover all the mines, then we need to set length of this square to the maximum from those two values.484A - BitsLet us define function f(L, R), that gives answer to the query. It looks follows: if L = R then f(L, R) = L; else if 2b ≤ L, where b — maximum integer such 2b ≤ R, then f(L, R) = f(L - 2b, R - 2b) + 2b; else if 2b + 1 - 1 ≤ R then f(L, R) = 2b + 1 - 1; else f(L, R) = 2b - 1. Total complexity is O(logR) per query.484B - Maximum ValueLet us iterate over all different aj. Since we need to maximize , then iterate all integer x (such x divisible by aj) in range from 2aj to M, where M — doubled maximum value of the sequence. For each such x we need to find maximum ai, such ai < x. Limits for numbers allow to do this in time O(1) with an array. After that, update answer by value . Total time complexity is O(nlogn + MlogM).484C - Strange SortingNote, that d-sorting is just a permutation (call it P), because it does not depends on characters in string. Look at shuffling operation in different way: instead of going to the next substring and sort it, we will shift string to one character left. It remains to understand that shift of string the permutation too (call it C). Now its clear, we need to calculate S·P·C·P·C... = S·(P·C)n - k + 1. And after that shift string for k - 1 character to the left for making answer to the shuffling operation. Here we use the multiplication of permutations. Since they are associative, that we can use binary algorithm to calculate (P·C)n - k + 1. Total time complexity is O(nmlogn).484D - KindergartenLet us note, that in optimal answer any segment that making a group contains their minimum and maximum values on borders. Otherwise it will be better to split this segment to two other segments. Another note that is every segment in optimal solution is strictly monotonic (increasing or decreasing). Paying attention to the interesting points in sequence which making local maximums (i. e. ai - 1 < ai > ai + 1), local minimums (ai - 1 > ai < ai + 1), and point adjacent to them. Solve the problem by dynamic programming: Di is the answer in the prefix i. To calculate Di we need to look at no more than three previous interesting points and to previous Di - 1. Total time complexity is O(n).484E - Sign on FenceLet us note that we can use binary search to find answer to the one query. Suppose at some moment was fixed height h and need to know will fit the rectangle with width w and height h to the segment of fence from l-th to r-th panel. Let us build data structure that can answer to this question. This will be persistent segment tree with unusual function inside: maximum number of consecutive ones in segment (maxOnes). In leaves of segment tree will be only numbers 0 and 1. To calculate this function need to know some other values, specifically:len — length of the segment in vertex of segment tree, prefOnes — length of prefix that consists only of ones, sufOnes — length of the suffix consist only of ones.These functions are computed as follows:maxOnes is equal to max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes equals prefOnes(Right) + len(Left) in case of len(Left) = prefOnes(Left), and prefOnes(Left) otherwise;sufOnes equals sufOnes(Left) + len(Right) in case of len(Right) = sufOnes(Right), and sufOnes(Right) otherwise;len = len(left) + len(Right);Left и Right — it is left and right sons of vertex in segment tree.As mentioned above, tree must be persistent, and it must be built as follows. First, builded empty tree of zeros. Next in position of highest plank need to put 1. The same doing for planks in decreasing order. For example if fence described with sequence [2, 5, 5, 1, 3] then bottom of segment tree will changed as follows:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].And we need to remember for all hi their version of tree. Now to answer the question we need to make query in our segment tree (that corresponding to height h) on segment [l, r]. If maxOnes form this query less than w, then rectangle impossible to put (otherwise possible).Building of tree will take O(nlogn) time and memory. Time complexity to the one query will take O(log2n) time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 484\\s*D"
          },
          "content_length": 4729
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 1000000000); // Default max_value is 1e9\n\n    // Ensure that max_value is within [1, 1e9]\n    max_value = min(max_value, int(1e9));\n    max_value = max(max_value, 1);\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        // All charisma values are the same\n        int val = rnd.next(-max_value, max_value);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        // Increasing sequence\n        int min_start = -max_value;\n        int max_start = max_value - n + 1;\n        int start = rnd.next(min_start, max_start);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Decreasing sequence\n        int min_start = -max_value + n - 1;\n        int max_start = max_value;\n        int start = rnd.next(min_start, max_start);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } else if (type == \"alternating\") {\n        // Alternating high and low values\n        int high = rnd.next(max_value / 2, max_value);\n        int low = rnd.next(-max_value, -max_value / 2);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? high : low;\n        }\n    } else if (type == \"big_diff\") {\n        // Maximize total sociability by alternating min and max values\n        int min_val = -max_value;\n        int max_val = max_value;\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? min_val : max_val;\n        }\n    } else if (type == \"small_diff\") {\n        // Minimize total sociability with small differences\n        int base = rnd.next(-max_value + 10, max_value - 10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = base + rnd.next(-5, 5); // Numbers within base ±5\n        }\n    } else { // \"random\" or default\n        // Random values between -max_value and max_value\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-max_value, max_value);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the charisma values\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 1000000000); // Default max_value is 1e9\n\n    // Ensure that max_value is within [1, 1e9]\n    max_value = min(max_value, int(1e9));\n    max_value = max(max_value, 1);\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        // All charisma values are the same\n        int val = rnd.next(-max_value, max_value);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        // Increasing sequence\n        int min_start = -max_value;\n        int max_start = max_value - n + 1;\n        int start = rnd.next(min_start, max_start);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Decreasing sequence\n        int min_start = -max_value + n - 1;\n        int max_start = max_value;\n        int start = rnd.next(min_start, max_start);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } else if (type == \"alternating\") {\n        // Alternating high and low values\n        int high = rnd.next(max_value / 2, max_value);\n        int low = rnd.next(-max_value, -max_value / 2);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? high : low;\n        }\n    } else if (type == \"big_diff\") {\n        // Maximize total sociability by alternating min and max values\n        int min_val = -max_value;\n        int max_val = max_value;\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? min_val : max_val;\n        }\n    } else if (type == \"small_diff\") {\n        // Minimize total sociability with small differences\n        int base = rnd.next(-max_value + 10, max_value - 10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = base + rnd.next(-5, 5); // Numbers within base ±5\n        }\n    } else { // \"random\" or default\n        // Random values between -max_value and max_value\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-max_value, max_value);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the charisma values\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n\n./gen -n 2 -type all_same\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type random\n\n./gen -n 3 -type big_diff\n./gen -n 3 -type small_diff\n\n./gen -n 10 -type all_same\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating\n\n./gen -n 100 -type big_diff\n./gen -n 100 -type small_diff\n./gen -n 100 -type random\n\n./gen -n 1000 -type all_same\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type alternating\n\n./gen -n 10000 -type big_diff\n./gen -n 10000 -type small_diff\n./gen -n 10000 -type random\n\n./gen -n 1000000 -type all_same\n./gen -n 1000000 -type increasing\n./gen -n 1000000 -type decreasing\n./gen -n 1000000 -type alternating\n./gen -n 1000000 -type big_diff\n./gen -n 1000000 -type small_diff\n./gen -n 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:57.095131",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "484/E",
      "title": "E. Объявление на заборе",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода содержится целое число n — количество досок в заборе (1 ≤ n ≤ 105). Во второй строке записаны n целых чисел hi, разделенных пробелом — высоты досок (1 ≤ hi ≤ 109). В третьей строке содержится целое число m — количество запросов (1 ≤ m ≤ 105). В последующих m строках идет описание запросов, каждый из которых представлен тремя целыми числами l, r и w (1 ≤ l ≤ r ≤ n, 1 ≤ w ≤ r - l + 1) — соответственно границы участка забора и ширина объявления.",
      "output_spec": "Выходные данныеНа каждый запрос выведите ответ в отдельной строке — максимальную высоту объявления, которую можно достичь на соответствующем участке забора при соблюдении всех условий.",
      "sample_tests": "ПримерыВходные данныеСкопировать51 2 2 3 332 5 32 5 21 5 5Выходные данныеСкопировать231",
      "description": "E. Объявление на заборе\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке ввода содержится целое число n — количество досок в заборе (1 ≤ n ≤ 105). Во второй строке записаны n целых чисел hi, разделенных пробелом — высоты досок (1 ≤ hi ≤ 109). В третьей строке содержится целое число m — количество запросов (1 ≤ m ≤ 105). В последующих m строках идет описание запросов, каждый из которых представлен тремя целыми числами l, r и w (1 ≤ l ≤ r ≤ n, 1 ≤ w ≤ r - l + 1) — соответственно границы участка забора и ширина объявления.\n\nВходные данные\n\nВыходные данныеНа каждый запрос выведите ответ в отдельной строке — максимальную высоту объявления, которую можно достичь на соответствующем участке забора при соблюдении всех условий.\n\nВыходные данные\n\nВходные данныеСкопировать51 2 2 3 332 5 32 5 21 5 5Выходные данныеСкопировать231\n\nВходные данныеСкопировать51 2 2 3 332 5 32 5 21 5 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать231\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЗабор, описанный в примере, выглядит следующим образом:   Ниже приведены возможные расположения объявлений при ответе на запросы.  Расположение объявления при ответе на первый запрос.   Расположение объявления при ответе на второй запрос.   Расположение объявления при ответе на третий запрос.",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Привет всем! Сегодня состоится Codeforces Round #276, который пройдёт в обоих дивизионах. Время старта — 19:30 по московскому времени (перейдите по ссылке для просмотра времени в других регионах). За помощь в подготовке контеста спасибо Zlobober, за перевод на английский спасибо Delinur, и спасибо MikeMirzayanov за сам проект Codeforces.Желаю всем удачи, надеюсь, вам понравятся задачи :)UPD Разбалловка в обоих дивизионах будет динамическая (подробнее об этом можно почитать здесь). Задачи будут упорядочены по возрастанию сложности, тем не менее, не забудьте прочитать все задачи до конца контеста.UPD Контест окончен! Спасибо всем, кто решал задачи несмотря ни на что. Разбор будет опубликован позднее.UPD Разбор можно найти здесь. На моё удивление задача div1C оказалась довольно сложной и по количеству посылок сравнялась с div1E, а во втором дивизионе эту задачу вообще никто не сдал за время контеста. Удачи вам в покорении разбора :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 943
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - ФабрикаПроизводство остановится только в том случае, если существует такое целое K ≥ 0, что a·2K делится на m. Из этого следует, что K может быть максимум порядка log2(m). Так как K — это по сути сколько пройдёт дней до этого момента, то можно промоделировать описанные в условии задачи действия, например, в течение 20-ти дней (не забыв при этом про 64-битный тип данных). Если в какой-то момент производство остановилось, то ответ \"Yes\". Если не остановилось в течение этих дней, то оно не остановится никогда, а значит ответ \"No\".485B - Ценные ресурсыНайдём минимальную длину, необходимую чтобы покрыть все точки по оси Ox — это будет в точности Maximum(xi) - Minumum(xi). Аналогично и для оси Oy — это Maximum(yi) - Minumum(yi). Так как нам необходим квадрат, то следует взять максимальную из этих двух величин в качестве длины его стороны.484A - БитыОпишем функцию f(L, R), которая будет ответом на задачу. Она ведёт себя следующим образом: если L = R, то f(L, R) = L; иначе, если 2b ≤ L, где b — максимальное целое число такое, что 2b ≤ R, то f(L, R) = f(L - 2b, R - 2b) + 2b; иначе, если 2b + 1 - 1 ≤ R, то f(L, R) = 2b + 1 - 1; иначе f(L, R) = 2b - 1. Итоговая сложность — O(logR) на один запрос.484B - Максимальное значениеПереберём все различные числа aj исходной последовательности. Так как нужно максимизировать , то переберём в цикле по x все числа, кратные aj в диапазоне от 2aj до M, где M — удвоенное максимальное значение элемента последовательности. Для каждого такого числа нужно найти максимальное ai, такое, что ai < x. Ограничения на числа позволяют сделать это за O(1) при помощи массива. Обновим ответ величиной . Так как перебираются только различные aj, то итоговая сложность составит O(nlogn + MlogM).484C - Странная сортировкаЗаметим, что d-сортировка не зависит от того, какие символы находятся в строке, а значит является перестановкой (назовём её P). Посмотрим на операцию перемешивания по другому: вместо того, чтобы переходить к очередной следующей подстроке и сортировать её, сделаем циклический сдвиг всей строки на один символ влево. Таким образом, сортироваться будет только префикс строки, а строка сдвигаться. Осталось понять, что сдвиг влево — это тоже перестановка (назовём её C). Теперь всё просто, к строке нужно поочерёдно применять перестановки P и C, то есть нужно получить S·P·C·P·C... = S·(P·C)n - k + 1. После этого строку нужно сдвинуть ещё на k - 1 символ влево, чтобы получить то, что получится после операции перемешивания. Здесь используется умножение перестановок, а оно в свою очередь ассоциативно, а значит для вычисления (P·C)n - k + 1 можно воспользоваться бинарным алгоритмом. Итоговая сложность составит O(nmlogn).484D - Детский садЗаметим, что существует оптимальный ответ такой, что любой отрезок, который образует группу, содержит свои максимальные и минимальные значения на границах. Иначе было бы выгодно разбить отрезок хотябы на два. Так же можно заметить, что каждый отрезок будет строго монотонным (элементы на нём строго возрастают или убывают). Выделим интересные точки в последовательности — это либо локальные максимумы (то есть ai - 1 < ai > ai + 1), либо минимумы (ai - 1 > ai < ai + 1), либо соседние с ними точки. Будем решать задачу методом динамического программирования, Di — наилучший ответ для префикса i. Тогда при вычислении очередного значения необходимо обработать не более трёх предыдущих интересных точек, а так же предыдущую точку. Итоговая сложность — O(n).484E - Объявление на забореЗаметим, что при поиске ответа на конкретный запрос можно воспользоваться бинарным поиском по ответу. Пусть в какой-то момент зафиксировалась высота h и необходимо узнать, помещается ли прямоугольник размера w на h в участок забора с l-ой по r-ой доски включительно. Заведём перед обработкой запросов структуру данных, которая поможет отвечать на такой вопрос. Это будет персистентное дерево отрезков с необычной функцией: максимальное количество подряд идущих единиц на отрезке (далее maxOnes). В листьях дерева будут только числа 0 и 1. Чтобы реализовать такую функцию, необходимо ввести ещё некоторые величины, а именно:len — длина отрезка в вершине дерева отрезков, prefOnes — длина префикса, полностью состоящего из единиц, sufOnes — длина суффикса, полностью состоящего из единиц.Вычисляются эти функции следующим образом:maxOnes, требуемая функция, равна max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes равна prefOnes(Right) + len(Left) в случае, если len(Left) = prefOnes(Left), иначе она равна prefOnes(Left);sufOnes равна sufOnes(Left) + len(Right) в случае, если len(Right) = sufOnes(Right), иначе она равна sufOnes(Right);len = len(left) + len(Right);Left и Right — соответственно левый и правые сыновья текущей вершины в структуре дерева отрезков.Как уже упоминалось выше, дерево должно быть персистентным (то есть хранить все свои версии после изменений), строиться оно должно следующим образом. Сначала строится пустое дерево — из одних нулей. Далее в позицию, где в заборе находится самая высокая доска, ставится единица. Тоже самое делается для второй по убыванию высоты доски и так далее. Например, если забор описывался последовательностью [2, 5, 5, 1, 3], то изменения последнего слоя дерева будут следующими:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].При этом для каждой высоты hi нужно запомнить соответствующую версию дерева, назовём её как treeheight. Теперь, чтобы ответить на вопрос выше, нужно сделать запрос на отрезке [l, r] у дерева treeh. Если maxOnes этого запроса меньше w, то прямоугольник невозможно разместить, иначе возможно.Построение дерева займёт O(nlogn) времени и памяти. Ответ на запрос займёт O(log2n) времени.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 484\\s*E"
          },
          "content_length": 5733
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "R = 2^A + Q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A - количество accepted",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "Q - quality",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 12",
          "code": "int64_t x;\n__builtin_popcount(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 13",
          "code": "int64_t x;\n__builtin_popcount(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 14",
          "code": "__builtin_popcountll(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 15",
          "code": "for(int i = 2; i <= 1e6; i++) {\n    int lf = i + 1;\n    while(lf <= mx) {\n        lf += 2;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 16",
          "code": "for(int i = 2; i <= 1e6; i++) {\n    int lf = i + 1;\n    while(lf <= mx) {\n        lf += 2;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 17",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 18",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 19",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "Тогда при вычислении очередного значения необходимо обработать не более трёх предыдущих интересных точек, а так же предыдущую точку.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "Выведете максимальную возможную суммарную общительность всех групп.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "Для каждого такого числа нужно найти максимальное ai, такое, что ai < x. Ограничения на числа позволяют сделать это за O(1) при помощи массива.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 14",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 15",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 16",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");  // n ≤ 1e5\n    inf.readEoln();\n    // Read n integers h_i\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");  // h_i ≤ 1e9\n    inf.readEoln();\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");  // m ≤ 1e5\n    inf.readEoln();\n    // For each of m queries\n    for (int i = 0; i < m; ++i) {\n        // Read l, r, w\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readSpace();\n        int w = inf.readInt(1, r - l + 1, \"w\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");  // n ≤ 1e5\n    inf.readEoln();\n    // Read n integers h_i\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");  // h_i ≤ 1e9\n    inf.readEoln();\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");  // m ≤ 1e5\n    inf.readEoln();\n    // For each of m queries\n    for (int i = 0; i < m; ++i) {\n        // Read l, r, w\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readSpace();\n        int w = inf.readInt(1, r - l + 1, \"w\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");  // n ≤ 1e5\n    inf.readEoln();\n    // Read n integers h_i\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");  // h_i ≤ 1e9\n    inf.readEoln();\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");  // m ≤ 1e5\n    inf.readEoln();\n    // For each of m queries\n    for (int i = 0; i < m; ++i) {\n        // Read l, r, w\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readSpace();\n        int w = inf.readInt(1, r - l + 1, \"w\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string htype = opt<string>(\"htype\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    vector<int> h(n);\n\n    if (htype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, 1000000000);\n        }\n    } else if (htype == \"min\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = 1;\n    } else if (htype == \"max\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = 1000000000;\n    } else if (htype == \"increasing\") {\n        int height = 1;\n        for (int i = 0; i < n; ++i)\n            h[i] = height++;\n    } else if (htype == \"decreasing\") {\n        int height = n;\n        for (int i = 0; i < n; ++i)\n            h[i] = height--;\n    } else if (htype == \"constant\") {\n        int value = opt<int>(\"hvalue\", 1000000000);\n        for (int i = 0; i < n; ++i)\n            h[i] = value;\n    } else if (htype == \"zigzag\") {\n        int low = 1, high = 1000000000;\n        for (int i = 0; i < n; ++i)\n            h[i] = (i % 2 == 0) ? low : high;\n    } else if (htype == \"staircase\") {\n        int step = opt<int>(\"step\", 1);\n        int repeat = step;\n        int current_height = 1;\n        for (int i = 0; i < n; ++i) {\n            h[i] = current_height;\n            if ((i + 1) % repeat == 0)\n                current_height++;\n        }\n    } else if (htype == \"spike\") {\n        int low = 1, high = 1000000000;\n        for (int i = 0; i < n; ++i)\n            h[i] = low;\n        int spike_pos = rnd.next(0, n - 1);\n        h[spike_pos] = high;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(1, 1000000000);\n    }\n\n    vector<tuple<int,int,int>> queries(m);\n\n    if (qtype == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int w = rnd.next(1, r - l + 1);\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"edge\") {\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            int w = n;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"single_panel\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = l;\n            int w = 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"max_w\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int w = r - l + 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"min_w\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int w = 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"fixed_w\") {\n        int fixed_w = opt<int>(\"wvalue\", 1);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n - fixed_w + 1);\n            int r = rnd.next(l + fixed_w - 1, n);\n            int w = fixed_w;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"small_w_large_range\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n / 2);\n            int r = rnd.next(n / 2, n);\n            int w = 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"large_w_small_range\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n - 5);\n            int r = l + rnd.next(0, 4);\n            int w = r - l + 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int w = rnd.next(1, r - l + 1);\n            queries[i] = make_tuple(l, r, w);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output h[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", h[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        int l, r, w;\n        tie(l, r, w) = queries[i];\n        printf(\"%d %d %d\\n\", l, r, w);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string htype = opt<string>(\"htype\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    vector<int> h(n);\n\n    if (htype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, 1000000000);\n        }\n    } else if (htype == \"min\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = 1;\n    } else if (htype == \"max\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = 1000000000;\n    } else if (htype == \"increasing\") {\n        int height = 1;\n        for (int i = 0; i < n; ++i)\n            h[i] = height++;\n    } else if (htype == \"decreasing\") {\n        int height = n;\n        for (int i = 0; i < n; ++i)\n            h[i] = height--;\n    } else if (htype == \"constant\") {\n        int value = opt<int>(\"hvalue\", 1000000000);\n        for (int i = 0; i < n; ++i)\n            h[i] = value;\n    } else if (htype == \"zigzag\") {\n        int low = 1, high = 1000000000;\n        for (int i = 0; i < n; ++i)\n            h[i] = (i % 2 == 0) ? low : high;\n    } else if (htype == \"staircase\") {\n        int step = opt<int>(\"step\", 1);\n        int repeat = step;\n        int current_height = 1;\n        for (int i = 0; i < n; ++i) {\n            h[i] = current_height;\n            if ((i + 1) % repeat == 0)\n                current_height++;\n        }\n    } else if (htype == \"spike\") {\n        int low = 1, high = 1000000000;\n        for (int i = 0; i < n; ++i)\n            h[i] = low;\n        int spike_pos = rnd.next(0, n - 1);\n        h[spike_pos] = high;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(1, 1000000000);\n    }\n\n    vector<tuple<int,int,int>> queries(m);\n\n    if (qtype == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int w = rnd.next(1, r - l + 1);\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"edge\") {\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            int w = n;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"single_panel\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = l;\n            int w = 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"max_w\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int w = r - l + 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"min_w\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int w = 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"fixed_w\") {\n        int fixed_w = opt<int>(\"wvalue\", 1);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n - fixed_w + 1);\n            int r = rnd.next(l + fixed_w - 1, n);\n            int w = fixed_w;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"small_w_large_range\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n / 2);\n            int r = rnd.next(n / 2, n);\n            int w = 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else if (qtype == \"large_w_small_range\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n - 5);\n            int r = l + rnd.next(0, 4);\n            int w = r - l + 1;\n            queries[i] = make_tuple(l, r, w);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int w = rnd.next(1, r - l + 1);\n            queries[i] = make_tuple(l, r, w);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output h[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", h[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        int l, r, w;\n        tie(l, r, w) = queries[i];\n        printf(\"%d %d %d\\n\", l, r, w);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -htype random -qtype random\n\n./gen -n 1 -m 1 -htype min -qtype single_panel\n\n./gen -n 1 -m 1 -htype max -qtype single_panel\n\n./gen -n 100000 -m 100000 -htype random -qtype random\n\n./gen -n 100000 -m 100000 -htype min -qtype random\n\n./gen -n 100000 -m 100000 -htype max -qtype random\n\n./gen -n 100000 -m 100000 -htype increasing -qtype random\n\n./gen -n 100000 -m 100000 -htype decreasing -qtype random\n\n./gen -n 100000 -m 100000 -htype constant -hvalue 123456789 -qtype random\n\n./gen -n 100000 -m 100000 -htype zigzag -qtype random\n\n./gen -n 100000 -m 100000 -htype staircase -step 1000 -qtype random\n\n./gen -n 100000 -m 100000 -htype spike -qtype random\n\n./gen -n 100000 -m 100000 -htype random -qtype edge\n\n./gen -n 100000 -m 100000 -htype random -qtype single_panel\n\n./gen -n 100000 -m 100000 -htype random -qtype min_w\n\n./gen -n 100000 -m 100000 -htype random -qtype max_w\n\n./gen -n 100000 -m 100000 -htype random -qtype fixed_w -wvalue 10\n\n./gen -n 100000 -m 100000 -htype random -qtype small_w_large_range\n\n./gen -n 100000 -m 100000 -htype random -qtype large_w_small_range\n\n./gen -n 100000 -m 100000 -htype min -qtype edge\n\n./gen -n 100000 -m 100000 -htype max -qtype edge\n\n./gen -n 1 -m 1 -htype random -qtype random\n\n./gen -n 1000 -m 1000 -htype random -qtype random\n\n./gen -n 100000 -m 100000 -htype constant -hvalue 1 -qtype random\n\n./gen -n 100000 -m 100000 -htype staircase -step 10000 -qtype random\n\n./gen -n 100000 -m 100000 -htype random -qtype fixed_w -wvalue 50000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:36:59.427532",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "485/A",
      "title": "A. Factory",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers a and m (1 ≤ a, m ≤ 105).",
      "output_spec": "OutputPrint \"Yes\" (without quotes) if the production will eventually stop, otherwise print \"No\".",
      "sample_tests": "ExamplesInputCopy1 5OutputCopyNoInputCopy3 6OutputCopyYes",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers a and m (1 ≤ a, m ≤ 105).\n\nOutputPrint \"Yes\" (without quotes) if the production will eventually stop, otherwise print \"No\".\n\nInputCopy1 5OutputCopyNoInputCopy3 6OutputCopyYes\n\nInputCopy1 5\n\nOutputCopyNo\n\nInputCopy3 6\n\nOutputCopyYes",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Hello everybody!Today will be Codeforces Round #276, which take place in both divisions. Start time is 19:30 in moscow time (follow this link to see time in others zones). For preparing contest i say thanks to Zlobober, for translating to Delinur, and to MikeMirzayanov for project Codeforces.Good luck to all, hope you will enjoy problems :)UPD Score distribution will be dynamic (see more information here). Problems will be sorted in increasing order of difficulty, however, do not forget to read all problems before the end of the contest.UPD The contest is over! Thanks to everyone who solved the problems despite everything. Analysis will be published later.UPD Editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 696
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - FactoryProduction will stops iff exists integer K ≥ 0 such a·2K is divisible by m. From this fact follows that K maximum will be about O(log2(m)). So if we modeling some, for example, 20 days and production does not stop, then it will never stop and answer is \"No\". Otherwise answer is \"Yes\".485B - Valuable ResourcesLet us find minimum length needed to cover points by Ox. It is Maximum(xi) - Minumum(xi). The same in Oy — Maximum(yi) - Minumum(yi). Since we need a square city to cover all the mines, then we need to set length of this square to the maximum from those two values.484A - BitsLet us define function f(L, R), that gives answer to the query. It looks follows: if L = R then f(L, R) = L; else if 2b ≤ L, where b — maximum integer such 2b ≤ R, then f(L, R) = f(L - 2b, R - 2b) + 2b; else if 2b + 1 - 1 ≤ R then f(L, R) = 2b + 1 - 1; else f(L, R) = 2b - 1. Total complexity is O(logR) per query.484B - Maximum ValueLet us iterate over all different aj. Since we need to maximize , then iterate all integer x (such x divisible by aj) in range from 2aj to M, where M — doubled maximum value of the sequence. For each such x we need to find maximum ai, such ai < x. Limits for numbers allow to do this in time O(1) with an array. After that, update answer by value . Total time complexity is O(nlogn + MlogM).484C - Strange SortingNote, that d-sorting is just a permutation (call it P), because it does not depends on characters in string. Look at shuffling operation in different way: instead of going to the next substring and sort it, we will shift string to one character left. It remains to understand that shift of string the permutation too (call it C). Now its clear, we need to calculate S·P·C·P·C... = S·(P·C)n - k + 1. And after that shift string for k - 1 character to the left for making answer to the shuffling operation. Here we use the multiplication of permutations. Since they are associative, that we can use binary algorithm to calculate (P·C)n - k + 1. Total time complexity is O(nmlogn).484D - KindergartenLet us note, that in optimal answer any segment that making a group contains their minimum and maximum values on borders. Otherwise it will be better to split this segment to two other segments. Another note that is every segment in optimal solution is strictly monotonic (increasing or decreasing). Paying attention to the interesting points in sequence which making local maximums (i. e. ai - 1 < ai > ai + 1), local minimums (ai - 1 > ai < ai + 1), and point adjacent to them. Solve the problem by dynamic programming: Di is the answer in the prefix i. To calculate Di we need to look at no more than three previous interesting points and to previous Di - 1. Total time complexity is O(n).484E - Sign on FenceLet us note that we can use binary search to find answer to the one query. Suppose at some moment was fixed height h and need to know will fit the rectangle with width w and height h to the segment of fence from l-th to r-th panel. Let us build data structure that can answer to this question. This will be persistent segment tree with unusual function inside: maximum number of consecutive ones in segment (maxOnes). In leaves of segment tree will be only numbers 0 and 1. To calculate this function need to know some other values, specifically:len — length of the segment in vertex of segment tree, prefOnes — length of prefix that consists only of ones, sufOnes — length of the suffix consist only of ones.These functions are computed as follows:maxOnes is equal to max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes equals prefOnes(Right) + len(Left) in case of len(Left) = prefOnes(Left), and prefOnes(Left) otherwise;sufOnes equals sufOnes(Left) + len(Right) in case of len(Right) = sufOnes(Right), and sufOnes(Right) otherwise;len = len(left) + len(Right);Left и Right — it is left and right sons of vertex in segment tree.As mentioned above, tree must be persistent, and it must be built as follows. First, builded empty tree of zeros. Next in position of highest plank need to put 1. The same doing for planks in decreasing order. For example if fence described with sequence [2, 5, 5, 1, 3] then bottom of segment tree will changed as follows:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].And we need to remember for all hi their version of tree. Now to answer the question we need to make query in our segment tree (that corresponding to height h) on segment [l, r]. If maxOnes form this query less than w, then rectangle impossible to put (otherwise possible).Building of tree will take O(nlogn) time and memory. Time complexity to the one query will take O(log2n) time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 485\\s*A"
          },
          "content_length": 4729
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100000, \"a\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100000, \"a\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100000, \"a\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int amax = opt<int>(\"amax\", 100000);\n    int mmax = opt<int>(\"mmax\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, m;\n\n    if (type == \"random\") {\n        a = rnd.next(1, amax);\n        m = rnd.next(1, mmax);\n    } else if (type == \"divisible\") {\n        m = rnd.next(1, mmax);\n        int k_max = amax / m;\n        if (k_max == 0) k_max = 1;\n        int k = rnd.next(1, k_max);\n        a = m * k;\n    } else if (type == \"coprime\") {\n        m = rnd.next(1, mmax);\n        do {\n            a = rnd.next(1, amax);\n        } while (gcd(a, m) != 1);\n    } else if (type == \"m1\") {\n        m = 1;\n        a = rnd.next(1, amax);\n    } else if (type == \"a1\") {\n        a = 1;\n        m = rnd.next(1, mmax);\n    } else if (type == \"mpow2\") {\n        int k_max = log2(mmax);\n        int k = rnd.next(0, k_max);\n        m = 1 << k;\n        if (m < 1 || m > mmax) m = mmax;\n        a = rnd.next(1, amax);\n    } else if (type == \"apow2\") {\n        int k_max = log2(amax);\n        int k = rnd.next(0, k_max);\n        a = 1 << k;\n        if (a < 1 || a > amax) a = amax;\n        m = rnd.next(1, mmax);\n    } else if (type == \"max\") {\n        a = amax;\n        m = mmax;\n    } else {\n        // default to random values\n        a = rnd.next(1, amax);\n        m = rnd.next(1, mmax);\n    }\n\n    printf(\"%d %d\\n\", a, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int amax = opt<int>(\"amax\", 100000);\n    int mmax = opt<int>(\"mmax\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, m;\n\n    if (type == \"random\") {\n        a = rnd.next(1, amax);\n        m = rnd.next(1, mmax);\n    } else if (type == \"divisible\") {\n        m = rnd.next(1, mmax);\n        int k_max = amax / m;\n        if (k_max == 0) k_max = 1;\n        int k = rnd.next(1, k_max);\n        a = m * k;\n    } else if (type == \"coprime\") {\n        m = rnd.next(1, mmax);\n        do {\n            a = rnd.next(1, amax);\n        } while (gcd(a, m) != 1);\n    } else if (type == \"m1\") {\n        m = 1;\n        a = rnd.next(1, amax);\n    } else if (type == \"a1\") {\n        a = 1;\n        m = rnd.next(1, mmax);\n    } else if (type == \"mpow2\") {\n        int k_max = log2(mmax);\n        int k = rnd.next(0, k_max);\n        m = 1 << k;\n        if (m < 1 || m > mmax) m = mmax;\n        a = rnd.next(1, amax);\n    } else if (type == \"apow2\") {\n        int k_max = log2(amax);\n        int k = rnd.next(0, k_max);\n        a = 1 << k;\n        if (a < 1 || a > amax) a = amax;\n        m = rnd.next(1, mmax);\n    } else if (type == \"max\") {\n        a = amax;\n        m = mmax;\n    } else {\n        // default to random values\n        a = rnd.next(1, amax);\n        m = rnd.next(1, mmax);\n    }\n\n    printf(\"%d %d\\n\", a, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with small values\n./gen -type random -amax 1 -mmax 1\n./gen -type random -amax 10 -mmax 10\n./gen -type random -amax 100 -mmax 100\n./gen -type random -amax 1000 -mmax 1000\n\n# Random test cases with maximum values\n./gen -type random -amax 100000 -mmax 100000\n./gen -type random -amax 99999 -mmax 99999\n\n# Test cases where 'a' is divisible by 'm'\n./gen -type divisible -amax 100000 -mmax 100000\n./gen -type divisible -amax 50000 -mmax 100000\n./gen -type divisible -amax 100000 -mmax 50000\n\n# Co-prime 'a' and 'm'\n./gen -type coprime -amax 100000 -mmax 100000\n./gen -type coprime -amax 50000 -mmax 50000\n./gen -type coprime -amax 99999 -mmax 100000\n\n# 'm' equals 1\n./gen -type m1 -amax 100000\n./gen -type m1 -amax 1\n./gen -type m1 -amax 1000\n\n# 'a' equals 1\n./gen -type a1 -mmax 100000\n./gen -type a1 -mmax 1\n./gen -type a1 -mmax 1000\n\n# 'm' is a power of 2\n./gen -type mpow2 -amax 100000 -mmax 100000\n./gen -type mpow2 -amax 100000 -mmax 100000\n./gen -type mpow2 -amax 50000 -mmax 1000\n\n# 'a' is a power of 2\n./gen -type apow2 -amax 100000 -mmax 100000\n./gen -type apow2 -amax 100000 -mmax 100000\n./gen -type apow2 -amax 50000 -mmax 1000\n\n# Maximum values\n./gen -type max -amax 100000 -mmax 100000\n\n# Edge cases\n./gen -type random -amax 1 -mmax 100000\n./gen -type random -amax 100000 -mmax 1\n./gen -type random -amax 99999 -mmax 1\n\n# Random test cases with small 'a' and large 'm'\n./gen -type random -amax 10 -mmax 100000\n\n# Random test cases with large 'a' and small 'm'\n./gen -type random -amax 100000 -mmax 10\n\n# Special test cases\n./gen -type divisible -amax 100000 -mmax 1\n./gen -type coprime -amax 2 -mmax 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:01.275459",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "485/B",
      "title": "B. Valuable Resources",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains number n — the number of mines on the map (2 ≤ n ≤ 1000). Each of the next n lines contains a pair of integers xi and yi — the coordinates of the corresponding mine ( - 109 ≤ xi, yi ≤ 109). All points are pairwise distinct.",
      "output_spec": "OutputPrint the minimum area of the city that can cover all the mines with valuable resources.",
      "sample_tests": "ExamplesInputCopy20 02 2OutputCopy4InputCopy20 00 3OutputCopy9",
      "description": "B. Valuable Resources\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains number n — the number of mines on the map (2 ≤ n ≤ 1000). Each of the next n lines contains a pair of integers xi and yi — the coordinates of the corresponding mine ( - 109 ≤ xi, yi ≤ 109). All points are pairwise distinct.\n\nOutputPrint the minimum area of the city that can cover all the mines with valuable resources.\n\nInputCopy20 02 2OutputCopy4InputCopy20 00 3OutputCopy9\n\nInputCopy20 02 2\n\nOutputCopy4\n\nInputCopy20 00 3\n\nOutputCopy9",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Hello everybody!Today will be Codeforces Round #276, which take place in both divisions. Start time is 19:30 in moscow time (follow this link to see time in others zones). For preparing contest i say thanks to Zlobober, for translating to Delinur, and to MikeMirzayanov for project Codeforces.Good luck to all, hope you will enjoy problems :)UPD Score distribution will be dynamic (see more information here). Problems will be sorted in increasing order of difficulty, however, do not forget to read all problems before the end of the contest.UPD The contest is over! Thanks to everyone who solved the problems despite everything. Analysis will be published later.UPD Editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 696
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - FactoryProduction will stops iff exists integer K ≥ 0 such a·2K is divisible by m. From this fact follows that K maximum will be about O(log2(m)). So if we modeling some, for example, 20 days and production does not stop, then it will never stop and answer is \"No\". Otherwise answer is \"Yes\".485B - Valuable ResourcesLet us find minimum length needed to cover points by Ox. It is Maximum(xi) - Minumum(xi). The same in Oy — Maximum(yi) - Minumum(yi). Since we need a square city to cover all the mines, then we need to set length of this square to the maximum from those two values.484A - BitsLet us define function f(L, R), that gives answer to the query. It looks follows: if L = R then f(L, R) = L; else if 2b ≤ L, where b — maximum integer such 2b ≤ R, then f(L, R) = f(L - 2b, R - 2b) + 2b; else if 2b + 1 - 1 ≤ R then f(L, R) = 2b + 1 - 1; else f(L, R) = 2b - 1. Total complexity is O(logR) per query.484B - Maximum ValueLet us iterate over all different aj. Since we need to maximize , then iterate all integer x (such x divisible by aj) in range from 2aj to M, where M — doubled maximum value of the sequence. For each such x we need to find maximum ai, such ai < x. Limits for numbers allow to do this in time O(1) with an array. After that, update answer by value . Total time complexity is O(nlogn + MlogM).484C - Strange SortingNote, that d-sorting is just a permutation (call it P), because it does not depends on characters in string. Look at shuffling operation in different way: instead of going to the next substring and sort it, we will shift string to one character left. It remains to understand that shift of string the permutation too (call it C). Now its clear, we need to calculate S·P·C·P·C... = S·(P·C)n - k + 1. And after that shift string for k - 1 character to the left for making answer to the shuffling operation. Here we use the multiplication of permutations. Since they are associative, that we can use binary algorithm to calculate (P·C)n - k + 1. Total time complexity is O(nmlogn).484D - KindergartenLet us note, that in optimal answer any segment that making a group contains their minimum and maximum values on borders. Otherwise it will be better to split this segment to two other segments. Another note that is every segment in optimal solution is strictly monotonic (increasing or decreasing). Paying attention to the interesting points in sequence which making local maximums (i. e. ai - 1 < ai > ai + 1), local minimums (ai - 1 > ai < ai + 1), and point adjacent to them. Solve the problem by dynamic programming: Di is the answer in the prefix i. To calculate Di we need to look at no more than three previous interesting points and to previous Di - 1. Total time complexity is O(n).484E - Sign on FenceLet us note that we can use binary search to find answer to the one query. Suppose at some moment was fixed height h and need to know will fit the rectangle with width w and height h to the segment of fence from l-th to r-th panel. Let us build data structure that can answer to this question. This will be persistent segment tree with unusual function inside: maximum number of consecutive ones in segment (maxOnes). In leaves of segment tree will be only numbers 0 and 1. To calculate this function need to know some other values, specifically:len — length of the segment in vertex of segment tree, prefOnes — length of prefix that consists only of ones, sufOnes — length of the suffix consist only of ones.These functions are computed as follows:maxOnes is equal to max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes equals prefOnes(Right) + len(Left) in case of len(Left) = prefOnes(Left), and prefOnes(Left) otherwise;sufOnes equals sufOnes(Left) + len(Right) in case of len(Right) = sufOnes(Right), and sufOnes(Right) otherwise;len = len(left) + len(Right);Left и Right — it is left and right sons of vertex in segment tree.As mentioned above, tree must be persistent, and it must be built as follows. First, builded empty tree of zeros. Next in position of highest plank need to put 1. The same doing for planks in decreasing order. For example if fence described with sequence [2, 5, 5, 1, 3] then bottom of segment tree will changed as follows:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].And we need to remember for all hi their version of tree. Now to answer the question we need to make query in our segment tree (that corresponding to height h) on segment [l, r]. If maxOnes form this query less than w, then rectangle impossible to put (otherwise possible).Building of tree will take O(nlogn) time and memory. Time complexity to the one query will take O(log2n) time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 485\\s*B"
          },
          "content_length": 4729
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n        \n        // Check that each point is unique\n        ensuref(points.count({x, y}) == 0, \"Point (%d, %d) appears more than once\", x, y);\n        points.insert({x, y});\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n        \n        // Check that each point is unique\n        ensuref(points.count({x, y}) == 0, \"Point (%d, %d) appears more than once\", x, y);\n        points.insert({x, y});\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n        \n        // Check that each point is unique\n        ensuref(points.count({x, y}) == 0, \"Point (%d, %d) appears more than once\", x, y);\n        points.insert({x, y});\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points(n);\n\n    if (type == \"random\") {\n        // Generate random points within constraints\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n                y = rnd.next(-1000000000, 1000000000);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else if (type == \"line_x\") {\n        // All points with same x coordinate\n        int x = rnd.next(-1000000000, 1000000000);\n        set<int> used_y;\n        for (int i = 0; i < n; ++i) {\n            int y;\n            do {\n                y = rnd.next(-1000000000, 1000000000);\n            } while (used_y.count(y));\n            used_y.insert(y);\n            points[i] = {x, y};\n        }\n    } else if (type == \"line_y\") {\n        // All points with same y coordinate\n        int y = rnd.next(-1000000000, 1000000000);\n        set<int> used_x;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n            } while (used_x.count(x));\n            used_x.insert(x);\n            points[i] = {x, y};\n        }\n    } else if (type == \"diagonal\") {\n        // Points along x = y\n        set<int> used_x;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n            } while (used_x.count(x));\n            used_x.insert(x);\n            points[i] = {x, x};\n        }\n    } else if (type == \"big_x\") {\n        // ∆x significantly larger than ∆y\n        int minY = rnd.next(-1000, 1000);\n        int maxY = minY + rnd.next(0, 10);\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n                y = rnd.next(minY, maxY);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else if (type == \"big_y\") {\n        // ∆y significantly larger than ∆x\n        int minX = rnd.next(-1000, 1000);\n        int maxX = minX + rnd.next(0, 10);\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(minX, maxX);\n                y = rnd.next(-1000000000, 1000000000);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else if (type == \"corners\") {\n        int minX = rnd.next(-1000000000, 1000000000 - 1000);\n        int minY = rnd.next(-1000000000, 1000000000 - 1000);\n        int length = rnd.next(1, 1000);\n        int maxX = minX + length;\n        int maxY = minY + length;\n\n        vector<pair<int,int>> possible_points;\n\n        // Four corners\n        possible_points.push_back({minX, minY});\n        possible_points.push_back({minX, maxY});\n        possible_points.push_back({maxX, minY});\n        possible_points.push_back({maxX, maxY});\n\n        // Generate points along edges\n        for (int i = 1; i < length && possible_points.size() < (size_t)n; ++i) {\n            possible_points.push_back({minX + i, minY});\n            possible_points.push_back({minX, minY + i});\n            possible_points.push_back({maxX - i, maxY});\n            possible_points.push_back({maxX, maxY - i});\n        }\n\n        // Fill in the rest with random points within the square\n        set<pair<int,int>> used(possible_points.begin(), possible_points.end());\n        while ((int)possible_points.size() < n) {\n            int x = rnd.next(minX, maxX);\n            int y = rnd.next(minY, maxY);\n            if (used.count({x, y})) continue;\n            possible_points.push_back({x, y});\n            used.insert({x, y});\n        }\n\n        // Now pick first n points\n        points = vector<pair<int,int>>(possible_points.begin(), possible_points.begin() + n);\n    } else if (type == \"negative\") {\n        // Points with negative coordinates\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000000, -1);\n                y = rnd.next(-1000000000, -1);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else if (type == \"max_range\") {\n        // Points at extreme coordinates\n        vector<int> xs = {int(-1000000000), int(1000000000)};\n        vector<int> ys = {int(-1000000000), int(1000000000)};\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x = xs[rnd.next(0, 1)];\n            int y = ys[rnd.next(0, 1)];\n            if (used.count({x, y})) {\n                x = (x == -1000000000) ? 1000000000 : -1000000000;\n                y = (y == -1000000000) ? 1000000000 : -1000000000;\n            }\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else {\n        // Default to random if type is unrecognized\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n                y = rnd.next(-1000000000, 1000000000);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output points\n    for (const auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points(n);\n\n    if (type == \"random\") {\n        // Generate random points within constraints\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n                y = rnd.next(-1000000000, 1000000000);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else if (type == \"line_x\") {\n        // All points with same x coordinate\n        int x = rnd.next(-1000000000, 1000000000);\n        set<int> used_y;\n        for (int i = 0; i < n; ++i) {\n            int y;\n            do {\n                y = rnd.next(-1000000000, 1000000000);\n            } while (used_y.count(y));\n            used_y.insert(y);\n            points[i] = {x, y};\n        }\n    } else if (type == \"line_y\") {\n        // All points with same y coordinate\n        int y = rnd.next(-1000000000, 1000000000);\n        set<int> used_x;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n            } while (used_x.count(x));\n            used_x.insert(x);\n            points[i] = {x, y};\n        }\n    } else if (type == \"diagonal\") {\n        // Points along x = y\n        set<int> used_x;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n            } while (used_x.count(x));\n            used_x.insert(x);\n            points[i] = {x, x};\n        }\n    } else if (type == \"big_x\") {\n        // ∆x significantly larger than ∆y\n        int minY = rnd.next(-1000, 1000);\n        int maxY = minY + rnd.next(0, 10);\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n                y = rnd.next(minY, maxY);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else if (type == \"big_y\") {\n        // ∆y significantly larger than ∆x\n        int minX = rnd.next(-1000, 1000);\n        int maxX = minX + rnd.next(0, 10);\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(minX, maxX);\n                y = rnd.next(-1000000000, 1000000000);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else if (type == \"corners\") {\n        int minX = rnd.next(-1000000000, 1000000000 - 1000);\n        int minY = rnd.next(-1000000000, 1000000000 - 1000);\n        int length = rnd.next(1, 1000);\n        int maxX = minX + length;\n        int maxY = minY + length;\n\n        vector<pair<int,int>> possible_points;\n\n        // Four corners\n        possible_points.push_back({minX, minY});\n        possible_points.push_back({minX, maxY});\n        possible_points.push_back({maxX, minY});\n        possible_points.push_back({maxX, maxY});\n\n        // Generate points along edges\n        for (int i = 1; i < length && possible_points.size() < (size_t)n; ++i) {\n            possible_points.push_back({minX + i, minY});\n            possible_points.push_back({minX, minY + i});\n            possible_points.push_back({maxX - i, maxY});\n            possible_points.push_back({maxX, maxY - i});\n        }\n\n        // Fill in the rest with random points within the square\n        set<pair<int,int>> used(possible_points.begin(), possible_points.end());\n        while ((int)possible_points.size() < n) {\n            int x = rnd.next(minX, maxX);\n            int y = rnd.next(minY, maxY);\n            if (used.count({x, y})) continue;\n            possible_points.push_back({x, y});\n            used.insert({x, y});\n        }\n\n        // Now pick first n points\n        points = vector<pair<int,int>>(possible_points.begin(), possible_points.begin() + n);\n    } else if (type == \"negative\") {\n        // Points with negative coordinates\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000000, -1);\n                y = rnd.next(-1000000000, -1);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else if (type == \"max_range\") {\n        // Points at extreme coordinates\n        vector<int> xs = {int(-1000000000), int(1000000000)};\n        vector<int> ys = {int(-1000000000), int(1000000000)};\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x = xs[rnd.next(0, 1)];\n            int y = ys[rnd.next(0, 1)];\n            if (used.count({x, y})) {\n                x = (x == -1000000000) ? 1000000000 : -1000000000;\n                y = (y == -1000000000) ? 1000000000 : -1000000000;\n            }\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    } else {\n        // Default to random if type is unrecognized\n        set<pair<int,int>> used;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n                y = rnd.next(-1000000000, 1000000000);\n            } while (used.count({x, y}));\n            used.insert({x, y});\n            points[i] = {x, y};\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output points\n    for (const auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type line_x\n./gen -n 2 -type line_y\n./gen -n 2 -type diagonal\n./gen -n 2 -type big_x\n./gen -n 2 -type big_y\n./gen -n 2 -type corners\n./gen -n 2 -type negative\n./gen -n 2 -type max_range\n\n./gen -n 10 -type random\n./gen -n 10 -type line_x\n./gen -n 10 -type line_y\n./gen -n 10 -type diagonal\n./gen -n 10 -type big_x\n./gen -n 10 -type big_y\n./gen -n 10 -type corners\n./gen -n 10 -type negative\n./gen -n 10 -type max_range\n\n./gen -n 100 -type random\n./gen -n 100 -type line_x\n./gen -n 100 -type line_y\n./gen -n 100 -type diagonal\n./gen -n 100 -type big_x\n./gen -n 100 -type big_y\n./gen -n 100 -type corners\n./gen -n 100 -type negative\n./gen -n 100 -type max_range\n\n./gen -n 500 -type random\n./gen -n 500 -type line_x\n./gen -n 500 -type line_y\n./gen -n 500 -type diagonal\n./gen -n 500 -type big_x\n./gen -n 500 -type big_y\n\n./gen -n 1000 -type random\n./gen -n 1000 -type line_x\n./gen -n 1000 -type diagonal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:03.526651",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "485/C",
      "title": "C. Bits",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n — the number of queries (1 ≤ n ≤ 10000).Each of the following n lines contain two integers li, ri — the arguments for the corresponding query (0 ≤ li ≤ ri ≤ 1018).",
      "output_spec": "OutputFor each query print the answer in a separate line.",
      "sample_tests": "ExamplesInputCopy31 22 41 10OutputCopy137",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n — the number of queries (1 ≤ n ≤ 10000).Each of the following n lines contain two integers li, ri — the arguments for the corresponding query (0 ≤ li ≤ ri ≤ 1018).\n\nOutputFor each query print the answer in a separate line.\n\nInputCopy31 22 41 10OutputCopy137\n\nInputCopy31 22 41 10\n\nOutputCopy137\n\nNoteThe binary representations of numbers from 1 to 10 are listed below:110 = 12210 = 102310 = 112410 = 1002510 = 1012610 = 1102710 = 1112810 = 10002910 = 100121010 = 10102",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Hello everybody!Today will be Codeforces Round #276, which take place in both divisions. Start time is 19:30 in moscow time (follow this link to see time in others zones). For preparing contest i say thanks to Zlobober, for translating to Delinur, and to MikeMirzayanov for project Codeforces.Good luck to all, hope you will enjoy problems :)UPD Score distribution will be dynamic (see more information here). Problems will be sorted in increasing order of difficulty, however, do not forget to read all problems before the end of the contest.UPD The contest is over! Thanks to everyone who solved the problems despite everything. Analysis will be published later.UPD Editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 696
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - FactoryProduction will stops iff exists integer K ≥ 0 such a·2K is divisible by m. From this fact follows that K maximum will be about O(log2(m)). So if we modeling some, for example, 20 days and production does not stop, then it will never stop and answer is \"No\". Otherwise answer is \"Yes\".485B - Valuable ResourcesLet us find minimum length needed to cover points by Ox. It is Maximum(xi) - Minumum(xi). The same in Oy — Maximum(yi) - Minumum(yi). Since we need a square city to cover all the mines, then we need to set length of this square to the maximum from those two values.484A - BitsLet us define function f(L, R), that gives answer to the query. It looks follows: if L = R then f(L, R) = L; else if 2b ≤ L, where b — maximum integer such 2b ≤ R, then f(L, R) = f(L - 2b, R - 2b) + 2b; else if 2b + 1 - 1 ≤ R then f(L, R) = 2b + 1 - 1; else f(L, R) = 2b - 1. Total complexity is O(logR) per query.484B - Maximum ValueLet us iterate over all different aj. Since we need to maximize , then iterate all integer x (such x divisible by aj) in range from 2aj to M, where M — doubled maximum value of the sequence. For each such x we need to find maximum ai, such ai < x. Limits for numbers allow to do this in time O(1) with an array. After that, update answer by value . Total time complexity is O(nlogn + MlogM).484C - Strange SortingNote, that d-sorting is just a permutation (call it P), because it does not depends on characters in string. Look at shuffling operation in different way: instead of going to the next substring and sort it, we will shift string to one character left. It remains to understand that shift of string the permutation too (call it C). Now its clear, we need to calculate S·P·C·P·C... = S·(P·C)n - k + 1. And after that shift string for k - 1 character to the left for making answer to the shuffling operation. Here we use the multiplication of permutations. Since they are associative, that we can use binary algorithm to calculate (P·C)n - k + 1. Total time complexity is O(nmlogn).484D - KindergartenLet us note, that in optimal answer any segment that making a group contains their minimum and maximum values on borders. Otherwise it will be better to split this segment to two other segments. Another note that is every segment in optimal solution is strictly monotonic (increasing or decreasing). Paying attention to the interesting points in sequence which making local maximums (i. e. ai - 1 < ai > ai + 1), local minimums (ai - 1 > ai < ai + 1), and point adjacent to them. Solve the problem by dynamic programming: Di is the answer in the prefix i. To calculate Di we need to look at no more than three previous interesting points and to previous Di - 1. Total time complexity is O(n).484E - Sign on FenceLet us note that we can use binary search to find answer to the one query. Suppose at some moment was fixed height h and need to know will fit the rectangle with width w and height h to the segment of fence from l-th to r-th panel. Let us build data structure that can answer to this question. This will be persistent segment tree with unusual function inside: maximum number of consecutive ones in segment (maxOnes). In leaves of segment tree will be only numbers 0 and 1. To calculate this function need to know some other values, specifically:len — length of the segment in vertex of segment tree, prefOnes — length of prefix that consists only of ones, sufOnes — length of the suffix consist only of ones.These functions are computed as follows:maxOnes is equal to max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes equals prefOnes(Right) + len(Left) in case of len(Left) = prefOnes(Left), and prefOnes(Left) otherwise;sufOnes equals sufOnes(Left) + len(Right) in case of len(Right) = sufOnes(Right), and sufOnes(Right) otherwise;len = len(left) + len(Right);Left и Right — it is left and right sons of vertex in segment tree.As mentioned above, tree must be persistent, and it must be built as follows. First, builded empty tree of zeros. Next in position of highest plank need to put 1. The same doing for planks in decreasing order. For example if fence described with sequence [2, 5, 5, 1, 3] then bottom of segment tree will changed as follows:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].And we need to remember for all hi their version of tree. Now to answer the question we need to make query in our segment tree (that corresponding to height h) on segment [l, r]. If maxOnes form this query less than w, then rectangle impossible to put (otherwise possible).Building of tree will take O(nlogn) time and memory. Time complexity to the one query will take O(log2n) time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 485 和字母"
          },
          "content_length": 4729
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const long long MAX_VAL = 1000000000000000000LL;\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        long long l_i = inf.readLong(0, MAX_VAL, \"l_i\");\n        inf.readSpace();\n        long long r_i = inf.readLong(l_i, MAX_VAL, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const long long MAX_VAL = 1000000000000000000LL;\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        long long l_i = inf.readLong(0, MAX_VAL, \"l_i\");\n        inf.readSpace();\n        long long r_i = inf.readLong(l_i, MAX_VAL, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const long long MAX_VAL = 1000000000000000000LL;\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        long long l_i = inf.readLong(0, MAX_VAL, \"l_i\");\n        inf.readSpace();\n        long long r_i = inf.readLong(l_i, MAX_VAL, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long maxl = opt<long long>(\"maxl\", 0LL); // default to 0\n    long long maxr = opt<long long>(\"maxr\", 1000000000000000000LL); // default to 1e18\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n    \n    for (int i = 0; i < n; i++) {\n        long long l, r;\n        if (type == \"random\") {\n            l = rnd.next(0LL, maxr);\n            r = rnd.next(l, maxr);\n        } else if (type == \"small\") {\n            // small l and r\n            l = rnd.next(0LL, 1000LL);\n            r = rnd.next(l, l + 1000LL);\n        } else if (type == \"large\") {\n            // l and r close to 1e18\n            l = rnd.next(1000000000000000000LL - 1000LL, 1000000000000000000LL);\n            r = rnd.next(l, 1000000000000000000LL);\n        } else if (type == \"equal\") {\n            l = rnd.next(0LL, maxr);\n            r = l;\n        } else if (type == \"powers\") {\n            // l and r around powers of two\n            int k = rnd.next(0, 60); // up to 2^60\n            long long p = 1LL << k;\n            l = p - rnd.next(0LL, 1000LL);\n            r = p + rnd.next(0LL, 1000LL);\n            l = max(0LL, l);\n            r = min(r, 1000000000000000000LL);\n        } else if (type == \"maxbits\") {\n            // numbers with maximum bits set in range\n            // numbers like (1<<k)-1\n            int k = rnd.next(1, 60);\n            long long x = (1LL << k) - 1;\n            l = x - rnd.next(0LL, 1000LL);\n            r = x + rnd.next(0LL, 1000LL);\n            l = max(0LL, l);\n            r = min(r, 1000000000000000000LL);\n        } else if (type == \"zeros\") {\n            // l is zero\n            l = 0;\n            r = rnd.next(0LL, maxr);\n        } else if (type == \"maxvalues\") {\n            // r is maximum\n            l = rnd.next(0LL, maxl);\n            r = 1000000000000000000LL;\n        } else {\n            // default to random\n            l = rnd.next(0LL, maxl);\n            r = rnd.next(l, maxr);\n        }\n        // Making sure l ≤ r ≤ 1e18\n        l = max(0LL, l);\n        r = max(l, min(r, 1000000000000000000LL));\n        printf(\"%lld %lld\\n\", l, r);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long maxl = opt<long long>(\"maxl\", 0LL); // default to 0\n    long long maxr = opt<long long>(\"maxr\", 1000000000000000000LL); // default to 1e18\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n    \n    for (int i = 0; i < n; i++) {\n        long long l, r;\n        if (type == \"random\") {\n            l = rnd.next(0LL, maxr);\n            r = rnd.next(l, maxr);\n        } else if (type == \"small\") {\n            // small l and r\n            l = rnd.next(0LL, 1000LL);\n            r = rnd.next(l, l + 1000LL);\n        } else if (type == \"large\") {\n            // l and r close to 1e18\n            l = rnd.next(1000000000000000000LL - 1000LL, 1000000000000000000LL);\n            r = rnd.next(l, 1000000000000000000LL);\n        } else if (type == \"equal\") {\n            l = rnd.next(0LL, maxr);\n            r = l;\n        } else if (type == \"powers\") {\n            // l and r around powers of two\n            int k = rnd.next(0, 60); // up to 2^60\n            long long p = 1LL << k;\n            l = p - rnd.next(0LL, 1000LL);\n            r = p + rnd.next(0LL, 1000LL);\n            l = max(0LL, l);\n            r = min(r, 1000000000000000000LL);\n        } else if (type == \"maxbits\") {\n            // numbers with maximum bits set in range\n            // numbers like (1<<k)-1\n            int k = rnd.next(1, 60);\n            long long x = (1LL << k) - 1;\n            l = x - rnd.next(0LL, 1000LL);\n            r = x + rnd.next(0LL, 1000LL);\n            l = max(0LL, l);\n            r = min(r, 1000000000000000000LL);\n        } else if (type == \"zeros\") {\n            // l is zero\n            l = 0;\n            r = rnd.next(0LL, maxr);\n        } else if (type == \"maxvalues\") {\n            // r is maximum\n            l = rnd.next(0LL, maxl);\n            r = 1000000000000000000LL;\n        } else {\n            // default to random\n            l = rnd.next(0LL, maxl);\n            r = rnd.next(l, maxr);\n        }\n        // Making sure l ≤ r ≤ 1e18\n        l = max(0LL, l);\n        r = max(l, min(r, 1000000000000000000LL));\n        printf(\"%lld %lld\\n\", l, r);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with small n and small ranges\n./gen -n 1 -type equal\n./gen -n 2 -type small\n./gen -n 5 -type small\n./gen -n 10 -type small\n\n# Test cases with medium n and random ranges\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n\n# Test cases with maximum n and random ranges\n./gen -n 10000 -type random\n\n# Test cases with l = r\n./gen -n 10000 -type equal\n\n# Test cases with l and r being zero or maximum values\n./gen -n 10000 -type zeros\n./gen -n 10000 -type maxvalues\n\n# Test cases with small ranges\n./gen -n 10000 -type small\n\n# Test cases with large ranges (values near 1e18)\n./gen -n 10000 -type large\n\n# Test cases with l and r around powers of two\n./gen -n 10000 -type powers\n\n# Test cases with l and r around numbers with maximum bits set\n./gen -n 10000 -type maxbits\n\n# Test cases with random ranges and maximum l and r specified\n./gen -n 10000 -type random -maxl 500000000000000000 -maxr 1000000000000000000\n\n# Test cases with l = 0 and random r\n./gen -n 10000 -type zeros -maxr 100000\n\n# Test cases with l and r close to each other\n./gen -n 10000 -type small\n\n# Test cases with l and r spanning the entire possible range\n./gen -n 10000 -type random -maxl 0 -maxr 1000000000000000000\n\n# Test cases with l and r in the middle of the range\n./gen -n 10000 -type random -maxl 500000000000000000 -maxr 500000000000000000\n\n# Test cases with l and r at extreme ends\n./gen -n 10000 -type random -maxl 0 -maxr 1000000000000000000\n\n# Test cases with l always zero and r being small\n./gen -n 10000 -type zeros -maxr 1000\n\n# Test cases with l and r both being maximum\n./gen -n 10000 -type maxvalues\n\n# Test cases with varying types\n./gen -n 10000 -type equal\n./gen -n 10000 -type powers\n./gen -n 10000 -type maxbits\n./gen -n 10000 -type random\n./gen -n 10000 -type large\n./gen -n 10000 -type small\n./gen -n 10000 -type zeros\n\n# Additional test cases with n = 10000 and varying l and r\n./gen -n 10000 -type random -maxl 1000000 -maxr 1000000000\n./gen -n 10000 -type random -maxl 1000000000 -maxr 1000000000000\n./gen -n 10000 -type random -maxl 0 -maxr 1\n./gen -n 10000 -type random -maxl 1 -maxr 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:05.228306",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "485/D",
      "title": "D. Максимальное значение",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n — длина последовательности (1 ≤ n ≤ 2·105). Во второй строке содержатся n целых чисел ai, разделенных пробелами (1 ≤ ai ≤ 106).",
      "output_spec": "Выходные данныеВыведите ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать33 4 5Выходные данныеСкопировать2",
      "description": "D. Максимальное значение\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n — длина последовательности (1 ≤ n ≤ 2·105). Во второй строке содержатся n целых чисел ai, разделенных пробелами (1 ≤ ai ≤ 106).\n\nВходные данные\n\nВыходные данныеВыведите ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать33 4 5Выходные данныеСкопировать2\n\nВходные данныеСкопировать33 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Привет всем! Сегодня состоится Codeforces Round #276, который пройдёт в обоих дивизионах. Время старта — 19:30 по московскому времени (перейдите по ссылке для просмотра времени в других регионах). За помощь в подготовке контеста спасибо Zlobober, за перевод на английский спасибо Delinur, и спасибо MikeMirzayanov за сам проект Codeforces.Желаю всем удачи, надеюсь, вам понравятся задачи :)UPD Разбалловка в обоих дивизионах будет динамическая (подробнее об этом можно почитать здесь). Задачи будут упорядочены по возрастанию сложности, тем не менее, не забудьте прочитать все задачи до конца контеста.UPD Контест окончен! Спасибо всем, кто решал задачи несмотря ни на что. Разбор будет опубликован позднее.UPD Разбор можно найти здесь. На моё удивление задача div1C оказалась довольно сложной и по количеству посылок сравнялась с div1E, а во втором дивизионе эту задачу вообще никто не сдал за время контеста. Удачи вам в покорении разбора :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 943
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - ФабрикаПроизводство остановится только в том случае, если существует такое целое K ≥ 0, что a·2K делится на m. Из этого следует, что K может быть максимум порядка log2(m). Так как K — это по сути сколько пройдёт дней до этого момента, то можно промоделировать описанные в условии задачи действия, например, в течение 20-ти дней (не забыв при этом про 64-битный тип данных). Если в какой-то момент производство остановилось, то ответ \"Yes\". Если не остановилось в течение этих дней, то оно не остановится никогда, а значит ответ \"No\".485B - Ценные ресурсыНайдём минимальную длину, необходимую чтобы покрыть все точки по оси Ox — это будет в точности Maximum(xi) - Minumum(xi). Аналогично и для оси Oy — это Maximum(yi) - Minumum(yi). Так как нам необходим квадрат, то следует взять максимальную из этих двух величин в качестве длины его стороны.484A - БитыОпишем функцию f(L, R), которая будет ответом на задачу. Она ведёт себя следующим образом: если L = R, то f(L, R) = L; иначе, если 2b ≤ L, где b — максимальное целое число такое, что 2b ≤ R, то f(L, R) = f(L - 2b, R - 2b) + 2b; иначе, если 2b + 1 - 1 ≤ R, то f(L, R) = 2b + 1 - 1; иначе f(L, R) = 2b - 1. Итоговая сложность — O(logR) на один запрос.484B - Максимальное значениеПереберём все различные числа aj исходной последовательности. Так как нужно максимизировать , то переберём в цикле по x все числа, кратные aj в диапазоне от 2aj до M, где M — удвоенное максимальное значение элемента последовательности. Для каждого такого числа нужно найти максимальное ai, такое, что ai < x. Ограничения на числа позволяют сделать это за O(1) при помощи массива. Обновим ответ величиной . Так как перебираются только различные aj, то итоговая сложность составит O(nlogn + MlogM).484C - Странная сортировкаЗаметим, что d-сортировка не зависит от того, какие символы находятся в строке, а значит является перестановкой (назовём её P). Посмотрим на операцию перемешивания по другому: вместо того, чтобы переходить к очередной следующей подстроке и сортировать её, сделаем циклический сдвиг всей строки на один символ влево. Таким образом, сортироваться будет только префикс строки, а строка сдвигаться. Осталось понять, что сдвиг влево — это тоже перестановка (назовём её C). Теперь всё просто, к строке нужно поочерёдно применять перестановки P и C, то есть нужно получить S·P·C·P·C... = S·(P·C)n - k + 1. После этого строку нужно сдвинуть ещё на k - 1 символ влево, чтобы получить то, что получится после операции перемешивания. Здесь используется умножение перестановок, а оно в свою очередь ассоциативно, а значит для вычисления (P·C)n - k + 1 можно воспользоваться бинарным алгоритмом. Итоговая сложность составит O(nmlogn).484D - Детский садЗаметим, что существует оптимальный ответ такой, что любой отрезок, который образует группу, содержит свои максимальные и минимальные значения на границах. Иначе было бы выгодно разбить отрезок хотябы на два. Так же можно заметить, что каждый отрезок будет строго монотонным (элементы на нём строго возрастают или убывают). Выделим интересные точки в последовательности — это либо локальные максимумы (то есть ai - 1 < ai > ai + 1), либо минимумы (ai - 1 > ai < ai + 1), либо соседние с ними точки. Будем решать задачу методом динамического программирования, Di — наилучший ответ для префикса i. Тогда при вычислении очередного значения необходимо обработать не более трёх предыдущих интересных точек, а так же предыдущую точку. Итоговая сложность — O(n).484E - Объявление на забореЗаметим, что при поиске ответа на конкретный запрос можно воспользоваться бинарным поиском по ответу. Пусть в какой-то момент зафиксировалась высота h и необходимо узнать, помещается ли прямоугольник размера w на h в участок забора с l-ой по r-ой доски включительно. Заведём перед обработкой запросов структуру данных, которая поможет отвечать на такой вопрос. Это будет персистентное дерево отрезков с необычной функцией: максимальное количество подряд идущих единиц на отрезке (далее maxOnes). В листьях дерева будут только числа 0 и 1. Чтобы реализовать такую функцию, необходимо ввести ещё некоторые величины, а именно:len — длина отрезка в вершине дерева отрезков, prefOnes — длина префикса, полностью состоящего из единиц, sufOnes — длина суффикса, полностью состоящего из единиц.Вычисляются эти функции следующим образом:maxOnes, требуемая функция, равна max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes равна prefOnes(Right) + len(Left) в случае, если len(Left) = prefOnes(Left), иначе она равна prefOnes(Left);sufOnes равна sufOnes(Left) + len(Right) в случае, если len(Right) = sufOnes(Right), иначе она равна sufOnes(Right);len = len(left) + len(Right);Left и Right — соответственно левый и правые сыновья текущей вершины в структуре дерева отрезков.Как уже упоминалось выше, дерево должно быть персистентным (то есть хранить все свои версии после изменений), строиться оно должно следующим образом. Сначала строится пустое дерево — из одних нулей. Далее в позицию, где в заборе находится самая высокая доска, ставится единица. Тоже самое делается для второй по убыванию высоты доски и так далее. Например, если забор описывался последовательностью [2, 5, 5, 1, 3], то изменения последнего слоя дерева будут следующими:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].При этом для каждой высоты hi нужно запомнить соответствующую версию дерева, назовём её как treeheight. Теперь, чтобы ответить на вопрос выше, нужно сделать запрос на отрезке [l, r] у дерева treeh. Если maxOnes этого запроса меньше w, то прямоугольник невозможно разместить, иначе возможно.Построение дерева займёт O(nlogn) времени и памяти. Ответ на запрос займёт O(log2n) времени.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 485 和字母"
          },
          "content_length": 5733
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "R = 2^A + Q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A - количество accepted",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "Q - quality",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 12",
          "code": "int64_t x;\n__builtin_popcount(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 13",
          "code": "int64_t x;\n__builtin_popcount(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 14",
          "code": "__builtin_popcountll(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 15",
          "code": "for(int i = 2; i <= 1e6; i++) {\n    int lf = i + 1;\n    while(lf <= mx) {\n        lf += 2;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 16",
          "code": "for(int i = 2; i <= 1e6; i++) {\n    int lf = i + 1;\n    while(lf <= mx) {\n        lf += 2;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 17",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 18",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 19",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "Тогда при вычислении очередного значения необходимо обработать не более трёх предыдущих интересных точек, а так же предыдущую точку.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "Выведете максимальную возможную суммарную общительность всех групп.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "Для каждого такого числа нужно найти максимальное ai, такое, что ai < x. Ограничения на числа позволяют сделать это за O(1) при помощи массива.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 14",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 15",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 16",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random values between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"all_max\") {\n        // All elements are maximum value 1e6\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000;\n        }\n    } else if (type == \"all_min\") {\n        // All elements are minimum value 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"duplicates\") {\n        // All elements are the same random value\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        // Elements are in increasing order\n        a[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; ++i) {\n            a[i] = min(a[i-1] + rnd.next(0, 10), 1000000);\n        }\n    } else if (type == \"decreasing\") {\n        // Elements are in decreasing order\n        a[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; ++i) {\n            a[i] = max(a[i-1] - rnd.next(0, 10), 1);\n        }\n    } else if (type == \"powers_of_two\") {\n        // Elements are powers of two\n        for (int i = 0; i < n; ++i) {\n            int p = rnd.next(0, 19);\n            a[i] = 1 << p;\n        }\n    } else if (type == \"max_min_mix\") {\n        // Mix of maximum and minimum values\n        for (int i = 0; i < n; ++i) {\n            a[i] = (rnd.next(0, 1) ? 1 : 1000000);\n        }\n    } else if (type == \"consecutive\") {\n        // Elements are consecutive integers\n        int start = rnd.next(1, 1000000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random values between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"all_max\") {\n        // All elements are maximum value 1e6\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000;\n        }\n    } else if (type == \"all_min\") {\n        // All elements are minimum value 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"duplicates\") {\n        // All elements are the same random value\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        // Elements are in increasing order\n        a[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; ++i) {\n            a[i] = min(a[i-1] + rnd.next(0, 10), 1000000);\n        }\n    } else if (type == \"decreasing\") {\n        // Elements are in decreasing order\n        a[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; ++i) {\n            a[i] = max(a[i-1] - rnd.next(0, 10), 1);\n        }\n    } else if (type == \"powers_of_two\") {\n        // Elements are powers of two\n        for (int i = 0; i < n; ++i) {\n            int p = rnd.next(0, 19);\n            a[i] = 1 << p;\n        }\n    } else if (type == \"max_min_mix\") {\n        // Mix of maximum and minimum values\n        for (int i = 0; i < n; ++i) {\n            a[i] = (rnd.next(0, 1) ? 1 : 1000000);\n        }\n    } else if (type == \"consecutive\") {\n        // Elements are consecutive integers\n        int start = rnd.next(1, 1000000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 1 -type random\n./gen -n 1 -type all_max\n./gen -n 1 -type all_min\n./gen -n 1 -type duplicates\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n\n# Medium test cases\n./gen -n 10 -type random\n./gen -n 10 -type duplicates\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type powers_of_two\n./gen -n 10 -type max_min_mix\n./gen -n 10 -type consecutive\n\n# Large test cases\n./gen -n 100000 -type random\n./gen -n 100000 -type all_max\n./gen -n 100000 -type all_min\n./gen -n 100000 -type duplicates\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type powers_of_two\n./gen -n 100000 -type max_min_mix\n./gen -n 100000 -type consecutive\n\n# Maximum size test cases\n./gen -n 200000 -type random\n./gen -n 200000 -type duplicates\n./gen -n 200000 -type increasing\n./gen -n 200000 -type decreasing\n./gen -n 200000 -type powers_of_two\n./gen -n 200000 -type max_min_mix\n./gen -n 200000 -type consecutive\n\n# Edge case with all elements equal to 1\n./gen -n 200000 -type all_min\n\n# Edge case with all elements equal to maximum value\n./gen -n 200000 -type all_max\n\n# Mixed test cases\n./gen -n 200000 -type random\n./gen -n 200000 -type max_min_mix\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:06.982237",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "485/E",
      "title": "E. Strange Sorting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a non-empty string S of length n, consisting of lowercase and uppercase English letters and digits from 0 to 9. The second line of the input contains integer m – the number of shuffling operations (1 ≤ m·n ≤ 106). Following m lines contain the descriptions of the operations consisting of two integers k and d (1 ≤ d ≤ k ≤ n).",
      "output_spec": "OutputAfter each operation print the current state of string S.",
      "sample_tests": "ExamplesInputCopyqwerty34 26 35 2OutputCopyqertwyqtewryqetyrw",
      "description": "E. Strange Sorting\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains a non-empty string S of length n, consisting of lowercase and uppercase English letters and digits from 0 to 9. The second line of the input contains integer m – the number of shuffling operations (1 ≤ m·n ≤ 106). Following m lines contain the descriptions of the operations consisting of two integers k and d (1 ≤ d ≤ k ≤ n).\n\nOutputAfter each operation print the current state of string S.\n\nInputCopyqwerty34 26 35 2OutputCopyqertwyqtewryqetyrw\n\nInputCopyqwerty34 26 35 2\n\nOutputCopyqertwyqtewryqetyrw\n\nNoteHere is detailed explanation of the sample. The first modification is executed with arguments k = 4, d = 2. That means that you need to apply 2-sorting for each substring of length 4 one by one moving from the left to the right. The string will transform in the following manner:qwerty  →  qewrty  →  qerwty  →  qertwyThus, string S equals 'qertwy' at the end of first query.The second modification is executed with arguments k = 6, d = 3. As a result of this operation the whole string S is replaced by its 3-sorting: qertwy  →  qtewryThe third modification is executed with arguments k = 5, d = 2. qtewry  →  qertwy  →  qetyrw",
      "solutions": [
        {
          "title": "Codeforces Round #276 - Codeforces",
          "content": "Hello everybody!Today will be Codeforces Round #276, which take place in both divisions. Start time is 19:30 in moscow time (follow this link to see time in others zones). For preparing contest i say thanks to Zlobober, for translating to Delinur, and to MikeMirzayanov for project Codeforces.Good luck to all, hope you will enjoy problems :)UPD Score distribution will be dynamic (see more information here). Problems will be sorted in increasing order of difficulty, however, do not forget to read all problems before the end of the contest.UPD The contest is over! Thanks to everyone who solved the problems despite everything. Analysis will be published later.UPD Editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14591",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 696
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces",
          "content": "485A - FactoryProduction will stops iff exists integer K ≥ 0 such a·2K is divisible by m. From this fact follows that K maximum will be about O(log2(m)). So if we modeling some, for example, 20 days and production does not stop, then it will never stop and answer is \"No\". Otherwise answer is \"Yes\".485B - Valuable ResourcesLet us find minimum length needed to cover points by Ox. It is Maximum(xi) - Minumum(xi). The same in Oy — Maximum(yi) - Minumum(yi). Since we need a square city to cover all the mines, then we need to set length of this square to the maximum from those two values.484A - BitsLet us define function f(L, R), that gives answer to the query. It looks follows: if L = R then f(L, R) = L; else if 2b ≤ L, where b — maximum integer such 2b ≤ R, then f(L, R) = f(L - 2b, R - 2b) + 2b; else if 2b + 1 - 1 ≤ R then f(L, R) = 2b + 1 - 1; else f(L, R) = 2b - 1. Total complexity is O(logR) per query.484B - Maximum ValueLet us iterate over all different aj. Since we need to maximize , then iterate all integer x (such x divisible by aj) in range from 2aj to M, where M — doubled maximum value of the sequence. For each such x we need to find maximum ai, such ai < x. Limits for numbers allow to do this in time O(1) with an array. After that, update answer by value . Total time complexity is O(nlogn + MlogM).484C - Strange SortingNote, that d-sorting is just a permutation (call it P), because it does not depends on characters in string. Look at shuffling operation in different way: instead of going to the next substring and sort it, we will shift string to one character left. It remains to understand that shift of string the permutation too (call it C). Now its clear, we need to calculate S·P·C·P·C... = S·(P·C)n - k + 1. And after that shift string for k - 1 character to the left for making answer to the shuffling operation. Here we use the multiplication of permutations. Since they are associative, that we can use binary algorithm to calculate (P·C)n - k + 1. Total time complexity is O(nmlogn).484D - KindergartenLet us note, that in optimal answer any segment that making a group contains their minimum and maximum values on borders. Otherwise it will be better to split this segment to two other segments. Another note that is every segment in optimal solution is strictly monotonic (increasing or decreasing). Paying attention to the interesting points in sequence which making local maximums (i. e. ai - 1 < ai > ai + 1), local minimums (ai - 1 > ai < ai + 1), and point adjacent to them. Solve the problem by dynamic programming: Di is the answer in the prefix i. To calculate Di we need to look at no more than three previous interesting points and to previous Di - 1. Total time complexity is O(n).484E - Sign on FenceLet us note that we can use binary search to find answer to the one query. Suppose at some moment was fixed height h and need to know will fit the rectangle with width w and height h to the segment of fence from l-th to r-th panel. Let us build data structure that can answer to this question. This will be persistent segment tree with unusual function inside: maximum number of consecutive ones in segment (maxOnes). In leaves of segment tree will be only numbers 0 and 1. To calculate this function need to know some other values, specifically:len — length of the segment in vertex of segment tree, prefOnes — length of prefix that consists only of ones, sufOnes — length of the suffix consist only of ones.These functions are computed as follows:maxOnes is equal to max(maxOnes(Left), maxOnes(Right), sufOnes(Left) + prefOnes(Right));prefOnes equals prefOnes(Right) + len(Left) in case of len(Left) = prefOnes(Left), and prefOnes(Left) otherwise;sufOnes equals sufOnes(Left) + len(Right) in case of len(Right) = sufOnes(Right), and sufOnes(Right) otherwise;len = len(left) + len(Right);Left и Right — it is left and right sons of vertex in segment tree.As mentioned above, tree must be persistent, and it must be built as follows. First, builded empty tree of zeros. Next in position of highest plank need to put 1. The same doing for planks in decreasing order. For example if fence described with sequence [2, 5, 5, 1, 3] then bottom of segment tree will changed as follows:[0, 0, 0, 0, 0] -> [0, 1, 0, 0, 0] -> [0, 1, 1, 0, 0] -> [0, 1, 1, 0, 1] -> [1, 1, 1, 0, 1] -> [1, 1, 1, 1, 1].And we need to remember for all hi their version of tree. Now to answer the question we need to make query in our segment tree (that corresponding to height h) on segment [l, r]. If maxOnes form this query less than w, then rectangle impossible to put (otherwise possible).Building of tree will take O(nlogn) time and memory. Time complexity to the one query will take O(log2n) time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 485 和字母"
          },
          "content_length": 4729
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #276 - Codeforces - Code 1",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 2",
          "code": "foo() {\n    bar();\n}\nmain() {\n    for ( int i = 0; i < 10; ++i ) foo();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 3",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 4",
          "code": "main\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar\n\tfoo\n\t\tbar",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 5",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 6",
          "code": "A= 10 20 30 40\nB= 50 45 25 20\nSum= 60 65 55 60",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 7",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 8",
          "code": "x = -a[0];\ny = a[0];\nans = 0;\nfor (int i = 0; i < n; ++i){\n\tans = max(x + a[i], y - a[i]);\n\tx = max(x, ans - a[i + 1]);\n\ty = max(y, ans + a[i + 1]);\n}\ncout << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 9",
          "code": "huh!, Codeforces community is busy with up-voting instead helping the guy.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 10",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 - Codeforces - Code 11",
          "code": "Output\nqertwy\nqtewry\nqetyrw\nAnswer\nqertwy\nqtewry\nqetyrw\nChecker comment\nwrong answer 1st lines differ - expected: 'qertwy', found: 'qertwy'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14591",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 1",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 2",
          "code": "for each ai do\n   divide by 1,2,3.... and find the lower bound of the numbers in the Array.\n   update maximum accordingly",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 3",
          "code": "integer division",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 4",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 5",
          "code": "arr[0]!=arr[-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 6",
          "code": "i&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 7",
          "code": "0&&arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 8",
          "code": "arr[i]!=arr[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 9",
          "code": "if(i&&arr[i]!=arr[i-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 10",
          "code": "Production will stops iff exists integer K ≥ 0 such a*POW(2,K) is divisible by m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 11",
          "code": "index i stores element just smaller than i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 12",
          "code": "[-1,-1,-1,2,2,4,4,4,7,7,7,7,11...]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #276 — Editorial - Codeforces - Code 13",
          "code": "-1 means no element is smaller than i.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string S = inf.readLine(\"[a-zA-Z0-9]+\", \"S\");\n    int n = int(S.length());\n    ensuref(1 <= n && n <= 1000000, \"Length of S must be between 1 and 1e6, but was %d.\", n);\n\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    ensuref(1LL * m * n <= 1000000LL, \"Constraint m * n <= 1e6 violated: m = %d, n = %d, m * n = %lld.\", m, n, 1LL * m * n);\n\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, n, \"k\");\n        inf.readSpace();\n        int d = inf.readInt(1, k, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string S = inf.readLine(\"[a-zA-Z0-9]+\", \"S\");\n    int n = int(S.length());\n    ensuref(1 <= n && n <= 1000000, \"Length of S must be between 1 and 1e6, but was %d.\", n);\n\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    ensuref(1LL * m * n <= 1000000LL, \"Constraint m * n <= 1e6 violated: m = %d, n = %d, m * n = %lld.\", m, n, 1LL * m * n);\n\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, n, \"k\");\n        inf.readSpace();\n        int d = inf.readInt(1, k, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string S = inf.readLine(\"[a-zA-Z0-9]+\", \"S\");\n    int n = int(S.length());\n    ensuref(1 <= n && n <= 1000000, \"Length of S must be between 1 and 1e6, but was %d.\", n);\n\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    ensuref(1LL * m * n <= 1000000LL, \"Constraint m * n <= 1e6 violated: m = %d, n = %d, m * n = %lld.\", m, n, 1LL * m * n);\n\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, n, \"k\");\n        inf.readSpace();\n        int d = inf.readInt(1, k, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string string_type = opt<string>(\"string_type\", \"random\");\n    string ops_type = opt<string>(\"ops_type\", \"random\");\n\n    // Ensure that m * n <= 1e6\n    assert(1LL * m * n <= 1000000);\n\n    string allowed_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    string S;\n\n    if (string_type == \"random\") {\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[rnd.next(allowed_chars.size())];\n        }\n    } else if (string_type == \"same_char\") {\n        char c = allowed_chars[rnd.next(allowed_chars.size())];\n        S = string(n, c);\n    } else if (string_type == \"all_chars\") {\n        // Use all allowed characters, repeating if necessary\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[i % allowed_chars.size()];\n        }\n    } else if (string_type == \"increasing_chars\") {\n        // Characters in increasing order\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[i % allowed_chars.size()];\n        }\n    } else if (string_type == \"decreasing_chars\") {\n        // Characters in decreasing order\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[(allowed_chars.size() - 1) - (i % allowed_chars.size())];\n        }\n    } else {\n        // Default to random\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[rnd.next(allowed_chars.size())];\n        }\n    }\n\n    cout << S << endl;\n    cout << m << endl;\n\n    if (ops_type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = rnd.next(1, k);\n            cout << k << \" \" << d << endl;\n        }\n    } else if (ops_type == \"fixed_d\") {\n        int fixed_d = opt<int>(\"d\");\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(fixed_d, n);\n            int d = fixed_d;\n            cout << k << \" \" << d << endl;\n        }\n    } else if (ops_type == \"d_equals_1\") {\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = 1;\n            cout << k << \" \" << d << endl;\n        }\n    } else if (ops_type == \"d_equals_k\") {\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = k;\n            cout << k << \" \" << d << endl;\n        }\n    } else if (ops_type == \"k_equals_n\") {\n        for(int i = 0; i < m; ++i) {\n            int k = n;\n            int d = rnd.next(1, k);\n            cout << k << \" \" << d << endl;\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = rnd.next(1, k);\n            cout << k << \" \" << d << endl;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string string_type = opt<string>(\"string_type\", \"random\");\n    string ops_type = opt<string>(\"ops_type\", \"random\");\n\n    // Ensure that m * n <= 1e6\n    assert(1LL * m * n <= 1000000);\n\n    string allowed_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    string S;\n\n    if (string_type == \"random\") {\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[rnd.next(allowed_chars.size())];\n        }\n    } else if (string_type == \"same_char\") {\n        char c = allowed_chars[rnd.next(allowed_chars.size())];\n        S = string(n, c);\n    } else if (string_type == \"all_chars\") {\n        // Use all allowed characters, repeating if necessary\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[i % allowed_chars.size()];\n        }\n    } else if (string_type == \"increasing_chars\") {\n        // Characters in increasing order\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[i % allowed_chars.size()];\n        }\n    } else if (string_type == \"decreasing_chars\") {\n        // Characters in decreasing order\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[(allowed_chars.size() - 1) - (i % allowed_chars.size())];\n        }\n    } else {\n        // Default to random\n        S.resize(n);\n        for(int i = 0; i < n; ++i) {\n            S[i] = allowed_chars[rnd.next(allowed_chars.size())];\n        }\n    }\n\n    cout << S << endl;\n    cout << m << endl;\n\n    if (ops_type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = rnd.next(1, k);\n            cout << k << \" \" << d << endl;\n        }\n    } else if (ops_type == \"fixed_d\") {\n        int fixed_d = opt<int>(\"d\");\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(fixed_d, n);\n            int d = fixed_d;\n            cout << k << \" \" << d << endl;\n        }\n    } else if (ops_type == \"d_equals_1\") {\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = 1;\n            cout << k << \" \" << d << endl;\n        }\n    } else if (ops_type == \"d_equals_k\") {\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = k;\n            cout << k << \" \" << d << endl;\n        }\n    } else if (ops_type == \"k_equals_n\") {\n        for(int i = 0; i < m; ++i) {\n            int k = n;\n            int d = rnd.next(1, k);\n            cout << k << \" \" << d << endl;\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            int d = rnd.next(1, k);\n            cout << k << \" \" << d << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test 1: Minimal n and m\n./gen -n 1 -m 1 -string_type same_char -ops_type fixed_d -d 1\n\n# Test 2: Maximal n, minimal m\n./gen -n 1000000 -m 1 -string_type random -ops_type random\n\n# Test 3: Medium n, large m\n./gen -n 1000 -m 1000 -string_type random -ops_type random\n\n# Test 4: n = 1000, m = 1000, string with all identical chars\n./gen -n 1000 -m 1000 -string_type same_char -ops_type random\n\n# Test 5: n = 62, string with all possible chars\n./gen -n 62 -m 1000 -string_type all_chars -ops_type random\n\n# Test 6: n = 62, m = 1000, increasing_chars\n./gen -n 62 -m 1000 -string_type increasing_chars -ops_type random\n\n# Test 7: n = 62, m = 1000, decreasing_chars\n./gen -n 62 -m 1000 -string_type decreasing_chars -ops_type random\n\n# Test 8: n = 1000000, m = 1, ops_type d_equals_1\n./gen -n 1000000 -m 1 -string_type random -ops_type d_equals_1\n\n# Test 9: n = 1000000, m = 1, ops_type d_equals_k\n./gen -n 1000000 -m 1 -string_type random -ops_type d_equals_k\n\n# Test 10: n = 1000000, m = 1, ops_type k_equals_n\n./gen -n 1000000 -m 1 -string_type random -ops_type k_equals_n\n\n# Test 11: n = 100, m = 10000, maximize m\n./gen -n 100 -m 10000 -string_type random -ops_type random\n\n# Test 12: n = 1000, m = 1000, d = 1\n./gen -n 1000 -m 1000 -string_type random -ops_type d_equals_1\n\n# Test 13: n = 1000, m = 1000, d = k\n./gen -n 1000 -m 1000 -string_type random -ops_type d_equals_k\n\n# Test 14: n = 1000, m = 1000, k = n\n./gen -n 1000 -m 1000 -string_type random -ops_type k_equals_n\n\n# Test 15: n = 10000, m = 100, random\n./gen -n 10000 -m 100 -string_type random -ops_type random\n\n# Test 16: n = 10000, m = 100, string with same_char\n./gen -n 10000 -m 100 -string_type same_char -ops_type random\n\n# Test 17: n = 100000, m = 10\n./gen -n 100000 -m 10 -string_type random -ops_type random\n\n# Test 18: n = 1000000, m = 1, string with same_char\n./gen -n 1000000 -m 1 -string_type same_char -ops_type random\n\n# Test 19: n = 999999, m = 1\n./gen -n 999999 -m 1 -string_type random -ops_type random\n\n# Test 20: n = 1000, m = 1000, ops_type fixed_d, d = 2\n./gen -n 1000 -m 1000 -string_type random -ops_type fixed_d -d 2\n\n# Test 21: n = 1000, m = 1000, ops_type fixed_d, d = 500\n./gen -n 1000 -m 1000 -string_type random -ops_type fixed_d -d 500\n\n# Test 22: n = 5000, m = 200, ops_type fixed_d, d = 1\n./gen -n 5000 -m 200 -string_type random -ops_type fixed_d -d 1\n\n# Test 23: n = 5000, m = 200, ops_type fixed_d, d = n\n./gen -n 5000 -m 200 -string_type random -ops_type fixed_d -d 5000\n\n# Test 24: n = 2, m = 500000, ops_type random\n./gen -n 2 -m 500000 -string_type random -ops_type random\n\n# Test 25: n = 1000000, m = 1, ops_type fixed_d, d = 1000000\n./gen -n 1000000 -m 1 -string_type random -ops_type fixed_d -d 1000000\n\n# Test 26: n = 1000, m = 1000, random ops\n./gen -n 1000 -m 1000 -string_type random -ops_type random\n\n# Test 27: n = 1000000, m = 1, string with increasing_chars\n./gen -n 1000000 -m 1 -string_type increasing_chars -ops_type random\n\n# Test 28: n = 1000000, m = 1, string with decreasing_chars\n./gen -n 1000000 -m 1 -string_type decreasing_chars -ops_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:08.754541",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "486/A",
      "title": "A. Подсчёт функции",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано положительное целое число n (1 ≤ n ≤ 1015).",
      "output_spec": "Выходные данныеВыведите f(n) в единственной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать4Выходные данныеСкопировать2Входные данныеСкопировать5Выходные данныеСкопировать-3",
      "description": "A. Подсчёт функции\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано положительное целое число n (1 ≤ n ≤ 1015).\n\nВходные данные\n\nВыходные данныеВыведите f(n) в единственной строке.\n\nВыходные данные\n\nВходные данныеСкопировать4Выходные данныеСкопировать2Входные данныеСкопировать5Выходные данныеСкопировать-3\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеf(4) =  - 1 + 2 - 3 + 4 = 2f(5) =  - 1 + 2 - 3 + 4 - 5 =  - 3",
      "solutions": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces",
          "content": "Hello everyone!Today, there will be another CodeForces Round at 18:00 (Moscow time). It is a Div. 2 contest, but Div. 1 participants can take part out of competition also.My name is Vuong and this is my very first CodeForces round. Hope that this is not the last one. I would like to thanks Maxim Akhmedov(Zlobober) for help me preparing the round, Maria Belova(Delinur) for translating problems into English, and Mike Mirzayanov(MikeMirzayanov) for such a great Polygon and CodeForces.Be sure to read all problem statements before contest ended. Hope you enjoy the contest. Good luck and have fun!UPD The contest is over! Thanks all of you for participating!Here is top 5 participants: khykhm110 My_First_Lady Perditio AkatsukiPain s_z_l The editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces",
          "content": "486A - Calculating FunctionIf n is even, then the answer is n / 2, otherwise the answer is (n - 1) / 2 - n =  - (n + 1) / 2.486B - OR in MatrixHint of this problem is presented in its statement. \" where is equal to 1 if some ai = 1, otherwise it is equal to 0.\"To solve this problem, do 3 following steps: Assign all aij (1 ≤ i ≤ m, 1 ≤ j ≤ n) equals to 1. If some bij = 0, then do assignments: aik = atj = 0 (1 ≤ k ≤ n, 1 ≤ t ≤ m) (that means, assign all elements in row i and column j of matrix a to 0). Then we have matrix a which need to find. Just check whether from matrix a, can we produce matrix b. If not, the answer is obviously \"NO\". Complexity: We can implement this algorithm in O(m * n), but it's not neccesary since 1 ≤ m, n ≤ 100.486C - Palindrome TransformationAssuming that cursor's position is in the first half of string(i.e 1 ≤ p ≤ n / 2) (if it's not, just reverse the string, and change p to n - p + 1, then the answer will not change).It is not hard to see that, in optimal solution, we only need to move our cusor in the first half of the string only, and the number of \"turn\" is at most once. Therefore, we have below algorithm: Find the largest index r before p in the first half of the string (p ≤ r ≤ n / 2) such that sr different to sn - r + 1. (si denote ith character of our input string s) Find the smallest index l after p (1 ≤ l ≤ p) such that sl different to sn - l + 1. In optimal solution, we move our cusor from p to l and then from l to r, or move from p to r and then from r to l. While moving, we also change character of string simultaneously (if needed) (by press up/down arrow keys). Be careful with some corner case(for example, does'nt exist such l or r discribed above).Complexity: O(n).486D - Valid Sets Firstly, we solve the case d =  + ∞. In this case, we can forget all ai since they doesn't play a role anymore. Consider the tree is rooted at node 1. Let Fi be the number of valid sets contain node i and several other nodes in subtree of i (\"several\" here means 0 or more). We can easily calculate Fi through Fj where j is directed child node of i: . Complexity: O(n). General case: d ≥ 0. For each node i, we count the number of valid sets contain node i and some other node j such that ai ≤ aj ≤ ai + d (that means, node i have the smallest value a in the set). How? Start DFS from node i, visit only nodes j such that ai ≤ aj ≤ ai + d. Then all nodes have visited form another tree. Just apply case d =  + ∞ for this new tree. We have to count n times, each time take O(n), so the overall complexity is O(n2). (Be craeful with duplicate counting) Here is my code.486E - LIS of SequenceLIS = Longest increasing subsequence.Solution 1 (Most of participant's solutions): Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai} and D1i is the number of such that LIS. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an} and D2i is the number of such that LIS. // Calculates F1i and F2i is familiar task, so I will not dig into this. For those who have'nt known it yet, this link may be useful) // We can calculate D1i and D2i by using advanced data structure, like BIT or Segment tree. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. m = number of LIS of {a1, a2, ..., an} = Let Ci be the number of LIS of {a1, a2, ..., an} that ai belongs to. Index i must in group:1) if Ci = 02) if 0 ≤ Ci < m3) if Ci = m How to calculate Ci? If (F1i + F2i - 1 < l) then Ci = 0, else Ci = D1i * D2i. Done! We have an additional issue. The number of LIS of {a1, a2, ..., an} maybe very large! D1i, D2i and m maybe exceed 64-bits integer. Hence, we need to store D1i, D2i and m after modulo some integer number, call it p.Usually, we will choose p is a prime, like 109 + 7 or 109 + 9. It's not hard to generate a test such that if you choose p = 109 + 7 or p = 109 + 9, your solution will lead to Wrong answer. But I have romeved such that tests, because the data tests is weak, even p is not a prime can pass all tests.Solution 2:// Some notation is re-defined. Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai}. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an}. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. Let Fi be the length of LIS of sequence {a1, a2, ..., ai - 1, ai + 1, ..., an} (i.e the length of LIS of initial sequence a after removing element ai). Index i must in group:1) if F1i + F2i - 1 < l, otherwise:2) if Fi = l3) if Fi = l - 1 How to caculate Fi? We have: Fi = max{F1u + F2v} among 1 ≤ u < i < v ≤ n such that au < av. From this formula, we can use Segment tree to calculate Fi. Due to limitation of my English, it is really hard to write exactly how. I will post my code soon. Complexity of both above solution: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14678",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 486\\s*A"
          },
          "content_length": 4836
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 1",
          "code": "right - pos + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 2",
          "code": "pos - left + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 3",
          "code": "min(abs(s[i] - s[n - i - 1]), 26 - abs(s[i] - s[n - i - 1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 4",
          "code": "min(abs(right-pos)+right-left,abs(pos-left)+right-left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 5",
          "code": "min(r-p,p-l) * 2 + max(r-p,p-l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 6",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 7",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 8",
          "code": "double pow (double base, double exponent);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 9",
          "code": "j=pow((i+1),2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 10",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 11",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 12",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 13",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 1",
          "code": "F(i) will be 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 2",
          "code": "(0,1,2....F(j))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 3",
          "code": "F(i) = prod(F(j)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 4",
          "code": "D-Valid Sets",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 1000000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 1000000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 1000000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long n_max = opt<long long>(\"maxn\", 1000000000000000LL);\n\n    if (type == \"min\") {\n        printf(\"1\\n\");\n    } else if (type == \"max\") {\n        printf(\"%lld\\n\", n_max);\n    } else if (type == \"small\") {\n        int n = rnd.next(1, 20);\n        printf(\"%d\\n\", n);\n    } else if (type == \"random\") {\n        long long n = rnd.next(1LL, n_max);\n        printf(\"%lld\\n\", n);\n    } else if (type == \"power2\") {\n        int k_min = 1;\n        int k_max = 50;\n        int k = rnd.next(k_min, k_max);\n        long long base = (1LL << k);\n        long long n = base + rnd.next(-1LL, 1LL);\n        if (n < 1LL) n = 1LL;\n        if (n > n_max) n = n_max;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"nearDivisionBoundary\") {\n        long long d = rnd.next(-2LL, 2LL);\n        long long n = n_max / 2 + d;\n        if (n < 1LL) n = 1LL;\n        if (n > n_max) n = n_max;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"intOverflow\") {\n        long long min_n = (1LL << 31) - 5;\n        long long max_n = (1LL << 31) + 5;\n        if (min_n < 1LL) min_n = 1LL;\n        if (max_n > n_max) max_n = n_max;\n        long long n = rnd.next(min_n, max_n);\n        printf(\"%lld\\n\", n);\n    } else {\n        // Default: random\n        long long n = rnd.next(1LL, n_max);\n        printf(\"%lld\\n\", n);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long n_max = opt<long long>(\"maxn\", 1000000000000000LL);\n\n    if (type == \"min\") {\n        printf(\"1\\n\");\n    } else if (type == \"max\") {\n        printf(\"%lld\\n\", n_max);\n    } else if (type == \"small\") {\n        int n = rnd.next(1, 20);\n        printf(\"%d\\n\", n);\n    } else if (type == \"random\") {\n        long long n = rnd.next(1LL, n_max);\n        printf(\"%lld\\n\", n);\n    } else if (type == \"power2\") {\n        int k_min = 1;\n        int k_max = 50;\n        int k = rnd.next(k_min, k_max);\n        long long base = (1LL << k);\n        long long n = base + rnd.next(-1LL, 1LL);\n        if (n < 1LL) n = 1LL;\n        if (n > n_max) n = n_max;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"nearDivisionBoundary\") {\n        long long d = rnd.next(-2LL, 2LL);\n        long long n = n_max / 2 + d;\n        if (n < 1LL) n = 1LL;\n        if (n > n_max) n = n_max;\n        printf(\"%lld\\n\", n);\n    } else if (type == \"intOverflow\") {\n        long long min_n = (1LL << 31) - 5;\n        long long max_n = (1LL << 31) + 5;\n        if (min_n < 1LL) min_n = 1LL;\n        if (max_n > n_max) max_n = n_max;\n        long long n = rnd.next(min_n, max_n);\n        printf(\"%lld\\n\", n);\n    } else {\n        // Default: random\n        long long n = rnd.next(1LL, n_max);\n        printf(\"%lld\\n\", n);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case with minimum input\n./gen -type min\n\n# Test cases with small n\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Test cases with random n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Test cases with n near powers of 2\n./gen -type power2\n./gen -type power2\n./gen -type power2\n./gen -type power2\n./gen -type power2\n\n# Test cases with n near integer division boundaries\n./gen -type nearDivisionBoundary\n./gen -type nearDivisionBoundary\n./gen -type nearDivisionBoundary\n./gen -type nearDivisionBoundary\n./gen -type nearDivisionBoundary\n\n# Test cases to check for 32-bit integer overflows\n./gen -type intOverflow\n./gen -type intOverflow\n./gen -type intOverflow\n\n# Test case with maximum n\n./gen -type max\n\n# Additional test cases with custom maxn values\n./gen -type random -maxn 1000\n./gen -type random -maxn 1000000\n./gen -type random -maxn 1000000000\n\n# Test cases with n near maximum value\n./gen -type random -maxn 1000000000000000\n\n# Test cases with default settings (random n)\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:10.768405",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "486/B",
      "title": "B. OR in Matrix",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integer m and n (1 ≤ m, n ≤ 100), number of rows and number of columns of matrices respectively.The next m lines each contain n integers separated by spaces describing rows of matrix B (each element of B is either 0 or 1).",
      "output_spec": "OutputIn the first line, print \"NO\" if Nam has made a mistake when calculating B, otherwise print \"YES\". If the first line is \"YES\", then also print m rows consisting of n integers representing matrix A that can produce given matrix B. If there are several solutions print any one.",
      "sample_tests": "ExamplesInputCopy2 21 00 0OutputCopyNOInputCopy2 31 1 11 1 1OutputCopyYES1 1 11 1 1InputCopy2 30 1 01 1 1OutputCopyYES0 0 00 1 0",
      "description": "B. OR in Matrix\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integer m and n (1 ≤ m, n ≤ 100), number of rows and number of columns of matrices respectively.The next m lines each contain n integers separated by spaces describing rows of matrix B (each element of B is either 0 or 1).\n\nOutputIn the first line, print \"NO\" if Nam has made a mistake when calculating B, otherwise print \"YES\". If the first line is \"YES\", then also print m rows consisting of n integers representing matrix A that can produce given matrix B. If there are several solutions print any one.\n\nInputCopy2 21 00 0OutputCopyNOInputCopy2 31 1 11 1 1OutputCopyYES1 1 11 1 1InputCopy2 30 1 01 1 1OutputCopyYES0 0 00 1 0\n\nInputCopy2 21 00 0\n\nOutputCopyNO\n\nInputCopy2 31 1 11 1 1\n\nOutputCopyYES1 1 11 1 1\n\nInputCopy2 30 1 01 1 1\n\nOutputCopyYES0 0 00 1 0",
      "solutions": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces",
          "content": "Hello everyone!Today, there will be another CodeForces Round at 18:00 (Moscow time). It is a Div. 2 contest, but Div. 1 participants can take part out of competition also.My name is Vuong and this is my very first CodeForces round. Hope that this is not the last one. I would like to thanks Maxim Akhmedov(Zlobober) for help me preparing the round, Maria Belova(Delinur) for translating problems into English, and Mike Mirzayanov(MikeMirzayanov) for such a great Polygon and CodeForces.Be sure to read all problem statements before contest ended. Hope you enjoy the contest. Good luck and have fun!UPD The contest is over! Thanks all of you for participating!Here is top 5 participants: khykhm110 My_First_Lady Perditio AkatsukiPain s_z_l The editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces",
          "content": "486A - Calculating FunctionIf n is even, then the answer is n / 2, otherwise the answer is (n - 1) / 2 - n =  - (n + 1) / 2.486B - OR in MatrixHint of this problem is presented in its statement. \" where is equal to 1 if some ai = 1, otherwise it is equal to 0.\"To solve this problem, do 3 following steps: Assign all aij (1 ≤ i ≤ m, 1 ≤ j ≤ n) equals to 1. If some bij = 0, then do assignments: aik = atj = 0 (1 ≤ k ≤ n, 1 ≤ t ≤ m) (that means, assign all elements in row i and column j of matrix a to 0). Then we have matrix a which need to find. Just check whether from matrix a, can we produce matrix b. If not, the answer is obviously \"NO\". Complexity: We can implement this algorithm in O(m * n), but it's not neccesary since 1 ≤ m, n ≤ 100.486C - Palindrome TransformationAssuming that cursor's position is in the first half of string(i.e 1 ≤ p ≤ n / 2) (if it's not, just reverse the string, and change p to n - p + 1, then the answer will not change).It is not hard to see that, in optimal solution, we only need to move our cusor in the first half of the string only, and the number of \"turn\" is at most once. Therefore, we have below algorithm: Find the largest index r before p in the first half of the string (p ≤ r ≤ n / 2) such that sr different to sn - r + 1. (si denote ith character of our input string s) Find the smallest index l after p (1 ≤ l ≤ p) such that sl different to sn - l + 1. In optimal solution, we move our cusor from p to l and then from l to r, or move from p to r and then from r to l. While moving, we also change character of string simultaneously (if needed) (by press up/down arrow keys). Be careful with some corner case(for example, does'nt exist such l or r discribed above).Complexity: O(n).486D - Valid Sets Firstly, we solve the case d =  + ∞. In this case, we can forget all ai since they doesn't play a role anymore. Consider the tree is rooted at node 1. Let Fi be the number of valid sets contain node i and several other nodes in subtree of i (\"several\" here means 0 or more). We can easily calculate Fi through Fj where j is directed child node of i: . Complexity: O(n). General case: d ≥ 0. For each node i, we count the number of valid sets contain node i and some other node j such that ai ≤ aj ≤ ai + d (that means, node i have the smallest value a in the set). How? Start DFS from node i, visit only nodes j such that ai ≤ aj ≤ ai + d. Then all nodes have visited form another tree. Just apply case d =  + ∞ for this new tree. We have to count n times, each time take O(n), so the overall complexity is O(n2). (Be craeful with duplicate counting) Here is my code.486E - LIS of SequenceLIS = Longest increasing subsequence.Solution 1 (Most of participant's solutions): Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai} and D1i is the number of such that LIS. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an} and D2i is the number of such that LIS. // Calculates F1i and F2i is familiar task, so I will not dig into this. For those who have'nt known it yet, this link may be useful) // We can calculate D1i and D2i by using advanced data structure, like BIT or Segment tree. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. m = number of LIS of {a1, a2, ..., an} = Let Ci be the number of LIS of {a1, a2, ..., an} that ai belongs to. Index i must in group:1) if Ci = 02) if 0 ≤ Ci < m3) if Ci = m How to calculate Ci? If (F1i + F2i - 1 < l) then Ci = 0, else Ci = D1i * D2i. Done! We have an additional issue. The number of LIS of {a1, a2, ..., an} maybe very large! D1i, D2i and m maybe exceed 64-bits integer. Hence, we need to store D1i, D2i and m after modulo some integer number, call it p.Usually, we will choose p is a prime, like 109 + 7 or 109 + 9. It's not hard to generate a test such that if you choose p = 109 + 7 or p = 109 + 9, your solution will lead to Wrong answer. But I have romeved such that tests, because the data tests is weak, even p is not a prime can pass all tests.Solution 2:// Some notation is re-defined. Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai}. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an}. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. Let Fi be the length of LIS of sequence {a1, a2, ..., ai - 1, ai + 1, ..., an} (i.e the length of LIS of initial sequence a after removing element ai). Index i must in group:1) if F1i + F2i - 1 < l, otherwise:2) if Fi = l3) if Fi = l - 1 How to caculate Fi? We have: Fi = max{F1u + F2v} among 1 ≤ u < i < v ≤ n such that au < av. From this formula, we can use Segment tree to calculate Fi. Due to limitation of my English, it is really hard to write exactly how. I will post my code soon. Complexity of both above solution: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14678",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 486\\s*B"
          },
          "content_length": 4836
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 1",
          "code": "right - pos + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 2",
          "code": "pos - left + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 3",
          "code": "min(abs(s[i] - s[n - i - 1]), 26 - abs(s[i] - s[n - i - 1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 4",
          "code": "min(abs(right-pos)+right-left,abs(pos-left)+right-left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 5",
          "code": "min(r-p,p-l) * 2 + max(r-p,p-l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 6",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 7",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 8",
          "code": "double pow (double base, double exponent);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 9",
          "code": "j=pow((i+1),2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 10",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 11",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 12",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 13",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 1",
          "code": "F(i) will be 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 2",
          "code": "(0,1,2....F(j))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 3",
          "code": "F(i) = prod(F(j)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 4",
          "code": "D-Valid Sets",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        vector<int> row = inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        vector<int> row = inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        vector<int> row = inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <vector>\nusing namespace std;\n\nconst int MAX = 105;\n\nint m, n;\nint B_input[MAX][MAX];\nint A_candidate[MAX][MAX];\nint B_checker[MAX][MAX];\nint sum_row[MAX];\nint sum_col[MAX];\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    m = inf.readInt(1, 100, \"m\");\n    n = inf.readInt(1, 100, \"n\");\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            B_input[i][j] = inf.readInt(0, 1, format(\"B[%d][%d]\", i, j).c_str());\n        }\n    }\n\n    // Build A_candidate\n    for (int i = 1; i <= m; i++)\n        for (int j = 1; j <= n; j++)\n            A_candidate[i][j] = 1;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (B_input[i][j] == 0) {\n                // Set all elements in row i and column j to 0\n                for (int k = 1; k <= n; k++)\n                    A_candidate[i][k] = 0;\n                for (int k = 1; k <= m; k++)\n                    A_candidate[k][j] = 0;\n            }\n        }\n    }\n\n    // Compute sum_row and sum_col\n    for (int i = 1; i <= m; i++) {\n        sum_row[i] = 0;\n        for (int k = 1; k <= n; k++)\n            sum_row[i] |= A_candidate[i][k];\n    }\n    for (int j = 1; j <= n; j++) {\n        sum_col[j] = 0;\n        for (int k = 1; k <= m; k++)\n            sum_col[j] |= A_candidate[k][j];\n    }\n\n    // Compute B_checker\n    bool valid = true;\n    for (int i = 1; i <= m && valid; i++) {\n        for (int j = 1; j <= n; j++) {\n            B_checker[i][j] = sum_row[i] | sum_col[j];\n            if (B_checker[i][j] != B_input[i][j]) {\n                valid = false;\n                break;\n            }\n        }\n    }\n\n    // Read contestant's output from ouf\n    string verdict = ouf.readToken();\n    if (verdict != \"YES\" && verdict != \"NO\") {\n        quitf(_pe, \"First line should be 'YES' or 'NO', found '%s'\", verdict.c_str());\n    }\n\n    if (verdict == \"YES\") {\n        if (!valid) {\n            quitf(_wa, \"Contestant output 'YES' but no valid matrix A exists\");\n        }\n        int A_contestant[MAX][MAX];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                A_contestant[i][j] = ouf.readInt(0, 1, format(\"A[%d][%d]\", i, j).c_str());\n            }\n        }\n        // Compute sum_row and sum_col for contestant's A\n        for (int i = 1; i <= m; i++) {\n            sum_row[i] = 0;\n            for (int k = 1; k <= n; k++)\n                sum_row[i] |= A_contestant[i][k];\n        }\n        for (int j = 1; j <= n; j++) {\n            sum_col[j] = 0;\n            for (int k = 1; k <= m; k++)\n                sum_col[j] |= A_contestant[k][j];\n        }\n        // Compute B_contestant\n        bool contestant_valid = true;\n        for (int i = 1; i <= m && contestant_valid; i++) {\n            for (int j = 1; j <= n; j++) {\n                int B_contestant = sum_row[i] | sum_col[j];\n                if (B_contestant != B_input[i][j]) {\n                    contestant_valid = false;\n                    break;\n                }\n            }\n        }\n        if (!contestant_valid) {\n            quitf(_wa, \"Contestant's matrix A does not produce the given B\");\n        }\n        quitf(_ok, \"Correct solution\");\n    } else { // verdict == \"NO\"\n        if (valid) {\n            quitf(_wa, \"Contestant output 'NO' but a valid matrix A exists\");\n        } else {\n            quitf(_ok, \"Correctly determined that no valid matrix A exists\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    // Ensure m and n are within the constraints\n    ensure(1 <= m && m <= 100);\n    ensure(1 <= n && n <= 100);\n\n    vector<vector<int>> A(m, vector<int>(n));\n    vector<vector<int>> B(m, vector<int>(n));\n\n    if (type == \"all_zeros\") {\n        // B is all zeros\n        B.assign(m, vector<int>(n, 0));\n\n    } else if (type == \"all_ones\") {\n        // B is all ones\n        B.assign(m, vector<int>(n, 1));\n\n    } else if (type == \"random_valid\") {\n        // Generate a random A and compute B from A\n        A.assign(m, vector<int>(n));\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(0, 1);\n\n        // Compute row-wise and column-wise OR for A\n        vector<int> row_or(m, 0), col_or(n, 0);\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                row_or[i] |= A[i][j];\n        for (int j = 0; j < n; ++j)\n            for (int i = 0; i < m; ++i)\n                col_or[j] |= A[i][j];\n\n        // Compute B from A\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                B[i][j] = row_or[i] | col_or[j];\n\n    } else if (type == \"random_invalid\") {\n        // Generate a B such that no valid A exists\n        B.assign(m, vector<int>(n, 0));\n        int num_conflicts = rnd.next(1, max(1, m * n / 10));\n        for (int k = 0; k < num_conflicts; ++k) {\n            int i = rnd.next(0, m - 1);\n            int j = rnd.next(0, n - 1);\n            B[i][j] = 1;\n            // Ensure that all other elements in row i and column j are zeros\n            for (int t = 0; t < n; ++t)\n                if (t != j)\n                    B[i][t] = 0;\n            for (int t = 0; t < m; ++t)\n                if (t != i)\n                    B[t][j] = 0;\n        }\n\n    } else if (type == \"checkerboard\") {\n        // B is a checkerboard pattern\n        B.assign(m, vector<int>(n, 0));\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                B[i][j] = (i + j) % 2;\n\n    } else if (type == \"custom_invalid\") {\n        // Specific invalid B with a single '1' and rest '0's\n        B.assign(m, vector<int>(n, 0));\n        int i = rnd.next(0, m - 1);\n        int j = rnd.next(0, n - 1);\n        B[i][j] = 1;\n        // Ensure that all other elements in row i and column j are zeros\n        for (int t = 0; t < n; ++t)\n            if (t != j)\n                B[i][t] = 0;\n        for (int t = 0; t < m; ++t)\n            if (t != i)\n                B[t][j] = 0;\n\n    } else if (type == \"single_row_ones\") {\n        // B has ones in a single row, zeros elsewhere\n        B.assign(m, vector<int>(n, 0));\n        int i = rnd.next(0, m - 1);\n        for (int j = 0; j < n; ++j)\n            B[i][j] = 1;\n\n    } else if (type == \"single_column_ones\") {\n        // B has ones in a single column, zeros elsewhere\n        B.assign(m, vector<int>(n, 0));\n        int j = rnd.next(0, n - 1);\n        for (int i = 0; i < m; ++i)\n            B[i][j] = 1;\n\n    } else if (type == \"random_sparse_valid\") {\n        // Generate a sparse A and compute B\n        A.assign(m, vector<int>(n, 0));\n        int num_ones = rnd.next(1, max(1, m * n / 10));\n        for (int k = 0; k < num_ones; ++k) {\n            int i = rnd.next(0, m - 1);\n            int j = rnd.next(0, n - 1);\n            A[i][j] = 1;\n        }\n        // Compute row-wise and column-wise OR for A\n        vector<int> row_or(m, 0), col_or(n, 0);\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                row_or[i] |= A[i][j];\n        for (int j = 0; j < n; ++j)\n            for (int i = 0; i < m; ++i)\n                col_or[j] |= A[i][j];\n        // Compute B from A\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                B[i][j] = row_or[i] | col_or[j];\n\n    } else {\n        // If type is not recognized, default to random_valid\n        // Generate a random A and compute B from A\n        A.assign(m, vector<int>(n));\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(0, 1);\n\n        // Compute row-wise and column-wise OR for A\n        vector<int> row_or(m, 0), col_or(n, 0);\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                row_or[i] |= A[i][j];\n        for (int j = 0; j < n; ++j)\n            for (int i = 0; i < m; ++i)\n                col_or[j] |= A[i][j];\n\n        // Compute B from A\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                B[i][j] = row_or[i] | col_or[j];\n    }\n\n    // Output m and n\n    printf(\"%d %d\\n\", m, n);\n\n    // Output matrix B\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (j > 0) printf(\" \");\n            printf(\"%d\", B[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    // Ensure m and n are within the constraints\n    ensure(1 <= m && m <= 100);\n    ensure(1 <= n && n <= 100);\n\n    vector<vector<int>> A(m, vector<int>(n));\n    vector<vector<int>> B(m, vector<int>(n));\n\n    if (type == \"all_zeros\") {\n        // B is all zeros\n        B.assign(m, vector<int>(n, 0));\n\n    } else if (type == \"all_ones\") {\n        // B is all ones\n        B.assign(m, vector<int>(n, 1));\n\n    } else if (type == \"random_valid\") {\n        // Generate a random A and compute B from A\n        A.assign(m, vector<int>(n));\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(0, 1);\n\n        // Compute row-wise and column-wise OR for A\n        vector<int> row_or(m, 0), col_or(n, 0);\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                row_or[i] |= A[i][j];\n        for (int j = 0; j < n; ++j)\n            for (int i = 0; i < m; ++i)\n                col_or[j] |= A[i][j];\n\n        // Compute B from A\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                B[i][j] = row_or[i] | col_or[j];\n\n    } else if (type == \"random_invalid\") {\n        // Generate a B such that no valid A exists\n        B.assign(m, vector<int>(n, 0));\n        int num_conflicts = rnd.next(1, max(1, m * n / 10));\n        for (int k = 0; k < num_conflicts; ++k) {\n            int i = rnd.next(0, m - 1);\n            int j = rnd.next(0, n - 1);\n            B[i][j] = 1;\n            // Ensure that all other elements in row i and column j are zeros\n            for (int t = 0; t < n; ++t)\n                if (t != j)\n                    B[i][t] = 0;\n            for (int t = 0; t < m; ++t)\n                if (t != i)\n                    B[t][j] = 0;\n        }\n\n    } else if (type == \"checkerboard\") {\n        // B is a checkerboard pattern\n        B.assign(m, vector<int>(n, 0));\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                B[i][j] = (i + j) % 2;\n\n    } else if (type == \"custom_invalid\") {\n        // Specific invalid B with a single '1' and rest '0's\n        B.assign(m, vector<int>(n, 0));\n        int i = rnd.next(0, m - 1);\n        int j = rnd.next(0, n - 1);\n        B[i][j] = 1;\n        // Ensure that all other elements in row i and column j are zeros\n        for (int t = 0; t < n; ++t)\n            if (t != j)\n                B[i][t] = 0;\n        for (int t = 0; t < m; ++t)\n            if (t != i)\n                B[t][j] = 0;\n\n    } else if (type == \"single_row_ones\") {\n        // B has ones in a single row, zeros elsewhere\n        B.assign(m, vector<int>(n, 0));\n        int i = rnd.next(0, m - 1);\n        for (int j = 0; j < n; ++j)\n            B[i][j] = 1;\n\n    } else if (type == \"single_column_ones\") {\n        // B has ones in a single column, zeros elsewhere\n        B.assign(m, vector<int>(n, 0));\n        int j = rnd.next(0, n - 1);\n        for (int i = 0; i < m; ++i)\n            B[i][j] = 1;\n\n    } else if (type == \"random_sparse_valid\") {\n        // Generate a sparse A and compute B\n        A.assign(m, vector<int>(n, 0));\n        int num_ones = rnd.next(1, max(1, m * n / 10));\n        for (int k = 0; k < num_ones; ++k) {\n            int i = rnd.next(0, m - 1);\n            int j = rnd.next(0, n - 1);\n            A[i][j] = 1;\n        }\n        // Compute row-wise and column-wise OR for A\n        vector<int> row_or(m, 0), col_or(n, 0);\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                row_or[i] |= A[i][j];\n        for (int j = 0; j < n; ++j)\n            for (int i = 0; i < m; ++i)\n                col_or[j] |= A[i][j];\n        // Compute B from A\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                B[i][j] = row_or[i] | col_or[j];\n\n    } else {\n        // If type is not recognized, default to random_valid\n        // Generate a random A and compute B from A\n        A.assign(m, vector<int>(n));\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(0, 1);\n\n        // Compute row-wise and column-wise OR for A\n        vector<int> row_or(m, 0), col_or(n, 0);\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                row_or[i] |= A[i][j];\n        for (int j = 0; j < n; ++j)\n            for (int i = 0; i < m; ++i)\n                col_or[j] |= A[i][j];\n\n        // Compute B from A\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                B[i][j] = row_or[i] | col_or[j];\n    }\n\n    // Output m and n\n    printf(\"%d %d\\n\", m, n);\n\n    // Output matrix B\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (j > 0) printf(\" \");\n            printf(\"%d\", B[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 2 -n 2 -type custom_invalid\n./gen -m 3 -n 3 -type custom_invalid\n./gen -m 5 -n 5 -type checkerboard\n./gen -m 5 -n 5 -type random_valid\n./gen -m 5 -n 5 -type random_invalid\n./gen -m 10 -n 10 -type all_zeros\n./gen -m 10 -n 10 -type all_ones\n./gen -m 10 -n 10 -type random_valid\n./gen -m 10 -n 10 -type random_invalid\n./gen -m 10 -n 10 -type checkerboard\n./gen -m 10 -n 10 -type custom_invalid\n./gen -m 10 -n 10 -type random_sparse_valid\n./gen -m 1 -n 1 -type random_valid\n./gen -m 1 -n 100 -type random_valid\n./gen -m 100 -n 1 -type random_valid\n./gen -m 100 -n 100 -type random_valid\n./gen -m 100 -n 100 -type random_invalid\n./gen -m 100 -n 100 -type checkerboard\n./gen -m 50 -n 50 -type random_valid\n./gen -m 50 -n 50 -type random_invalid\n./gen -m 30 -n 70 -type random_valid\n./gen -m 70 -n 30 -type random_invalid\n./gen -m 1 -n 100 -type all_zeros\n./gen -m 1 -n 100 -type all_ones\n./gen -m 100 -n 1 -type all_zeros\n./gen -m 100 -n 1 -type all_ones\n./gen -m 100 -n 100 -type single_row_ones\n./gen -m 100 -n 100 -type single_column_ones\n./gen -m 20 -n 80 -type random_valid\n./gen -m 80 -n 20 -type random_valid\n./gen -m 50 -n 50 -type random_sparse_valid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:12.582023",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "486/C",
      "title": "C. Преобразование в палиндром",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел, n (1 ≤ n ≤ 105) и p (1 ≤ p ≤ n), соответственно длина строки Нама и начальное положение курсора.В следующей строке записано n строчных символов, составляющих строку Нама.",
      "output_spec": "Выходные данныеВыведите минимальное количество нажатий, необходимое для преобразования строки в палиндром.",
      "sample_tests": "ПримерыВходные данныеСкопировать8 3aeabcaezВыходные данныеСкопировать6",
      "description": "C. Преобразование в палиндром\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел, n (1 ≤ n ≤ 105) и p (1 ≤ p ≤ n), соответственно длина строки Нама и начальное положение курсора.В следующей строке записано n строчных символов, составляющих строку Нама.\n\nВходные данные\n\nВыходные данныеВыведите минимальное количество нажатий, необходимое для преобразования строки в палиндром.\n\nВыходные данные\n\nВходные данныеСкопировать8 3aeabcaezВыходные данныеСкопировать6\n\nВходные данныеСкопировать8 3aeabcaez\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеСтрока является палиндромом, если она одинаково читается слева-направо и справа-налево.В примере изначальная строка Нама такова:  (положение курсора выделено жирным).В оптимальном решении Нам может совершить 6 следующих шагов:В результате получится строка , являющаяся палиндромом.",
      "solutions": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces",
          "content": "Hello everyone!Today, there will be another CodeForces Round at 18:00 (Moscow time). It is a Div. 2 contest, but Div. 1 participants can take part out of competition also.My name is Vuong and this is my very first CodeForces round. Hope that this is not the last one. I would like to thanks Maxim Akhmedov(Zlobober) for help me preparing the round, Maria Belova(Delinur) for translating problems into English, and Mike Mirzayanov(MikeMirzayanov) for such a great Polygon and CodeForces.Be sure to read all problem statements before contest ended. Hope you enjoy the contest. Good luck and have fun!UPD The contest is over! Thanks all of you for participating!Here is top 5 participants: khykhm110 My_First_Lady Perditio AkatsukiPain s_z_l The editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces",
          "content": "486A - Calculating FunctionIf n is even, then the answer is n / 2, otherwise the answer is (n - 1) / 2 - n =  - (n + 1) / 2.486B - OR in MatrixHint of this problem is presented in its statement. \" where is equal to 1 if some ai = 1, otherwise it is equal to 0.\"To solve this problem, do 3 following steps: Assign all aij (1 ≤ i ≤ m, 1 ≤ j ≤ n) equals to 1. If some bij = 0, then do assignments: aik = atj = 0 (1 ≤ k ≤ n, 1 ≤ t ≤ m) (that means, assign all elements in row i and column j of matrix a to 0). Then we have matrix a which need to find. Just check whether from matrix a, can we produce matrix b. If not, the answer is obviously \"NO\". Complexity: We can implement this algorithm in O(m * n), but it's not neccesary since 1 ≤ m, n ≤ 100.486C - Palindrome TransformationAssuming that cursor's position is in the first half of string(i.e 1 ≤ p ≤ n / 2) (if it's not, just reverse the string, and change p to n - p + 1, then the answer will not change).It is not hard to see that, in optimal solution, we only need to move our cusor in the first half of the string only, and the number of \"turn\" is at most once. Therefore, we have below algorithm: Find the largest index r before p in the first half of the string (p ≤ r ≤ n / 2) such that sr different to sn - r + 1. (si denote ith character of our input string s) Find the smallest index l after p (1 ≤ l ≤ p) such that sl different to sn - l + 1. In optimal solution, we move our cusor from p to l and then from l to r, or move from p to r and then from r to l. While moving, we also change character of string simultaneously (if needed) (by press up/down arrow keys). Be careful with some corner case(for example, does'nt exist such l or r discribed above).Complexity: O(n).486D - Valid Sets Firstly, we solve the case d =  + ∞. In this case, we can forget all ai since they doesn't play a role anymore. Consider the tree is rooted at node 1. Let Fi be the number of valid sets contain node i and several other nodes in subtree of i (\"several\" here means 0 or more). We can easily calculate Fi through Fj where j is directed child node of i: . Complexity: O(n). General case: d ≥ 0. For each node i, we count the number of valid sets contain node i and some other node j such that ai ≤ aj ≤ ai + d (that means, node i have the smallest value a in the set). How? Start DFS from node i, visit only nodes j such that ai ≤ aj ≤ ai + d. Then all nodes have visited form another tree. Just apply case d =  + ∞ for this new tree. We have to count n times, each time take O(n), so the overall complexity is O(n2). (Be craeful with duplicate counting) Here is my code.486E - LIS of SequenceLIS = Longest increasing subsequence.Solution 1 (Most of participant's solutions): Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai} and D1i is the number of such that LIS. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an} and D2i is the number of such that LIS. // Calculates F1i and F2i is familiar task, so I will not dig into this. For those who have'nt known it yet, this link may be useful) // We can calculate D1i and D2i by using advanced data structure, like BIT or Segment tree. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. m = number of LIS of {a1, a2, ..., an} = Let Ci be the number of LIS of {a1, a2, ..., an} that ai belongs to. Index i must in group:1) if Ci = 02) if 0 ≤ Ci < m3) if Ci = m How to calculate Ci? If (F1i + F2i - 1 < l) then Ci = 0, else Ci = D1i * D2i. Done! We have an additional issue. The number of LIS of {a1, a2, ..., an} maybe very large! D1i, D2i and m maybe exceed 64-bits integer. Hence, we need to store D1i, D2i and m after modulo some integer number, call it p.Usually, we will choose p is a prime, like 109 + 7 or 109 + 9. It's not hard to generate a test such that if you choose p = 109 + 7 or p = 109 + 9, your solution will lead to Wrong answer. But I have romeved such that tests, because the data tests is weak, even p is not a prime can pass all tests.Solution 2:// Some notation is re-defined. Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai}. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an}. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. Let Fi be the length of LIS of sequence {a1, a2, ..., ai - 1, ai + 1, ..., an} (i.e the length of LIS of initial sequence a after removing element ai). Index i must in group:1) if F1i + F2i - 1 < l, otherwise:2) if Fi = l3) if Fi = l - 1 How to caculate Fi? We have: Fi = max{F1u + F2v} among 1 ≤ u < i < v ≤ n such that au < av. From this formula, we can use Segment tree to calculate Fi. Due to limitation of my English, it is really hard to write exactly how. I will post my code soon. Complexity of both above solution: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14678",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 486\\s*C"
          },
          "content_length": 4836
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 1",
          "code": "right - pos + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 2",
          "code": "pos - left + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 3",
          "code": "min(abs(s[i] - s[n - i - 1]), 26 - abs(s[i] - s[n - i - 1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 4",
          "code": "min(abs(right-pos)+right-left,abs(pos-left)+right-left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 5",
          "code": "min(r-p,p-l) * 2 + max(r-p,p-l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 6",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 7",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 8",
          "code": "double pow (double base, double exponent);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 9",
          "code": "j=pow((i+1),2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 10",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 11",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 12",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 13",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 1",
          "code": "F(i) will be 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 2",
          "code": "(0,1,2....F(j))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 3",
          "code": "F(i) = prod(F(j)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 4",
          "code": "D-Valid Sets",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]+\");\n    inf.readEoln();\n\n    ensuref((int)s.length() == n, \"Expected length %d but found %d\", n, (int)s.length());\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]+\");\n    inf.readEoln();\n\n    ensuref((int)s.length() == n, \"Expected length %d but found %d\", n, (int)s.length());\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]+\");\n    inf.readEoln();\n\n    ensuref((int)s.length() == n, \"Expected length %d but found %d\", n, (int)s.length());\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\", n / 2 + 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure p is in range [1, n]\n    p = max(1, min(p, n));\n\n    string s(n, 'a');\n\n    if (type == \"random\") {\n        // Generate random lowercase letters\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char c = 'a' + rnd.next(26);\n            s[i] = s[n - i - 1] = c;\n        }\n    } else if (type == \"max_changes\") {\n        // Generate a string that requires maximum changes to become palindrome\n        // For each position i, make s[i] != s[n - i - 1]\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        for (int i = 0; i < n / 2; ++i) {\n            while (s[i] == s[n - i - 1]) {\n                s[n - i - 1] = 'a' + rnd.next(26);\n            }\n        }\n    } else if (type == \"all_same\") {\n        // All letters are the same\n        char c = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            s[i] = c;\n        }\n    } else if (type == \"alternating\") {\n        // Generate an alternating string, e.g., 'ababab...'\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"hard\") {\n        // A carefully constructed test case to test cursor movement\n        // For example, spread out the positions that need to change\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a';\n        int changes = n / 10; // For example, 10% positions need to be changed\n        set<int> positions;\n        while ((int)positions.size() < changes) {\n            int pos = rnd.next(n);\n            positions.insert(pos);\n        }\n        for (int pos : positions) {\n            s[pos] = 'b'; // Change to a different letter\n        }\n    } else {\n        // Default to random if unrecognized type\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    }\n    \n    // Output\n    printf(\"%d %d\\n\", n, p);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\", n / 2 + 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure p is in range [1, n]\n    p = max(1, min(p, n));\n\n    string s(n, 'a');\n\n    if (type == \"random\") {\n        // Generate random lowercase letters\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char c = 'a' + rnd.next(26);\n            s[i] = s[n - i - 1] = c;\n        }\n    } else if (type == \"max_changes\") {\n        // Generate a string that requires maximum changes to become palindrome\n        // For each position i, make s[i] != s[n - i - 1]\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        for (int i = 0; i < n / 2; ++i) {\n            while (s[i] == s[n - i - 1]) {\n                s[n - i - 1] = 'a' + rnd.next(26);\n            }\n        }\n    } else if (type == \"all_same\") {\n        // All letters are the same\n        char c = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            s[i] = c;\n        }\n    } else if (type == \"alternating\") {\n        // Generate an alternating string, e.g., 'ababab...'\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"hard\") {\n        // A carefully constructed test case to test cursor movement\n        // For example, spread out the positions that need to change\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a';\n        int changes = n / 10; // For example, 10% positions need to be changed\n        set<int> positions;\n        while ((int)positions.size() < changes) {\n            int pos = rnd.next(n);\n            positions.insert(pos);\n        }\n        for (int pos : positions) {\n            s[pos] = 'b'; // Change to a different letter\n        }\n    } else {\n        // Default to random if unrecognized type\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    }\n    \n    // Output\n    printf(\"%d %d\\n\", n, p);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random string\n./gen -n 1 -type random\n./gen -n 1 -type palindrome\n./gen -n 2 -type random\n./gen -n 2 -type palindrome\n./gen -n 5 -type random\n./gen -n 5 -type palindrome\n\n# Cursor positions at edges\n./gen -n 10 -p 1 -type random\n./gen -n 10 -p 10 -type random\n\n# All same letters\n./gen -n 100 -p 50 -type all_same\n\n# Large n, random string\n./gen -n 1000 -type random\n./gen -n 1000 -type palindrome\n\n# Maximum n\n./gen -n 100000 -type random\n./gen -n 100000 -type palindrome\n./gen -n 100000 -p 1 -type random\n./gen -n 100000 -p 100000 -type random\n\n# Max changes\n./gen -n 100000 -type max_changes\n\n# Alternating letters\n./gen -n 100000 -type alternating\n\n# Hard test case\n./gen -n 100000 -type hard\n\n# Cursor at middle\n./gen -n 99999 -p 50000 -type random\n\n# All same letters, p at 1\n./gen -n 100000 -p 1 -type all_same\n\n# Small n, cursor at end\n./gen -n 7 -p 7 -type random\n\n# Random types\n./gen -n 100 -p 25 -type random\n./gen -n 1000 -p 500 -type max_changes\n./gen -n 20000 -type palindrome\n./gen -n 30000 -type max_changes\n./gen -n 50000 -type random\n./gen -n 80000 -type hard\n\n# Edge case n = 1, p = 1\n./gen -n 1 -p 1 -type random\n\n# Edge case n = 1e5, p = 1e5\n./gen -n 100000 -p 100000 -type random\n\n# Alternating, p in the middle\n./gen -n 100000 -p 50000 -type alternating\n\n# Another hard test case\n./gen -n 100000 -p 50000 -type hard\n\n# Gaps in required changes\n./gen -n 100000 -p 100000 -type max_changes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:14.803539",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "486/D",
      "title": "D. Допустимые множества",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержатся два целых числа через пробел, d (0 ≤ d ≤ 2000) и n (1 ≤ n ≤ 2000).Во второй строке записано n целых положительных чисел, разделённых пробелами, a1, a2, ..., an(1 ≤ ai ≤ 2000).В следующих n - 1 строках записано по паре целых чисел u и v (1 ≤ u, v ≤ n), обозначающих наличие ребра между u и v. Гарантируется, что данный граф является деревом.",
      "output_spec": "Выходные данныеВыведите количество допустимых множеств по модулю 1000000007.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 42 1 3 21 21 33 4Выходные данныеСкопировать8Входные данныеСкопировать0 31 2 31 22 3Выходные данныеСкопировать3Входные данныеСкопировать4 87 8 7 5 4 6 4 101 61 25 81 33 56 73 4Выходные данныеСкопировать41",
      "description": "D. Допустимые множества\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержатся два целых числа через пробел, d (0 ≤ d ≤ 2000) и n (1 ≤ n ≤ 2000).Во второй строке записано n целых положительных чисел, разделённых пробелами, a1, a2, ..., an(1 ≤ ai ≤ 2000).В следующих n - 1 строках записано по паре целых чисел u и v (1 ≤ u, v ≤ n), обозначающих наличие ребра между u и v. Гарантируется, что данный граф является деревом.\n\nВходные данные\n\nВыходные данныеВыведите количество допустимых множеств по модулю 1000000007.\n\nВыходные данные\n\nВходные данныеСкопировать1 42 1 3 21 21 33 4Выходные данныеСкопировать8Входные данныеСкопировать0 31 2 31 22 3Выходные данныеСкопировать3Входные данныеСкопировать4 87 8 7 5 4 6 4 101 61 25 81 33 56 73 4Выходные данныеСкопировать41\n\nВходные данныеСкопировать1 42 1 3 21 21 33 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 31 2 31 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 87 8 7 5 4 6 4 101 61 25 81 33 56 73 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать41\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере можно найти ровно 8 допустимых множеств: {1}, {2}, {3}, {4}, {1, 2}, {1, 3}, {3, 4} и {1, 3, 4}. Множество {1, 2, 3, 4} не является допустимым, поскольку оно не отвечает третьему условию. Множество {1, 4} отвечает третьему условию, но противоречит второму условию.",
      "solutions": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces",
          "content": "Hello everyone!Today, there will be another CodeForces Round at 18:00 (Moscow time). It is a Div. 2 contest, but Div. 1 participants can take part out of competition also.My name is Vuong and this is my very first CodeForces round. Hope that this is not the last one. I would like to thanks Maxim Akhmedov(Zlobober) for help me preparing the round, Maria Belova(Delinur) for translating problems into English, and Mike Mirzayanov(MikeMirzayanov) for such a great Polygon and CodeForces.Be sure to read all problem statements before contest ended. Hope you enjoy the contest. Good luck and have fun!UPD The contest is over! Thanks all of you for participating!Here is top 5 participants: khykhm110 My_First_Lady Perditio AkatsukiPain s_z_l The editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces",
          "content": "486A - Calculating FunctionIf n is even, then the answer is n / 2, otherwise the answer is (n - 1) / 2 - n =  - (n + 1) / 2.486B - OR in MatrixHint of this problem is presented in its statement. \" where is equal to 1 if some ai = 1, otherwise it is equal to 0.\"To solve this problem, do 3 following steps: Assign all aij (1 ≤ i ≤ m, 1 ≤ j ≤ n) equals to 1. If some bij = 0, then do assignments: aik = atj = 0 (1 ≤ k ≤ n, 1 ≤ t ≤ m) (that means, assign all elements in row i and column j of matrix a to 0). Then we have matrix a which need to find. Just check whether from matrix a, can we produce matrix b. If not, the answer is obviously \"NO\". Complexity: We can implement this algorithm in O(m * n), but it's not neccesary since 1 ≤ m, n ≤ 100.486C - Palindrome TransformationAssuming that cursor's position is in the first half of string(i.e 1 ≤ p ≤ n / 2) (if it's not, just reverse the string, and change p to n - p + 1, then the answer will not change).It is not hard to see that, in optimal solution, we only need to move our cusor in the first half of the string only, and the number of \"turn\" is at most once. Therefore, we have below algorithm: Find the largest index r before p in the first half of the string (p ≤ r ≤ n / 2) such that sr different to sn - r + 1. (si denote ith character of our input string s) Find the smallest index l after p (1 ≤ l ≤ p) such that sl different to sn - l + 1. In optimal solution, we move our cusor from p to l and then from l to r, or move from p to r and then from r to l. While moving, we also change character of string simultaneously (if needed) (by press up/down arrow keys). Be careful with some corner case(for example, does'nt exist such l or r discribed above).Complexity: O(n).486D - Valid Sets Firstly, we solve the case d =  + ∞. In this case, we can forget all ai since they doesn't play a role anymore. Consider the tree is rooted at node 1. Let Fi be the number of valid sets contain node i and several other nodes in subtree of i (\"several\" here means 0 or more). We can easily calculate Fi through Fj where j is directed child node of i: . Complexity: O(n). General case: d ≥ 0. For each node i, we count the number of valid sets contain node i and some other node j such that ai ≤ aj ≤ ai + d (that means, node i have the smallest value a in the set). How? Start DFS from node i, visit only nodes j such that ai ≤ aj ≤ ai + d. Then all nodes have visited form another tree. Just apply case d =  + ∞ for this new tree. We have to count n times, each time take O(n), so the overall complexity is O(n2). (Be craeful with duplicate counting) Here is my code.486E - LIS of SequenceLIS = Longest increasing subsequence.Solution 1 (Most of participant's solutions): Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai} and D1i is the number of such that LIS. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an} and D2i is the number of such that LIS. // Calculates F1i and F2i is familiar task, so I will not dig into this. For those who have'nt known it yet, this link may be useful) // We can calculate D1i and D2i by using advanced data structure, like BIT or Segment tree. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. m = number of LIS of {a1, a2, ..., an} = Let Ci be the number of LIS of {a1, a2, ..., an} that ai belongs to. Index i must in group:1) if Ci = 02) if 0 ≤ Ci < m3) if Ci = m How to calculate Ci? If (F1i + F2i - 1 < l) then Ci = 0, else Ci = D1i * D2i. Done! We have an additional issue. The number of LIS of {a1, a2, ..., an} maybe very large! D1i, D2i and m maybe exceed 64-bits integer. Hence, we need to store D1i, D2i and m after modulo some integer number, call it p.Usually, we will choose p is a prime, like 109 + 7 or 109 + 9. It's not hard to generate a test such that if you choose p = 109 + 7 or p = 109 + 9, your solution will lead to Wrong answer. But I have romeved such that tests, because the data tests is weak, even p is not a prime can pass all tests.Solution 2:// Some notation is re-defined. Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai}. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an}. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. Let Fi be the length of LIS of sequence {a1, a2, ..., ai - 1, ai + 1, ..., an} (i.e the length of LIS of initial sequence a after removing element ai). Index i must in group:1) if F1i + F2i - 1 < l, otherwise:2) if Fi = l3) if Fi = l - 1 How to caculate Fi? We have: Fi = max{F1u + F2v} among 1 ≤ u < i < v ≤ n such that au < av. From this formula, we can use Segment tree to calculate Fi. Due to limitation of my English, it is really hard to write exactly how. I will post my code soon. Complexity of both above solution: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14678",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 486\\s*D"
          },
          "content_length": 4836
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 1",
          "code": "right - pos + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 2",
          "code": "pos - left + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 3",
          "code": "min(abs(s[i] - s[n - i - 1]), 26 - abs(s[i] - s[n - i - 1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 4",
          "code": "min(abs(right-pos)+right-left,abs(pos-left)+right-left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 5",
          "code": "min(r-p,p-l) * 2 + max(r-p,p-l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 6",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 7",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 8",
          "code": "double pow (double base, double exponent);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 9",
          "code": "j=pow((i+1),2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 10",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 11",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 12",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 13",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 1",
          "code": "F(i) will be 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 2",
          "code": "(0,1,2....F(j))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 3",
          "code": "F(i) = prod(F(j)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 4",
          "code": "D-Valid Sets",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int u, const vector<vector<int>>& adj, vector<bool>& visited) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v, adj, visited);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(0, 2000, \"d\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2000, \"a_i\");\n    inf.readEoln();\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loop detected at edge %d: u (%d) == v (%d)\", i+1, u, v);\n        int mn = min(u, v);\n        int mx = max(u, v);\n        ensuref(edges.count({mn, mx}) == 0, \"Multiple edges detected between nodes %d and %d at edge %d\", mn, mx, i+1);\n        edges.insert({mn, mx});\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<bool> visited(n + 1, false);\n    dfs(1, adj, visited);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"The graph is not connected, node %d is unreachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int u, const vector<vector<int>>& adj, vector<bool>& visited) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v, adj, visited);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(0, 2000, \"d\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2000, \"a_i\");\n    inf.readEoln();\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loop detected at edge %d: u (%d) == v (%d)\", i+1, u, v);\n        int mn = min(u, v);\n        int mx = max(u, v);\n        ensuref(edges.count({mn, mx}) == 0, \"Multiple edges detected between nodes %d and %d at edge %d\", mn, mx, i+1);\n        edges.insert({mn, mx});\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<bool> visited(n + 1, false);\n    dfs(1, adj, visited);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"The graph is not connected, node %d is unreachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int u, const vector<vector<int>>& adj, vector<bool>& visited) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v, adj, visited);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(0, 2000, \"d\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2000, \"a_i\");\n    inf.readEoln();\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loop detected at edge %d: u (%d) == v (%d)\", i+1, u, v);\n        int mn = min(u, v);\n        int mx = max(u, v);\n        ensuref(edges.count({mn, mx}) == 0, \"Multiple edges detected between nodes %d and %d at edge %d\", mn, mx, i+1);\n        edges.insert({mn, mx});\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<bool> visited(n + 1, false);\n    dfs(1, adj, visited);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"The graph is not connected, node %d is unreachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string atype = opt<string>(\"atype\", \"random\");\n    string ttype = opt<string>(\"ttype\", \"random\");\n\n    int min_a = 1;\n    int max_a = 2000;\n\n    vector<int> a(n);\n\n    if (atype == \"min\") {\n        fill(a.begin(), a.end(), min_a);\n    } else if (atype == \"max\") {\n        fill(a.begin(), a.end(), max_a);\n    } else if (atype == \"same\") {\n        int val = rnd.next(min_a, max_a);\n        fill(a.begin(), a.end(), val);\n    } else if (atype == \"increasing\") {\n        int val = rnd.next(min_a, max_a - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val + i;\n        }\n    } else if (atype == \"decreasing\") {\n        int val = rnd.next(min_a + n - 1, max_a);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val - i;\n        }\n    } else if (atype == \"small_d\") {\n        a[0] = rnd.next(min_a, max_a);\n        for(int i = 1; i < n; ++i) {\n            int lo = max(min_a, a[i - 1] - d);\n            int hi = min(max_a, a[i - 1] + d);\n            if (lo > hi) lo = hi = a[i - 1];\n            a[i] = rnd.next(lo, hi);\n        }\n    } else { // random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(min_a, max_a);\n        }\n    }\n\n    vector<pair<int,int>> edges;\n\n    if (ttype == \"chain\") {\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (ttype == \"star\") {\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n    } else if (ttype == \"balanced\") {\n        function<void(int,int)> buildBalanced = [&](int l, int r){\n            if (l >= r) return;\n            int m = (l + r) / 2;\n            if (l != m) {\n                int left_child = (l + m - 1) / 2;\n                edges.push_back({m, left_child});\n                buildBalanced(l, m - 1);\n            }\n            if (m + 1 <= r) {\n                int right_child = (m + 1 + r) / 2;\n                edges.push_back({m, right_child});\n                buildBalanced(m + 1, r);\n            }\n        };\n        buildBalanced(0, n - 1);\n    } else { // random\n        vector<int> p(n);\n        for(int i = 1; i < n; ++i) {\n            p[i] = rnd.next(0, i - 1);\n            edges.push_back({p[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i) perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Apply permutation to a\n    vector<int> shuffled_a(n);\n    for(int i = 0; i < n; ++i) {\n        shuffled_a[perm[i]] = a[i];\n    }\n    // Apply permutation to edges\n    vector<pair<int,int>> shuffled_edges;\n    for(auto edge : edges) {\n        int u = perm[edge.first];\n        int v = perm[edge.second];\n        shuffled_edges.push_back({u, v});\n    }\n    // Shuffle the edges\n    shuffle(shuffled_edges.begin(), shuffled_edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", d, n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", shuffled_a[i]);\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    for(auto edge : shuffled_edges) {\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string atype = opt<string>(\"atype\", \"random\");\n    string ttype = opt<string>(\"ttype\", \"random\");\n\n    int min_a = 1;\n    int max_a = 2000;\n\n    vector<int> a(n);\n\n    if (atype == \"min\") {\n        fill(a.begin(), a.end(), min_a);\n    } else if (atype == \"max\") {\n        fill(a.begin(), a.end(), max_a);\n    } else if (atype == \"same\") {\n        int val = rnd.next(min_a, max_a);\n        fill(a.begin(), a.end(), val);\n    } else if (atype == \"increasing\") {\n        int val = rnd.next(min_a, max_a - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val + i;\n        }\n    } else if (atype == \"decreasing\") {\n        int val = rnd.next(min_a + n - 1, max_a);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val - i;\n        }\n    } else if (atype == \"small_d\") {\n        a[0] = rnd.next(min_a, max_a);\n        for(int i = 1; i < n; ++i) {\n            int lo = max(min_a, a[i - 1] - d);\n            int hi = min(max_a, a[i - 1] + d);\n            if (lo > hi) lo = hi = a[i - 1];\n            a[i] = rnd.next(lo, hi);\n        }\n    } else { // random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(min_a, max_a);\n        }\n    }\n\n    vector<pair<int,int>> edges;\n\n    if (ttype == \"chain\") {\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (ttype == \"star\") {\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n    } else if (ttype == \"balanced\") {\n        function<void(int,int)> buildBalanced = [&](int l, int r){\n            if (l >= r) return;\n            int m = (l + r) / 2;\n            if (l != m) {\n                int left_child = (l + m - 1) / 2;\n                edges.push_back({m, left_child});\n                buildBalanced(l, m - 1);\n            }\n            if (m + 1 <= r) {\n                int right_child = (m + 1 + r) / 2;\n                edges.push_back({m, right_child});\n                buildBalanced(m + 1, r);\n            }\n        };\n        buildBalanced(0, n - 1);\n    } else { // random\n        vector<int> p(n);\n        for(int i = 1; i < n; ++i) {\n            p[i] = rnd.next(0, i - 1);\n            edges.push_back({p[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i) perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Apply permutation to a\n    vector<int> shuffled_a(n);\n    for(int i = 0; i < n; ++i) {\n        shuffled_a[perm[i]] = a[i];\n    }\n    // Apply permutation to edges\n    vector<pair<int,int>> shuffled_edges;\n    for(auto edge : edges) {\n        int u = perm[edge.first];\n        int v = perm[edge.second];\n        shuffled_edges.push_back({u, v});\n    }\n    // Shuffle the edges\n    shuffle(shuffled_edges.begin(), shuffled_edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", d, n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", shuffled_a[i]);\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    for(auto edge : shuffled_edges) {\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d 0 -atype min -ttype chain\n./gen -n 2 -d 0 -atype same -ttype chain\n./gen -n 2 -d 0 -atype random -ttype star\n./gen -n 3 -d 0 -atype same -ttype chain\n./gen -n 3 -d 0 -atype random -ttype star\n./gen -n 5 -d 0 -atype same -ttype star\n./gen -n 5 -d 1 -atype increasing -ttype chain\n./gen -n 5 -d 2 -atype decreasing -ttype chain\n./gen -n 10 -d 0 -atype random -ttype random\n./gen -n 10 -d 10 -atype increasing -ttype chain\n./gen -n 10 -d 10 -atype decreasing -ttype chain\n./gen -n 20 -d 5 -atype small_d -ttype random\n./gen -n 50 -d 0 -atype same -ttype balanced\n./gen -n 100 -d 100 -atype random -ttype random\n./gen -n 100 -d 0 -atype min -ttype chain\n./gen -n 100 -d 2000 -atype max -ttype star\n./gen -n 500 -d 0 -atype same -ttype star\n./gen -n 500 -d 250 -atype random -ttype balanced\n./gen -n 1000 -d 0 -atype min -ttype chain\n./gen -n 1000 -d 500 -atype random -ttype random\n./gen -n 2000 -d 0 -atype same -ttype star\n./gen -n 2000 -d 1000 -atype small_d -ttype random\n./gen -n 2000 -d 2000 -atype random -ttype random\n./gen -n 2000 -d 0 -atype increasing -ttype chain\n./gen -n 2000 -d 0 -atype decreasing -ttype chain\n./gen -n 2000 -d 0 -atype random -ttype random\n./gen -n 2000 -d 2000 -atype min -ttype star\n./gen -n 2000 -d 2000 -atype max -ttype star\n./gen -n 2000 -d 2000 -atype random -ttype balanced\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:16.712012",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "486/E",
      "title": "E. LIS of Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the single integer n (1 ≤ n ≤ 105) denoting the number of elements of sequence a.The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 105).",
      "output_spec": "OutputPrint a string consisting of n characters. i-th character should be '1', '2' or '3' depending on which group among listed above index i belongs to.",
      "sample_tests": "ExamplesInputCopy14OutputCopy3InputCopy41 3 2 5OutputCopy3223InputCopy41 5 2 3OutputCopy3133",
      "description": "E. LIS of Sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the single integer n (1 ≤ n ≤ 105) denoting the number of elements of sequence a.The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 105).\n\nOutputPrint a string consisting of n characters. i-th character should be '1', '2' or '3' depending on which group among listed above index i belongs to.\n\nInputCopy14OutputCopy3InputCopy41 3 2 5OutputCopy3223InputCopy41 5 2 3OutputCopy3133\n\nInputCopy14\n\nOutputCopy3\n\nInputCopy41 3 2 5\n\nOutputCopy3223\n\nInputCopy41 5 2 3\n\nOutputCopy3133\n\nNoteIn the second sample, sequence a consists of 4 elements: {a1, a2, a3, a4} = {1, 3, 2, 5}. Sequence a has exactly 2 longest increasing subsequences of length 3, they are {a1, a2, a4} = {1, 3, 5} and {a1, a3, a4} = {1, 2, 5}.In the third sample, sequence a consists of 4 elements: {a1, a2, a3, a4} = {1, 5, 2, 3}. Sequence a have exactly 1 longest increasing subsequence of length 3, that is {a1, a3, a4} = {1, 2, 3}.",
      "solutions": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces",
          "content": "Hello everyone!Today, there will be another CodeForces Round at 18:00 (Moscow time). It is a Div. 2 contest, but Div. 1 participants can take part out of competition also.My name is Vuong and this is my very first CodeForces round. Hope that this is not the last one. I would like to thanks Maxim Akhmedov(Zlobober) for help me preparing the round, Maria Belova(Delinur) for translating problems into English, and Mike Mirzayanov(MikeMirzayanov) for such a great Polygon and CodeForces.Be sure to read all problem statements before contest ended. Hope you enjoy the contest. Good luck and have fun!UPD The contest is over! Thanks all of you for participating!Here is top 5 participants: khykhm110 My_First_Lady Perditio AkatsukiPain s_z_l The editorial can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces",
          "content": "486A - Calculating FunctionIf n is even, then the answer is n / 2, otherwise the answer is (n - 1) / 2 - n =  - (n + 1) / 2.486B - OR in MatrixHint of this problem is presented in its statement. \" where is equal to 1 if some ai = 1, otherwise it is equal to 0.\"To solve this problem, do 3 following steps: Assign all aij (1 ≤ i ≤ m, 1 ≤ j ≤ n) equals to 1. If some bij = 0, then do assignments: aik = atj = 0 (1 ≤ k ≤ n, 1 ≤ t ≤ m) (that means, assign all elements in row i and column j of matrix a to 0). Then we have matrix a which need to find. Just check whether from matrix a, can we produce matrix b. If not, the answer is obviously \"NO\". Complexity: We can implement this algorithm in O(m * n), but it's not neccesary since 1 ≤ m, n ≤ 100.486C - Palindrome TransformationAssuming that cursor's position is in the first half of string(i.e 1 ≤ p ≤ n / 2) (if it's not, just reverse the string, and change p to n - p + 1, then the answer will not change).It is not hard to see that, in optimal solution, we only need to move our cusor in the first half of the string only, and the number of \"turn\" is at most once. Therefore, we have below algorithm: Find the largest index r before p in the first half of the string (p ≤ r ≤ n / 2) such that sr different to sn - r + 1. (si denote ith character of our input string s) Find the smallest index l after p (1 ≤ l ≤ p) such that sl different to sn - l + 1. In optimal solution, we move our cusor from p to l and then from l to r, or move from p to r and then from r to l. While moving, we also change character of string simultaneously (if needed) (by press up/down arrow keys). Be careful with some corner case(for example, does'nt exist such l or r discribed above).Complexity: O(n).486D - Valid Sets Firstly, we solve the case d =  + ∞. In this case, we can forget all ai since they doesn't play a role anymore. Consider the tree is rooted at node 1. Let Fi be the number of valid sets contain node i and several other nodes in subtree of i (\"several\" here means 0 or more). We can easily calculate Fi through Fj where j is directed child node of i: . Complexity: O(n). General case: d ≥ 0. For each node i, we count the number of valid sets contain node i and some other node j such that ai ≤ aj ≤ ai + d (that means, node i have the smallest value a in the set). How? Start DFS from node i, visit only nodes j such that ai ≤ aj ≤ ai + d. Then all nodes have visited form another tree. Just apply case d =  + ∞ for this new tree. We have to count n times, each time take O(n), so the overall complexity is O(n2). (Be craeful with duplicate counting) Here is my code.486E - LIS of SequenceLIS = Longest increasing subsequence.Solution 1 (Most of participant's solutions): Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai} and D1i is the number of such that LIS. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an} and D2i is the number of such that LIS. // Calculates F1i and F2i is familiar task, so I will not dig into this. For those who have'nt known it yet, this link may be useful) // We can calculate D1i and D2i by using advanced data structure, like BIT or Segment tree. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. m = number of LIS of {a1, a2, ..., an} = Let Ci be the number of LIS of {a1, a2, ..., an} that ai belongs to. Index i must in group:1) if Ci = 02) if 0 ≤ Ci < m3) if Ci = m How to calculate Ci? If (F1i + F2i - 1 < l) then Ci = 0, else Ci = D1i * D2i. Done! We have an additional issue. The number of LIS of {a1, a2, ..., an} maybe very large! D1i, D2i and m maybe exceed 64-bits integer. Hence, we need to store D1i, D2i and m after modulo some integer number, call it p.Usually, we will choose p is a prime, like 109 + 7 or 109 + 9. It's not hard to generate a test such that if you choose p = 109 + 7 or p = 109 + 9, your solution will lead to Wrong answer. But I have romeved such that tests, because the data tests is weak, even p is not a prime can pass all tests.Solution 2:// Some notation is re-defined. Let F1i be the length of LIS ending exactly at ai of sequence {a1, a2, ..., ai}. Let F2i be the length of LIS beginning exactly at ai of sequence {ai, ai + 1, ..., an}. l = length of LIS of {a1, a2, ..., an} = max{F1i} = max{F2j}. Let Fi be the length of LIS of sequence {a1, a2, ..., ai - 1, ai + 1, ..., an} (i.e the length of LIS of initial sequence a after removing element ai). Index i must in group:1) if F1i + F2i - 1 < l, otherwise:2) if Fi = l3) if Fi = l - 1 How to caculate Fi? We have: Fi = max{F1u + F2v} among 1 ≤ u < i < v ≤ n such that au < av. From this formula, we can use Segment tree to calculate Fi. Due to limitation of my English, it is really hard to write exactly how. I will post my code soon. Complexity of both above solution: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14678",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 486\\s*E"
          },
          "content_length": 4836
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 1",
          "code": "right - pos + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 2",
          "code": "pos - left + right - left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 3",
          "code": "min(abs(s[i] - s[n - i - 1]), 26 - abs(s[i] - s[n - i - 1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 4",
          "code": "min(abs(right-pos)+right-left,abs(pos-left)+right-left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 5",
          "code": "min(r-p,p-l) * 2 + max(r-p,p-l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 6",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 7",
          "code": "if(n&1){\n\t\t\tcout<<\"-\"<<n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<n/2<<endl;\n\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 8",
          "code": "double pow (double base, double exponent);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 9",
          "code": "j=pow((i+1),2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 10",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 11",
          "code": "for (int i=1; i<=n; i=i+2)\n s=s+i-i+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 12",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) - Codeforces - Code 13",
          "code": "s = s + n / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 1",
          "code": "F(i) will be 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 2",
          "code": "(0,1,2....F(j))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 3",
          "code": "F(i) = prod(F(j)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277(Div. 2) Editorial - Codeforces - Code 4",
          "code": "D-Valid Sets",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14678",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"constant\") {\n        // All elements are the same\n        int val = rnd.next(1, 100000);\n        fill(a.begin(), a.end(), val);\n    } else if (type == \"increasing\") {\n        // ai = i\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        // ai = n - i\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"random\") {\n        // Random elements between 1 and 1e5\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    } else if (type == \"alternating\") {\n        // High and low numbers alternating\n        int high = 100000;\n        int low = 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? high : low;\n    } else if (type == \"few_unique\") {\n        // Only few unique values\n        int k = opt<int>(\"k\", 2);\n        vector<int> values(k);\n        for (int i = 0; i < k; ++i)\n            values[i] = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i)\n            a[i] = values[rnd.next(0, k - 1)];\n    } else if (type == \"repeated_pattern\") {\n        // Repeating pattern\n        vector<int> pattern = {1, 2, 3, 2, 1};\n        for (int i = 0; i < n; ++i)\n            a[i] = pattern[i % pattern.size()];\n    } else if (type == \"permuted_increasing\") {\n        // Permuted increasing sequence\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } else {\n        // By default, generate random elements\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"constant\") {\n        // All elements are the same\n        int val = rnd.next(1, 100000);\n        fill(a.begin(), a.end(), val);\n    } else if (type == \"increasing\") {\n        // ai = i\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        // ai = n - i\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"random\") {\n        // Random elements between 1 and 1e5\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    } else if (type == \"alternating\") {\n        // High and low numbers alternating\n        int high = 100000;\n        int low = 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? high : low;\n    } else if (type == \"few_unique\") {\n        // Only few unique values\n        int k = opt<int>(\"k\", 2);\n        vector<int> values(k);\n        for (int i = 0; i < k; ++i)\n            values[i] = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i)\n            a[i] = values[rnd.next(0, k - 1)];\n    } else if (type == \"repeated_pattern\") {\n        // Repeating pattern\n        vector<int> pattern = {1, 2, 3, 2, 1};\n        for (int i = 0; i < n; ++i)\n            a[i] = pattern[i % pattern.size()];\n    } else if (type == \"permuted_increasing\") {\n        // Permuted increasing sequence\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } else {\n        // By default, generate random elements\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small size, n = 1 to 5\n./gen -n 1 -type constant\n./gen -n 1 -type increasing\n./gen -n 1 -type random\n\n./gen -n 2 -type decreasing\n./gen -n 2 -type random\n\n./gen -n 5 -type random\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n\n# Moderate size, n = 100\n./gen -n 100 -type constant\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type random\n\n# Larger size, n = 1000\n./gen -n 1000 -type constant\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type random\n\n# Large size, n = 100000\n./gen -n 100000 -type constant\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type random\n\n# Special sequences to test edge cases\n./gen -n 100000 -type alternating\n./gen -n 100000 -type few_unique -k 2\n./gen -n 100000 -type few_unique -k 3\n./gen -n 100000 -type repeated_pattern\n./gen -n 100000 -type permuted_increasing\n\n# Sequences with maximum values\n./gen -n 100000 -type constant\n./gen -n 100000 -type random\n\n# Sequences with only two unique values\n./gen -n 100000 -type few_unique -k 2\n\n# Sequences with increasing pattern but shuffled\n./gen -n 100000 -type permuted_increasing\n\n# Corner cases\n./gen -n 1 -type random\n./gen -n 2 -type alternating\n./gen -n 5 -type repeated_pattern\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:18.536828",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "487/A",
      "title": "A. Fight the Monster",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers HPY, ATKY, DEFY, separated by a space, denoting the initial HP, ATK and DEF of Master Yang.The second line contains three integers HPM, ATKM, DEFM, separated by a space, denoting the HP, ATK and DEF of the monster.The third line contains three integers h, a, d, separated by a space, denoting the price of 1 HP, 1 ATK and 1 DEF.All numbers in input are integer and lie between 1 and 100 inclusively.",
      "output_spec": "OutputThe only output line should contain an integer, denoting the minimum bitcoins Master Yang should spend in order to win.",
      "sample_tests": "ExamplesInputCopy1 2 11 100 11 100 100OutputCopy99InputCopy100 100 1001 1 11 1 1OutputCopy0",
      "description": "A. Fight the Monster\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers HPY, ATKY, DEFY, separated by a space, denoting the initial HP, ATK and DEF of Master Yang.The second line contains three integers HPM, ATKM, DEFM, separated by a space, denoting the HP, ATK and DEF of the monster.The third line contains three integers h, a, d, separated by a space, denoting the price of 1 HP, 1 ATK and 1 DEF.All numbers in input are integer and lie between 1 and 100 inclusively.\n\nOutputThe only output line should contain an integer, denoting the minimum bitcoins Master Yang should spend in order to win.\n\nInputCopy1 2 11 100 11 100 100OutputCopy99InputCopy100 100 1001 1 11 1 1OutputCopy0\n\nInputCopy1 2 11 100 11 100 100\n\nOutputCopy99\n\nInputCopy100 100 1001 1 11 1 1\n\nOutputCopy0\n\nNoteFor the first sample, prices for ATK and DEF are extremely high. Master Yang can buy 99 HP, then he can beat the monster with 1 HP left.For the second sample, Master Yang is strong enough to beat the monster, so he doesn't need to buy anything.",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 487\\s*A"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> y = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    vector<int> m = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    vector<int> price = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> y = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    vector<int> m = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    vector<int> price = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> y = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    vector<int> m = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    vector<int> price = inf.readInts(3, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read options\n    string type = opt<string>(\"type\", \"random\");\n    // Optional prices\n    int h = opt<int>(\"h\", -1); // Default -1 means random\n    int a = opt<int>(\"a\", -1);\n    int d = opt<int>(\"d\", -1);\n\n    // Now we will generate values according to the test type\n\n    // All attributes are in [1, 100]\n    int HPY, ATKY, DEFY; // Master Yang's HP, ATK, DEF\n    int HPM, ATKM, DEFM; // Monster's HP, ATK, DEF\n\n    // Prices h, a, d in [1, 100]\n    if (h == -1) h = rnd.next(1, 100);\n    if (a == -1) a = rnd.next(1, 100);\n    if (d == -1) d = rnd.next(1, 100);\n\n    if (type == \"atk_zero\") {\n        // ATKY ≤ DEFM\n        ATKY = rnd.next(1, 100);\n        DEFM = rnd.next(ATKY, 100);\n\n        HPY = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n\n        HPM = rnd.next(1, 100);\n        ATKM = rnd.next(1, 100);\n\n    } else if (type == \"def_zero\") {\n        // ATKM ≤ DEFY\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(ATKM, 100);\n\n        HPY = rnd.next(1, 100);\n        ATKY = rnd.next(1, 100);\n\n        HPM = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n\n    } else if (type == \"no_damage\") {\n        // ATKY ≤ DEFM and ATKM ≤ DEFY\n        ATKY = rnd.next(1, 100);\n        DEFM = rnd.next(ATKY, 100);\n\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(ATKM, 100);\n\n        HPY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n\n    } else if (type == \"need_hp\") {\n        // Master Yang can damage Monster, but needs extra HP to survive long enough\n        do {\n            ATKY = rnd.next(1, 100);\n            DEFM = rnd.next(1, 100);\n        } while (ATKY <= DEFM);\n\n        do {\n            ATKM = rnd.next(1, 100);\n            DEFY = rnd.next(1, 100);\n        } while (ATKM <= DEFY); // So Yang is taking damage\n\n        HPY = rnd.next(1, 50); // Small HPY\n        HPM = rnd.next(50, 100); // Large HPM\n\n    } else if (type == \"impossible\") {\n        // Even after buying attributes, cannot win\n        ATKY = rnd.next(1, 100);\n        DEFM = 100;\n\n        ATKM = 100;\n        DEFY = rnd.next(1, 100);\n\n        HPY = rnd.next(1, 100);\n        HPM = 100;\n\n    } else if (type == \"price_hp_optimal\") {\n        // Prices make buying HP the best option\n        h = rnd.next(1, 10);\n        a = rnd.next(50, 100);\n        d = rnd.next(50, 100);\n\n        do {\n            ATKY = rnd.next(1, 100);\n            DEFM = rnd.next(1, 100);\n        } while (ATKY <= DEFM);\n\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n\n        HPY = rnd.next(1, 50); // Small HPY\n        HPM = rnd.next(50, 100); // Large HPM\n\n    } else if (type == \"price_atk_optimal\") {\n        // Prices make buying ATK the best option\n        h = rnd.next(50, 100);\n        a = rnd.next(1, 10);\n        d = rnd.next(50, 100);\n\n        ATKY = rnd.next(1, 50);\n        DEFM = rnd.next(ATKY+1, 100); // Ensure ATKY ≤ DEFM\n\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n\n        HPY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n\n    } else if (type == \"price_def_optimal\") {\n        // Prices make buying DEF the best option\n        h = rnd.next(50, 100);\n        a = rnd.next(50, 100);\n        d = rnd.next(1, 10);\n\n        ATKY = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(ATKM-1, ATKM-1); // DEFY < ATKM\n\n        HPY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n\n    } else if (type == \"max_attributes\") {\n        // All attributes are maximum (100)\n        HPY = 100;\n        ATKY = 100;\n        DEFY = 100;\n\n        HPM = 100;\n        ATKM = 100;\n        DEFM = 100;\n\n    } else if (type == \"min_attributes\") {\n        // All attributes are minimum (1)\n        HPY = 1;\n        ATKY = 1;\n        DEFY = 1;\n\n        HPM = 1;\n        ATKM = 1;\n        DEFM = 1;\n\n    } else if (type == \"random\") {\n        // Random test case\n        HPY = rnd.next(1, 100);\n        ATKY = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n\n        HPM = rnd.next(1, 100);\n        ATKM = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n    } else {\n        // Unknown type\n        cerr << \"Unknown type \" << type << endl;\n        return 1;\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", HPY, ATKY, DEFY);\n    printf(\"%d %d %d\\n\", HPM, ATKM, DEFM);\n    printf(\"%d %d %d\\n\", h, a, d);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read options\n    string type = opt<string>(\"type\", \"random\");\n    // Optional prices\n    int h = opt<int>(\"h\", -1); // Default -1 means random\n    int a = opt<int>(\"a\", -1);\n    int d = opt<int>(\"d\", -1);\n\n    // Now we will generate values according to the test type\n\n    // All attributes are in [1, 100]\n    int HPY, ATKY, DEFY; // Master Yang's HP, ATK, DEF\n    int HPM, ATKM, DEFM; // Monster's HP, ATK, DEF\n\n    // Prices h, a, d in [1, 100]\n    if (h == -1) h = rnd.next(1, 100);\n    if (a == -1) a = rnd.next(1, 100);\n    if (d == -1) d = rnd.next(1, 100);\n\n    if (type == \"atk_zero\") {\n        // ATKY ≤ DEFM\n        ATKY = rnd.next(1, 100);\n        DEFM = rnd.next(ATKY, 100);\n\n        HPY = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n\n        HPM = rnd.next(1, 100);\n        ATKM = rnd.next(1, 100);\n\n    } else if (type == \"def_zero\") {\n        // ATKM ≤ DEFY\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(ATKM, 100);\n\n        HPY = rnd.next(1, 100);\n        ATKY = rnd.next(1, 100);\n\n        HPM = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n\n    } else if (type == \"no_damage\") {\n        // ATKY ≤ DEFM and ATKM ≤ DEFY\n        ATKY = rnd.next(1, 100);\n        DEFM = rnd.next(ATKY, 100);\n\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(ATKM, 100);\n\n        HPY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n\n    } else if (type == \"need_hp\") {\n        // Master Yang can damage Monster, but needs extra HP to survive long enough\n        do {\n            ATKY = rnd.next(1, 100);\n            DEFM = rnd.next(1, 100);\n        } while (ATKY <= DEFM);\n\n        do {\n            ATKM = rnd.next(1, 100);\n            DEFY = rnd.next(1, 100);\n        } while (ATKM <= DEFY); // So Yang is taking damage\n\n        HPY = rnd.next(1, 50); // Small HPY\n        HPM = rnd.next(50, 100); // Large HPM\n\n    } else if (type == \"impossible\") {\n        // Even after buying attributes, cannot win\n        ATKY = rnd.next(1, 100);\n        DEFM = 100;\n\n        ATKM = 100;\n        DEFY = rnd.next(1, 100);\n\n        HPY = rnd.next(1, 100);\n        HPM = 100;\n\n    } else if (type == \"price_hp_optimal\") {\n        // Prices make buying HP the best option\n        h = rnd.next(1, 10);\n        a = rnd.next(50, 100);\n        d = rnd.next(50, 100);\n\n        do {\n            ATKY = rnd.next(1, 100);\n            DEFM = rnd.next(1, 100);\n        } while (ATKY <= DEFM);\n\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n\n        HPY = rnd.next(1, 50); // Small HPY\n        HPM = rnd.next(50, 100); // Large HPM\n\n    } else if (type == \"price_atk_optimal\") {\n        // Prices make buying ATK the best option\n        h = rnd.next(50, 100);\n        a = rnd.next(1, 10);\n        d = rnd.next(50, 100);\n\n        ATKY = rnd.next(1, 50);\n        DEFM = rnd.next(ATKY+1, 100); // Ensure ATKY ≤ DEFM\n\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n\n        HPY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n\n    } else if (type == \"price_def_optimal\") {\n        // Prices make buying DEF the best option\n        h = rnd.next(50, 100);\n        a = rnd.next(50, 100);\n        d = rnd.next(1, 10);\n\n        ATKY = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(ATKM-1, ATKM-1); // DEFY < ATKM\n\n        HPY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n\n    } else if (type == \"max_attributes\") {\n        // All attributes are maximum (100)\n        HPY = 100;\n        ATKY = 100;\n        DEFY = 100;\n\n        HPM = 100;\n        ATKM = 100;\n        DEFM = 100;\n\n    } else if (type == \"min_attributes\") {\n        // All attributes are minimum (1)\n        HPY = 1;\n        ATKY = 1;\n        DEFY = 1;\n\n        HPM = 1;\n        ATKM = 1;\n        DEFM = 1;\n\n    } else if (type == \"random\") {\n        // Random test case\n        HPY = rnd.next(1, 100);\n        ATKY = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n\n        HPM = rnd.next(1, 100);\n        ATKM = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n    } else {\n        // Unknown type\n        cerr << \"Unknown type \" << type << endl;\n        return 1;\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", HPY, ATKY, DEFY);\n    printf(\"%d %d %d\\n\", HPM, ATKM, DEFM);\n    printf(\"%d %d %d\\n\", h, a, d);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type atk_zero\n./gen -type def_zero\n./gen -type no_damage\n./gen -type need_hp\n./gen -type impossible\n./gen -type price_hp_optimal\n./gen -type price_atk_optimal\n./gen -type price_def_optimal\n./gen -type max_attributes\n./gen -type min_attributes\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type atk_zero\n./gen -type atk_zero\n./gen -type def_zero\n./gen -type def_zero\n./gen -type need_hp\n./gen -type need_hp\n./gen -type impossible\n./gen -type impossible\n\n./gen -type random -h 1 -a 100 -d 100\n./gen -type random -h 100 -a 1 -d 100\n./gen -type random -h 100 -a 100 -d 1\n\n./gen -type max_attributes\n./gen -type min_attributes\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:20.765991",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "487/B",
      "title": "B. Strip",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, s, l (1 ≤ n ≤ 105, 0 ≤ s ≤ 109, 1 ≤ l ≤ 105).The second line contains n integers ai separated by spaces ( - 109 ≤ ai ≤ 109).",
      "output_spec": "OutputOutput the minimal number of strip pieces.If there are no ways to split the strip, output -1.",
      "sample_tests": "ExamplesInputCopy7 2 21 3 1 2 4 1 2OutputCopy3InputCopy7 2 21 100 1 100 1 100 1OutputCopy-1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, s, l (1 ≤ n ≤ 105, 0 ≤ s ≤ 109, 1 ≤ l ≤ 105).The second line contains n integers ai separated by spaces ( - 109 ≤ ai ≤ 109).\n\nOutputOutput the minimal number of strip pieces.If there are no ways to split the strip, output -1.\n\nInputCopy7 2 21 3 1 2 4 1 2OutputCopy3InputCopy7 2 21 100 1 100 1 100 1OutputCopy-1\n\nInputCopy7 2 21 3 1 2 4 1 2\n\nOutputCopy3\n\nInputCopy7 2 21 100 1 100 1 100 1\n\nOutputCopy-1\n\nNoteFor the first sample, we can split the strip into 3 pieces: [1, 3, 1], [2, 4], [1, 2].For the second sample, we can't let 1 and 100 be on the same piece, so no solution exists.",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 487\\s*B"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    int l = opt<int>(\"l\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int minAi = -1000000000;\n    const int maxAi = 1000000000;\n\n    vector<int> ai(n);\n    if (type == \"all_equal\") {\n        int val = rnd.next(minAi, maxAi);\n        for (int i = 0; i < n; ++i)\n            ai[i] = val;\n    } else if (type == \"increasing_sequence\") {\n        int start = rnd.next(minAi, maxAi - n);\n        for (int i = 0; i < n; ++i)\n            ai[i] = start + i;\n    } else if (type == \"decreasing_sequence\") {\n        int start = rnd.next(minAi + n, maxAi);\n        for (int i = 0; i < n; ++i)\n            ai[i] = start - i;\n    } else if (type == \"alternating_big_small\") {\n        int val1 = minAi;\n        int val2 = maxAi;\n        for (int i = 0; i < n; ++i)\n            ai[i] = (i % 2 == 0) ? val1 : val2;\n    } else if (type == \"max_splits\") {\n        // Each group of size l has values within s range, but between groups differ by more than s\n        int64_t delta = (int64_t)(s + 1); // s >= 0\n        int64_t base = minAi + delta; // Start from minAi + delta to avoid underflow\n        for (int i = 0; i < n; ++i) {\n            int group = i / l;\n            ai[i] = base + group * delta;\n            // Keep ai[i] within bounds\n            if (ai[i] > maxAi) ai[i] = maxAi;\n            if (ai[i] < minAi) ai[i] = minAi;\n        }\n    } else if (type == \"no_solution\") {\n        // Difference between any l elements exceeds s\n        int64_t delta = (int64_t)(s + 1); // s >= 0\n        int64_t base = minAi;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = base + i * delta;\n            // Keep ai[i] within bounds\n            if (ai[i] > maxAi) ai[i] = maxAi;\n            if (ai[i] < minAi) ai[i] = minAi;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(minAi, maxAi);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(minAi, maxAi);\n    }\n    // Output\n    printf(\"%d %d %d\\n\", n, s, l);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    int l = opt<int>(\"l\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int minAi = -1000000000;\n    const int maxAi = 1000000000;\n\n    vector<int> ai(n);\n    if (type == \"all_equal\") {\n        int val = rnd.next(minAi, maxAi);\n        for (int i = 0; i < n; ++i)\n            ai[i] = val;\n    } else if (type == \"increasing_sequence\") {\n        int start = rnd.next(minAi, maxAi - n);\n        for (int i = 0; i < n; ++i)\n            ai[i] = start + i;\n    } else if (type == \"decreasing_sequence\") {\n        int start = rnd.next(minAi + n, maxAi);\n        for (int i = 0; i < n; ++i)\n            ai[i] = start - i;\n    } else if (type == \"alternating_big_small\") {\n        int val1 = minAi;\n        int val2 = maxAi;\n        for (int i = 0; i < n; ++i)\n            ai[i] = (i % 2 == 0) ? val1 : val2;\n    } else if (type == \"max_splits\") {\n        // Each group of size l has values within s range, but between groups differ by more than s\n        int64_t delta = (int64_t)(s + 1); // s >= 0\n        int64_t base = minAi + delta; // Start from minAi + delta to avoid underflow\n        for (int i = 0; i < n; ++i) {\n            int group = i / l;\n            ai[i] = base + group * delta;\n            // Keep ai[i] within bounds\n            if (ai[i] > maxAi) ai[i] = maxAi;\n            if (ai[i] < minAi) ai[i] = minAi;\n        }\n    } else if (type == \"no_solution\") {\n        // Difference between any l elements exceeds s\n        int64_t delta = (int64_t)(s + 1); // s >= 0\n        int64_t base = minAi;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = base + i * delta;\n            // Keep ai[i] within bounds\n            if (ai[i] > maxAi) ai[i] = maxAi;\n            if (ai[i] < minAi) ai[i] = minAi;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(minAi, maxAi);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(minAi, maxAi);\n    }\n    // Output\n    printf(\"%d %d %d\\n\", n, s, l);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -s 0 -l 1 -type all_equal\n./gen -n 1 -s 0 -l 1 -type random\n\n# Edge cases for l and s\n./gen -n 10 -s 0 -l 1 -type increasing_sequence\n./gen -n 10 -s 0 -l 1 -type decreasing_sequence\n./gen -n 10 -s 0 -l 1 -type alternating_big_small\n./gen -n 10 -s 0 -l 1 -type all_equal\n\n# l larger than n (invalid case)\n./gen -n 10 -s 1 -l 15 -type random\n\n# s is zero\n./gen -n 100 -s 0 -l 10 -type random\n./gen -n 100 -s 0 -l 10 -type no_solution\n\n# s is very large\n./gen -n 1000 -s 1000000000 -l 100 -type random\n./gen -n 1000 -s 1000000000 -l 100 -type all_equal\n\n# Max n\n./gen -n 100000 -s 50 -l 1 -type random\n./gen -n 100000 -s 50 -l 1000 -type max_splits\n./gen -n 100000 -s 0 -l 1 -type alternating_big_small\n./gen -n 100000 -s 0 -l 100000 -type no_solution\n\n# s causes no possible solution\n./gen -n 50000 -s 0 -l 2 -type increasing_sequence\n./gen -n 50000 -s 0 -l 2 -type no_solution\n\n# l is very large\n./gen -n 100000 -s 1000 -l 100000 -type random\n\n# Random cases\n./gen -n 100000 -s 1000 -l 2 -type random\n./gen -n 100000 -s 1000 -l 50 -type random\n\n# All equal numbers\n./gen -n 100000 -s 0 -l 1 -type all_equal\n./gen -n 100000 -s 0 -l 100000 -type all_equal\n\n# Increasing sequence\n./gen -n 100000 -s 10 -l 1 -type increasing_sequence\n./gen -n 100000 -s 1000000000 -l 1 -type increasing_sequence\n\n# Decreasing sequence\n./gen -n 100000 -s 10 -l 1 -type decreasing_sequence\n./gen -n 100000 -s 1000000000 -l 1 -type decreasing_sequence\n\n# Alternating big small\n./gen -n 100000 -s 0 -l 1 -type alternating_big_small\n./gen -n 100000 -s 1000000000 -l 2 -type alternating_big_small\n\n# Max splits\n./gen -n 99999 -s 0 -l 1 -type max_splits\n./gen -n 100000 -s 1 -l 1000 -type max_splits\n\n# No solution cases\n./gen -n 100000 -s 0 -l 2 -type no_solution\n./gen -n 100000 -s 0 -l 1 -type no_solution\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:22.922103",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "487/C",
      "title": "C. Последовательность частичных произведений",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке ввода записано целое число n (1 ≤ n ≤ 105).",
      "output_spec": "Выходные данныеВ первой строке выведите «YES», если такая последовательность существует, или «NO», если такой последовательности не существует.Если решение существует, то выведите вывести ещё n строк. В i-ой строке надо вывести только число ai. Элементы последовательности должны быть различными целыми положительными числами, не превышающими n.Если решений несколько, можно вывести любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать7Выходные данныеСкопироватьYES1436527Входные данныеСкопировать6Выходные данныеСкопироватьNO",
      "description": "C. Последовательность частичных произведений\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке ввода записано целое число n (1 ≤ n ≤ 105).\n\nВходные данные\n\nВыходные данныеВ первой строке выведите «YES», если такая последовательность существует, или «NO», если такой последовательности не существует.Если решение существует, то выведите вывести ещё n строк. В i-ой строке надо вывести только число ai. Элементы последовательности должны быть различными целыми положительными числами, не превышающими n.Если решений несколько, можно вывести любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать7Выходные данныеСкопироватьYES1436527Входные данныеСкопировать6Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1436527\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере корректной последовательности не существует.",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 487\\s*C"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "1 100 1\n100 100 100\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "1 100 1\n100 100 100\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "1 1 1 100 100 100 1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 14",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 15",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 16",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 17",
          "code": "for( ll a4 = a1; a4 <= 1500; a4 ++ ) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 18",
          "code": "for( ll a4 = 1; a4 <= 1500; a4 ++ ) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n\n    // Read the jury's answer\n    string sAns = ans.readToken();\n    if (sAns != \"YES\" && sAns != \"NO\") {\n        ans.quitf(_fail, \"Jury's answer is neither 'YES' nor 'NO'\");\n    }\n\n    // Read the participant's answer\n    string sOuf = ouf.readToken();\n    if (sOuf != \"YES\" && sOuf != \"NO\") {\n        quitf(_wa, \"First line should be 'YES' or 'NO'\");\n    }\n\n    if (sAns == \"NO\") {\n        // Jury says no solution exists\n        if (sOuf != \"NO\") {\n            quitf(_wa, \"No solution exists, but participant reported 'YES'\");\n        } else {\n            quitf(_ok, \"Correctly reported no solution\");\n        }\n    } else {\n        // Jury says solution exists\n        if (sOuf != \"YES\") {\n            quitf(_wa, \"Solution exists, but participant reported 'NO'\");\n        } else {\n            // Read participant's sequence\n            vector<int> a(n);\n            vector<bool> used(n + 1, false); // For checking permutation of 1..n\n\n            for (int i = 0; i < n; i++) {\n                a[i] = ouf.readInt(1, n);\n                if (used[a[i]]) {\n                    quitf(_wa, \"Number %d occurs more than once in the sequence\", a[i]);\n                }\n                used[a[i]] = true;\n            }\n\n            // Compute prefix products modulo n\n            vector<bool> usedPrefix(n, false); // For checking permutation of 0..n-1\n            long long prod = 1LL;\n            for (int i = 0; i < n; i++) {\n                prod = (prod * a[i]) % n;\n                int val = (int)prod;\n                if (usedPrefix[val]) {\n                    quitf(_wa, \"Prefix product modulo n value %d occurs more than once\", val);\n                }\n                usedPrefix[val] = true;\n            }\n\n            for (int i = 0; i < n; i++) {\n                if (!usedPrefix[i]) {\n                    quitf(_wa, \"Prefix products modulo n do not form a permutation of [0, n - 1]\");\n                }\n            }\n\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nvector<int> primes;\nvector<int> composites;\nvector<int> allNumbers;\n\nvoid sieve(int max_n) {\n    vector<bool> isComposite(max_n + 1, false);\n    isComposite[0] = isComposite[1] = true;\n\n    for (int i = 2; i * i <= max_n; ++i) {\n        if (!isComposite[i]) {\n            for (int j = i * i; j <= max_n; j += i) {\n                isComposite[j] = true;\n            }\n        }\n    }\n    for (int i = 1; i <= max_n; ++i) {\n        if (!isComposite[i])\n            primes.push_back(i);\n        else\n            composites.push_back(i);\n        allNumbers.push_back(i);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int min_n = opt<int>(\"min_n\", 1);\n    int max_n = opt<int>(\"max_n\", MAX_N);\n    string type = opt<string>(\"type\", \"random\");\n    int n_param = opt<int>(\"n\", -1);\n\n    sieve(max_n);\n\n    int n;\n\n    if (n_param != -1) {\n        n = n_param;\n    } else if (type == \"YES\") {\n        // Choose a random prime number between min_n and max_n\n        vector<int> candidatePrimes;\n        for (int p : primes) {\n            if (p >= min_n && p <= max_n)\n                candidatePrimes.push_back(p);\n        }\n        if (candidatePrimes.empty()) {\n            fprintf(stderr, \"No primes in the range [%d, %d]\\n\", min_n, max_n);\n            exit(1);\n        }\n        n = candidatePrimes[rnd.next(candidatePrimes.size())];\n    } else if (type == \"NO\") {\n        // Choose a random composite number between min_n and max_n\n        vector<int> candidateComposites;\n        for (int c : composites) {\n            if (c >= min_n && c <= max_n)\n                candidateComposites.push_back(c);\n        }\n        if (candidateComposites.empty()) {\n            fprintf(stderr, \"No composite numbers in the range [%d, %d]\\n\", min_n, max_n);\n            exit(1);\n        }\n        n = candidateComposites[rnd.next(candidateComposites.size())];\n    } else if (type == \"random\") {\n        n = rnd.next(min_n, max_n);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nvector<int> primes;\nvector<int> composites;\nvector<int> allNumbers;\n\nvoid sieve(int max_n) {\n    vector<bool> isComposite(max_n + 1, false);\n    isComposite[0] = isComposite[1] = true;\n\n    for (int i = 2; i * i <= max_n; ++i) {\n        if (!isComposite[i]) {\n            for (int j = i * i; j <= max_n; j += i) {\n                isComposite[j] = true;\n            }\n        }\n    }\n    for (int i = 1; i <= max_n; ++i) {\n        if (!isComposite[i])\n            primes.push_back(i);\n        else\n            composites.push_back(i);\n        allNumbers.push_back(i);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int min_n = opt<int>(\"min_n\", 1);\n    int max_n = opt<int>(\"max_n\", MAX_N);\n    string type = opt<string>(\"type\", \"random\");\n    int n_param = opt<int>(\"n\", -1);\n\n    sieve(max_n);\n\n    int n;\n\n    if (n_param != -1) {\n        n = n_param;\n    } else if (type == \"YES\") {\n        // Choose a random prime number between min_n and max_n\n        vector<int> candidatePrimes;\n        for (int p : primes) {\n            if (p >= min_n && p <= max_n)\n                candidatePrimes.push_back(p);\n        }\n        if (candidatePrimes.empty()) {\n            fprintf(stderr, \"No primes in the range [%d, %d]\\n\", min_n, max_n);\n            exit(1);\n        }\n        n = candidatePrimes[rnd.next(candidatePrimes.size())];\n    } else if (type == \"NO\") {\n        // Choose a random composite number between min_n and max_n\n        vector<int> candidateComposites;\n        for (int c : composites) {\n            if (c >= min_n && c <= max_n)\n                candidateComposites.push_back(c);\n        }\n        if (candidateComposites.empty()) {\n            fprintf(stderr, \"No composite numbers in the range [%d, %d]\\n\", min_n, max_n);\n            exit(1);\n        }\n        n = candidateComposites[rnd.next(candidateComposites.size())];\n    } else if (type == \"random\") {\n        n = rnd.next(min_n, max_n);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n\n# YES cases with small n\n./gen -type YES -min_n 2 -max_n 10\n./gen -type YES -min_n 2 -max_n 10\n./gen -type YES -min_n 2 -max_n 10\n\n# NO cases with small n\n./gen -type NO -min_n 2 -max_n 10\n./gen -type NO -min_n 2 -max_n 10\n./gen -type NO -min_n 2 -max_n 10\n\n# YES cases with large n\n./gen -type YES -min_n 50000 -max_n 100000\n./gen -type YES -min_n 50000 -max_n 100000\n./gen -type YES -min_n 50000 -max_n 100000\n\n# NO cases with large n\n./gen -type NO -min_n 50000 -max_n 100000\n./gen -type NO -min_n 50000 -max_n 100000\n./gen -type NO -min_n 50000 -max_n 100000\n\n# Random n\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases\n./gen -n 99999\n./gen -n 100000\n./gen -n 99998\n\n# Powers of two\n./gen -n 1024\n./gen -n 4096\n./gen -n 16384\n\n# Large primes\n./gen -n 99991\n./gen -n 99961\n./gen -n 99709\n\n# Small composites\n./gen -n 4\n./gen -n 6\n./gen -n 8\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:25.000900",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "487/D",
      "title": "D. Conveyor Belts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three integers n, m and q (1 ≤ n ≤ 105, 1 ≤ m ≤ 10, 1 ≤ q ≤ 105), separated by a space.Next n lines, each line contains m characters, describing the table. The characters can only be one of \"<^>\".Next q lines, each line describes an event. The format is \"C x y c\" or \"A x y\" (Consecutive elements are separated by a space). It's guaranteed that 1 ≤ x ≤ n, 1 ≤ y ≤ m. c is a character from the set \"<^>\".There are at most 10000 queries of \"C\" type.",
      "output_spec": "OutputFor each event of type \"A\", output two integers tx, ty in a line, separated by a space, denoting the destination of (x, y) is (tx, ty).If there is an infinite loop, you should output tx = ty =  - 1.",
      "sample_tests": "ExamplesInputCopy2 2 3>>^^A 2 1C 1 2 <A 2 1OutputCopy1 3-1 -1InputCopy4 5 7><<^<^<^^>>>>^>>^>>^A 3 1A 2 2C 1 4 <A 3 1C 1 2 ^A 3 1A 2 2OutputCopy0 4-1 -1-1 -10 20 2",
      "description": "D. Conveyor Belts\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains three integers n, m and q (1 ≤ n ≤ 105, 1 ≤ m ≤ 10, 1 ≤ q ≤ 105), separated by a space.Next n lines, each line contains m characters, describing the table. The characters can only be one of \"<^>\".Next q lines, each line describes an event. The format is \"C x y c\" or \"A x y\" (Consecutive elements are separated by a space). It's guaranteed that 1 ≤ x ≤ n, 1 ≤ y ≤ m. c is a character from the set \"<^>\".There are at most 10000 queries of \"C\" type.\n\nOutputFor each event of type \"A\", output two integers tx, ty in a line, separated by a space, denoting the destination of (x, y) is (tx, ty).If there is an infinite loop, you should output tx = ty =  - 1.\n\nInputCopy2 2 3>>^^A 2 1C 1 2 <A 2 1OutputCopy1 3-1 -1InputCopy4 5 7><<^<^<^^>>>>^>>^>>^A 3 1A 2 2C 1 4 <A 3 1C 1 2 ^A 3 1A 2 2OutputCopy0 4-1 -1-1 -10 20 2\n\nInputCopy2 2 3>>^^A 2 1C 1 2 <A 2 1\n\nOutputCopy1 3-1 -1\n\nInputCopy4 5 7><<^<^<^^>>>>^>>^>>^A 3 1A 2 2C 1 4 <A 3 1C 1 2 ^A 3 1A 2 2\n\nOutputCopy0 4-1 -1-1 -10 20 2\n\nNoteFor the first sample:If the bread goes from (2, 1), it will go out of the table at (1, 3).After changing the conveyor belt of (1, 2) to \"<\", when the bread goes from (2, 1) again, it will get stuck at \"><\", so output is ( - 1,  - 1).",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 487\\s*D"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    string allowed_chars = \"<\\\\^>\";\n    string row_pattern = string(\"[\") + allowed_chars + \"]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(row_pattern, \"table_row\");\n        // s.length() == m, and s contains only allowed characters\n    }\n\n    int num_C = 0;\n\n    for (int i = 0; i < q; ++i) {\n        string cmd = inf.readToken(\"[AC]\", \"cmd\");\n\n        if (cmd == \"A\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, m, \"y\");\n            inf.readEoln();\n        } else if (cmd == \"C\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, m, \"y\");\n            inf.readSpace();\n            string c = inf.readToken(\"[<\\\\^>]\", \"c\");\n            inf.readEoln();\n\n            num_C++;\n        } else {\n            ensuref(false, \"Invalid command '%s'\", cmd.c_str());\n        }\n    }\n\n    ensuref(num_C <= 10000, \"Number of 'C' commands (%d) exceeds limit 10000\", num_C);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    string allowed_chars = \"<\\\\^>\";\n    string row_pattern = string(\"[\") + allowed_chars + \"]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(row_pattern, \"table_row\");\n        // s.length() == m, and s contains only allowed characters\n    }\n\n    int num_C = 0;\n\n    for (int i = 0; i < q; ++i) {\n        string cmd = inf.readToken(\"[AC]\", \"cmd\");\n\n        if (cmd == \"A\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, m, \"y\");\n            inf.readEoln();\n        } else if (cmd == \"C\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, m, \"y\");\n            inf.readSpace();\n            string c = inf.readToken(\"[<\\\\^>]\", \"c\");\n            inf.readEoln();\n\n            num_C++;\n        } else {\n            ensuref(false, \"Invalid command '%s'\", cmd.c_str());\n        }\n    }\n\n    ensuref(num_C <= 10000, \"Number of 'C' commands (%d) exceeds limit 10000\", num_C);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    string allowed_chars = \"<\\\\^>\";\n    string row_pattern = string(\"[\") + allowed_chars + \"]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(row_pattern, \"table_row\");\n        // s.length() == m, and s contains only allowed characters\n    }\n\n    int num_C = 0;\n\n    for (int i = 0; i < q; ++i) {\n        string cmd = inf.readToken(\"[AC]\", \"cmd\");\n\n        if (cmd == \"A\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, m, \"y\");\n            inf.readEoln();\n        } else if (cmd == \"C\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, m, \"y\");\n            inf.readSpace();\n            string c = inf.readToken(\"[<\\\\^>]\", \"c\");\n            inf.readEoln();\n\n            num_C++;\n        } else {\n            ensuref(false, \"Invalid command '%s'\", cmd.c_str());\n        }\n    }\n\n    ensuref(num_C <= 10000, \"Number of 'C' commands (%d) exceeds limit 10000\", num_C);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    int c = opt<int>(\"c\", 0); // default number of 'C' events is 0\n    string conveyor_type = opt<string>(\"conveyor_type\", \"random\");\n    string event_type = opt<string>(\"event_type\", \"random\");\n\n    // Constraints check\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 10);\n    ensure(1 <= q && q <= 100000);\n\n    // Initialize grid\n    vector<string> grid(n, string(m, '^')); // default '^'\n\n    if (conveyor_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                int r = rnd.next(3);\n                if (r == 0) grid[i][j] = '<';\n                else if (r == 1) grid[i][j] = '^';\n                else grid[i][j] = '>';\n            }\n        }\n    } else if (conveyor_type == \"all_left\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '<');\n    } else if (conveyor_type == \"all_right\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '>');\n    } else if (conveyor_type == \"all_up\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '^');\n    } else if (conveyor_type == \"point_out\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                if (i == 0)\n                    grid[i][j] = '^'; // top row, belt points up\n                else if (j == 0)\n                    grid[i][j] = '<'; // leftmost column, belt points left\n                else if (j == m - 1)\n                    grid[i][j] = '>'; // rightmost column, belt points right\n                else\n                    grid[i][j] = '^'; // default\n            }\n        }\n    } else if (conveyor_type == \"point_in\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = '^'; // All belts point up\n            }\n        }\n    } else if (conveyor_type == \"cycle\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            if (i % 2 == 0) {\n                for (int j = 0; j < m; ++j) {\n                    if (j != m - 1)\n                        grid[i][j] = '>'; // move right\n                    else\n                        grid[i][j] = '^'; // move up at end\n                }\n            } else {\n                for (int j = m - 1; j >= 0; --j) {\n                    if (j != 0)\n                        grid[i][j] = '<'; // move left\n                    else\n                        grid[i][j] = '^'; // move up at end\n                }\n            }\n        }\n    } else if (conveyor_type == \"spiral\") {\n        // Implement spiral pattern if needed\n        // For simplicity, let's leave it as random\n        // You can add spiral logic here if desired\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                int r = rnd.next(3);\n                if (r == 0) grid[i][j] = '<';\n                else if (r == 1) grid[i][j] = '^';\n                else grid[i][j] = '>';\n            }\n        }\n    }\n\n    // Adjust c (number of 'C' events) if necessary\n    if (c > 10000) c = 10000;\n    if (c > q) c = q; // cannot have more 'C' events than total events\n\n    vector<tuple<string, int, int, char> > events;\n\n    if (event_type == \"random\") {\n        // Generate c 'C' events\n        for (int i = 0; i < c; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            char belt;\n            int r = rnd.next(3);\n            if (r == 0) belt = '<';\n            else if (r == 1) belt = '^';\n            else belt = '>';\n            events.emplace_back(\"C\", x, y, belt);\n        }\n        // Generate q - c 'A' events\n        for (int i = c; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n        // Shuffle events\n        shuffle(events.begin(), events.end());\n    } else if (event_type == \"no_changes\") {\n        // All events are 'A' events\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n    } else if (event_type == \"only_changes\") {\n        // All events are 'C' events\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            char belt;\n            int r = rnd.next(3);\n            if (r == 0) belt = '<';\n            else if (r == 1) belt = '^';\n            else belt = '>';\n            events.emplace_back(\"C\", x, y, belt);\n        }\n    } else if (event_type == \"max_changes\") {\n        // Generate maximum of 10000 'C' events\n        c = min(q, 10000);\n        for (int i = 0; i < c; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            char belt;\n            int r = rnd.next(3);\n            if (r == 0) belt = '<';\n            else if (r == 1) belt = '^';\n            else belt = '>';\n            events.emplace_back(\"C\", x, y, belt);\n        }\n        // Remaining events are 'A'\n        for (int i = c; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n        // Shuffle events\n        shuffle(events.begin(), events.end());\n    } else if (event_type == \"changes_everywhere\") {\n        vector<pair<int, int>> positions;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= m; ++j)\n                positions.push_back({i, j});\n        shuffle(positions.begin(), positions.end());\n        c = min((int)positions.size(), 10000);\n        q = c + 100; // ensure q does not exceed 1e5\n        if (q > 100000) q = 100000;\n\n        for (int i = 0; i < c; ++i) {\n            int x = positions[i].first;\n            int y = positions[i].second;\n            char belt;\n            int r = rnd.next(3);\n            if (r == 0) belt = '<';\n            else if (r == 1) belt = '^';\n            else belt = '>';\n            events.emplace_back(\"C\", x, y, belt);\n        }\n        for (int i = c; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n        shuffle(events.begin(), events.end());\n    } else {\n        // Default: All 'A' events\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    for (auto& e : events) {\n        string type;\n        int x, y;\n        char c;\n        tie(type, x, y, c) = e;\n        if (type == \"A\") {\n            printf(\"A %d %d\\n\", x, y);\n        } else {\n            printf(\"C %d %d %c\\n\", x, y, c);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    int c = opt<int>(\"c\", 0); // default number of 'C' events is 0\n    string conveyor_type = opt<string>(\"conveyor_type\", \"random\");\n    string event_type = opt<string>(\"event_type\", \"random\");\n\n    // Constraints check\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 10);\n    ensure(1 <= q && q <= 100000);\n\n    // Initialize grid\n    vector<string> grid(n, string(m, '^')); // default '^'\n\n    if (conveyor_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                int r = rnd.next(3);\n                if (r == 0) grid[i][j] = '<';\n                else if (r == 1) grid[i][j] = '^';\n                else grid[i][j] = '>';\n            }\n        }\n    } else if (conveyor_type == \"all_left\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '<');\n    } else if (conveyor_type == \"all_right\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '>');\n    } else if (conveyor_type == \"all_up\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '^');\n    } else if (conveyor_type == \"point_out\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                if (i == 0)\n                    grid[i][j] = '^'; // top row, belt points up\n                else if (j == 0)\n                    grid[i][j] = '<'; // leftmost column, belt points left\n                else if (j == m - 1)\n                    grid[i][j] = '>'; // rightmost column, belt points right\n                else\n                    grid[i][j] = '^'; // default\n            }\n        }\n    } else if (conveyor_type == \"point_in\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = '^'; // All belts point up\n            }\n        }\n    } else if (conveyor_type == \"cycle\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            if (i % 2 == 0) {\n                for (int j = 0; j < m; ++j) {\n                    if (j != m - 1)\n                        grid[i][j] = '>'; // move right\n                    else\n                        grid[i][j] = '^'; // move up at end\n                }\n            } else {\n                for (int j = m - 1; j >= 0; --j) {\n                    if (j != 0)\n                        grid[i][j] = '<'; // move left\n                    else\n                        grid[i][j] = '^'; // move up at end\n                }\n            }\n        }\n    } else if (conveyor_type == \"spiral\") {\n        // Implement spiral pattern if needed\n        // For simplicity, let's leave it as random\n        // You can add spiral logic here if desired\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                int r = rnd.next(3);\n                if (r == 0) grid[i][j] = '<';\n                else if (r == 1) grid[i][j] = '^';\n                else grid[i][j] = '>';\n            }\n        }\n    }\n\n    // Adjust c (number of 'C' events) if necessary\n    if (c > 10000) c = 10000;\n    if (c > q) c = q; // cannot have more 'C' events than total events\n\n    vector<tuple<string, int, int, char> > events;\n\n    if (event_type == \"random\") {\n        // Generate c 'C' events\n        for (int i = 0; i < c; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            char belt;\n            int r = rnd.next(3);\n            if (r == 0) belt = '<';\n            else if (r == 1) belt = '^';\n            else belt = '>';\n            events.emplace_back(\"C\", x, y, belt);\n        }\n        // Generate q - c 'A' events\n        for (int i = c; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n        // Shuffle events\n        shuffle(events.begin(), events.end());\n    } else if (event_type == \"no_changes\") {\n        // All events are 'A' events\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n    } else if (event_type == \"only_changes\") {\n        // All events are 'C' events\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            char belt;\n            int r = rnd.next(3);\n            if (r == 0) belt = '<';\n            else if (r == 1) belt = '^';\n            else belt = '>';\n            events.emplace_back(\"C\", x, y, belt);\n        }\n    } else if (event_type == \"max_changes\") {\n        // Generate maximum of 10000 'C' events\n        c = min(q, 10000);\n        for (int i = 0; i < c; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            char belt;\n            int r = rnd.next(3);\n            if (r == 0) belt = '<';\n            else if (r == 1) belt = '^';\n            else belt = '>';\n            events.emplace_back(\"C\", x, y, belt);\n        }\n        // Remaining events are 'A'\n        for (int i = c; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n        // Shuffle events\n        shuffle(events.begin(), events.end());\n    } else if (event_type == \"changes_everywhere\") {\n        vector<pair<int, int>> positions;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= m; ++j)\n                positions.push_back({i, j});\n        shuffle(positions.begin(), positions.end());\n        c = min((int)positions.size(), 10000);\n        q = c + 100; // ensure q does not exceed 1e5\n        if (q > 100000) q = 100000;\n\n        for (int i = 0; i < c; ++i) {\n            int x = positions[i].first;\n            int y = positions[i].second;\n            char belt;\n            int r = rnd.next(3);\n            if (r == 0) belt = '<';\n            else if (r == 1) belt = '^';\n            else belt = '>';\n            events.emplace_back(\"C\", x, y, belt);\n        }\n        for (int i = c; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n        shuffle(events.begin(), events.end());\n    } else {\n        // Default: All 'A' events\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            events.emplace_back(\"A\", x, y, '-');\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    for (auto& e : events) {\n        string type;\n        int x, y;\n        char c;\n        tie(type, x, y, c) = e;\n        if (type == \"A\") {\n            printf(\"A %d %d\\n\", x, y);\n        } else {\n            printf(\"C %d %d %c\\n\", x, y, c);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -q 1 -conveyor_type all_up -event_type no_changes\n./gen -n 10 -m 5 -q 10 -conveyor_type random -event_type random\n./gen -n 1000 -m 10 -q 1000 -conveyor_type random -event_type no_changes\n./gen -n 100000 -m 10 -q 100000 -conveyor_type random -event_type no_changes\n./gen -n 100000 -m 10 -q 100000 -conveyor_type point_out -event_type no_changes\n./gen -n 100000 -m 1 -q 100000 -conveyor_type point_in -event_type random -c 10000\n./gen -n 50000 -m 10 -q 100000 -conveyor_type cycle -event_type random -c 10000\n./gen -n 100000 -m 10 -q 100000 -conveyor_type point_in -event_type max_changes\n./gen -n 100000 -m 10 -q 100000 -conveyor_type random -event_type changes_everywhere\n./gen -n 100000 -m 10 -q 100000 -conveyor_type all_left -event_type random -c 10000\n./gen -n 1 -m 10 -q 10 -conveyor_type spiral -event_type only_changes\n./gen -n 1 -m 10 -q 100000 -conveyor_type random -event_type no_changes\n./gen -n 1 -m 1 -q 100000 -conveyor_type random -event_type no_changes\n./gen -n 100 -m 10 -q 10000 -conveyor_type point_in -event_type max_changes\n./gen -n 100000 -m 1 -q 100000 -conveyor_type random -event_type random -c 10000\n./gen -n 100000 -m 10 -q 100000 -conveyor_type random -event_type random -c 10000\n./gen -n 100000 -m 10 -q 100000 -conveyor_type random -event_type random\n./gen -n 99999 -m 10 -q 100000 -conveyor_type random -event_type random -c 9999\n./gen -n 100000 -m 10 -q 100000 -conveyor_type random -event_type changes_everywhere\n./gen -n 100000 -m 10 -q 100000 -conveyor_type point_in -event_type max_changes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:26.915486",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "487/E",
      "title": "E. Туристы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входного файла записано три разделённых пробелами целых числа n, m, q (1 ≤ n, m, q ≤ 105).В следующих n строках записаны целые числа wi (1 ≤ wi ≤ 109).В следующих m строках записано по два разделённых пробелами целых числа, aj и bj (1 ≤ aj, bj ≤ n, aj ≠ bj).Одна и та же пара городов соединяется не более чем одной дорогой. Между любыми двумя городами всегда есть по крайней мере один корректный путь.Далее следует q строк, в каждой из которых записано по запросу. Формат строки: \"C a w\" или \"A a b\" (1 ≤ a, b ≤ n, 1 ≤ w ≤ 109).",
      "output_spec": "Выходные данныеДля каждого запроса типа \"A\" выведите соответствующий ответ.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3 31231 22 31 3A 2 3C 1 5A 2 3Выходные данныеСкопировать12Входные данныеСкопировать7 9 412345671 22 51 52 33 42 45 66 75 7A 2 3A 6 4A 6 7A 3 3Выходные данныеСкопировать2153",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входного файла записано три разделённых пробелами целых числа n, m, q (1 ≤ n, m, q ≤ 105).В следующих n строках записаны целые числа wi (1 ≤ wi ≤ 109).В следующих m строках записано по два разделённых пробелами целых числа, aj и bj (1 ≤ aj, bj ≤ n, aj ≠ bj).Одна и та же пара городов соединяется не более чем одной дорогой. Между любыми двумя городами всегда есть по крайней мере один корректный путь.Далее следует q строк, в каждой из которых записано по запросу. Формат строки: \"C a w\" или \"A a b\" (1 ≤ a, b ≤ n, 1 ≤ w ≤ 109).\n\nВходные данные\n\nВыходные данныеДля каждого запроса типа \"A\" выведите соответствующий ответ.\n\nВыходные данные\n\nВходные данныеСкопировать3 3 31231 22 31 3A 2 3C 1 5A 2 3Выходные данныеСкопировать12Входные данныеСкопировать7 9 412345671 22 51 52 33 42 45 66 75 7A 2 3A 6 4A 6 7A 3 3Выходные данныеСкопировать2153\n\nВходные данныеСкопировать3 3 31231 22 31 3A 2 3C 1 5A 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 9 412345671 22 51 52 33 42 45 66 75 7A 2 3A 6 4A 6 7A 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2153\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере оптимальные пути таковы:Из 2 в 3 — [2, 3].Из 6 в 4 — [6, 5, 1, 2, 4].Из 6 в 7 — [6, 5, 7].Из 3 в 3 — [3].",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 487\\s*E"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "1 100 1\n100 100 100\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "1 100 1\n100 100 100\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "1 1 1 100 100 100 1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 14",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 15",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 16",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 17",
          "code": "for( ll a4 = a1; a4 <= 1500; a4 ++ ) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 18",
          "code": "for( ll a4 = 1; a4 <= 1500; a4 ++ ) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> w(n + 1); // 1-based indexing\n\n    for (int i = 1; i <= n; ++i) {\n        w[i] = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"aj\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bj\");\n        inf.readEoln();\n        ensuref(a != b, \"Cities aj and bj must be different (%d)\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.count({u, v}) == 0, \"Duplicate road between cities %d and %d\", u, v);\n        edges.insert({u, v});\n    }\n\n    // Check that the graph is connected\n    vector<int> parent(n + 1);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    for (const auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) parent[pu] = pv;\n    }\n\n    int comp = find(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(find(i) == comp, \"The graph is not connected\");\n    }\n\n    for (int i = 0; i < q; ++i) {\n        string line = inf.readLine(\"^[AC] [1-9][0-9]* [1-9][0-9]*$\");\n        istringstream iss(line);\n        string type;\n        int a;\n        iss >> type >> a;\n        ensuref(1 <= a && a <= n, \"Invalid 'a' in query %d: %d\", i + 1, a);\n        if (type == \"C\") {\n            int w;\n            iss >> w;\n            ensuref(1 <= w && w <= 1000000000, \"Invalid 'w' in query %d: %d\", i + 1, w);\n        } else if (type == \"A\") {\n            int b;\n            iss >> b;\n            ensuref(1 <= b && b <= n, \"Invalid 'b' in query %d: %d\", i + 1, b);\n        } else {\n            ensuref(false, \"Invalid query type '%s' in query %d\", type.c_str(), i + 1);\n        }\n        string extra;\n        if (iss >> extra) {\n            ensuref(false, \"Extra data in query line %d: '%s'\", i + 1, extra.c_str());\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> w(n + 1); // 1-based indexing\n\n    for (int i = 1; i <= n; ++i) {\n        w[i] = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"aj\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bj\");\n        inf.readEoln();\n        ensuref(a != b, \"Cities aj and bj must be different (%d)\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.count({u, v}) == 0, \"Duplicate road between cities %d and %d\", u, v);\n        edges.insert({u, v});\n    }\n\n    // Check that the graph is connected\n    vector<int> parent(n + 1);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    for (const auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) parent[pu] = pv;\n    }\n\n    int comp = find(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(find(i) == comp, \"The graph is not connected\");\n    }\n\n    for (int i = 0; i < q; ++i) {\n        string line = inf.readLine(\"^[AC] [1-9][0-9]* [1-9][0-9]*$\");\n        istringstream iss(line);\n        string type;\n        int a;\n        iss >> type >> a;\n        ensuref(1 <= a && a <= n, \"Invalid 'a' in query %d: %d\", i + 1, a);\n        if (type == \"C\") {\n            int w;\n            iss >> w;\n            ensuref(1 <= w && w <= 1000000000, \"Invalid 'w' in query %d: %d\", i + 1, w);\n        } else if (type == \"A\") {\n            int b;\n            iss >> b;\n            ensuref(1 <= b && b <= n, \"Invalid 'b' in query %d: %d\", i + 1, b);\n        } else {\n            ensuref(false, \"Invalid query type '%s' in query %d\", type.c_str(), i + 1);\n        }\n        string extra;\n        if (iss >> extra) {\n            ensuref(false, \"Extra data in query line %d: '%s'\", i + 1, extra.c_str());\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> w(n + 1); // 1-based indexing\n\n    for (int i = 1; i <= n; ++i) {\n        w[i] = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"aj\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bj\");\n        inf.readEoln();\n        ensuref(a != b, \"Cities aj and bj must be different (%d)\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.count({u, v}) == 0, \"Duplicate road between cities %d and %d\", u, v);\n        edges.insert({u, v});\n    }\n\n    // Check that the graph is connected\n    vector<int> parent(n + 1);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    for (const auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) parent[pu] = pv;\n    }\n\n    int comp = find(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(find(i) == comp, \"The graph is not connected\");\n    }\n\n    for (int i = 0; i < q; ++i) {\n        string line = inf.readLine(\"^[AC] [1-9][0-9]* [1-9][0-9]*$\");\n        istringstream iss(line);\n        string type;\n        int a;\n        iss >> type >> a;\n        ensuref(1 <= a && a <= n, \"Invalid 'a' in query %d: %d\", i + 1, a);\n        if (type == \"C\") {\n            int w;\n            iss >> w;\n            ensuref(1 <= w && w <= 1000000000, \"Invalid 'w' in query %d: %d\", i + 1, w);\n        } else if (type == \"A\") {\n            int b;\n            iss >> b;\n            ensuref(1 <= b && b <= n, \"Invalid 'b' in query %d: %d\", i + 1, b);\n        } else {\n            ensuref(false, \"Invalid query type '%s' in query %d\", type.c_str(), i + 1);\n        }\n        string extra;\n        if (iss >> extra) {\n            ensuref(false, \"Extra data in query line %d: '%s'\", i + 1, extra.c_str());\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string graphType = opt<string>(\"graphType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n    int minW = opt<int>(\"minW\",1);\n    int maxW = opt<int>(\"maxW\",1000000000);\n\n    // Generate wi\n    vector<int> w(n+1); // 1-based indexing\n    for (int i = 1; i <= n; ++i) {\n        w[i] = rnd.next(minW, maxW);\n    }\n\n    // Generate the graph\n    vector<pair<int,int>> edges;\n    if (graphType == \"random\") {\n        // Generate a random connected graph\n        // Use a random spanning tree to ensure connectedness, then add random edges\n\n        vector<int> parent(n+1);\n        parent[1] = -1; // root\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n\n        // Now add extra random edges to reach m\n        set<pair<int,int>> usedEdges(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (usedEdges.count({u, v})) continue;\n            edges.push_back({u, v});\n            usedEdges.insert({u, v});\n        }\n    } else if (graphType == \"path\") {\n        // Create a path from 1 to n\n        for(int i = 1; i < n; ++i)\n            edges.push_back({i, i+1});\n        // Add additional edges if m > n-1\n        set<pair<int,int>> usedEdges(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (usedEdges.count({u, v})) continue;\n            edges.push_back({u, v});\n            usedEdges.insert({u, v});\n        }\n    } else if (graphType == \"star\") {\n        // Connect all nodes to node 1\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n        // Add additional edges if m > n-1\n        set<pair<int,int>> usedEdges(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (usedEdges.count({u, v})) continue;\n            edges.push_back({u, v});\n            usedEdges.insert({u, v});\n        }\n    } else if (graphType == \"complete\") {\n        // For small n, generate complete graph\n        if (n*(n-1)/2 < m) {\n            fprintf(stderr, \"Cannot generate complete graph with given m\\n\");\n            exit(1);\n        }\n        for (int u = 1; u <= n; ++u)\n            for (int v = u+1; v <= n; ++v)\n                edges.push_back({u, v});\n        // Shuffle and pick first m edges\n        shuffle(edges.begin(), edges.end());\n        edges.resize(m);\n    } else if (graphType == \"tree\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i-1);\n            edges.push_back({u, i});\n        }\n        // m must be n-1\n        if (m != n-1) {\n            fprintf(stderr, \"For tree, m must be n-1\\n\");\n            exit(1);\n        }\n    } else if (graphType == \"grid\") {\n        // For n close to a square number\n        int s = sqrt(n);\n        if (s*s != n) {\n            fprintf(stderr, \"n should be perfect square for grid\\n\");\n            exit(1);\n        }\n        vector<vector<int>> grid(s, vector<int>(s));\n        int cnt = 1;\n        for (int i = 0; i < s; ++i)\n            for (int j = 0; j < s; ++j)\n                grid[i][j] = cnt++;\n        for (int i = 0; i < s; ++i)\n            for (int j = 0; j < s; ++j) {\n                if (i+1 < s) edges.push_back({grid[i][j], grid[i+1][j]});\n                if (j+1 < s) edges.push_back({grid[i][j], grid[i][j+1]});\n            }\n        // Shuffle edges and pick first m edges\n        shuffle(edges.begin(), edges.end());\n        if ((int)edges.size() > m)\n            edges.resize(m);\n    } else {\n        fprintf(stderr, \"Unknown graph type: %s\\n\", graphType.c_str());\n        exit(1);\n    }\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output wi\n    for (int i = 1; i <= n; ++i)\n        printf(\"%d\\n\", w[i]);\n\n    // Output edges\n    for (auto e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n\n    // Generate queries\n    vector<string> queries;\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(2);\n            if (type == 0) {\n                // \"C a w\"\n                int a = rnd.next(1, n);\n                int w_new = rnd.next(minW, maxW);\n                queries.push_back(\"C \" + to_string(a) + \" \" + to_string(w_new));\n            } else {\n                // \"A a b\"\n                int a = rnd.next(1, n);\n                int b = rnd.next(1, n);\n                queries.push_back(\"A \" + to_string(a) + \" \" + to_string(b));\n            }\n        }\n    } else if (queryType == \"updatesOnly\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int w_new = rnd.next(minW, maxW);\n            queries.push_back(\"C \" + to_string(a) + \" \" + to_string(w_new));\n        }\n    } else if (queryType == \"queriesOnly\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back(\"A \" + to_string(a) + \" \" + to_string(b));\n        }\n    } else if (queryType == \"manyUpdates\") {\n        int numUpdates = q * 70 / 100;\n        for (int i = 0; i < numUpdates; ++i) {\n            int a = rnd.next(1, n);\n            int w_new = rnd.next(minW, maxW);\n            queries.push_back(\"C \" + to_string(a) + \" \" + to_string(w_new));\n        }\n        for (int i = numUpdates; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back(\"A \" + to_string(a) + \" \" + to_string(b));\n        }\n    } else if (queryType == \"manyQueries\") {\n        int numQueries = q * 70 / 100;\n        for (int i = 0; i < numQueries; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back(\"A \" + to_string(a) + \" \" + to_string(b));\n        }\n        for (int i = numQueries; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int w_new = rnd.next(minW, maxW);\n            queries.push_back(\"C \" + to_string(a) + \" \" + to_string(w_new));\n        }\n    } else {\n        fprintf(stderr, \"Unknown query type: %s\\n\", queryType.c_str());\n        exit(1);\n    }\n\n    // Output queries\n    for (auto s : queries)\n        printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string graphType = opt<string>(\"graphType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n    int minW = opt<int>(\"minW\",1);\n    int maxW = opt<int>(\"maxW\",1000000000);\n\n    // Generate wi\n    vector<int> w(n+1); // 1-based indexing\n    for (int i = 1; i <= n; ++i) {\n        w[i] = rnd.next(minW, maxW);\n    }\n\n    // Generate the graph\n    vector<pair<int,int>> edges;\n    if (graphType == \"random\") {\n        // Generate a random connected graph\n        // Use a random spanning tree to ensure connectedness, then add random edges\n\n        vector<int> parent(n+1);\n        parent[1] = -1; // root\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n\n        // Now add extra random edges to reach m\n        set<pair<int,int>> usedEdges(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (usedEdges.count({u, v})) continue;\n            edges.push_back({u, v});\n            usedEdges.insert({u, v});\n        }\n    } else if (graphType == \"path\") {\n        // Create a path from 1 to n\n        for(int i = 1; i < n; ++i)\n            edges.push_back({i, i+1});\n        // Add additional edges if m > n-1\n        set<pair<int,int>> usedEdges(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (usedEdges.count({u, v})) continue;\n            edges.push_back({u, v});\n            usedEdges.insert({u, v});\n        }\n    } else if (graphType == \"star\") {\n        // Connect all nodes to node 1\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n        // Add additional edges if m > n-1\n        set<pair<int,int>> usedEdges(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (usedEdges.count({u, v})) continue;\n            edges.push_back({u, v});\n            usedEdges.insert({u, v});\n        }\n    } else if (graphType == \"complete\") {\n        // For small n, generate complete graph\n        if (n*(n-1)/2 < m) {\n            fprintf(stderr, \"Cannot generate complete graph with given m\\n\");\n            exit(1);\n        }\n        for (int u = 1; u <= n; ++u)\n            for (int v = u+1; v <= n; ++v)\n                edges.push_back({u, v});\n        // Shuffle and pick first m edges\n        shuffle(edges.begin(), edges.end());\n        edges.resize(m);\n    } else if (graphType == \"tree\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i-1);\n            edges.push_back({u, i});\n        }\n        // m must be n-1\n        if (m != n-1) {\n            fprintf(stderr, \"For tree, m must be n-1\\n\");\n            exit(1);\n        }\n    } else if (graphType == \"grid\") {\n        // For n close to a square number\n        int s = sqrt(n);\n        if (s*s != n) {\n            fprintf(stderr, \"n should be perfect square for grid\\n\");\n            exit(1);\n        }\n        vector<vector<int>> grid(s, vector<int>(s));\n        int cnt = 1;\n        for (int i = 0; i < s; ++i)\n            for (int j = 0; j < s; ++j)\n                grid[i][j] = cnt++;\n        for (int i = 0; i < s; ++i)\n            for (int j = 0; j < s; ++j) {\n                if (i+1 < s) edges.push_back({grid[i][j], grid[i+1][j]});\n                if (j+1 < s) edges.push_back({grid[i][j], grid[i][j+1]});\n            }\n        // Shuffle edges and pick first m edges\n        shuffle(edges.begin(), edges.end());\n        if ((int)edges.size() > m)\n            edges.resize(m);\n    } else {\n        fprintf(stderr, \"Unknown graph type: %s\\n\", graphType.c_str());\n        exit(1);\n    }\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output wi\n    for (int i = 1; i <= n; ++i)\n        printf(\"%d\\n\", w[i]);\n\n    // Output edges\n    for (auto e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n\n    // Generate queries\n    vector<string> queries;\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(2);\n            if (type == 0) {\n                // \"C a w\"\n                int a = rnd.next(1, n);\n                int w_new = rnd.next(minW, maxW);\n                queries.push_back(\"C \" + to_string(a) + \" \" + to_string(w_new));\n            } else {\n                // \"A a b\"\n                int a = rnd.next(1, n);\n                int b = rnd.next(1, n);\n                queries.push_back(\"A \" + to_string(a) + \" \" + to_string(b));\n            }\n        }\n    } else if (queryType == \"updatesOnly\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int w_new = rnd.next(minW, maxW);\n            queries.push_back(\"C \" + to_string(a) + \" \" + to_string(w_new));\n        }\n    } else if (queryType == \"queriesOnly\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back(\"A \" + to_string(a) + \" \" + to_string(b));\n        }\n    } else if (queryType == \"manyUpdates\") {\n        int numUpdates = q * 70 / 100;\n        for (int i = 0; i < numUpdates; ++i) {\n            int a = rnd.next(1, n);\n            int w_new = rnd.next(minW, maxW);\n            queries.push_back(\"C \" + to_string(a) + \" \" + to_string(w_new));\n        }\n        for (int i = numUpdates; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back(\"A \" + to_string(a) + \" \" + to_string(b));\n        }\n    } else if (queryType == \"manyQueries\") {\n        int numQueries = q * 70 / 100;\n        for (int i = 0; i < numQueries; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back(\"A \" + to_string(a) + \" \" + to_string(b));\n        }\n        for (int i = numQueries; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int w_new = rnd.next(minW, maxW);\n            queries.push_back(\"C \" + to_string(a) + \" \" + to_string(w_new));\n        }\n    } else {\n        fprintf(stderr, \"Unknown query type: %s\\n\", queryType.c_str());\n        exit(1);\n    }\n\n    // Output queries\n    for (auto s : queries)\n        printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 9 -q 10 -graphType random -queryType random\n./gen -n 10 -m 9 -q 10 -graphType path -queryType random\n./gen -n 10 -m 9 -q 10 -graphType star -queryType random\n./gen -n 10 -m 45 -q 10 -graphType complete -queryType random\n\n./gen -n 100 -m 99 -q 100 -graphType path -queryType random\n./gen -n 100 -m 99 -q 100 -graphType star -queryType random\n./gen -n 100 -m 99 -q 100 -graphType tree -queryType random\n\n./gen -n 1000 -m 1000 -q 1000 -graphType random -queryType random\n./gen -n 1000 -m 999 -q 1000 -graphType path -queryType random\n./gen -n 1000 -m 999 -q 1000 -graphType star -queryType random\n\n./gen -n 10000 -m 10000 -q 10000 -graphType random -queryType random\n./gen -n 10000 -m 9999 -q 10000 -graphType path -queryType random\n\n./gen -n 100000 -m 100000 -q 100000 -graphType random -queryType random\n./gen -n 100000 -m 100000 -q 100000 -graphType random -queryType manyUpdates\n./gen -n 100000 -m 100000 -q 100000 -graphType random -queryType manyQueries\n\n./gen -n 100000 -m 99999 -q 100000 -graphType path -queryType random\n./gen -n 100000 -m 99999 -q 100000 -graphType path -queryType manyQueries\n\n./gen -n 100000 -m 100000 -q 100000 -graphType star -queryType random\n\n./gen -n 100000 -m 100000 -q 50000 -graphType random -queryType random -minW 1 -maxW 1\n\n./gen -n 100000 -m 100000 -q 50000 -graphType random -queryType random -minW 1000000000 -maxW 1000000000\n\n./gen -n 100000 -m 100000 -q 100000 -graphType random -queryType updatesOnly\n\n./gen -n 100000 -m 100000 -q 100000 -graphType random -queryType queriesOnly\n\n./gen -n 10000 -m 20000 -q 10000 -graphType grid -queryType random\n\n./gen -n 1 -m 0 -q 100 -graphType star -queryType random\n\n./gen -n 500 -m 124750 -q 1000 -graphType complete -queryType random\n\n./gen -n 100000 -m 100000 -q 50000 -graphType random -queryType random -minW 1 -maxW 10\n\n./gen -n 100000 -m 100000 -q 50000 -graphType random -queryType random -minW 999999990 -maxW 1000000000\n\n./gen -n 2 -m 1 -q 10 -graphType random -queryType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:28.606626",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "488/A",
      "title": "A. Giga Tower",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains an integer a ( - 109 ≤ a ≤ 109).",
      "output_spec": "OutputPrint the minimum b in a line.",
      "sample_tests": "ExamplesInputCopy179OutputCopy1InputCopy-1OutputCopy9InputCopy18OutputCopy10",
      "description": "A. Giga Tower\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line of input contains an integer a ( - 109 ≤ a ≤ 109).\n\nOutputPrint the minimum b in a line.\n\nInputCopy179OutputCopy1InputCopy-1OutputCopy9InputCopy18OutputCopy10\n\nInputCopy179\n\nOutputCopy1\n\nInputCopy-1\n\nOutputCopy9\n\nInputCopy18\n\nOutputCopy10\n\nNoteFor the first sample, he has to arrive at the floor numbered 180.For the second sample, he will arrive at 8.Note that b should be positive, so the answer for the third sample is 10, not 0.",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 488\\s*A"
          },
          "content_length": 7236
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 488\\s*A"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\", \"random\");\n\n    int a; // the value to output\n\n    if (type == \"random\") {\n        // generate random a in valid range\n        a = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"max\") {\n        a = 1000000000;\n    } else if (type == \"min\") {\n        a = -1000000000;\n    } else if (type == \"lucky\") {\n        // generate a number containing '8' within the constraints\n        while (true) {\n            a = rnd.next(-1000000000, 1000000000);\n            if (to_string(abs(a)).find('8') != string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"unlucky\") {\n        // generate a number not containing '8' within the constraints\n        while (true) {\n            a = rnd.next(-1000000000, 1000000000);\n            if (to_string(abs(a)).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"before_lucky\") {\n        // Generate a number just before a lucky floor\n        int lucky_a;\n        // Generate a random lucky number\n        while (true) {\n            lucky_a = rnd.next(-1000000000 + 1, 1000000000);\n            if (to_string(abs(lucky_a)).find('8') != string::npos) {\n                break;\n            }\n        }\n        // Now find a number before lucky_a that is unlucky\n        for (int k = 1; k <= 100; ++k) {\n            a = lucky_a - k;\n            if (a >= -1000000000 && a <= 1000000000 && to_string(abs(a)).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"after_lucky\") {\n        // Generate a number just after a lucky floor\n        int lucky_a;\n        // Generate a random lucky number\n        while (true) {\n            lucky_a = rnd.next(-1000000000, 1000000000 - 1);\n            if (to_string(abs(lucky_a)).find('8') != string::npos) {\n                break;\n            }\n        }\n        // Now find a number after lucky_a that is unlucky\n        for (int k = 1; k <= 100; ++k) {\n            a = lucky_a + k;\n            if (a >= -1000000000 && a <= 1000000000 && to_string(abs(a)).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"max_unlucky\") {\n        // The maximum a that does not contain '8'\n        a = 1000000000;\n        while (to_string(abs(a)).find('8') != string::npos) {\n            --a;\n        }\n    } else if (type == \"min_unlucky\") {\n        // The minimum a that does not contain '8'\n        a = -1000000000;\n        while (to_string(abs(a)).find('8') != string::npos) {\n            ++a;\n        }\n    } else if (type == \"zero\") {\n        a = 0;\n    } else if (type == \"positive_lucky\") {\n        // Generate positive lucky a\n        while (true) {\n            a = rnd.next(1, 1000000000);\n            if (to_string(a).find('8') != string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"negative_lucky\") {\n        // Generate negative lucky a\n        while (true) {\n            a = rnd.next(-1000000000, -1);\n            if (to_string(-a).find('8') != string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"positive_unlucky\") {\n        // Generate positive unlucky a\n        while (true) {\n            a = rnd.next(1, 1000000000);\n            if (to_string(a).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"negative_unlucky\") {\n        // Generate negative unlucky a\n        while (true) {\n            a = rnd.next(-1000000000, -1);\n            if (to_string(-a).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"boundary\") {\n        // Generate test cases at boundaries\n        a = rnd.next(2) ? 1000000000 : -1000000000;\n    } else {\n        // Default to random\n        a = rnd.next(-1000000000, 1000000000);\n    }\n\n    // Output 'a'\n    printf(\"%d\\n\", a);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\", \"random\");\n\n    int a; // the value to output\n\n    if (type == \"random\") {\n        // generate random a in valid range\n        a = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"max\") {\n        a = 1000000000;\n    } else if (type == \"min\") {\n        a = -1000000000;\n    } else if (type == \"lucky\") {\n        // generate a number containing '8' within the constraints\n        while (true) {\n            a = rnd.next(-1000000000, 1000000000);\n            if (to_string(abs(a)).find('8') != string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"unlucky\") {\n        // generate a number not containing '8' within the constraints\n        while (true) {\n            a = rnd.next(-1000000000, 1000000000);\n            if (to_string(abs(a)).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"before_lucky\") {\n        // Generate a number just before a lucky floor\n        int lucky_a;\n        // Generate a random lucky number\n        while (true) {\n            lucky_a = rnd.next(-1000000000 + 1, 1000000000);\n            if (to_string(abs(lucky_a)).find('8') != string::npos) {\n                break;\n            }\n        }\n        // Now find a number before lucky_a that is unlucky\n        for (int k = 1; k <= 100; ++k) {\n            a = lucky_a - k;\n            if (a >= -1000000000 && a <= 1000000000 && to_string(abs(a)).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"after_lucky\") {\n        // Generate a number just after a lucky floor\n        int lucky_a;\n        // Generate a random lucky number\n        while (true) {\n            lucky_a = rnd.next(-1000000000, 1000000000 - 1);\n            if (to_string(abs(lucky_a)).find('8') != string::npos) {\n                break;\n            }\n        }\n        // Now find a number after lucky_a that is unlucky\n        for (int k = 1; k <= 100; ++k) {\n            a = lucky_a + k;\n            if (a >= -1000000000 && a <= 1000000000 && to_string(abs(a)).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"max_unlucky\") {\n        // The maximum a that does not contain '8'\n        a = 1000000000;\n        while (to_string(abs(a)).find('8') != string::npos) {\n            --a;\n        }\n    } else if (type == \"min_unlucky\") {\n        // The minimum a that does not contain '8'\n        a = -1000000000;\n        while (to_string(abs(a)).find('8') != string::npos) {\n            ++a;\n        }\n    } else if (type == \"zero\") {\n        a = 0;\n    } else if (type == \"positive_lucky\") {\n        // Generate positive lucky a\n        while (true) {\n            a = rnd.next(1, 1000000000);\n            if (to_string(a).find('8') != string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"negative_lucky\") {\n        // Generate negative lucky a\n        while (true) {\n            a = rnd.next(-1000000000, -1);\n            if (to_string(-a).find('8') != string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"positive_unlucky\") {\n        // Generate positive unlucky a\n        while (true) {\n            a = rnd.next(1, 1000000000);\n            if (to_string(a).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"negative_unlucky\") {\n        // Generate negative unlucky a\n        while (true) {\n            a = rnd.next(-1000000000, -1);\n            if (to_string(-a).find('8') == string::npos) {\n                break;\n            }\n        }\n    } else if (type == \"boundary\") {\n        // Generate test cases at boundaries\n        a = rnd.next(2) ? 1000000000 : -1000000000;\n    } else {\n        // Default to random\n        a = rnd.next(-1000000000, 1000000000);\n    }\n\n    // Output 'a'\n    printf(\"%d\\n\", a);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type max\n./gen -type min\n./gen -type zero\n./gen -type lucky\n./gen -type lucky\n./gen -type unlucky\n./gen -type unlucky\n./gen -type positive_lucky\n./gen -type negative_lucky\n./gen -type positive_unlucky\n./gen -type negative_unlucky\n./gen -type before_lucky\n./gen -type after_lucky\n./gen -type before_lucky\n./gen -type after_lucky\n./gen -type boundary\n./gen -type boundary\n./gen -type max_unlucky\n./gen -type min_unlucky\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:30.636272",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "488/B",
      "title": "B. Candy Boxes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an only integer n (0 ≤ n ≤ 4).The next n lines contain integers ai, denoting the number of candies in the i-th box (1 ≤ ai ≤ 500).",
      "output_spec": "OutputIn the first output line, print \"YES\" if a solution exists, or print \"NO\" if there is no solution.If a solution exists, you should output 4 - n more lines, each line containing an integer b, denoting the number of candies in a missing box.All your numbers b must satisfy inequality 1 ≤ b ≤ 106. It is guaranteed that if there exists a positive integer solution, you can always find such b's meeting the condition. If there are multiple answers, you are allowed to print any of them.Given numbers ai may follow in any order in the input, not necessary in non-decreasing.ai may have stood at any positions in the original set, not necessary on lowest n first positions.",
      "sample_tests": "ExamplesInputCopy211OutputCopyYES33InputCopy3111OutputCopyNOInputCopy41223OutputCopyYES",
      "description": "B. Candy Boxes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an only integer n (0 ≤ n ≤ 4).The next n lines contain integers ai, denoting the number of candies in the i-th box (1 ≤ ai ≤ 500).\n\nOutputIn the first output line, print \"YES\" if a solution exists, or print \"NO\" if there is no solution.If a solution exists, you should output 4 - n more lines, each line containing an integer b, denoting the number of candies in a missing box.All your numbers b must satisfy inequality 1 ≤ b ≤ 106. It is guaranteed that if there exists a positive integer solution, you can always find such b's meeting the condition. If there are multiple answers, you are allowed to print any of them.Given numbers ai may follow in any order in the input, not necessary in non-decreasing.ai may have stood at any positions in the original set, not necessary on lowest n first positions.\n\nInputCopy211OutputCopyYES33InputCopy3111OutputCopyNOInputCopy41223OutputCopyYES\n\nInputCopy211\n\nOutputCopyYES33\n\nInputCopy3111\n\nOutputCopyNO\n\nInputCopy41223\n\nOutputCopyYES\n\nNoteFor the first sample, the numbers of candies in 4 boxes can be 1, 1, 3, 3. The arithmetic mean, the median and the range of them are all 2.For the second sample, it's impossible to find the missing number of candies.In the third example no box has been lost and numbers satisfy the condition.You may output b in any order.",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 488\\s*B"
          },
          "content_length": 7236
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 488\\s*B"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 4, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 500, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 4, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 500, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 4, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 500, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    int n = inf.readInt(0, 4, \"n\");\n    vector<int> ai;\n    for (int i = 0; i < n; i++) {\n        int a_i = inf.readInt(1, 500, format(\"a[%d]\", i+1).c_str());\n        ai.push_back(a_i);\n    }\n\n    // Read jury's answer\n    string juryAns = ans.readToken();\n    if (juryAns != \"YES\" && juryAns != \"NO\") {\n        quitf(_fail, \"Jury's answer is neither YES nor NO\");\n    }\n\n    // Read contestant's answer\n    string userAns = ouf.readToken();\n    if (userAns != \"YES\" && userAns != \"NO\") {\n        quitf(_wa, \"Your answer is neither YES nor NO\");\n    }\n\n    if (juryAns == \"NO\") {\n        if (userAns != \"NO\") {\n            quitf(_wa, \"Correct answer is NO, but your answer is YES\");\n        } else {\n            quitf(_ok, \"Correct answer is NO\");\n        }\n    } else {\n        if (userAns != \"YES\") {\n            quitf(_wa, \"Correct answer is YES, but your answer is NO\");\n        } else {\n            // Read 4 - n integers\n            int missing = 4 - n;\n            vector<int> b;\n            for (int i = 0; i < missing; i++) {\n                int b_i = ouf.readInt(1, 1000000, format(\"b[%d]\", i+1).c_str());\n                b.push_back(b_i);\n            }\n            // Combine ai and b\n            vector<int> nums = ai;\n            nums.insert(nums.end(), b.begin(), b.end());\n            if (nums.size() != 4) {\n                quitf(_wa, \"Total number of boxes is not 4\");\n            }\n            // Check the condition\n            sort(nums.begin(), nums.end());\n            int x1 = nums[0];\n            int x2 = nums[1];\n            int x3 = nums[2];\n            int x4 = nums[3];\n            double mean = (x1 + x2 + x3 + x4) / 4.0;\n            double median = (x2 + x3) / 2.0;\n            double range = x4 - x1;\n            if (fabs(mean - median) > 1e-6 || fabs(mean - range) > 1e-6) {\n                quitf(_wa, \"Your set of numbers does not satisfy mean == median == range\");\n            }\n            // All conditions satisfied\n            quitf(_ok, \"Correct\");\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read options\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 500);\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, 500);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 500;\n        }\n    } else if (type == \"impossible\") {\n        if (n > 0) {\n            int val = rnd.next(1, 500);\n            for (int i = 0; i < n; ++i) {\n                ai[i] = val;\n            }\n        } // For n = 0, leave ai empty\n    } else if (type == \"already_satisfy\") {\n        if (n > 4) n = 4; // Safety check\n        int k = rnd.next(1, 250000); // to keep x4 <= 1e6\n        int m = 2 * k;\n        // Generate numbers following the formula:\n        // x1 = k\n        // x4 = 3k\n        // x2 in [k, 2k]\n        int x1 = k;\n        int x4 = 3 * k;\n        int x2 = rnd.next(k, 2 * k);\n        int x3 = 4 * k - x2;\n        if (x2 > x3) swap(x2, x3);\n        vector<int> nums = {x1, x2, x3, x4};\n        shuffle(nums.begin(), nums.end());\n        for (int i = 0; i < n; ++i) {\n            ai[i] = nums[i];\n        }\n    } else if (type == \"need_large_missing\") {\n        if (n >= 4) n = 3;\n        ai.resize(n);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 2); // Small numbers, missing numbers need to be large\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 500);\n        }\n    }\n\n    // Shuffle ai's since they can be in arbitrary order\n    shuffle(ai.begin(), ai.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", ai[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read options\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 500);\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, 500);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 500;\n        }\n    } else if (type == \"impossible\") {\n        if (n > 0) {\n            int val = rnd.next(1, 500);\n            for (int i = 0; i < n; ++i) {\n                ai[i] = val;\n            }\n        } // For n = 0, leave ai empty\n    } else if (type == \"already_satisfy\") {\n        if (n > 4) n = 4; // Safety check\n        int k = rnd.next(1, 250000); // to keep x4 <= 1e6\n        int m = 2 * k;\n        // Generate numbers following the formula:\n        // x1 = k\n        // x4 = 3k\n        // x2 in [k, 2k]\n        int x1 = k;\n        int x4 = 3 * k;\n        int x2 = rnd.next(k, 2 * k);\n        int x3 = 4 * k - x2;\n        if (x2 > x3) swap(x2, x3);\n        vector<int> nums = {x1, x2, x3, x4};\n        shuffle(nums.begin(), nums.end());\n        for (int i = 0; i < n; ++i) {\n            ai[i] = nums[i];\n        }\n    } else if (type == \"need_large_missing\") {\n        if (n >= 4) n = 3;\n        ai.resize(n);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 2); // Small numbers, missing numbers need to be large\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 500);\n        }\n    }\n\n    // Shuffle ai's since they can be in arbitrary order\n    shuffle(ai.begin(), ai.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", ai[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varying n\n./gen -n 0 -type random\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n\n# All same value test cases\n./gen -n 1 -type all_same\n./gen -n 2 -type all_same\n./gen -n 3 -type all_same\n./gen -n 4 -type all_same\n\n# Min value test cases (ai = 1)\n./gen -n 1 -type min\n./gen -n 2 -type min\n./gen -n 3 -type min\n./gen -n 4 -type min\n\n# Max value test cases (ai = 500)\n./gen -n 1 -type max\n./gen -n 2 -type max\n./gen -n 3 -type max\n./gen -n 4 -type max\n\n# Test cases needing large missing numbers\n./gen -n 0 -type need_large_missing\n./gen -n 1 -type need_large_missing\n./gen -n 2 -type need_large_missing\n./gen -n 3 -type need_large_missing\n\n# Impossible cases\n./gen -n 3 -type impossible\n./gen -n 4 -type impossible\n./gen -n 0 -type impossible\n\n# Cases where the given ai's already satisfy the condition\n./gen -n 4 -type already_satisfy\n./gen -n 2 -type already_satisfy\n./gen -n 3 -type already_satisfy\n\n# Edge cases with n = 0\n./gen -n 0 -type min\n./gen -n 0 -type max\n./gen -n 0 -type all_same\n./gen -n 0 -type random\n\n# Additional random test cases\n./gen -n 2 -type random\n./gen -n 3 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:32.794664",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "488/C",
      "title": "C. Fight the Monster",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers HPY, ATKY, DEFY, separated by a space, denoting the initial HP, ATK and DEF of Master Yang.The second line contains three integers HPM, ATKM, DEFM, separated by a space, denoting the HP, ATK and DEF of the monster.The third line contains three integers h, a, d, separated by a space, denoting the price of 1 HP, 1 ATK and 1 DEF.All numbers in input are integer and lie between 1 and 100 inclusively.",
      "output_spec": "OutputThe only output line should contain an integer, denoting the minimum bitcoins Master Yang should spend in order to win.",
      "sample_tests": "ExamplesInputCopy1 2 11 100 11 100 100OutputCopy99InputCopy100 100 1001 1 11 1 1OutputCopy0",
      "description": "C. Fight the Monster\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers HPY, ATKY, DEFY, separated by a space, denoting the initial HP, ATK and DEF of Master Yang.The second line contains three integers HPM, ATKM, DEFM, separated by a space, denoting the HP, ATK and DEF of the monster.The third line contains three integers h, a, d, separated by a space, denoting the price of 1 HP, 1 ATK and 1 DEF.All numbers in input are integer and lie between 1 and 100 inclusively.\n\nOutputThe only output line should contain an integer, denoting the minimum bitcoins Master Yang should spend in order to win.\n\nInputCopy1 2 11 100 11 100 100OutputCopy99InputCopy100 100 1001 1 11 1 1OutputCopy0\n\nInputCopy1 2 11 100 11 100 100\n\nOutputCopy99\n\nInputCopy100 100 1001 1 11 1 1\n\nOutputCopy0\n\nNoteFor the first sample, prices for ATK and DEF are extremely high. Master Yang can buy 99 HP, then he can beat the monster with 1 HP left.For the second sample, Master Yang is strong enough to beat the monster, so he doesn't need to buy anything.",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 488 和字母"
          },
          "content_length": 7236
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 488 和字母"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int HPY = inf.readInt(1, 100, \"HPY\");\n    inf.readSpace();\n    int ATKY = inf.readInt(1, 100, \"ATKY\");\n    inf.readSpace();\n    int DEFY = inf.readInt(1, 100, \"DEFY\");\n    inf.readEoln();\n\n    int HPM = inf.readInt(1, 100, \"HPM\");\n    inf.readSpace();\n    int ATKM = inf.readInt(1, 100, \"ATKM\");\n    inf.readSpace();\n    int DEFM = inf.readInt(1, 100, \"DEFM\");\n    inf.readEoln();\n\n    int h = inf.readInt(1, 100, \"h\");\n    inf.readSpace();\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int d = inf.readInt(1, 100, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int HPY = inf.readInt(1, 100, \"HPY\");\n    inf.readSpace();\n    int ATKY = inf.readInt(1, 100, \"ATKY\");\n    inf.readSpace();\n    int DEFY = inf.readInt(1, 100, \"DEFY\");\n    inf.readEoln();\n\n    int HPM = inf.readInt(1, 100, \"HPM\");\n    inf.readSpace();\n    int ATKM = inf.readInt(1, 100, \"ATKM\");\n    inf.readSpace();\n    int DEFM = inf.readInt(1, 100, \"DEFM\");\n    inf.readEoln();\n\n    int h = inf.readInt(1, 100, \"h\");\n    inf.readSpace();\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int d = inf.readInt(1, 100, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int HPY = inf.readInt(1, 100, \"HPY\");\n    inf.readSpace();\n    int ATKY = inf.readInt(1, 100, \"ATKY\");\n    inf.readSpace();\n    int DEFY = inf.readInt(1, 100, \"DEFY\");\n    inf.readEoln();\n\n    int HPM = inf.readInt(1, 100, \"HPM\");\n    inf.readSpace();\n    int ATKM = inf.readInt(1, 100, \"ATKM\");\n    inf.readSpace();\n    int DEFM = inf.readInt(1, 100, \"DEFM\");\n    inf.readEoln();\n\n    int h = inf.readInt(1, 100, \"h\");\n    inf.readSpace();\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int d = inf.readInt(1, 100, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid print_test(int HPY, int ATKY, int DEFY, int HPM, int ATKM, int DEFM, int h, int a, int d) {\n    printf(\"%d %d %d\\n\", HPY, ATKY, DEFY);\n    printf(\"%d %d %d\\n\", HPM, ATKM, DEFM);\n    printf(\"%d %d %d\\n\", h, a, d);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int HPY, ATKY, DEFY;\n    int HPM, ATKM, DEFM;\n    int h, a, d;\n\n    if (type == \"random\") {\n        // All variables random between 1 and 100\n        HPY = rnd.next(1, 100);\n        ATKY = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n        ATKM = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n        h = rnd.next(1, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(1, 100);\n    } else if (type == \"edge_min\") {\n        // All variables set to 1\n        HPY = ATKY = DEFY = 1;\n        HPM = ATKM = DEFM = 1;\n        h = a = d = 1;\n    } else if (type == \"edge_max\") {\n        // All variables set to 100\n        HPY = ATKY = DEFY = 100;\n        HPM = ATKM = DEFM = 100;\n        h = a = d = 100;\n    } else if (type == \"zero_cost\") {\n        // Yang can win without buying anything\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(ATKM + 1, 100);\n        ATKY = rnd.next(1, 100);\n        DEFM = rnd.next(1, ATKY - 1);\n        HPM = rnd.next(1, 100);\n        HPY = rnd.next(1, 100);\n        h = rnd.next(1, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(1, 100);\n    } else if (type == \"max_hp_needed\") {\n        // Yang needs to increase HP to win\n        ATKY = rnd.next(50, 100);\n        DEFM = rnd.next(1, ATKY - 1);\n        ATKM = rnd.next(50, 100);\n        DEFY = rnd.next(1, ATKM - 1);\n        int Dmg_Monster = ATKY - DEFM;\n        int Dmg_Yang = ATKM - DEFY;\n        HPM = rnd.next(50, 100);\n        int turns_to_kill_monster = (HPM + Dmg_Monster - 1) / Dmg_Monster;\n        HPY = Dmg_Yang * (turns_to_kill_monster - 1);\n        HPY = max(1, min(HPY, 100));\n        h = rnd.next(1, 100);\n        a = rnd.next(50, 100);\n        d = rnd.next(50, 100);\n    } else if (type == \"max_atk_needed\") {\n        // Yang needs to increase ATK to win\n        DEFM = rnd.next(50, 100);\n        ATKY = DEFM;\n        ATKM = rnd.next(1, 50);\n        DEFY = rnd.next(ATKM + 1, 100);\n        HPM = rnd.next(1, 100);\n        HPY = rnd.next(1, 100);\n        h = rnd.next(50, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(50, 100);\n    } else if (type == \"max_def_needed\") {\n        // Yang needs to increase DEF to win\n        ATKM = rnd.next(50, 100);\n        DEFY = rnd.next(1, ATKM - 1);\n        ATKY = rnd.next(50, 100);\n        DEFM = rnd.next(1, ATKY - 1);\n        HPM = rnd.next(50, 100);\n        int Dmg_Monster = ATKY - DEFM;\n        int Dmg_Yang = ATKM - DEFY;\n        int turns_to_kill_monster = (HPM + Dmg_Monster - 1) / Dmg_Monster;\n        HPY = Dmg_Yang * (turns_to_kill_monster - 1);\n        HPY = max(1, min(HPY, 100));\n        h = rnd.next(50, 100);\n        a = rnd.next(50, 100);\n        d = rnd.next(1, 100);\n    } else if (type == \"need_all\") {\n        // Yang needs to increase multiple attributes\n        ATKY = rnd.next(1, 50);\n        DEFM = rnd.next(ATKY + 1, 100);\n        ATKM = rnd.next(50, 100);\n        DEFY = rnd.next(1, ATKM - 1);\n        HPM = rnd.next(50, 100);\n        HPY = rnd.next(1, 50);\n        h = rnd.next(1, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(1, 100);\n    } else {\n        // Default to random\n        HPY = rnd.next(1, 100);\n        ATKY = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n        ATKM = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n        h = rnd.next(1, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(1, 100);\n    }\n\n    print_test(HPY, ATKY, DEFY, HPM, ATKM, DEFM, h, a, d);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid print_test(int HPY, int ATKY, int DEFY, int HPM, int ATKM, int DEFM, int h, int a, int d) {\n    printf(\"%d %d %d\\n\", HPY, ATKY, DEFY);\n    printf(\"%d %d %d\\n\", HPM, ATKM, DEFM);\n    printf(\"%d %d %d\\n\", h, a, d);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int HPY, ATKY, DEFY;\n    int HPM, ATKM, DEFM;\n    int h, a, d;\n\n    if (type == \"random\") {\n        // All variables random between 1 and 100\n        HPY = rnd.next(1, 100);\n        ATKY = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n        ATKM = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n        h = rnd.next(1, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(1, 100);\n    } else if (type == \"edge_min\") {\n        // All variables set to 1\n        HPY = ATKY = DEFY = 1;\n        HPM = ATKM = DEFM = 1;\n        h = a = d = 1;\n    } else if (type == \"edge_max\") {\n        // All variables set to 100\n        HPY = ATKY = DEFY = 100;\n        HPM = ATKM = DEFM = 100;\n        h = a = d = 100;\n    } else if (type == \"zero_cost\") {\n        // Yang can win without buying anything\n        ATKM = rnd.next(1, 100);\n        DEFY = rnd.next(ATKM + 1, 100);\n        ATKY = rnd.next(1, 100);\n        DEFM = rnd.next(1, ATKY - 1);\n        HPM = rnd.next(1, 100);\n        HPY = rnd.next(1, 100);\n        h = rnd.next(1, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(1, 100);\n    } else if (type == \"max_hp_needed\") {\n        // Yang needs to increase HP to win\n        ATKY = rnd.next(50, 100);\n        DEFM = rnd.next(1, ATKY - 1);\n        ATKM = rnd.next(50, 100);\n        DEFY = rnd.next(1, ATKM - 1);\n        int Dmg_Monster = ATKY - DEFM;\n        int Dmg_Yang = ATKM - DEFY;\n        HPM = rnd.next(50, 100);\n        int turns_to_kill_monster = (HPM + Dmg_Monster - 1) / Dmg_Monster;\n        HPY = Dmg_Yang * (turns_to_kill_monster - 1);\n        HPY = max(1, min(HPY, 100));\n        h = rnd.next(1, 100);\n        a = rnd.next(50, 100);\n        d = rnd.next(50, 100);\n    } else if (type == \"max_atk_needed\") {\n        // Yang needs to increase ATK to win\n        DEFM = rnd.next(50, 100);\n        ATKY = DEFM;\n        ATKM = rnd.next(1, 50);\n        DEFY = rnd.next(ATKM + 1, 100);\n        HPM = rnd.next(1, 100);\n        HPY = rnd.next(1, 100);\n        h = rnd.next(50, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(50, 100);\n    } else if (type == \"max_def_needed\") {\n        // Yang needs to increase DEF to win\n        ATKM = rnd.next(50, 100);\n        DEFY = rnd.next(1, ATKM - 1);\n        ATKY = rnd.next(50, 100);\n        DEFM = rnd.next(1, ATKY - 1);\n        HPM = rnd.next(50, 100);\n        int Dmg_Monster = ATKY - DEFM;\n        int Dmg_Yang = ATKM - DEFY;\n        int turns_to_kill_monster = (HPM + Dmg_Monster - 1) / Dmg_Monster;\n        HPY = Dmg_Yang * (turns_to_kill_monster - 1);\n        HPY = max(1, min(HPY, 100));\n        h = rnd.next(50, 100);\n        a = rnd.next(50, 100);\n        d = rnd.next(1, 100);\n    } else if (type == \"need_all\") {\n        // Yang needs to increase multiple attributes\n        ATKY = rnd.next(1, 50);\n        DEFM = rnd.next(ATKY + 1, 100);\n        ATKM = rnd.next(50, 100);\n        DEFY = rnd.next(1, ATKM - 1);\n        HPM = rnd.next(50, 100);\n        HPY = rnd.next(1, 50);\n        h = rnd.next(1, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(1, 100);\n    } else {\n        // Default to random\n        HPY = rnd.next(1, 100);\n        ATKY = rnd.next(1, 100);\n        DEFY = rnd.next(1, 100);\n        HPM = rnd.next(1, 100);\n        ATKM = rnd.next(1, 100);\n        DEFM = rnd.next(1, 100);\n        h = rnd.next(1, 100);\n        a = rnd.next(1, 100);\n        d = rnd.next(1, 100);\n    }\n\n    print_test(HPY, ATKY, DEFY, HPM, ATKM, DEFM, h, a, d);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type edge_min\n./gen -type edge_max\n./gen -type zero_cost\n./gen -type max_hp_needed\n./gen -type max_atk_needed\n./gen -type max_def_needed\n./gen -type need_all\n\n./gen -type random\n./gen -type random\n./gen -type zero_cost\n./gen -type zero_cost\n./gen -type max_hp_needed\n./gen -type max_hp_needed\n./gen -type max_atk_needed\n./gen -type max_atk_needed\n./gen -type max_def_needed\n./gen -type max_def_needed\n./gen -type need_all\n./gen -type need_all\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type edge_min\n./gen -type edge_max\n./gen -type edge_min\n./gen -type edge_max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:34.877156",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "488/D",
      "title": "D. Strip",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, s, l (1 ≤ n ≤ 105, 0 ≤ s ≤ 109, 1 ≤ l ≤ 105).The second line contains n integers ai separated by spaces ( - 109 ≤ ai ≤ 109).",
      "output_spec": "OutputOutput the minimal number of strip pieces.If there are no ways to split the strip, output -1.",
      "sample_tests": "ExamplesInputCopy7 2 21 3 1 2 4 1 2OutputCopy3InputCopy7 2 21 100 1 100 1 100 1OutputCopy-1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, s, l (1 ≤ n ≤ 105, 0 ≤ s ≤ 109, 1 ≤ l ≤ 105).The second line contains n integers ai separated by spaces ( - 109 ≤ ai ≤ 109).\n\nOutputOutput the minimal number of strip pieces.If there are no ways to split the strip, output -1.\n\nInputCopy7 2 21 3 1 2 4 1 2OutputCopy3InputCopy7 2 21 100 1 100 1 100 1OutputCopy-1\n\nInputCopy7 2 21 3 1 2 4 1 2\n\nOutputCopy3\n\nInputCopy7 2 21 100 1 100 1 100 1\n\nOutputCopy-1\n\nNoteFor the first sample, we can split the strip into 3 pieces: [1, 3, 1], [2, 4], [1, 2].For the second sample, we can't let 1 and 100 be on the same piece, so no solution exists.",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 488 和字母"
          },
          "content_length": 7236
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 488 和字母"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    int l = opt<int>(\"l\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_equal\") {\n        // All numbers are the same\n        int val = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_diff\") {\n        // All numbers have difference <= s\n        int minVal = rnd.next(-1000000000, 1000000000 - s);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minVal, minVal + s);\n    } else if (type == \"large_diff\") {\n        // Numbers have difference > s\n        if (s == 0) {\n            for (int i = 0; i < n; ++i)\n                a[i] = i;\n        } else {\n            int minVal = rnd.next(-1000000000, 1000000000 - n*(s+1));\n            for (int i = 0; i < n; ++i)\n                a[i] = minVal + i*(s+1);\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between low and high values where difference > s\n        int low = rnd.next(-1000000000, 1000000000 - s - 1);\n        int high = low + s + 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? low : high;\n    } else if (type == \"random\") {\n        int minA = -1000000000;\n        int maxA = 1000000000;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minA, maxA);\n    } else if (type == \"increasing\") {\n        int start = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(-1000000000 + n, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"impossible\") {\n        // Make it impossible to split the strip\n        // For example, l > n\n        if (l <= n)\n            l = n + 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"max_pieces\") {\n        // Maximize the number of pieces\n        // Each piece must have at least l elements, s is small, numbers are distinct\n        int minVal = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i)\n            a[i] = minVal + i;\n    } else if (type == \"min_pieces\") {\n        // Minimize the number of pieces (ideally 1)\n        // All numbers are within s difference, so we can have one piece\n        int val = rnd.next(-1000000000, 1000000000 - s);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(val, val + s);\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, s, l);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    int l = opt<int>(\"l\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_equal\") {\n        // All numbers are the same\n        int val = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_diff\") {\n        // All numbers have difference <= s\n        int minVal = rnd.next(-1000000000, 1000000000 - s);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minVal, minVal + s);\n    } else if (type == \"large_diff\") {\n        // Numbers have difference > s\n        if (s == 0) {\n            for (int i = 0; i < n; ++i)\n                a[i] = i;\n        } else {\n            int minVal = rnd.next(-1000000000, 1000000000 - n*(s+1));\n            for (int i = 0; i < n; ++i)\n                a[i] = minVal + i*(s+1);\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between low and high values where difference > s\n        int low = rnd.next(-1000000000, 1000000000 - s - 1);\n        int high = low + s + 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? low : high;\n    } else if (type == \"random\") {\n        int minA = -1000000000;\n        int maxA = 1000000000;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minA, maxA);\n    } else if (type == \"increasing\") {\n        int start = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(-1000000000 + n, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"impossible\") {\n        // Make it impossible to split the strip\n        // For example, l > n\n        if (l <= n)\n            l = n + 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"max_pieces\") {\n        // Maximize the number of pieces\n        // Each piece must have at least l elements, s is small, numbers are distinct\n        int minVal = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i)\n            a[i] = minVal + i;\n    } else if (type == \"min_pieces\") {\n        // Minimize the number of pieces (ideally 1)\n        // All numbers are within s difference, so we can have one piece\n        int val = rnd.next(-1000000000, 1000000000 - s);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(val, val + s);\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, s, l);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -s 0 -l 1 -type all_equal\n\n./gen -n 1 -s 0 -l 1 -type random\n\n./gen -n 5 -s 0 -l 1 -type all_equal\n\n./gen -n 5 -s 1000000000 -l 1 -type random\n\n./gen -n 5 -s 0 -l 1 -type increasing\n\n./gen -n 5 -s 0 -l 1 -type decreasing\n\n./gen -n 5 -s 0 -l 1 -type alternating\n\n./gen -n 5 -s 0 -l 1 -type impossible\n\n./gen -n 100 -s 0 -l 1 -type max_pieces\n\n./gen -n 100 -s 1000000000 -l 1 -type min_pieces\n\n./gen -n 100 -s 0 -l 100 -type impossible\n\n./gen -n 1000 -s 10 -l 50 -type small_diff\n\n./gen -n 1000 -s 10 -l 50 -type large_diff\n\n./gen -n 1000 -s 1000000000 -l 1 -type random\n\n./gen -n 1000 -s 0 -l 1 -type random\n\n./gen -n 10000 -s 0 -l 1 -type max_pieces\n\n./gen -n 10000 -s 1000000000 -l 1 -type min_pieces\n\n./gen -n 100000 -s 0 -l 1 -type max_pieces\n\n./gen -n 100000 -s 0 -l 100000 -type impossible\n\n./gen -n 100000 -s 1000000000 -l 1 -type min_pieces\n\n./gen -n 100000 -s 0 -l 100 -type alternating\n\n./gen -n 100000 -s 0 -l 1 -type alternating\n\n./gen -n 100000 -s 1000000000 -l 1 -type random\n\n./gen -n 100000 -s 500000000 -l 1 -type random\n\n./gen -n 100000 -s 0 -l 1 -type small_diff\n\n./gen -n 100000 -s 0 -l 1 -type large_diff\n\n./gen -n 100000 -s 0 -l 1 -type impossible\n\n./gen -n 100000 -s 5 -l 1 -type random\n\n./gen -n 100000 -s 0 -l 1 -type min_pieces\n\n./gen -n 99999 -s 0 -l 1 -type random\n\n./gen -n 1 -s 0 -l 1 -type impossible\n\n./gen -n 10000 -s 1 -l 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:37.109269",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "488/E",
      "title": "E. Prefix Product Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only input line contains an integer n (1 ≤ n ≤ 105).",
      "output_spec": "OutputIn the first output line, print \"YES\" if such sequence exists, or print \"NO\" if no such sequence exists.If any solution exists, you should output n more lines. i-th line contains only an integer ai. The elements of the sequence should be different positive integers no larger than n.If there are multiple solutions, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy7OutputCopyYES1436527InputCopy6OutputCopyNO",
      "description": "E. Prefix Product Sequence\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only input line contains an integer n (1 ≤ n ≤ 105).\n\nOutputIn the first output line, print \"YES\" if such sequence exists, or print \"NO\" if no such sequence exists.If any solution exists, you should output n more lines. i-th line contains only an integer ai. The elements of the sequence should be different positive integers no larger than n.If there are multiple solutions, you are allowed to print any of them.\n\nInputCopy7OutputCopyYES1436527InputCopy6OutputCopyNO\n\nOutputCopyYES1436527\n\nOutputCopyNO\n\nNoteFor the second sample, there are no valid sequences.",
      "solutions": [
        {
          "title": "Codeforces Round #278 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #278 will be held at Nov/21/2014 20:00 MSK for both divisions. Note that the time is 30 minutes later than regular Codeforces time, and Moscow is currently UTC+3.The problem setters are taorunz and me. This is our first Codeforces round!We'd like to thank Maxim Akhmedov (Zlobober), who helped us prepare the problems very much; also to thank MikeMirzayanov for Codeforces and Polygon platforms.This round is involved in MIPT Fall Programming Training Camp, and top-20 of contestants from the camp will be rewarded with Codeforces T-shirts. For other contestants it will be regular Codeforces round.Hope you enjoy the round, and wish you high rating.UPD: Score distribution:Div. 2: 500 — 1500 — 1500 — 2500 — 2500Div. 1: 500 — 1500 — 1500 — 2000 — 2500It's not for everyone that the optimal strategy is solving tasks in order. Make sure you've read all problems before the contest ends.UPD: Very sorry that the round will be moved 20 forward due to technical reasons.UPD: Top 5 participants:Div.1 ACRush rng_58 Egor Kostroma sankear Div.2 nghiand rabbit_TR mwc123 batkhuyag whalyzh Honorable mentioned:anta, who solved Div.1 E!CKYang, who solved Div.2 E!UPD: Editorial is here!UPD: hack statistics (Div.1 and Div.2) by kostka!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 488 和字母"
          },
          "content_length": 7236
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces",
          "content": "488A - ГигабашняThe answer b is very small (usually no larger than 10), because one of a + 1, a + 2, ..., a + 10 has its last digit be 8.However, b can exceed 10 when a is negative and close to 0. The worst case is a =  - 8, where b = 16.Anyway b is rather small, so we can simply try b from 1, and check whether a + b has a digit 8.488B - Коробки конфетLet's sort the four numbers in ascending order: a, b, c, d (where x1, x2, x3, x4 are used in problem statement). So .With some basic math, we can get a: d = 1: 3 and a + d = b + c.Solution 1:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.If n = 2, let x, y denote the known numbers (x ≤ y). No solution exists if 3x < y. Otherwise we can construct a solution {x, y, 4x - y, 3x} (certainly other solutions may exist).If n = 3, let x, y, z denote the known numbers (x ≤ y ≤ z). No solution exists if 3x < z. Otherwise the solution can only be {x, y, z, 3x}, or {x, y, x + z - y, z}.Solution 2:The known numbers are no larger than 500, so all numbers are no larger than 1500 if solution exists. We enumerate x from 1 to 500, y from x to 3x, then {x, y, 4x - y, 3x} is a solution. For each solution, check if it matches the known numbers.Solution 3:If n = 0, just output any answer (such as {1, 1, 3, 3}). If n = 1, just output {x, x, 3x, 3x}, where x is the known number. If n = 4, just check whether the four known numbers meet the condition.Otherwise, we can enumerate the 1 or 2 missing number(s), and check if the four numbers meet the condition.487A - Бьём чудовище!It is no use to make Yang's ATK > HP_M + DEF_M (Yang already can beat it in a second). And it's no use to make Yang's DEF > ATK_M (it cannot deal any damage to him).As a result, Yang's final ATK will not exceed 200, and final DEF will not exceed 100. So just enumerate final ATK from ATK_Y to 200, final DEF from DEF_Y to 100.With final ATK and DEF known, you can calculate how long the battle will last, then calculate HP loss. You can easily find the gold you spend, and then find the optimal answer.487B - ЛентаWe can use dynamic programming to solve this problem.Let f[i] denote the minimal number of pieces that the first i numbers can be split into. g[i] denote the maximal length of substrip whose right border is i(included) and it satisfy the condition.Then f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.We can use monotonic queue to calculate g[i] and f[i]. And this can be implemented in O(n)We can also use sparse table or segment tree to solve the problem, the time complexity is or (It should be well-implemented).For more details about monotonic queue, you can see here487C - Последовательность частичных произведенийThe answer is YES if and only if n is a prime or n = 1 or n = 4.First we can find . If n occurs in {a_1,…,a_{n-1}} in the prefix product sequence 0 will occur twice which do not satisfy the condition. So an must be 0 from which we know a1a2... an - 1 = (n - 1)!. But for any composite number n > 4 we have (See the proof below). So we can know that for all composite number n > 4 the answer is NO.For n = 1, 1 is a solution.For n = 4, 1, 3, 2, 4 is a solution.For any prime number n, let ai be . If there are two same number ai, aj. Then we get i / (i - 1) ≡ j / (j - 1) which leads to i ≡ j, which is a contradiction. So all n numbers will occur exactly once. And this is a solution.Also, we can find a primitive root g of n and $g^{0}, g^{1}, g^{n-3}, g^{3}, g^{n-5}, \\cdots } is also a solution.Proof: For a composite number n > 4 it can either be written as the products of two numbers p, q > 1.If p ≠ q, then we immediately get pq|(n - 1)!.If p = q, note that n > 4 so 2p < n, we have p2|(n - 1)!So n|(n - 1)! always holds which means 487D - Ленты конвейераThis problem can be solved by classic data structures.For example, let's try something like SQRT-decomposition. Let's divide the map horizontally into some blocks. For each grid, calculate its destination when going out the current block (or infinite loop before going out current block).For each modification, recalculate the affected block by brute force. For each query, we can just use the \"destination when going out the current block\" to speed up simulation.Let S be the size of a block, then the time for each modification is O(S), for each query is O(nm / S), since at most O(nm / S) blocks, and at most 1 grid of each block are visited.The total time complexity is O(nm + qnm / S + pS), where p is the number of modifications. Let , the complexity can be the best: .This task can also be solve by segment tree. The time complexity is , or , depending on implementation.487E - ТуристыFirst we can find out all cut vertices and biconnected components(BCC) by Tarjan’s Algorithm. And it must form a tree.From the lemma below, we know that if we can pass by a BCC, then we can always pass any point in the BCC.We use a priority queue for each BCC to maintain the minimal price in the component.For each modification, if the vertex is a cut vertex, then modify itself and its related BCCs’ priority queue. If not, modify the priority queue of its BCC.For each query, the answer is the minimal price on the path from x (or its BCC) to y (or its BCC). We can use Link-Cut Trees or Heavy-Light Decomposition with Segment Trees.To be more exact, we can only modify the father BCC of the cut vertex in order to guarantee complexity(otherwise it would be hacked by a star graph).When querying, if the LCA of x and y is a BCC. Then the father of the LCA(which is a cut vertex related to the BCC) should also be taken into account.The time complexity is or .Lemma: In a biconnected graph with n ≥ 3 points, for any three different vertices a, b, c, there is a simple path to from a to b going through c.Proof: Consider a biconnected graph with at least 3 vertices. If we remove any vertex or any edge, the graph is still connected.We build a network on the graph. Let's use (u,v,w) to describe a directed edge from u to v with capacity w. For each edge (u,v) of the original graph, we build (u,v,1) and (v,u,1). Build (S,c,2), (a,T,1) and (b,T,1). For each vertex other than S,T,c, we should give a capacity of 1 to the vertex.In order to give capacity to vertex u, we build two vertices u1,u2 instead of u. For each (v,u,w), build (v,u1,w). For each (u,v,w), build(u2,v,w). Finally build (u1,u2,1).Hence, if the maximal flow from S to T is 2, there is a simple path from a to b going through c.Now we consider the minimal cut of the network. It is easy to find that minimal cut <= 2, so let's prove minimal cut > 1, which means, no matter which edge of capacity 1 we cut, there is still a path from S to T.If we cut an edge like (u1,u2,1), it is equivalent to set the capacity of the vertex to 0, and equivalent to remove the vertex from the original graph. The graph is still connected, so there is still a path in the network.If we cut other edges, it is equivalent to remove an edge from the original graph. It is still connected, too.Now we have minimal cut > 1, which means maximal flow = minimal cut = 2. So there is always a simple path from a to b going through c.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 488 和字母"
          },
          "content_length": 7236
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #278 - Codeforces - Code 1",
          "code": "Nov/20/2014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 2",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 3",
          "code": "100 1 50\n100 100 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 4",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 5",
          "code": "YES\n125\n375\n375NO",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 6",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 7",
          "code": "2 1 1\n10 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 8",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 9",
          "code": "1 1 1\n100 2 100\n100 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 10",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 11",
          "code": "1 10 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 12",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 - Codeforces - Code 13",
          "code": "1 2 1\n99 100 1\n1 100 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 1",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 2",
          "code": "i/(i-1) mod n == j/(j-1) mod n\ni*(j-1) mod n == j*(i-1) mod n\ni*j - i mod n == i*j - j mod n\ni mod n = j mod n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 3",
          "code": "For any prime number n, let ai be i/(i-1) mod n.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 4",
          "code": "f[i] = min(f[k]) + 1, where i - g[i] ≤ k ≤ i - l.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #278 Editorial - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h> \nusing namespace std;\n#define intt int64_t \n\nvoid solve()\n{\n    intt n, s, l;\n    cin>>n>>s>>l;\n\n    // input vector\n    vector<intt> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n\n    // two pointers which will slide through the vector\n    intt p1 =0, p2 = 0;\n    // a multiset to instantly know the minima and maxima within the pointers\n    multiset<intt> win;\n    // a vector to keep the intervals which should contain at least one boundary\n    vector<pair<intt, intt>> intervals;\n    // assuming a virtual boundary at the start of array\n    intervals.push_back({-1, -1});\n\n    // through the input vector\n    while(p1<=p2 and p1<n and p2<n)\n    {\n\n        win.insert(a[p2]);\n        \n        // flag tells whether the diff of max and min in the multiset\n        // became greater than s\n        intt flag  = 0;\n\n        while(p1<n and p2<n and abs(*(--win.end())-*(win.begin()))>s)\n        {\n            // increase the first pointer while the diff remains greater than s\n            win.erase(win.find(a[p1]));\n            p1++;\n            flag = 1; \n        }\n\n        if(flag)\n        {\n            // if the first pointer is displaced then it means we require a boundary \n            // somewhere between the first pointer and the second pointer\n            // only if this is not already put in the intervals vector.\n            if(p1-1>intervals.back().second) intervals.push_back({p1-1, p2-1});\n        }\n        p2++;\n    }\n\n    // if the array can be partitioned then the ans will be the number of boundaries + 1 \n    // we are not doing +1 as we have already added an additional virtual boundary in this\n    intt ans = intervals.size();\n\n    for(intt i=1;i<intervals.size();i++)\n    {\n        // this flag will tell whether we were able to successfully draw a boundary in the\n        //  interval without violating the partition length constraints\n        intt flag = 0;\n\n        for(intt j=intervals[i].first;j<=intervals[i].second;j++)\n        {\n            // greedily check for the first viable boundary position in the interval\n            if(j-intervals[i-1].first>=l)\n            {\n                // the previous boundary and this boundary are at least l distance apart\n                flag=1;\n                // also update the interval because the next time we have to check the \n                // distance from this boundary rather than the start of the interval\n                intervals[i].first=j;\n                break;\n            }\n        }\n\n        if(!flag)\n        {\n            // if we were unsuccessful in putting a boundary in the interval \n            cout<<\"-1\";\n            return;\n        }\n    }\n\n    auto last = intervals.back();\n    // also check if the last partition has enough length\n    if(n-1-last.first>=l) cout<<ans;\n    else cout<<\"-1\";\n}\n \nint main()\n{\n    int t=1;\n    while(t--) solve();\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n\n    string jury_ans = ans.readWord();\n    if (jury_ans != \"YES\" && jury_ans != \"NO\") {\n        ans.quitf(_fail, \"Jury answer is neither 'YES' nor 'NO', but '%s'\", jury_ans.c_str());\n    }\n\n    string participant_ans = ouf.readWord();\n    if (participant_ans != \"YES\" && participant_ans != \"NO\") {\n        ouf.quitf(_wa, \"Participant answer is neither 'YES' nor 'NO', but '%s'\", participant_ans.c_str());\n    }\n\n    if (jury_ans == \"NO\") {\n        // Jury says no solution exists\n        if (participant_ans != \"NO\") {\n            quitf(_wa, \"Participant claims a solution exists, but jury says there is none.\");\n        } else {\n            // Both agree no solution exists\n            if (!ouf.seekEof())\n                quitf(_wa, \"Expected no more output after 'NO'\");\n            quitf(_ok, \"Correctly reported that no solution exists.\");\n        }\n    } else {\n        // Jury says a solution exists\n        if (participant_ans != \"YES\") {\n            quitf(_wa, \"Participant says no solution exists, but a solution exists.\");\n        } else {\n            // Both say YES\n            vector<int> a(n);\n            for (int i = 0; i < n; ++i) {\n                a[i] = ouf.readInt(1, n, format(\"a[%d]\", i + 1).c_str());\n            }\n            if (!ouf.seekEof())\n                quitf(_wa, \"Participant output contains extra data after reading n integers.\");\n\n            // Check that a is a permutation of [1..n]\n            vector<bool> used(n + 1, false);\n            for (int i = 0; i < n; ++i) {\n                if (used[a[i]]) {\n                    quitf(_wa, \"Number %d appears more than once in the sequence.\", a[i]);\n                }\n                used[a[i]] = true;\n            }\n\n            // Compute prefix products modulo n\n            vector<int> b(n);\n            long long prod = 1;\n            vector<bool> used_b(n, false);\n            for (int i = 0; i < n; ++i) {\n                prod = (prod * a[i]) % n;\n                b[i] = (int)prod;\n                if (used_b[b[i]]) {\n                    quitf(_wa, \"Prefix product modulo n value %d occurs more than once.\", b[i]);\n                }\n                used_b[b[i]] = true;\n            }\n\n            quitf(_ok, \"Correct solution.\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <=1) return false;\n    if (n <=3) return true;\n    if (n%2==0 || n%3==0) return false;\n    for (int i=5; i*i<=n; i+=6) {\n        if (n%i==0 || n%(i+2)==0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"yes\") {\n        // Ensure n is 1, 2, 4, or an odd prime\n        if (n == 1 || n == 2 || n == 4 || (n % 2 == 1 && isPrime(n))) {\n            // Valid n, do nothing\n        } else {\n            // Adjust n to be valid for \"yes\" type\n            do {\n                n = rnd.next(1, 100000);\n            } while (!(n == 1 || n == 2 || n == 4 || (n % 2 == 1 && isPrime(n))));\n        }\n    } else if (type == \"no\") {\n        // Ensure n is not 1, 2, 4, or an odd prime\n        if (n != 1 && n != 2 && n != 4 && !(n % 2 == 1 && isPrime(n))) {\n            // Valid n, do nothing\n        } else {\n            // Adjust n to be valid for \"no\" type\n            do {\n                n = rnd.next(1, 100000);\n            } while (n == 1 || n == 2 || n == 4 || (n % 2 == 1 && isPrime(n)));\n        }\n    } else {\n        // Random n between 1 and 100000\n        n = rnd.next(1,100000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <=1) return false;\n    if (n <=3) return true;\n    if (n%2==0 || n%3==0) return false;\n    for (int i=5; i*i<=n; i+=6) {\n        if (n%i==0 || n%(i+2)==0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"yes\") {\n        // Ensure n is 1, 2, 4, or an odd prime\n        if (n == 1 || n == 2 || n == 4 || (n % 2 == 1 && isPrime(n))) {\n            // Valid n, do nothing\n        } else {\n            // Adjust n to be valid for \"yes\" type\n            do {\n                n = rnd.next(1, 100000);\n            } while (!(n == 1 || n == 2 || n == 4 || (n % 2 == 1 && isPrime(n))));\n        }\n    } else if (type == \"no\") {\n        // Ensure n is not 1, 2, 4, or an odd prime\n        if (n != 1 && n != 2 && n != 4 && !(n % 2 == 1 && isPrime(n))) {\n            // Valid n, do nothing\n        } else {\n            // Adjust n to be valid for \"no\" type\n            do {\n                n = rnd.next(1, 100000);\n            } while (n == 1 || n == 2 || n == 4 || (n % 2 == 1 && isPrime(n)));\n        }\n    } else {\n        // Random n between 1 and 100000\n        n = rnd.next(1,100000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type yes\n./gen -n 2 -type yes\n./gen -n 3 -type yes\n./gen -n 4 -type yes\n./gen -n 5 -type yes\n./gen -n 6 -type no\n./gen -n 7 -type yes\n./gen -n 8 -type no\n./gen -n 9 -type no\n./gen -n 10 -type no\n./gen -n 11 -type yes\n./gen -n 12 -type no\n./gen -n 13 -type yes\n./gen -n 14 -type no\n./gen -n 15 -type no\n./gen -n 16 -type no\n./gen -n 17 -type yes\n./gen -n 18 -type no\n./gen -n 19 -type yes\n./gen -n 20 -type no\n./gen -n 23 -type yes\n./gen -n 25 -type no\n./gen -n 29 -type yes\n./gen -n 30 -type no\n./gen -n 31 -type yes\n./gen -n 37 -type yes\n./gen -n 40 -type no\n./gen -n 41 -type yes\n./gen -n 50 -type no\n./gen -n 97 -type yes\n./gen -n 100 -type no\n./gen -n 101 -type yes\n./gen -n 1024 -type no\n./gen -n 4096 -type no\n./gen -n 4099 -type yes\n./gen -n 8192 -type no\n./gen -n 99991 -type yes\n./gen -n 99999 -type no\n./gen -n 100000 -type no\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:38.767712",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "489/A",
      "title": "A. SwapSort",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 3000) — the number of array elements. The second line contains elements of array: a0, a1, ..., an - 1 ( - 109 ≤ ai ≤ 109), where ai is the i-th element of the array. The elements are numerated from 0 to n - 1 from left to right. Some integers may appear in the array more than once.",
      "output_spec": "OutputIn the first line print k (0 ≤ k ≤ n) — the number of swaps. Next k lines must contain the descriptions of the k swaps, one per line. Each swap should be printed as a pair of integers i, j (0 ≤ i, j ≤ n - 1), representing the swap of elements ai and aj. You can print indices in the pairs in any order. The swaps are performed in the order they appear in the output, from the first to the last. It is allowed to print i = j and swap the same pair of elements multiple times.If there are multiple answers, print any of them. It is guaranteed that at least one answer exists.",
      "sample_tests": "ExamplesInputCopy55 2 5 1 4OutputCopy20 34 2InputCopy610 20 20 40 60 60OutputCopy0InputCopy2101 100OutputCopy10 1",
      "description": "A. SwapSort\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 3000) — the number of array elements. The second line contains elements of array: a0, a1, ..., an - 1 ( - 109 ≤ ai ≤ 109), where ai is the i-th element of the array. The elements are numerated from 0 to n - 1 from left to right. Some integers may appear in the array more than once.\n\nOutputIn the first line print k (0 ≤ k ≤ n) — the number of swaps. Next k lines must contain the descriptions of the k swaps, one per line. Each swap should be printed as a pair of integers i, j (0 ≤ i, j ≤ n - 1), representing the swap of elements ai and aj. You can print indices in the pairs in any order. The swaps are performed in the order they appear in the output, from the first to the last. It is allowed to print i = j and swap the same pair of elements multiple times.If there are multiple answers, print any of them. It is guaranteed that at least one answer exists.\n\nInputCopy55 2 5 1 4OutputCopy20 34 2InputCopy610 20 20 40 60 60OutputCopy0InputCopy2101 100OutputCopy10 1\n\nInputCopy55 2 5 1 4\n\nOutputCopy20 34 2\n\nInputCopy610 20 20 40 60 60\n\nOutputCopy0\n\nInputCopy2101 100\n\nOutputCopy10 1",
      "solutions": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!Actually, I didn't understand how, but I've prepated a round for the second division. I think it is subconscious wanted to soften the hard memories of the round of 276.I hope that very much that the round will be held without any technical issues, as was the 277th.I express my sincere gratitude to all involved in the preparation — Maxim Zlobober Akhmedov, Maria Delinur Belova, Polygon System, servers and James Gosling for Java. Also I am immensely grateful to the driver, who did not knock down me by car, although I, thinking about the problems, was crossing road on red.It will be rated round, 6 problems and non-typical progressive scores: min(500 + i*500, 2500).Wish you to see many Accepteds.UPD. The Round moved 5 minutes forward. I want very much so that no one be late! Sorry.UPD 2. Rating has been updated. But if we will find any cheaters, they will be punished and we will recalculate ratings. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14711",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 955
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces",
          "content": "489A - SwapSortAll you need is to swap the current minimum with the i-th element each time. You can do it with the code like: for (int i = 0; i < n; i++)\n {\n int j = i;\n for (int t = i; t < n; t++)\n if (a[j] > a[t])\n j = t;\n if (i != j)\n answer.push_back(make_pair(i, j));\n swap(a[i], a[j]);\n }This solution makes at most n-1 swap operation. Also if (i != j) is not necessary.489B - BerSU BallThere are about 100500 ways to solve the problem. You can find maximal matching in a bipartite graph boys-girls, write dynamic programming or just use greedy approach.Let's sort boys and girls by skill. If boy with lowest skill can be matched, it is good idea to match him. It can't reduce answer size. Use girl with lowest skill to match. So you can use code like: sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n for (int j = 0; j < m; j++)\n if (abs(boys[i] - girls[j]) <= 1)\n {\n girls[j] = 1000;\n result++;\n break;\n }489C - Given Length and Sum of Digits...There is a greedy approach to solve the problem. Just try first digit from lower values to higher (in subtask to minimize number) and check if it is possible to construct a tail in such a way that it satisfies rule about length/sum. You can use a function `can(m,s)' that answers if it is possible to construct a sequence of length m with the sum of digits s: bool can(int m, int s)\n{\n return s >= 0 && s <= 9 * m;\n}Using the function can(m,s) you can easily pick up answer digit-by-digit. For the first part of problem (to minimize number) this part of code is: int sum = s;\n for (int i = 0; i < m; i++)\n for (int d = 0; d < 10; d++)\n if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n {\n minn += char('0' + d);\n sum -= d;\n break;\n }The equation (i > 0 || d > 0 || (m == 1 && d == 0)) is needed to be careful with leading zeroes.489D - Unbearable Controversy of BeingLet's iterate through all combinations of a and c just two simple nested loops in O(n2) and find all candidates for b and d inside. To find candidates you can go through all neighbors of a and check that they are neighbors of c. Among all the candidates you should choose two junctions as b and d. So just use https://en.wikipedia.org/wiki/Combination All you need is to add to the answer , where r is the number of candidates (common neighbors of a and c). The code is: for (int a = 0; a < n; a++)\n for (int c = 0; c < n; c++)\n if (a != c)\n {\n int r = 0;\n for (int b = 0; b < nxt[a].size(); b++)\n if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n r++;\n result += r * (r - 1) / 2;\n }It is easy to see that the total complexity is O(nm), because of sum of number of neighbors over all junctions is exactly m.P.S. I'll be grateful if some of you will write editorial of E and F in comments because of now I should leave Codeforces and will return back some hours later. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14741",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 489\\s*A"
          },
          "content_length": 2893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 1",
          "code": "tnks a lot from all of friends who took this contest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 4",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 5",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 3",
          "code": "if (i != j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 4",
          "code": "sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if (abs(boys[i] - girls[j]) <= 1)\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 5",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 6",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 7",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 8",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 9",
          "code": "(i > 0 || d > 0 || (m == 1 && d == 0))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 10",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 11",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 12",
          "code": "cnt[v] * ( cnt[v] - 1 ) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 13",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 14",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 15",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 16",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 17",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 18",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 19",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 20",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 21",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 22",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 23",
          "code": "O(nm + n^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read 'n' and the initial array from the input file\n    int n = inf.readInt(1, 3000);\n    vector<long long> initialArray(n);\n    for (int i = 0; i < n; ++i) {\n        initialArray[i] = inf.readLong(-1000000000LL, 1000000000LL);\n    }\n\n    // Copy the initial array to apply swaps\n    vector<long long> arr = initialArray;\n\n    // Read 'k' from the contestant's output\n    int k = ouf.readInt(0, n, \"k\");\n\n    // Read 'k' swap operations and apply them\n    for (int i = 0; i < k; ++i) {\n        int index1 = ouf.readInt(0, n - 1, format(\"swap[%d][0]\", i + 1).c_str());\n        int index2 = ouf.readInt(0, n - 1, format(\"swap[%d][1]\", i + 1).c_str());\n        swap(arr[index1], arr[index2]);\n    }\n\n    // Check if the array is sorted in non-decreasing order after applying swaps\n    for (int i = 1; i < n; ++i) {\n        if (arr[i - 1] > arr[i]) {\n            quitf(_wa, \"The array is not sorted after applying swaps\");\n        }\n    }\n\n    // If the array is sorted, accept the answer\n    quitf(_ok, \"The array is sorted after %d swaps\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    \n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"sorted\") {\n        a[0] = rnd.next(-1000000000, 1000000000);\n        for (int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 100000); // Ensure non-decreasing order\n            long long val = (long long)a[i-1] + delta;\n            if(val > 1000000000) val = 1000000000;\n            a[i] = (int)val;\n        }\n    } else if (type == \"reverse\") {\n        a[0] = rnd.next(-1000000000, 1000000000);\n        for (int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 100000); // Ensure decreasing order\n            long long val = (long long)a[i-1] - delta;\n            if(val < -1000000000) val = -1000000000;\n            a[i] = (int)val;\n        }\n    } else if (type == \"equal\") {\n        int val = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"duplicates\") {\n        int num_distinct = rnd.next(1, min(n, 10)); // Up to 10 distinct numbers\n        vector<int> vals;\n        for(int i=0; i < num_distinct; ++i)\n            vals.push_back(rnd.next(-1000000000, 1000000000));\n        for(int i=0; i < n; ++i)\n            a[i] = vals[rnd.next(0, num_distinct - 1)];\n    } else if (type == \"maxmin\") {\n        for(int i=0; i < n; ++i) {\n            if(rnd.next(0, 1)) a[i] = -1000000000;\n            else a[i] = 1000000000;\n        }\n    } else if (type == \"small_range\") {\n        int low = rnd.next(-10, 10);\n        int high = low + rnd.next(1, 20);\n        for(int i=0; i < n; ++i)\n            a[i] = rnd.next(low, high);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    \n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"sorted\") {\n        a[0] = rnd.next(-1000000000, 1000000000);\n        for (int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 100000); // Ensure non-decreasing order\n            long long val = (long long)a[i-1] + delta;\n            if(val > 1000000000) val = 1000000000;\n            a[i] = (int)val;\n        }\n    } else if (type == \"reverse\") {\n        a[0] = rnd.next(-1000000000, 1000000000);\n        for (int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 100000); // Ensure decreasing order\n            long long val = (long long)a[i-1] - delta;\n            if(val < -1000000000) val = -1000000000;\n            a[i] = (int)val;\n        }\n    } else if (type == \"equal\") {\n        int val = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"duplicates\") {\n        int num_distinct = rnd.next(1, min(n, 10)); // Up to 10 distinct numbers\n        vector<int> vals;\n        for(int i=0; i < num_distinct; ++i)\n            vals.push_back(rnd.next(-1000000000, 1000000000));\n        for(int i=0; i < n; ++i)\n            a[i] = vals[rnd.next(0, num_distinct - 1)];\n    } else if (type == \"maxmin\") {\n        for(int i=0; i < n; ++i) {\n            if(rnd.next(0, 1)) a[i] = -1000000000;\n            else a[i] = 1000000000;\n        }\n    } else if (type == \"small_range\") {\n        int low = rnd.next(-10, 10);\n        int high = low + rnd.next(1, 20);\n        for(int i=0; i < n; ++i)\n            a[i] = rnd.next(low, high);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type sorted\n./gen -n 1 -type random\n\n./gen -n 2 -type sorted\n./gen -n 2 -type reverse\n./gen -n 2 -type equal\n./gen -n 2 -type duplicates\n\n./gen -n 3 -type sorted\n./gen -n 3 -type reverse\n./gen -n 3 -type maxmin\n./gen -n 3 -type small_range\n\n./gen -n 10 -type random\n./gen -n 10 -type sorted\n./gen -n 10 -type reverse\n./gen -n 10 -type equal\n\n./gen -n 1000 -type random\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reverse\n./gen -n 1000 -type duplicates\n\n./gen -n 2999 -type random\n./gen -n 2999 -type maxmin\n./gen -n 2999 -type small_range\n\n./gen -n 3000 -type random\n./gen -n 3000 -type sorted\n./gen -n 3000 -type reverse\n./gen -n 3000 -type equal\n./gen -n 3000 -type duplicates\n./gen -n 3000 -type maxmin\n./gen -n 3000 -type small_range\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:40.623097",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "489/B",
      "title": "B. BerSU Ball",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 100) — the number of boys. The second line contains sequence a1, a2, ..., an (1 ≤ ai ≤ 100), where ai is the i-th boy's dancing skill.Similarly, the third line contains an integer m (1 ≤ m ≤ 100) — the number of girls. The fourth line contains sequence b1, b2, ..., bm (1 ≤ bj ≤ 100), where bj is the j-th girl's dancing skill.",
      "output_spec": "OutputPrint a single number — the required maximum possible number of pairs.",
      "sample_tests": "ExamplesInputCopy41 4 6 255 1 5 7 9OutputCopy3InputCopy41 2 3 4410 11 12 13OutputCopy0InputCopy51 1 1 1 131 2 3OutputCopy2",
      "description": "B. BerSU Ball\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 100) — the number of boys. The second line contains sequence a1, a2, ..., an (1 ≤ ai ≤ 100), where ai is the i-th boy's dancing skill.Similarly, the third line contains an integer m (1 ≤ m ≤ 100) — the number of girls. The fourth line contains sequence b1, b2, ..., bm (1 ≤ bj ≤ 100), where bj is the j-th girl's dancing skill.\n\nOutputPrint a single number — the required maximum possible number of pairs.\n\nInputCopy41 4 6 255 1 5 7 9OutputCopy3InputCopy41 2 3 4410 11 12 13OutputCopy0InputCopy51 1 1 1 131 2 3OutputCopy2\n\nInputCopy41 4 6 255 1 5 7 9\n\nOutputCopy3\n\nInputCopy41 2 3 4410 11 12 13\n\nOutputCopy0\n\nInputCopy51 1 1 1 131 2 3\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!Actually, I didn't understand how, but I've prepated a round for the second division. I think it is subconscious wanted to soften the hard memories of the round of 276.I hope that very much that the round will be held without any technical issues, as was the 277th.I express my sincere gratitude to all involved in the preparation — Maxim Zlobober Akhmedov, Maria Delinur Belova, Polygon System, servers and James Gosling for Java. Also I am immensely grateful to the driver, who did not knock down me by car, although I, thinking about the problems, was crossing road on red.It will be rated round, 6 problems and non-typical progressive scores: min(500 + i*500, 2500).Wish you to see many Accepteds.UPD. The Round moved 5 minutes forward. I want very much so that no one be late! Sorry.UPD 2. Rating has been updated. But if we will find any cheaters, they will be punished and we will recalculate ratings. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14711",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 955
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces",
          "content": "489A - SwapSortAll you need is to swap the current minimum with the i-th element each time. You can do it with the code like: for (int i = 0; i < n; i++)\n {\n int j = i;\n for (int t = i; t < n; t++)\n if (a[j] > a[t])\n j = t;\n if (i != j)\n answer.push_back(make_pair(i, j));\n swap(a[i], a[j]);\n }This solution makes at most n-1 swap operation. Also if (i != j) is not necessary.489B - BerSU BallThere are about 100500 ways to solve the problem. You can find maximal matching in a bipartite graph boys-girls, write dynamic programming or just use greedy approach.Let's sort boys and girls by skill. If boy with lowest skill can be matched, it is good idea to match him. It can't reduce answer size. Use girl with lowest skill to match. So you can use code like: sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n for (int j = 0; j < m; j++)\n if (abs(boys[i] - girls[j]) <= 1)\n {\n girls[j] = 1000;\n result++;\n break;\n }489C - Given Length and Sum of Digits...There is a greedy approach to solve the problem. Just try first digit from lower values to higher (in subtask to minimize number) and check if it is possible to construct a tail in such a way that it satisfies rule about length/sum. You can use a function `can(m,s)' that answers if it is possible to construct a sequence of length m with the sum of digits s: bool can(int m, int s)\n{\n return s >= 0 && s <= 9 * m;\n}Using the function can(m,s) you can easily pick up answer digit-by-digit. For the first part of problem (to minimize number) this part of code is: int sum = s;\n for (int i = 0; i < m; i++)\n for (int d = 0; d < 10; d++)\n if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n {\n minn += char('0' + d);\n sum -= d;\n break;\n }The equation (i > 0 || d > 0 || (m == 1 && d == 0)) is needed to be careful with leading zeroes.489D - Unbearable Controversy of BeingLet's iterate through all combinations of a and c just two simple nested loops in O(n2) and find all candidates for b and d inside. To find candidates you can go through all neighbors of a and check that they are neighbors of c. Among all the candidates you should choose two junctions as b and d. So just use https://en.wikipedia.org/wiki/Combination All you need is to add to the answer , where r is the number of candidates (common neighbors of a and c). The code is: for (int a = 0; a < n; a++)\n for (int c = 0; c < n; c++)\n if (a != c)\n {\n int r = 0;\n for (int b = 0; b < nxt[a].size(); b++)\n if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n r++;\n result += r * (r - 1) / 2;\n }It is easy to see that the total complexity is O(nm), because of sum of number of neighbors over all junctions is exactly m.P.S. I'll be grateful if some of you will write editorial of E and F in comments because of now I should leave Codeforces and will return back some hours later. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14741",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 489\\s*B"
          },
          "content_length": 2893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 1",
          "code": "tnks a lot from all of friends who took this contest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 4",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 5",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 3",
          "code": "if (i != j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 4",
          "code": "sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if (abs(boys[i] - girls[j]) <= 1)\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 5",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 6",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 7",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 8",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 9",
          "code": "(i > 0 || d > 0 || (m == 1 && d == 0))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 10",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 11",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 12",
          "code": "cnt[v] * ( cnt[v] - 1 ) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 13",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 14",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 15",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 16",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 17",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 18",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 19",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 20",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 21",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 22",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 23",
          "code": "O(nm + n^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> boys(n);\n    vector<int> girls(m);\n\n    if (type == \"random\") {\n        // Generate random skills between 1 and 100\n        for (int i = 0; i < n; ++i)\n            boys[i] = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i)\n            girls[i] = rnd.next(1, 100);\n    } else if (type == \"max_pairs\") {\n        // Generate skills so that every boy can be paired with a girl\n        int skill = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i)\n            boys[i] = skill;\n        for (int i = 0; i < m; ++i)\n            girls[i] = skill;\n    } else if (type == \"min_pairs\") {\n        // Generate skills so that no boy can be paired with any girl\n        int boy_skill = rnd.next(1, 49);\n        int girl_skill = rnd.next(51, 100);\n        for (int i = 0; i < n; ++i)\n            boys[i] = boy_skill;\n        for (int i = 0; i < m; ++i)\n            girls[i] = girl_skill;\n    } else if (type == \"alternate_skills\") {\n        // Alternate boys' skills between two values\n        for (int i = 0; i < n; ++i)\n            boys[i] = (i % 2 == 0) ? 50 : 51;\n        for (int i = 0; i < m; ++i)\n            girls[i] = (i % 2 == 0) ? 51 : 50;\n    } else if (type == \"edge_skills\") {\n        // Set boys' skills to 1, girls' skills to 100, or vice versa\n        for (int i = 0; i < n; ++i)\n            boys[i] = 1;\n        for (int i = 0; i < m; ++i)\n            girls[i] = 100;\n    } else if (type == \"random_same_skills\") {\n        // All boys have the same skill, girls have random skills\n        int boy_skill = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i)\n            boys[i] = boy_skill;\n        for (int i = 0; i < m; ++i)\n            girls[i] = rnd.next(1, 100);\n    } else if (type == \"special_off_by_one\") {\n        // Generate skills that might cause off-by-one errors\n        int base_skill = rnd.next(2, 99);\n        for (int i = 0; i < n; ++i)\n            boys[i] = base_skill + (i % 3) - 1; // Skills: base_skill -1, base_skill, base_skill +1\n        for (int i = 0; i < m; ++i)\n            girls[i] = base_skill + ((i + 1) % 3) - 1; // Offset to differ by exactly 1 or 2\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            boys[i] = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i)\n            girls[i] = rnd.next(1, 100);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", boys[i], i + 1 == n ? '\\n' : ' ');\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d%c\", girls[i], i + 1 == m ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> boys(n);\n    vector<int> girls(m);\n\n    if (type == \"random\") {\n        // Generate random skills between 1 and 100\n        for (int i = 0; i < n; ++i)\n            boys[i] = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i)\n            girls[i] = rnd.next(1, 100);\n    } else if (type == \"max_pairs\") {\n        // Generate skills so that every boy can be paired with a girl\n        int skill = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i)\n            boys[i] = skill;\n        for (int i = 0; i < m; ++i)\n            girls[i] = skill;\n    } else if (type == \"min_pairs\") {\n        // Generate skills so that no boy can be paired with any girl\n        int boy_skill = rnd.next(1, 49);\n        int girl_skill = rnd.next(51, 100);\n        for (int i = 0; i < n; ++i)\n            boys[i] = boy_skill;\n        for (int i = 0; i < m; ++i)\n            girls[i] = girl_skill;\n    } else if (type == \"alternate_skills\") {\n        // Alternate boys' skills between two values\n        for (int i = 0; i < n; ++i)\n            boys[i] = (i % 2 == 0) ? 50 : 51;\n        for (int i = 0; i < m; ++i)\n            girls[i] = (i % 2 == 0) ? 51 : 50;\n    } else if (type == \"edge_skills\") {\n        // Set boys' skills to 1, girls' skills to 100, or vice versa\n        for (int i = 0; i < n; ++i)\n            boys[i] = 1;\n        for (int i = 0; i < m; ++i)\n            girls[i] = 100;\n    } else if (type == \"random_same_skills\") {\n        // All boys have the same skill, girls have random skills\n        int boy_skill = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i)\n            boys[i] = boy_skill;\n        for (int i = 0; i < m; ++i)\n            girls[i] = rnd.next(1, 100);\n    } else if (type == \"special_off_by_one\") {\n        // Generate skills that might cause off-by-one errors\n        int base_skill = rnd.next(2, 99);\n        for (int i = 0; i < n; ++i)\n            boys[i] = base_skill + (i % 3) - 1; // Skills: base_skill -1, base_skill, base_skill +1\n        for (int i = 0; i < m; ++i)\n            girls[i] = base_skill + ((i + 1) % 3) - 1; // Offset to differ by exactly 1 or 2\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            boys[i] = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i)\n            girls[i] = rnd.next(1, 100);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", boys[i], i + 1 == n ? '\\n' : ' ');\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d%c\", girls[i], i + 1 == m ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type max_pairs\n./gen -n 1 -m 1 -type min_pairs\n./gen -n 1 -m 1 -type alternate_skills\n./gen -n 1 -m 1 -type edge_skills\n./gen -n 1 -m 1 -type random_same_skills\n./gen -n 1 -m 1 -type special_off_by_one\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type max_pairs\n./gen -n 10 -m 10 -type min_pairs\n./gen -n 10 -m 10 -type alternate_skills\n./gen -n 10 -m 10 -type edge_skills\n./gen -n 10 -m 10 -type random_same_skills\n./gen -n 10 -m 10 -type special_off_by_one\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type max_pairs\n./gen -n 50 -m 50 -type min_pairs\n./gen -n 50 -m 50 -type alternate_skills\n./gen -n 50 -m 50 -type edge_skills\n./gen -n 50 -m 50 -type random_same_skills\n./gen -n 50 -m 50 -type special_off_by_one\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type max_pairs\n./gen -n 100 -m 100 -type min_pairs\n./gen -n 100 -m 100 -type alternate_skills\n./gen -n 100 -m 100 -type edge_skills\n./gen -n 100 -m 100 -type random_same_skills\n./gen -n 100 -m 100 -type special_off_by_one\n\n./gen -n 100 -m 1 -type random\n./gen -n 1 -m 100 -type random\n./gen -n 100 -m 1 -type max_pairs\n./gen -n 1 -m 100 -type max_pairs\n./gen -n 100 -m 1 -type min_pairs\n./gen -n 1 -m 100 -type min_pairs\n\n./gen -n 99 -m 50 -type random\n./gen -n 50 -m 99 -type random\n\n./gen -n 50 -m 100 -type alternate_skills\n./gen -n 100 -m 50 -type alternate_skills\n\n./gen -n 100 -m 100 -type edge_skills\n\n./gen -n 100 -m 100 -type random_same_skills\n./gen -n 100 -m 30 -type random_same_skills\n\n./gen -n 70 -m 30 -type random\n\n./gen -n 100 -m 100 -type special_off_by_one\n./gen -n 100 -m 99 -type special_off_by_one\n./gen -n 99 -m 100 -type special_off_by_one\n\n./gen -n 100 -m 100 -type random\n\n./gen -n 2 -m 2 -type max_pairs\n./gen -n 2 -m 2 -type min_pairs\n./gen -n 2 -m 2 -type special_off_by_one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:42.354277",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "489/C",
      "title": "C. Given Length and Sum of Digits...",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains a pair of integers m, s (1 ≤ m ≤ 100, 0 ≤ s ≤ 900) — the length and the sum of the digits of the required numbers.",
      "output_spec": "OutputIn the output print the pair of the required non-negative integer numbers — first the minimum possible number, then — the maximum possible number. If no numbers satisfying conditions required exist, print the pair of numbers \"-1 -1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy2 15OutputCopy69 96InputCopy3 0OutputCopy-1 -1",
      "description": "C. Given Length and Sum of Digits...\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains a pair of integers m, s (1 ≤ m ≤ 100, 0 ≤ s ≤ 900) — the length and the sum of the digits of the required numbers.\n\nOutputIn the output print the pair of the required non-negative integer numbers — first the minimum possible number, then — the maximum possible number. If no numbers satisfying conditions required exist, print the pair of numbers \"-1 -1\" (without the quotes).\n\nInputCopy2 15OutputCopy69 96InputCopy3 0OutputCopy-1 -1\n\nInputCopy2 15\n\nOutputCopy69 96\n\nInputCopy3 0\n\nOutputCopy-1 -1",
      "solutions": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!Actually, I didn't understand how, but I've prepated a round for the second division. I think it is subconscious wanted to soften the hard memories of the round of 276.I hope that very much that the round will be held without any technical issues, as was the 277th.I express my sincere gratitude to all involved in the preparation — Maxim Zlobober Akhmedov, Maria Delinur Belova, Polygon System, servers and James Gosling for Java. Also I am immensely grateful to the driver, who did not knock down me by car, although I, thinking about the problems, was crossing road on red.It will be rated round, 6 problems and non-typical progressive scores: min(500 + i*500, 2500).Wish you to see many Accepteds.UPD. The Round moved 5 minutes forward. I want very much so that no one be late! Sorry.UPD 2. Rating has been updated. But if we will find any cheaters, they will be punished and we will recalculate ratings. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14711",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 955
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces",
          "content": "489A - SwapSortAll you need is to swap the current minimum with the i-th element each time. You can do it with the code like: for (int i = 0; i < n; i++)\n {\n int j = i;\n for (int t = i; t < n; t++)\n if (a[j] > a[t])\n j = t;\n if (i != j)\n answer.push_back(make_pair(i, j));\n swap(a[i], a[j]);\n }This solution makes at most n-1 swap operation. Also if (i != j) is not necessary.489B - BerSU BallThere are about 100500 ways to solve the problem. You can find maximal matching in a bipartite graph boys-girls, write dynamic programming or just use greedy approach.Let's sort boys and girls by skill. If boy with lowest skill can be matched, it is good idea to match him. It can't reduce answer size. Use girl with lowest skill to match. So you can use code like: sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n for (int j = 0; j < m; j++)\n if (abs(boys[i] - girls[j]) <= 1)\n {\n girls[j] = 1000;\n result++;\n break;\n }489C - Given Length and Sum of Digits...There is a greedy approach to solve the problem. Just try first digit from lower values to higher (in subtask to minimize number) and check if it is possible to construct a tail in such a way that it satisfies rule about length/sum. You can use a function `can(m,s)' that answers if it is possible to construct a sequence of length m with the sum of digits s: bool can(int m, int s)\n{\n return s >= 0 && s <= 9 * m;\n}Using the function can(m,s) you can easily pick up answer digit-by-digit. For the first part of problem (to minimize number) this part of code is: int sum = s;\n for (int i = 0; i < m; i++)\n for (int d = 0; d < 10; d++)\n if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n {\n minn += char('0' + d);\n sum -= d;\n break;\n }The equation (i > 0 || d > 0 || (m == 1 && d == 0)) is needed to be careful with leading zeroes.489D - Unbearable Controversy of BeingLet's iterate through all combinations of a and c just two simple nested loops in O(n2) and find all candidates for b and d inside. To find candidates you can go through all neighbors of a and check that they are neighbors of c. Among all the candidates you should choose two junctions as b and d. So just use https://en.wikipedia.org/wiki/Combination All you need is to add to the answer , where r is the number of candidates (common neighbors of a and c). The code is: for (int a = 0; a < n; a++)\n for (int c = 0; c < n; c++)\n if (a != c)\n {\n int r = 0;\n for (int b = 0; b < nxt[a].size(); b++)\n if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n r++;\n result += r * (r - 1) / 2;\n }It is easy to see that the total complexity is O(nm), because of sum of number of neighbors over all junctions is exactly m.P.S. I'll be grateful if some of you will write editorial of E and F in comments because of now I should leave Codeforces and will return back some hours later. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14741",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 489\\s*C"
          },
          "content_length": 2893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 1",
          "code": "tnks a lot from all of friends who took this contest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 4",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 5",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 3",
          "code": "if (i != j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 4",
          "code": "sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if (abs(boys[i] - girls[j]) <= 1)\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 5",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 6",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 7",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 8",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 9",
          "code": "(i > 0 || d > 0 || (m == 1 && d == 0))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 10",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 11",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 12",
          "code": "cnt[v] * ( cnt[v] - 1 ) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 13",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 14",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 15",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 16",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 17",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 18",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 19",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 20",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 21",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 22",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 23",
          "code": "O(nm + n^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 900, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 900, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 900, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int s = 0;\n\n    if (type == \"min_sum\") {\n        // Set s to minimal possible sum for given m\n        if (m == 1) {\n            // Sum can range from 0 to 9 for a single-digit number\n            s = rnd.next(0, 9);\n        } else {\n            // The smallest non-zero sum for multi-digit numbers is 1\n            s = 1;\n        }\n    } else if (type == \"max_sum\") {\n        // Set s to maximal possible sum for given m\n        s = min(900, 9 * m);\n    } else if (type == \"no_solution\") {\n        if (m == 1) {\n            // For m = 1, any s > 9 has no solution\n            s = rnd.next(10, 900);\n        } else {\n            // For m > 1, s = 0 or s > 9 * m has no solution\n            if (rnd.next(2)) {\n                s = 0; // No solution when s = 0 and m > 1\n            } else {\n                int max_s = min(900, 9 * m);\n                if (max_s < 900) {\n                    s = rnd.next(max_s + 1, 900); // s greater than maximum possible sum\n                } else {\n                    s = 900; // No solution when s > 9 * m\n                }\n            }\n        }\n    } else if (type == \"boundary\") {\n        // Generate boundary cases for s\n        int choice = rnd.next(1, 3);\n        if (choice == 1) {\n            s = 0; // Boundary case where s = 0\n        } else if (choice == 2) {\n            s = 1; // Boundary case where s = 1\n        } else {\n            s = min(900, 9 * m); // Boundary case where s is maximum possible sum\n        }\n    } else if (type == \"random\") {\n        // Generate random valid s\n        int max_s = min(900, 9 * m);\n        s = rnd.next(0, max_s);\n    } else {\n        // Handle other types or default to random\n        int max_s = min(900, 9 * m);\n        s = rnd.next(0, max_s);\n    }\n\n    // Ensure s is within [0, 900]\n    s = max(0, min(s, 900));\n\n    // Output m and s\n    printf(\"%d %d\\n\", m, s);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int s = 0;\n\n    if (type == \"min_sum\") {\n        // Set s to minimal possible sum for given m\n        if (m == 1) {\n            // Sum can range from 0 to 9 for a single-digit number\n            s = rnd.next(0, 9);\n        } else {\n            // The smallest non-zero sum for multi-digit numbers is 1\n            s = 1;\n        }\n    } else if (type == \"max_sum\") {\n        // Set s to maximal possible sum for given m\n        s = min(900, 9 * m);\n    } else if (type == \"no_solution\") {\n        if (m == 1) {\n            // For m = 1, any s > 9 has no solution\n            s = rnd.next(10, 900);\n        } else {\n            // For m > 1, s = 0 or s > 9 * m has no solution\n            if (rnd.next(2)) {\n                s = 0; // No solution when s = 0 and m > 1\n            } else {\n                int max_s = min(900, 9 * m);\n                if (max_s < 900) {\n                    s = rnd.next(max_s + 1, 900); // s greater than maximum possible sum\n                } else {\n                    s = 900; // No solution when s > 9 * m\n                }\n            }\n        }\n    } else if (type == \"boundary\") {\n        // Generate boundary cases for s\n        int choice = rnd.next(1, 3);\n        if (choice == 1) {\n            s = 0; // Boundary case where s = 0\n        } else if (choice == 2) {\n            s = 1; // Boundary case where s = 1\n        } else {\n            s = min(900, 9 * m); // Boundary case where s is maximum possible sum\n        }\n    } else if (type == \"random\") {\n        // Generate random valid s\n        int max_s = min(900, 9 * m);\n        s = rnd.next(0, max_s);\n    } else {\n        // Handle other types or default to random\n        int max_s = min(900, 9 * m);\n        s = rnd.next(0, max_s);\n    }\n\n    // Ensure s is within [0, 900]\n    s = max(0, min(s, 900));\n\n    // Output m and s\n    printf(\"%d %d\\n\", m, s);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 1 -type min_sum\n./gen -m 1 -type max_sum\n./gen -m 1 -type no_solution\n./gen -m 1 -type random\n\n./gen -m 2 -type min_sum\n./gen -m 2 -type max_sum\n./gen -m 2 -type no_solution\n./gen -m 2 -type random\n\n./gen -m 5 -type min_sum\n./gen -m 5 -type max_sum\n./gen -m 5 -type no_solution\n./gen -m 5 -type random\n\n./gen -m 10 -type min_sum\n./gen -m 10 -type max_sum\n./gen -m 10 -type no_solution\n./gen -m 10 -type random\n\n./gen -m 50 -type min_sum\n./gen -m 50 -type max_sum\n./gen -m 50 -type no_solution\n./gen -m 50 -type random\n\n./gen -m 99 -type min_sum\n./gen -m 99 -type max_sum\n./gen -m 99 -type no_solution\n./gen -m 99 -type random\n\n./gen -m 100 -type min_sum\n./gen -m 100 -type max_sum\n./gen -m 100 -type no_solution\n./gen -m 100 -type random\n\n./gen -m 1 -type boundary\n./gen -m 2 -type boundary\n./gen -m 10 -type boundary\n./gen -m 50 -type boundary\n./gen -m 99 -type boundary\n./gen -m 100 -type boundary\n\n./gen -m 3 -type random\n./gen -m 7 -type random\n./gen -m 15 -type random\n./gen -m 30 -type random\n./gen -m 60 -type random\n./gen -m 90 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:44.557319",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "489/D",
      "title": "D. Невыносимая запутанность бытия",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записана пара целых чисел n, m (1 ≤ n ≤ 3000, 0 ≤ m ≤ 30000) — количество перекрестков и дорог соответственно. Далее в m строках перечислены дороги по одной в строке. Каждая из дорог задана парой целых чисел ai, bi (1 ≤ ai, bi ≤ n;ai ≠ bi) — номером перекрестка откуда она ведет и номером перекрестка куда она ведет. Между парой перекрестков существует не более одной дороги в каждом из двух направлений.Не гарантируется, что из любого перекрестка можно добрать до любого другого.",
      "output_spec": "Выходные данныеВыведите искомое количество «чёртовых ромбов».",
      "sample_tests": "ПримерыВходные данныеСкопировать5 41 22 31 44 3Выходные данныеСкопировать1Входные данныеСкопировать4 121 21 31 42 12 32 43 13 23 44 14 24 3Выходные данныеСкопировать12",
      "description": "D. Невыносимая запутанность бытия\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записана пара целых чисел n, m (1 ≤ n ≤ 3000, 0 ≤ m ≤ 30000) — количество перекрестков и дорог соответственно. Далее в m строках перечислены дороги по одной в строке. Каждая из дорог задана парой целых чисел ai, bi (1 ≤ ai, bi ≤ n;ai ≠ bi) — номером перекрестка откуда она ведет и номером перекрестка куда она ведет. Между парой перекрестков существует не более одной дороги в каждом из двух направлений.Не гарантируется, что из любого перекрестка можно добрать до любого другого.\n\nВходные данные\n\nВыходные данныеВыведите искомое количество «чёртовых ромбов».\n\nВыходные данные\n\nВходные данныеСкопировать5 41 22 31 44 3Выходные данныеСкопировать1Входные данныеСкопировать4 121 21 31 42 12 32 43 13 23 44 14 24 3Выходные данныеСкопировать12\n\nВходные данныеСкопировать5 41 22 31 44 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 121 21 31 42 12 32 43 13 23 44 14 24 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces",
          "content": "Добрый день, Codeforces!Как-то даже я сам не понял как, но я вдруг взял и подготовил раунд для второго дивизиона. Мне кажется, это подсознание захотело как-то еще смягчить воспоминания о раунде 276.Я очень надеюсь, что раунд пройдет на ура, как и прошел 277-й — без каких-либо нареканий на работу системы.Выражаю искренние слова благодарности всем задействованным в подготовке — Максиму Zlobober Ахмедову, Марии Delinur Беловой, Полигону, серверам и Джеймсу Гослингу за Java. Еще я безмерно благодарен тому водителю, который меня всё-таки сегодня не задавил, хотя я, задумавшись о задачах, шел на красный.Раунд будет рейтинговым, задач будет 6, а разбалловка — неклассической min(500 + i*500, 2500).Удачи!UPD.: Раунд передвинут на 5 минут вперед — мне очень хочется, чтобы все, кто хочет принять участие, успели на него. Извините.UPD 2.: Рейтинг предварительно обновлен. Найдем читеров — применим меры, обновим еще раз. Спасибо за участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14711",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 939
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces",
          "content": "489A - SwapSortAll you need is to swap the current minimum with the i-th element each time. You can do it with the code like: for (int i = 0; i < n; i++)\n {\n int j = i;\n for (int t = i; t < n; t++)\n if (a[j] > a[t])\n j = t;\n if (i != j)\n answer.push_back(make_pair(i, j));\n swap(a[i], a[j]);\n }This solution makes at most n-1 swap operation. Also if (i != j) is not necessary.489B - BerSU BallThere are about 100500 ways to solve the problem. You can find maximal matching in a bipartite graph boys-girls, write dynamic programming or just use greedy approach.Let's sort boys and girls by skill. If boy with lowest skill can be matched, it is good idea to match him. It can't reduce answer size. Use girl with lowest skill to match. So you can use code like: sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n for (int j = 0; j < m; j++)\n if (abs(boys[i] - girls[j]) <= 1)\n {\n girls[j] = 1000;\n result++;\n break;\n }489C - Given Length and Sum of Digits...There is a greedy approach to solve the problem. Just try first digit from lower values to higher (in subtask to minimize number) and check if it is possible to construct a tail in such a way that it satisfies rule about length/sum. You can use a function `can(m,s)' that answers if it is possible to construct a sequence of length m with the sum of digits s: bool can(int m, int s)\n{\n return s >= 0 && s <= 9 * m;\n}Using the function can(m,s) you can easily pick up answer digit-by-digit. For the first part of problem (to minimize number) this part of code is: int sum = s;\n for (int i = 0; i < m; i++)\n for (int d = 0; d < 10; d++)\n if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n {\n minn += char('0' + d);\n sum -= d;\n break;\n }The equation (i > 0 || d > 0 || (m == 1 && d == 0)) is needed to be careful with leading zeroes.489D - Unbearable Controversy of BeingLet's iterate through all combinations of a and c just two simple nested loops in O(n2) and find all candidates for b and d inside. To find candidates you can go through all neighbors of a and check that they are neighbors of c. Among all the candidates you should choose two junctions as b and d. So just use https://en.wikipedia.org/wiki/Combination All you need is to add to the answer , where r is the number of candidates (common neighbors of a and c). The code is: for (int a = 0; a < n; a++)\n for (int c = 0; c < n; c++)\n if (a != c)\n {\n int r = 0;\n for (int b = 0; b < nxt[a].size(); b++)\n if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n r++;\n result += r * (r - 1) / 2;\n }It is easy to see that the total complexity is O(nm), because of sum of number of neighbors over all junctions is exactly m.P.S. I'll be grateful if some of you will write editorial of E and F in comments because of now I should leave Codeforces and will return back some hours later. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14741",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 489\\s*D"
          },
          "content_length": 2893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 1",
          "code": "tnks a lot from all of friends who took this contest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 4",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 5",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 3",
          "code": "if (i != j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 4",
          "code": "sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if (abs(boys[i] - girls[j]) <= 1)\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 5",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 6",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 7",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 8",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 9",
          "code": "(i > 0 || d > 0 || (m == 1 && d == 0))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 10",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 11",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 12",
          "code": "cnt[v] * ( cnt[v] - 1 ) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 13",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 14",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 15",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 16",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 17",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 18",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 19",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 20",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 21",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 22",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 23",
          "code": "O(nm + n^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 30000, \"m\");\n    inf.readEoln();\n    set< pair<int,int> > edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Self-loops are not allowed (edge from %d to %d)\", ai, bi);\n        pair<int,int> edge = make_pair(ai, bi);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge from %d to %d\", ai, bi);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 30000, \"m\");\n    inf.readEoln();\n    set< pair<int,int> > edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Self-loops are not allowed (edge from %d to %d)\", ai, bi);\n        pair<int,int> edge = make_pair(ai, bi);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge from %d to %d\", ai, bi);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 30000, \"m\");\n    inf.readEoln();\n    set< pair<int,int> > edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Self-loops are not allowed (edge from %d to %d)\", ai, bi);\n        pair<int,int> edge = make_pair(ai, bi);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge from %d to %d\", ai, bi);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // If m is -1, it will be adjusted accordingly.\n    string type = opt<string>(\"type\", \"random_sparse\");\n    int layers = opt<int>(\"layers\", 2); // Used for 'maximal_rhombi' type.\n\n    vector<pair<int,int>> edges; // List of edges.\n    set<pair<int,int>> edgeSet;  // To ensure no duplicate edges.\n\n    if (type == \"empty\") {\n        // Empty graph with no edges.\n        m = 0;\n        // Nothing to do.\n    } else if (type == \"chain\") {\n        // Chain graph: Nodes connected in a line.\n        m = n - 1;\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n            edgeSet.insert({i, i+1});\n        }\n    } else if (type == \"star_in\") {\n        // Star graph with edges from center to leaves.\n        int center = 1;\n        m = n - 1;\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({center, i});\n            edgeSet.insert({center, i});\n        }\n    } else if (type == \"star_out\") {\n        // Star graph with edges from leaves to center.\n        int center = 1;\n        m = n - 1;\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({i, center});\n            edgeSet.insert({i, center});\n        }\n    } else if (type == \"full\") {\n        // Fully connected graph (excluding self-loops).\n        m = n * (n - 1);\n        for(int i = 1; i <= n; ++i) {\n            for(int j = 1; j <= n; ++j) {\n                if (i != j) {\n                    edges.push_back({i, j});\n                    edgeSet.insert({i, j});\n                }\n            }\n        }\n    } else if (type == \"random_sparse\" || type == \"random_dense\") {\n        // Random graph with specified density.\n        int maxEdges = n * (n - 1);\n        if (m == -1) {\n            if (type == \"random_sparse\") {\n                m = rnd.next(n, min(maxEdges, n * 10)); // Sparse graph.\n            } else {\n                m = rnd.next(min(maxEdges, n * 10), maxEdges); // Dense graph.\n            }\n        } else {\n            m = min(m, maxEdges);\n        }\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b && edgeSet.find({a, b}) == edgeSet.end()) {\n                edges.push_back({a, b});\n                edgeSet.insert({a, b});\n            }\n        }\n    } else if (type == \"maximal_rhombi\") {\n        // Generate a graph designed to maximize the number of rhombi.\n        // Create layers and connect every node in a layer to every node in the next layer.\n        if (layers < 2 || layers > n) layers = 2;\n        vector<vector<int>> layerNodes(layers);\n        int idx = 1;\n        for(int l = 0; l < layers; ++l) {\n            int layerSize = n / layers + (l < n % layers);\n            for(int i = 0; i < layerSize; ++i) {\n                layerNodes[l].push_back(idx++);\n            }\n        }\n        for(int l = 0; l < layers - 1; ++l) {\n            for(int u : layerNodes[l]) {\n                for(int v : layerNodes[l + 1]) {\n                    edges.push_back({u, v});\n                    edgeSet.insert({u, v});\n                }\n            }\n        }\n        m = edges.size();\n    } else if (type == \"minimal_rhombi\") {\n        // Generate a graph designed to minimize the number of rhombi.\n        // Use a chain graph (no rhombi).\n        m = n - 1;\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n            edgeSet.insert({i, i + 1});\n        }\n    } else {\n        // Default to random_sparse if unknown type.\n        type = \"random_sparse\";\n        int maxEdges = n * (n - 1);\n        if (m == -1) {\n            m = rnd.next(n, min(maxEdges, n * 10));\n        } else {\n            m = min(m, maxEdges);\n        }\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b && edgeSet.find({a, b}) == edgeSet.end()) {\n                edges.push_back({a, b});\n                edgeSet.insert({a, b});\n            }\n        }\n    }\n\n    // Output the graph.\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // If m is -1, it will be adjusted accordingly.\n    string type = opt<string>(\"type\", \"random_sparse\");\n    int layers = opt<int>(\"layers\", 2); // Used for 'maximal_rhombi' type.\n\n    vector<pair<int,int>> edges; // List of edges.\n    set<pair<int,int>> edgeSet;  // To ensure no duplicate edges.\n\n    if (type == \"empty\") {\n        // Empty graph with no edges.\n        m = 0;\n        // Nothing to do.\n    } else if (type == \"chain\") {\n        // Chain graph: Nodes connected in a line.\n        m = n - 1;\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n            edgeSet.insert({i, i+1});\n        }\n    } else if (type == \"star_in\") {\n        // Star graph with edges from center to leaves.\n        int center = 1;\n        m = n - 1;\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({center, i});\n            edgeSet.insert({center, i});\n        }\n    } else if (type == \"star_out\") {\n        // Star graph with edges from leaves to center.\n        int center = 1;\n        m = n - 1;\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({i, center});\n            edgeSet.insert({i, center});\n        }\n    } else if (type == \"full\") {\n        // Fully connected graph (excluding self-loops).\n        m = n * (n - 1);\n        for(int i = 1; i <= n; ++i) {\n            for(int j = 1; j <= n; ++j) {\n                if (i != j) {\n                    edges.push_back({i, j});\n                    edgeSet.insert({i, j});\n                }\n            }\n        }\n    } else if (type == \"random_sparse\" || type == \"random_dense\") {\n        // Random graph with specified density.\n        int maxEdges = n * (n - 1);\n        if (m == -1) {\n            if (type == \"random_sparse\") {\n                m = rnd.next(n, min(maxEdges, n * 10)); // Sparse graph.\n            } else {\n                m = rnd.next(min(maxEdges, n * 10), maxEdges); // Dense graph.\n            }\n        } else {\n            m = min(m, maxEdges);\n        }\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b && edgeSet.find({a, b}) == edgeSet.end()) {\n                edges.push_back({a, b});\n                edgeSet.insert({a, b});\n            }\n        }\n    } else if (type == \"maximal_rhombi\") {\n        // Generate a graph designed to maximize the number of rhombi.\n        // Create layers and connect every node in a layer to every node in the next layer.\n        if (layers < 2 || layers > n) layers = 2;\n        vector<vector<int>> layerNodes(layers);\n        int idx = 1;\n        for(int l = 0; l < layers; ++l) {\n            int layerSize = n / layers + (l < n % layers);\n            for(int i = 0; i < layerSize; ++i) {\n                layerNodes[l].push_back(idx++);\n            }\n        }\n        for(int l = 0; l < layers - 1; ++l) {\n            for(int u : layerNodes[l]) {\n                for(int v : layerNodes[l + 1]) {\n                    edges.push_back({u, v});\n                    edgeSet.insert({u, v});\n                }\n            }\n        }\n        m = edges.size();\n    } else if (type == \"minimal_rhombi\") {\n        // Generate a graph designed to minimize the number of rhombi.\n        // Use a chain graph (no rhombi).\n        m = n - 1;\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n            edgeSet.insert({i, i + 1});\n        }\n    } else {\n        // Default to random_sparse if unknown type.\n        type = \"random_sparse\";\n        int maxEdges = n * (n - 1);\n        if (m == -1) {\n            m = rnd.next(n, min(maxEdges, n * 10));\n        } else {\n            m = min(m, maxEdges);\n        }\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b && edgeSet.find({a, b}) == edgeSet.end()) {\n                edges.push_back({a, b});\n                edgeSet.insert({a, b});\n            }\n        }\n    }\n\n    // Output the graph.\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type empty\n./gen -n 2 -type empty\n./gen -n 2 -type chain\n./gen -n 3 -type chain\n./gen -n 5 -type minimal_rhombi\n./gen -n 10 -type chain\n./gen -n 10 -type star_in\n./gen -n 10 -type star_out\n./gen -n 10 -type full\n./gen -n 5 -type random_sparse\n./gen -n 5 -type random_dense\n./gen -n 100 -type random_sparse\n./gen -n 100 -type random_dense\n./gen -n 100 -type maximal_rhombi -layers 2\n./gen -n 300 -type minimal_rhombi\n./gen -n 300 -type maximal_rhombi -layers 5\n./gen -n 1000 -type chain\n./gen -n 1000 -type star_in\n./gen -n 1000 -type star_out\n./gen -n 1000 -type maximal_rhombi -layers 10\n./gen -n 1000 -type random_sparse\n./gen -n 1000 -type random_dense\n./gen -n 3000 -type minimal_rhombi\n./gen -n 3000 -type chain\n./gen -n 3000 -type star_in\n./gen -n 3000 -type star_out\n./gen -n 3000 -type maximal_rhombi -layers 15\n./gen -n 3000 -m 30000 -type random_dense\n./gen -n 3000 -m 1000 -type random_sparse\n./gen -n 500 -type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:46.548561",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "489/E",
      "title": "E. Поход",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны целые числа n, l (1 ≤ n ≤ 1000, 1 ≤ l ≤ 105) — количество мест для ночлега и оптимальная длина пути за одни сутки.Далее следует n строк, каждая строка описывает одно место для ночлега парой целых чисел xi, bi (1 ≤ xi, bi ≤ 106). Никакие два места для ночлега не имеют одинаковые xi, строки заданы в порядке строго возрастания xi.",
      "output_spec": "Выходные данныеВыведите маршрут путешественника в виде последовательности номеров использованных мест ночлега в порядке их прохождения. Места нумеруйте от 1 до n в порядке возрастания xi. Последнее выведенное число обязательно должно быть равно n.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 910 1020 1030 131 540 10Выходные данныеСкопировать1 2 4 5",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записаны целые числа n, l (1 ≤ n ≤ 1000, 1 ≤ l ≤ 105) — количество мест для ночлега и оптимальная длина пути за одни сутки.Далее следует n строк, каждая строка описывает одно место для ночлега парой целых чисел xi, bi (1 ≤ xi, bi ≤ 106). Никакие два места для ночлега не имеют одинаковые xi, строки заданы в порядке строго возрастания xi.\n\nВходные данные\n\nВыходные данныеВыведите маршрут путешественника в виде последовательности номеров использованных мест ночлега в порядке их прохождения. Места нумеруйте от 1 до n в порядке возрастания xi. Последнее выведенное число обязательно должно быть равно n.\n\nВыходные данные\n\nВходные данныеСкопировать5 910 1020 1030 131 540 10Выходные данныеСкопировать1 2 4 5\n\nВходные данныеСкопировать5 910 1020 1030 131 540 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 4 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ тесте из примера минимальное значение относительного суммарного недовольства примерно равно 0.097549. Это значение может быть вычислено как .",
      "solutions": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces",
          "content": "Добрый день, Codeforces!Как-то даже я сам не понял как, но я вдруг взял и подготовил раунд для второго дивизиона. Мне кажется, это подсознание захотело как-то еще смягчить воспоминания о раунде 276.Я очень надеюсь, что раунд пройдет на ура, как и прошел 277-й — без каких-либо нареканий на работу системы.Выражаю искренние слова благодарности всем задействованным в подготовке — Максиму Zlobober Ахмедову, Марии Delinur Беловой, Полигону, серверам и Джеймсу Гослингу за Java. Еще я безмерно благодарен тому водителю, который меня всё-таки сегодня не задавил, хотя я, задумавшись о задачах, шел на красный.Раунд будет рейтинговым, задач будет 6, а разбалловка — неклассической min(500 + i*500, 2500).Удачи!UPD.: Раунд передвинут на 5 минут вперед — мне очень хочется, чтобы все, кто хочет принять участие, успели на него. Извините.UPD 2.: Рейтинг предварительно обновлен. Найдем читеров — применим меры, обновим еще раз. Спасибо за участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14711",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 939
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces",
          "content": "489A - SwapSortAll you need is to swap the current minimum with the i-th element each time. You can do it with the code like: for (int i = 0; i < n; i++)\n {\n int j = i;\n for (int t = i; t < n; t++)\n if (a[j] > a[t])\n j = t;\n if (i != j)\n answer.push_back(make_pair(i, j));\n swap(a[i], a[j]);\n }This solution makes at most n-1 swap operation. Also if (i != j) is not necessary.489B - BerSU BallThere are about 100500 ways to solve the problem. You can find maximal matching in a bipartite graph boys-girls, write dynamic programming or just use greedy approach.Let's sort boys and girls by skill. If boy with lowest skill can be matched, it is good idea to match him. It can't reduce answer size. Use girl with lowest skill to match. So you can use code like: sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n for (int j = 0; j < m; j++)\n if (abs(boys[i] - girls[j]) <= 1)\n {\n girls[j] = 1000;\n result++;\n break;\n }489C - Given Length and Sum of Digits...There is a greedy approach to solve the problem. Just try first digit from lower values to higher (in subtask to minimize number) and check if it is possible to construct a tail in such a way that it satisfies rule about length/sum. You can use a function `can(m,s)' that answers if it is possible to construct a sequence of length m with the sum of digits s: bool can(int m, int s)\n{\n return s >= 0 && s <= 9 * m;\n}Using the function can(m,s) you can easily pick up answer digit-by-digit. For the first part of problem (to minimize number) this part of code is: int sum = s;\n for (int i = 0; i < m; i++)\n for (int d = 0; d < 10; d++)\n if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n {\n minn += char('0' + d);\n sum -= d;\n break;\n }The equation (i > 0 || d > 0 || (m == 1 && d == 0)) is needed to be careful with leading zeroes.489D - Unbearable Controversy of BeingLet's iterate through all combinations of a and c just two simple nested loops in O(n2) and find all candidates for b and d inside. To find candidates you can go through all neighbors of a and check that they are neighbors of c. Among all the candidates you should choose two junctions as b and d. So just use https://en.wikipedia.org/wiki/Combination All you need is to add to the answer , where r is the number of candidates (common neighbors of a and c). The code is: for (int a = 0; a < n; a++)\n for (int c = 0; c < n; c++)\n if (a != c)\n {\n int r = 0;\n for (int b = 0; b < nxt[a].size(); b++)\n if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n r++;\n result += r * (r - 1) / 2;\n }It is easy to see that the total complexity is O(nm), because of sum of number of neighbors over all junctions is exactly m.P.S. I'll be grateful if some of you will write editorial of E and F in comments because of now I should leave Codeforces and will return back some hours later. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14741",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 489 和字母"
          },
          "content_length": 2893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 1",
          "code": "tnks a lot from all of friends who took this contest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 4",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 5",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 3",
          "code": "if (i != j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 4",
          "code": "sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if (abs(boys[i] - girls[j]) <= 1)\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 5",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 6",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 7",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 8",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 9",
          "code": "(i > 0 || d > 0 || (m == 1 && d == 0))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 10",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 11",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 12",
          "code": "cnt[v] * ( cnt[v] - 1 ) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 13",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 14",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 15",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 16",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 17",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 18",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 19",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 20",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 21",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 22",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 23",
          "code": "O(nm + n^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000);\n    inf.readSpace();\n    int l = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    int last_xi = -1;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 1000000);\n        if (i > 0) {\n            ensuref(xi > last_xi, \"xi must be strictly increasing\");\n        }\n        last_xi = xi;\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000);\n    inf.readSpace();\n    int l = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    int last_xi = -1;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 1000000);\n        if (i > 0) {\n            ensuref(xi > last_xi, \"xi must be strictly increasing\");\n        }\n        last_xi = xi;\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000);\n    inf.readSpace();\n    int l = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    int last_xi = -1;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 1000000);\n        if (i > 0) {\n            ensuref(xi > last_xi, \"xi must be strictly increasing\");\n        }\n        last_xi = xi;\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-6;\n\nint n, l;\nvector<int> xi, bi;\n\ndouble readAndEvaluateAnswer(InStream& stream) {\n    vector<int> path;\n    set<int> used_rest_points;\n    while (!stream.seekEof()) {\n        int p = stream.readInt(1, n, \"rest point index\");\n        if (!used_rest_points.insert(p).second) {\n            stream.quitf(_wa, \"Rest point %d is visited more than once\", p);\n        }\n        path.push_back(p);\n    }\n    if (path.empty()) {\n        stream.quitf(_wa, \"Empty path\");\n    }\n    // Check that path ends at rest point n\n    if (path.back() != n) {\n        stream.quitf(_wa, \"The last rest point is %d, expected %d\", path.back(), n);\n    }\n    // Check that positions are strictly increasing\n    for (size_t i = 0; i < path.size(); ++i) {\n        int index = path[i] - 1; // Zero-based index\n        if (i > 0) {\n            int prev_index = path[i - 1] - 1;\n            if (xi[prev_index] >= xi[index]) {\n                stream.quitf(_wa, \"Positions are not strictly increasing at rest point %d\", path[i]);\n            }\n        } else {\n            // Check that xi[index] > 0\n            if (xi[index] <= 0) {\n                stream.quitf(_wa, \"First rest point position is not greater than 0\");\n            }\n        }\n    }\n    // Compute total frustration and total picturesqueness\n    double total_frustration = 0.0;\n    long long total_bi = 0;\n    int prev_pos = 0;\n    for (size_t i = 0; i < path.size(); ++i) {\n        int index = path[i] - 1;\n        int curr_pos = xi[index];\n        long long rj = curr_pos - prev_pos;\n        total_frustration += 1.0 * (rj - l) * (rj - l);\n        total_bi += bi[index];\n        prev_pos = curr_pos;\n    }\n    double rel_total_frustration = total_frustration / total_bi;\n    return rel_total_frustration;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 1000, \"n\");\n    l = inf.readInt(1, 100000, \"l\");\n    xi.resize(n);\n    bi.resize(n);\n    for (int i = 0; i < n; ++i) {\n        xi[i] = inf.readInt(1, 1000000, format(\"xi[%d]\", i + 1).c_str());\n        bi[i] = inf.readInt(1, 1000000, format(\"bi[%d]\", i + 1).c_str());\n    }\n    \n    for (int i = 1; i < n; ++i) {\n        if (xi[i - 1] >= xi[i]) {\n            quitf(_fail, \"Positions xi are not in strictly increasing order in the input\");\n        }\n    }\n    \n    double min_rel_frustration = readAndEvaluateAnswer(ans);\n    double participant_rel_frustration = readAndEvaluateAnswer(ouf);\n    \n    if (participant_rel_frustration <= min_rel_frustration + EPS) {\n        quitf(_ok, \"Relative total frustration = %.10f\", participant_rel_frustration);\n    } else {\n        quitf(_wa, \"Relative total frustration is not minimal: your value = %.10f, minimal value = %.10f\", participant_rel_frustration, min_rel_frustration);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    string xi_type = opt<string>(\"xi_type\", \"uniform\");\n    string bi_type = opt<string>(\"bi_type\", \"random\");\n\n    vector<int> xi(n);\n    const int max_xi = 1e6;\n\n    // Generate xi based on xi_type\n    if (xi_type == \"uniform\") {\n        xi[0] = 1;\n        xi[n - 1] = max_xi;\n        for (int i = 1; i < n - 1; ++i) {\n            xi[i] = xi[0] + (long long)(xi[n - 1] - xi[0]) * i / (n - 1);\n        }\n    } else if (xi_type == \"min_gaps\") {\n        xi[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            xi[i] = xi[i - 1] + 1; // Minimal gap of 1\n        }\n    } else if (xi_type == \"max_gaps\") {\n        xi[0] = 1;\n        int gap = (max_xi - n) / n + 1; // Ensure we don't exceed max_xi\n        for (int i = 1; i < n; ++i) {\n            xi[i] = xi[i - 1] + gap;\n        }\n    } else if (xi_type == \"clustered\") {\n        int num_clusters = rnd.next(1, min(n, 10));\n        vector<int> cluster_centers;\n        for (int i = 0; i < num_clusters; ++i) {\n            int center = rnd.next(1, max_xi);\n            cluster_centers.push_back(center);\n        }\n        sort(cluster_centers.begin(), cluster_centers.end());\n\n        vector<int> cluster_sizes(num_clusters);\n        int remaining = n;\n        for (int i = 0; i < num_clusters; ++i) {\n            if (i == num_clusters - 1) {\n                cluster_sizes[i] = remaining;\n            } else {\n                cluster_sizes[i] = rnd.next(1, remaining - (num_clusters - i - 1));\n            }\n            remaining -= cluster_sizes[i];\n        }\n\n        int idx = 0;\n        for (int c = 0; c < num_clusters; ++c) {\n            int center = cluster_centers[c];\n            int sz = cluster_sizes[c];\n            set<int> points;\n            while ((int)points.size() < sz) {\n                int offset = rnd.next(-1000, 1000);\n                int x = center + offset;\n                if (x >= 1 && x <= max_xi)\n                    points.insert(x);\n            }\n            vector<int> pts(points.begin(), points.end());\n            sort(pts.begin(), pts.end());\n            for (int x : pts) {\n                xi[idx++] = x;\n            }\n        }\n        sort(xi.begin(), xi.end());\n    } else if (xi_type == \"random\") {\n        set<int> xs;\n        while ((int)xs.size() < n) {\n            int x = rnd.next(1, max_xi);\n            xs.insert(x);\n        }\n        xi.assign(xs.begin(), xs.end());\n        sort(xi.begin(), xi.end());\n    } else {\n        // Default to uniform if unknown xi_type\n        xi[0] = 1;\n        xi[n - 1] = max_xi;\n        for (int i = 1; i < n - 1; ++i) {\n            xi[i] = xi[0] + (long long)(xi[n - 1] - xi[0]) * i / (n - 1);\n        }\n    }\n\n    // Generate bi based on bi_type\n    vector<int> bi(n);\n    if (bi_type == \"constant\") {\n        int c = opt<int>(\"bi_constant\", 1);\n        for (int i = 0; i < n; ++i) {\n            bi[i] = c;\n        }\n    } else if (bi_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = int(1e6);\n        }\n    } else if (bi_type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 1;\n        }\n    } else if (bi_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, int(1e6));\n        }\n    } else {\n        // Default to random if unknown bi_type\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, int(1e6));\n        }\n    }\n\n    // Output n and l\n    printf(\"%d %d\\n\", n, l);\n\n    // Output xi and bi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xi[i], bi[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    string xi_type = opt<string>(\"xi_type\", \"uniform\");\n    string bi_type = opt<string>(\"bi_type\", \"random\");\n\n    vector<int> xi(n);\n    const int max_xi = 1e6;\n\n    // Generate xi based on xi_type\n    if (xi_type == \"uniform\") {\n        xi[0] = 1;\n        xi[n - 1] = max_xi;\n        for (int i = 1; i < n - 1; ++i) {\n            xi[i] = xi[0] + (long long)(xi[n - 1] - xi[0]) * i / (n - 1);\n        }\n    } else if (xi_type == \"min_gaps\") {\n        xi[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            xi[i] = xi[i - 1] + 1; // Minimal gap of 1\n        }\n    } else if (xi_type == \"max_gaps\") {\n        xi[0] = 1;\n        int gap = (max_xi - n) / n + 1; // Ensure we don't exceed max_xi\n        for (int i = 1; i < n; ++i) {\n            xi[i] = xi[i - 1] + gap;\n        }\n    } else if (xi_type == \"clustered\") {\n        int num_clusters = rnd.next(1, min(n, 10));\n        vector<int> cluster_centers;\n        for (int i = 0; i < num_clusters; ++i) {\n            int center = rnd.next(1, max_xi);\n            cluster_centers.push_back(center);\n        }\n        sort(cluster_centers.begin(), cluster_centers.end());\n\n        vector<int> cluster_sizes(num_clusters);\n        int remaining = n;\n        for (int i = 0; i < num_clusters; ++i) {\n            if (i == num_clusters - 1) {\n                cluster_sizes[i] = remaining;\n            } else {\n                cluster_sizes[i] = rnd.next(1, remaining - (num_clusters - i - 1));\n            }\n            remaining -= cluster_sizes[i];\n        }\n\n        int idx = 0;\n        for (int c = 0; c < num_clusters; ++c) {\n            int center = cluster_centers[c];\n            int sz = cluster_sizes[c];\n            set<int> points;\n            while ((int)points.size() < sz) {\n                int offset = rnd.next(-1000, 1000);\n                int x = center + offset;\n                if (x >= 1 && x <= max_xi)\n                    points.insert(x);\n            }\n            vector<int> pts(points.begin(), points.end());\n            sort(pts.begin(), pts.end());\n            for (int x : pts) {\n                xi[idx++] = x;\n            }\n        }\n        sort(xi.begin(), xi.end());\n    } else if (xi_type == \"random\") {\n        set<int> xs;\n        while ((int)xs.size() < n) {\n            int x = rnd.next(1, max_xi);\n            xs.insert(x);\n        }\n        xi.assign(xs.begin(), xs.end());\n        sort(xi.begin(), xi.end());\n    } else {\n        // Default to uniform if unknown xi_type\n        xi[0] = 1;\n        xi[n - 1] = max_xi;\n        for (int i = 1; i < n - 1; ++i) {\n            xi[i] = xi[0] + (long long)(xi[n - 1] - xi[0]) * i / (n - 1);\n        }\n    }\n\n    // Generate bi based on bi_type\n    vector<int> bi(n);\n    if (bi_type == \"constant\") {\n        int c = opt<int>(\"bi_constant\", 1);\n        for (int i = 0; i < n; ++i) {\n            bi[i] = c;\n        }\n    } else if (bi_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = int(1e6);\n        }\n    } else if (bi_type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 1;\n        }\n    } else if (bi_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, int(1e6));\n        }\n    } else {\n        // Default to random if unknown bi_type\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, int(1e6));\n        }\n    }\n\n    // Output n and l\n    printf(\"%d %d\\n\", n, l);\n\n    // Output xi and bi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xi[i], bi[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -l 1 -xi_type min_gaps -bi_type min\n\n./gen -n 5 -l 10 -xi_type min_gaps -bi_type constant -bi_constant 1\n\n./gen -n 5 -l 10 -xi_type max_gaps -bi_type max\n\n./gen -n 5 -l 10 -xi_type uniform -bi_type random\n\n./gen -n 5 -l 10 -xi_type clustered -bi_type random\n\n./gen -n 1000 -l 100000 -xi_type min_gaps -bi_type min\n\n./gen -n 1000 -l 100000 -xi_type max_gaps -bi_type max\n\n./gen -n 1000 -l 100000 -xi_type uniform -bi_type random\n\n./gen -n 1000 -l 50000 -xi_type clustered -bi_type random\n\n./gen -n 1000 -l 1 -xi_type min_gaps -bi_type min\n\n./gen -n 1000 -l 1 -xi_type max_gaps -bi_type max\n\n./gen -n 1000 -l 1 -xi_type uniform -bi_type constant -bi_constant 1\n\n./gen -n 1000 -l 100000 -xi_type clustered -bi_type constant -bi_constant 1\n\n./gen -n 500 -l 1000 -xi_type uniform -bi_type random\n\n./gen -n 500 -l 50000 -xi_type uniform -bi_type random\n\n./gen -n 2 -l 1 -xi_type min_gaps -bi_type min\n\n./gen -n 2 -l 100000 -xi_type max_gaps -bi_type max\n\n./gen -n 999 -l 50000 -xi_type clustered -bi_type random\n\n./gen -n 1000 -l 100000 -xi_type random -bi_type random\n\n./gen -n 500 -l 50000 -xi_type uniform -bi_type constant -bi_constant 1000000\n\n./gen -n 1000 -l 100000 -xi_type uniform -bi_type min\n\n./gen -n 3 -l 10000 -xi_type uniform -bi_type random\n\n./gen -n 997 -l 100000 -xi_type min_gaps -bi_type max\n\n./gen -n 1000 -l 10 -xi_type clustered -bi_type constant -bi_constant 1\n\n./gen -n 1000 -l 99999 -xi_type max_gaps -bi_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:49.045146",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "489/F",
      "title": "F. Особые матрицы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит три целых чисел n, m, mod (2 ≤ n ≤ 500, 0 ≤ m ≤ n, 2 ≤ mod ≤ 109). Далее идут m строк по n символов в каждой из них — первые строки искомых особых матриц. В каждой из этих строк ровно два символа '1' и все остальные символы — '0'. В каждом столбце заданной m × n таблицы не более двух единиц.",
      "output_spec": "Выходные данныеВыведите остаток при делении искомого количества на число mod.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1 1000011Выходные данныеСкопировать2Входные данныеСкопировать4 4 1005000110101001011001Выходные данныеСкопировать1",
      "description": "F. Особые матрицы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка входных данных содержит три целых чисел n, m, mod (2 ≤ n ≤ 500, 0 ≤ m ≤ n, 2 ≤ mod ≤ 109). Далее идут m строк по n символов в каждой из них — первые строки искомых особых матриц. В каждой из этих строк ровно два символа '1' и все остальные символы — '0'. В каждом столбце заданной m × n таблицы не более двух единиц.\n\nВходные данные\n\nВыходные данныеВыведите остаток при делении искомого количества на число mod.\n\nВыходные данные\n\nВходные данныеСкопировать3 1 1000011Выходные данныеСкопировать2Входные данныеСкопировать4 4 1005000110101001011001Выходные данныеСкопировать1\n\nВходные данныеСкопировать3 1 1000011\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 4 1005000110101001011001\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеДля первого теста искомые матрицы: 011101110011110101Во втором тесте особая матрица уже задана полностью, поэтому ответ 1.",
      "solutions": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces",
          "content": "Добрый день, Codeforces!Как-то даже я сам не понял как, но я вдруг взял и подготовил раунд для второго дивизиона. Мне кажется, это подсознание захотело как-то еще смягчить воспоминания о раунде 276.Я очень надеюсь, что раунд пройдет на ура, как и прошел 277-й — без каких-либо нареканий на работу системы.Выражаю искренние слова благодарности всем задействованным в подготовке — Максиму Zlobober Ахмедову, Марии Delinur Беловой, Полигону, серверам и Джеймсу Гослингу за Java. Еще я безмерно благодарен тому водителю, который меня всё-таки сегодня не задавил, хотя я, задумавшись о задачах, шел на красный.Раунд будет рейтинговым, задач будет 6, а разбалловка — неклассической min(500 + i*500, 2500).Удачи!UPD.: Раунд передвинут на 5 минут вперед — мне очень хочется, чтобы все, кто хочет принять участие, успели на него. Извините.UPD 2.: Рейтинг предварительно обновлен. Найдем читеров — применим меры, обновим еще раз. Спасибо за участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14711",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 939
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces",
          "content": "489A - SwapSortAll you need is to swap the current minimum with the i-th element each time. You can do it with the code like: for (int i = 0; i < n; i++)\n {\n int j = i;\n for (int t = i; t < n; t++)\n if (a[j] > a[t])\n j = t;\n if (i != j)\n answer.push_back(make_pair(i, j));\n swap(a[i], a[j]);\n }This solution makes at most n-1 swap operation. Also if (i != j) is not necessary.489B - BerSU BallThere are about 100500 ways to solve the problem. You can find maximal matching in a bipartite graph boys-girls, write dynamic programming or just use greedy approach.Let's sort boys and girls by skill. If boy with lowest skill can be matched, it is good idea to match him. It can't reduce answer size. Use girl with lowest skill to match. So you can use code like: sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n for (int j = 0; j < m; j++)\n if (abs(boys[i] - girls[j]) <= 1)\n {\n girls[j] = 1000;\n result++;\n break;\n }489C - Given Length and Sum of Digits...There is a greedy approach to solve the problem. Just try first digit from lower values to higher (in subtask to minimize number) and check if it is possible to construct a tail in such a way that it satisfies rule about length/sum. You can use a function `can(m,s)' that answers if it is possible to construct a sequence of length m with the sum of digits s: bool can(int m, int s)\n{\n return s >= 0 && s <= 9 * m;\n}Using the function can(m,s) you can easily pick up answer digit-by-digit. For the first part of problem (to minimize number) this part of code is: int sum = s;\n for (int i = 0; i < m; i++)\n for (int d = 0; d < 10; d++)\n if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n {\n minn += char('0' + d);\n sum -= d;\n break;\n }The equation (i > 0 || d > 0 || (m == 1 && d == 0)) is needed to be careful with leading zeroes.489D - Unbearable Controversy of BeingLet's iterate through all combinations of a and c just two simple nested loops in O(n2) and find all candidates for b and d inside. To find candidates you can go through all neighbors of a and check that they are neighbors of c. Among all the candidates you should choose two junctions as b and d. So just use https://en.wikipedia.org/wiki/Combination All you need is to add to the answer , where r is the number of candidates (common neighbors of a and c). The code is: for (int a = 0; a < n; a++)\n for (int c = 0; c < n; c++)\n if (a != c)\n {\n int r = 0;\n for (int b = 0; b < nxt[a].size(); b++)\n if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n r++;\n result += r * (r - 1) / 2;\n }It is easy to see that the total complexity is O(nm), because of sum of number of neighbors over all junctions is exactly m.P.S. I'll be grateful if some of you will write editorial of E and F in comments because of now I should leave Codeforces and will return back some hours later. Thank you for participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14741",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 489 和字母"
          },
          "content_length": 2893
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 1",
          "code": "tnks a lot from all of friends who took this contest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=0;i<n;i++)\n  for (int j=i+1;j<=n;j++)\n  {\n   double cost=-sqrt(fabs(.0+x[j]-x[i]-L));\n   cost+=b[j]*ratio;\n   if (best[j]<best[i]+cost)\n   {\n    best[j]=best[i]+cost;\n    par[j]=i;\n   }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 4",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) - Codeforces - Code 5",
          "code": "const int MAX_N=3001;\n\tbool matrix[MAX_N][MAX_N]={false};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14711",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n    {\n        int j = i;\n        for (int t = i; t < n; t++)\n            if (a[j] > a[t])\n                j = t;\n        if (i != j)\n            answer.push_back(make_pair(i, j));\n        swap(a[i], a[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 3",
          "code": "if (i != j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 4",
          "code": "sort(boys.begin(), boys.end());\nsort(girls.begin(), girls.end());\n\nfor (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if (abs(boys[i] - girls[j]) <= 1)\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 5",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 6",
          "code": "bool can(int m, int s)\n{\n    return s >= 0 && s <= 9 * m;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 7",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 8",
          "code": "int sum = s;\n    for (int i = 0; i < m; i++)\n        for (int d = 0; d < 10; d++)\n            if ((i > 0 || d > 0 || (m == 1 && d == 0)) && can(m - i - 1, sum - d))\n            {\n                minn += char('0' + d);\n                sum -= d;\n                break;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 9",
          "code": "(i > 0 || d > 0 || (m == 1 && d == 0))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 10",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 11",
          "code": "for (int a = 0; a < n; a++)\n        for (int c = 0; c < n; c++)\n            if (a != c)\n            {\n                int r = 0;\n                for (int b = 0; b < nxt[a].size(); b++)\n                    if (nxt[a][b] != a && nxt[a][b] != c && g[nxt[a][b]][c])\n                        r++;\n                result += r * (r - 1) / 2;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 12",
          "code": "cnt[v] * ( cnt[v] - 1 ) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 13",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 14",
          "code": "for i,j:\n  [i-2][j+2] += [i][j] * C(i,2)\n  [i-1][j-1+1] += [i][j] * C(i,1)*C(j,1)\n  [i][j-2] += [i][j] * C(j,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 15",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 16",
          "code": "[i-2][j+2] += [i][j] * C(i,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 17",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 18",
          "code": "[i][j]+=[i+2][j-2]*C(i+2,2)\n[i][j]+=...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 19",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 20",
          "code": "for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n        if( ... )\n        {\n            girls[j] = 1000;\n            result++;\n            break;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 21",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 22",
          "code": "for (int b = 0; b < nxt[a].size(); b++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #277.5 (Div. 2) Editorial [A-D for now] - Codeforces - Code 23",
          "code": "O(nm + n^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14741",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, mod with constraints\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int mod = inf.readInt(2, 1000000000, \"mod\");\n    inf.readEoln();\n\n    vector<int> col_count(n, 0);\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine();\n\n        ensuref((int)s.length() == n, \"Line %d has length %d instead of %d\", i+1, (int)s.length(), n);\n\n        int ones_in_row = 0;\n\n        for (int j = 0; j < n; ++j) {\n            char c = s[j];\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' at row %d column %d\", c, i+1, j+1);\n\n            if (c == '1') {\n                ones_in_row++;\n\n                col_count[j]++;\n                ensuref(col_count[j] <= 2, \"Column %d has more than 2 ones after row %d\", j+1, i+1);\n            }\n        }\n        ensuref(ones_in_row == 2, \"Row %d has %d ones instead of 2\", i+1, ones_in_row);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, mod with constraints\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int mod = inf.readInt(2, 1000000000, \"mod\");\n    inf.readEoln();\n\n    vector<int> col_count(n, 0);\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine();\n\n        ensuref((int)s.length() == n, \"Line %d has length %d instead of %d\", i+1, (int)s.length(), n);\n\n        int ones_in_row = 0;\n\n        for (int j = 0; j < n; ++j) {\n            char c = s[j];\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' at row %d column %d\", c, i+1, j+1);\n\n            if (c == '1') {\n                ones_in_row++;\n\n                col_count[j]++;\n                ensuref(col_count[j] <= 2, \"Column %d has more than 2 ones after row %d\", j+1, i+1);\n            }\n        }\n        ensuref(ones_in_row == 2, \"Row %d has %d ones instead of 2\", i+1, ones_in_row);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, mod with constraints\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int mod = inf.readInt(2, 1000000000, \"mod\");\n    inf.readEoln();\n\n    vector<int> col_count(n, 0);\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine();\n\n        ensuref((int)s.length() == n, \"Line %d has length %d instead of %d\", i+1, (int)s.length(), n);\n\n        int ones_in_row = 0;\n\n        for (int j = 0; j < n; ++j) {\n            char c = s[j];\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' at row %d column %d\", c, i+1, j+1);\n\n            if (c == '1') {\n                ones_in_row++;\n\n                col_count[j]++;\n                ensuref(col_count[j] <= 2, \"Column %d has more than 2 ones after row %d\", j+1, i+1);\n            }\n        }\n        ensuref(ones_in_row == 2, \"Row %d has %d ones instead of 2\", i+1, ones_in_row);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int mod = opt<int>(\"mod\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(2 <= n && n <= 500);\n    ensure(0 <= m && m <= n);\n    ensure(2 <= mod && mod <= 1000000000);\n\n    vector<string> rows(m, string(n, '0'));\n\n    if (type == \"random\") {\n        // Generate random valid initial m rows\n        vector<int> col_counts(n, 0);\n        for (int i = 0; i < m; i++) {\n            vector<int> indices(n);\n            for (int j = 0; j < n; j++)\n                indices[j] = j;\n            shuffle(indices.begin(), indices.end());\n\n            int idx1 = indices[0];\n            int idx2 = indices[1];\n\n            rows[i][idx1] = '1';\n            rows[i][idx2] = '1';\n            col_counts[idx1]++;\n            col_counts[idx2]++;\n        }\n\n        // Ensure no column has more than two ones\n        for (int j = 0; j < n; j++) {\n            if (col_counts[j] > 2) {\n                // Can't fix, make the problem impossible\n                type = \"impossible\";\n                break;\n            }\n        }\n\n        if (type == \"impossible\") {\n            // Can't fix the rows, so output impossible test case\n            // We'll overwrite rows with impossible ones\n            rows.assign(m, string(n, '0'));\n            for (int i = 0; i < m; i++) {\n                rows[i][0] = '1';\n                rows[i][1] = '1';\n            }\n            // Overfill column 0 and 1\n        }\n\n    } else if (type == \"impossible\") {\n        // Create an impossible initial m rows where some column has more than two ones\n        rows.assign(m, string(n, '0'));\n        for (int i = 0; i < m; i++) {\n            rows[i][0] = '1';\n            rows[i][1] = '1';\n        }\n        // Overfill column 0 and 1\n    } else if (type == \"full\") {\n        // Set m = n, and generate a full valid special matrix\n        m = n;\n        rows.resize(n, string(n, '0'));\n        for (int i = 0; i < n; i++) {\n            int idx1 = i;\n            int idx2 = (i + 1) % n; // Ensure no duplicates\n            rows[i][idx1] = '1';\n            rows[i][idx2] = '1';\n        }\n    } else if (type == \"overfilled\") {\n        // Overfill columns to make the problem impossible\n        rows.assign(m, string(n, '0'));\n        for (int i = 0; i < m; i++) {\n            int col = i % n;\n            rows[i][col] = '1';\n            rows[i][(col + 1) % n] = '1';\n            rows[i][(col + 2) % n] = '1'; // Overfill columns\n        }\n    } else if (type == \"zero_case\") {\n        // m = 0\n        m = 0;\n        rows.clear();\n    } else if (type == \"max_n\") {\n        // n = 500\n        n = 500;\n        ensure(m <= n);\n        // Generate random valid initial m rows\n        rows.assign(m, string(n, '0'));\n        vector<int> col_counts(n, 0);\n        for (int i = 0; i < m; i++) {\n            vector<int> indices(n);\n            for (int j = 0; j < n; j++)\n                indices[j] = j;\n            shuffle(indices.begin(), indices.end());\n            int idx1 = indices[0];\n            int idx2 = indices[1];\n            rows[i][idx1] = '1';\n            rows[i][idx2] = '1';\n            col_counts[idx1]++;\n            col_counts[idx2]++;\n        }\n    } else if (type == \"min_n\") {\n        // n = 2\n        n = 2;\n        ensure(m <= n);\n        rows.assign(m, string(n, '0'));\n        for (int i = 0; i < m; i++) {\n            rows[i][0] = '1';\n            rows[i][1] = '1';\n        }\n    } else if (type == \"m_equals_1\") {\n        // m = 1\n        m = 1;\n        ensure(m <= n);\n        rows.assign(m, string(n, '0'));\n        vector<int> indices(n);\n        for (int j = 0; j < n; j++)\n            indices[j] = j;\n        shuffle(indices.begin(), indices.end());\n        rows[0][indices[0]] = '1';\n        rows[0][indices[1]] = '1';\n    } else {\n        // Default to random\n        // Generate random valid initial m rows\n        vector<int> col_counts(n, 0);\n        for (int i = 0; i < m; i++) {\n            vector<int> indices(n);\n            for (int j = 0; j < n; j++)\n                indices[j] = j;\n            shuffle(indices.begin(), indices.end());\n\n            int idx1 = indices[0];\n            int idx2 = indices[1];\n\n            rows[i][idx1] = '1';\n            rows[i][idx2] = '1';\n            col_counts[idx1]++;\n            col_counts[idx2]++;\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, mod);\n    for (int i = 0; i < m; i++) {\n        printf(\"%s\\n\", rows[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int mod = opt<int>(\"mod\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(2 <= n && n <= 500);\n    ensure(0 <= m && m <= n);\n    ensure(2 <= mod && mod <= 1000000000);\n\n    vector<string> rows(m, string(n, '0'));\n\n    if (type == \"random\") {\n        // Generate random valid initial m rows\n        vector<int> col_counts(n, 0);\n        for (int i = 0; i < m; i++) {\n            vector<int> indices(n);\n            for (int j = 0; j < n; j++)\n                indices[j] = j;\n            shuffle(indices.begin(), indices.end());\n\n            int idx1 = indices[0];\n            int idx2 = indices[1];\n\n            rows[i][idx1] = '1';\n            rows[i][idx2] = '1';\n            col_counts[idx1]++;\n            col_counts[idx2]++;\n        }\n\n        // Ensure no column has more than two ones\n        for (int j = 0; j < n; j++) {\n            if (col_counts[j] > 2) {\n                // Can't fix, make the problem impossible\n                type = \"impossible\";\n                break;\n            }\n        }\n\n        if (type == \"impossible\") {\n            // Can't fix the rows, so output impossible test case\n            // We'll overwrite rows with impossible ones\n            rows.assign(m, string(n, '0'));\n            for (int i = 0; i < m; i++) {\n                rows[i][0] = '1';\n                rows[i][1] = '1';\n            }\n            // Overfill column 0 and 1\n        }\n\n    } else if (type == \"impossible\") {\n        // Create an impossible initial m rows where some column has more than two ones\n        rows.assign(m, string(n, '0'));\n        for (int i = 0; i < m; i++) {\n            rows[i][0] = '1';\n            rows[i][1] = '1';\n        }\n        // Overfill column 0 and 1\n    } else if (type == \"full\") {\n        // Set m = n, and generate a full valid special matrix\n        m = n;\n        rows.resize(n, string(n, '0'));\n        for (int i = 0; i < n; i++) {\n            int idx1 = i;\n            int idx2 = (i + 1) % n; // Ensure no duplicates\n            rows[i][idx1] = '1';\n            rows[i][idx2] = '1';\n        }\n    } else if (type == \"overfilled\") {\n        // Overfill columns to make the problem impossible\n        rows.assign(m, string(n, '0'));\n        for (int i = 0; i < m; i++) {\n            int col = i % n;\n            rows[i][col] = '1';\n            rows[i][(col + 1) % n] = '1';\n            rows[i][(col + 2) % n] = '1'; // Overfill columns\n        }\n    } else if (type == \"zero_case\") {\n        // m = 0\n        m = 0;\n        rows.clear();\n    } else if (type == \"max_n\") {\n        // n = 500\n        n = 500;\n        ensure(m <= n);\n        // Generate random valid initial m rows\n        rows.assign(m, string(n, '0'));\n        vector<int> col_counts(n, 0);\n        for (int i = 0; i < m; i++) {\n            vector<int> indices(n);\n            for (int j = 0; j < n; j++)\n                indices[j] = j;\n            shuffle(indices.begin(), indices.end());\n            int idx1 = indices[0];\n            int idx2 = indices[1];\n            rows[i][idx1] = '1';\n            rows[i][idx2] = '1';\n            col_counts[idx1]++;\n            col_counts[idx2]++;\n        }\n    } else if (type == \"min_n\") {\n        // n = 2\n        n = 2;\n        ensure(m <= n);\n        rows.assign(m, string(n, '0'));\n        for (int i = 0; i < m; i++) {\n            rows[i][0] = '1';\n            rows[i][1] = '1';\n        }\n    } else if (type == \"m_equals_1\") {\n        // m = 1\n        m = 1;\n        ensure(m <= n);\n        rows.assign(m, string(n, '0'));\n        vector<int> indices(n);\n        for (int j = 0; j < n; j++)\n            indices[j] = j;\n        shuffle(indices.begin(), indices.end());\n        rows[0][indices[0]] = '1';\n        rows[0][indices[1]] = '1';\n    } else {\n        // Default to random\n        // Generate random valid initial m rows\n        vector<int> col_counts(n, 0);\n        for (int i = 0; i < m; i++) {\n            vector<int> indices(n);\n            for (int j = 0; j < n; j++)\n                indices[j] = j;\n            shuffle(indices.begin(), indices.end());\n\n            int idx1 = indices[0];\n            int idx2 = indices[1];\n\n            rows[i][idx1] = '1';\n            rows[i][idx2] = '1';\n            col_counts[idx1]++;\n            col_counts[idx2]++;\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, mod);\n    for (int i = 0; i < m; i++) {\n        printf(\"%s\\n\", rows[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 0 -mod 2 -type zero_case\n./gen -n 2 -m 2 -mod 10 -type full\n./gen -n 2 -m 2 -mod 1000 -type overfilled\n./gen -n 3 -m 1 -mod 1000 -type random\n./gen -n 3 -m 3 -mod 1000 -type impossible\n./gen -n 10 -m 0 -mod 1000000000 -type random\n./gen -n 10 -m 5 -mod 1000000000 -type random\n./gen -n 10 -m 10 -mod 1000000000 -type full\n./gen -n 10 -m 10 -mod 1000000000 -type impossible\n./gen -n 10 -m 10 -mod 1000000000 -type overfilled\n./gen -n 100 -m 0 -mod 1000000000 -type random\n./gen -n 100 -m 50 -mod 1000000000 -type random\n./gen -n 100 -m 100 -mod 1000000000 -type full\n./gen -n 100 -m 100 -mod 1000000000 -type impossible\n./gen -n 100 -m 100 -mod 1000000000 -type overfilled\n./gen -n 500 -m 0 -mod 1000000000 -type random\n./gen -n 500 -m 250 -mod 1000000000 -type random\n./gen -n 500 -m 500 -mod 1000000000 -type full\n./gen -n 500 -m 500 -mod 1000000000 -type impossible\n./gen -n 500 -m 500 -mod 1000000000 -type overfilled\n./gen -n 500 -m 0 -mod 1000000000 -type max_n\n./gen -n 2 -m 2 -mod 1000000000 -type min_n\n./gen -n 2 -m 1 -mod 2 -type m_equals_1\n./gen -n 10 -m 1 -mod 1000000000 -type m_equals_1\n./gen -n 100 -m 1 -mod 1000000000 -type m_equals_1\n./gen -n 500 -m 1 -mod 1000000000 -type m_equals_1\n./gen -n 250 -m 0 -mod 1000000000 -type random\n./gen -n 250 -m 125 -mod 1000000000 -type random\n./gen -n 250 -m 250 -mod 1000000000 -type full\n./gen -n 300 -m 0 -mod 1000000000 -type random\n./gen -n 300 -m 300 -mod 1000000000 -type impossible\n./gen -n 500 -m 0 -mod 1000000000 -type zero_case\n./gen -n 500 -m 499 -mod 1000000000 -type random\n./gen -n 500 -m 500 -mod 2 -type overfilled\n./gen -n 201 -m 100 -mod 1000000000 -type random\n./gen -n 500 -m 250 -mod 1000000000 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:51.099064",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "49/A",
      "title": "A. Sleuth",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains a question represented by a non-empty line consisting of large and small Latin letters, spaces and a question mark. The line length does not exceed 100. It is guaranteed that the question mark occurs exactly once in the line — as the last symbol and that the line contains at least one letter.",
      "output_spec": "OutputPrint answer for the question in a single line: YES if the answer is \"Yes\", NO if the answer is \"No\".Remember that in the reply to the question the last letter, not the last character counts. I. e. the spaces and the question mark do not count as letters.",
      "sample_tests": "ExamplesInputCopyIs it a melon?OutputCopyNOInputCopyIs it an apple?OutputCopyYESInputCopy  Is     it a banana ?OutputCopyYESInputCopyIs   it an apple  and a  banana   simultaneouSLY?OutputCopyYES",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains a question represented by a non-empty line consisting of large and small Latin letters, spaces and a question mark. The line length does not exceed 100. It is guaranteed that the question mark occurs exactly once in the line — as the last symbol and that the line contains at least one letter.\n\nOutputPrint answer for the question in a single line: YES if the answer is \"Yes\", NO if the answer is \"No\".Remember that in the reply to the question the last letter, not the last character counts. I. e. the spaces and the question mark do not count as letters.\n\nInputCopyIs it a melon?OutputCopyNOInputCopyIs it an apple?OutputCopyYESInputCopy  Is     it a banana ?OutputCopyYESInputCopyIs   it an apple  and a  banana   simultaneouSLY?OutputCopyYES\n\nInputCopyIs it a melon?\n\nOutputCopyNO\n\nInputCopyIs it an apple?\n\nOutputCopyYES\n\nInputCopy  Is     it a banana ?\n\nOutputCopyYES\n\nInputCopyIs   it an apple  and a  banana   simultaneouSLY?\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good evening! Soon many of you will have your examinations, and someone even have it now. I wish you excellent marks and many easy exams! Thanks to Nickolay Kuznetsov, Gerald Agapov and Ivan Fefer for their help in preparation of the round. Good luck! Artem Rakhov and Codeforces teamUPD:StandingsProblemsWinner: ghostof2007Ratings will be updated later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "ababaaba2c->bac->cc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "wrong answer 1st numbers differ - expected: '4', found: '3'------------------------------When i run the program on my system i get Anser as 4 not 3here is my program (i have removed the header files)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 3",
          "code": "101000101001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n\n    int s_length = s.length();\n\n    ensuref(s_length >= 1, \"Line is empty\");\n\n    ensuref(s_length <= 100, \"Line length exceeds 100, length=%d\", s_length);\n\n    ensuref(s.back() == '?', \"Line must end with '?' character\");\n\n    int qm_in_body = count(s.begin(), s.end() - 1, '?');\n\n    ensuref(qm_in_body == 0, \"Question mark must occur only at the end\");\n\n    int letterCount = 0;\n\n    for (int i = 0; i < s_length - 1; ++i) {\n        char c = s[i];\n        ensuref(isalpha(c) || c == ' ', \"Invalid character '%c' at position %d\", c, i + 1);\n        if (isalpha(c)) letterCount++;\n    }\n\n    ensuref(letterCount >= 1, \"Line must contain at least one letter\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n\n    int s_length = s.length();\n\n    ensuref(s_length >= 1, \"Line is empty\");\n\n    ensuref(s_length <= 100, \"Line length exceeds 100, length=%d\", s_length);\n\n    ensuref(s.back() == '?', \"Line must end with '?' character\");\n\n    int qm_in_body = count(s.begin(), s.end() - 1, '?');\n\n    ensuref(qm_in_body == 0, \"Question mark must occur only at the end\");\n\n    int letterCount = 0;\n\n    for (int i = 0; i < s_length - 1; ++i) {\n        char c = s[i];\n        ensuref(isalpha(c) || c == ' ', \"Invalid character '%c' at position %d\", c, i + 1);\n        if (isalpha(c)) letterCount++;\n    }\n\n    ensuref(letterCount >= 1, \"Line must contain at least one letter\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n\n    int s_length = s.length();\n\n    ensuref(s_length >= 1, \"Line is empty\");\n\n    ensuref(s_length <= 100, \"Line length exceeds 100, length=%d\", s_length);\n\n    ensuref(s.back() == '?', \"Line must end with '?' character\");\n\n    int qm_in_body = count(s.begin(), s.end() - 1, '?');\n\n    ensuref(qm_in_body == 0, \"Question mark must occur only at the end\");\n\n    int letterCount = 0;\n\n    for (int i = 0; i < s_length - 1; ++i) {\n        char c = s[i];\n        ensuref(isalpha(c) || c == ' ', \"Invalid character '%c' at position %d\", c, i + 1);\n        if (isalpha(c)) letterCount++;\n    }\n\n    ensuref(letterCount >= 1, \"Line must contain at least one letter\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char c) {\n    c = toupper(c);\n    return c=='A'||c=='E'||c=='I'||c=='O'||c=='U'||c=='Y';\n}\n\nchar getRandomVowel() {\n    char vowels[] = {'A','E','I','O','U','Y'};\n    return vowels[rnd.next(6)];\n}\n\nchar getRandomConsonant() {\n    char consonants[] = {'B','C','D','F','G','H','J','K','L','M','N','P','Q','R','S','T','V','W','X','Z'};\n    return consonants[rnd.next(20)];\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (len == -1) len = rnd.next(2, 100);\n    if (len < 2) len = 2;\n    if (len > 100) len = 100;\n\n    string s = \"\";\n\n    if (type == \"random\") {\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\", \"question\", \"answer\", \"yes\", \"no\", \"maybe\", \"why\", \"how\", \"what\", \"who\", \"when\", \"where\", \"do\", \"does\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\", \"might\", \"have\", \"has\", \"had\", \"was\", \"were\", \"be\", \"being\", \"been\", \"and\", \"the\", \"an\", \"a\"};\n        int len_limit = len - 1; // Exclude '?'\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int add_space = (total_length > 0) ? 1 : 0;\n            if (total_length + word.length() + add_space > len_limit) break;\n\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        s += '?';\n\n    } else if (type == \"vowel_end\") {\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\", \"question\", \"answer\", \"yes\", \"no\", \"maybe\", \"why\", \"how\", \"what\", \"who\", \"when\", \"where\", \"do\", \"does\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\", \"might\", \"have\", \"has\", \"had\", \"was\", \"were\", \"be\", \"being\", \"been\", \"and\", \"the\", \"an\", \"a\"};\n        int len_limit = len -1;\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int add_space = (total_length > 0) ? 1 : 0;\n\n            if (total_length + word.length() + add_space >= len_limit -1) break;\n\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        // Generate last word ending with vowel\n        string last_word;\n        while (true) {\n            last_word = sample_words[rnd.next(sample_words.size())];\n            if (isVowel(last_word.back())) {\n                break;\n            }\n        }\n\n        int add_space = (total_length > 0) ? 1 : 0;\n        if (total_length + last_word.length() + add_space > len_limit) {\n            // Adjust last_word to fit\n            int available_length = len_limit - total_length - add_space;\n            if (available_length > 0) {\n                last_word = last_word.substr(0, available_length);\n                // Ensure last letter is vowel\n                if (!isVowel(last_word.back())) {\n                    last_word.back() = getRandomVowel();\n                }\n\n                if (add_space) {\n                    s += \" \";\n                    total_length +=1;\n                }\n                s += last_word;\n                total_length += last_word.length();\n            }\n        } else {\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n            s += last_word;\n            total_length += last_word.length();\n        }\n\n        s += '?';\n\n    } else if (type == \"consonant_end\") {\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\", \"question\", \"answer\", \"yes\", \"no\", \"maybe\", \"why\", \"how\", \"what\", \"who\", \"when\", \"where\", \"do\", \"does\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\", \"might\", \"have\", \"has\", \"had\", \"was\", \"were\", \"be\", \"being\", \"been\", \"and\", \"the\", \"an\", \"a\"};\n        int len_limit = len -1;\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int add_space = (total_length > 0) ? 1 : 0;\n\n            if (total_length + word.length() + add_space >= len_limit -1) break;\n\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        // Generate last word ending with consonant\n        string last_word;\n        while (true) {\n            last_word = sample_words[rnd.next(sample_words.size())];\n            if (!isVowel(last_word.back())) {\n                break;\n            }\n        }\n\n        int add_space = (total_length > 0) ? 1 : 0;\n        if (total_length + last_word.length() + add_space > len_limit) {\n            int available_length = len_limit - total_length - add_space;\n            if (available_length > 0) {\n                last_word = last_word.substr(0, available_length);\n                // Ensure last letter is consonant\n                if (isVowel(last_word.back())) {\n                    last_word.back() = getRandomConsonant();\n                }\n\n                if (add_space) {\n                    s += \" \";\n                    total_length +=1;\n                }\n                s += last_word;\n                total_length += last_word.length();\n            }\n        } else {\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n            s += last_word;\n            total_length += last_word.length();\n        }\n\n        s += '?';\n\n    } else if (type == \"max_length\") {\n        len = 100;\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\", \"question\", \"answer\", \"yes\", \"no\", \"maybe\", \"why\", \"how\", \"what\", \"who\", \"when\", \"where\", \"do\", \"does\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\", \"might\", \"have\", \"has\", \"had\", \"was\", \"were\", \"be\", \"being\", \"been\", \"and\", \"the\", \"an\", \"a\"};\n        int len_limit = len -1;\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int add_space = (total_length > 0) ? 1 : 0;\n            if (total_length + word.length() + add_space > len_limit) break;\n\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        s += '?';\n\n    } else if (type == \"min_length\") {\n        s = \"A?\";\n    } else if (type == \"spaces\") {\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\"};\n        int len_limit = len -1;\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int num_spaces = rnd.next(1, 5); // Random number of spaces\n            int spaces_length = (total_length > 0) ? num_spaces : 0;\n            if (total_length + word.length() + spaces_length > len_limit) break;\n\n            if (spaces_length > 0) {\n                s += string(num_spaces, ' ');\n                total_length += spaces_length;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        s += string(rnd.next(1,5), ' '); // Add random spaces before '?'\n        s += '?';\n\n    } else if (type == \"special_case1\") {\n        // Input with multiple spaces and minimal letters\n        s = \"     A     ?\";\n    } else {\n        // Default to random\n        s = \"Is it a question?\";\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char c) {\n    c = toupper(c);\n    return c=='A'||c=='E'||c=='I'||c=='O'||c=='U'||c=='Y';\n}\n\nchar getRandomVowel() {\n    char vowels[] = {'A','E','I','O','U','Y'};\n    return vowels[rnd.next(6)];\n}\n\nchar getRandomConsonant() {\n    char consonants[] = {'B','C','D','F','G','H','J','K','L','M','N','P','Q','R','S','T','V','W','X','Z'};\n    return consonants[rnd.next(20)];\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (len == -1) len = rnd.next(2, 100);\n    if (len < 2) len = 2;\n    if (len > 100) len = 100;\n\n    string s = \"\";\n\n    if (type == \"random\") {\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\", \"question\", \"answer\", \"yes\", \"no\", \"maybe\", \"why\", \"how\", \"what\", \"who\", \"when\", \"where\", \"do\", \"does\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\", \"might\", \"have\", \"has\", \"had\", \"was\", \"were\", \"be\", \"being\", \"been\", \"and\", \"the\", \"an\", \"a\"};\n        int len_limit = len - 1; // Exclude '?'\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int add_space = (total_length > 0) ? 1 : 0;\n            if (total_length + word.length() + add_space > len_limit) break;\n\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        s += '?';\n\n    } else if (type == \"vowel_end\") {\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\", \"question\", \"answer\", \"yes\", \"no\", \"maybe\", \"why\", \"how\", \"what\", \"who\", \"when\", \"where\", \"do\", \"does\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\", \"might\", \"have\", \"has\", \"had\", \"was\", \"were\", \"be\", \"being\", \"been\", \"and\", \"the\", \"an\", \"a\"};\n        int len_limit = len -1;\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int add_space = (total_length > 0) ? 1 : 0;\n\n            if (total_length + word.length() + add_space >= len_limit -1) break;\n\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        // Generate last word ending with vowel\n        string last_word;\n        while (true) {\n            last_word = sample_words[rnd.next(sample_words.size())];\n            if (isVowel(last_word.back())) {\n                break;\n            }\n        }\n\n        int add_space = (total_length > 0) ? 1 : 0;\n        if (total_length + last_word.length() + add_space > len_limit) {\n            // Adjust last_word to fit\n            int available_length = len_limit - total_length - add_space;\n            if (available_length > 0) {\n                last_word = last_word.substr(0, available_length);\n                // Ensure last letter is vowel\n                if (!isVowel(last_word.back())) {\n                    last_word.back() = getRandomVowel();\n                }\n\n                if (add_space) {\n                    s += \" \";\n                    total_length +=1;\n                }\n                s += last_word;\n                total_length += last_word.length();\n            }\n        } else {\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n            s += last_word;\n            total_length += last_word.length();\n        }\n\n        s += '?';\n\n    } else if (type == \"consonant_end\") {\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\", \"question\", \"answer\", \"yes\", \"no\", \"maybe\", \"why\", \"how\", \"what\", \"who\", \"when\", \"where\", \"do\", \"does\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\", \"might\", \"have\", \"has\", \"had\", \"was\", \"were\", \"be\", \"being\", \"been\", \"and\", \"the\", \"an\", \"a\"};\n        int len_limit = len -1;\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int add_space = (total_length > 0) ? 1 : 0;\n\n            if (total_length + word.length() + add_space >= len_limit -1) break;\n\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        // Generate last word ending with consonant\n        string last_word;\n        while (true) {\n            last_word = sample_words[rnd.next(sample_words.size())];\n            if (!isVowel(last_word.back())) {\n                break;\n            }\n        }\n\n        int add_space = (total_length > 0) ? 1 : 0;\n        if (total_length + last_word.length() + add_space > len_limit) {\n            int available_length = len_limit - total_length - add_space;\n            if (available_length > 0) {\n                last_word = last_word.substr(0, available_length);\n                // Ensure last letter is consonant\n                if (isVowel(last_word.back())) {\n                    last_word.back() = getRandomConsonant();\n                }\n\n                if (add_space) {\n                    s += \" \";\n                    total_length +=1;\n                }\n                s += last_word;\n                total_length += last_word.length();\n            }\n        } else {\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n            s += last_word;\n            total_length += last_word.length();\n        }\n\n        s += '?';\n\n    } else if (type == \"max_length\") {\n        len = 100;\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\", \"question\", \"answer\", \"yes\", \"no\", \"maybe\", \"why\", \"how\", \"what\", \"who\", \"when\", \"where\", \"do\", \"does\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\", \"might\", \"have\", \"has\", \"had\", \"was\", \"were\", \"be\", \"being\", \"been\", \"and\", \"the\", \"an\", \"a\"};\n        int len_limit = len -1;\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int add_space = (total_length > 0) ? 1 : 0;\n            if (total_length + word.length() + add_space > len_limit) break;\n\n            if (add_space) {\n                s += \" \";\n                total_length +=1;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        s += '?';\n\n    } else if (type == \"min_length\") {\n        s = \"A?\";\n    } else if (type == \"spaces\") {\n        vector<string> sample_words = {\"is\", \"it\", \"apple\", \"banana\", \"melon\", \"simultaneously\"};\n        int len_limit = len -1;\n        int total_length = 0;\n\n        while (true) {\n            if (total_length >= len_limit - 1) break;\n\n            string word = sample_words[rnd.next(sample_words.size())];\n            int num_spaces = rnd.next(1, 5); // Random number of spaces\n            int spaces_length = (total_length > 0) ? num_spaces : 0;\n            if (total_length + word.length() + spaces_length > len_limit) break;\n\n            if (spaces_length > 0) {\n                s += string(num_spaces, ' ');\n                total_length += spaces_length;\n            }\n\n            s += word;\n            total_length += word.length();\n        }\n\n        s += string(rnd.next(1,5), ' '); // Add random spaces before '?'\n        s += '?';\n\n    } else if (type == \"special_case1\") {\n        // Input with multiple spaces and minimal letters\n        s = \"     A     ?\";\n    } else {\n        // Default to random\n        s = \"Is it a question?\";\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type vowel_end\n./gen -type consonant_end\n./gen -type max_length\n./gen -type min_length\n./gen -type spaces\n./gen -type special_case1\n\n./gen -type random -len 10\n./gen -type vowel_end -len 10\n./gen -type random -len 50\n./gen -type random -len 100\n./gen -type vowel_end -len 100\n./gen -type consonant_end -len 100\n./gen -type random -len 2\n./gen -type random -len 99\n./gen -type spaces -len 80\n./gen -type spaces -len 100\n./gen -type special_case1\n./gen -type special_case1 -len 20\n./gen -type special_case1 -len 100\n./gen -type random\n./gen -type random\n./gen -type vowel_end\n./gen -type consonant_end\n./gen -type max_length\n./gen -type min_length\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:52.856488",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "49/B",
      "title": "B. Sum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first letter contains two space-separated numbers a and b (1 ≤ a, b ≤ 1000) which represent the given summands.",
      "output_spec": "OutputPrint a single number — the length of the longest answer.",
      "sample_tests": "ExamplesInputCopy78 87OutputCopy3InputCopy1 1OutputCopy2",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first letter contains two space-separated numbers a and b (1 ≤ a, b ≤ 1000) which represent the given summands.\n\nOutputPrint a single number — the length of the longest answer.\n\nInputCopy78 87OutputCopy3InputCopy1 1OutputCopy2\n\nInputCopy78 87\n\nOutputCopy3\n\nInputCopy1 1\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good evening! Soon many of you will have your examinations, and someone even have it now. I wish you excellent marks and many easy exams! Thanks to Nickolay Kuznetsov, Gerald Agapov and Ivan Fefer for their help in preparation of the round. Good luck! Artem Rakhov and Codeforces teamUPD:StandingsProblemsWinner: ghostof2007Ratings will be updated later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "ababaaba2c->bac->cc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "wrong answer 1st numbers differ - expected: '4', found: '3'------------------------------When i run the program on my system i get Anser as 4 not 3here is my program (i have removed the header files)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 3",
          "code": "101000101001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a = 1, b = 1;\n\n    if (type == \"random\") {\n        a = rnd.next(1, n);\n        b = rnd.next(1, n);\n    } else if (type == \"max_digits\") {\n        // Generate numbers with digits as big as possible (digits '9's)\n        int num9 = 9;\n        a = b = num9;\n        while (true) {\n            int next_num9 = num9 * 10 + 9;\n            if (next_num9 > n) break;\n            num9 = next_num9;\n            a = b = num9;\n        }\n    } else if (type == \"min_digits\") {\n        // Generate numbers with digits as small as possible (digits '1's)\n        int num1 = 1;\n        a = b = num1;\n        while (true) {\n            int next_num1 = num1 * 10 + 1;\n            if (next_num1 > n) break;\n            num1 = next_num1;\n            a = b = num1;\n        }\n    } else if (type == \"max_length\") {\n        // Maximize the length of c = a + b in minimal base\n        // Use digits '1's\n        int num1 = 1;\n        a = b = num1;\n        while (true) {\n            int next_num1 = num1 * 10 + 1;\n            if (next_num1 > n) break;\n            num1 = next_num1;\n            a = b = num1;\n        }\n    } else if (type == \"min_length\") {\n        // Minimize the length, pick minimal a and b\n        a = b = 1;\n    } else if (type == \"edge_case\") {\n        a = 1;\n        b = n;\n    } else {\n        // Default to random\n        a = rnd.next(1, n);\n        b = rnd.next(1, n);\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a = 1, b = 1;\n\n    if (type == \"random\") {\n        a = rnd.next(1, n);\n        b = rnd.next(1, n);\n    } else if (type == \"max_digits\") {\n        // Generate numbers with digits as big as possible (digits '9's)\n        int num9 = 9;\n        a = b = num9;\n        while (true) {\n            int next_num9 = num9 * 10 + 9;\n            if (next_num9 > n) break;\n            num9 = next_num9;\n            a = b = num9;\n        }\n    } else if (type == \"min_digits\") {\n        // Generate numbers with digits as small as possible (digits '1's)\n        int num1 = 1;\n        a = b = num1;\n        while (true) {\n            int next_num1 = num1 * 10 + 1;\n            if (next_num1 > n) break;\n            num1 = next_num1;\n            a = b = num1;\n        }\n    } else if (type == \"max_length\") {\n        // Maximize the length of c = a + b in minimal base\n        // Use digits '1's\n        int num1 = 1;\n        a = b = num1;\n        while (true) {\n            int next_num1 = num1 * 10 + 1;\n            if (next_num1 > n) break;\n            num1 = next_num1;\n            a = b = num1;\n        }\n    } else if (type == \"min_length\") {\n        // Minimize the length, pick minimal a and b\n        a = b = 1;\n    } else if (type == \"edge_case\") {\n        a = 1;\n        b = n;\n    } else {\n        // Default to random\n        a = rnd.next(1, n);\n        b = rnd.next(1, n);\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_length\n./gen -n 2 -type min_length\n./gen -n 2 -type max_length\n./gen -n 9 -type max_digits\n\n./gen -n 10 -type max_digits\n./gen -n 11 -type min_digits\n./gen -n 11 -type max_length\n./gen -n 100 -type min_length\n\n./gen -n 100 -type max_length\n./gen -n 99 -type max_digits\n./gen -n 100 -type max_digits\n./gen -n 111 -type min_digits\n\n./gen -n 111 -type max_length\n./gen -n 999 -type max_digits\n./gen -n 1000 -type max_digits\n./gen -n 1000 -type min_digits\n\n./gen -n 999 -type max_length\n./gen -n 1000 -type max_length\n./gen -n 1000 -type min_length\n./gen -n 1000 -type edge_case\n\n./gen -n 100 -type random\n./gen -n 200 -type random\n./gen -n 300 -type random\n./gen -n 400 -type random\n\n./gen -n 500 -type random\n./gen -n 600 -type random\n./gen -n 700 -type random\n./gen -n 800 -type random\n\n./gen -n 900 -type random\n./gen -n 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:55.031002",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "49/C",
      "title": "C. Disposition",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number n (1 ≤ n ≤ 100000) which represents the number of volumes and free places.",
      "output_spec": "OutputPrint n numbers — the sought disposition with the minimum divisor number. The j-th number (1 ≤ j ≤ n) should be equal to p(j) — the number of tome that stands on the j-th place. If there are several solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy2OutputCopy2 1 InputCopy3OutputCopy1 3 2",
      "description": "C. Disposition\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains number n (1 ≤ n ≤ 100000) which represents the number of volumes and free places.\n\nOutputPrint n numbers — the sought disposition with the minimum divisor number. The j-th number (1 ≤ j ≤ n) should be equal to p(j) — the number of tome that stands on the j-th place. If there are several solutions, print any of them.\n\nInputCopy2OutputCopy2 1 InputCopy3OutputCopy1 3 2\n\nOutputCopy2 1\n\nOutputCopy1 3 2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good evening! Soon many of you will have your examinations, and someone even have it now. I wish you excellent marks and many easy exams! Thanks to Nickolay Kuznetsov, Gerald Agapov and Ivan Fefer for their help in preparation of the round. Good luck! Artem Rakhov and Codeforces teamUPD:StandingsProblemsWinner: ghostof2007Ratings will be updated later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "ababaaba2c->bac->cc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "wrong answer 1st numbers differ - expected: '4', found: '3'------------------------------When i run the program on my system i get Anser as 4 not 3here is my program (i have removed the header files)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 3",
          "code": "101000101001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Reads a permutation from the given stream,\n// checks that it's valid (contains distinct values in [1..n]),\n// and returns the vector.\nvector<int> readPermutation(InStream &stream, int n, const string &tag) {\n    vector<int> perm(n);\n    vector<bool> used(n + 1, false);\n\n    for (int i = 0; i < n; i++) {\n        int val = stream.readInt(1, n, (\"p_\" + tag + \"[\" + to_string(i+1) + \"]\").c_str());\n        if (used[val]) {\n            // If reading from 'ouf', that is a Wrong Answer,\n            // if from 'ans' (jury file), it's _fail.\n            stream.quitf(_wa, \"duplicate value %d in the permutation %s\", val, tag.c_str());\n        }\n        used[val] = true;\n        perm[i] = val;\n    }\n    return perm;\n}\n\n// Computes the number of divisors i (1 <= i <= n) such that\n// there exists j with j mod i = 0 and p(j) mod i = 0.\n// We use the gcd-based approach and a frequency array.\nlong long countDivisors(const vector<int> &p) {\n    int n = p.size();\n    // freq[x] = how many j have gcd(j, p[j-1]) = x\n    vector<int> freq(n + 1, 0);\n\n    // Build freq array\n    for (int j = 1; j <= n; j++) {\n        int g = std::gcd(j, p[j-1]);\n        freq[g]++;\n    }\n\n    // Now for each d in [1..n], check if it divides gcd(j, p_j) for some j.\n    // That is, check freq[d], freq[2d], freq[3d], ... Summation.\n    long long cnt = 0;\n    for (int d = 1; d <= n; d++) {\n        int sum = 0;\n        for (int multiple = d; multiple <= n; multiple += d) {\n            sum += freq[multiple];\n        }\n        if (sum > 0) {\n            cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from the input file\n    int n = inf.readInt(1, 100000, \"n\");\n\n    // Read jury's (official) solution\n    vector<int> juryPerm = readPermutation(ans, n, \"jury\");\n\n    // Read participant's solution\n    vector<int> partPerm = readPermutation(ouf, n, \"participant\");\n\n    // Calculate the number of divisors for both\n    long long jdiv = countDivisors(juryPerm);\n    long long pdiv = countDivisors(partPerm);\n\n    // Compare\n    if (pdiv < jdiv) {\n        quitf(_fail,\n              \"participant's solution is better than jury's (jury divisors=%lld, participant=%lld)\",\n              jdiv, pdiv);\n    } else if (pdiv == jdiv) {\n        quitf(_ok, \"correct solution, number of divisors=%lld\", pdiv);\n    } else {\n        quitf(_wa,\n              \"jury's solution is better than participant's (jury divisors=%lld, participant=%lld)\",\n              jdiv, pdiv);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 7\n./gen -n 10\n./gen -n 16\n./gen -n 100\n./gen -n 500\n./gen -n 1000\n./gen -n 5000\n./gen -n 9999\n./gen -n 10000\n./gen -n 12345\n./gen -n 20000\n./gen -n 25000\n./gen -n 30000\n./gen -n 40000\n./gen -n 50000\n./gen -n 55555\n./gen -n 60000\n./gen -n 65536\n./gen -n 70000\n./gen -n 75000\n./gen -n 80000\n./gen -n 85000\n./gen -n 90000\n./gen -n 95000\n./gen -n 99999\n./gen -n 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:57.183897",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "49/D",
      "title": "D. Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number n (1 ≤ n ≤ 1000) which represents the stripe’s length. The second line contains exactly n symbols — the line’s initial coloring. 0 corresponds to a white square, 1 corresponds to a black one.",
      "output_spec": "OutputIf Petya cannot win with such an initial coloring, print -1. Otherwise print the minimum number of moves Petya needs to win.",
      "sample_tests": "ExamplesInputCopy6111010OutputCopy1InputCopy510001OutputCopy1InputCopy71100010OutputCopy2InputCopy500100OutputCopy2",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains number n (1 ≤ n ≤ 1000) which represents the stripe’s length. The second line contains exactly n symbols — the line’s initial coloring. 0 corresponds to a white square, 1 corresponds to a black one.\n\nOutputIf Petya cannot win with such an initial coloring, print -1. Otherwise print the minimum number of moves Petya needs to win.\n\nInputCopy6111010OutputCopy1InputCopy510001OutputCopy1InputCopy71100010OutputCopy2InputCopy500100OutputCopy2\n\nInputCopy6111010\n\nOutputCopy1\n\nInputCopy510001\n\nOutputCopy1\n\nInputCopy71100010\n\nOutputCopy2\n\nInputCopy500100\n\nOutputCopy2\n\nNoteIn the first sample Petya can take squares 1 and 2. He repaints square 1 to black and square 2 to white.In the second sample Petya can take squares 2 and 3. He repaints square 2 to white and square 3 to black.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good evening! Soon many of you will have your examinations, and someone even have it now. I wish you excellent marks and many easy exams! Thanks to Nickolay Kuznetsov, Gerald Agapov and Ivan Fefer for their help in preparation of the round. Good luck! Artem Rakhov and Codeforces teamUPD:StandingsProblemsWinner: ghostof2007Ratings will be updated later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "ababaaba2c->bac->cc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "wrong answer 1st numbers differ - expected: '4', found: '3'------------------------------When i run the program on my system i get Anser as 4 not 3here is my program (i have removed the header files)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 3",
          "code": "101000101001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"line\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"line\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"line\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s(n, '0');\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n    } else if (type == \"alternating\") {\n        char start = rnd.next(0,1) + '0';\n        for (int i = 0; i < n; ++i) {\n            s[i] = ((start - '0') ^ (i & 1)) + '0';\n        }\n    } else if (type == \"all_same\") {\n        char c = rnd.next(0,1) + '0';\n        s = string(n, c);\n    } else if (type == \"impossible\") {\n        if (n < 2) {\n            // For n < 2, it's not possible to create an impossible test case\n            s[0] = '0';\n        } else {\n            // Generate a sequence where counts of connected components of '0's and '1's are both odd\n            s[0] = '0';\n            int zeros = 1, ones = 0;\n            for(int i = 1; i < n; ++i) {\n                if (s[i-1] == '0') {\n                    // Alternate between '0's and '1's\n                    s[i] = '1';\n                    ++ones;\n                } else {\n                    s[i] = '0';\n                    ++zeros;\n                }\n            }\n            // Ensure counts are odd\n            if ((zeros % 2 == 0) || (ones % 2 == 0)) {\n                // Flip last character to adjust counts\n                if (s[n-1] == '0') {\n                    s[n-1] = '1';\n                    --zeros;\n                    if (n >= 2 && s[n-2] == '1') {\n                        // Merged with previous '1's component\n                    } else {\n                        ++ones;\n                    }\n                } else {\n                    s[n-1] = '0';\n                    --ones;\n                    if (n >= 2 && s[n-2] == '0') {\n                        // Merged with previous '0's component\n                    } else {\n                        ++zeros;\n                    }\n                }\n            }\n        }\n    } else if (type == \"possible\") {\n        // Generate stripe where counts of connected components of '0's and '1's are not both odd\n        s[0] = '0';\n        int zeros = 1, ones = 0;\n        for(int i = 1; i < n; ++i) {\n            if (rnd.next(0,1)) {\n                s[i] = s[i-1];\n            } else {\n                s[i] = (s[i-1] == '0') ? '1' : '0';\n                if (s[i] == '0') ++zeros;\n                else ++ones;\n            }\n        }\n        // Adjust counts if necessary\n        if ((zeros % 2 == 1) && (ones % 2 == 1)) {\n            // Flip last character to adjust counts\n            if (s[n-1] == '0') {\n                s[n-1] = '1';\n            } else {\n                s[n-1] = '0';\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n    }\n    // Output n and s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s(n, '0');\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n    } else if (type == \"alternating\") {\n        char start = rnd.next(0,1) + '0';\n        for (int i = 0; i < n; ++i) {\n            s[i] = ((start - '0') ^ (i & 1)) + '0';\n        }\n    } else if (type == \"all_same\") {\n        char c = rnd.next(0,1) + '0';\n        s = string(n, c);\n    } else if (type == \"impossible\") {\n        if (n < 2) {\n            // For n < 2, it's not possible to create an impossible test case\n            s[0] = '0';\n        } else {\n            // Generate a sequence where counts of connected components of '0's and '1's are both odd\n            s[0] = '0';\n            int zeros = 1, ones = 0;\n            for(int i = 1; i < n; ++i) {\n                if (s[i-1] == '0') {\n                    // Alternate between '0's and '1's\n                    s[i] = '1';\n                    ++ones;\n                } else {\n                    s[i] = '0';\n                    ++zeros;\n                }\n            }\n            // Ensure counts are odd\n            if ((zeros % 2 == 0) || (ones % 2 == 0)) {\n                // Flip last character to adjust counts\n                if (s[n-1] == '0') {\n                    s[n-1] = '1';\n                    --zeros;\n                    if (n >= 2 && s[n-2] == '1') {\n                        // Merged with previous '1's component\n                    } else {\n                        ++ones;\n                    }\n                } else {\n                    s[n-1] = '0';\n                    --ones;\n                    if (n >= 2 && s[n-2] == '0') {\n                        // Merged with previous '0's component\n                    } else {\n                        ++zeros;\n                    }\n                }\n            }\n        }\n    } else if (type == \"possible\") {\n        // Generate stripe where counts of connected components of '0's and '1's are not both odd\n        s[0] = '0';\n        int zeros = 1, ones = 0;\n        for(int i = 1; i < n; ++i) {\n            if (rnd.next(0,1)) {\n                s[i] = s[i-1];\n            } else {\n                s[i] = (s[i-1] == '0') ? '1' : '0';\n                if (s[i] == '0') ++zeros;\n                else ++ones;\n            }\n        }\n        // Adjust counts if necessary\n        if ((zeros % 2 == 1) && (ones % 2 == 1)) {\n            // Flip last character to adjust counts\n            if (s[n-1] == '0') {\n                s[n-1] = '1';\n            } else {\n                s[n-1] = '0';\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n    }\n    // Output n and s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_same\n./gen -n 1 -type alternating\n\n./gen -n 2 -type impossible\n./gen -n 2 -type possible\n\n./gen -n 3 -type impossible\n./gen -n 3 -type possible\n\n./gen -n 4 -type impossible\n./gen -n 4 -type possible\n\n./gen -n 5 -type impossible\n./gen -n 5 -type possible\n\n./gen -n 7 -type impossible\n./gen -n 7 -type possible\n\n./gen -n 10 -type random\n\n./gen -n 100 -type random\n./gen -n 100 -type impossible\n./gen -n 100 -type possible\n\n./gen -n 200 -type random\n\n./gen -n 300 -type random\n\n./gen -n 400 -type random\n\n./gen -n 500 -type random\n./gen -n 500 -type possible\n\n./gen -n 600 -type random\n\n./gen -n 700 -type random\n\n./gen -n 800 -type random\n\n./gen -n 900 -type random\n\n./gen -n 999 -type alternating\n./gen -n 999 -type impossible\n./gen -n 999 -type possible\n\n./gen -n 1000 -type all_same\n./gen -n 1000 -type alternating\n./gen -n 1000 -type impossible\n./gen -n 1000 -type possible\n./gen -n 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:37:59.548758",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "49/E",
      "title": "E. Common ancestor",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty DNA sequence s1, the second line contains a non-empty DNA sequence s2. The lengths of these lines do not exceed 50, the lines contain only lowercase Latin letters. The third line contains an integer n (0 ≤ n ≤ 50) — the number of permissible substitutions. Then follow n lines each of which describes a substitution in the format ai->bici. The characters ai, bi, and ci are lowercase Latin letters. Lines s1 and s2 can coincide, the list of substitutions can contain similar substitutions.",
      "output_spec": "OutputIf s1 and s2 cannot have a common ancestor, print -1. Otherwise print the length of the shortest sequence s3, from which s1 and s2 could have evolved.",
      "sample_tests": "ExamplesInputCopyababaaba2c->bac->ccOutputCopy2InputCopyababaaba7c->bac->cce->abz->eab->bad->ddd->abOutputCopy1InputCopyababaaba1c->baOutputCopy-1",
      "description": "E. Common ancestor\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty DNA sequence s1, the second line contains a non-empty DNA sequence s2. The lengths of these lines do not exceed 50, the lines contain only lowercase Latin letters. The third line contains an integer n (0 ≤ n ≤ 50) — the number of permissible substitutions. Then follow n lines each of which describes a substitution in the format ai->bici. The characters ai, bi, and ci are lowercase Latin letters. Lines s1 and s2 can coincide, the list of substitutions can contain similar substitutions.\n\nOutputIf s1 and s2 cannot have a common ancestor, print -1. Otherwise print the length of the shortest sequence s3, from which s1 and s2 could have evolved.\n\nInputCopyababaaba2c->bac->ccOutputCopy2InputCopyababaaba7c->bac->cce->abz->eab->bad->ddd->abOutputCopy1InputCopyababaaba1c->baOutputCopy-1\n\nInputCopyababaaba2c->bac->cc\n\nOutputCopy2\n\nInputCopyababaaba7c->bac->cce->abz->eab->bad->ddd->ab\n\nOutputCopy1\n\nInputCopyababaaba1c->ba\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good evening! Soon many of you will have your examinations, and someone even have it now. I wish you excellent marks and many easy exams! Thanks to Nickolay Kuznetsov, Gerald Agapov and Ivan Fefer for their help in preparation of the round. Good luck! Artem Rakhov and Codeforces teamUPD:StandingsProblemsWinner: ghostof2007Ratings will be updated later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "ababaaba2c->bac->cc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "wrong answer 1st numbers differ - expected: '4', found: '3'------------------------------When i run the program on my system i get Anser as 4 not 3here is my program (i have removed the header files)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #46 (Div. 2, Codeforces format) - Codeforces - Code 3",
          "code": "101000101001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/969",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s1\n    std::string s1 = inf.readLine(\"[a-z]{1,50}\");\n    // Read s2\n    std::string s2 = inf.readLine(\"[a-z]{1,50}\");\n\n    // Read n\n    int n = inf.readInt(0, 50);\n    inf.readEoln();\n\n    // Read n substitution lines\n    for (int i = 0; i < n; ++i) {\n        std::string sub = inf.readLine(\"^[a-z]->[a-z]{2}$\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s1\n    std::string s1 = inf.readLine(\"[a-z]{1,50}\");\n    // Read s2\n    std::string s2 = inf.readLine(\"[a-z]{1,50}\");\n\n    // Read n\n    int n = inf.readInt(0, 50);\n    inf.readEoln();\n\n    // Read n substitution lines\n    for (int i = 0; i < n; ++i) {\n        std::string sub = inf.readLine(\"^[a-z]->[a-z]{2}$\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s1\n    std::string s1 = inf.readLine(\"[a-z]{1,50}\");\n    // Read s2\n    std::string s2 = inf.readLine(\"[a-z]{1,50}\");\n\n    // Read n\n    int n = inf.readInt(0, 50);\n    inf.readEoln();\n\n    // Read n substitution lines\n    for (int i = 0; i < n; ++i) {\n        std::string sub = inf.readLine(\"^[a-z]->[a-z]{2}$\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nchar randomLowerCaseLetter() {\n    return (char)('a' + rnd.next(26));\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int l1 = opt<int>(\"l1\", 10); // length of s1\n    int l2 = opt<int>(\"l2\", 10); // length of s2\n    int n = opt<int>(\"n\", 5);   // number of substitutions\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n\n    string s1, s2;\n    vector<tuple<char, char, char>> substitutions;\n\n    if (type == \"random\") {\n        // Generate s1 and s2 randomly\n        for (int i = 0; i < l1; ++i)\n            s1 += randomLowerCaseLetter();\n        for (int i = 0; i < l2; ++i)\n            s2 += randomLowerCaseLetter();\n\n        // Generate n substitutions\n        for (int i = 0; i < n; ++i) {\n            char ai = randomLowerCaseLetter();\n            char bi = randomLowerCaseLetter();\n            char ci = randomLowerCaseLetter();\n            substitutions.emplace_back(ai, bi, ci);\n        }\n    } else if (type == \"positive\") {\n        // Generate s3\n        int l3 = rnd.next(1, 5);\n        string s3;\n        for (int i = 0; i < l3; ++i)\n            s3 += randomLowerCaseLetter();\n\n        // Collect characters in s3\n        set<char> chars_in_s3;\n        for (char c : s3)\n            chars_in_s3.insert(c);\n\n        // Generate substitutions\n        unordered_map<char, vector<pair<char, char>>> substitutions_map;\n\n        // Ensure at least one substitution for each character in s3\n        for (char ai : chars_in_s3) {\n            char bi = randomLowerCaseLetter();\n            char ci = randomLowerCaseLetter();\n            substitutions.emplace_back(ai, bi, ci);\n            substitutions_map[ai].emplace_back(bi, ci);\n        }\n\n        // Now, generate additional substitutions to reach n\n        int n_current = substitutions.size();\n        for (int i = n_current; i < n; ++i) {\n            char ai = randomLowerCaseLetter();\n            char bi = randomLowerCaseLetter();\n            char ci = randomLowerCaseLetter();\n            substitutions.emplace_back(ai, bi, ci);\n            substitutions_map[ai].emplace_back(bi, ci);\n        }\n\n        // Expand s3 to s1\n        // s1\n        s1 = s3;\n        int iterations = 0;\n        int max_iterations = 1000;\n        while (s1.length() < l1 && iterations < max_iterations) {\n            iterations++;\n            vector<int> positions;\n            for (int i = 0; i < s1.length(); ++i) {\n                if (substitutions_map.count(s1[i]) > 0) {\n                    positions.push_back(i);\n                }\n            }\n            if (positions.empty())\n                break;// Cannot expand further\n            int idx = positions[rnd.next(positions.size())];\n            char ai = s1[idx];\n\n            // Get the list of possible substitutions for ai\n            auto &substs = substitutions_map[ai];\n\n            // Choose a substitution randomly\n            auto subst = substs[rnd.next(substs.size())];\n            char bi = subst.first;\n            char ci = subst.second;\n\n            // Replace s1[idx] with bi ci\n            s1 = s1.substr(0, idx) + bi + ci + s1.substr(idx + 1);\n        }\n        // Truncate s1 to length 50 if necessary\n        if (s1.length() > 50)\n            s1 = s1.substr(0,50);\n\n        // s2\n        s2 = s3;\n        iterations = 0;\n        while (s2.length() < l2 && iterations < max_iterations) {\n            iterations++;\n            vector<int> positions;\n            for (int i = 0; i < s2.length(); ++i) {\n                if (substitutions_map.count(s2[i]) > 0) {\n                    positions.push_back(i);\n                }\n            }\n            if (positions.empty())\n                break;// Cannot expand further\n            int idx = positions[rnd.next(positions.size())];\n            char ai = s2[idx];\n\n            // Get the list of possible substitutions for ai\n            auto &substs = substitutions_map[ai];\n\n            // Choose a substitution randomly\n            auto subst = substs[rnd.next(substs.size())];\n            char bi = subst.first;\n            char ci = subst.second;\n\n            // Replace s2[idx] with bi ci\n            s2 = s2.substr(0, idx) + bi + ci + s2.substr(idx + 1);\n        }\n        // Truncate s2 to length 50 if necessary\n        if (s2.length() > 50)\n            s2 = s2.substr(0,50);\n\n    } else {\n        // Other types can be added later\n        // For now, we can print an error\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output s1, s2\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output substitutions\n    for (auto subst : substitutions) {\n        char ai = get<0>(subst);\n        char bi = get<1>(subst);\n        char ci = get<2>(subst);\n        printf(\"%c->%c%c\\n\", ai, bi, ci);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nchar randomLowerCaseLetter() {\n    return (char)('a' + rnd.next(26));\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int l1 = opt<int>(\"l1\", 10); // length of s1\n    int l2 = opt<int>(\"l2\", 10); // length of s2\n    int n = opt<int>(\"n\", 5);   // number of substitutions\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n\n    string s1, s2;\n    vector<tuple<char, char, char>> substitutions;\n\n    if (type == \"random\") {\n        // Generate s1 and s2 randomly\n        for (int i = 0; i < l1; ++i)\n            s1 += randomLowerCaseLetter();\n        for (int i = 0; i < l2; ++i)\n            s2 += randomLowerCaseLetter();\n\n        // Generate n substitutions\n        for (int i = 0; i < n; ++i) {\n            char ai = randomLowerCaseLetter();\n            char bi = randomLowerCaseLetter();\n            char ci = randomLowerCaseLetter();\n            substitutions.emplace_back(ai, bi, ci);\n        }\n    } else if (type == \"positive\") {\n        // Generate s3\n        int l3 = rnd.next(1, 5);\n        string s3;\n        for (int i = 0; i < l3; ++i)\n            s3 += randomLowerCaseLetter();\n\n        // Collect characters in s3\n        set<char> chars_in_s3;\n        for (char c : s3)\n            chars_in_s3.insert(c);\n\n        // Generate substitutions\n        unordered_map<char, vector<pair<char, char>>> substitutions_map;\n\n        // Ensure at least one substitution for each character in s3\n        for (char ai : chars_in_s3) {\n            char bi = randomLowerCaseLetter();\n            char ci = randomLowerCaseLetter();\n            substitutions.emplace_back(ai, bi, ci);\n            substitutions_map[ai].emplace_back(bi, ci);\n        }\n\n        // Now, generate additional substitutions to reach n\n        int n_current = substitutions.size();\n        for (int i = n_current; i < n; ++i) {\n            char ai = randomLowerCaseLetter();\n            char bi = randomLowerCaseLetter();\n            char ci = randomLowerCaseLetter();\n            substitutions.emplace_back(ai, bi, ci);\n            substitutions_map[ai].emplace_back(bi, ci);\n        }\n\n        // Expand s3 to s1\n        // s1\n        s1 = s3;\n        int iterations = 0;\n        int max_iterations = 1000;\n        while (s1.length() < l1 && iterations < max_iterations) {\n            iterations++;\n            vector<int> positions;\n            for (int i = 0; i < s1.length(); ++i) {\n                if (substitutions_map.count(s1[i]) > 0) {\n                    positions.push_back(i);\n                }\n            }\n            if (positions.empty())\n                break;// Cannot expand further\n            int idx = positions[rnd.next(positions.size())];\n            char ai = s1[idx];\n\n            // Get the list of possible substitutions for ai\n            auto &substs = substitutions_map[ai];\n\n            // Choose a substitution randomly\n            auto subst = substs[rnd.next(substs.size())];\n            char bi = subst.first;\n            char ci = subst.second;\n\n            // Replace s1[idx] with bi ci\n            s1 = s1.substr(0, idx) + bi + ci + s1.substr(idx + 1);\n        }\n        // Truncate s1 to length 50 if necessary\n        if (s1.length() > 50)\n            s1 = s1.substr(0,50);\n\n        // s2\n        s2 = s3;\n        iterations = 0;\n        while (s2.length() < l2 && iterations < max_iterations) {\n            iterations++;\n            vector<int> positions;\n            for (int i = 0; i < s2.length(); ++i) {\n                if (substitutions_map.count(s2[i]) > 0) {\n                    positions.push_back(i);\n                }\n            }\n            if (positions.empty())\n                break;// Cannot expand further\n            int idx = positions[rnd.next(positions.size())];\n            char ai = s2[idx];\n\n            // Get the list of possible substitutions for ai\n            auto &substs = substitutions_map[ai];\n\n            // Choose a substitution randomly\n            auto subst = substs[rnd.next(substs.size())];\n            char bi = subst.first;\n            char ci = subst.second;\n\n            // Replace s2[idx] with bi ci\n            s2 = s2.substr(0, idx) + bi + ci + s2.substr(idx + 1);\n        }\n        // Truncate s2 to length 50 if necessary\n        if (s2.length() > 50)\n            s2 = s2.substr(0,50);\n\n    } else {\n        // Other types can be added later\n        // For now, we can print an error\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output s1, s2\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output substitutions\n    for (auto subst : substitutions) {\n        char ai = get<0>(subst);\n        char bi = get<1>(subst);\n        char ci = get<2>(subst);\n        printf(\"%c->%c%c\\n\", ai, bi, ci);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -l1 5 -l2 5 -n 2 -type random\n./gen -l1 10 -l2 10 -n 5 -type random\n./gen -l1 20 -l2 20 -n 10 -type random\n./gen -l1 50 -l2 50 -n 50 -type random\n\n./gen -l1 5 -l2 5 -n 3 -type positive\n./gen -l1 10 -l2 10 -n 5 -type positive\n./gen -l1 20 -l2 15 -n 10 -type positive\n./gen -l1 50 -l2 50 -n 25 -type positive\n./gen -l1 50 -l2 50 -n 50 -type positive\n\n./gen -l1 1 -l2 1 -n 1 -type positive\n./gen -l1 1 -l2 1 -n 0 -type random\n\n./gen -l1 10 -l2 10 -n 0 -type random\n./gen -l1 10 -l2 10 -n 0 -type positive\n\n./gen -l1 50 -l2 1 -n 50 -type positive\n./gen -l1 1 -l2 50 -n 50 -type positive\n./gen -l1 25 -l2 25 -n 50 -type positive\n\n./gen -l1 5 -l2 5 -n 0 -type random\n./gen -l1 0 -l2 0 -n 0 -type random\n\n./gen -l1 50 -l2 50 -n 0 -type random\n./gen -l1 50 -l2 50 -n 50 -type random\n\n./gen -l1 10 -l2 20 -n 20 -type positive\n./gen -l1 20 -l2 10 -n 20 -type positive\n\n./gen -l1 2 -l2 2 -n 2 -type random\n./gen -l1 3 -l2 3 -n 5 -type positive\n\n./gen -l1 30 -l2 20 -n 25 -type positive\n./gen -l1 20 -l2 30 -n 25 -type positive\n\n./gen -l1 15 -l2 15 -n 1 -type random\n./gen -l1 15 -l2 15 -n 1 -type positive\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:01.529417",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "490/A",
      "title": "A. Team Olympiad",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 5000) — the number of children in the school. The second line contains n integers t1, t2, ..., tn (1 ≤ ti ≤ 3), where ti describes the skill of the i-th child.",
      "output_spec": "OutputIn the first line output integer w — the largest possible number of teams. Then print w lines, containing three numbers in each line. Each triple represents the indexes of the children forming the team. You can print both the teams, and the numbers in the triplets in any order. The children are numbered from 1 to n in the order of their appearance in the input. Each child must participate in no more than one team. If there are several solutions, print any of them.If no teams can be compiled, print the only line with value w equal to 0.",
      "sample_tests": "ExamplesInputCopy71 3 1 3 2 1 2OutputCopy23 5 26 7 4InputCopy42 1 1 2OutputCopy0",
      "description": "A. Team Olympiad\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 5000) — the number of children in the school. The second line contains n integers t1, t2, ..., tn (1 ≤ ti ≤ 3), where ti describes the skill of the i-th child.\n\nOutputIn the first line output integer w — the largest possible number of teams. Then print w lines, containing three numbers in each line. Each triple represents the indexes of the children forming the team. You can print both the teams, and the numbers in the triplets in any order. The children are numbered from 1 to n in the order of their appearance in the input. Each child must participate in no more than one team. If there are several solutions, print any of them.If no teams can be compiled, print the only line with value w equal to 0.\n\nInputCopy71 3 1 3 2 1 2OutputCopy23 5 26 7 4InputCopy42 1 1 2OutputCopy0\n\nInputCopy71 3 1 3 2 1 2\n\nOutputCopy23 5 26 7 4\n\nInputCopy42 1 1 2\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "Hi everybody!Today at 12:00 Moscow Time there will be Codeforces Round #279, dedicated for second division contestants. Round is based on the problems of the Saratov second round of All-Russian School Olympiad in Informatics 2014-2015 that is held at the same time in Saratov.This round was brought to you by ikar, HolkinPV, IlyaLos, fcspartakm that are all members and ex-members of Saratov SU 2 team.There will be 6 tasks for 2 hours 30 minutes. Scoring will be announced just before the round starts.Round will be rated for second divison participants. First division contestants may participate out of competition.UPD: Scoring: 500-1000-1500-2000-2000-2500.Good luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces",
          "content": "490A - Team OlympiadThe teams could be formed using greedy algorithm. We can choose any three children with different skills who are not participants of any team yet and form a new team using them. After some time we could not form any team, so the answer to the problem is minimum of the number of ones, twos and threes in given array. We can get O(N) solution if we add children with different skills into three different arrays. Also the problem could be solved in O(N2) — every iteration find new three children for new team.490B - QueueThis problem can be solved constructively. Find the first student — it is a student with such number which can be found among ai and could not be found among bi (because he doesn’t stand behind for anybody). Find the second student — it is a student standing behind the first, number ai of the first student equals 0, so his number is a number in pair [0, bi].After that we will find numbers of all other students beginning from the third. It can be easily done using penultimate found number. The number of the next student is a number bi in such pair where ai equals to number of penultimate found student number (that is a number in pair [ans[i - 2], bi]). Look at the sample to understand the solution better.490C - Hacking CypherAt first, let’s check all prefixes of specified number — do they have remainder 0 when divided by the a? It can be done with asymptotic behavior O(N), where N -length of specified number C. If we have remainder of division by a of prefix, which ends in position pos, we can count remainder in position pos + 1: rema[pos + 1] = (rema[pos] * 10 + C[pos + 1]) % a.Then we need to check suffixes.If we have remainder of division by b of suffix, which begin in position pos, we can count remainder of position pos - 1: remb[pos - 1] = (C[pos - 1] * P + remb[pos]) % b, where P — it is 10^(L - 1) module b, L — length of suffix (P we can count parallel).Now let’s check all positions pos — can we cut specified number C in this position. We can do it if next four conditions performed: prefix of number C, which ends in pos is divisible by a; suffix of number C, which begin in pos + 1 is divisible by b; length of prefix and suffix more than 0; first digit of suffix is different from 0. If all four conditions performed we found answer. If we did not find any such positions, than print NO.490D - ChocolateWe can change the numbers by dividing their by two or by dividing their by three and multiply two. Firstly remove all 2 and 3 from factorization of chocolate and determine equals their square or not. If their squares are not equals answer doesn’t exists. Otherwise calculate of difference between number of three in factorization, we should remove this amount of threes from the some chocolate, it depends from the sign, and recalculate difference between number of two in factorization and do the same.490E - Restoring Increasing SequenceLet’s iterate on specified numbers and try to make from current number minimal possible, which value more than value of previous number. Let’s current number is cur, previous number is prev. If length of number cur less than length of number prev — let’s print NO, this problem has not solution.If length of number cur more than length of number prev — replace all signs ? in number cur to digit 0, except case, when sign ? in first position — replace him on digit 1, because numbers in answer must be without leading zeroes.Another case when lengths of numbers a and b are equal. Let’s iterate on positions pos, in which prefix number cur more than prefix of number prev. Now we need to try for this position make minimal possible number, which more than prev. In all positions posi, which less than pos, replace all ? on prev[posi]. In all positions posi, which more than pos, replace all ? on digit 0. If cur[pos] =  = ? than make cur[pos] = max(prev[pos] + 1, 9).If received number less or equal to prev — this position is bad. From all good positions choose minimal number, received with operations above and assign him number cur and will continue iteration. If count of such positions is 0 we need to print NO.490F - Treeland TourThe problem is generalization of finding maximal increasing subsequence in array, so it probably can be solved using dynamic programming. We will calс dynamic d[(u, v)], the state is directed edge (u, v) in tree. Value d[(u, v)] means the maximum number of vertices where the band will have concerts on some simple path ended in vertex v going through vertex u. Also the concert in vertex v must be certainly.To calc d(u, v) we should consider all such edges (x, y) that there is simple path started in x, going through y, u and ended in v. These edges can be found using dfs from vertex u which is not going through vertex v. All edges used by dfs should be reoriented. So if r[y] < r[v] then d[(u, v)] = max(d[(u, v)], d[(x, y)] + 1). The solution needs O(N2) time and O(N2) memory. The memory could be O(N) if you get indexes of directed edges without two-dimensional array.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 490\\s*A"
          },
          "content_length": 5030
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "int[] map = new int[1000000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "int[] map = new int[1000001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 7",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 8",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 9",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 10",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 11",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 12",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 13",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 14",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 15",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 16",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 17",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 18",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 19",
          "code": "x[i] = s[0..i] % a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 20",
          "code": "y[i] = s[i..n-1] % b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 21",
          "code": "x[i] == 0 and y[i+1] == 0 and s[i + 1] != '0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 22",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 23",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "O(N^2 * logN)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1 1 2 2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "D-Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "a1*b1!=a2*b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 3, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 3, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 3, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> skills;\nint cnt[4]; // counts of skills 1 to 3\n\nint readAns(InStream& stream) {\n    int w = stream.readInt(0, n / 3, \"number of teams\");\n    if (w > min(cnt[1], min(cnt[2], cnt[3]))) {\n        stream.quitf(_fail, \"number of teams exceeds the possible maximum\");\n    }\n\n    vector<bool> used(n, false);\n    for (int i = 0; i < w; i++) {\n        int a = stream.readInt(1, n, format(\"team[%d][1]\", i + 1).c_str());\n        int b = stream.readInt(1, n, format(\"team[%d][2]\", i + 1).c_str());\n        int c = stream.readInt(1, n, format(\"team[%d][3]\", i + 1).c_str());\n\n        if (a == b || b == c || a == c) {\n            stream.quitf(_wa, \"team %d contains duplicate indices\", i + 1);\n        }\n\n        if (used[a - 1]) {\n            stream.quitf(_wa, \"child %d is used more than once\", a);\n        }\n        if (used[b - 1]) {\n            stream.quitf(_wa, \"child %d is used more than once\", b);\n        }\n        if (used[c - 1]) {\n            stream.quitf(_wa, \"child %d is used more than once\", c);\n        }\n        used[a - 1] = used[b - 1] = used[c - 1] = true;\n\n        int skill_a = skills[a - 1];\n        int skill_b = skills[b - 1];\n        int skill_c = skills[c - 1];\n\n        set<int> skill_set;\n        skill_set.insert(skill_a);\n        skill_set.insert(skill_b);\n        skill_set.insert(skill_c);\n\n        if (skill_set.size() != 3 || skill_set.find(1) == skill_set.end() || \n            skill_set.find(2) == skill_set.end() || skill_set.find(3) == skill_set.end()) {\n            stream.quitf(_wa, \"team %d does not contain one member of each skill\", i + 1);\n        }\n    }\n    return w;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 5000, \"n\");\n    skills.resize(n);\n    cnt[1] = cnt[2] = cnt[3] = 0;\n\n    for (int i = 0; i < n; i++) {\n        skills[i] = inf.readInt(1, 3, format(\"skills[%d]\", i + 1).c_str());\n        cnt[skills[i]]++;\n    }\n\n    int w_jury = readAns(ans);\n    int w_part = readAns(ouf);\n\n    if (w_jury > w_part) {\n        quitf(_wa, \"jury has the better answer: expected w = %d, found w = %d\", w_jury, w_part);\n    } else if (w_jury == w_part) {\n        quitf(_ok, \"correct solution: w = %d\", w_part);\n    } else {\n        quitf(_fail, \"participant has a better answer than jury: jury's w = %d, participant's w = %d\", w_jury, w_part);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string distribution = opt<string>(\"distribution\", \"random\");\n\n    if (n < 1 || n > 5000) {\n        fprintf(stderr, \"n must be between 1 and 5000\\n\");\n        return 1;\n    }\n\n    vector<int> t(n);\n\n    if (distribution == \"random\") {\n        // Randomly assign types between 1 and 3\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 3);\n        }\n    } else if (distribution == \"missing_type\") {\n        // One type is missing\n        int missing_type = rnd.next(1, 3);\n        vector<int> available_types = {1, 2, 3};\n        available_types.erase(find(available_types.begin(), available_types.end(), missing_type));\n        for (int i = 0; i < n; ++i) {\n            t[i] = available_types[rnd.next(0, 1)];\n        }\n    } else if (distribution == \"only_one_each\") {\n        // Only one of each type, rest are of a random type\n        if (n < 3) {\n            fprintf(stderr, \"n must be at least 3 for 'only_one_each' distribution\\n\");\n            return 1;\n        }\n        t[0] = 1;\n        t[1] = 2;\n        t[2] = 3;\n        int dominant_type = rnd.next(1, 3);\n        for (int i = 3; i < n; ++i) {\n            t[i] = dominant_type;\n        }\n        shuffle(t.begin(), t.end());\n    } else if (distribution == \"one_dominant\") {\n        // One type is dominant\n        int dominant_type = opt<int>(\"dominant_type\", 1); // Default dominant type is 1\n        if (dominant_type < 1 || dominant_type > 3) {\n            fprintf(stderr, \"dominant_type must be between 1 and 3\\n\");\n            return 1;\n        }\n        int dominant_count = n * 90 / 100; // 90% of n\n        int remaining = n - dominant_count;\n        vector<int> other_types = {1, 2, 3};\n        other_types.erase(find(other_types.begin(), other_types.end(), dominant_type));\n        for (int i = 0; i < dominant_count; ++i) {\n            t[i] = dominant_type;\n        }\n        for (int i = dominant_count; i < n; ++i) {\n            t[i] = other_types[rnd.next(0, 1)];\n        }\n        shuffle(t.begin(), t.end());\n    } else if (distribution == \"max_teams\") {\n        // Equal number of each type as much as possible\n        int k = n / 3;\n        int remainder = n - 3 * k;\n        vector<int> temp;\n        for (int i = 0; i < k; ++i) temp.push_back(1);\n        for (int i = 0; i < k; ++i) temp.push_back(2);\n        for (int i = 0; i < k; ++i) temp.push_back(3);\n        for (int i = 0; i < remainder; ++i) {\n            temp.push_back(rnd.next(1, 3));\n        }\n        shuffle(temp.begin(), temp.end());\n        t = temp;\n    } else if (distribution == \"min_teams\") {\n        // All children are of the same type\n        int same_type = rnd.next(1, 3);\n        for (int i = 0; i < n; ++i) {\n            t[i] = same_type;\n        }\n    } else {\n        fprintf(stderr, \"Unknown distribution type '%s'\\n\", distribution.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output t_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", t[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string distribution = opt<string>(\"distribution\", \"random\");\n\n    if (n < 1 || n > 5000) {\n        fprintf(stderr, \"n must be between 1 and 5000\\n\");\n        return 1;\n    }\n\n    vector<int> t(n);\n\n    if (distribution == \"random\") {\n        // Randomly assign types between 1 and 3\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 3);\n        }\n    } else if (distribution == \"missing_type\") {\n        // One type is missing\n        int missing_type = rnd.next(1, 3);\n        vector<int> available_types = {1, 2, 3};\n        available_types.erase(find(available_types.begin(), available_types.end(), missing_type));\n        for (int i = 0; i < n; ++i) {\n            t[i] = available_types[rnd.next(0, 1)];\n        }\n    } else if (distribution == \"only_one_each\") {\n        // Only one of each type, rest are of a random type\n        if (n < 3) {\n            fprintf(stderr, \"n must be at least 3 for 'only_one_each' distribution\\n\");\n            return 1;\n        }\n        t[0] = 1;\n        t[1] = 2;\n        t[2] = 3;\n        int dominant_type = rnd.next(1, 3);\n        for (int i = 3; i < n; ++i) {\n            t[i] = dominant_type;\n        }\n        shuffle(t.begin(), t.end());\n    } else if (distribution == \"one_dominant\") {\n        // One type is dominant\n        int dominant_type = opt<int>(\"dominant_type\", 1); // Default dominant type is 1\n        if (dominant_type < 1 || dominant_type > 3) {\n            fprintf(stderr, \"dominant_type must be between 1 and 3\\n\");\n            return 1;\n        }\n        int dominant_count = n * 90 / 100; // 90% of n\n        int remaining = n - dominant_count;\n        vector<int> other_types = {1, 2, 3};\n        other_types.erase(find(other_types.begin(), other_types.end(), dominant_type));\n        for (int i = 0; i < dominant_count; ++i) {\n            t[i] = dominant_type;\n        }\n        for (int i = dominant_count; i < n; ++i) {\n            t[i] = other_types[rnd.next(0, 1)];\n        }\n        shuffle(t.begin(), t.end());\n    } else if (distribution == \"max_teams\") {\n        // Equal number of each type as much as possible\n        int k = n / 3;\n        int remainder = n - 3 * k;\n        vector<int> temp;\n        for (int i = 0; i < k; ++i) temp.push_back(1);\n        for (int i = 0; i < k; ++i) temp.push_back(2);\n        for (int i = 0; i < k; ++i) temp.push_back(3);\n        for (int i = 0; i < remainder; ++i) {\n            temp.push_back(rnd.next(1, 3));\n        }\n        shuffle(temp.begin(), temp.end());\n        t = temp;\n    } else if (distribution == \"min_teams\") {\n        // All children are of the same type\n        int same_type = rnd.next(1, 3);\n        for (int i = 0; i < n; ++i) {\n            t[i] = same_type;\n        }\n    } else {\n        fprintf(stderr, \"Unknown distribution type '%s'\\n\", distribution.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output t_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", t[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n with different distributions\n./gen -n 1 -distribution min_teams\n./gen -n 2 -distribution missing_type\n./gen -n 3 -distribution max_teams\n./gen -n 4 -distribution random\n./gen -n 5 -distribution random\n\n# Edge cases with n mod 3\n./gen -n 3000 -distribution max_teams       # n mod 3 == 0\n./gen -n 3001 -distribution max_teams       # n mod 3 == 1\n./gen -n 3002 -distribution max_teams       # n mod 3 == 2\n\n# Max n with different distributions\n./gen -n 5000 -distribution random\n./gen -n 5000 -distribution missing_type\n./gen -n 5000 -distribution min_teams\n\n# One dominant type\n./gen -n 5000 -distribution one_dominant -dominant_type 1\n./gen -n 5000 -distribution one_dominant -dominant_type 2\n./gen -n 5000 -distribution one_dominant -dominant_type 3\n\n# Only one of each type, rest are random of one type\n./gen -n 5000 -distribution only_one_each\n\n# Edge case where no teams can be formed\n./gen -n 5000 -distribution min_teams\n\n# Random distributions with various n\n./gen -n 1000 -distribution random\n./gen -n 2000 -distribution random\n./gen -n 3000 -distribution random\n./gen -n 4000 -distribution random\n./gen -n 5000 -distribution random\n\n# Missing one type\n./gen -n 4999 -distribution missing_type\n./gen -n 5000 -distribution missing_type\n\n# All combinations of distribution at max n\n./gen -n 5000 -distribution random\n./gen -n 5000 -distribution missing_type\n./gen -n 5000 -distribution only_one_each\n./gen -n 5000 -distribution one_dominant -dominant_type 1\n./gen -n 5000 -distribution one_dominant -dominant_type 2\n./gen -n 5000 -distribution one_dominant -dominant_type 3\n./gen -n 5000 -distribution max_teams\n./gen -n 5000 -distribution min_teams\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:03.320026",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "490/B",
      "title": "B. Очередь",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (2 ≤ n ≤ 2·105) — количество студентов в очереди. Далее следует n строк, где i-я строка содержит пару целых чисел ai, bi (0 ≤ ai, bi ≤ 106), где ai — номер студенческого билета того, кто стоит перед очередным студентом, а bi — номер студенческого билета того, кто стоит после очередного студента. Строки заданы в произвольном порядке. В качестве номера студенческого билета используется значение 0, если такого соседа нет.У всех студентов номера студенческих билетов различны. Гарантируется, что записи соответствуют очереди, в которой стоят все студенты в каком-то порядке.",
      "output_spec": "Выходные данныеВыведите последовательность n целых чисел x1, x2, ..., xn — последовательность номеров студенческих билетов всех студентов в порядке очереди от первого к последнему.",
      "sample_tests": "ПримерыВходные данныеСкопировать492 310 731 07 141Выходные данныеСкопировать92 7 31 141",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (2 ≤ n ≤ 2·105) — количество студентов в очереди. Далее следует n строк, где i-я строка содержит пару целых чисел ai, bi (0 ≤ ai, bi ≤ 106), где ai — номер студенческого билета того, кто стоит перед очередным студентом, а bi — номер студенческого билета того, кто стоит после очередного студента. Строки заданы в произвольном порядке. В качестве номера студенческого билета используется значение 0, если такого соседа нет.У всех студентов номера студенческих билетов различны. Гарантируется, что записи соответствуют очереди, в которой стоят все студенты в каком-то порядке.\n\nВходные данные\n\nВыходные данныеВыведите последовательность n целых чисел x1, x2, ..., xn — последовательность номеров студенческих билетов всех студентов в порядке очереди от первого к последнему.\n\nВыходные данные\n\nВходные данныеСкопировать492 310 731 07 141Выходные данныеСкопировать92 7 31 141\n\nВходные данныеСкопировать492 310 731 07 141\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать92 7 31 141\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеКартинка иллюстрирует очередь для первого примера.",
      "solutions": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "Всем доброго времени суток!Сегодня в 12:00 по Москве состоится Codeforces Round #279, предназначенный для участников второго дивизиона. Раунд проходит на задачах муниципиального (II) этапа всероссийской олимпиады школьников по информатике 2014-2015 учебного года, который проходит в это же время в Саратове.Раунд подготовила для вас дружная команда Saratov SU 2, членами которой в разное время являлись и являются ikar, HolkinPV, IlyaLos, fcspartakm.Вам будет предложено 6 задач на 2 часа 30 минут. Разбаловка будет оглашена непосредственно перед раундом.Раунд является рейтинговым для участников из второго дивизиона. Участники из первого дивизиона, как и всегда, могут участвовать вне конкурса.UPD: Разбалловка — 500-1000-1500-2000-2000-2500.Удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 750
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "490A - Командная олимпиадаБудем формировать команды жадно. То есть, если у нас есть по одному школьнику каждого из трёх типов, которые ещё не относятся ни к какой команде, то из них можно сформировать новую команду. И так делее, пока достигнется ситуация, когда мы не сможем сформировать команду. Таким образом, общее число команд — это минимум из количеcтва школьников каждого из трёх типов. Решение получается за O(N), если сложить индексы школьников каждого типа в три отдельных массива. Можно решать и за O(N2), если каждый раз пробегаться по всему массиву в поисках школьника конкретного типа для очередной команды.490B - ОчередьЭту задачу будем решать конструктивно. Определим, кто находится на первом месте — это студент с таким номером, который встречается среди чисел ai, но не встречается среди чисел bi (потому, что ни для кого из остальных он не находится позади). Определим, кто находится на втором месте — это студент, который стоит позади первого, а поскольку у первого студента число ai равно 0, то соответствующее ему число bi и будет его номером (то есть число из пары [0, bi]).Теперь будем определять остальных, начиная с третьего. Это делается очень просто по предпоследнему уже определенному номеру студента. Номер очередного студента, это число bi в некоторой паре, где число ai, это номер предпоследнего уже найденного номера студента (то есть число из пары [ans[i - 2], bi]. Решение достаточно просто осознать, разбирая пример из условия.490C - Взлом шифраБудем решать эту задачу следующим образом. Сначала проверим все префиксы заданного числа — делятся ли они на число a. Это можно сделать за O(N), где N — это длина заданного числа C. Зная остаток от деления префикса, заканчивающегося в позиции pos, можно пересчитать остаток для позиции pos + 1 следующим образом: rema[pos + 1] = (rema[pos] * 10 + C[pos + 1]) % a.Затем нужно проверить все суффиксы числа C — делятся ли они на число b. Зная остаток от деления суффикса, начинающегося в позиции pos, можно пересчитать остаток для позиции pos - 1 следующим образом: remb[pos - 1] = (C[pos - 1] * P + remb[pos]) % b, где P — это 10^(L - 1) по модулю b, L — это длина суффикса (величину P можно вычислять параллельно).Теперь нужно перебрать все позиции pos и проверить, можно ли сделать разрез числа C после этой позиции. Для этого необходимо выполнение четырех условий: префикс числа C, заканчивающийся в позиции pos, делится на число a; суффикс числа C, начинающийся в позиции pos + 1, делится на число b; длины префикса и суффикса ненулевые; суффикс не может начинаться с цифры 0. Если все эти условия выполняются, то после позиции pos можно сделать разрез. Если же все позиции не подходят, то решения не существует и следует вывести NO.490D - ШоколадкиЗаметим, что мы можем преобразовывать число следующим образом, либо делить на два либо делить на три и домножать на два. Изначально уберём из чисел все степени двоек и троек. После этого проверим, возможно ли удалив все эти степени добиться равенства площадей, если нет, то ответа не существует. Посмотрим на разность количества троек в факторизации шоколадок. Понятно, что именно на такое число нужно сократить одну из шоколадок, в зависимости от знака. Выполним данную операцию, пересчитывая количество двоек, и после сделаем то же самое для них.490E - Восстановление возрастающей последовательностиБудем решать данную задачу жадным образом. Будем перебирать заданные числа сначала и пытаться сделать из текущего числа минимальное, но большее предыдущего. Обозначим текущее число — cur, а предыдущее число — prev. Если длина числа cur меньше длины числа prev — следует вывести NO, задача не имеет решения.Если длина числа cur больше длины числа prev — заменим все знаки ? в числе cur на цифру 0, за исключением случая, когда знак ? стоит в первой позиции — заменим его на цифру 1, так как числа в ответе не могут иметь лидирующих нулей.Остался случай, когда длины чисел cur и prev равны. По условию задачи, каждое число в ответе должно быть строго больше предыдущего. Переберем позицию pos, в которой префикс числа cur больше чем префикс числа prev. Теперь попробуем для этой позиции сделать минимально возможное число, большее prev. Во всех позициях posi в которых стоит знак ? и меньших pos, поставим цифру, которая стоит в соответствующей позиции числа cur. А во всех позициях posi в которых стоит знак ? и больших pos, поставим цифру 0. Если в числе cur в позиции pos стоит знак ?, то поставим в эту позиции цифру на 1 большую, чем prev[pos]. Если в prev[pos] стоит цифра 9, то данная позиция pos не подходит для рассмотрения. Если полученное число меньше либо равно предыдущему, то данная позиция pos не подходит. Из всех подходящих позиций pos выберем минимальное число, полученное в результате описанных выше действий, присвоим ему число cur и продолжим восстановление ответа. Если подходящих позиций pos на каком-то шаге не нашлось — следует вывести NO.490F - Турне по ДревляндииЗадача является обобщением нахождения наибольшей возрастающей подпоследовательности в массиве, поэтому наверняка решается диначеским программированием. Будем делать динамику d[(u, v)], в которой состоянием является ориентированное ребро в графе (u, v). В динамике будем хранить максимальное число вершин, где группа могла дать концерты на каком-то простом пути, заканчивающемся в вершине v и проходящем через вершину u. Причём в вершине v точно будет концерт. Чтобы посчитать значение для ребра (u, v) нужно посчитать значение для всех рёбер (x, y) таких, что существует простой путь, начинающийся в вершине x, проходящий через вершины y и u и заканчивающийся в вершине v.Чтобы найти все рёбра (x, y), удовлетворяющие этому условию, нужно просто запустить обход в глубину из вершины u, которому будет запрещено заходить за вершину v. Тогда все ребра, которые он обойдёт, нужно просто взять с обратной ориентацией. Таким образом если r[y] < r[v], то d[(u, v)] = max(d[(u, v)], d[(x, y)] + 1). В итоге получется решение за O(N2) и (O(N2)) памяти. Память можно сократить до линейной если научиться получать индексы ориентированных рёбер без обращения к двумерному массиву.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 490\\s*B"
          },
          "content_length": 6089
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "int[] map = new int[1000000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "int[] map = new int[1000001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 7",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 8",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 9",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 10",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 11",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 12",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 13",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 14",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 15",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 16",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 17",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 18",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 19",
          "code": "x[i] = s[0..i] % a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 20",
          "code": "y[i] = s[i..n-1] % b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 21",
          "code": "x[i] == 0 and y[i+1] == 0 and s[i + 1] != '0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 22",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 23",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "O(N^2 * logN)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1 1 2 2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "D-Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "a1*b1!=a2*b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> student_ids;\n    map<int, pair<int, int>> students; // Map student ID to <prev, next>\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 1000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 1000000, \"bi\");\n        inf.readEoln();\n\n        // Collect student IDs\n        // Each line corresponds to a student; collect their own ID\n        // Their own ID must be unique among all students and not 0\n        // Since the problem statement doesn't specify student's own ID explicitly,\n        // we need to infer it. As per the sample input, perhaps the student's own ID is\n        // the one that does not appear in ai and bi\n        // However, that is not reliable without proper problem statement.\n\n        // Since we cannot determine student's own ID from the given data due to incomplete\n        // problem statement, we can only check ai and bi are within the ranges.\n\n        // Collect IDs\n        if (ai != 0)\n            student_ids.insert(ai);\n        if (bi != 0)\n            student_ids.insert(bi);\n    }\n\n    // The number of unique IDs (excluding 0) should be equal to n\n    ensuref(int(student_ids.size()) == n, \"Number of unique student IDs must be equal to n\");\n\n    // IDs should be between 1 and 1,000,000\n    for (int id : student_ids) {\n        ensuref(1 <= id && id <= 1000000, \"Student ID %d is out of range [1, 1000000]\", id);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> student_ids;\n    map<int, pair<int, int>> students; // Map student ID to <prev, next>\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 1000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 1000000, \"bi\");\n        inf.readEoln();\n\n        // Collect student IDs\n        // Each line corresponds to a student; collect their own ID\n        // Their own ID must be unique among all students and not 0\n        // Since the problem statement doesn't specify student's own ID explicitly,\n        // we need to infer it. As per the sample input, perhaps the student's own ID is\n        // the one that does not appear in ai and bi\n        // However, that is not reliable without proper problem statement.\n\n        // Since we cannot determine student's own ID from the given data due to incomplete\n        // problem statement, we can only check ai and bi are within the ranges.\n\n        // Collect IDs\n        if (ai != 0)\n            student_ids.insert(ai);\n        if (bi != 0)\n            student_ids.insert(bi);\n    }\n\n    // The number of unique IDs (excluding 0) should be equal to n\n    ensuref(int(student_ids.size()) == n, \"Number of unique student IDs must be equal to n\");\n\n    // IDs should be between 1 and 1,000,000\n    for (int id : student_ids) {\n        ensuref(1 <= id && id <= 1000000, \"Student ID %d is out of range [1, 1000000]\", id);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> student_ids;\n    map<int, pair<int, int>> students; // Map student ID to <prev, next>\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 1000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 1000000, \"bi\");\n        inf.readEoln();\n\n        // Collect student IDs\n        // Each line corresponds to a student; collect their own ID\n        // Their own ID must be unique among all students and not 0\n        // Since the problem statement doesn't specify student's own ID explicitly,\n        // we need to infer it. As per the sample input, perhaps the student's own ID is\n        // the one that does not appear in ai and bi\n        // However, that is not reliable without proper problem statement.\n\n        // Since we cannot determine student's own ID from the given data due to incomplete\n        // problem statement, we can only check ai and bi are within the ranges.\n\n        // Collect IDs\n        if (ai != 0)\n            student_ids.insert(ai);\n        if (bi != 0)\n            student_ids.insert(bi);\n    }\n\n    // The number of unique IDs (excluding 0) should be equal to n\n    ensuref(int(student_ids.size()) == n, \"Number of unique student IDs must be equal to n\");\n\n    // IDs should be between 1 and 1,000,000\n    for (int id : student_ids) {\n        ensuref(1 <= id && id <= 1000000, \"Student ID %d is out of range [1, 1000000]\", id);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ids(n);\n\n    if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            ids[i] = n - i;\n    } else if (type == \"random\") {\n        set<int> used_ids;\n        for (int i = 0; i < n; ++i) {\n            int id;\n            do {\n                id = rnd.next(1, 1000000);\n            } while (used_ids.count(id));\n            used_ids.insert(id);\n            ids[i] = id;\n        }\n    } else if (type == \"max\") {\n        int start = 1000000 - n + 1;\n        for (int i = 0; i < n; ++i)\n            ids[i] = start + i;\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n    } else if (type == \"random_large\") {\n        set<int> used_ids;\n        for (int i = 0; i < n; ++i) {\n            int id;\n            do {\n                id = rnd.next(1000000 - n + 1, 1000000);\n            } while (used_ids.count(id));\n            used_ids.insert(id);\n            ids[i] = id;\n        }\n    } else {\n        // Default to random\n        set<int> used_ids;\n        for (int i = 0; i < n; ++i) {\n            int id;\n            do {\n                id = rnd.next(1, 1000000);\n            } while (used_ids.count(id));\n            used_ids.insert(id);\n            ids[i] = id;\n        }\n    }\n\n    // Now, generate ai and bi for each student\n    vector<int> ai(n), bi(n);\n\n    for (int i = 0; i < n; ++i) {\n        if (i == 0) {\n            ai[i] = 0;\n            bi[i] = ids[i + 1];\n        } else if (i == n -1) {\n            ai[i] = ids[i - 1];\n            bi[i] = 0;\n        } else {\n            ai[i] = ids[i - 1];\n            bi[i] = ids[i + 1];\n        }\n    }\n\n    // Create the neighbor list\n    vector<pair<int, int>> neighbor_list(n);\n    for (int i = 0; i < n; ++i) {\n        neighbor_list[i] = make_pair(ai[i], bi[i]);\n    }\n\n    // Shuffle the neighbor list\n    shuffle(neighbor_list.begin(), neighbor_list.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the neighbor list\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", neighbor_list[i].first, neighbor_list[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ids(n);\n\n    if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            ids[i] = n - i;\n    } else if (type == \"random\") {\n        set<int> used_ids;\n        for (int i = 0; i < n; ++i) {\n            int id;\n            do {\n                id = rnd.next(1, 1000000);\n            } while (used_ids.count(id));\n            used_ids.insert(id);\n            ids[i] = id;\n        }\n    } else if (type == \"max\") {\n        int start = 1000000 - n + 1;\n        for (int i = 0; i < n; ++i)\n            ids[i] = start + i;\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n    } else if (type == \"random_large\") {\n        set<int> used_ids;\n        for (int i = 0; i < n; ++i) {\n            int id;\n            do {\n                id = rnd.next(1000000 - n + 1, 1000000);\n            } while (used_ids.count(id));\n            used_ids.insert(id);\n            ids[i] = id;\n        }\n    } else {\n        // Default to random\n        set<int> used_ids;\n        for (int i = 0; i < n; ++i) {\n            int id;\n            do {\n                id = rnd.next(1, 1000000);\n            } while (used_ids.count(id));\n            used_ids.insert(id);\n            ids[i] = id;\n        }\n    }\n\n    // Now, generate ai and bi for each student\n    vector<int> ai(n), bi(n);\n\n    for (int i = 0; i < n; ++i) {\n        if (i == 0) {\n            ai[i] = 0;\n            bi[i] = ids[i + 1];\n        } else if (i == n -1) {\n            ai[i] = ids[i - 1];\n            bi[i] = 0;\n        } else {\n            ai[i] = ids[i - 1];\n            bi[i] = ids[i + 1];\n        }\n    }\n\n    // Create the neighbor list\n    vector<pair<int, int>> neighbor_list(n);\n    for (int i = 0; i < n; ++i) {\n        neighbor_list[i] = make_pair(ai[i], bi[i]);\n    }\n\n    // Shuffle the neighbor list\n    shuffle(neighbor_list.begin(), neighbor_list.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the neighbor list\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", neighbor_list[i].first, neighbor_list[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type random\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type random\n./gen -n 50000 -type increasing\n./gen -n 50000 -type decreasing\n./gen -n 50000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type random\n./gen -n 199999 -type random_large\n./gen -n 200000 -type increasing\n./gen -n 200000 -type decreasing\n./gen -n 200000 -type random\n./gen -n 200000 -type max\n./gen -n 200000 -type min\n./gen -n 200000 -type random_large\n./gen -n 2 -type random_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:05.526237",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "490/C",
      "title": "C. Взлом шифра",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записан публичный ключ мессенджера — целое число без ведущих нулей, имеющее длину от 1 до 106 цифр. Вторая строка содержит пару записанных через пробел целых положительных чисел a, b (1 ≤ a, b ≤ 108).",
      "output_spec": "Выходные данныеВ первую строку выведите «YES» (без кавычек), если искомый способ существует. Далее в этом случае выведите две строки — левую и правую части после разреза. Записанные подряд (сначала левая, потом правая) эти части должны в точности составлять публичный ключ. Левая часть должна делиться на a, а правая — на b. Обе части должны быть целыми положительными числами, не имеющими ведущих нулей. Если ответов несколько, выведите любой из них.Если ответа не существует, то выведите в единственной строке «NO» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать11640102497 1024Выходные данныеСкопироватьYES116401024Входные данныеСкопировать2842545891539281719112818110001009 1000Выходные данныеСкопироватьYES284254589153928171911281811000Входные данныеСкопировать12012 1Выходные данныеСкопироватьNO",
      "description": "C. Взлом шифра\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записан публичный ключ мессенджера — целое число без ведущих нулей, имеющее длину от 1 до 106 цифр. Вторая строка содержит пару записанных через пробел целых положительных чисел a, b (1 ≤ a, b ≤ 108).\n\nВходные данные\n\nВыходные данныеВ первую строку выведите «YES» (без кавычек), если искомый способ существует. Далее в этом случае выведите две строки — левую и правую части после разреза. Записанные подряд (сначала левая, потом правая) эти части должны в точности составлять публичный ключ. Левая часть должна делиться на a, а правая — на b. Обе части должны быть целыми положительными числами, не имеющими ведущих нулей. Если ответов несколько, выведите любой из них.Если ответа не существует, то выведите в единственной строке «NO» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать11640102497 1024Выходные данныеСкопироватьYES116401024Входные данныеСкопировать2842545891539281719112818110001009 1000Выходные данныеСкопироватьYES284254589153928171911281811000Входные данныеСкопировать12012 1Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать11640102497 1024\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES116401024\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2842545891539281719112818110001009 1000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES284254589153928171911281811000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать12012 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "Всем доброго времени суток!Сегодня в 12:00 по Москве состоится Codeforces Round #279, предназначенный для участников второго дивизиона. Раунд проходит на задачах муниципиального (II) этапа всероссийской олимпиады школьников по информатике 2014-2015 учебного года, который проходит в это же время в Саратове.Раунд подготовила для вас дружная команда Saratov SU 2, членами которой в разное время являлись и являются ikar, HolkinPV, IlyaLos, fcspartakm.Вам будет предложено 6 задач на 2 часа 30 минут. Разбаловка будет оглашена непосредственно перед раундом.Раунд является рейтинговым для участников из второго дивизиона. Участники из первого дивизиона, как и всегда, могут участвовать вне конкурса.UPD: Разбалловка — 500-1000-1500-2000-2000-2500.Удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 750
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "490A - Командная олимпиадаБудем формировать команды жадно. То есть, если у нас есть по одному школьнику каждого из трёх типов, которые ещё не относятся ни к какой команде, то из них можно сформировать новую команду. И так делее, пока достигнется ситуация, когда мы не сможем сформировать команду. Таким образом, общее число команд — это минимум из количеcтва школьников каждого из трёх типов. Решение получается за O(N), если сложить индексы школьников каждого типа в три отдельных массива. Можно решать и за O(N2), если каждый раз пробегаться по всему массиву в поисках школьника конкретного типа для очередной команды.490B - ОчередьЭту задачу будем решать конструктивно. Определим, кто находится на первом месте — это студент с таким номером, который встречается среди чисел ai, но не встречается среди чисел bi (потому, что ни для кого из остальных он не находится позади). Определим, кто находится на втором месте — это студент, который стоит позади первого, а поскольку у первого студента число ai равно 0, то соответствующее ему число bi и будет его номером (то есть число из пары [0, bi]).Теперь будем определять остальных, начиная с третьего. Это делается очень просто по предпоследнему уже определенному номеру студента. Номер очередного студента, это число bi в некоторой паре, где число ai, это номер предпоследнего уже найденного номера студента (то есть число из пары [ans[i - 2], bi]. Решение достаточно просто осознать, разбирая пример из условия.490C - Взлом шифраБудем решать эту задачу следующим образом. Сначала проверим все префиксы заданного числа — делятся ли они на число a. Это можно сделать за O(N), где N — это длина заданного числа C. Зная остаток от деления префикса, заканчивающегося в позиции pos, можно пересчитать остаток для позиции pos + 1 следующим образом: rema[pos + 1] = (rema[pos] * 10 + C[pos + 1]) % a.Затем нужно проверить все суффиксы числа C — делятся ли они на число b. Зная остаток от деления суффикса, начинающегося в позиции pos, можно пересчитать остаток для позиции pos - 1 следующим образом: remb[pos - 1] = (C[pos - 1] * P + remb[pos]) % b, где P — это 10^(L - 1) по модулю b, L — это длина суффикса (величину P можно вычислять параллельно).Теперь нужно перебрать все позиции pos и проверить, можно ли сделать разрез числа C после этой позиции. Для этого необходимо выполнение четырех условий: префикс числа C, заканчивающийся в позиции pos, делится на число a; суффикс числа C, начинающийся в позиции pos + 1, делится на число b; длины префикса и суффикса ненулевые; суффикс не может начинаться с цифры 0. Если все эти условия выполняются, то после позиции pos можно сделать разрез. Если же все позиции не подходят, то решения не существует и следует вывести NO.490D - ШоколадкиЗаметим, что мы можем преобразовывать число следующим образом, либо делить на два либо делить на три и домножать на два. Изначально уберём из чисел все степени двоек и троек. После этого проверим, возможно ли удалив все эти степени добиться равенства площадей, если нет, то ответа не существует. Посмотрим на разность количества троек в факторизации шоколадок. Понятно, что именно на такое число нужно сократить одну из шоколадок, в зависимости от знака. Выполним данную операцию, пересчитывая количество двоек, и после сделаем то же самое для них.490E - Восстановление возрастающей последовательностиБудем решать данную задачу жадным образом. Будем перебирать заданные числа сначала и пытаться сделать из текущего числа минимальное, но большее предыдущего. Обозначим текущее число — cur, а предыдущее число — prev. Если длина числа cur меньше длины числа prev — следует вывести NO, задача не имеет решения.Если длина числа cur больше длины числа prev — заменим все знаки ? в числе cur на цифру 0, за исключением случая, когда знак ? стоит в первой позиции — заменим его на цифру 1, так как числа в ответе не могут иметь лидирующих нулей.Остался случай, когда длины чисел cur и prev равны. По условию задачи, каждое число в ответе должно быть строго больше предыдущего. Переберем позицию pos, в которой префикс числа cur больше чем префикс числа prev. Теперь попробуем для этой позиции сделать минимально возможное число, большее prev. Во всех позициях posi в которых стоит знак ? и меньших pos, поставим цифру, которая стоит в соответствующей позиции числа cur. А во всех позициях posi в которых стоит знак ? и больших pos, поставим цифру 0. Если в числе cur в позиции pos стоит знак ?, то поставим в эту позиции цифру на 1 большую, чем prev[pos]. Если в prev[pos] стоит цифра 9, то данная позиция pos не подходит для рассмотрения. Если полученное число меньше либо равно предыдущему, то данная позиция pos не подходит. Из всех подходящих позиций pos выберем минимальное число, полученное в результате описанных выше действий, присвоим ему число cur и продолжим восстановление ответа. Если подходящих позиций pos на каком-то шаге не нашлось — следует вывести NO.490F - Турне по ДревляндииЗадача является обобщением нахождения наибольшей возрастающей подпоследовательности в массиве, поэтому наверняка решается диначеским программированием. Будем делать динамику d[(u, v)], в которой состоянием является ориентированное ребро в графе (u, v). В динамике будем хранить максимальное число вершин, где группа могла дать концерты на каком-то простом пути, заканчивающемся в вершине v и проходящем через вершину u. Причём в вершине v точно будет концерт. Чтобы посчитать значение для ребра (u, v) нужно посчитать значение для всех рёбер (x, y) таких, что существует простой путь, начинающийся в вершине x, проходящий через вершины y и u и заканчивающийся в вершине v.Чтобы найти все рёбра (x, y), удовлетворяющие этому условию, нужно просто запустить обход в глубину из вершины u, которому будет запрещено заходить за вершину v. Тогда все ребра, которые он обойдёт, нужно просто взять с обратной ориентацией. Таким образом если r[y] < r[v], то d[(u, v)] = max(d[(u, v)], d[(x, y)] + 1). В итоге получется решение за O(N2) и (O(N2)) памяти. Память можно сократить до линейной если научиться получать индексы ориентированных рёбер без обращения к двумерному массиву.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 490\\s*C"
          },
          "content_length": 6089
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "int[] map = new int[1000000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "int[] map = new int[1000001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 7",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 8",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 9",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 10",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 11",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 12",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 13",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 14",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 15",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 16",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 17",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 18",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 19",
          "code": "x[i] = s[0..i] % a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 20",
          "code": "y[i] = s[i..n-1] % b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 21",
          "code": "x[i] == 0 and y[i+1] == 0 and s[i + 1] != '0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 22",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 23",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "O(N^2 * logN)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1 1 2 2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "D-Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "a1*b1!=a2*b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n\r\n    string publicKey = inf.readToken(\"[1-9][0-9]{0,999999}\", \"publicKey\");\r\n    inf.readEoln();\r\n\r\n    int a = inf.readInt(1, 100000000, \"a\");\r\n    inf.readSpace();\r\n    int b = inf.readInt(1, 100000000, \"b\");\r\n    inf.readEoln();\r\n\r\n    inf.readEof();\r\n    return 0;\r\n}",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n\r\n    string publicKey = inf.readToken(\"[1-9][0-9]{0,999999}\", \"publicKey\");\r\n    inf.readEoln();\r\n\r\n    int a = inf.readInt(1, 100000000, \"a\");\r\n    inf.readSpace();\r\n    int b = inf.readInt(1, 100000000, \"b\");\r\n    inf.readEoln();\r\n\r\n    inf.readEof();\r\n    return 0;\r\n}",
            "output_validator": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n\r\n    string publicKey = inf.readToken(\"[1-9][0-9]{0,999999}\", \"publicKey\");\r\n    inf.readEoln();\r\n\r\n    int a = inf.readInt(1, 100000000, \"a\");\r\n    inf.readSpace();\r\n    int b = inf.readInt(1, 100000000, \"b\");\r\n    inf.readEoln();\r\n\r\n    inf.readEof();\r\n    return 0;\r\n}",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring S;\nint a, b;\nstring ansFirstLine;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from the input file\n    S = inf.readToken(); // public key\n    a = inf.readInt(); // divisor a\n    b = inf.readInt(); // divisor b\n\n    // Read the judge's answer\n    ansFirstLine = ans.readToken();\n\n    // Read the contestant's output\n    string outFirstLine = ouf.readToken();\n\n    // Check that the first line is either 'YES' or 'NO'\n    if (outFirstLine != \"YES\" && outFirstLine != \"NO\") {\n        quitf(_wa, \"Expected 'YES' or 'NO' in the first line, found '%s'\", outFirstLine.c_str());\n    }\n\n    if (outFirstLine == \"NO\") {\n        if (ansFirstLine == \"YES\") {\n            // Contestant outputs 'NO' when there is a valid split\n            quitf(_wa, \"Contestant's output is 'NO' while a valid split exists\");\n        }\n        // Accept 'NO' when the judge's answer is also 'NO'\n        quitf(_ok, \"Correctly output 'NO'\");\n    } else { // outFirstLine == \"YES\"\n        // Read the two parts\n        string leftPart = ouf.readToken();\n        string rightPart = ouf.readToken();\n\n        // Check if concatenation equals S\n        if (leftPart + rightPart != S) {\n            quitf(_wa, \"The concatenation of left and right parts does not equal the input number\");\n        }\n\n        // Check for leading zeros and non-empty parts\n        if (leftPart.empty() || (leftPart.size() > 1 && leftPart[0] == '0')) {\n            quitf(_wa, \"Left part is empty or has leading zeros\");\n        }\n        if (rightPart.empty() || (rightPart.size() > 1 && rightPart[0] == '0')) {\n            quitf(_wa, \"Right part is empty or has leading zeros\");\n        }\n\n        // Compute leftPart % a\n        int remA = 0;\n        for (char c : leftPart) {\n            if (!isdigit(c)) {\n                quitf(_wa, \"Left part contains non-digit characters\");\n            }\n            remA = (remA * 10 + (c - '0')) % a;\n        }\n        if (remA != 0) {\n            quitf(_wa, \"Left part is not divisible by %d\", a);\n        }\n\n        // Compute rightPart % b\n        int remB = 0;\n        for (char c : rightPart) {\n            if (!isdigit(c)) {\n                quitf(_wa, \"Right part contains non-digit characters\");\n            }\n            remB = (remB * 10 + (c - '0')) % b;\n        }\n        if (remB != 0) {\n            quitf(_wa, \"Right part is not divisible by %d\", b);\n        }\n\n        // All checks passed\n        quitf(_ok, \"Found a valid split\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000);\n    int a = opt<int>(\"a\", rnd.next(1, 100000000)); // 1 to 1e8\n    int b = opt<int>(\"b\", rnd.next(1, 100000000)); // 1 to 1e8\n    string type = opt<string>(\"type\", \"random\");\n\n    string public_key;\n\n    if (type == \"random\") {\n        // Generate random public key of length n\n        public_key += char(rnd.next('1', '9')); // first digit, no leading zeros\n        for (int i = 1; i < n; ++i) {\n            public_key += char(rnd.next('0', '9'));\n        }\n    } else if (type == \"max_length\") {\n        // n = 1e6\n        n = 1000000;\n        public_key += char(rnd.next('1', '9')); // first digit\n        for (int i = 1; i < n; ++i) {\n            public_key += char(rnd.next('0', '9'));\n        }\n    } else if (type == \"leading_zero_right\") {\n        // Generate public_key where the only split is invalid due to leading zero on right\n        string left_part;\n        string right_part;\n        // Generate left part\n        left_part += char(rnd.next('1', '9')); // no leading zero\n        int left_length = n / 2;\n        for (int i = 1; i < left_length; ++i) {\n            left_part += char(rnd.next('0', '9'));\n        }\n        // Generate right part starting with '0'\n        right_part += '0';\n        for (int i = 1; i < n - left_length; ++i) {\n            right_part += char(rnd.next('0', '9'));\n        }\n        public_key = left_part + right_part;\n        // Adjust 'a' and 'b' so that left_part % a == 0, right_part % b == 0\n        // Compute left_part modulo to get a\n        long long left_num = 0;\n        for (char c : left_part) {\n            left_num = (left_num * 10 + (c - '0')) % 100000000; // modulo 1e8 to keep within limits\n        }\n        a = left_num ? left_num : 1;\n        // Similarly for right_part\n        long long right_num = 0;\n        for (char c : right_part) {\n            right_num = (right_num * 10 + (c - '0')) % 100000000; // modulo 1e8 to keep within limits\n        }\n        b = right_num ? right_num : 1;\n    } else if (type == \"no_solution\") {\n        // Generate a test case where no valid split exists\n        // For simplicity, set n = 3\n        n = 3;\n        public_key = \"120\";\n        a = 12;\n        b = 1;\n    } else {\n        // default to random\n        public_key += char(rnd.next('1', '9')); // first digit, no leading zeros\n        for (int i = 1; i < n; ++i) {\n            public_key += char(rnd.next('0', '9'));\n        }\n    }\n\n    // Output the public key\n    cout << public_key << endl;\n    // Output a and b\n    cout << a << \" \" << b << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000);\n    int a = opt<int>(\"a\", rnd.next(1, 100000000)); // 1 to 1e8\n    int b = opt<int>(\"b\", rnd.next(1, 100000000)); // 1 to 1e8\n    string type = opt<string>(\"type\", \"random\");\n\n    string public_key;\n\n    if (type == \"random\") {\n        // Generate random public key of length n\n        public_key += char(rnd.next('1', '9')); // first digit, no leading zeros\n        for (int i = 1; i < n; ++i) {\n            public_key += char(rnd.next('0', '9'));\n        }\n    } else if (type == \"max_length\") {\n        // n = 1e6\n        n = 1000000;\n        public_key += char(rnd.next('1', '9')); // first digit\n        for (int i = 1; i < n; ++i) {\n            public_key += char(rnd.next('0', '9'));\n        }\n    } else if (type == \"leading_zero_right\") {\n        // Generate public_key where the only split is invalid due to leading zero on right\n        string left_part;\n        string right_part;\n        // Generate left part\n        left_part += char(rnd.next('1', '9')); // no leading zero\n        int left_length = n / 2;\n        for (int i = 1; i < left_length; ++i) {\n            left_part += char(rnd.next('0', '9'));\n        }\n        // Generate right part starting with '0'\n        right_part += '0';\n        for (int i = 1; i < n - left_length; ++i) {\n            right_part += char(rnd.next('0', '9'));\n        }\n        public_key = left_part + right_part;\n        // Adjust 'a' and 'b' so that left_part % a == 0, right_part % b == 0\n        // Compute left_part modulo to get a\n        long long left_num = 0;\n        for (char c : left_part) {\n            left_num = (left_num * 10 + (c - '0')) % 100000000; // modulo 1e8 to keep within limits\n        }\n        a = left_num ? left_num : 1;\n        // Similarly for right_part\n        long long right_num = 0;\n        for (char c : right_part) {\n            right_num = (right_num * 10 + (c - '0')) % 100000000; // modulo 1e8 to keep within limits\n        }\n        b = right_num ? right_num : 1;\n    } else if (type == \"no_solution\") {\n        // Generate a test case where no valid split exists\n        // For simplicity, set n = 3\n        n = 3;\n        public_key = \"120\";\n        a = 12;\n        b = 1;\n    } else {\n        // default to random\n        public_key += char(rnd.next('1', '9')); // first digit, no leading zeros\n        for (int i = 1; i < n; ++i) {\n            public_key += char(rnd.next('0', '9'));\n        }\n    }\n\n    // Output the public key\n    cout << public_key << endl;\n    // Output a and b\n    cout << a << \" \" << b << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random tests with varying n\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n./gen -n 10000 -type random\n./gen -n 50000 -type random\n./gen -n 100000 -type random\n./gen -n 500000 -type random\n\n# Maximum length test\n./gen -n 1000000 -type max_length\n\n# Leading zero right tests\n./gen -n 10 -type leading_zero_right\n./gen -n 100 -type leading_zero_right\n./gen -n 1000 -type leading_zero_right\n\n# No solution test\n./gen -type no_solution\n\n# Custom a and b\n./gen -n 1000 -a 1 -b 1 -type random\n./gen -n 1000 -a 99999989 -b 99999971 -type random\n\n# Edge cases with small n\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n\n# Random tests with specified a and b\n./gen -n 1000 -a 12345 -b 67890 -type random\n./gen -n 1000 -a 100000000 -b 100000000 -type random\n\n# Leading zero right test with specific n\n./gen -n 2000 -type leading_zero_right\n\n# Random tests with maximum a and b\n./gen -n 1000 -a 100000000 -b 100000000 -type random\n\n# Random tests with a or b equal to 1\n./gen -n 1000 -a 1 -b 98765432 -type random\n./gen -n 1000 -a 98765432 -b 1 -type random\n\n# Max_length test with specified a and b\n./gen -type max_length -a 99999989 -b 99999971\n\n# Random tests with small a and b\n./gen -n 1000 -a 2 -b 3 -type random\n./gen -n 1000 -a 5 -b 7 -type random\n\n# Random tests with equal a and b\n./gen -n 1000 -a 12345678 -b 12345678 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:07.895437",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "490/D",
      "title": "D. Chocolate",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers a1, b1 (1 ≤ a1, b1 ≤ 109) — the initial sizes of the first chocolate bar. The second line of the input contains integers a2, b2 (1 ≤ a2, b2 ≤ 109) — the initial sizes of the second bar.You can use the data of type int64 (in Pascal), long long (in С++), long (in Java) to process large integers (exceeding 231 - 1).",
      "output_spec": "OutputIn the first line print m — the sought minimum number of minutes. In the second and third line print the possible sizes of the bars after they are leveled in m minutes. Print the sizes using the format identical to the input format. Print the sizes (the numbers in the printed pairs) in any order. The second line must correspond to the first bar and the third line must correspond to the second bar. If there are multiple solutions, print any of them.If there is no solution, print a single line with integer -1.",
      "sample_tests": "ExamplesInputCopy2 62 3OutputCopy11 62 3InputCopy36 510 16OutputCopy316 55 16InputCopy3 52 1OutputCopy-1",
      "description": "D. Chocolate\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integers a1, b1 (1 ≤ a1, b1 ≤ 109) — the initial sizes of the first chocolate bar. The second line of the input contains integers a2, b2 (1 ≤ a2, b2 ≤ 109) — the initial sizes of the second bar.You can use the data of type int64 (in Pascal), long long (in С++), long (in Java) to process large integers (exceeding 231 - 1).\n\nOutputIn the first line print m — the sought minimum number of minutes. In the second and third line print the possible sizes of the bars after they are leveled in m minutes. Print the sizes using the format identical to the input format. Print the sizes (the numbers in the printed pairs) in any order. The second line must correspond to the first bar and the third line must correspond to the second bar. If there are multiple solutions, print any of them.If there is no solution, print a single line with integer -1.\n\nInputCopy2 62 3OutputCopy11 62 3InputCopy36 510 16OutputCopy316 55 16InputCopy3 52 1OutputCopy-1\n\nInputCopy2 62 3\n\nOutputCopy11 62 3\n\nInputCopy36 510 16\n\nOutputCopy316 55 16\n\nInputCopy3 52 1\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "Hi everybody!Today at 12:00 Moscow Time there will be Codeforces Round #279, dedicated for second division contestants. Round is based on the problems of the Saratov second round of All-Russian School Olympiad in Informatics 2014-2015 that is held at the same time in Saratov.This round was brought to you by ikar, HolkinPV, IlyaLos, fcspartakm that are all members and ex-members of Saratov SU 2 team.There will be 6 tasks for 2 hours 30 minutes. Scoring will be announced just before the round starts.Round will be rated for second divison participants. First division contestants may participate out of competition.UPD: Scoring: 500-1000-1500-2000-2000-2500.Good luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces",
          "content": "490A - Team OlympiadThe teams could be formed using greedy algorithm. We can choose any three children with different skills who are not participants of any team yet and form a new team using them. After some time we could not form any team, so the answer to the problem is minimum of the number of ones, twos and threes in given array. We can get O(N) solution if we add children with different skills into three different arrays. Also the problem could be solved in O(N2) — every iteration find new three children for new team.490B - QueueThis problem can be solved constructively. Find the first student — it is a student with such number which can be found among ai and could not be found among bi (because he doesn’t stand behind for anybody). Find the second student — it is a student standing behind the first, number ai of the first student equals 0, so his number is a number in pair [0, bi].After that we will find numbers of all other students beginning from the third. It can be easily done using penultimate found number. The number of the next student is a number bi in such pair where ai equals to number of penultimate found student number (that is a number in pair [ans[i - 2], bi]). Look at the sample to understand the solution better.490C - Hacking CypherAt first, let’s check all prefixes of specified number — do they have remainder 0 when divided by the a? It can be done with asymptotic behavior O(N), where N -length of specified number C. If we have remainder of division by a of prefix, which ends in position pos, we can count remainder in position pos + 1: rema[pos + 1] = (rema[pos] * 10 + C[pos + 1]) % a.Then we need to check suffixes.If we have remainder of division by b of suffix, which begin in position pos, we can count remainder of position pos - 1: remb[pos - 1] = (C[pos - 1] * P + remb[pos]) % b, where P — it is 10^(L - 1) module b, L — length of suffix (P we can count parallel).Now let’s check all positions pos — can we cut specified number C in this position. We can do it if next four conditions performed: prefix of number C, which ends in pos is divisible by a; suffix of number C, which begin in pos + 1 is divisible by b; length of prefix and suffix more than 0; first digit of suffix is different from 0. If all four conditions performed we found answer. If we did not find any such positions, than print NO.490D - ChocolateWe can change the numbers by dividing their by two or by dividing their by three and multiply two. Firstly remove all 2 and 3 from factorization of chocolate and determine equals their square or not. If their squares are not equals answer doesn’t exists. Otherwise calculate of difference between number of three in factorization, we should remove this amount of threes from the some chocolate, it depends from the sign, and recalculate difference between number of two in factorization and do the same.490E - Restoring Increasing SequenceLet’s iterate on specified numbers and try to make from current number minimal possible, which value more than value of previous number. Let’s current number is cur, previous number is prev. If length of number cur less than length of number prev — let’s print NO, this problem has not solution.If length of number cur more than length of number prev — replace all signs ? in number cur to digit 0, except case, when sign ? in first position — replace him on digit 1, because numbers in answer must be without leading zeroes.Another case when lengths of numbers a and b are equal. Let’s iterate on positions pos, in which prefix number cur more than prefix of number prev. Now we need to try for this position make minimal possible number, which more than prev. In all positions posi, which less than pos, replace all ? on prev[posi]. In all positions posi, which more than pos, replace all ? on digit 0. If cur[pos] =  = ? than make cur[pos] = max(prev[pos] + 1, 9).If received number less or equal to prev — this position is bad. From all good positions choose minimal number, received with operations above and assign him number cur and will continue iteration. If count of such positions is 0 we need to print NO.490F - Treeland TourThe problem is generalization of finding maximal increasing subsequence in array, so it probably can be solved using dynamic programming. We will calс dynamic d[(u, v)], the state is directed edge (u, v) in tree. Value d[(u, v)] means the maximum number of vertices where the band will have concerts on some simple path ended in vertex v going through vertex u. Also the concert in vertex v must be certainly.To calc d(u, v) we should consider all such edges (x, y) that there is simple path started in x, going through y, u and ended in v. These edges can be found using dfs from vertex u which is not going through vertex v. All edges used by dfs should be reoriented. So if r[y] < r[v] then d[(u, v)] = max(d[(u, v)], d[(x, y)] + 1). The solution needs O(N2) time and O(N2) memory. The memory could be O(N) if you get indexes of directed edges without two-dimensional array.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 490\\s*D"
          },
          "content_length": 5030
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "int[] map = new int[1000000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "int[] map = new int[1000001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 7",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 8",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 9",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 10",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 11",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 12",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 13",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 14",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 15",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 16",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 17",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 18",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 19",
          "code": "x[i] = s[0..i] % a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 20",
          "code": "y[i] = s[i..n-1] % b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 21",
          "code": "x[i] == 0 and y[i+1] == 0 and s[i + 1] != '0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 22",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 23",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "O(N^2 * logN)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1 1 2 2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "D-Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "a1*b1!=a2*b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a1 = inf.readInt(1, 1000000000, \"a1\");\n    inf.readSpace();\n    int b1 = inf.readInt(1, 1000000000, \"b1\");\n    inf.readEoln();\n\n    int a2 = inf.readInt(1, 1000000000, \"a2\");\n    inf.readSpace();\n    int b2 = inf.readInt(1, 1000000000, \"b2\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a1 = inf.readInt(1, 1000000000, \"a1\");\n    inf.readSpace();\n    int b1 = inf.readInt(1, 1000000000, \"b1\");\n    inf.readEoln();\n\n    int a2 = inf.readInt(1, 1000000000, \"a2\");\n    inf.readSpace();\n    int b2 = inf.readInt(1, 1000000000, \"b2\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a1 = inf.readInt(1, 1000000000, \"a1\");\n    inf.readSpace();\n    int b1 = inf.readInt(1, 1000000000, \"b1\");\n    inf.readEoln();\n\n    int a2 = inf.readInt(1, 1000000000, \"a2\");\n    inf.readSpace();\n    int b2 = inf.readInt(1, 1000000000, \"b2\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll a1_initial, b1_initial, a2_initial, b2_initial;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read initial sizes from the input file\n    a1_initial = inf.readLong(1, (ll)1e9, \"a1\");\n    b1_initial = inf.readLong(1, (ll)1e9, \"b1\");\n    a2_initial = inf.readLong(1, (ll)1e9, \"a2\");\n    b2_initial = inf.readLong(1, (ll)1e9, \"b2\");\n\n    // Read judge's answer\n    ll m_judge = ans.readLong(-1, (ll)1e9, \"judge's m\");\n    ll m_participant;\n\n    // Read participant's answer\n    m_participant = ouf.readLong(-1, (ll)1e9, \"participant's m\");\n\n    if (m_judge == -1) {\n        if (m_participant != -1) {\n            quitf(_fail, \"Participant found a solution while judge says none exists\");\n        } else {\n            quitf(_ok, \"Correctly found no solution\");\n        }\n    } else {\n        if (m_participant == -1) {\n            quitf(_wa, \"Participant reports no solution while judge has a solution\");\n        } else if (m_participant > m_judge) {\n            quitf(_wa, \"Participant's m = %lld is greater than minimal m = %lld\", m_participant, m_judge);\n        } else if (m_participant < m_judge) {\n            quitf(_fail, \"Participant found a better solution: participant's m = %lld, judge's m = %lld\", m_participant, m_judge);\n        } else {\n            // m_participant == m_judge\n            // Read participant's final sizes\n            ll a1_final = ouf.readLong(1, (ll)1e9, \"a1_final\");\n            ll b1_final = ouf.readLong(1, (ll)1e9, \"b1_final\");\n            ll a2_final = ouf.readLong(1, (ll)1e9, \"a2_final\");\n            ll b2_final = ouf.readLong(1, (ll)1e9, \"b2_final\");\n\n            ll area1 = a1_final * b1_final;\n            ll area2 = a2_final * b2_final;\n\n            if (area1 != area2) {\n                quitf(_wa, \"Participant's final areas are not equal: area1 = %lld, area2 = %lld\", area1, area2);\n            }\n\n            if (a1_final > a1_initial || b1_final > b1_initial || a2_final > a2_initial || b2_final > b2_initial) {\n                quitf(_wa, \"Participant's final sizes cannot be larger than initial sizes\");\n            }\n\n            // We accept the participant's answer as correct\n            quitf(_ok, \"Correct answer with m = %lld\", m_participant);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    ll n = opt<ll>(\"n\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    ll a1, b1, a2, b2;\n\n    if (type == \"random\") {\n        a1 = rnd.next(1LL, n);\n        b1 = rnd.next(1LL, n);\n        a2 = rnd.next(1LL, n);\n        b2 = rnd.next(1LL, n);\n    }\n    else if (type == \"samearea\") {\n        // Generate a random area S between 1 and n^2\n        ll S = rnd.next(1LL, n*n);\n\n        // Find divisors of S up to n\n        vector<ll> divisors;\n        for (ll i = 1; i <= n && i * i <= S; ++i) {\n            if (S % i == 0) {\n                if (S / i <= n) {\n                    divisors.push_back(i);\n                    if (i != S / i)\n                        divisors.push_back(S / i);\n                }\n            }\n        }\n        if (divisors.size() == 0) {\n            // No valid divisors, set default values\n            a1 = b1 = a2 = b2 = 1;\n        } else {\n            // Shuffle divisors\n            shuffle(divisors.begin(), divisors.end());\n\n            // Pick two random divisors\n            ll d1 = divisors[rnd.next(0, (int)divisors.size()-1)];\n            ll d2 = divisors[rnd.next(0, (int)divisors.size()-1)];\n\n            a1 = d1;\n            b1 = S / d1;\n\n            a2 = d2;\n            b2 = S / d2;\n        }\n    }\n    else if (type == \"onlyhalves\") {\n        // Generate bars where only halves are possible\n        auto gen_bar_halves = [&]() {\n            ll a, b;\n            while (true) {\n                a = rnd.next(1LL, n);\n                b = rnd.next(1LL, n);\n                bool can_half = (a % 2 == 0 || b % 2 == 0);\n                bool can_third = (a % 3 == 0 || b % 3 == 0);\n                if (can_half && !can_third)\n                    break;\n            }\n            return make_pair(a, b);\n        };\n        tie(a1, b1) = gen_bar_halves();\n        tie(a2, b2) = gen_bar_halves();\n    }\n    else if (type == \"onlythirds\") {\n        // Generate bars where only thirds are possible\n        auto gen_bar_thirds = [&]() {\n            ll a, b;\n            while (true) {\n                a = rnd.next(1LL, n);\n                b = rnd.next(1LL, n);\n                bool can_half = (a % 2 == 0 || b % 2 == 0);\n                bool can_third = (a % 3 == 0 || b % 3 == 0);\n                if (!can_half && can_third)\n                    break;\n            }\n            return make_pair(a, b);\n        };\n        tie(a1, b1) = gen_bar_thirds();\n        tie(a2, b2) = gen_bar_thirds();\n    }\n    else if (type == \"both\") {\n        // Generate bars where both halves and thirds are possible\n        auto gen_bar_both = [&]() {\n            ll a, b;\n            while (true) {\n                a = rnd.next(1LL, n);\n                b = rnd.next(1LL, n);\n                if ((a % 6 == 0 || b % 6 == 0))\n                    break;\n            }\n            return make_pair(a, b);\n        };\n        tie(a1, b1) = gen_bar_both();\n        tie(a2, b2) = gen_bar_both();\n    }\n    else if (type == \"neither\") {\n        // Generate bars where neither halves nor thirds are possible\n        auto gen_bar_neither = [&]() {\n            ll a, b;\n            while (true) {\n                a = rnd.next(1LL, n);\n                b = rnd.next(1LL, n);\n                if (a % 2 != 0 && b % 2 != 0 && a % 3 != 0 && b % 3 != 0)\n                    break;\n            }\n            return make_pair(a, b);\n        };\n        tie(a1, b1) = gen_bar_neither();\n        tie(a2, b2) = gen_bar_neither();\n    }\n    else if (type == \"nosolution\") {\n        // Generate bars with areas that cannot be matched via dividing by 2 and 3\n        ll primes[] = {5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61};\n        ll p1 = primes[rnd.next(0, (int)(sizeof(primes)/sizeof(ll))-1)];\n        ll p2 = primes[rnd.next(0, (int)(sizeof(primes)/sizeof(ll))-1)];\n        while (p1 == p2) {\n            p2 = primes[rnd.next(0, (int)(sizeof(primes)/sizeof(ll))-1)];\n        }\n\n        auto gen_bar_with_area = [&](ll area) {\n            // Find factors of area within [1,n]\n            vector<pair<ll, ll>> factors;\n            for (ll i = 1; i <= n && i * i <= area; ++i) {\n                if (area % i == 0) {\n                    ll q = area / i;\n                    if (q <= n) {\n                        factors.push_back({i, q});\n                        if (i != q)\n                            factors.push_back({q, i});\n                    }\n                }\n            }\n            if (factors.empty()) {\n                // Cannot find factors within [1, n], set default\n                return make_pair(area, 1LL);\n            }\n            // Pick one randomly\n            auto pr = factors[rnd.next(0, (int)factors.size()-1)];\n            return pr;\n        };\n\n        tie(a1, b1) = gen_bar_with_area(p1);\n        tie(a2, b2) = gen_bar_with_area(p2);\n    }\n    else if (type == \"largevalues\") {\n        // Generate large values close to n\n        a1 = rnd.next(max(1LL, n - 100), n);\n        b1 = rnd.next(max(1LL, n - 100), n);\n        a2 = rnd.next(max(1LL, n - 100), n);\n        b2 = rnd.next(max(1LL, n - 100), n);\n    }\n    else if (type == \"smallvalues\") {\n        // Generate small values between 1 and 10\n        a1 = rnd.next(1LL, min(n, 10LL));\n        b1 = rnd.next(1LL, min(n, 10LL));\n        a2 = rnd.next(1LL, min(n, 10LL));\n        b2 = rnd.next(1LL, min(n, 10LL));\n    }\n    else {\n        // Default case, random values\n        a1 = rnd.next(1LL, n);\n        b1 = rnd.next(1LL, n);\n        a2 = rnd.next(1LL, n);\n        b2 = rnd.next(1LL, n);\n    }\n\n    // Output the two bars\n    printf(\"%lld %lld\\n\", a1, b1);\n    printf(\"%lld %lld\\n\", a2, b2);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    ll n = opt<ll>(\"n\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    ll a1, b1, a2, b2;\n\n    if (type == \"random\") {\n        a1 = rnd.next(1LL, n);\n        b1 = rnd.next(1LL, n);\n        a2 = rnd.next(1LL, n);\n        b2 = rnd.next(1LL, n);\n    }\n    else if (type == \"samearea\") {\n        // Generate a random area S between 1 and n^2\n        ll S = rnd.next(1LL, n*n);\n\n        // Find divisors of S up to n\n        vector<ll> divisors;\n        for (ll i = 1; i <= n && i * i <= S; ++i) {\n            if (S % i == 0) {\n                if (S / i <= n) {\n                    divisors.push_back(i);\n                    if (i != S / i)\n                        divisors.push_back(S / i);\n                }\n            }\n        }\n        if (divisors.size() == 0) {\n            // No valid divisors, set default values\n            a1 = b1 = a2 = b2 = 1;\n        } else {\n            // Shuffle divisors\n            shuffle(divisors.begin(), divisors.end());\n\n            // Pick two random divisors\n            ll d1 = divisors[rnd.next(0, (int)divisors.size()-1)];\n            ll d2 = divisors[rnd.next(0, (int)divisors.size()-1)];\n\n            a1 = d1;\n            b1 = S / d1;\n\n            a2 = d2;\n            b2 = S / d2;\n        }\n    }\n    else if (type == \"onlyhalves\") {\n        // Generate bars where only halves are possible\n        auto gen_bar_halves = [&]() {\n            ll a, b;\n            while (true) {\n                a = rnd.next(1LL, n);\n                b = rnd.next(1LL, n);\n                bool can_half = (a % 2 == 0 || b % 2 == 0);\n                bool can_third = (a % 3 == 0 || b % 3 == 0);\n                if (can_half && !can_third)\n                    break;\n            }\n            return make_pair(a, b);\n        };\n        tie(a1, b1) = gen_bar_halves();\n        tie(a2, b2) = gen_bar_halves();\n    }\n    else if (type == \"onlythirds\") {\n        // Generate bars where only thirds are possible\n        auto gen_bar_thirds = [&]() {\n            ll a, b;\n            while (true) {\n                a = rnd.next(1LL, n);\n                b = rnd.next(1LL, n);\n                bool can_half = (a % 2 == 0 || b % 2 == 0);\n                bool can_third = (a % 3 == 0 || b % 3 == 0);\n                if (!can_half && can_third)\n                    break;\n            }\n            return make_pair(a, b);\n        };\n        tie(a1, b1) = gen_bar_thirds();\n        tie(a2, b2) = gen_bar_thirds();\n    }\n    else if (type == \"both\") {\n        // Generate bars where both halves and thirds are possible\n        auto gen_bar_both = [&]() {\n            ll a, b;\n            while (true) {\n                a = rnd.next(1LL, n);\n                b = rnd.next(1LL, n);\n                if ((a % 6 == 0 || b % 6 == 0))\n                    break;\n            }\n            return make_pair(a, b);\n        };\n        tie(a1, b1) = gen_bar_both();\n        tie(a2, b2) = gen_bar_both();\n    }\n    else if (type == \"neither\") {\n        // Generate bars where neither halves nor thirds are possible\n        auto gen_bar_neither = [&]() {\n            ll a, b;\n            while (true) {\n                a = rnd.next(1LL, n);\n                b = rnd.next(1LL, n);\n                if (a % 2 != 0 && b % 2 != 0 && a % 3 != 0 && b % 3 != 0)\n                    break;\n            }\n            return make_pair(a, b);\n        };\n        tie(a1, b1) = gen_bar_neither();\n        tie(a2, b2) = gen_bar_neither();\n    }\n    else if (type == \"nosolution\") {\n        // Generate bars with areas that cannot be matched via dividing by 2 and 3\n        ll primes[] = {5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61};\n        ll p1 = primes[rnd.next(0, (int)(sizeof(primes)/sizeof(ll))-1)];\n        ll p2 = primes[rnd.next(0, (int)(sizeof(primes)/sizeof(ll))-1)];\n        while (p1 == p2) {\n            p2 = primes[rnd.next(0, (int)(sizeof(primes)/sizeof(ll))-1)];\n        }\n\n        auto gen_bar_with_area = [&](ll area) {\n            // Find factors of area within [1,n]\n            vector<pair<ll, ll>> factors;\n            for (ll i = 1; i <= n && i * i <= area; ++i) {\n                if (area % i == 0) {\n                    ll q = area / i;\n                    if (q <= n) {\n                        factors.push_back({i, q});\n                        if (i != q)\n                            factors.push_back({q, i});\n                    }\n                }\n            }\n            if (factors.empty()) {\n                // Cannot find factors within [1, n], set default\n                return make_pair(area, 1LL);\n            }\n            // Pick one randomly\n            auto pr = factors[rnd.next(0, (int)factors.size()-1)];\n            return pr;\n        };\n\n        tie(a1, b1) = gen_bar_with_area(p1);\n        tie(a2, b2) = gen_bar_with_area(p2);\n    }\n    else if (type == \"largevalues\") {\n        // Generate large values close to n\n        a1 = rnd.next(max(1LL, n - 100), n);\n        b1 = rnd.next(max(1LL, n - 100), n);\n        a2 = rnd.next(max(1LL, n - 100), n);\n        b2 = rnd.next(max(1LL, n - 100), n);\n    }\n    else if (type == \"smallvalues\") {\n        // Generate small values between 1 and 10\n        a1 = rnd.next(1LL, min(n, 10LL));\n        b1 = rnd.next(1LL, min(n, 10LL));\n        a2 = rnd.next(1LL, min(n, 10LL));\n        b2 = rnd.next(1LL, min(n, 10LL));\n    }\n    else {\n        // Default case, random values\n        a1 = rnd.next(1LL, n);\n        b1 = rnd.next(1LL, n);\n        a2 = rnd.next(1LL, n);\n        b2 = rnd.next(1LL, n);\n    }\n\n    // Output the two bars\n    printf(\"%lld %lld\\n\", a1, b1);\n    printf(\"%lld %lld\\n\", a2, b2);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 1000000 -type random\n./gen -n 1000000000 -type random\n\n./gen -n 100 -type samearea\n./gen -n 1000 -type samearea\n./gen -n 1000000 -type samearea\n./gen -n 1000000000 -type samearea\n\n./gen -n 100 -type onlyhalves\n./gen -n 1000 -type onlyhalves\n./gen -n 1000000 -type onlyhalves\n./gen -n 1000000000 -type onlyhalves\n\n./gen -n 100 -type onlythirds\n./gen -n 1000 -type onlythirds\n./gen -n 1000000 -type onlythirds\n./gen -n 1000000000 -type onlythirds\n\n./gen -n 100 -type both\n./gen -n 1000 -type both\n./gen -n 1000000 -type both\n./gen -n 1000000000 -type both\n\n./gen -n 100 -type neither\n./gen -n 1000 -type neither\n./gen -n 1000000 -type neither\n./gen -n 1000000000 -type neither\n\n./gen -n 100 -type nosolution\n./gen -n 1000 -type nosolution\n./gen -n 1000000 -type nosolution\n./gen -n 1000000000 -type nosolution\n\n./gen -n 1000000000 -type largevalues\n./gen -n 1000000000 -type largevalues\n./gen -n 10 -type smallvalues\n./gen -n 100 -type smallvalues\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:09.876834",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "490/E",
      "title": "E. Restoring Increasing Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 105) — the length of the sequence. Next n lines contain one element of the sequence each. Each element consists only of digits and question marks. No element starts from digit 0. Each element has length from 1 to 8 characters, inclusive.",
      "output_spec": "OutputIf the answer exists, print in the first line \"YES\" (without the quotes). Next n lines must contain the sequence of positive integers — a possible variant of Peter's sequence. The found sequence must be strictly increasing, it must be transformed from the given one by replacing each question mark by a single digit. All numbers on the resulting sequence must be written without leading zeroes. If there are multiple solutions, print any of them.If there is no answer, print a single line \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy3?181?OutputCopyYES11819InputCopy2???OutputCopyNOInputCopy51222412??512226?0000?00000OutputCopyYES12224122251222620000100000",
      "description": "E. Restoring Increasing Sequence\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 105) — the length of the sequence. Next n lines contain one element of the sequence each. Each element consists only of digits and question marks. No element starts from digit 0. Each element has length from 1 to 8 characters, inclusive.\n\nOutputIf the answer exists, print in the first line \"YES\" (without the quotes). Next n lines must contain the sequence of positive integers — a possible variant of Peter's sequence. The found sequence must be strictly increasing, it must be transformed from the given one by replacing each question mark by a single digit. All numbers on the resulting sequence must be written without leading zeroes. If there are multiple solutions, print any of them.If there is no answer, print a single line \"NO\" (without the quotes).\n\nInputCopy3?181?OutputCopyYES11819InputCopy2???OutputCopyNOInputCopy51222412??512226?0000?00000OutputCopyYES12224122251222620000100000\n\nInputCopy3?181?\n\nOutputCopyYES11819\n\nInputCopy2???\n\nOutputCopyNO\n\nInputCopy51222412??512226?0000?00000\n\nOutputCopyYES12224122251222620000100000",
      "solutions": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "Hi everybody!Today at 12:00 Moscow Time there will be Codeforces Round #279, dedicated for second division contestants. Round is based on the problems of the Saratov second round of All-Russian School Olympiad in Informatics 2014-2015 that is held at the same time in Saratov.This round was brought to you by ikar, HolkinPV, IlyaLos, fcspartakm that are all members and ex-members of Saratov SU 2 team.There will be 6 tasks for 2 hours 30 minutes. Scoring will be announced just before the round starts.Round will be rated for second divison participants. First division contestants may participate out of competition.UPD: Scoring: 500-1000-1500-2000-2000-2500.Good luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces",
          "content": "490A - Team OlympiadThe teams could be formed using greedy algorithm. We can choose any three children with different skills who are not participants of any team yet and form a new team using them. After some time we could not form any team, so the answer to the problem is minimum of the number of ones, twos and threes in given array. We can get O(N) solution if we add children with different skills into three different arrays. Also the problem could be solved in O(N2) — every iteration find new three children for new team.490B - QueueThis problem can be solved constructively. Find the first student — it is a student with such number which can be found among ai and could not be found among bi (because he doesn’t stand behind for anybody). Find the second student — it is a student standing behind the first, number ai of the first student equals 0, so his number is a number in pair [0, bi].After that we will find numbers of all other students beginning from the third. It can be easily done using penultimate found number. The number of the next student is a number bi in such pair where ai equals to number of penultimate found student number (that is a number in pair [ans[i - 2], bi]). Look at the sample to understand the solution better.490C - Hacking CypherAt first, let’s check all prefixes of specified number — do they have remainder 0 when divided by the a? It can be done with asymptotic behavior O(N), where N -length of specified number C. If we have remainder of division by a of prefix, which ends in position pos, we can count remainder in position pos + 1: rema[pos + 1] = (rema[pos] * 10 + C[pos + 1]) % a.Then we need to check suffixes.If we have remainder of division by b of suffix, which begin in position pos, we can count remainder of position pos - 1: remb[pos - 1] = (C[pos - 1] * P + remb[pos]) % b, where P — it is 10^(L - 1) module b, L — length of suffix (P we can count parallel).Now let’s check all positions pos — can we cut specified number C in this position. We can do it if next four conditions performed: prefix of number C, which ends in pos is divisible by a; suffix of number C, which begin in pos + 1 is divisible by b; length of prefix and suffix more than 0; first digit of suffix is different from 0. If all four conditions performed we found answer. If we did not find any such positions, than print NO.490D - ChocolateWe can change the numbers by dividing their by two or by dividing their by three and multiply two. Firstly remove all 2 and 3 from factorization of chocolate and determine equals their square or not. If their squares are not equals answer doesn’t exists. Otherwise calculate of difference between number of three in factorization, we should remove this amount of threes from the some chocolate, it depends from the sign, and recalculate difference between number of two in factorization and do the same.490E - Restoring Increasing SequenceLet’s iterate on specified numbers and try to make from current number minimal possible, which value more than value of previous number. Let’s current number is cur, previous number is prev. If length of number cur less than length of number prev — let’s print NO, this problem has not solution.If length of number cur more than length of number prev — replace all signs ? in number cur to digit 0, except case, when sign ? in first position — replace him on digit 1, because numbers in answer must be without leading zeroes.Another case when lengths of numbers a and b are equal. Let’s iterate on positions pos, in which prefix number cur more than prefix of number prev. Now we need to try for this position make minimal possible number, which more than prev. In all positions posi, which less than pos, replace all ? on prev[posi]. In all positions posi, which more than pos, replace all ? on digit 0. If cur[pos] =  = ? than make cur[pos] = max(prev[pos] + 1, 9).If received number less or equal to prev — this position is bad. From all good positions choose minimal number, received with operations above and assign him number cur and will continue iteration. If count of such positions is 0 we need to print NO.490F - Treeland TourThe problem is generalization of finding maximal increasing subsequence in array, so it probably can be solved using dynamic programming. We will calс dynamic d[(u, v)], the state is directed edge (u, v) in tree. Value d[(u, v)] means the maximum number of vertices where the band will have concerts on some simple path ended in vertex v going through vertex u. Also the concert in vertex v must be certainly.To calc d(u, v) we should consider all such edges (x, y) that there is simple path started in x, going through y, u and ended in v. These edges can be found using dfs from vertex u which is not going through vertex v. All edges used by dfs should be reoriented. So if r[y] < r[v] then d[(u, v)] = max(d[(u, v)], d[(x, y)] + 1). The solution needs O(N2) time and O(N2) memory. The memory could be O(N) if you get indexes of directed edges without two-dimensional array.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 490\\s*E"
          },
          "content_length": 5030
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "int[] map = new int[1000000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "int[] map = new int[1000001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 7",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 8",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 9",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 10",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 11",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 12",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 13",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 14",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 15",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 16",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 17",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 18",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 19",
          "code": "x[i] = s[0..i] % a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 20",
          "code": "y[i] = s[i..n-1] % b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 21",
          "code": "x[i] == 0 and y[i+1] == 0 and s[i + 1] != '0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 22",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 23",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "O(N^2 * logN)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1 1 2 2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "D-Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "a1*b1!=a2*b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s_i = inf.readLine(\"^[1-9?][0-9?]{0,7}$\", \"s_i\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s_i = inf.readLine(\"^[1-9?][0-9?]{0,7}$\", \"s_i\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s_i = inf.readLine(\"^[1-9?][0-9?]{0,7}$\", \"s_i\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt();\n    vector<string> patterns(n);\n    for (int i = 0; i < n; ++i) {\n        patterns[i] = inf.readToken();\n    }\n\n    // Read jury's answer\n    string jans = ans.readToken();\n    if (jans != \"YES\" && jans != \"NO\") {\n        ans.quitf(_fail, \"Jury output is neither YES nor NO\");\n    }\n\n    // Read participant's answer\n    string pans = ouf.readToken();\n    if (pans != \"YES\" && pans != \"NO\") {\n        quitf(_wa, \"Participant output is neither YES nor NO\");\n    }\n\n    if (jans == \"NO\") {\n        if (pans == \"NO\") {\n            // Ensure there is no extra output\n            if (!ouf.seekEof()) {\n                ouf.quitf(_wa, \"Extra output after NO\");\n            }\n            quitf(_ok, \"Correct answer NO\");\n        } else { // Participant output YES\n            ouf.quitf(_wa, \"Participant claimed YES but correct answer is NO\");\n        }\n    } else { // Jury's answer is YES\n        if (pans == \"NO\") {\n            ouf.quitf(_wa, \"Participant claimed NO but correct answer is YES\");\n        } else { // Both outputs are YES\n            // Read participant's sequence\n            vector<string> participant_sequence;\n            for (int i = 0; i < n; ++i) {\n                if (ouf.eof()) {\n                    ouf.quitf(_wa, \"Participant output too short, expected %d numbers, got %d\", n, i);\n                }\n                string s = ouf.readToken();\n                participant_sequence.push_back(s);\n            }\n            // Ensure there is no extra output\n            if (!ouf.seekEof()) {\n                ouf.quitf(_wa, \"Extra output after sequence\");\n            }\n\n            // Validate participant's sequence\n            long long prev = 0;\n            for (int i = 0; i < n; ++i) {\n                string s = participant_sequence[i];\n                string pat = patterns[i];\n\n                // Check that s is a positive integer without leading zeros\n                if (s.empty()) {\n                    ouf.quitf(_wa, \"Empty number at index %d\", i + 1);\n                }\n\n                if (s[0] == '0' && s.size() > 1) {\n                    ouf.quitf(_wa, \"Leading zero in number at index %d: %s\", i + 1, s.c_str());\n                }\n\n                if (!all_of(s.begin(), s.end(), ::isdigit)) {\n                    ouf.quitf(_wa, \"Invalid character in number at index %d: %s\", i + 1, s.c_str());\n                }\n\n                long long num = atoll(s.c_str());\n                if (num <= 0) {\n                    ouf.quitf(_wa, \"Number at index %d is not positive: %s\", i + 1, s.c_str());\n                }\n\n                if (num <= prev) {\n                    ouf.quitf(_wa, \"Sequence not strictly increasing at index %d\", i + 1);\n                }\n\n                if (s.size() != pat.size()) {\n                    ouf.quitf(_wa, \"Number length mismatch at index %d: expected length %d, found %d\", i + 1, pat.size(), s.size());\n                }\n\n                for (size_t j = 0; j < s.size(); ++j) {\n                    if (pat[j] != '?' && pat[j] != s[j]) {\n                        ouf.quitf(_wa, \"Mismatch at index %d position %d: expected '%c', found '%c'\", i + 1, j + 1, pat[j], s[j]);\n                    }\n                }\n\n                prev = num;\n            }\n\n            quitf(_ok, \"Correct sequence\");\n        }\n    }\n\n    quitf(_fail, \"Unreachable code reached\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string ans = opt<string>(\"ans\", \"YES\");\n\n    vector<string> inputs(n);\n    vector<long long> seq(n);\n\n    long long maxValue = 99999999LL; // Max 8-digit number\n    long long minValue = 1;\n\n    if (type == \"random\") {\n        // Generate a random strictly increasing sequence\n        seq[0] = rnd.next(minValue, maxValue - n + 1);\n        for (int i = 1; i < n; ++i) {\n            long long minNext = seq[i - 1] + 1;\n            long long maxNext = min(seq[i - 1] + rnd.next(1LL, 100LL), maxValue - n + i + 1);\n            if (minNext > maxValue)\n                minNext = maxValue;\n            seq[i] = rnd.next(minNext, maxNext);\n        }\n    } \n    else if (type == \"same_length\") {\n        // All numbers have the same length\n        int length = opt<int>(\"length\", 8);\n        if (length < 1 || length > 8) {\n            cerr << \"Length must be between 1 and 8\" << endl;\n            return 1;\n        }\n        long long minNumber = pow(10LL, length - 1);\n        long long maxNumber = pow(10LL, length) - n;\n\n        if (maxNumber < minNumber) {\n            cerr << \"Cannot generate sequence with same_length and given n\" << endl;\n            return 1;\n        }\n\n        seq[0] = minNumber;\n        for (int i = 1; i < n; ++i) {\n            seq[i] = seq[i - 1] + 1LL;\n        }\n    }\n    else if (type == \"max_length\") {\n        // Numbers have maximum length 8\n        seq[0] = rnd.next(minValue, maxValue - n + 1);\n        for (int i = 1; i < n; ++i) {\n            seq[i] = seq[i - 1] + 1LL;\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate a test case where the answer is NO\n        // For that, we can generate all numbers as '?', so impossible to create strictly increasing sequence\n        for(int i =0; i<n; ++i){\n            int len = rnd.next(1,8);\n            inputs[i] = string(len,'?');\n        }\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output inputs\n        for(int i=0;i<n;++i){\n            printf(\"%s\\n\", inputs[i].c_str());\n        }\n        return 0;\n    }\n\n    // Now, we need to generate inputs[i] by replacing digits with '?'\n\n    for (int i = 0; i < n; ++i) {\n        string s = to_string(seq[i]);\n        int len = s.length();\n        // Length constraint: 1 to 8\n        if (len > 8) {\n            cerr << \"Number length exceeds 8 digits\" << endl;\n            return 1;\n        }\n        // Randomly replace some digits with '?'\n        // Decide how many digits to replace\n        int num_replace = rnd.next(0, len);\n        set<int> positions;\n        while (positions.size() < num_replace) {\n            int pos = rnd.next(0, len - 1);\n            positions.insert(pos);\n        }\n        for (int pos : positions) {\n            s[pos] = '?';\n        }\n        // Ensure that after replacement, s[0] is not '0'\n        if (s[0] == '0') {\n            // Try to fix it\n            if (positions.count(0)) {\n                // s[0] is '?', acceptable\n                // Do nothing\n            } else {\n                // s[0] is '0' and not '?', this is invalid\n                // We need to ensure s[0] != '0'\n                // We can change s[0] to '?' to make it acceptable\n                s[0] = '?';\n            }\n        }\n        inputs[i] = s;\n    }\n\n    // Now, we need to handle the 'NO' cases\n    if (ans == \"NO\") {\n        // Modify inputs to make it impossible\n        // For example, make all inputs the same number with '?'\n        long long sameNumber = seq[n/2];\n        string s = to_string(sameNumber);\n        // Replace all digits with '?'\n        for (size_t i = 0; i < s.size(); ++i) {\n            s[i] = '?';\n        }\n        for (int i = 0; i < n; ++i) {\n            inputs[i] = s;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the inputs\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", inputs[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string ans = opt<string>(\"ans\", \"YES\");\n\n    vector<string> inputs(n);\n    vector<long long> seq(n);\n\n    long long maxValue = 99999999LL; // Max 8-digit number\n    long long minValue = 1;\n\n    if (type == \"random\") {\n        // Generate a random strictly increasing sequence\n        seq[0] = rnd.next(minValue, maxValue - n + 1);\n        for (int i = 1; i < n; ++i) {\n            long long minNext = seq[i - 1] + 1;\n            long long maxNext = min(seq[i - 1] + rnd.next(1LL, 100LL), maxValue - n + i + 1);\n            if (minNext > maxValue)\n                minNext = maxValue;\n            seq[i] = rnd.next(minNext, maxNext);\n        }\n    } \n    else if (type == \"same_length\") {\n        // All numbers have the same length\n        int length = opt<int>(\"length\", 8);\n        if (length < 1 || length > 8) {\n            cerr << \"Length must be between 1 and 8\" << endl;\n            return 1;\n        }\n        long long minNumber = pow(10LL, length - 1);\n        long long maxNumber = pow(10LL, length) - n;\n\n        if (maxNumber < minNumber) {\n            cerr << \"Cannot generate sequence with same_length and given n\" << endl;\n            return 1;\n        }\n\n        seq[0] = minNumber;\n        for (int i = 1; i < n; ++i) {\n            seq[i] = seq[i - 1] + 1LL;\n        }\n    }\n    else if (type == \"max_length\") {\n        // Numbers have maximum length 8\n        seq[0] = rnd.next(minValue, maxValue - n + 1);\n        for (int i = 1; i < n; ++i) {\n            seq[i] = seq[i - 1] + 1LL;\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate a test case where the answer is NO\n        // For that, we can generate all numbers as '?', so impossible to create strictly increasing sequence\n        for(int i =0; i<n; ++i){\n            int len = rnd.next(1,8);\n            inputs[i] = string(len,'?');\n        }\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output inputs\n        for(int i=0;i<n;++i){\n            printf(\"%s\\n\", inputs[i].c_str());\n        }\n        return 0;\n    }\n\n    // Now, we need to generate inputs[i] by replacing digits with '?'\n\n    for (int i = 0; i < n; ++i) {\n        string s = to_string(seq[i]);\n        int len = s.length();\n        // Length constraint: 1 to 8\n        if (len > 8) {\n            cerr << \"Number length exceeds 8 digits\" << endl;\n            return 1;\n        }\n        // Randomly replace some digits with '?'\n        // Decide how many digits to replace\n        int num_replace = rnd.next(0, len);\n        set<int> positions;\n        while (positions.size() < num_replace) {\n            int pos = rnd.next(0, len - 1);\n            positions.insert(pos);\n        }\n        for (int pos : positions) {\n            s[pos] = '?';\n        }\n        // Ensure that after replacement, s[0] is not '0'\n        if (s[0] == '0') {\n            // Try to fix it\n            if (positions.count(0)) {\n                // s[0] is '?', acceptable\n                // Do nothing\n            } else {\n                // s[0] is '0' and not '?', this is invalid\n                // We need to ensure s[0] != '0'\n                // We can change s[0] to '?' to make it acceptable\n                s[0] = '?';\n            }\n        }\n        inputs[i] = s;\n    }\n\n    // Now, we need to handle the 'NO' cases\n    if (ans == \"NO\") {\n        // Modify inputs to make it impossible\n        // For example, make all inputs the same number with '?'\n        long long sameNumber = seq[n/2];\n        string s = to_string(sameNumber);\n        // Replace all digits with '?'\n        for (size_t i = 0; i < s.size(); ++i) {\n            s[i] = '?';\n        }\n        for (int i = 0; i < n; ++i) {\n            inputs[i] = s;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the inputs\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", inputs[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n\n./gen -n 2 -type impossible\n\n./gen -n 2 -type random\n\n./gen -n 2 -type same_length -length 1\n\n./gen -n 3 -type random\n\n./gen -n 10 -type random\n\n./gen -n 10 -type same_length -length 8\n\n./gen -n 10 -type impossible\n\n./gen -n 100 -type random\n\n./gen -n 100 -type same_length -length 5\n\n./gen -n 1000 -type max_length\n\n./gen -n 1000 -type random\n\n./gen -n 1000 -type impossible\n\n./gen -n 5000 -type random\n\n./gen -n 5000 -type same_length -length 8\n\n./gen -n 10000 -type random\n\n./gen -n 10000 -type impossible\n\n./gen -n 50000 -type random\n\n./gen -n 50000 -type same_length -length 8\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type impossible\n\n./gen -n 100000 -type same_length -length 8\n\n./gen -n 1 -type random -ans NO\n\n./gen -n 2 -type impossible\n\n./gen -n 10 -type random -ans NO\n\n./gen -n 100 -type random -ans NO\n\n./gen -n 1000 -type random -ans NO\n\n./gen -n 10000 -type random -ans NO\n\n./gen -n 10000 -type same_length -length 8 -ans NO\n\n./gen -n 50000 -type max_length -ans NO\n\n./gen -n 100000 -type random -ans NO\n\n./gen -n 100000 -type same_length -length 8 -ans NO\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:12.286478",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "490/F",
      "title": "F. Турне по Древляндии",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано целое число n (2 ≤ n ≤ 6000) — количество городов в Древляндии. Следующая строка содержит n целых чисел r1, r2, ..., rn (1 ≤ ri ≤ 106), где ri — численность населения i-го города. Следующая n - 1 строка содержит описания дорог, по одной дороге в строке. Каждая из дорог задается парой целых чисел aj, bj (1 ≤ aj, bj ≤ n) — парой номеров городов, которые соединены j-й дорогой. Все числа в строках разделяются пробелами.",
      "output_spec": "Выходные данныеВыведите количество городов, в которых «ДТП» даст концерты.",
      "sample_tests": "ПримерыВходные данныеСкопировать61 2 3 4 5 11 22 33 43 53 6Выходные данныеСкопировать4Входные данныеСкопировать51 2 3 4 51 21 32 43 5Выходные данныеСкопировать3",
      "description": "F. Турне по Древляндии\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано целое число n (2 ≤ n ≤ 6000) — количество городов в Древляндии. Следующая строка содержит n целых чисел r1, r2, ..., rn (1 ≤ ri ≤ 106), где ri — численность населения i-го города. Следующая n - 1 строка содержит описания дорог, по одной дороге в строке. Каждая из дорог задается парой целых чисел aj, bj (1 ≤ aj, bj ≤ n) — парой номеров городов, которые соединены j-й дорогой. Все числа в строках разделяются пробелами.\n\nВходные данные\n\nВыходные данныеВыведите количество городов, в которых «ДТП» даст концерты.\n\nВыходные данные\n\nВходные данныеСкопировать61 2 3 4 5 11 22 33 43 53 6Выходные данныеСкопировать4Входные данныеСкопировать51 2 3 4 51 21 32 43 5Выходные данныеСкопировать3\n\nВходные данныеСкопировать61 2 3 4 5 11 22 33 43 53 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 2 3 4 51 21 32 43 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "Всем доброго времени суток!Сегодня в 12:00 по Москве состоится Codeforces Round #279, предназначенный для участников второго дивизиона. Раунд проходит на задачах муниципиального (II) этапа всероссийской олимпиады школьников по информатике 2014-2015 учебного года, который проходит в это же время в Саратове.Раунд подготовила для вас дружная команда Saratov SU 2, членами которой в разное время являлись и являются ikar, HolkinPV, IlyaLos, fcspartakm.Вам будет предложено 6 задач на 2 часа 30 минут. Разбаловка будет оглашена непосредственно перед раундом.Раунд является рейтинговым для участников из второго дивизиона. Участники из первого дивизиона, как и всегда, могут участвовать вне конкурса.UPD: Разбалловка — 500-1000-1500-2000-2000-2500.Удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 750
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces",
          "content": "490A - Командная олимпиадаБудем формировать команды жадно. То есть, если у нас есть по одному школьнику каждого из трёх типов, которые ещё не относятся ни к какой команде, то из них можно сформировать новую команду. И так делее, пока достигнется ситуация, когда мы не сможем сформировать команду. Таким образом, общее число команд — это минимум из количеcтва школьников каждого из трёх типов. Решение получается за O(N), если сложить индексы школьников каждого типа в три отдельных массива. Можно решать и за O(N2), если каждый раз пробегаться по всему массиву в поисках школьника конкретного типа для очередной команды.490B - ОчередьЭту задачу будем решать конструктивно. Определим, кто находится на первом месте — это студент с таким номером, который встречается среди чисел ai, но не встречается среди чисел bi (потому, что ни для кого из остальных он не находится позади). Определим, кто находится на втором месте — это студент, который стоит позади первого, а поскольку у первого студента число ai равно 0, то соответствующее ему число bi и будет его номером (то есть число из пары [0, bi]).Теперь будем определять остальных, начиная с третьего. Это делается очень просто по предпоследнему уже определенному номеру студента. Номер очередного студента, это число bi в некоторой паре, где число ai, это номер предпоследнего уже найденного номера студента (то есть число из пары [ans[i - 2], bi]. Решение достаточно просто осознать, разбирая пример из условия.490C - Взлом шифраБудем решать эту задачу следующим образом. Сначала проверим все префиксы заданного числа — делятся ли они на число a. Это можно сделать за O(N), где N — это длина заданного числа C. Зная остаток от деления префикса, заканчивающегося в позиции pos, можно пересчитать остаток для позиции pos + 1 следующим образом: rema[pos + 1] = (rema[pos] * 10 + C[pos + 1]) % a.Затем нужно проверить все суффиксы числа C — делятся ли они на число b. Зная остаток от деления суффикса, начинающегося в позиции pos, можно пересчитать остаток для позиции pos - 1 следующим образом: remb[pos - 1] = (C[pos - 1] * P + remb[pos]) % b, где P — это 10^(L - 1) по модулю b, L — это длина суффикса (величину P можно вычислять параллельно).Теперь нужно перебрать все позиции pos и проверить, можно ли сделать разрез числа C после этой позиции. Для этого необходимо выполнение четырех условий: префикс числа C, заканчивающийся в позиции pos, делится на число a; суффикс числа C, начинающийся в позиции pos + 1, делится на число b; длины префикса и суффикса ненулевые; суффикс не может начинаться с цифры 0. Если все эти условия выполняются, то после позиции pos можно сделать разрез. Если же все позиции не подходят, то решения не существует и следует вывести NO.490D - ШоколадкиЗаметим, что мы можем преобразовывать число следующим образом, либо делить на два либо делить на три и домножать на два. Изначально уберём из чисел все степени двоек и троек. После этого проверим, возможно ли удалив все эти степени добиться равенства площадей, если нет, то ответа не существует. Посмотрим на разность количества троек в факторизации шоколадок. Понятно, что именно на такое число нужно сократить одну из шоколадок, в зависимости от знака. Выполним данную операцию, пересчитывая количество двоек, и после сделаем то же самое для них.490E - Восстановление возрастающей последовательностиБудем решать данную задачу жадным образом. Будем перебирать заданные числа сначала и пытаться сделать из текущего числа минимальное, но большее предыдущего. Обозначим текущее число — cur, а предыдущее число — prev. Если длина числа cur меньше длины числа prev — следует вывести NO, задача не имеет решения.Если длина числа cur больше длины числа prev — заменим все знаки ? в числе cur на цифру 0, за исключением случая, когда знак ? стоит в первой позиции — заменим его на цифру 1, так как числа в ответе не могут иметь лидирующих нулей.Остался случай, когда длины чисел cur и prev равны. По условию задачи, каждое число в ответе должно быть строго больше предыдущего. Переберем позицию pos, в которой префикс числа cur больше чем префикс числа prev. Теперь попробуем для этой позиции сделать минимально возможное число, большее prev. Во всех позициях posi в которых стоит знак ? и меньших pos, поставим цифру, которая стоит в соответствующей позиции числа cur. А во всех позициях posi в которых стоит знак ? и больших pos, поставим цифру 0. Если в числе cur в позиции pos стоит знак ?, то поставим в эту позиции цифру на 1 большую, чем prev[pos]. Если в prev[pos] стоит цифра 9, то данная позиция pos не подходит для рассмотрения. Если полученное число меньше либо равно предыдущему, то данная позиция pos не подходит. Из всех подходящих позиций pos выберем минимальное число, полученное в результате описанных выше действий, присвоим ему число cur и продолжим восстановление ответа. Если подходящих позиций pos на каком-то шаге не нашлось — следует вывести NO.490F - Турне по ДревляндииЗадача является обобщением нахождения наибольшей возрастающей подпоследовательности в массиве, поэтому наверняка решается диначеским программированием. Будем делать динамику d[(u, v)], в которой состоянием является ориентированное ребро в графе (u, v). В динамике будем хранить максимальное число вершин, где группа могла дать концерты на каком-то простом пути, заканчивающемся в вершине v и проходящем через вершину u. Причём в вершине v точно будет концерт. Чтобы посчитать значение для ребра (u, v) нужно посчитать значение для всех рёбер (x, y) таких, что существует простой путь, начинающийся в вершине x, проходящий через вершины y и u и заканчивающийся в вершине v.Чтобы найти все рёбра (x, y), удовлетворяющие этому условию, нужно просто запустить обход в глубину из вершины u, которому будет запрещено заходить за вершину v. Тогда все ребра, которые он обойдёт, нужно просто взять с обратной ориентацией. Таким образом если r[y] < r[v], то d[(u, v)] = max(d[(u, v)], d[(x, y)] + 1). В итоге получется решение за O(N2) и (O(N2)) памяти. Память можно сократить до линейной если научиться получать индексы ориентированных рёбер без обращения к двумерному массиву.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 490\\s*F"
          },
          "content_length": 6089
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "1230\n123 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1...1 (1 repeats 1e6 times)\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "int[] map = new int[1000000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "int[] map = new int[1000001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 7",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 8",
          "code": "mods_p = []\nmods_p.append(mod_p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 9",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 10",
          "code": "(1*10^8)+(1*10^7)+(6*10^6)+(4*10^5)+(0*10^4)+(1*10^3)+(0*10^2)+(2*10^1)+(4*10^0)\n\n   a8       a7       a6       a5       a4       a3       a2       a1       a0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 11",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 12",
          "code": "rem = 0;\nrep i from 0 to 8:\n    rem = ( rem%M + ai%M )%M;\nif(rem == 0)\n    the number is divisible by M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 13",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 14",
          "code": "1 16401024\n11 6401024\n116 401024\n1164 01024\n11640 1024\n116401 024\n1164010 24\n11640102 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 15",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 16",
          "code": "n = Number of digits in N;\nrem = N[0]%a;\nrep i from 1 to n-1:   --------------------------------> O(N)\n    rem = ((rem*10)%a + (N[i]%a))%a\n    if(rem == 0)\n        divisible_by_a[i] = true;\n    else\n        divisible_by_a[i] = false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 17",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 18",
          "code": "(divisible_by_a[i] == true) && (divisible_by_b[i+1] == true)  && (N[i+1] != 0)    -------> O(1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 19",
          "code": "x[i] = s[0..i] % a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 20",
          "code": "y[i] = s[i..n-1] % b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 21",
          "code": "x[i] == 0 and y[i+1] == 0 and s[i + 1] != '0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 22",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #279 (Div. 2) - Codeforces - Code 23",
          "code": "Test #12\n\n2160 3240\n7200 384\n\nВывод\n5\n1280 1080\n3600 384\n\nОтвет\n5\n640 2160\n3600 384\n\nПротокол тестирования\nwrong answer reported answer can be reached in minimum 1000000002 operations, but given result is 5 operations",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 1",
          "code": "O(N^2 * logN)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 2",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 3",
          "code": "N=int(input())\nT=list(map(int,input().split()))\nOutput=[]\nI=0\nwhile 1 in T and 2 in T and 3 in T:\n   try:\n      if T[I]==1:\n         Output.append([I+1])\n         T[I]=0\n         for I in range(N):\n            if T[I]==2:\n               Output[len(Output)-1].append(I+1)\n               T[I]=0\n               for I in range(N):\n                  if T[I]==3:\n                     Output[len(Output)-1].append(I+1)\n                     T[I]=0\n                     break\n               break\n   except IndexError:break\n   I+=1\nprint(len(Output))\nfor I in range(len(Output)):\n   for I2 in range(3):\n      if I2==2:print(Output[I][I2])\n      else:print(Output[I][I2],end=' ')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 4",
          "code": "1 1 2 2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 5",
          "code": "D-Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #279 (Div. 2) - Codeforces - Code 6",
          "code": "a1*b1!=a2*b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 6000 + 5;\n\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid Union(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 6000, \"n\");\n    inf.readEoln();\n\n    vector<int> r = inf.readInts(n, 1, 1000000, \"r_i\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Self-loops are not allowed (edge between %d and %d)\", a, b);\n\n        pair<int,int> p = make_pair(min(a,b), max(a,b));\n        ensuref(edges.count(p) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert(p);\n\n        int fa = find(a);\n        int fb = find(b);\n        ensuref(fa != fb, \"Graph contains a cycle detected between %d and %d\", a, b);\n        Union(fa, fb);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 6000 + 5;\n\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid Union(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 6000, \"n\");\n    inf.readEoln();\n\n    vector<int> r = inf.readInts(n, 1, 1000000, \"r_i\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Self-loops are not allowed (edge between %d and %d)\", a, b);\n\n        pair<int,int> p = make_pair(min(a,b), max(a,b));\n        ensuref(edges.count(p) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert(p);\n\n        int fa = find(a);\n        int fb = find(b);\n        ensuref(fa != fb, \"Graph contains a cycle detected between %d and %d\", a, b);\n        Union(fa, fb);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 6000 + 5;\n\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid Union(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 6000, \"n\");\n    inf.readEoln();\n\n    vector<int> r = inf.readInts(n, 1, 1000000, \"r_i\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Self-loops are not allowed (edge between %d and %d)\", a, b);\n\n        pair<int,int> p = make_pair(min(a,b), max(a,b));\n        ensuref(edges.count(p) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert(p);\n\n        int fa = find(a);\n        int fb = find(b);\n        ensuref(fa != fb, \"Graph contains a cycle detected between %d and %d\", a, b);\n        Union(fa, fb);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string rType = opt<string>(\"rType\", \"random\");\n\n    // Generate tree\n    vector<pair<int, int>> edges;\n    if (treeType == \"chain\") {\n        // Connect nodes in a line\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i + 1));\n        }\n    } else if (treeType == \"star\") {\n        // Central node 1 connected to all others\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(1, i));\n        }\n    } else if (treeType == \"binary\") {\n        // Build a binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(i / 2, i));\n        }\n    } else {\n        // Random tree\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back(make_pair(parent[i], i));\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate ri values\n    vector<int> r(n + 1);\n    if (rType == \"equal\") {\n        int val = rnd.next(1, 1000000);\n        for (int i = 1; i <= n; ++i)\n            r[i] = val;\n    } else if (rType == \"increasing\") {\n        r[1] = rnd.next(1, 50);\n        for (int i = 2; i <= n; ++i)\n            r[i] = r[i - 1] + rnd.next(1, 50);\n        shuffle(r.begin() + 1, r.end());\n    } else if (rType == \"decreasing\") {\n        r[1] = rnd.next(1e6 - 50 * n, 1e6);\n        for (int i = 2; i <= n; ++i)\n            r[i] = r[i - 1] - rnd.next(1, 50);\n        for (int i = 1; i <= n; ++i)\n            r[i] = max(r[i], 1);\n        shuffle(r.begin() + 1, r.end());\n    } else if (rType == \"random\") {\n        for (int i = 1; i <= n; ++i)\n            r[i] = rnd.next(1, 1000000);\n    } else if (rType == \"maxLIS\") {\n        // Create a chain with strictly increasing ri values\n        if (treeType != \"chain\") {\n            edges.clear();\n            for (int i = 1; i < n; ++i) {\n                edges.push_back(make_pair(i, i + 1));\n            }\n        }\n        for (int i = 1; i <= n; ++i) {\n            r[i] = i;\n        }\n    } else if (rType == \"minLIS\") {\n        // Set all ri equal\n        int val = rnd.next(1, 1000000);\n        for (int i = 1; i <= n; ++i) {\n            r[i] = val;\n        }\n    } else if (rType == \"equal_one\") {\n        for (int i = 1; i <= n; ++i) {\n            r[i] = 1;\n        }\n    } else if (rType == \"equal_max\") {\n        for (int i = 1; i <= n; ++i) {\n            r[i] = 1000000;\n        }\n    } else if (rType == \"path_increasing\") {\n        // Build a random tree, pick a random path, set ri increasing along that path\n        vector<vector<int>> adj(n + 1);\n        for (auto edge : edges) {\n            adj[edge.first].push_back(edge.second);\n            adj[edge.second].push_back(edge.first);\n        }\n        int pathLength = rnd.next(1, n);\n        vector<int> path;\n        vector<int> visited(n + 1, 0);\n        int current = rnd.next(1, n);\n        path.push_back(current);\n        visited[current] = 1;\n        while ((int)path.size() < pathLength) {\n            vector<int> candidates;\n            for (int neighbor : adj[current]) {\n                if (!visited[neighbor]) {\n                    candidates.push_back(neighbor);\n                }\n            }\n            if (candidates.empty()) break;\n            current = candidates[rnd.next(0, (int)candidates.size() - 1)];\n            path.push_back(current);\n            visited[current] = 1;\n        }\n        for (int i = 1; i <= n; ++i)\n            r[i] = rnd.next(1, 1000000);\n        int val = rnd.next(1, 1000000 - n);\n        for (int i = 0; i < (int)path.size(); ++i) {\n            r[path[i]] = val + i;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", r[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string rType = opt<string>(\"rType\", \"random\");\n\n    // Generate tree\n    vector<pair<int, int>> edges;\n    if (treeType == \"chain\") {\n        // Connect nodes in a line\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i + 1));\n        }\n    } else if (treeType == \"star\") {\n        // Central node 1 connected to all others\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(1, i));\n        }\n    } else if (treeType == \"binary\") {\n        // Build a binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(i / 2, i));\n        }\n    } else {\n        // Random tree\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back(make_pair(parent[i], i));\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate ri values\n    vector<int> r(n + 1);\n    if (rType == \"equal\") {\n        int val = rnd.next(1, 1000000);\n        for (int i = 1; i <= n; ++i)\n            r[i] = val;\n    } else if (rType == \"increasing\") {\n        r[1] = rnd.next(1, 50);\n        for (int i = 2; i <= n; ++i)\n            r[i] = r[i - 1] + rnd.next(1, 50);\n        shuffle(r.begin() + 1, r.end());\n    } else if (rType == \"decreasing\") {\n        r[1] = rnd.next(1e6 - 50 * n, 1e6);\n        for (int i = 2; i <= n; ++i)\n            r[i] = r[i - 1] - rnd.next(1, 50);\n        for (int i = 1; i <= n; ++i)\n            r[i] = max(r[i], 1);\n        shuffle(r.begin() + 1, r.end());\n    } else if (rType == \"random\") {\n        for (int i = 1; i <= n; ++i)\n            r[i] = rnd.next(1, 1000000);\n    } else if (rType == \"maxLIS\") {\n        // Create a chain with strictly increasing ri values\n        if (treeType != \"chain\") {\n            edges.clear();\n            for (int i = 1; i < n; ++i) {\n                edges.push_back(make_pair(i, i + 1));\n            }\n        }\n        for (int i = 1; i <= n; ++i) {\n            r[i] = i;\n        }\n    } else if (rType == \"minLIS\") {\n        // Set all ri equal\n        int val = rnd.next(1, 1000000);\n        for (int i = 1; i <= n; ++i) {\n            r[i] = val;\n        }\n    } else if (rType == \"equal_one\") {\n        for (int i = 1; i <= n; ++i) {\n            r[i] = 1;\n        }\n    } else if (rType == \"equal_max\") {\n        for (int i = 1; i <= n; ++i) {\n            r[i] = 1000000;\n        }\n    } else if (rType == \"path_increasing\") {\n        // Build a random tree, pick a random path, set ri increasing along that path\n        vector<vector<int>> adj(n + 1);\n        for (auto edge : edges) {\n            adj[edge.first].push_back(edge.second);\n            adj[edge.second].push_back(edge.first);\n        }\n        int pathLength = rnd.next(1, n);\n        vector<int> path;\n        vector<int> visited(n + 1, 0);\n        int current = rnd.next(1, n);\n        path.push_back(current);\n        visited[current] = 1;\n        while ((int)path.size() < pathLength) {\n            vector<int> candidates;\n            for (int neighbor : adj[current]) {\n                if (!visited[neighbor]) {\n                    candidates.push_back(neighbor);\n                }\n            }\n            if (candidates.empty()) break;\n            current = candidates[rnd.next(0, (int)candidates.size() - 1)];\n            path.push_back(current);\n            visited[current] = 1;\n        }\n        for (int i = 1; i <= n; ++i)\n            r[i] = rnd.next(1, 1000000);\n        int val = rnd.next(1, 1000000 - n);\n        for (int i = 0; i < (int)path.size(); ++i) {\n            r[path[i]] = val + i;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", r[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 2 -treeType chain -rType random\n./gen -n 2 -treeType star -rType equal\n./gen -n 2 -treeType binary -rType increasing\n\n./gen -n 5 -treeType chain -rType random\n./gen -n 5 -treeType star -rType decreasing\n./gen -n 5 -treeType binary -rType equal\n./gen -n 5 -treeType random -rType random\n\n# Medium test cases\n./gen -n 100 -treeType chain -rType increasing\n./gen -n 100 -treeType star -rType decreasing\n./gen -n 100 -treeType binary -rType random\n./gen -n 100 -treeType random -rType random\n\n# Large test cases\n./gen -n 6000 -treeType chain -rType increasing\n./gen -n 6000 -treeType star -rType random\n./gen -n 6000 -treeType binary -rType decreasing\n./gen -n 6000 -treeType random -rType random\n\n# Edge cases with maximum LIS\n./gen -n 6000 -treeType chain -rType maxLIS\n./gen -n 6000 -treeType star -rType maxLIS\n./gen -n 6000 -treeType binary -rType maxLIS\n./gen -n 6000 -treeType random -rType maxLIS\n\n# Edge cases with minimum LIS (maximum concerts is 1)\n./gen -n 6000 -treeType chain -rType minLIS\n./gen -n 6000 -treeType star -rType minLIS\n./gen -n 6000 -treeType binary -rType minLIS\n./gen -n 6000 -treeType random -rType minLIS\n\n# Cases with all ri equal to 1\n./gen -n 6000 -treeType chain -rType equal_one\n./gen -n 6000 -treeType star -rType equal_one\n./gen -n 6000 -treeType binary -rType equal_one\n./gen -n 6000 -treeType random -rType equal_one\n\n# Cases with all ri equal to maximum value\n./gen -n 6000 -treeType chain -rType equal_max\n./gen -n 6000 -treeType star -rType equal_max\n./gen -n 6000 -treeType binary -rType equal_max\n./gen -n 6000 -treeType random -rType equal_max\n\n# Random trees with ri increasing along a random path\n./gen -n 6000 -treeType random -rType path_increasing\n./gen -n 6000 -treeType random -rType path_increasing\n./gen -n 6000 -treeType random -rType path_increasing\n\n# Random test cases\n./gen -n 6000 -treeType random -rType random\n./gen -n 6000 -treeType random -rType random\n./gen -n 6000 -treeType random -rType random\n./gen -n 6000 -treeType random -rType random\n\n# Test cases with decreasing ri values\n./gen -n 6000 -treeType chain -rType decreasing\n./gen -n 6000 -treeType star -rType decreasing\n./gen -n 6000 -treeType binary -rType decreasing\n\n# Small random test cases\n./gen -n 10 -treeType random -rType random\n./gen -n 50 -treeType random -rType random\n./gen -n 100 -treeType random -rType random\n\n# Test cases with a mixture of increasing and decreasing ri values\n./gen -n 6000 -treeType random -rType increasing\n./gen -n 6000 -treeType random -rType decreasing\n\n# Test cases with ri values all random but with potential for large LIS\n./gen -n 6000 -treeType random -rType random\n\n# Test cases with special trees\n./gen -n 6000 -treeType star -rType increasing\n./gen -n 6000 -treeType star -rType decreasing\n\n# Additional test cases\n./gen -n 5999 -treeType binary -rType random\n./gen -n 6000 -treeType chain -rType equal\n./gen -n 6000 -treeType star -rType equal\n\n# Short chain with random ri\n./gen -n 1000 -treeType chain -rType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:14.247531",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "491/A",
      "title": "A. Up the hill",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line there is an integer non-negative number A denoting the number of days of climbing up the hill. Second line contains an integer non-negative number B — the number of days of walking down the hill (A + B + 1 = N, 1 ≤ N ≤ 100 000).",
      "output_spec": "OutputOutput N space-separated distinct integers from 1 to N inclusive, denoting possible heights of the stops in order of visiting.",
      "sample_tests": "ExamplesInputCopy01OutputCopy2 1 InputCopy21OutputCopy1 3 4 2",
      "description": "A. Up the hill\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputIn the first line there is an integer non-negative number A denoting the number of days of climbing up the hill. Second line contains an integer non-negative number B — the number of days of walking down the hill (A + B + 1 = N, 1 ≤ N ≤ 100 000).\n\nOutputOutput N space-separated distinct integers from 1 to N inclusive, denoting possible heights of the stops in order of visiting.\n\nInputCopy01OutputCopy2 1 InputCopy21OutputCopy1 3 4 2\n\nInputCopy01\n\nOutputCopy2 1\n\nInputCopy21\n\nOutputCopy1 3 4 2",
      "solutions": [
        {
          "title": "Testing Round #11 - Codeforces",
          "content": "It is not visible from user point of view, but we've introduced some changes in Codeforces backend to improve system performance. And now we want to test the system before Round 278.I invite you to take part in Testing Round 11. It will start soon, on November, 20 21:30:00 (UTC). It will be unofficial unrated round.Pretests are unusually weak to trigger more hack.If you see any unexpected behavior or bugs, please inform us via comments.Thanks.UPD.: Thank you for participation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14776",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 481
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(0, 99999, \"A\");\n    inf.readEoln();\n\n    int B = inf.readInt(0, 99999, \"B\");\n    inf.readEoln();\n\n    int N = A + B + 1;\n    ensuref(1 <= N && N <= 100000, \"N = A + B + 1 = %d is out of bounds (1 <= N <= 100000)\", N);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(0, 99999, \"A\");\n    inf.readEoln();\n\n    int B = inf.readInt(0, 99999, \"B\");\n    inf.readEoln();\n\n    int N = A + B + 1;\n    ensuref(1 <= N && N <= 100000, \"N = A + B + 1 = %d is out of bounds (1 <= N <= 100000)\", N);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(0, 99999, \"A\");\n    inf.readEoln();\n\n    int B = inf.readInt(0, 99999, \"B\");\n    inf.readEoln();\n\n    int N = A + B + 1;\n    ensuref(1 <= N && N <= 100000, \"N = A + B + 1 = %d is out of bounds (1 <= N <= 100000)\", N);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n    int A = inf.readInt();\n    int B = inf.readInt();\n    int N = A + B + 1;\n    vector<int> heights = ouf.readInts(N, 1, N, \"heights\");\n    set<int> unique_heights(heights.begin(), heights.end());\n    if ((int)unique_heights.size() != N) {\n        quitf(_wa, \"Heights are not distinct\");\n    }\n    int uphill = 0, downhill = 0;\n    for (int i = 1; i < N; ++i) {\n        if (heights[i] > heights[i-1]) {\n            ++uphill;\n        } else if (heights[i] < heights[i-1]) {\n            ++downhill;\n        }\n    }\n    if (uphill != A) {\n        quitf(_wa, \"Expected %d uphill days, but found %d\", A, uphill);\n    }\n    if (downhill != B) {\n        quitf(_wa, \"Expected %d downhill days, but found %d\", B, downhill);\n    }\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int A, B;\n\n    if (type == \"maxup\") {\n        A = n - 1;\n        B = 0;\n    } else if (type == \"maxdown\") {\n        A = 0;\n        B = n - 1;\n    } else if (type == \"random\") {\n        A = rnd.next(0, n - 1);\n        B = n - 1 - A;\n    } else if (type == \"halfup\") {\n        A = (n - 1) / 2;\n        B = n - 1 - A;\n    } else if (type == \"halfdown\") {\n        B = (n - 1) / 2;\n        A = n - 1 - B;\n    } else if (type == \"alternating\") {\n        A = B = (n - 1) / 2;\n        if ((n - 1) % 2 != 0) {\n            if (rnd.next(0, 1)) {\n                A++;\n            } else {\n                B++;\n            }\n        }\n    } else if (type == \"equalAandB\") {\n        if ((n - 1) % 2 == 0) {\n            A = B = (n - 1) / 2;\n        } else {\n            A = (n - 1) / 2;\n            B = n - 1 - A;\n        }\n    } else {\n        // Default to random\n        A = rnd.next(0, n - 1);\n        B = n - 1 - A;\n    }\n\n    cout << A << '\\n';\n    cout << B << '\\n';\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int A, B;\n\n    if (type == \"maxup\") {\n        A = n - 1;\n        B = 0;\n    } else if (type == \"maxdown\") {\n        A = 0;\n        B = n - 1;\n    } else if (type == \"random\") {\n        A = rnd.next(0, n - 1);\n        B = n - 1 - A;\n    } else if (type == \"halfup\") {\n        A = (n - 1) / 2;\n        B = n - 1 - A;\n    } else if (type == \"halfdown\") {\n        B = (n - 1) / 2;\n        A = n - 1 - B;\n    } else if (type == \"alternating\") {\n        A = B = (n - 1) / 2;\n        if ((n - 1) % 2 != 0) {\n            if (rnd.next(0, 1)) {\n                A++;\n            } else {\n                B++;\n            }\n        }\n    } else if (type == \"equalAandB\") {\n        if ((n - 1) % 2 == 0) {\n            A = B = (n - 1) / 2;\n        } else {\n            A = (n - 1) / 2;\n            B = n - 1 - A;\n        }\n    } else {\n        // Default to random\n        A = rnd.next(0, n - 1);\n        B = n - 1 - A;\n    }\n\n    cout << A << '\\n';\n    cout << B << '\\n';\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type maxup\n./gen -n 2 -type maxdown\n./gen -n 2 -type equalAandB\n./gen -n 2 -type random\n\n./gen -n 3 -type maxup\n./gen -n 3 -type maxdown\n./gen -n 3 -type alternating\n\n./gen -n 10 -type maxup\n./gen -n 10 -type maxdown\n./gen -n 10 -type halfup\n./gen -n 10 -type halfdown\n./gen -n 10 -type equalAandB\n./gen -n 10 -type random\n\n./gen -n 100 -type maxup\n./gen -n 100 -type maxdown\n./gen -n 100 -type alternating\n./gen -n 100 -type equalAandB\n./gen -n 100 -type random\n\n./gen -n 1000 -type maxup\n./gen -n 1000 -type maxdown\n./gen -n 1000 -type halfup\n./gen -n 1000 -type halfdown\n./gen -n 1000 -type alternating\n./gen -n 1000 -type equalAandB\n./gen -n 1000 -type random\n\n./gen -n 100000 -type maxup\n./gen -n 100000 -type maxdown\n./gen -n 100000 -type halfup\n./gen -n 100000 -type halfdown\n./gen -n 100000 -type alternating\n./gen -n 100000 -type equalAandB\n./gen -n 100000 -type random\n\n./gen -n 50000 -type random\n./gen -n 75000 -type random\n./gen -n 99999 -type random\n./gen -n 99999 -type equalAandB\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:16.181376",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "491/B",
      "title": "B. Отель в Нью-Йорке",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных содержится два числа N и M — размеры города (1 ≤ N, M ≤ 109). В следующей строке содержится единственное число C — количество отелей, в которых расположились друзья (1 ≤ C ≤ 105). Далее в C строках содержатся описания отелей, каждый из них задается двумя координатами x и y (1 ≤ x ≤ N, 1 ≤ y ≤ M). В следующей строке содержится одно число H — количество ресторанов (1 ≤ H ≤ 105). В следующих строках содержатся описания ресторанов, в том же формате, что и отели.Несколько ресторанов и отелей могут располагаться возле одного и того же перекрестка.",
      "output_spec": "Выходные данныеВ первой строке выходных данных выведите одно число — искомое оптимальное расстояние. В следующей строке выведите номер любого из ресторанов, гарантирующих данное расстояние. Если вариантов ответа несколько, выведите любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 1021 13 321 104 4Выходные данныеСкопировать62",
      "description": "B. Отель в Нью-Йорке\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных содержится два числа N и M — размеры города (1 ≤ N, M ≤ 109). В следующей строке содержится единственное число C — количество отелей, в которых расположились друзья (1 ≤ C ≤ 105). Далее в C строках содержатся описания отелей, каждый из них задается двумя координатами x и y (1 ≤ x ≤ N, 1 ≤ y ≤ M). В следующей строке содержится одно число H — количество ресторанов (1 ≤ H ≤ 105). В следующих строках содержатся описания ресторанов, в том же формате, что и отели.Несколько ресторанов и отелей могут располагаться возле одного и того же перекрестка.\n\nВходные данные\n\nВыходные данныеВ первой строке выходных данных выведите одно число — искомое оптимальное расстояние. В следующей строке выведите номер любого из ресторанов, гарантирующих данное расстояние. Если вариантов ответа несколько, выведите любой.\n\nВыходные данные\n\nВходные данныеСкопировать10 1021 13 321 104 4Выходные данныеСкопировать62\n\nВходные данныеСкопировать10 1021 13 321 104 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать62\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Testing Round #11 - Codeforces",
          "content": "С виду оно не заметно, но за последние дни в недрах бэкэнда Codeforces произошли заметные изменения, призванные улучшить производительность и стабильность. Теперь мы хотим проверить перед предстоящим раундом, что все работает как надо.Приглашаем вас принять участие в Testing Round 11. Старт состоится ночью в 00:30. Раунд будет неофициальным, нерейтинговым.Как обычно претесты будут необычно слабыми, чтобы спровоцировать побольше взломов.Если вы видите какие-то изменения в функциональности, то пишите о них в комментариях.Спасибо.UPD: Спасибо, что приняли участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14776",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 567
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000000, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 1000000000, \"M\");\n    inf.readEoln();\n\n    int C = inf.readInt(1, 100000, \"C\");\n    inf.readEoln();\n\n    for (int i = 0; i < C; ++i) {\n        int x = inf.readInt(1, N, \"x_friend_\" + to_string(i+1));\n        inf.readSpace();\n        int y = inf.readInt(1, M, \"y_friend_\" + to_string(i+1));\n        inf.readEoln();\n    }\n\n    int H = inf.readInt(1, 100000, \"H\");\n    inf.readEoln();\n\n    for (int i = 0; i < H; ++i) {\n        int x = inf.readInt(1, N, \"x_restaurant_\" + to_string(i+1));\n        inf.readSpace();\n        int y = inf.readInt(1, M, \"y_restaurant_\" + to_string(i+1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000000, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 1000000000, \"M\");\n    inf.readEoln();\n\n    int C = inf.readInt(1, 100000, \"C\");\n    inf.readEoln();\n\n    for (int i = 0; i < C; ++i) {\n        int x = inf.readInt(1, N, \"x_friend_\" + to_string(i+1));\n        inf.readSpace();\n        int y = inf.readInt(1, M, \"y_friend_\" + to_string(i+1));\n        inf.readEoln();\n    }\n\n    int H = inf.readInt(1, 100000, \"H\");\n    inf.readEoln();\n\n    for (int i = 0; i < H; ++i) {\n        int x = inf.readInt(1, N, \"x_restaurant_\" + to_string(i+1));\n        inf.readSpace();\n        int y = inf.readInt(1, M, \"y_restaurant_\" + to_string(i+1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000000, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 1000000000, \"M\");\n    inf.readEoln();\n\n    int C = inf.readInt(1, 100000, \"C\");\n    inf.readEoln();\n\n    for (int i = 0; i < C; ++i) {\n        int x = inf.readInt(1, N, \"x_friend_\" + to_string(i+1));\n        inf.readSpace();\n        int y = inf.readInt(1, M, \"y_friend_\" + to_string(i+1));\n        inf.readEoln();\n    }\n\n    int H = inf.readInt(1, 100000, \"H\");\n    inf.readEoln();\n\n    for (int i = 0; i < H; ++i) {\n        int x = inf.readInt(1, N, \"x_restaurant_\" + to_string(i+1));\n        inf.readSpace();\n        int y = inf.readInt(1, M, \"y_restaurant_\" + to_string(i+1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int N = inf.readInt(1, (int)1e9, \"N\");\n    int M = inf.readInt(1, (int)1e9, \"M\");\n    int C = inf.readInt(1, (int)1e5, \"C\");\n    vector<pair<int, int>> hotels(C);\n    for (int i = 0; i < C; i++) {\n        int x = inf.readInt(1, N, format(\"hotel[%d].x\", i + 1).c_str());\n        int y = inf.readInt(1, M, format(\"hotel[%d].y\", i + 1).c_str());\n        hotels[i] = make_pair(x, y);\n    }\n\n    int H = inf.readInt(1, (int)1e5, \"H\");\n    vector<pair<int, int>> restaurants(H);\n    for (int i = 0; i < H; i++) {\n        int x = inf.readInt(1, N, format(\"restaurant[%d].x\", i + 1).c_str());\n        int y = inf.readInt(1, M, format(\"restaurant[%d].y\", i + 1).c_str());\n        restaurants[i] = make_pair(x, y);\n    }\n\n    // Compute the minimal maximum distance\n    vector<int> maxDistances(H, 0);\n    int minimalDistance = INT_MAX;\n\n    for (int i = 0; i < H; i++) {\n        int rx = restaurants[i].first;\n        int ry = restaurants[i].second;\n        int maxDist = 0;\n        for (int j = 0; j < C; j++) {\n            int hx = hotels[j].first;\n            int hy = hotels[j].second;\n            int dist = abs(rx - hx) + abs(ry - hy);\n            if (dist > maxDist) {\n                maxDist = dist;\n            }\n        }\n        maxDistances[i] = maxDist;\n        if (maxDist < minimalDistance) {\n            minimalDistance = maxDist;\n        }\n    }\n\n    // Collect all restaurant indices that achieve minimalDistance\n    vector<int> optimalRestaurantIndices;\n    for (int i = 0; i < H; i++) {\n        if (maxDistances[i] == minimalDistance) {\n            optimalRestaurantIndices.push_back(i + 1); // Indices are from 1 to H\n        }\n    }\n\n    // Read the participant's output\n    int pansDistance = ouf.readInt(0, (int)2e9, \"optimal distance\");\n    int pansIndex = ouf.readInt(1, H, \"restaurant index\");\n\n    // Check that pansDistance equals minimalDistance\n    if (pansDistance != minimalDistance) {\n        quitf(_wa, \"Incorrect optimal distance: expected %d, found %d\", minimalDistance, pansDistance);\n    }\n\n    // Check that pansIndex is in optimalRestaurantIndices\n    if (find(optimalRestaurantIndices.begin(), optimalRestaurantIndices.end(), pansIndex) == optimalRestaurantIndices.end()) {\n        // Participant provided a restaurant that doesn't achieve the minimal maximum distance\n        quitf(_wa, \"Restaurant %d does not achieve the minimal maximum distance %d\", pansIndex, minimalDistance);\n    }\n\n    // Passed all checks\n    quitf(_ok, \"Correct optimal distance %d and restaurant index %d\", pansDistance, pansIndex);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int N = opt<int>(\"N\");\n    int M = opt<int>(\"M\");\n    int C = opt<int>(\"C\");\n    int H = opt<int>(\"H\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> hotels(C), restaurants(H);\n\n    if (type == \"random\") {\n        // Randomly generate coordinates within [1, N] x [1, M]\n        for (int i = 0; i < C; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, M);\n            hotels[i] = {x, y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, M);\n            restaurants[i] = {x, y};\n        }\n    } else if (type == \"maxdist\") {\n        // Place all hotels at (1,1) and all restaurants at (N,M)\n        for (int i = 0; i < C; ++i) hotels[i] = {1,1};\n        for (int i = 0; i < H; ++i) restaurants[i] = {N,M};\n    } else if (type == \"samelocation\") {\n        // All hotels and all restaurants at the same location\n        int x = rnd.next(1,N);\n        int y = rnd.next(1,M);\n        for (int i = 0; i < C; ++i) hotels[i] = {x,y};\n        for (int i = 0; i < H; ++i) restaurants[i] = {x,y};\n    } else if (type == \"edgealigned\") {\n        // Hotels along one edge, restaurants along opposite edge\n        for (int i = 0; i < C; ++i) {\n            int x = 1;\n            int y = rnd.next(1, M);\n            hotels[i] = {x, y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x = N;\n            int y = rnd.next(1, M);\n            restaurants[i] = {x, y};\n        }\n    } else if (type == \"linehotels\") {\n        // Hotels along a random line\n        int x = rnd.next(1,N);\n        for (int i = 0; i < C; ++i) {\n            int y = rnd.next(1, M);\n            hotels[i] = {x, y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x_r = rnd.next(1,N);\n            int y_r = rnd.next(1,M);\n            restaurants[i] = {x_r, y_r};\n        }\n    } else if (type == \"cornercases\") {\n        // Hotels and restaurants located at all four corners\n        vector<pair<int,int>> corners = {{1,1}, {1,M}, {N,1}, {N,M}};\n        hotels.assign(corners.begin(), corners.end());\n        while ((int)hotels.size() < C) {\n            int x = rnd.next(1,N);\n            int y = rnd.next(1,M);\n            hotels.push_back({x, y});\n        }\n        restaurants.assign(corners.begin(), corners.end());\n        while ((int)restaurants.size() < H) {\n            int x = rnd.next(1,N);\n            int y = rnd.next(1,M);\n            restaurants.push_back({x, y});\n        }\n    } else if (type == \"n1orm1\") {\n        // N or M is 1\n        for (int i = 0; i < C; ++i) {\n            int x = (N == 1) ? 1 : rnd.next(1,N);\n            int y = (M == 1) ? 1 : rnd.next(1,M);\n            hotels[i] = {x,y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x = (N == 1) ? 1 : rnd.next(1,N);\n            int y = (M == 1) ? 1 : rnd.next(1,M);\n            restaurants[i] = {x,y};\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < C; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, M);\n            hotels[i] = {x, y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, M);\n            restaurants[i] = {x, y};\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", N, M);\n    printf(\"%d\\n\", C);\n    for (int i = 0; i < C; ++i) {\n        printf(\"%d %d\\n\", hotels[i].first, hotels[i].second);\n    }\n    printf(\"%d\\n\", H);\n    for (int i = 0; i < H; ++i) {\n        printf(\"%d %d\\n\", restaurants[i].first, restaurants[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int N = opt<int>(\"N\");\n    int M = opt<int>(\"M\");\n    int C = opt<int>(\"C\");\n    int H = opt<int>(\"H\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> hotels(C), restaurants(H);\n\n    if (type == \"random\") {\n        // Randomly generate coordinates within [1, N] x [1, M]\n        for (int i = 0; i < C; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, M);\n            hotels[i] = {x, y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, M);\n            restaurants[i] = {x, y};\n        }\n    } else if (type == \"maxdist\") {\n        // Place all hotels at (1,1) and all restaurants at (N,M)\n        for (int i = 0; i < C; ++i) hotels[i] = {1,1};\n        for (int i = 0; i < H; ++i) restaurants[i] = {N,M};\n    } else if (type == \"samelocation\") {\n        // All hotels and all restaurants at the same location\n        int x = rnd.next(1,N);\n        int y = rnd.next(1,M);\n        for (int i = 0; i < C; ++i) hotels[i] = {x,y};\n        for (int i = 0; i < H; ++i) restaurants[i] = {x,y};\n    } else if (type == \"edgealigned\") {\n        // Hotels along one edge, restaurants along opposite edge\n        for (int i = 0; i < C; ++i) {\n            int x = 1;\n            int y = rnd.next(1, M);\n            hotels[i] = {x, y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x = N;\n            int y = rnd.next(1, M);\n            restaurants[i] = {x, y};\n        }\n    } else if (type == \"linehotels\") {\n        // Hotels along a random line\n        int x = rnd.next(1,N);\n        for (int i = 0; i < C; ++i) {\n            int y = rnd.next(1, M);\n            hotels[i] = {x, y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x_r = rnd.next(1,N);\n            int y_r = rnd.next(1,M);\n            restaurants[i] = {x_r, y_r};\n        }\n    } else if (type == \"cornercases\") {\n        // Hotels and restaurants located at all four corners\n        vector<pair<int,int>> corners = {{1,1}, {1,M}, {N,1}, {N,M}};\n        hotels.assign(corners.begin(), corners.end());\n        while ((int)hotels.size() < C) {\n            int x = rnd.next(1,N);\n            int y = rnd.next(1,M);\n            hotels.push_back({x, y});\n        }\n        restaurants.assign(corners.begin(), corners.end());\n        while ((int)restaurants.size() < H) {\n            int x = rnd.next(1,N);\n            int y = rnd.next(1,M);\n            restaurants.push_back({x, y});\n        }\n    } else if (type == \"n1orm1\") {\n        // N or M is 1\n        for (int i = 0; i < C; ++i) {\n            int x = (N == 1) ? 1 : rnd.next(1,N);\n            int y = (M == 1) ? 1 : rnd.next(1,M);\n            hotels[i] = {x,y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x = (N == 1) ? 1 : rnd.next(1,N);\n            int y = (M == 1) ? 1 : rnd.next(1,M);\n            restaurants[i] = {x,y};\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < C; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, M);\n            hotels[i] = {x, y};\n        }\n        for (int i = 0; i < H; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, M);\n            restaurants[i] = {x, y};\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", N, M);\n    printf(\"%d\\n\", C);\n    for (int i = 0; i < C; ++i) {\n        printf(\"%d %d\\n\", hotels[i].first, hotels[i].second);\n    }\n    printf(\"%d\\n\", H);\n    for (int i = 0; i < H; ++i) {\n        printf(\"%d %d\\n\", restaurants[i].first, restaurants[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -N 1 -M 1 -C 1 -H 1 -type samelocation\n./gen -N 1000000000 -M 1000000000 -C 100000 -H 100000 -type random\n\n./gen -N 1 -M 1 -C 1 -H 1 -type random\n./gen -N 1000000000 -M 1000000000 -C 1 -H 1 -type random\n\n./gen -N 1 -M 1000000000 -C 100000 -H 100000 -type n1orm1\n./gen -N 1000000000 -M 1 -C 100000 -H 100000 -type n1orm1\n\n./gen -N 1000 -M 1000 -C 100000 -H 100000 -type random\n./gen -N 1000000000 -M 1000000000 -C 100000 -H 100000 -type maxdist\n\n./gen -N 1000000 -M 1000000 -C 1000 -H 1000 -type edgealigned\n\n./gen -N 1000000 -M 1000000 -C 1000 -H 1000 -type linehotels\n\n./gen -N 1000000 -M 1000000 -C 100000 -H 100000 -type cornercases\n\n./gen -N 1000000000 -M 1 -C 50000 -H 50000 -type random\n\n./gen -N 1 -M 1000000000 -C 50000 -H 50000 -type random\n\n./gen -N 1000000000 -M 1000000000 -C 100000 -H 100000 -type samelocation\n\n./gen -N 1000 -M 1000 -C 500 -H 500 -type maxdist\n\n./gen -N 1000000000 -M 1000000000 -C 50000 -H 50000 -type linehotels\n\n./gen -N 1 -M 1 -C 100000 -H 100000 -type random\n\n./gen -N 1000000000 -M 1000000000 -C 1 -H 1 -type maxdist\n\n./gen -N 1000 -M 1000 -C 4 -H 4 -type cornercases\n\n./gen -N 1000 -M 1000 -C 1000 -H 1000 -type random\n\n./gen -N 1000000 -M 1000000 -C 1000 -H 1000 -type maxdist\n\n./gen -N 10 -M 10 -C 10 -H 10 -type random\n\n./gen -N 1000000 -M 10 -C 1000 -H 1000 -type random\n./gen -N 10 -M 1000000 -C 1000 -H 1000 -type random\n\n./gen -N 100 -M 100 -C 100 -H 100 -type random\n\n./gen -N 1000000 -M 1000000 -C 50000 -H 50000 -type samelocation\n\n./gen -N 1000000000 -M 1000000000 -C 100000 -H 100000 -type maxdist\n\n./gen -N 1000000000 -M 1000000000 -C 100000 -H 100000 -type random\n\n./gen -N 1000000000 -M 1000000000 -C 5 -H 5 -type random\n\n./gen -N 500 -M 1000000000 -C 100000 -H 100000 -type random\n./gen -N 1000000000 -M 500 -C 100000 -H 100000 -type random\n\n./gen -N 1000 -M 1000 -C 500 -H 500 -type random\n\n./gen -N 2 -M 2 -C 4 -H 4 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:18.160200",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "491/C",
      "title": "C. Deciphering",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains length of both strings N (1 ≤ N ≤ 2 000 000) and an integer K — number of possible answers for each of the questions (1 ≤ K ≤ 52). Answers to the questions are denoted as Latin letters abcde...xyzABCDE...XYZ in the order. For example for K = 6, possible answers are abcdef and for K = 30 possible answers are abcde...xyzABCD.Second line contains a ciphered message string consisting of Latin letters.Third line contains a correct answers string consisting of Latin letters.",
      "output_spec": "OutputIn the first line output maximum possible number of correct Sasha's answers.In the second line output cipher rule as the string of length K where for each letter from the students' cipher (starting from 'a' as mentioned above) there is specified which answer does it correspond to.If there are several ways to produce maximum answer, output any of them.",
      "sample_tests": "ExamplesInputCopy10 2aaabbbaaabbbbbabbbbbOutputCopy7baInputCopy10 2aaaaaaabbbbbbbaaabbbOutputCopy6abInputCopy9 4dacbdacbdacbdacbdaOutputCopy9cdba",
      "description": "C. Deciphering\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst line contains length of both strings N (1 ≤ N ≤ 2 000 000) and an integer K — number of possible answers for each of the questions (1 ≤ K ≤ 52). Answers to the questions are denoted as Latin letters abcde...xyzABCDE...XYZ in the order. For example for K = 6, possible answers are abcdef and for K = 30 possible answers are abcde...xyzABCD.Second line contains a ciphered message string consisting of Latin letters.Third line contains a correct answers string consisting of Latin letters.\n\nOutputIn the first line output maximum possible number of correct Sasha's answers.In the second line output cipher rule as the string of length K where for each letter from the students' cipher (starting from 'a' as mentioned above) there is specified which answer does it correspond to.If there are several ways to produce maximum answer, output any of them.\n\nInputCopy10 2aaabbbaaabbbbbabbbbbOutputCopy7baInputCopy10 2aaaaaaabbbbbbbaaabbbOutputCopy6abInputCopy9 4dacbdacbdacbdacbdaOutputCopy9cdba\n\nInputCopy10 2aaabbbaaabbbbbabbbbb\n\nOutputCopy7ba\n\nInputCopy10 2aaaaaaabbbbbbbaaabbb\n\nOutputCopy6ab\n\nInputCopy9 4dacbdacbdacbdacbda\n\nOutputCopy9cdba",
      "solutions": [
        {
          "title": "Testing Round #11 - Codeforces",
          "content": "It is not visible from user point of view, but we've introduced some changes in Codeforces backend to improve system performance. And now we want to test the system before Round 278.I invite you to take part in Testing Round 11. It will start soon, on November, 20 21:30:00 (UTC). It will be unofficial unrated round.Pretests are unusually weak to trigger more hack.If you see any unexpected behavior or bugs, please inform us via comments.Thanks.UPD.: Thank you for participation.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14776",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 481
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 2000000, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, 52, \"K\");\n    inf.readEoln();\n\n    string ciphered_message = inf.readLine();\n    ensuref(int(ciphered_message.length()) == N, \"The ciphered message length should be %d, but it is %d\", N, int(ciphered_message.length()));\n    for(int i = 0; i < N; ++i) {\n        char c = ciphered_message[i];\n        ensuref((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'), \"The ciphered message contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    string possible_answers = \"\";\n    for(char c = 'a'; c <= 'z'; ++c) possible_answers += c;\n    for(char c = 'A'; c <= 'Z'; ++c) possible_answers += c;\n    string allowed_answers = possible_answers.substr(0, K);\n    set<char> allowed_answers_set(allowed_answers.begin(), allowed_answers.end());\n\n    string correct_answers = inf.readLine();\n    ensuref(int(correct_answers.length()) == N, \"The correct answers length should be %d, but it is %d\", N, int(correct_answers.length()));\n    for(int i = 0; i < N; ++i) {\n        char c = correct_answers[i];\n        ensuref((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'), \"The correct answers contain invalid character '%c' at position %d\", c, i+1);\n        ensuref(allowed_answers_set.count(c), \"The correct answer at position %d is '%c', which is not among the first %d allowed answers\", i+1, c, K);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 2000000, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, 52, \"K\");\n    inf.readEoln();\n\n    string ciphered_message = inf.readLine();\n    ensuref(int(ciphered_message.length()) == N, \"The ciphered message length should be %d, but it is %d\", N, int(ciphered_message.length()));\n    for(int i = 0; i < N; ++i) {\n        char c = ciphered_message[i];\n        ensuref((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'), \"The ciphered message contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    string possible_answers = \"\";\n    for(char c = 'a'; c <= 'z'; ++c) possible_answers += c;\n    for(char c = 'A'; c <= 'Z'; ++c) possible_answers += c;\n    string allowed_answers = possible_answers.substr(0, K);\n    set<char> allowed_answers_set(allowed_answers.begin(), allowed_answers.end());\n\n    string correct_answers = inf.readLine();\n    ensuref(int(correct_answers.length()) == N, \"The correct answers length should be %d, but it is %d\", N, int(correct_answers.length()));\n    for(int i = 0; i < N; ++i) {\n        char c = correct_answers[i];\n        ensuref((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'), \"The correct answers contain invalid character '%c' at position %d\", c, i+1);\n        ensuref(allowed_answers_set.count(c), \"The correct answer at position %d is '%c', which is not among the first %d allowed answers\", i+1, c, K);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 2000000, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, 52, \"K\");\n    inf.readEoln();\n\n    string ciphered_message = inf.readLine();\n    ensuref(int(ciphered_message.length()) == N, \"The ciphered message length should be %d, but it is %d\", N, int(ciphered_message.length()));\n    for(int i = 0; i < N; ++i) {\n        char c = ciphered_message[i];\n        ensuref((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'), \"The ciphered message contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    string possible_answers = \"\";\n    for(char c = 'a'; c <= 'z'; ++c) possible_answers += c;\n    for(char c = 'A'; c <= 'Z'; ++c) possible_answers += c;\n    string allowed_answers = possible_answers.substr(0, K);\n    set<char> allowed_answers_set(allowed_answers.begin(), allowed_answers.end());\n\n    string correct_answers = inf.readLine();\n    ensuref(int(correct_answers.length()) == N, \"The correct answers length should be %d, but it is %d\", N, int(correct_answers.length()));\n    for(int i = 0; i < N; ++i) {\n        char c = correct_answers[i];\n        ensuref((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'), \"The correct answers contain invalid character '%c' at position %d\", c, i+1);\n        ensuref(allowed_answers_set.count(c), \"The correct answer at position %d is '%c', which is not among the first %d allowed answers\", i+1, c, K);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from inf\n    int N = inf.readInt();\n    int K = inf.readInt();\n\n    // Prepare the list of possible letters\n    string letters;\n    for (char c = 'a'; c <= 'z' && letters.size() < K; ++c)\n        letters += c;\n    for (char c = 'A'; c <= 'Z' && letters.size() < K; ++c)\n        letters += c;\n    // Now letters is a string of length K\n\n    // Map from letters to indices\n    map<char, int> letter_index;\n    for (int i = 0; i < K; ++i) {\n        letter_index[letters[i]] = i;\n    }\n\n    // Read ciphered_message and correct_answers\n    string ciphered_message = inf.readToken();\n    if (int(ciphered_message.size()) != N)\n        quitf(_fail, \"Input length mismatch: ciphered_message length %d != N\", int(ciphered_message.size()));\n    string correct_answers = inf.readToken();\n    if (int(correct_answers.size()) != N)\n        quitf(_fail, \"Input length mismatch: correct_answers length %d != N\", int(correct_answers.size()));\n\n    // From participant's output (ouf), read M_p and cipher_rule\n    int M_p = ouf.readInt(0, N, \"number of correct answers\");\n    string cipher_rule = ouf.readToken();\n    if (int(cipher_rule.size()) != K)\n        quitf(_wa, \"Cipher rule length is incorrect: expected %d, found %d\", K, int(cipher_rule.size()));\n\n    // Validate that cipher_rule is a valid mapping\n    // Each letter in cipher_rule should be among possible letters\n    // Each letter should appear only once (bijection)\n    set<char> cipher_rule_letters;\n    for (int i = 0; i < K; ++i) {\n        char c = cipher_rule[i];\n        if (letter_index.find(c) == letter_index.end())\n            quitf(_wa, \"Invalid letter '%c' in cipher_rule at position %d\", c, i+1);\n        if (cipher_rule_letters.count(c))\n            quitf(_wa, \"Duplicate letter '%c' in cipher_rule\", c);\n        cipher_rule_letters.insert(c);\n    }\n\n    // Now create the mapping from cipher letters to original letters\n    map<char, char> mapping; // maps ciphered letter to original letter\n    for (int i = 0; i < K; ++i) {\n        mapping[letters[i]] = cipher_rule[i];\n    }\n\n    // Now apply the mapping to ciphered_message\n    string deciphered_message(N, ' ');\n    for (int i = 0; i < N; ++i) {\n        char c = ciphered_message[i];\n        if (mapping.find(c) == mapping.end())\n            quitf(_wa, \"Ciphered message contains invalid letter '%c' at position %d\", c, i+1);\n        deciphered_message[i] = mapping[c];\n    }\n\n    // Now compare deciphered_message to correct_answers\n    int M_p_actual = 0;\n    for (int i = 0; i < N; ++i) {\n        if (deciphered_message[i] == correct_answers[i])\n            ++M_p_actual;\n    }\n\n    if (M_p_actual != M_p)\n        quitf(_wa, \"Mismatch in number of correct answers: expected %d, found %d\", M_p_actual, M_p);\n\n    // Now read jury's answer (ans)\n    int M_j = ans.readInt(0, N, \"maximum number of correct answers from jury\");\n\n    if (M_p < M_j)\n        quitf(_wa, \"Participant's number of correct answers %d is less than maximum possible %d\", M_p, M_j);\n    else if (M_p == M_j)\n        quitf(_ok, \"Correct, maximum number of correct answers is %d\", M_p);\n    else // M_p > M_j\n        quitf(_fail, \"Participant's number of correct answers %d is greater than maximum possible %d\", M_p, M_j);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const string letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    assert(1 <= k && k <= 52);\n\n    string possibleLetters = letters.substr(0, k);\n\n    string cipheredMessage(n, ' ');\n    string correctAnswers(n, ' ');\n\n    if (type == \"all_correct\") {\n        // Generate ciphered message and correct answers that are the same\n        for (int i = 0; i < n; ++i) {\n            char c = possibleLetters[rnd.next(0, k - 1)];\n            cipheredMessage[i] = c;\n            correctAnswers[i] = c;\n        }\n    } else if (type == \"none_correct\") {\n        // Generate ciphered message and correct answers that cannot be matched for maximum correctness\n        if (k == 1) {\n            // Special case when k == 1\n            for (int i = 0; i < n; ++i) {\n                cipheredMessage[i] = possibleLetters[0];\n                correctAnswers[i] = possibleLetters[0];\n            }\n        } else {\n            // Map each ciphered letter to a different letter in correctAnswers\n            vector<char> cipherLetters(k);\n            vector<char> answerLetters(k);\n            for (int i = 0; i < k; ++i) {\n                cipherLetters[i] = possibleLetters[i];\n                answerLetters[i] = possibleLetters[(i + 1) % k];\n            }\n            for (int i = 0; i < n; ++i) {\n                cipheredMessage[i] = cipherLetters[i % k];\n                correctAnswers[i] = answerLetters[i % k];\n            }\n        }\n    } else if (type == \"all_same_cipher\") {\n        // Ciphered message is composed of the same letter\n        char cipherChar = possibleLetters[0];\n        cipheredMessage = string(n, cipherChar);\n        for (int i = 0; i < n; ++i) {\n            correctAnswers[i] = possibleLetters[rnd.next(0, k - 1)];\n        }\n    } else if (type == \"alternating\") {\n        // Ciphered message alternates between two letters\n        if (k < 2) {\n            cerr << \"Error: 'alternating' type requires k >= 2\" << endl;\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            cipheredMessage[i] = possibleLetters[i % 2];\n            correctAnswers[i] = possibleLetters[rnd.next(0, k - 1)];\n        }\n    } else if (type == \"case_sensitivity\") {\n        // Test case sensitivity between upper and lower case letters\n        if (k < 52) {\n            cerr << \"Error: 'case_sensitivity' type requires k = 52\" << endl;\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            char c = letters[rnd.next(0, 51)];\n            cipheredMessage[i] = c;\n            if (islower(c))\n                correctAnswers[i] = toupper(c);\n            else\n                correctAnswers[i] = tolower(c);\n        }\n    } else if (type == \"one_letter_off\") {\n        // Ciphered message matches correct answers except for one position\n        for (int i = 0; i < n; ++i) {\n            char c = possibleLetters[rnd.next(0, k - 1)];\n            cipheredMessage[i] = c;\n            correctAnswers[i] = c;\n        }\n        if (n > 0) {\n            int pos = rnd.next(0, n - 1);\n            char original = correctAnswers[pos];\n            char newChar = original;\n            while (newChar == original) {\n                newChar = possibleLetters[rnd.next(0, k - 1)];\n            }\n            correctAnswers[pos] = newChar;\n        }\n    } else {\n        // Random case\n        for (int i = 0; i < n; ++i) {\n            cipheredMessage[i] = possibleLetters[rnd.next(0, k - 1)];\n            correctAnswers[i] = possibleLetters[rnd.next(0, k - 1)];\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", cipheredMessage.c_str());\n    printf(\"%s\\n\", correctAnswers.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const string letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    assert(1 <= k && k <= 52);\n\n    string possibleLetters = letters.substr(0, k);\n\n    string cipheredMessage(n, ' ');\n    string correctAnswers(n, ' ');\n\n    if (type == \"all_correct\") {\n        // Generate ciphered message and correct answers that are the same\n        for (int i = 0; i < n; ++i) {\n            char c = possibleLetters[rnd.next(0, k - 1)];\n            cipheredMessage[i] = c;\n            correctAnswers[i] = c;\n        }\n    } else if (type == \"none_correct\") {\n        // Generate ciphered message and correct answers that cannot be matched for maximum correctness\n        if (k == 1) {\n            // Special case when k == 1\n            for (int i = 0; i < n; ++i) {\n                cipheredMessage[i] = possibleLetters[0];\n                correctAnswers[i] = possibleLetters[0];\n            }\n        } else {\n            // Map each ciphered letter to a different letter in correctAnswers\n            vector<char> cipherLetters(k);\n            vector<char> answerLetters(k);\n            for (int i = 0; i < k; ++i) {\n                cipherLetters[i] = possibleLetters[i];\n                answerLetters[i] = possibleLetters[(i + 1) % k];\n            }\n            for (int i = 0; i < n; ++i) {\n                cipheredMessage[i] = cipherLetters[i % k];\n                correctAnswers[i] = answerLetters[i % k];\n            }\n        }\n    } else if (type == \"all_same_cipher\") {\n        // Ciphered message is composed of the same letter\n        char cipherChar = possibleLetters[0];\n        cipheredMessage = string(n, cipherChar);\n        for (int i = 0; i < n; ++i) {\n            correctAnswers[i] = possibleLetters[rnd.next(0, k - 1)];\n        }\n    } else if (type == \"alternating\") {\n        // Ciphered message alternates between two letters\n        if (k < 2) {\n            cerr << \"Error: 'alternating' type requires k >= 2\" << endl;\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            cipheredMessage[i] = possibleLetters[i % 2];\n            correctAnswers[i] = possibleLetters[rnd.next(0, k - 1)];\n        }\n    } else if (type == \"case_sensitivity\") {\n        // Test case sensitivity between upper and lower case letters\n        if (k < 52) {\n            cerr << \"Error: 'case_sensitivity' type requires k = 52\" << endl;\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            char c = letters[rnd.next(0, 51)];\n            cipheredMessage[i] = c;\n            if (islower(c))\n                correctAnswers[i] = toupper(c);\n            else\n                correctAnswers[i] = tolower(c);\n        }\n    } else if (type == \"one_letter_off\") {\n        // Ciphered message matches correct answers except for one position\n        for (int i = 0; i < n; ++i) {\n            char c = possibleLetters[rnd.next(0, k - 1)];\n            cipheredMessage[i] = c;\n            correctAnswers[i] = c;\n        }\n        if (n > 0) {\n            int pos = rnd.next(0, n - 1);\n            char original = correctAnswers[pos];\n            char newChar = original;\n            while (newChar == original) {\n                newChar = possibleLetters[rnd.next(0, k - 1)];\n            }\n            correctAnswers[pos] = newChar;\n        }\n    } else {\n        // Random case\n        for (int i = 0; i < n; ++i) {\n            cipheredMessage[i] = possibleLetters[rnd.next(0, k - 1)];\n            correctAnswers[i] = possibleLetters[rnd.next(0, k - 1)];\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", cipheredMessage.c_str());\n    printf(\"%s\\n\", correctAnswers.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type all_correct\n./gen -n 2 -k 2 -type random\n./gen -n 2 -k 2 -type all_correct\n./gen -n 2 -k 2 -type none_correct\n./gen -n 2 -k 2 -type one_letter_off\n./gen -n 10 -k 2 -type random\n./gen -n 10 -k 2 -type all_correct\n./gen -n 10 -k 2 -type none_correct\n./gen -n 10 -k 2 -type alternating\n./gen -n 10 -k 2 -type one_letter_off\n./gen -n 10 -k 2 -type all_same_cipher\n./gen -n 1000 -k 4 -type random\n./gen -n 1000 -k 4 -type all_correct\n./gen -n 1000 -k 4 -type none_correct\n./gen -n 1000 -k 4 -type alternating\n./gen -n 1000 -k 4 -type one_letter_off\n./gen -n 2000000 -k 52 -type random\n./gen -n 2000000 -k 52 -type all_correct\n./gen -n 2000000 -k 52 -type none_correct\n./gen -n 2000000 -k 52 -type case_sensitivity\n./gen -n 2000000 -k 26 -type random\n./gen -n 2000000 -k 26 -type all_correct\n./gen -n 2000000 -k 1 -type random\n./gen -n 2000000 -k 1 -type all_correct\n./gen -n 2000000 -k 2 -type alternating\n./gen -n 2000000 -k 52 -type one_letter_off\n./gen -n 2000000 -k 52 -type all_same_cipher\n./gen -n 1000000 -k 50 -type random\n./gen -n 1000000 -k 50 -type none_correct\n./gen -n 500000 -k 26 -type random\n./gen -n 500000 -k 26 -type one_letter_off\n./gen -n 2 -k 52 -type one_letter_off\n./gen -n 2 -k 4 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:20.087948",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "492/A",
      "title": "A. Vanya and Cubes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 104) — the number of cubes given to Vanya.",
      "output_spec": "OutputPrint the maximum possible height of the pyramid in the single line.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1InputCopy25OutputCopy4",
      "description": "A. Vanya and Cubes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 104) — the number of cubes given to Vanya.\n\nOutputPrint the maximum possible height of the pyramid in the single line.\n\nInputCopy1OutputCopy1InputCopy25OutputCopy4\n\nOutputCopy1\n\nInputCopy25\n\nOutputCopy4\n\nNoteIllustration to the second sample:",
      "solutions": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #280 for participants from the second division will take place on 1 December, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my first round on Codeforces. Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: Scoring is standard — 500-1000-1500-2000-2500.UPD: Thanks to everyone, who participated in the round!Congratulations to the winners:1.alex_y2.wingemerald3.Eric944.Zpw9875.rabbit_TRstandingsUPD: Editorial is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14945",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 807
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces",
          "content": "492A - Vanya and Cubes.In fact need to do what is asked in the statement. We need to find in a cycle the maximum height h, counting, how many blocks must be in i-th row and adding these values to the result. Iterate until the result is not greater than n.Jury's solution: 8924831492B - Vanya and Lanterns.Sort lanterns in non-decreasing order. Then we need to find maximal distance between two neighbour lanterns, let it be maxdist. Also we need to consider street bounds and count distances from outside lanterns to street bounds, it will be (a[0] - 0) and (l - a[n - 1]). The answer will be max(maxdist / 2, max(a[0] - 0, l - a[n - 1]))Time complexity O(nlogn).Jury's solution: 8924823492C - Vanya and Exams.Sort (ai, bi) in non-decreasing order for number of essays bi, after that go from the beginning of this sorted pairs and add greedily the maximal number of points we can, i.e. add value min(avg * n - sum, r - ai), while total amount of points will not be greater, than avg * n.Time complexity O(nlogn).Jury's solution: 8924807492D - Vanya and Computer Game.Let's create vector rez with size x + y, in which there will be a sequence of Vanya's and Vova's strikes for the first second. To do this, we can take 2 variables cntx = cnty = 0. Then while cntx < x and cnty < y, we will check 3 conditions:1) If (cntx + 1) / x > (cnty + 1) / y, then add into the vector word “Vova”, cnty++.2) If (cntx + 1) / x < (cnty + 1) / y, then add into the vector word “Vanya”, cntx++.3) If (cntx + 1) / x = (cnty + 1) / y, then add into the vector word “Both” 2 times, cntx++, cnty++.Then we are able to respond on each query for О(1), the answer will be rez[(ai - 1)mod(x + y)].Time complexity O(x + y).Jury's solution: 8924773492E - Vanya and Field.As long as gcd(dx, n) = gcd(dy, n) = 1, Vanya will do full cycle for n moves. Let's group all possible pathes into n groups, where 1 - th, 2 - nd, ... , n - th path will be started from points (0, 0), (0, 1), …, (0, n - 1). Let's look on first path: (0, 0) - (dx, dy) - ((2 * dx) mod n, (2 * dy) mod n) - ... - (((n - 1) * dx) mod n, ((n - 1) * dy) mod n). As long as gcd(dx, n) = 1, among the first coordinates of points of the path there will be all the numbers from 0 to n - 1. So we can write in the array all relations between the first and second coordinate in points for the path, that starts in the point (0, 0), i.e. y[0] = 0, y[dx] = dy, ... , y[((n - 1) * dx) mod n] = ((n - 1) * dy) mod n. Now we know, that all points with type (i, y[i]), where 0 ≤ i ≤ n - 1, belong to the group with start point (0, 0). In that case, points with type (i, (y[i] + k)modn) belong to the group with start point (0, k). Then we can add every point (xi, yi) to required group k for О(1): (y[xi] + k) mod n = yi, k = (yi - y[xi] + n) mod n. Then we need just to find group with the maximal amount of elements, it will be the answer.Time complexity O(n).Jury's solution: 8924746P.S. Sorry for my bad English, I hope, I will correct this editorial as much, as possible.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 492\\s*A"
          },
          "content_length": 3003
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 1",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 2",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 3",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 4",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 5",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 6",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 7",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 8",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 9",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 10",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 11",
          "code": "cmp = avg*n*1LL",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "if(a.hw == b.hw) return a.score<=b.score;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for(int i=0;i<n;i++){\n    cin>>a[i];\n}\n\nsort(a,a+n);\n\ndouble rez=max(a[0],l-a[n-1]);\n\nfor(int i=1;i<n;i++){\n    rez=max(rez,a[i]-a[i-1]);\n}\ncout<<rez/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize total_cubes array\n    vector<int> total_cubes(1,0); // total_cubes[0]=0\n\n    int n_max = 10000;\n\n    for(int h=1;;h++){\n        int t = h*(h+1)/2;\n        total_cubes.push_back(total_cubes.back() + t);\n        if(total_cubes.back() > n_max)\n            break;\n    }\n    int n;\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = n_max;\n    } else if (type == \"random\") {\n        int min_n = opt<int>(\"min_n\", 1);\n        int max_n = opt<int>(\"max_n\", n_max);\n        n = rnd.next(min_n, max_n);\n    } else if (type == \"by_height\") {\n        int h = opt<int>(\"h\");\n        if (h <= 0 || h >= (int)total_cubes.size()) {\n            cerr << \"Invalid height h\" << endl;\n            return 1;\n        }\n        n = total_cubes[h];\n    } else if (type == \"just_before_height\") {\n        int h = opt<int>(\"h\");\n        if (h <= 0 || h >= (int)total_cubes.size()) {\n            cerr << \"Invalid height h\" << endl;\n            return 1;\n        }\n        n = total_cubes[h] - 1;\n        if (n < 1)\n            n = 1;\n    } else if (type == \"just_after_height\") {\n        int h = opt<int>(\"h\");\n        if (h <= 0 || h >= (int)total_cubes.size()) {\n            cerr << \"Invalid height h\" << endl;\n            return 1;\n        }\n        n = total_cubes[h] + 1;\n        if (n > n_max)\n            n = n_max;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Ensure n within constraints\n    if (n < 1)\n        n = 1;\n    if (n > n_max)\n        n = n_max;\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize total_cubes array\n    vector<int> total_cubes(1,0); // total_cubes[0]=0\n\n    int n_max = 10000;\n\n    for(int h=1;;h++){\n        int t = h*(h+1)/2;\n        total_cubes.push_back(total_cubes.back() + t);\n        if(total_cubes.back() > n_max)\n            break;\n    }\n    int n;\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = n_max;\n    } else if (type == \"random\") {\n        int min_n = opt<int>(\"min_n\", 1);\n        int max_n = opt<int>(\"max_n\", n_max);\n        n = rnd.next(min_n, max_n);\n    } else if (type == \"by_height\") {\n        int h = opt<int>(\"h\");\n        if (h <= 0 || h >= (int)total_cubes.size()) {\n            cerr << \"Invalid height h\" << endl;\n            return 1;\n        }\n        n = total_cubes[h];\n    } else if (type == \"just_before_height\") {\n        int h = opt<int>(\"h\");\n        if (h <= 0 || h >= (int)total_cubes.size()) {\n            cerr << \"Invalid height h\" << endl;\n            return 1;\n        }\n        n = total_cubes[h] - 1;\n        if (n < 1)\n            n = 1;\n    } else if (type == \"just_after_height\") {\n        int h = opt<int>(\"h\");\n        if (h <= 0 || h >= (int)total_cubes.size()) {\n            cerr << \"Invalid height h\" << endl;\n            return 1;\n        }\n        n = total_cubes[h] + 1;\n        if (n > n_max)\n            n = n_max;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Ensure n within constraints\n    if (n < 1)\n        n = 1;\n    if (n > n_max)\n        n = n_max;\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n\n./gen -type min\n\n# Maximum n\n./gen -type max\n\n# Random n within full range [1,10000], multiple times\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Random n within smaller ranges\n./gen -type random -min_n 1 -max_n 10\n./gen -type random -min_n 1 -max_n 100\n./gen -type random -min_n 100 -max_n 1000\n./gen -type random -min_n 1000 -max_n 10000\n\n# Test cases for specific heights\n./gen -type by_height -h 1\n./gen -type by_height -h 2\n./gen -type by_height -h 3\n./gen -type by_height -h 5\n./gen -type by_height -h 10\n./gen -type by_height -h 15\n./gen -type by_height -h 20\n./gen -type by_height -h 38\n\n# Test cases just before the required n for height h\n./gen -type just_before_height -h 2\n./gen -type just_before_height -h 3\n./gen -type just_before_height -h 5\n./gen -type just_before_height -h 10\n./gen -type just_before_height -h 20\n./gen -type just_before_height -h 38\n\n# Test cases just after the required n for height h\n./gen -type just_after_height -h 1\n./gen -type just_after_height -h 2\n./gen -type just_after_height -h 5\n./gen -type just_after_height -h 10\n./gen -type just_after_height -h 20\n./gen -type just_after_height -h 38\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:21.731989",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "492/B",
      "title": "B. Ваня и фонари",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n, l (1 ≤ n ≤ 1000, 1 ≤ l ≤ 109) — количество фонарей и длина улицы соответственно. В следующей строке записано n целых чисел ai (0 ≤ ai ≤ l). Несколько фонарей могут находиться в одной точке. Фонари могут находиться в концах улицы.",
      "output_spec": "Выходные данныеВыведите минимальный радиус освещения d, который необходим, чтобы осветить всю улицу. Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 9",
      "sample_tests": "ПримерыВходные данныеСкопировать7 1515 5 3 7 9 14 0Выходные данныеСкопировать2.5000000000Входные данныеСкопировать2 52 5Выходные данныеСкопировать2.0000000000",
      "description": "B. Ваня и фонари\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n, l (1 ≤ n ≤ 1000, 1 ≤ l ≤ 109) — количество фонарей и длина улицы соответственно. В следующей строке записано n целых чисел ai (0 ≤ ai ≤ l). Несколько фонарей могут находиться в одной точке. Фонари могут находиться в концах улицы.\n\nВходные данные\n\nВыходные данныеВыведите минимальный радиус освещения d, который необходим, чтобы осветить всю улицу. Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 9\n\nВыходные данные\n\nВходные данныеСкопировать7 1515 5 3 7 9 14 0Выходные данныеСкопировать2.5000000000Входные данныеСкопировать2 52 5Выходные данныеСкопировать2.0000000000\n\nВходные данныеСкопировать7 1515 5 3 7 9 14 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.5000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 52 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.0000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим второй пример. При d = 2 первый фонарь будет освещать отрезок [0, 4] улицы, а второй — отрезок [3, 5]. Таким образом, вся улица будет освещена.",
      "solutions": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces",
          "content": "Приветствую сообщество Codeforces.1 декабря 2014 года в 19:30 MSK состоится очередной раунд Codeforces #280 для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Это мой первый Codeforces раунд. Надеюсь, он вам понравится.Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено пять задач и два часа на их решение.UPD: Разбалловка стандартная — 500-1000-1500-2000-2500.UPD: Спасибо всем, кто принимал участие в раунде!Поздравляю победителей:1.alex_y2.wingemerald3.Eric944.Zpw9875.rabbit_TRрезультатыUPD: Разбор задач здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14945",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 775
        },
        {
          "title": "Разбор задач Codeforces Round #280 (Div. 2) - Codeforces",
          "content": "492A - Ваня и кубики.По сути нужно выполнить то, что просят в условии. Находим в цикле максимальную высоту h, подсчитывая, сколько кубиков должно быть в i-м рядку и добавляя эти значения к результату. Выполняем цикл, пока результат не превышает n.Авторское решение: 8924831492B - Ваня и фонари.Отсортируем фонари в порядке возрастания. Дальше найдем максимально возможное расстояние между двумя соседними фонарями, пусть это будет maxdist. Также учтем границы улицы, т.е. найдем расстояния от крайних фонарей к концам улицы (a[0] - 0) и (l - a[n - 1]). Ответом будет max(maxdist / 2, max(a[0] - 0, l - a[n - 1]))Асимптотика по времени O(nlogn), учитывая сортировку.Авторское решение: 8924823492C - Ваня и экзамены.Сортируем пары (ai, bi) в порядке возрастания по количеству рефератов bi, после этого проходимся от самого начала отсортированных пар и добавляем жадно по максимуму количество баллов, то есть добавляем значение min(avg * n - sum, r - ai), пока суммарное количество баллов не будет не меньше, чем avg * n.Асимптотика по времени O(nlogn), учитывая сортировку.Авторское решение: 8924807492D - Ваня и компьютерная игра.Создадим вектор rez размером x + y, в котором будут находится последовательность ударов Вани и Вовы за первую секунду. Для этого заведем 2 переменные cntx = cnty = 0. Дальше пока cntx < x и cnty < y, мы проверяем 3 условия:1) Если (cntx + 1) / x > (cnty + 1) / y, то добавляем в вектор “Vova”, cnty++.2) Если (cntx + 1) / x < (cnty + 1) / y, то добавляем в вектор “Vanya”, cntx++.3) Если (cntx + 1) / x = (cnty + 1) / y, то добавляем в вектор “Both” 2 раза, cntx++, cnty++.Дальше можем отвечать на каждый запрос за О(1), ответом будет rez[(ai - 1)mod(x + y)].Асимптотика по времени O(x + y).Авторское решение: 8924773492E - Ваня и поле.Поскольку gcd(dx, n) = gcd(dy, n) = 1, то Ваня сделает полный цикл за n движений. Сгруппируем все возможные пути в n групп, то есть те, что начинаются с точки (0, 0), (0, 1), …, (0, n - 1). Рассмотрим первый путь: он будет иметь вид (0, 0) - (dx, dy) - ((2 * dx) mod n, (2 * dy) mod n) - ... - (((n - 1) * dx) mod n, ((n - 1) * dy) mod n). Поскольку gcd(dx, n) = 1, то среди всех первых координат будут присутствовать все числа от 0 до n - 1. То есть можем занести в массив все соответствия между первой и второй координатой для пути с точки (0, 0), т.е. y[0] = 0, y[dx] = dy, ... , y[((n - 1) * dx) mod n] = ((n - 1) * dy) mod n. Теперь мы знаем, что все точки типа (i, y[i]), где 0 ≤ i ≤ n - 1, принадлежат к группе (0, 0). В таком случае точки типа (i, (y[i] + k)modn) принадлежат к группе (0, k). Тогда каждую точку (xi, yi) мы можем добавить к нужной группе k за О(1): (y[xi] + k) mod n = yi, k = (yi - y[xi] + n) mod n. Дальше просто ищем группу с максимальным количеством элементов, она и будет ответом.Асимптотика по времени O(n).Авторское решение: 8924746",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 492\\s*B"
          },
          "content_length": 2829
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 1",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 2",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 3",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 4",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 5",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 6",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 7",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 8",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 9",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 10",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 11",
          "code": "cmp = avg*n*1LL",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #280 (Div. 2) - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #280 (Div. 2) - Codeforces - Code 2",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #280 (Div. 2) - Codeforces - Code 3",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #280 (Div. 2) - Codeforces - Code 4",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #280 (Div. 2) - Codeforces - Code 5",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #280 (Div. 2) - Codeforces - Code 6",
          "code": "if(a.hw == b.hw) return a.score<=b.score;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #280 (Div. 2) - Codeforces - Code 7",
          "code": "for(int i=0;i<n;i++){\n    cin>>a[i];\n}\n\nsort(a,a+n);\n\ndouble rez=max(a[0],l-a[n-1]);\n\nfor(int i=1;i<n;i++){\n    rez=max(rez,a[i]-a[i-1]);\n}\ncout<<rez/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, l, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, l, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, l, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    const double EPS = 1E-9;\n\n    double juryAnswer = ans.readDouble();\n    double participantAnswer = ouf.readDouble();\n\n    // Check if the absolute or relative error does not exceed EPS\n    if (!doubleCompare(juryAnswer, participantAnswer, EPS)) {\n        quitf(_wa, \"Wrong answer. Expected: %.10f, found: %.10f, error = %.10e\",\n            juryAnswer, participantAnswer, fabs(juryAnswer - participantAnswer));\n    }\n\n    // Ensure that there are no extra tokens in the participant's output\n    if (!ouf.seekEof()) {\n        quitf(_wa, \"Extra data in the output\");\n    }\n\n    quitf(_ok, \"Correct answer within absolute or relative error of 1e-9.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long l = opt<long long>(\"l\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"random\") {\n        // Random positions between 0 and l\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, l);\n        }\n    } else if (type == \"edges\") {\n        // Lanterns at positions 0 and l\n        if (n >= 1) a[0] = 0;\n        if (n >= 2) a[1] = l;\n        for (int i = 2; i < n; ++i) {\n            a[i] = rnd.next(0LL, l);\n        }\n    } else if (type == \"not_cover_start\") {\n        // Lanterns not covering start of street\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(l / 10LL, l);\n        }\n    } else if (type == \"not_cover_end\") {\n        // Lanterns not covering end of street\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, l - l / 10LL);\n        }\n    } else if (type == \"not_cover_both_ends\") {\n        // Lanterns not covering both ends\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(l / 4LL, 3 * l / 4LL);\n        }\n    } else if (type == \"clustered\") {\n        // All lanterns at the same position\n        long long pos = rnd.next(0LL, l);\n        for (int i = 0; i < n; ++i) {\n            a[i] = pos;\n        }\n    } else if (type == \"max_gap_middle\") {\n        // Maximum gap occurs in the middle\n        if (n >= 1) a[0] = 0;\n        if (n >= 2) a[n - 1] = l;\n        for (int i = 1; i < n - 1; ++i) {\n            if (rnd.next(2)) {\n                a[i] = rnd.next(0LL, l / 3LL);\n            } else {\n                a[i] = rnd.next(2 * l / 3LL, l);\n            }\n        }\n    } else if (type == \"max_gap_ends\") {\n        // Lanterns in the middle, maximum gaps at ends\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(l / 3LL, 2 * l / 3LL);\n        }\n    } else if (type == \"uniform\") {\n        // Uniformly spaced lanterns\n        if (n == 1) {\n            a[0] = l / 2;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                a[i] = (i * l) / (n - 1);\n            }\n        }\n    } else if (type == \"single\") {\n        // Single lantern\n        a[0] = rnd.next(0LL, l);\n    } else if (type == \"minimal_l\") {\n        // l = 1\n        if (l != 1) l = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, l);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, l);\n        }\n    }\n\n    printf(\"%d %lld\\n\", n, l);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long l = opt<long long>(\"l\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"random\") {\n        // Random positions between 0 and l\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, l);\n        }\n    } else if (type == \"edges\") {\n        // Lanterns at positions 0 and l\n        if (n >= 1) a[0] = 0;\n        if (n >= 2) a[1] = l;\n        for (int i = 2; i < n; ++i) {\n            a[i] = rnd.next(0LL, l);\n        }\n    } else if (type == \"not_cover_start\") {\n        // Lanterns not covering start of street\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(l / 10LL, l);\n        }\n    } else if (type == \"not_cover_end\") {\n        // Lanterns not covering end of street\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, l - l / 10LL);\n        }\n    } else if (type == \"not_cover_both_ends\") {\n        // Lanterns not covering both ends\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(l / 4LL, 3 * l / 4LL);\n        }\n    } else if (type == \"clustered\") {\n        // All lanterns at the same position\n        long long pos = rnd.next(0LL, l);\n        for (int i = 0; i < n; ++i) {\n            a[i] = pos;\n        }\n    } else if (type == \"max_gap_middle\") {\n        // Maximum gap occurs in the middle\n        if (n >= 1) a[0] = 0;\n        if (n >= 2) a[n - 1] = l;\n        for (int i = 1; i < n - 1; ++i) {\n            if (rnd.next(2)) {\n                a[i] = rnd.next(0LL, l / 3LL);\n            } else {\n                a[i] = rnd.next(2 * l / 3LL, l);\n            }\n        }\n    } else if (type == \"max_gap_ends\") {\n        // Lanterns in the middle, maximum gaps at ends\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(l / 3LL, 2 * l / 3LL);\n        }\n    } else if (type == \"uniform\") {\n        // Uniformly spaced lanterns\n        if (n == 1) {\n            a[0] = l / 2;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                a[i] = (i * l) / (n - 1);\n            }\n        }\n    } else if (type == \"single\") {\n        // Single lantern\n        a[0] = rnd.next(0LL, l);\n    } else if (type == \"minimal_l\") {\n        // l = 1\n        if (l != 1) l = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, l);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, l);\n        }\n    }\n\n    printf(\"%d %lld\\n\", n, l);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -l 1 -type single\n./gen -n 1 -l 1 -type minimal_l\n./gen -n 1 -l 1000000000 -type single\n./gen -n 2 -l 10 -type edges\n./gen -n 2 -l 1000000000 -type edges\n./gen -n 2 -l 1000000 -type max_gap_ends\n./gen -n 3 -l 100 -type not_cover_both_ends\n./gen -n 5 -l 1000 -type not_cover_start\n./gen -n 5 -l 1 -type not_cover_end\n./gen -n 10 -l 500 -type clustered\n./gen -n 10 -l 500 -type uniform\n./gen -n 100 -l 1000000 -type uniform\n./gen -n 100 -l 1000000 -type random\n./gen -n 100 -l 1000000 -type max_gap_middle\n./gen -n 500 -l 1000000000 -type max_gap_middle\n./gen -n 500 -l 1000000000 -type max_gap_ends\n./gen -n 1000 -l 1000000000 -type random\n./gen -n 1000 -l 1000000000 -type edges\n./gen -n 1000 -l 1000000000 -type not_cover_start\n./gen -n 1000 -l 1000000000 -type not_cover_end\n./gen -n 1000 -l 1000000000 -type not_cover_both_ends\n./gen -n 1000 -l 1000000000 -type clustered\n./gen -n 1000 -l 1000000000 -type uniform\n./gen -n 1 -l 1000000000 -type single\n./gen -n 1 -l 1 -type minimal_l\n./gen -n 1000 -l 1 -type random\n./gen -n 1000 -l 1 -type clustered\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:23.961341",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "492/C",
      "title": "C. Vanya and Exams",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, r, avg (1 ≤ n ≤ 105, 1 ≤ r ≤ 109, 1 ≤ avg ≤ min(r, 106)) — the number of exams, the maximum grade and the required grade point average, respectively.Each of the following n lines contains space-separated integers ai and bi (1 ≤ ai ≤ r, 1 ≤ bi ≤ 106).",
      "output_spec": "OutputIn the first line print the minimum number of essays.",
      "sample_tests": "ExamplesInputCopy5 5 45 24 73 13 22 5OutputCopy4InputCopy2 5 45 25 2OutputCopy0",
      "description": "C. Vanya and Exams\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, r, avg (1 ≤ n ≤ 105, 1 ≤ r ≤ 109, 1 ≤ avg ≤ min(r, 106)) — the number of exams, the maximum grade and the required grade point average, respectively.Each of the following n lines contains space-separated integers ai and bi (1 ≤ ai ≤ r, 1 ≤ bi ≤ 106).\n\nOutputIn the first line print the minimum number of essays.\n\nInputCopy5 5 45 24 73 13 22 5OutputCopy4InputCopy2 5 45 25 2OutputCopy0\n\nInputCopy5 5 45 24 73 13 22 5\n\nOutputCopy4\n\nInputCopy2 5 45 25 2\n\nOutputCopy0\n\nNoteIn the first sample Vanya can write 2 essays for the 3rd exam to raise his grade by 2 points and 2 essays for the 4th exam to raise his grade by 1 point.In the second sample, Vanya doesn't need to write any essays as his general point average already is above average.",
      "solutions": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #280 for participants from the second division will take place on 1 December, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my first round on Codeforces. Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: Scoring is standard — 500-1000-1500-2000-2500.UPD: Thanks to everyone, who participated in the round!Congratulations to the winners:1.alex_y2.wingemerald3.Eric944.Zpw9875.rabbit_TRstandingsUPD: Editorial is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14945",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 807
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces",
          "content": "492A - Vanya and Cubes.In fact need to do what is asked in the statement. We need to find in a cycle the maximum height h, counting, how many blocks must be in i-th row and adding these values to the result. Iterate until the result is not greater than n.Jury's solution: 8924831492B - Vanya and Lanterns.Sort lanterns in non-decreasing order. Then we need to find maximal distance between two neighbour lanterns, let it be maxdist. Also we need to consider street bounds and count distances from outside lanterns to street bounds, it will be (a[0] - 0) and (l - a[n - 1]). The answer will be max(maxdist / 2, max(a[0] - 0, l - a[n - 1]))Time complexity O(nlogn).Jury's solution: 8924823492C - Vanya and Exams.Sort (ai, bi) in non-decreasing order for number of essays bi, after that go from the beginning of this sorted pairs and add greedily the maximal number of points we can, i.e. add value min(avg * n - sum, r - ai), while total amount of points will not be greater, than avg * n.Time complexity O(nlogn).Jury's solution: 8924807492D - Vanya and Computer Game.Let's create vector rez with size x + y, in which there will be a sequence of Vanya's and Vova's strikes for the first second. To do this, we can take 2 variables cntx = cnty = 0. Then while cntx < x and cnty < y, we will check 3 conditions:1) If (cntx + 1) / x > (cnty + 1) / y, then add into the vector word “Vova”, cnty++.2) If (cntx + 1) / x < (cnty + 1) / y, then add into the vector word “Vanya”, cntx++.3) If (cntx + 1) / x = (cnty + 1) / y, then add into the vector word “Both” 2 times, cntx++, cnty++.Then we are able to respond on each query for О(1), the answer will be rez[(ai - 1)mod(x + y)].Time complexity O(x + y).Jury's solution: 8924773492E - Vanya and Field.As long as gcd(dx, n) = gcd(dy, n) = 1, Vanya will do full cycle for n moves. Let's group all possible pathes into n groups, where 1 - th, 2 - nd, ... , n - th path will be started from points (0, 0), (0, 1), …, (0, n - 1). Let's look on first path: (0, 0) - (dx, dy) - ((2 * dx) mod n, (2 * dy) mod n) - ... - (((n - 1) * dx) mod n, ((n - 1) * dy) mod n). As long as gcd(dx, n) = 1, among the first coordinates of points of the path there will be all the numbers from 0 to n - 1. So we can write in the array all relations between the first and second coordinate in points for the path, that starts in the point (0, 0), i.e. y[0] = 0, y[dx] = dy, ... , y[((n - 1) * dx) mod n] = ((n - 1) * dy) mod n. Now we know, that all points with type (i, y[i]), where 0 ≤ i ≤ n - 1, belong to the group with start point (0, 0). In that case, points with type (i, (y[i] + k)modn) belong to the group with start point (0, k). Then we can add every point (xi, yi) to required group k for О(1): (y[xi] + k) mod n = yi, k = (yi - y[xi] + n) mod n. Then we need just to find group with the maximal amount of elements, it will be the answer.Time complexity O(n).Jury's solution: 8924746P.S. Sorry for my bad English, I hope, I will correct this editorial as much, as possible.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 492\\s*C"
          },
          "content_length": 3003
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 1",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 2",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 3",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 4",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 5",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 6",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 7",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 8",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 9",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 10",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 11",
          "code": "cmp = avg*n*1LL",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "if(a.hw == b.hw) return a.score<=b.score;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for(int i=0;i<n;i++){\n    cin>>a[i];\n}\n\nsort(a,a+n);\n\ndouble rez=max(a[0],l-a[n-1]);\n\nfor(int i=1;i<n;i++){\n    rez=max(rez,a[i]-a[i-1]);\n}\ncout<<rez/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int avg = inf.readInt(1, min(r, 1000000), \"avg\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, r, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int avg = inf.readInt(1, min(r, 1000000), \"avg\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, r, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int avg = inf.readInt(1, min(r, 1000000), \"avg\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, r, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    int avg = opt<int>(\"avg\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> exams(n); // Pair of ai and bi\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, r);\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"max_grades\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = r;\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"min_grades\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = 1;\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"equal_avg\") {\n        long long total_ai_needed = (long long)avg * n;\n        long long sum_ai = 0;\n        for (int i = 0; i < n; ++i) {\n            int ai = avg;\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n            sum_ai += ai;\n        }\n    } else if (type == \"bi_small_first\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, r);\n            int bi;\n            if (i < n / 2)\n                bi = 1;\n            else\n                bi = 1000000;\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"max_bi\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, r);\n            int bi = 1000000;\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"ai_equals_r\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = r;\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"overflows\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = 1;\n            int bi = 1;\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1000000, r);\n            int bi = rnd.next(500000, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, r);\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, r, avg);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", exams[i].first, exams[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    int avg = opt<int>(\"avg\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> exams(n); // Pair of ai and bi\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, r);\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"max_grades\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = r;\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"min_grades\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = 1;\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"equal_avg\") {\n        long long total_ai_needed = (long long)avg * n;\n        long long sum_ai = 0;\n        for (int i = 0; i < n; ++i) {\n            int ai = avg;\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n            sum_ai += ai;\n        }\n    } else if (type == \"bi_small_first\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, r);\n            int bi;\n            if (i < n / 2)\n                bi = 1;\n            else\n                bi = 1000000;\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"max_bi\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, r);\n            int bi = 1000000;\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"ai_equals_r\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = r;\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"overflows\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = 1;\n            int bi = 1;\n            exams[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1000000, r);\n            int bi = rnd.next(500000, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, r);\n            int bi = rnd.next(1, 1000000);\n            exams[i] = make_pair(ai, bi);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, r, avg);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", exams[i].first, exams[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -r 5 -avg 3 -type random\n./gen -n 100 -r 10 -avg 5 -type random\n./gen -n 1000 -r 100 -avg 50 -type random\n./gen -n 10000 -r 1000 -avg 500 -type random\n./gen -n 100000 -r 1000000 -avg 500000 -type random\n\n./gen -n 10 -r 5 -avg 5 -type max_grades\n./gen -n 100 -r 10 -avg 10 -type max_grades\n./gen -n 1000 -r 100 -avg 100 -type max_grades\n./gen -n 10000 -r 1000 -avg 1000 -type max_grades\n./gen -n 100000 -r 1000000 -avg 1000000 -type max_grades\n\n./gen -n 10 -r 5 -avg 4 -type min_grades\n./gen -n 100 -r 10 -avg 7 -type min_grades\n./gen -n 1000 -r 100 -avg 80 -type min_grades\n./gen -n 10000 -r 1000 -avg 700 -type min_grades\n./gen -n 100000 -r 1000000 -avg 900000 -type min_grades\n\n./gen -n 10 -r 5 -avg 3 -type equal_avg\n./gen -n 100 -r 10 -avg 5 -type equal_avg\n./gen -n 1000 -r 100 -avg 50 -type equal_avg\n./gen -n 10000 -r 1000 -avg 500 -type equal_avg\n./gen -n 100000 -r 1000000 -avg 500000 -type equal_avg\n\n./gen -n 1000 -r 100 -avg 50 -type bi_small_first\n./gen -n 10000 -r 1000 -avg 500 -type bi_small_first\n./gen -n 100000 -r 1000000 -avg 500000 -type bi_small_first\n\n./gen -n 1000 -r 100 -avg 50 -type max_bi\n./gen -n 10000 -r 1000 -avg 500 -type max_bi\n./gen -n 100000 -r 1000000 -avg 500000 -type max_bi\n\n./gen -n 10 -r 5 -avg 5 -type ai_equals_r\n./gen -n 100 -r 10 -avg 10 -type ai_equals_r\n./gen -n 1000 -r 100 -avg 100 -type ai_equals_r\n./gen -n 10000 -r 1000 -avg 1000 -type ai_equals_r\n./gen -n 100000 -r 1000000 -avg 1000000 -type ai_equals_r\n\n./gen -n 100000 -r 1000000000 -avg 1000000 -type overflows\n\n./gen -n 100000 -r 1000000000 -avg 1000000 -type large_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:25.795958",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "492/D",
      "title": "D. Vanya and Computer Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n,x,y (1 ≤ n ≤ 105, 1 ≤ x, y ≤ 106) — the number of monsters, the frequency of Vanya's and Vova's attack, correspondingly.Next n lines contain integers ai (1 ≤ ai ≤ 109) — the number of hits needed do destroy the i-th monster.",
      "output_spec": "OutputPrint n lines. In the i-th line print word \"Vanya\", if the last hit on the i-th monster was performed by Vanya, \"Vova\", if Vova performed the last hit, or \"Both\", if both boys performed it at the same time.",
      "sample_tests": "ExamplesInputCopy4 3 21234OutputCopyVanyaVovaVanyaBothInputCopy2 1 112OutputCopyBothBoth",
      "description": "D. Vanya and Computer Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n,x,y (1 ≤ n ≤ 105, 1 ≤ x, y ≤ 106) — the number of monsters, the frequency of Vanya's and Vova's attack, correspondingly.Next n lines contain integers ai (1 ≤ ai ≤ 109) — the number of hits needed do destroy the i-th monster.\n\nOutputPrint n lines. In the i-th line print word \"Vanya\", if the last hit on the i-th monster was performed by Vanya, \"Vova\", if Vova performed the last hit, or \"Both\", if both boys performed it at the same time.\n\nInputCopy4 3 21234OutputCopyVanyaVovaVanyaBothInputCopy2 1 112OutputCopyBothBoth\n\nInputCopy4 3 21234\n\nOutputCopyVanyaVovaVanyaBoth\n\nInputCopy2 1 112\n\nOutputCopyBothBoth\n\nNoteIn the first sample Vanya makes the first hit at time 1 / 3, Vova makes the second hit at time 1 / 2, Vanya makes the third hit at time 2 / 3, and both boys make the fourth and fifth hit simultaneously at the time 1.In the second sample Vanya and Vova make the first and second hit simultaneously at time 1.",
      "solutions": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #280 for participants from the second division will take place on 1 December, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my first round on Codeforces. Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: Scoring is standard — 500-1000-1500-2000-2500.UPD: Thanks to everyone, who participated in the round!Congratulations to the winners:1.alex_y2.wingemerald3.Eric944.Zpw9875.rabbit_TRstandingsUPD: Editorial is here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14945",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 807
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces",
          "content": "492A - Vanya and Cubes.In fact need to do what is asked in the statement. We need to find in a cycle the maximum height h, counting, how many blocks must be in i-th row and adding these values to the result. Iterate until the result is not greater than n.Jury's solution: 8924831492B - Vanya and Lanterns.Sort lanterns in non-decreasing order. Then we need to find maximal distance between two neighbour lanterns, let it be maxdist. Also we need to consider street bounds and count distances from outside lanterns to street bounds, it will be (a[0] - 0) and (l - a[n - 1]). The answer will be max(maxdist / 2, max(a[0] - 0, l - a[n - 1]))Time complexity O(nlogn).Jury's solution: 8924823492C - Vanya and Exams.Sort (ai, bi) in non-decreasing order for number of essays bi, after that go from the beginning of this sorted pairs and add greedily the maximal number of points we can, i.e. add value min(avg * n - sum, r - ai), while total amount of points will not be greater, than avg * n.Time complexity O(nlogn).Jury's solution: 8924807492D - Vanya and Computer Game.Let's create vector rez with size x + y, in which there will be a sequence of Vanya's and Vova's strikes for the first second. To do this, we can take 2 variables cntx = cnty = 0. Then while cntx < x and cnty < y, we will check 3 conditions:1) If (cntx + 1) / x > (cnty + 1) / y, then add into the vector word “Vova”, cnty++.2) If (cntx + 1) / x < (cnty + 1) / y, then add into the vector word “Vanya”, cntx++.3) If (cntx + 1) / x = (cnty + 1) / y, then add into the vector word “Both” 2 times, cntx++, cnty++.Then we are able to respond on each query for О(1), the answer will be rez[(ai - 1)mod(x + y)].Time complexity O(x + y).Jury's solution: 8924773492E - Vanya and Field.As long as gcd(dx, n) = gcd(dy, n) = 1, Vanya will do full cycle for n moves. Let's group all possible pathes into n groups, where 1 - th, 2 - nd, ... , n - th path will be started from points (0, 0), (0, 1), …, (0, n - 1). Let's look on first path: (0, 0) - (dx, dy) - ((2 * dx) mod n, (2 * dy) mod n) - ... - (((n - 1) * dx) mod n, ((n - 1) * dy) mod n). As long as gcd(dx, n) = 1, among the first coordinates of points of the path there will be all the numbers from 0 to n - 1. So we can write in the array all relations between the first and second coordinate in points for the path, that starts in the point (0, 0), i.e. y[0] = 0, y[dx] = dy, ... , y[((n - 1) * dx) mod n] = ((n - 1) * dy) mod n. Now we know, that all points with type (i, y[i]), where 0 ≤ i ≤ n - 1, belong to the group with start point (0, 0). In that case, points with type (i, (y[i] + k)modn) belong to the group with start point (0, k). Then we can add every point (xi, yi) to required group k for О(1): (y[xi] + k) mod n = yi, k = (yi - y[xi] + n) mod n. Then we need just to find group with the maximal amount of elements, it will be the answer.Time complexity O(n).Jury's solution: 8924746P.S. Sorry for my bad English, I hope, I will correct this editorial as much, as possible.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 492\\s*D"
          },
          "content_length": 3003
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 1",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 2",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 3",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 4",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 5",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 6",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 7",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 8",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 9",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 10",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 11",
          "code": "cmp = avg*n*1LL",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "if(a.hw == b.hw) return a.score<=b.score;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for(int i=0;i<n;i++){\n    cin>>a[i];\n}\n\nsort(a,a+n);\n\ndouble rez=max(a[0],l-a[n-1]);\n\nfor(int i=1;i<n;i++){\n    rez=max(rez,a[i]-a[i-1]);\n}\ncout<<rez/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000, \"y\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000, \"y\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000, \"y\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    } else if (type == \"small_ai\") {\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 10);\n    } else if (type == \"large_ai\") {\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1000000000 - 10, 1000000000);\n    } else if (type == \"same_ai\") {\n        int value = opt<int>(\"value\", 1);\n        for(int i = 0; i < n; ++i)\n            ai[i] = value;\n    } else if (type == \"vanya_makes_last_hit\") {\n        // For small ai, we can try to simulate and set ai accordingly.\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 10);\n            while ( ((a * y) % x) == 0 ) {\n                a = rnd.next(1, 10);\n            }\n            ai[i] = a;\n        }\n    } else if (type == \"vova_makes_last_hit\") {\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 10);\n            while ( ((a * x) % y) == 0 ) {\n                a = rnd.next(1, 10);\n            }\n            ai[i] = a;\n        }\n    } else if (type == \"both_make_last_hit\") {\n        int lcm_xy = x * y / __gcd(x, y);\n        for(int i = 0; i < n; ++i) {\n            int multiples = rnd.next(1, 10);\n            // Number of attacks needed so that both attack at the same time\n            int a = multiples * (lcm_xy / x + lcm_xy / y) - 1;\n            ai[i] = a;\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    }\n\n    /* output n, x, y */\n    printf(\"%d %d %d\\n\", n, x, y);\n\n    /* output ai */\n    for(int i = 0; i < n; ++i)\n        printf(\"%d\\n\", ai[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    } else if (type == \"small_ai\") {\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 10);\n    } else if (type == \"large_ai\") {\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1000000000 - 10, 1000000000);\n    } else if (type == \"same_ai\") {\n        int value = opt<int>(\"value\", 1);\n        for(int i = 0; i < n; ++i)\n            ai[i] = value;\n    } else if (type == \"vanya_makes_last_hit\") {\n        // For small ai, we can try to simulate and set ai accordingly.\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 10);\n            while ( ((a * y) % x) == 0 ) {\n                a = rnd.next(1, 10);\n            }\n            ai[i] = a;\n        }\n    } else if (type == \"vova_makes_last_hit\") {\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 10);\n            while ( ((a * x) % y) == 0 ) {\n                a = rnd.next(1, 10);\n            }\n            ai[i] = a;\n        }\n    } else if (type == \"both_make_last_hit\") {\n        int lcm_xy = x * y / __gcd(x, y);\n        for(int i = 0; i < n; ++i) {\n            int multiples = rnd.next(1, 10);\n            // Number of attacks needed so that both attack at the same time\n            int a = multiples * (lcm_xy / x + lcm_xy / y) - 1;\n            ai[i] = a;\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    }\n\n    /* output n, x, y */\n    printf(\"%d %d %d\\n\", n, x, y);\n\n    /* output ai */\n    for(int i = 0; i < n; ++i)\n        printf(\"%d\\n\", ai[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -x 3 -y 2 -type random\n./gen -n 10 -x 1000000 -y 1000000 -type random\n./gen -n 100000 -x 999999 -y 1000000 -type random\n./gen -n 100000 -x 1 -y 1 -type random\n\n./gen -n 10 -x 5 -y 5 -type small_ai\n./gen -n 100 -x 5 -y 5 -type small_ai\n./gen -n 1000 -x 5 -y 5 -type small_ai\n./gen -n 100000 -x 500000 -y 500000 -type small_ai\n\n./gen -n 10 -x 1000000 -y 1 -type large_ai\n./gen -n 100 -x 1 -y 1000000 -type large_ai\n./gen -n 1000 -x 999999 -y 888888 -type large_ai\n./gen -n 100000 -x 123456 -y 654321 -type large_ai\n\n./gen -n 10 -x 1 -y 1 -type same_ai -value 1\n./gen -n 100 -x 2 -y 2 -type same_ai -value 2\n./gen -n 1000 -x 3 -y 3 -type same_ai -value 1\n./gen -n 100000 -x 4 -y 4 -type same_ai -value 1000000000\n\n./gen -n 10 -x 3 -y 2 -type vanya_makes_last_hit\n./gen -n 100 -x 1000 -y 1 -type vanya_makes_last_hit\n./gen -n 1000 -x 1000000 -y 1 -type vanya_makes_last_hit\n\n./gen -n 10 -x 2 -y 3 -type vova_makes_last_hit\n./gen -n 100 -x 1 -y 1000 -type vova_makes_last_hit\n./gen -n 1000 -x 1 -y 1000000 -type vova_makes_last_hit\n\n./gen -n 10 -x 2 -y 2 -type both_make_last_hit\n./gen -n 100 -x 3 -y 6 -type both_make_last_hit\n./gen -n 1000 -x 5 -y 10 -type both_make_last_hit\n./gen -n 100000 -x 1000000 -y 1000000 -type both_make_last_hit\n\n./gen -n 100000 -x 1 -y 1 -type random\n./gen -n 100000 -x 1 -y 1000000 -type random\n./gen -n 100000 -x 1000000 -y 1 -type random\n./gen -n 100000 -x 123456 -y 789012 -type random\n\n./gen -n 1 -x 1 -y 1 -type small_ai\n./gen -n 1 -x 1000000 -y 1000000 -type large_ai\n./gen -n 1 -x 1 -y 1 -type both_make_last_hit\n\n./gen -n 2 -x 2 -y 2 -type small_ai\n./gen -n 2 -x 999999 -y 1000000 -type large_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:27.854109",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "492/E",
      "title": "E. Vanya and Field",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, m, dx, dy(1 ≤ n ≤ 106, 1 ≤ m ≤ 105, 1 ≤ dx, dy ≤ n) — the size of the field, the number of apple trees and the vector of Vanya's movement. Next m lines contain integers xi, yi (0 ≤ xi, yi ≤ n - 1) — the coordinates of apples. One cell may contain multiple apple trees.",
      "output_spec": "OutputPrint two space-separated numbers — the coordinates of the cell from which you should start your path. If there are several answers you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy5 5 2 30 01 21 32 43 1OutputCopy1 3InputCopy2 3 1 10 00 11 1OutputCopy0 0",
      "description": "E. Vanya and Field\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m, dx, dy(1 ≤ n ≤ 106, 1 ≤ m ≤ 105, 1 ≤ dx, dy ≤ n) — the size of the field, the number of apple trees and the vector of Vanya's movement. Next m lines contain integers xi, yi (0 ≤ xi, yi ≤ n - 1) — the coordinates of apples. One cell may contain multiple apple trees.\n\nOutputPrint two space-separated numbers — the coordinates of the cell from which you should start your path. If there are several answers you are allowed to print any of them.\n\nInputCopy5 5 2 30 01 21 32 43 1OutputCopy1 3InputCopy2 3 1 10 00 11 1OutputCopy0 0\n\nInputCopy5 5 2 30 01 21 32 43 1\n\nOutputCopy1 3\n\nInputCopy2 3 1 10 00 11 1\n\nOutputCopy0 0\n\nNoteIn the first sample Vanya's path will look like: (1, 3) - (3, 1) - (0, 4) - (2, 2) - (4, 0) - (1, 3)In the second sample: (0, 0) - (1, 1) - (0, 0)",
      "solutions": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #280 for participants from the second division will take place on 1 December, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my first round on Codeforces. Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: Scoring is standard — 500-1000-1500-2000-2500.UPD: Thanks to everyone, who participated in the round!Congratulations to the winners:1.alex_y2.wingemerald3.Eric944.Zpw9875.rabbit_TRstandingsUPD: Editorial is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14945",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 807
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces",
          "content": "492A - Vanya and Cubes.In fact need to do what is asked in the statement. We need to find in a cycle the maximum height h, counting, how many blocks must be in i-th row and adding these values to the result. Iterate until the result is not greater than n.Jury's solution: 8924831492B - Vanya and Lanterns.Sort lanterns in non-decreasing order. Then we need to find maximal distance between two neighbour lanterns, let it be maxdist. Also we need to consider street bounds and count distances from outside lanterns to street bounds, it will be (a[0] - 0) and (l - a[n - 1]). The answer will be max(maxdist / 2, max(a[0] - 0, l - a[n - 1]))Time complexity O(nlogn).Jury's solution: 8924823492C - Vanya and Exams.Sort (ai, bi) in non-decreasing order for number of essays bi, after that go from the beginning of this sorted pairs and add greedily the maximal number of points we can, i.e. add value min(avg * n - sum, r - ai), while total amount of points will not be greater, than avg * n.Time complexity O(nlogn).Jury's solution: 8924807492D - Vanya and Computer Game.Let's create vector rez with size x + y, in which there will be a sequence of Vanya's and Vova's strikes for the first second. To do this, we can take 2 variables cntx = cnty = 0. Then while cntx < x and cnty < y, we will check 3 conditions:1) If (cntx + 1) / x > (cnty + 1) / y, then add into the vector word “Vova”, cnty++.2) If (cntx + 1) / x < (cnty + 1) / y, then add into the vector word “Vanya”, cntx++.3) If (cntx + 1) / x = (cnty + 1) / y, then add into the vector word “Both” 2 times, cntx++, cnty++.Then we are able to respond on each query for О(1), the answer will be rez[(ai - 1)mod(x + y)].Time complexity O(x + y).Jury's solution: 8924773492E - Vanya and Field.As long as gcd(dx, n) = gcd(dy, n) = 1, Vanya will do full cycle for n moves. Let's group all possible pathes into n groups, where 1 - th, 2 - nd, ... , n - th path will be started from points (0, 0), (0, 1), …, (0, n - 1). Let's look on first path: (0, 0) - (dx, dy) - ((2 * dx) mod n, (2 * dy) mod n) - ... - (((n - 1) * dx) mod n, ((n - 1) * dy) mod n). As long as gcd(dx, n) = 1, among the first coordinates of points of the path there will be all the numbers from 0 to n - 1. So we can write in the array all relations between the first and second coordinate in points for the path, that starts in the point (0, 0), i.e. y[0] = 0, y[dx] = dy, ... , y[((n - 1) * dx) mod n] = ((n - 1) * dy) mod n. Now we know, that all points with type (i, y[i]), where 0 ≤ i ≤ n - 1, belong to the group with start point (0, 0). In that case, points with type (i, (y[i] + k)modn) belong to the group with start point (0, k). Then we can add every point (xi, yi) to required group k for О(1): (y[xi] + k) mod n = yi, k = (yi - y[xi] + n) mod n. Then we need just to find group with the maximal amount of elements, it will be the answer.Time complexity O(n).Jury's solution: 8924746P.S. Sorry for my bad English, I hope, I will correct this editorial as much, as possible.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 492\\s*E"
          },
          "content_length": 3003
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 1",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 2",
          "code": "8 6 10\n1\n2\n3\n4\n5\n6\n7\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 3",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 4",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nBoth",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 5",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 6",
          "code": "Vova\nVanya\nVova\nVova\nVanya\nVova\nBoth\nVova",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 7",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 8",
          "code": "while((ll) my_avg <  avg && i < n) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 9",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 10",
          "code": "vector < pair < int, int > > v(n);\nlong long ans = 0, add = cmp - sum, here;\nans += here * v[ptr].first;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) - Codeforces - Code 11",
          "code": "cmp = avg*n*1LL",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14945",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "1. Y\n2. X\n3. Y\n4. Y\n5. X\n6. Y\n7. Both\n8. Both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1. Y\n2. X\n3. Y\n4. X\n5. Y\n6. X\n7. Both?\n8. Both?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "if(a.hw == b.hw) return a.score<=b.score;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #280 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for(int i=0;i<n;i++){\n    cin>>a[i];\n}\n\nsort(a,a+n);\n\ndouble rez=max(a[0],l-a[n-1]);\n\nfor(int i=1;i<n;i++){\n    rez=max(rez,a[i]-a[i-1]);\n}\ncout<<rez/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14957",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int dx = inf.readInt(1, n, \"dx\");\n    inf.readSpace();\n    int dy = inf.readInt(1, n, \"dy\");\n    inf.readEoln();\n\n    ensuref(__gcd(dx, dy) == 1, \"gcd(dx, dy) must be 1\");\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(0, n - 1, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, n - 1, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int dx = inf.readInt(1, n, \"dx\");\n    inf.readSpace();\n    int dy = inf.readInt(1, n, \"dy\");\n    inf.readEoln();\n\n    ensuref(__gcd(dx, dy) == 1, \"gcd(dx, dy) must be 1\");\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(0, n - 1, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, n - 1, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int dx = inf.readInt(1, n, \"dx\");\n    inf.readSpace();\n    int dy = inf.readInt(1, n, \"dy\");\n    inf.readEoln();\n\n    ensuref(__gcd(dx, dy) == 1, \"gcd(dx, dy) must be 1\");\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(0, n - 1, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, n - 1, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdint>\nusing namespace std;\n\nint n, m, dx, dy;\nunordered_map<int64_t, int> apple_trees;\n\n// Function to read answer and compute total apples collected\nint readAns(InStream& stream) {\n    int x = stream.readInt(0, n - 1, \"x\");\n    int y = stream.readInt(0, n - 1, \"y\");\n    int64_t key = int64_t(x) * n + y;\n    unordered_set<int64_t> visited_positions;\n    int total_apples = 0;\n    while (visited_positions.find(key) == visited_positions.end()) {\n        visited_positions.insert(key);\n        if (apple_trees.find(key) != apple_trees.end()) {\n            total_apples += apple_trees[key];\n        }\n        x = (x + dx) % n;\n        y = (y + dy) % n;\n        key = int64_t(x) * n + y;\n    }\n    return total_apples;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input file\n    n = inf.readInt(1, 1000000, \"n\");\n    m = inf.readInt(1, 100000, \"m\");\n    dx = inf.readInt(1, n, \"dx\");\n    dy = inf.readInt(1, n, \"dy\");\n\n    apple_trees.reserve(m);\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(0, n - 1, \"xi\");\n        int yi = inf.readInt(0, n - 1, \"yi\");\n        int64_t key = int64_t(xi) * n + yi;\n        apple_trees[key]++;\n    }\n\n    int jury_apples = readAns(ans);\n    int cont_apples = readAns(ouf);\n\n    if (cont_apples < jury_apples) {\n        quitf(_wa, \"Contestant collected fewer apples than jury: contestant = %d, jury = %d\", cont_apples, jury_apples);\n    } else if (cont_apples == jury_apples) {\n        quitf(_ok, \"Contestant collected correct number of apples: %d\", cont_apples);\n    } else { // cont_apples > jury_apples\n        quitf(_fail, \"Contestant collected more apples than jury: contestant = %d, jury = %d\", cont_apples, jury_apples);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string test_type = opt<string>(\"test_type\", \"random\");\n\n    int dx;\n    do {\n        dx = rnd.next(1, n);\n    } while (gcd(dx, n) != 1);\n\n    int dy = rnd.next(1, n);\n\n    // Output n m dx dy\n    printf(\"%d %d %d %d\\n\", n, m, dx, dy);\n\n    vector<pair<int, int>> apples;\n\n    if(test_type == \"random\"){\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    } else if(test_type == \"line\"){\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            apples.emplace_back(xi, xi);\n        }\n    } else if(test_type == \"path\"){\n        int x0 = rnd.next(0, n -1);\n        int y0 = rnd.next(0, n -1);\n        vector<pair<int, int>> path_positions;\n        int x = x0, y = y0;\n        do {\n            path_positions.emplace_back(x, y);\n            x = (x + dx) % n;\n            y = (y + dy) % n;\n        } while (x != x0 || y != y0);\n\n        int path_size = path_positions.size();\n        m = min(m, path_size);\n        shuffle(path_positions.begin(), path_positions.end());\n        for(int i = 0; i < m; ++i){\n            apples.push_back(path_positions[i]);\n        }\n    } else if(test_type == \"single_cell\"){\n        int xi = rnd.next(0, n -1);\n        int yi = rnd.next(0, n -1);\n        for(int i = 0; i < m; ++i){\n            apples.emplace_back(xi, yi);\n        }\n    } else if(test_type == \"max_m\"){\n        m = 100000; // maximum m\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    } else if(test_type == \"max_n\"){\n        n = 1000000; // maximum n\n        do {\n            dx = rnd.next(1, n);\n        } while (gcd(dx, n) != 1);\n        dy = rnd.next(1, n);\n        // m remains as input or default\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    } else if(test_type == \"small_n\"){\n        n = rnd.next(1, 10);\n        do {\n            dx = rnd.next(1, n);\n        } while (gcd(dx, n) != 1);\n        dy = rnd.next(1, n);\n        // m remains as input or default\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    }\n\n    for(auto &p : apples){\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string test_type = opt<string>(\"test_type\", \"random\");\n\n    int dx;\n    do {\n        dx = rnd.next(1, n);\n    } while (gcd(dx, n) != 1);\n\n    int dy = rnd.next(1, n);\n\n    // Output n m dx dy\n    printf(\"%d %d %d %d\\n\", n, m, dx, dy);\n\n    vector<pair<int, int>> apples;\n\n    if(test_type == \"random\"){\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    } else if(test_type == \"line\"){\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            apples.emplace_back(xi, xi);\n        }\n    } else if(test_type == \"path\"){\n        int x0 = rnd.next(0, n -1);\n        int y0 = rnd.next(0, n -1);\n        vector<pair<int, int>> path_positions;\n        int x = x0, y = y0;\n        do {\n            path_positions.emplace_back(x, y);\n            x = (x + dx) % n;\n            y = (y + dy) % n;\n        } while (x != x0 || y != y0);\n\n        int path_size = path_positions.size();\n        m = min(m, path_size);\n        shuffle(path_positions.begin(), path_positions.end());\n        for(int i = 0; i < m; ++i){\n            apples.push_back(path_positions[i]);\n        }\n    } else if(test_type == \"single_cell\"){\n        int xi = rnd.next(0, n -1);\n        int yi = rnd.next(0, n -1);\n        for(int i = 0; i < m; ++i){\n            apples.emplace_back(xi, yi);\n        }\n    } else if(test_type == \"max_m\"){\n        m = 100000; // maximum m\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    } else if(test_type == \"max_n\"){\n        n = 1000000; // maximum n\n        do {\n            dx = rnd.next(1, n);\n        } while (gcd(dx, n) != 1);\n        dy = rnd.next(1, n);\n        // m remains as input or default\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    } else if(test_type == \"small_n\"){\n        n = rnd.next(1, 10);\n        do {\n            dx = rnd.next(1, n);\n        } while (gcd(dx, n) != 1);\n        dy = rnd.next(1, n);\n        // m remains as input or default\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < m; ++i){\n            int xi = rnd.next(0, n -1);\n            int yi = rnd.next(0, n -1);\n            apples.emplace_back(xi, yi);\n        }\n    }\n\n    for(auto &p : apples){\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 5 -m 5 -test_type random\n./gen -n 5 -m 5 -test_type line\n./gen -n 5 -m 3 -test_type path\n./gen -n 5 -m 5 -test_type single_cell\n./gen -n 5 -m 5 -test_type small_n\n\n# Medium test cases\n./gen -n 1000 -m 1000 -test_type random\n./gen -n 1000 -m 1000 -test_type line\n./gen -n 1000 -m 1000 -test_type path\n./gen -n 1000 -m 1000 -test_type single_cell\n./gen -n 1000 -m 1000 -test_type small_n\n\n# Large test cases\n./gen -n 1000000 -m 100000 -test_type random\n./gen -n 1000000 -m 100000 -test_type line\n./gen -n 1000000 -m 100000 -test_type path\n./gen -n 1000000 -m 100000 -test_type single_cell\n./gen -n 1000000 -m 100000 -test_type max_m\n./gen -n 1000000 -m 100000 -test_type max_n\n\n# Edge cases\n./gen -n 1 -m 1 -test_type random\n./gen -n 2 -m 2 -test_type line\n./gen -n 10 -m 10 -test_type small_n\n./gen -n 10 -m 100000 -test_type max_m\n./gen -n 1000000 -m 1 -test_type random\n\n# Special dx and dy values\n./gen -n 999983 -m 100000 -test_type random\n./gen -n 1000000 -m 100000 -test_type random\n./gen -n 1000000 -m 100000 -test_type small_n\n\n# Additional test cases\n./gen -n 500000 -m 100000 -test_type random\n./gen -n 999999 -m 100000 -test_type single_cell\n./gen -n 100000 -m 100000 -test_type line\n./gen -n 100000 -m 100000 -test_type path\n./gen -n 1000 -m 50000 -test_type max_m\n./gen -n 100 -m 100000 -test_type max_m\n./gen -n 100 -m 100000 -test_type single_cell\n./gen -n 50000 -m 100000 -test_type line\n./gen -n 50000 -m 100000 -test_type path\n./gen -n 7 -m 100000 -test_type single_cell\n./gen -n 999991 -m 100000 -test_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:29.503170",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "493/A",
      "title": "A. Вася и футбол",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задается имя команды, которая играет дома. Во второй строке задается имя команды, которая играет в гостях. Обе строки — непустые. Длины обеих строк не превышают 20. Каждая из строк состоит только из заглавных латинских букв. Названия команд — различны.Далее следует число n (1 ≤ n ≤ 90) — количество фолов. В каждой из последующих n строк указана информация об очередном фоле в следующем виде:  сначала следует число t (1 ≤ t ≤ 90) — минута на которой происходит нарушение;  затем следует буква «h» или буква «a» — если буква это «h», то карточку получил игрок из команды, которая играет дома, в противном случае карточка была показана игроку команды, играющей в гостях;  затем следует номер игрока m (1 ≤ m ≤ 99);  затем следует буква «y» или буква «r» — если буква это «y», то была показана жёлтая карточка, в противном случае была показана красная карточка. Футболисты разных команд могут иметь один и тот же номер. Футболисты внутри одной команды имеют различные номера. Фолы следуют в хронологическом порядке, никакие два фола не произошли на одной и той же минуте.",
      "output_spec": "Выходные данныеНа каждое событие получения футболистом своей первой красной карточки в хронологическом порядке выведите строку, содержащую следующую информацию:  имя команды, к которой принадлежит футболист;  номер футболиста в своей команде;  минута получения карточки. Если ни один футболист не получил красную карточку, ничего выводить не требуется.Это возможно, что ваша программа ничего не выведет в ходе своего выполнения (если красных карточек в игре не было).",
      "sample_tests": "ПримерыВходные данныеСкопироватьMCCSKA928 a 3 y62 h 25 y66 h 42 y70 h 25 y77 a 4 y79 a 25 y82 h 42 r89 h 16 y90 a 13 rВыходные данныеСкопироватьMC 25 70MC 42 82CSKA 13 90",
      "description": "A. Вася и футбол\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задается имя команды, которая играет дома. Во второй строке задается имя команды, которая играет в гостях. Обе строки — непустые. Длины обеих строк не превышают 20. Каждая из строк состоит только из заглавных латинских букв. Названия команд — различны.Далее следует число n (1 ≤ n ≤ 90) — количество фолов. В каждой из последующих n строк указана информация об очередном фоле в следующем виде:  сначала следует число t (1 ≤ t ≤ 90) — минута на которой происходит нарушение;  затем следует буква «h» или буква «a» — если буква это «h», то карточку получил игрок из команды, которая играет дома, в противном случае карточка была показана игроку команды, играющей в гостях;  затем следует номер игрока m (1 ≤ m ≤ 99);  затем следует буква «y» или буква «r» — если буква это «y», то была показана жёлтая карточка, в противном случае была показана красная карточка. Футболисты разных команд могут иметь один и тот же номер. Футболисты внутри одной команды имеют различные номера. Фолы следуют в хронологическом порядке, никакие два фола не произошли на одной и той же минуте.\n\nВходные данные\n\nВыходные данныеНа каждое событие получения футболистом своей первой красной карточки в хронологическом порядке выведите строку, содержащую следующую информацию:  имя команды, к которой принадлежит футболист;  номер футболиста в своей команде;  минута получения карточки. Если ни один футболист не получил красную карточку, ничего выводить не требуется.Это возможно, что ваша программа ничего не выведет в ходе своего выполнения (если красных карточек в игре не было).\n\nВыходные данные\n\nВходные данныеСкопироватьMCCSKA928 a 3 y62 h 25 y66 h 42 y70 h 25 y77 a 4 y79 a 25 y82 h 42 r89 h 16 y90 a 13 rВыходные данныеСкопироватьMC 25 70MC 42 82CSKA 13 90\n\nВходные данныеСкопироватьMCCSKA928 a 3 y62 h 25 y66 h 42 y70 h 25 y77 a 4 y79 a 25 y82 h 42 r89 h 16 y90 a 13 r\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьMC 25 70MC 42 82CSKA 13 90\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces",
          "content": "Здравствуйте!Третьего декабря, в 18:00 по Москве состоится Codeforces Round #281 для Див. 2 участников. Традиционно Див. 1 участники могут участвовать вне конкурса.Это мой первый Codeforces Round и надеюсь, что не последний :)Большое спасибо Максиму Ахмедову (Zlobober) за помощь при подготовке раунда и MikeMirzayanov-у за платформы Codeforces и Polygon.UPD1: Разбалловка будет динамической.UPD2: Контест завершен. Спасибо всем, кто участвовал. Надеюсь, что контест всем нравилось.UPD3: Разбор задачUPD4: Top-5 участники. Поздравляю ShiXingxing15 ganar27 Tim_LinYd coolwyj gaoyihan Еще раз поздравляю gaoyihan — он единственный, кто решил задачу Е.UPD5: Статистика взломов",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 673
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces",
          "content": "493A - Вася и футболНам придется хранить два массива — для игроков хозяев и гостей. В каждом из них мы должны сохранять статусы игроков \"чист\", \"желтая карточка\" или статус \"игрок удален\". И с каждом вводом просто проверить — если игрок удален, то ничего не предпринимать, иначе менять его статус в зависимости от того какую карточку он получает и от его статуса. При получении красной карточки в любом статусе, или желтой, находясь в статусе \"желтая карточка\" игрок удаляется с поля, и печатается строка в стандартный вывод.493B - Вася и борьбаНадо делать то, что сказано в условии. Хранить двe vector-ы, в одном из них очки первого борца, а во втором — очки второго. Еще две переменные — в первом сумма всех очков, что дано в вводе, а во втором — кто выполнил последний прием. Если Sum всех не 0, то выводить номер борца, иначе пройти над векторами и проверить — имеются ли неравные элементы. При равенстве выводить ответ зависимо от того, кто выполнял последний прием.493C - Вася и баскетболХраним один большой массив pair-ов — дистанция бросков и кто это выполнил. Сортируем весь этот массив, потом предлагаем, что все броски — трехочковые. Потом пройдем над массивом, и зависимо от второго элемента на одно уменьшаем наши очки на единицу и сравниваем с наилучшим ответом и при необходимости меняем. В самом конце выводим ответ.493D - Вася и шахматыЗаметим, что если n — нечетное, то черные могут сделать симметричные шаги относительно центральной линии — победив таким образом. А если n — четное, то белые могут ставить ферзь на поле (1;2) (что лексикографически наименьший возможный ход), никогда не входить в первую строку, и победить.493E - Вася и многочленРассмотрим две случая. 1) t!=1 и 2) t=1.1) Если наша функция — разная от константа, то а больше всех коэффициентов, и в ответ может быть только представление числа b в а-ичной системе счисления. Еще и надо проверить — является ли константа решением?2) при t=1 надо быть осторожнее:при 1 1 1: ответ inf,при 1 1 n: ответ 0при 1 а, а^x(x-натуральное): ответ 1при других случаях P(1) больше всех коэффициентов.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/14985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 493\\s*A"
          },
          "content_length": 2071
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 1",
          "code": "1! + 3! + 4! + 5! + ... + 281!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 2",
          "code": "281 = 9*8 + 7*6 + 5*4 + 3*2 + 1 + 2*3 + 4*5 + 6*7 + 8*9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 3",
          "code": "281 = 9*8 + 7*6 + 5*4 + 3*2 + 1 + 2*3 + 4*5 + 6*7 + 8*9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 4",
          "code": "a[j][m][k] ++;\nif( a[j][m][0] == 2 || a[j][m][1] == 1 )\n    cout << s[j] << \" \" << m << \" \" << t << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 5",
          "code": "a[j][m][k] ++;\nif( a[j][m][0] == 2 || a[j][m][1] == 1 )\n    cout << s[j] << \" \" << m << \" \" << t << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 6",
          "code": "3\n1000000000\n1000000000\n1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 7",
          "code": "3\n1000000000\n1000000000\n1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 8",
          "code": "4\n1\n5\n-2\n-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 9",
          "code": "4\n1\n5\n-2\n-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 10",
          "code": "4\n11\n1\n-9\n-3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 11",
          "code": "4\n11\n1\n-9\n-3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 12",
          "code": "11 > 9 => true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 13",
          "code": "111 gt 93 => false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 14",
          "code": "if(n%2) cout<<\"black\\n\";  else cout<<\"white\\n1 2\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 15",
          "code": "if ( (n & 1) == 1 ) {\n        System.out.println(\"black\");\n    } else {\n        System.out.println(\"white\\n1 2\");\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 16",
          "code": "if ( (n & 1) == 1 ) {\n        System.out.println(\"black\");\n    } else {\n        System.out.println(\"white\\n1 2\");\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 17",
          "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define ll long long \nll dp[6000];\nint main()\n{\n\tcout<<200000<<endl;\n\tfor(int i=0;i<200000;i++)\n\t\tcout<<1999999999<<\" \";\n\tcout<<1<<endl;\n\tcout<<2000000000;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 18",
          "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define ll long long \nll dp[6000];\nint main()\n{\n\tcout<<200000<<endl;\n\tfor(int i=0;i<200000;i++)\n\t\tcout<<1999999999<<\" \";\n\tcout<<1<<endl;\n\tcout<<2000000000;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 19",
          "code": "cout<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 20",
          "code": "cout<<endl<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 21",
          "code": "int a;\nscanf(\"%c\",&a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 22",
          "code": "int a;\nscanf(\"%c\",&a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "Задача D - скажем так, не очень-то.  Я ее сдал не очень-то задумываясь, исходя из двух соображений. Во-первых - все ее сдают, почему бы и мне не сдать. Во-вторых, явно что-то связанное с четностью n, и тогда остается 2-3 варианта с учетом разбора в условии задачи. Мне еще не повезло, только третий вариант оказался правильным. В общем, полагаю, подобные задачи на угадывание правильного ответа из не очень-то большого количества возможных вариантов далеко не самый лучший жанр на олимпиадах.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "wrong answer 1st words differ - expected: '6:8', found: '0:0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "ll AA, BB;\nAA = BB == -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "ll AA, BB;\nAA = BB == -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "5\n6 7 8 9 10\n5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "5\n6 7 8 9 10\n5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5\n5\n6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 8",
          "code": "5\n1 2 3 4 5\n5\n6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 9",
          "code": "TANC\n XNCOR\n 2\n 15 h 27 r\n 28 h 27 r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 10",
          "code": "TANC\n XNCOR\n 2\n 15 h 27 r\n 28 h 27 r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 11",
          "code": "for(j = 0; j < 2; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 12",
          "code": "for(j = 0; j <= 2; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string homeTeam = inf.readLine(\"[A-Z]{1,20}\", \"Home team name\");\n    string awayTeam = inf.readLine(\"[A-Z]{1,20}\", \"Away team name\");\n\n    ensuref(homeTeam != awayTeam, \"The names of the teams are distinct\");\n\n    int n = inf.readInt(1, 90, \"n\");\n    inf.readEoln();\n\n    int last_t = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int t = inf.readInt(1, 90, \"t_i\");\n        ensuref(t > last_t, \"Fouls must occur at strictly increasing times\");\n        last_t = t;\n\n        inf.readSpace();\n        string h_or_a = inf.readToken(\"[ha]\", \"h_or_a\");\n        inf.readSpace();\n        int m = inf.readInt(1, 99, \"m\");\n        inf.readSpace();\n        string y_or_r = inf.readToken(\"[yr]\", \"y_or_r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string homeTeam = inf.readLine(\"[A-Z]{1,20}\", \"Home team name\");\n    string awayTeam = inf.readLine(\"[A-Z]{1,20}\", \"Away team name\");\n\n    ensuref(homeTeam != awayTeam, \"The names of the teams are distinct\");\n\n    int n = inf.readInt(1, 90, \"n\");\n    inf.readEoln();\n\n    int last_t = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int t = inf.readInt(1, 90, \"t_i\");\n        ensuref(t > last_t, \"Fouls must occur at strictly increasing times\");\n        last_t = t;\n\n        inf.readSpace();\n        string h_or_a = inf.readToken(\"[ha]\", \"h_or_a\");\n        inf.readSpace();\n        int m = inf.readInt(1, 99, \"m\");\n        inf.readSpace();\n        string y_or_r = inf.readToken(\"[yr]\", \"y_or_r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string homeTeam = inf.readLine(\"[A-Z]{1,20}\", \"Home team name\");\n    string awayTeam = inf.readLine(\"[A-Z]{1,20}\", \"Away team name\");\n\n    ensuref(homeTeam != awayTeam, \"The names of the teams are distinct\");\n\n    int n = inf.readInt(1, 90, \"n\");\n    inf.readEoln();\n\n    int last_t = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int t = inf.readInt(1, 90, \"t_i\");\n        ensuref(t > last_t, \"Fouls must occur at strictly increasing times\");\n        last_t = t;\n\n        inf.readSpace();\n        string h_or_a = inf.readToken(\"[ha]\", \"h_or_a\");\n        inf.readSpace();\n        int m = inf.readInt(1, 99, \"m\");\n        inf.readSpace();\n        string y_or_r = inf.readToken(\"[yr]\", \"y_or_r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int minLength, int maxLength) {\n    int len = rnd.next(minLength, maxLength);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        char c = 'A' + rnd.next(26); // 0 to 25\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string home_team, away_team;\n    if (type == \"edge_names\") {\n        home_team = randomString(1, 1);\n        do {\n            away_team = randomString(20, 20);\n        } while (away_team == home_team);\n    } else {\n        home_team = randomString(1, 20);\n        do {\n            away_team = randomString(1, 20);\n        } while (away_team == home_team);\n    }\n\n    // Generate n unique times between 1 and 90\n    set<int> times_set;\n    while ((int)times_set.size() < n) {\n        times_set.insert(rnd.next(1, 90));\n    }\n    vector<int> times(times_set.begin(), times_set.end());\n    sort(times.begin(), times.end());\n\n    // For home and away team, maintain sets of player numbers assigned\n    set<int> home_players;\n    set<int> away_players;\n\n    // Now generate fouls\n    vector<tuple<int, char, int, char>> fouls; // time, 'h'/'a', m, 'y'/'r'\n\n    if (type == \"yellow_only\") {\n        // All fouls are yellow cards\n        for (int i = 0; i < n; ++i) {\n            int t = times[i];\n            // Decide h/a\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            // Decide player number\n            int m;\n            if (ha == 'h') {\n                // From home team\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    // All numbers taken, pick one\n                    m = *home_players.begin();\n                }\n            } else {\n                // From away team\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            // All yellow cards\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else if (type == \"direct_red\") {\n        // Some fouls are direct red cards\n        for (int i = 0; i < n; ++i) {\n            int t = times[i];\n            // Decide h/a\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            // Decide player number\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            // Decide y/r\n            char yr = rnd.next(0,1) == 0 ? 'y' : 'r';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else if (type == \"two_yellows\") {\n        // Create players who will get red cards via two yellow cards\n        int num_players = min(n/2, 20); // number of players to get two yellow cards\n        vector<int> player_numbers_home;\n        vector<int> player_numbers_away;\n        // Assign player numbers\n        for (int i = 0; i < num_players; ++i) {\n            int m;\n            do {\n                m = rnd.next(1, 99);\n            } while (home_players.count(m));\n            home_players.insert(m);\n            player_numbers_home.push_back(m);\n\n            do {\n                m = rnd.next(1, 99);\n            } while (away_players.count(m));\n            away_players.insert(m);\n            player_numbers_away.push_back(m);\n        }\n\n        // Now, for each player, add two yellow cards\n        int idx = 0;\n        for (int i = 0; i < num_players*2 && idx < n; ++i, ++idx) {\n            int t = times[idx];\n            char ha = (i%2 == 0) ? 'h' : 'a';\n            int m = (ha == 'h') ? player_numbers_home[i/2] : player_numbers_away[i/2];\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n        // For remaining fouls, add random fouls\n        for (; idx < n; ++idx) {\n            int t = times[idx];\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            char yr = 'y';\n            // Just yellow cards\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else if (type == \"same_numbers\") {\n        // Players from different teams have same numbers\n        int num_same_numbers = min(n/4, 20); // adjust as necessary\n        vector<int> shared_numbers;\n        for (int i = 0; i < num_same_numbers; ++i) {\n            int m = rnd.next(1, 99);\n            shared_numbers.push_back(m);\n        }\n        // Assign shared numbers to both teams\n        for (int m : shared_numbers) {\n            home_players.insert(m);\n            away_players.insert(m);\n        }\n        // Generate fouls involving these players\n        int idx = 0;\n        for (int m : shared_numbers) {\n            if (idx >= n) break;\n            int t = times[idx++];\n            fouls.push_back(make_tuple(t, 'h', m, 'y'));\n            if (idx >= n) break;\n            t = times[idx++];\n            fouls.push_back(make_tuple(t, 'a', m, 'y'));\n        }\n        // Generate random fouls for remaining times\n        for (; idx < n; ++idx) {\n            int t = times[idx];\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else if (type == \"edge_numbers\") {\n        // Use player numbers 1 and 99\n        home_players.insert(1);\n        home_players.insert(99);\n        away_players.insert(1);\n        away_players.insert(99);\n        // Generate fouls involving these players\n        int idx = 0;\n        int numbers[] = {1, 99};\n        for (int m : numbers) {\n            if (idx >= n) break;\n            int t = times[idx++];\n            char ha = 'h';\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n            if (idx >= n) break;\n            t = times[idx++];\n            ha = 'a';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n        // Generate random fouls for remaining times\n        for (; idx < n; ++idx) {\n            int t = times[idx];\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            int t = times[i];\n            // Decide h/a\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            // Decide player number\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            // Decide y/r\n            char yr = rnd.next(0,1) == 0 ? 'y' : 'r';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    }\n\n    // Now output the data\n    cout << home_team << endl;\n    cout << away_team << endl;\n    cout << n << endl;\n    for (int i = 0; i < n; ++i) {\n        int t;\n        char ha;\n        int m;\n        char yr;\n        tie(t, ha, m, yr) = fouls[i];\n        cout << t << ' ' << ha << ' ' << m << ' ' << yr << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int minLength, int maxLength) {\n    int len = rnd.next(minLength, maxLength);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        char c = 'A' + rnd.next(26); // 0 to 25\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string home_team, away_team;\n    if (type == \"edge_names\") {\n        home_team = randomString(1, 1);\n        do {\n            away_team = randomString(20, 20);\n        } while (away_team == home_team);\n    } else {\n        home_team = randomString(1, 20);\n        do {\n            away_team = randomString(1, 20);\n        } while (away_team == home_team);\n    }\n\n    // Generate n unique times between 1 and 90\n    set<int> times_set;\n    while ((int)times_set.size() < n) {\n        times_set.insert(rnd.next(1, 90));\n    }\n    vector<int> times(times_set.begin(), times_set.end());\n    sort(times.begin(), times.end());\n\n    // For home and away team, maintain sets of player numbers assigned\n    set<int> home_players;\n    set<int> away_players;\n\n    // Now generate fouls\n    vector<tuple<int, char, int, char>> fouls; // time, 'h'/'a', m, 'y'/'r'\n\n    if (type == \"yellow_only\") {\n        // All fouls are yellow cards\n        for (int i = 0; i < n; ++i) {\n            int t = times[i];\n            // Decide h/a\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            // Decide player number\n            int m;\n            if (ha == 'h') {\n                // From home team\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    // All numbers taken, pick one\n                    m = *home_players.begin();\n                }\n            } else {\n                // From away team\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            // All yellow cards\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else if (type == \"direct_red\") {\n        // Some fouls are direct red cards\n        for (int i = 0; i < n; ++i) {\n            int t = times[i];\n            // Decide h/a\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            // Decide player number\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            // Decide y/r\n            char yr = rnd.next(0,1) == 0 ? 'y' : 'r';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else if (type == \"two_yellows\") {\n        // Create players who will get red cards via two yellow cards\n        int num_players = min(n/2, 20); // number of players to get two yellow cards\n        vector<int> player_numbers_home;\n        vector<int> player_numbers_away;\n        // Assign player numbers\n        for (int i = 0; i < num_players; ++i) {\n            int m;\n            do {\n                m = rnd.next(1, 99);\n            } while (home_players.count(m));\n            home_players.insert(m);\n            player_numbers_home.push_back(m);\n\n            do {\n                m = rnd.next(1, 99);\n            } while (away_players.count(m));\n            away_players.insert(m);\n            player_numbers_away.push_back(m);\n        }\n\n        // Now, for each player, add two yellow cards\n        int idx = 0;\n        for (int i = 0; i < num_players*2 && idx < n; ++i, ++idx) {\n            int t = times[idx];\n            char ha = (i%2 == 0) ? 'h' : 'a';\n            int m = (ha == 'h') ? player_numbers_home[i/2] : player_numbers_away[i/2];\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n        // For remaining fouls, add random fouls\n        for (; idx < n; ++idx) {\n            int t = times[idx];\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            char yr = 'y';\n            // Just yellow cards\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else if (type == \"same_numbers\") {\n        // Players from different teams have same numbers\n        int num_same_numbers = min(n/4, 20); // adjust as necessary\n        vector<int> shared_numbers;\n        for (int i = 0; i < num_same_numbers; ++i) {\n            int m = rnd.next(1, 99);\n            shared_numbers.push_back(m);\n        }\n        // Assign shared numbers to both teams\n        for (int m : shared_numbers) {\n            home_players.insert(m);\n            away_players.insert(m);\n        }\n        // Generate fouls involving these players\n        int idx = 0;\n        for (int m : shared_numbers) {\n            if (idx >= n) break;\n            int t = times[idx++];\n            fouls.push_back(make_tuple(t, 'h', m, 'y'));\n            if (idx >= n) break;\n            t = times[idx++];\n            fouls.push_back(make_tuple(t, 'a', m, 'y'));\n        }\n        // Generate random fouls for remaining times\n        for (; idx < n; ++idx) {\n            int t = times[idx];\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else if (type == \"edge_numbers\") {\n        // Use player numbers 1 and 99\n        home_players.insert(1);\n        home_players.insert(99);\n        away_players.insert(1);\n        away_players.insert(99);\n        // Generate fouls involving these players\n        int idx = 0;\n        int numbers[] = {1, 99};\n        for (int m : numbers) {\n            if (idx >= n) break;\n            int t = times[idx++];\n            char ha = 'h';\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n            if (idx >= n) break;\n            t = times[idx++];\n            ha = 'a';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n        // Generate random fouls for remaining times\n        for (; idx < n; ++idx) {\n            int t = times[idx];\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            char yr = 'y';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            int t = times[i];\n            // Decide h/a\n            char ha = rnd.next(0,1) == 0 ? 'h' : 'a';\n            // Decide player number\n            int m;\n            if (ha == 'h') {\n                if ((int)home_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (home_players.count(m));\n                    home_players.insert(m);\n                } else {\n                    m = *home_players.begin();\n                }\n            } else {\n                if ((int)away_players.size() < 99) {\n                    do {\n                        m = rnd.next(1, 99);\n                    } while (away_players.count(m));\n                    away_players.insert(m);\n                } else {\n                    m = *away_players.begin();\n                }\n            }\n            // Decide y/r\n            char yr = rnd.next(0,1) == 0 ? 'y' : 'r';\n            fouls.push_back(make_tuple(t, ha, m, yr));\n        }\n    }\n\n    // Now output the data\n    cout << home_team << endl;\n    cout << away_team << endl;\n    cout << n << endl;\n    for (int i = 0; i < n; ++i) {\n        int t;\n        char ha;\n        int m;\n        char yr;\n        tie(t, ha, m, yr) = fouls[i];\n        cout << t << ' ' << ha << ' ' << m << ' ' << yr << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type yellow_only\n./gen -n 10 -type direct_red\n./gen -n 10 -type two_yellows\n./gen -n 10 -type same_numbers\n./gen -n 10 -type edge_numbers\n./gen -n 10 -type edge_names\n\n./gen -n 90 -type random\n./gen -n 90 -type yellow_only\n./gen -n 90 -type direct_red\n./gen -n 90 -type two_yellows\n./gen -n 90 -type same_numbers\n./gen -n 90 -type edge_numbers\n./gen -n 90 -type edge_names\n\n./gen -n 1 -type random\n./gen -n 1 -type yellow_only\n./gen -n 1 -type direct_red\n./gen -n 1 -type two_yellows\n./gen -n 1 -type edge_numbers\n./gen -n 1 -type edge_names\n\n./gen -n 30 -type random\n./gen -n 60 -type random\n./gen -n 89 -type two_yellows\n./gen -n 90 -type same_numbers\n\n./gen -n 90 -type edge_numbers\n./gen -n 90 -type edge_names\n\n./gen -n 45 -type direct_red\n./gen -n 45 -type yellow_only\n\n./gen -n 20 -type random\n./gen -n 20 -type same_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:31.711721",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}