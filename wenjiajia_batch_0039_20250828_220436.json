{
  "metadata": {
    "batch_number": 39,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.383596",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "340/C",
      "title": "C. Tourist Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 105). Next line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ 107).",
      "output_spec": "OutputOutput two integers — the numerator and denominator of a fraction which is equal to the wanted average number. The fraction must be irreducible.",
      "sample_tests": "ExamplesInputCopy32 3 5OutputCopy22 3",
      "description": "C. Tourist Problem\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 105). Next line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ 107).\n\nOutputOutput two integers — the numerator and denominator of a fraction which is equal to the wanted average number. The fraction must be irreducible.\n\nInputCopy32 3 5OutputCopy22 3\n\nInputCopy32 3 5\n\nOutputCopy22 3\n\nNoteConsider 6 possible routes:  [2, 3, 5]: total distance traveled: |2 – 0| + |3 – 2| + |5 – 3| = 5;  [2, 5, 3]: |2 – 0| + |5 – 2| + |3 – 5| = 7;  [3, 2, 5]: |3 – 0| + |2 – 3| + |5 – 2| = 7;  [3, 5, 2]: |3 – 0| + |5 – 3| + |2 – 5| = 8;  [5, 2, 3]: |5 – 0| + |2 – 5| + |3 – 2| = 9;  [5, 3, 2]: |5 – 0| + |3 – 5| + |2 – 3| = 8. The average travel distance is  =  = .",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 340\\s*C"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 10000000);\n    inf.readEoln();\n    sort(a.begin(), a.end());\n    for(int i = 1; i < n; i++)\n        ensuref(a[i] != a[i - 1], \"All ai must be distinct, but value %d appears more than once\", a[i]);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 10000000);\n    inf.readEoln();\n    sort(a.begin(), a.end());\n    for(int i = 1; i < n; i++)\n        ensuref(a[i] != a[i - 1], \"All ai must be distinct, but value %d appears more than once\", a[i]);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 10000000);\n    inf.readEoln();\n    sort(a.begin(), a.end());\n    for(int i = 1; i < n; i++)\n        ensuref(a[i] != a[i - 1], \"All ai must be distinct, but value %d appears more than once\", a[i]);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if(type == \"seq\") {\n        // Positions are sequential from 1 to n\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if(type == \"reverse_seq\") {\n        // Positions are decreasing from 1e7 downwards\n        for(int i = 0; i < n; ++i)\n            a[i] = 10000000 - i;\n    } else if(type == \"random\") {\n        // Random unique positions between 1 and 1e7\n        unordered_set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 10000000);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"small_range\") {\n        // Positions are within a small range, ensuring they are distinct\n        int max_ai = n + 1000; // Ensure the range is large enough\n        set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, max_ai);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"large_range\") {\n        // Positions are within a range near 1e7\n        int min_ai = 10000000 - n - 1000 + 1;\n        int max_ai = 10000000;\n        set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(min_ai, max_ai);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"left_biased\") {\n        // Positions are biased towards 1\n        int max_ai = 10000000;\n        set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.wnext(1, max_ai, -5);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"right_biased\") {\n        // Positions are biased towards 1e7\n        int max_ai = 10000000;\n        set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.wnext(1, max_ai, 5);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"extreme\") {\n        // Positions are at the extremes (near 1 and near 1e7)\n        int mid = n / 2;\n        set<int> s;\n        for(int i = 0; i < mid; ++i) {\n            a[i] = i + 1; // Positions near 1\n            s.insert(a[i]);\n        }\n        for(int i = mid; i < n; ++i) {\n            a[i] = 10000000 - (i - mid); // Positions near 1e7\n            s.insert(a[i]);\n        }\n    } else {\n        // Default to random if unknown type\n        unordered_set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 10000000);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output positions ai\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if(type == \"seq\") {\n        // Positions are sequential from 1 to n\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if(type == \"reverse_seq\") {\n        // Positions are decreasing from 1e7 downwards\n        for(int i = 0; i < n; ++i)\n            a[i] = 10000000 - i;\n    } else if(type == \"random\") {\n        // Random unique positions between 1 and 1e7\n        unordered_set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 10000000);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"small_range\") {\n        // Positions are within a small range, ensuring they are distinct\n        int max_ai = n + 1000; // Ensure the range is large enough\n        set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, max_ai);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"large_range\") {\n        // Positions are within a range near 1e7\n        int min_ai = 10000000 - n - 1000 + 1;\n        int max_ai = 10000000;\n        set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(min_ai, max_ai);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"left_biased\") {\n        // Positions are biased towards 1\n        int max_ai = 10000000;\n        set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.wnext(1, max_ai, -5);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"right_biased\") {\n        // Positions are biased towards 1e7\n        int max_ai = 10000000;\n        set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.wnext(1, max_ai, 5);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    } else if(type == \"extreme\") {\n        // Positions are at the extremes (near 1 and near 1e7)\n        int mid = n / 2;\n        set<int> s;\n        for(int i = 0; i < mid; ++i) {\n            a[i] = i + 1; // Positions near 1\n            s.insert(a[i]);\n        }\n        for(int i = mid; i < n; ++i) {\n            a[i] = 10000000 - (i - mid); // Positions near 1e7\n            s.insert(a[i]);\n        }\n    } else {\n        // Default to random if unknown type\n        unordered_set<int> s;\n        for(int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 10000000);\n            } while(s.count(x));\n            s.insert(x);\n            a[i] = x;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output positions ai\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type seq\n./gen -n 3 -type reverse_seq\n./gen -n 5 -type random\n./gen -n 10 -type small_range\n\n./gen -n 100 -type seq\n./gen -n 100 -type reverse_seq\n./gen -n 100 -type random\n./gen -n 100 -type small_range\n\n./gen -n 1000 -type left_biased\n./gen -n 1000 -type right_biased\n./gen -n 1000 -type extreme\n\n./gen -n 10000 -type random\n./gen -n 10000 -type small_range\n./gen -n 10000 -type large_range\n\n./gen -n 50000 -type random\n./gen -n 50000 -type left_biased\n./gen -n 50000 -type right_biased\n\n./gen -n 99999 -type random\n./gen -n 99999 -type extreme\n\n./gen -n 100000 -type seq\n./gen -n 100000 -type reverse_seq\n./gen -n 100000 -type random\n./gen -n 100000 -type small_range\n./gen -n 100000 -type large_range\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:56.483749",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "340/D",
      "title": "D. Bubble Sort Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n (2 ≤ n ≤ 105). The next line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ n).",
      "output_spec": "OutputOutput a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy33 1 2OutputCopy2",
      "description": "D. Bubble Sort Graph\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n (2 ≤ n ≤ 105). The next line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ n).\n\nOutputOutput a single integer — the answer to the problem.\n\nInputCopy33 1 2OutputCopy2\n\nInputCopy33 1 2\n\nOutputCopy2\n\nNoteConsider the first example. Bubble sort swaps elements 3 and 1. We add edge (1, 3). Permutation is now [1, 3, 2]. Then bubble sort swaps elements 3 and 2. We add edge (2, 3). Permutation is now sorted. We have a graph with 3 vertices and 2 edges (1, 3) and (2, 3). Its maximal independent set is [1, 2].",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 340\\s*D"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> perm(n);\n\n    if (type == \"sorted\") {\n        // The permutation is 1, 2, ..., n\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n    }\n    else if (type == \"reverse\") {\n        // The permutation is n, n-1, ..., 1\n        for (int i = 0; i < n; ++i)\n            perm[i] = n - i;\n    }\n    else if (type == \"random\") {\n        // The permutation is a random permutation of 1..n\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n    }\n    else if (type == \"star\") {\n        // The permutation is n, 1, 2, ..., n-1\n        perm[0] = n;\n        for (int i = 1; i < n; ++i)\n            perm[i] = i;\n    }\n    else if (type == \"almost_sorted\") {\n        // The permutation is sorted except last two elements are swapped\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        if (n >= 2)\n            swap(perm[n - 2], perm[n - 1]);\n    }\n    else if (type == \"alternating\") {\n        // The permutation is arranged as high, low, high, low...\n        vector<int> low, high;\n        int mid = (n + 1) / 2;\n        for (int i = 1; i <= n; ++i) {\n            if (i <= mid)\n                low.push_back(i);\n            else\n                high.push_back(i);\n        }\n        int li = 0, hi = high.size() - 1;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                perm[i] = high[hi--];\n            else\n                perm[i] = low[li++];\n        }\n    }\n    else if (type == \"reversed_pairs\") {\n        // Every consecutive pair is reversed\n        for (int i = 0; i < n; i += 2) {\n            if (i + 1 < n) {\n                perm[i] = i + 2;\n                perm[i + 1] = i + 1;\n            }\n            else {\n                perm[i] = i + 1;\n            }\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", perm[i]);\n        if (i + 1 != n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> perm(n);\n\n    if (type == \"sorted\") {\n        // The permutation is 1, 2, ..., n\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n    }\n    else if (type == \"reverse\") {\n        // The permutation is n, n-1, ..., 1\n        for (int i = 0; i < n; ++i)\n            perm[i] = n - i;\n    }\n    else if (type == \"random\") {\n        // The permutation is a random permutation of 1..n\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n    }\n    else if (type == \"star\") {\n        // The permutation is n, 1, 2, ..., n-1\n        perm[0] = n;\n        for (int i = 1; i < n; ++i)\n            perm[i] = i;\n    }\n    else if (type == \"almost_sorted\") {\n        // The permutation is sorted except last two elements are swapped\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        if (n >= 2)\n            swap(perm[n - 2], perm[n - 1]);\n    }\n    else if (type == \"alternating\") {\n        // The permutation is arranged as high, low, high, low...\n        vector<int> low, high;\n        int mid = (n + 1) / 2;\n        for (int i = 1; i <= n; ++i) {\n            if (i <= mid)\n                low.push_back(i);\n            else\n                high.push_back(i);\n        }\n        int li = 0, hi = high.size() - 1;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                perm[i] = high[hi--];\n            else\n                perm[i] = low[li++];\n        }\n    }\n    else if (type == \"reversed_pairs\") {\n        // Every consecutive pair is reversed\n        for (int i = 0; i < n; i += 2) {\n            if (i + 1 < n) {\n                perm[i] = i + 2;\n                perm[i + 1] = i + 1;\n            }\n            else {\n                perm[i] = i + 1;\n            }\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", perm[i]);\n        if (i + 1 != n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type sorted\n./gen -n 2 -type reverse\n./gen -n 2 -type random\n./gen -n 2 -type star\n./gen -n 2 -type almost_sorted\n./gen -n 2 -type alternating\n./gen -n 2 -type reversed_pairs\n\n./gen -n 10 -type sorted\n./gen -n 10 -type reverse\n./gen -n 10 -type random\n./gen -n 10 -type star\n./gen -n 10 -type almost_sorted\n./gen -n 10 -type alternating\n./gen -n 10 -type reversed_pairs\n\n./gen -n 100 -type sorted\n./gen -n 100 -type reverse\n./gen -n 100 -type random\n./gen -n 100 -type star\n./gen -n 100 -type almost_sorted\n./gen -n 100 -type alternating\n./gen -n 100 -type reversed_pairs\n\n./gen -n 1000 -type random\n./gen -n 1000 -type reverse\n./gen -n 1000 -type star\n./gen -n 1000 -type almost_sorted\n./gen -n 1000 -type alternating\n./gen -n 1000 -type reversed_pairs\n\n./gen -n 10000 -type random\n./gen -n 10000 -type reverse\n./gen -n 10000 -type star\n./gen -n 10000 -type almost_sorted\n./gen -n 10000 -type alternating\n./gen -n 10000 -type reversed_pairs\n\n./gen -n 100000 -type random\n./gen -n 100000 -type reverse\n./gen -n 100000 -type star\n./gen -n 100000 -type almost_sorted\n./gen -n 100000 -type alternating\n./gen -n 100000 -type reversed_pairs\n\n./gen -n 99999 -type reversed_pairs\n./gen -n 99998 -type alternating\n./gen -n 100001 -type random # Note: This will produce an error due to n exceeding the constraints\n./gen -n 1 -type sorted # Note: This will produce an error due to n less than the minimum constraint\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:58.447095",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "340/E",
      "title": "E. Iahub and Permutations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 2000). On the second line, there are n integers, representing Iahub's important permutation after Iahubina replaces some values with -1. It's guaranteed that there are no fixed points in the given permutation. Also, the given sequence contains at least two numbers -1 and each positive number occurs in the sequence at most once. It's guaranteed that there is at least one suitable permutation.",
      "output_spec": "OutputOutput a single integer, the number of ways Iahub could recover his permutation, modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy5-1 -1 4 3 -1OutputCopy2",
      "description": "E. Iahub and Permutations\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 2000). On the second line, there are n integers, representing Iahub's important permutation after Iahubina replaces some values with -1. It's guaranteed that there are no fixed points in the given permutation. Also, the given sequence contains at least two numbers -1 and each positive number occurs in the sequence at most once. It's guaranteed that there is at least one suitable permutation.\n\nOutputOutput a single integer, the number of ways Iahub could recover his permutation, modulo 1000000007 (109 + 7).\n\nInputCopy5-1 -1 4 3 -1OutputCopy2\n\nInputCopy5-1 -1 4 3 -1\n\nOutputCopy2\n\nNoteFor the first test example there are two permutations with no fixed points are [2, 5, 4, 3, 1] and [5, 1, 4, 3, 2]. Any other permutation would have at least one fixed point.",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 340\\s*E"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1, n, \"a\");\n    inf.readEoln();\n\n    set<int> positive_numbers;\n    int count_neg_ones = 0;\n    for(int i = 0; i < n; ++i) {\n        int ai = a[i];\n        if (ai == -1) {\n            ++count_neg_ones;\n        } else {\n            // Check for duplicates\n            ensuref(positive_numbers.count(ai) == 0, \"Positive number %d occurs multiple times\", ai);\n            positive_numbers.insert(ai);\n\n            // Check no fixed points\n            ensuref(ai != i + 1, \"Fixed point found at position %d with value %d\", i + 1, ai);\n        }\n    }\n    // Ensure there are at least two numbers -1\n    ensuref(count_neg_ones >= 2, \"There should be at least two numbers -1\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1, n, \"a\");\n    inf.readEoln();\n\n    set<int> positive_numbers;\n    int count_neg_ones = 0;\n    for(int i = 0; i < n; ++i) {\n        int ai = a[i];\n        if (ai == -1) {\n            ++count_neg_ones;\n        } else {\n            // Check for duplicates\n            ensuref(positive_numbers.count(ai) == 0, \"Positive number %d occurs multiple times\", ai);\n            positive_numbers.insert(ai);\n\n            // Check no fixed points\n            ensuref(ai != i + 1, \"Fixed point found at position %d with value %d\", i + 1, ai);\n        }\n    }\n    // Ensure there are at least two numbers -1\n    ensuref(count_neg_ones >= 2, \"There should be at least two numbers -1\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1, n, \"a\");\n    inf.readEoln();\n\n    set<int> positive_numbers;\n    int count_neg_ones = 0;\n    for(int i = 0; i < n; ++i) {\n        int ai = a[i];\n        if (ai == -1) {\n            ++count_neg_ones;\n        } else {\n            // Check for duplicates\n            ensuref(positive_numbers.count(ai) == 0, \"Positive number %d occurs multiple times\", ai);\n            positive_numbers.insert(ai);\n\n            // Check no fixed points\n            ensuref(ai != i + 1, \"Fixed point found at position %d with value %d\", i + 1, ai);\n        }\n    }\n    // Ensure there are at least two numbers -1\n    ensuref(count_neg_ones >= 2, \"There should be at least two numbers -1\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> genDerangement(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        a[i] = i + 1;\n    do {\n        shuffle(a.begin(), a.end());\n    } while ([&]() {\n        for (int i = 0; i < n; ++i)\n            if (a[i] == i + 1)\n                return true;\n        return false;\n    }());\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a = genDerangement(n); // Generate a derangement of size n\n\n    int k; // Number of positions to replace with -1\n    if (type == \"random\") {\n        k = rnd.next(2, n); // At least two positions are -1\n    } else if (type == \"min_minus_one\") {\n        k = 2; // Exactly two positions are -1\n    } else if (type == \"max_minus_one\") {\n        k = n - 2; // All positions are -1 except two\n    } else if (type == \"all_minus_one\") {\n        k = n; // All positions are -1\n    } else {\n        // Default to random\n        k = rnd.next(2, n);\n    }\n\n    // Randomly select k positions to replace with -1\n    vector<int> indices(n);\n    for (int i = 0; i < n; ++i)\n        indices[i] = i;\n    shuffle(indices.begin(), indices.end());\n    set<int> minusOnePositions(indices.begin(), indices.begin() + k);\n\n    // Build the input sequence\n    vector<int> ai(n);\n    for (int i = 0; i < n; ++i) {\n        if (minusOnePositions.count(i))\n            ai[i] = -1;\n        else\n            ai[i] = a[i];\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> genDerangement(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        a[i] = i + 1;\n    do {\n        shuffle(a.begin(), a.end());\n    } while ([&]() {\n        for (int i = 0; i < n; ++i)\n            if (a[i] == i + 1)\n                return true;\n        return false;\n    }());\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a = genDerangement(n); // Generate a derangement of size n\n\n    int k; // Number of positions to replace with -1\n    if (type == \"random\") {\n        k = rnd.next(2, n); // At least two positions are -1\n    } else if (type == \"min_minus_one\") {\n        k = 2; // Exactly two positions are -1\n    } else if (type == \"max_minus_one\") {\n        k = n - 2; // All positions are -1 except two\n    } else if (type == \"all_minus_one\") {\n        k = n; // All positions are -1\n    } else {\n        // Default to random\n        k = rnd.next(2, n);\n    }\n\n    // Randomly select k positions to replace with -1\n    vector<int> indices(n);\n    for (int i = 0; i < n; ++i)\n        indices[i] = i;\n    shuffle(indices.begin(), indices.end());\n    set<int> minusOnePositions(indices.begin(), indices.begin() + k);\n\n    // Build the input sequence\n    vector<int> ai(n);\n    for (int i = 0; i < n; ++i) {\n        if (minusOnePositions.count(i))\n            ai[i] = -1;\n        else\n            ai[i] = a[i];\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type min_minus_one\n./gen -n 2 -type max_minus_one\n./gen -n 2 -type all_minus_one\n./gen -n 2 -type random\n\n./gen -n 3 -type min_minus_one\n./gen -n 3 -type max_minus_one\n./gen -n 3 -type all_minus_one\n./gen -n 3 -type random\n\n./gen -n 10 -type min_minus_one\n./gen -n 10 -type max_minus_one\n./gen -n 10 -type all_minus_one\n./gen -n 10 -type random\n\n./gen -n 100 -type min_minus_one\n./gen -n 100 -type max_minus_one\n./gen -n 100 -type all_minus_one\n./gen -n 100 -type random\n\n./gen -n 500 -type min_minus_one\n./gen -n 500 -type max_minus_one\n./gen -n 500 -type all_minus_one\n./gen -n 500 -type random\n\n./gen -n 1000 -type min_minus_one\n./gen -n 1000 -type max_minus_one\n./gen -n 1000 -type all_minus_one\n./gen -n 1000 -type random\n\n./gen -n 1999 -type min_minus_one\n./gen -n 1999 -type max_minus_one\n./gen -n 1999 -type all_minus_one\n./gen -n 1999 -type random\n\n./gen -n 2000 -type min_minus_one\n./gen -n 2000 -type max_minus_one\n./gen -n 2000 -type all_minus_one\n./gen -n 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:00.641546",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "341/A",
      "title": "A. Tourist Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 105). Next line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ 107).",
      "output_spec": "OutputOutput two integers — the numerator and denominator of a fraction which is equal to the wanted average number. The fraction must be irreducible.",
      "sample_tests": "ExamplesInputCopy32 3 5OutputCopy22 3",
      "description": "A. Tourist Problem\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 105). Next line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ 107).\n\nOutputOutput two integers — the numerator and denominator of a fraction which is equal to the wanted average number. The fraction must be irreducible.\n\nInputCopy32 3 5OutputCopy22 3\n\nInputCopy32 3 5\n\nOutputCopy22 3\n\nNoteConsider 6 possible routes:  [2, 3, 5]: total distance traveled: |2 – 0| + |3 – 2| + |5 – 3| = 5;  [2, 5, 3]: |2 – 0| + |5 – 2| + |3 – 5| = 7;  [3, 2, 5]: |3 – 0| + |2 – 3| + |5 – 2| = 7;  [3, 5, 2]: |3 – 0| + |5 – 3| + |2 – 5| = 8;  [5, 2, 3]: |5 – 0| + |2 – 5| + |3 – 2| = 9;  [5, 3, 2]: |5 – 0| + |3 – 5| + |2 – 3| = 8. The average travel distance is  =  = .",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 341 和字母"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n    \n    // Ensure a_i are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All a_i must be distinct; found %d unique values out of n=%d\", (int)s.size(), n);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n    \n    // Ensure a_i are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All a_i must be distinct; found %d unique values out of n=%d\", (int)s.size(), n);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n    \n    // Ensure a_i are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All a_i must be distinct; found %d unique values out of n=%d\", (int)s.size(), n);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"sequential\") {\n        // ai = 1 to n\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } \n    else if (type == \"reverse\") {\n        // ai = n down to 1\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } \n    else if (type == \"small_values\") {\n        // ai are small values from 1 to n, shuffled\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"large_values\") {\n        // ai are large values close to 1e7, shuffled\n        int base = 10000000 - n + 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = base + i;\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"powers\") {\n        // ai are powers of 2\n        vector<int> powers;\n        for (int i = 0; i < 24 && powers.size() < n; ++i) {\n            int val = 1 << i;\n            if (val <= 10000000)\n                powers.push_back(val);\n        }\n        // Fill the rest with random values if needed\n        while (powers.size() < n) {\n            int x = rnd.next(1, 10000000);\n            if (find(powers.begin(), powers.end(), x) == powers.end())\n                powers.push_back(x);\n        }\n        a = powers;\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"primes\") {\n        // ai are prime numbers\n        vector<int> primes;\n        const int MAX = 10000000;\n        vector<bool> is_prime(MAX + 1, true);\n        for (int i = 2; i <= MAX && primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (1LL * i * i <= MAX) {\n                    for (int j = i * i; j <= MAX; j += i)\n                        is_prime[j] = false;\n                }\n            }\n        }\n        // If not enough primes, fill the rest with composite numbers\n        for (int i = 2; i <= MAX && primes.size() < n; ++i) {\n            if (!is_prime[i]) {\n                primes.push_back(i);\n            }\n        }\n        a = primes;\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"max_distances\") {\n        // ai are evenly spread from 1 to 1e7\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 + (int)((1LL * i * 9999999) / (n - 1));\n        }\n        shuffle(a.begin(), a.end());\n    }\n    else {\n        // Default random ai in [1, 1e7], distinct\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 10000000);\n            } while (used.count(x));\n            a[i] = x;\n            used.insert(x);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"sequential\") {\n        // ai = 1 to n\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } \n    else if (type == \"reverse\") {\n        // ai = n down to 1\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } \n    else if (type == \"small_values\") {\n        // ai are small values from 1 to n, shuffled\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"large_values\") {\n        // ai are large values close to 1e7, shuffled\n        int base = 10000000 - n + 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = base + i;\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"powers\") {\n        // ai are powers of 2\n        vector<int> powers;\n        for (int i = 0; i < 24 && powers.size() < n; ++i) {\n            int val = 1 << i;\n            if (val <= 10000000)\n                powers.push_back(val);\n        }\n        // Fill the rest with random values if needed\n        while (powers.size() < n) {\n            int x = rnd.next(1, 10000000);\n            if (find(powers.begin(), powers.end(), x) == powers.end())\n                powers.push_back(x);\n        }\n        a = powers;\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"primes\") {\n        // ai are prime numbers\n        vector<int> primes;\n        const int MAX = 10000000;\n        vector<bool> is_prime(MAX + 1, true);\n        for (int i = 2; i <= MAX && primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (1LL * i * i <= MAX) {\n                    for (int j = i * i; j <= MAX; j += i)\n                        is_prime[j] = false;\n                }\n            }\n        }\n        // If not enough primes, fill the rest with composite numbers\n        for (int i = 2; i <= MAX && primes.size() < n; ++i) {\n            if (!is_prime[i]) {\n                primes.push_back(i);\n            }\n        }\n        a = primes;\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"max_distances\") {\n        // ai are evenly spread from 1 to 1e7\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 + (int)((1LL * i * 9999999) / (n - 1));\n        }\n        shuffle(a.begin(), a.end());\n    }\n    else {\n        // Default random ai in [1, 1e7], distinct\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 10000000);\n            } while (used.count(x));\n            a[i] = x;\n            used.insert(x);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type sequential\n./gen -n 2 -type reverse\n./gen -n 2 -type random\n\n./gen -n 3 -type random\n\n./gen -n 10 -type small_values\n./gen -n 10 -type large_values\n./gen -n 10 -type random\n\n./gen -n 100 -type sequential\n./gen -n 100 -type reverse\n./gen -n 100 -type powers\n\n./gen -n 1000 -type small_values\n./gen -n 1000 -type large_values\n./gen -n 1000 -type primes\n\n./gen -n 5000 -type random\n./gen -n 5000 -type max_distances\n\n./gen -n 10000 -type sequential\n./gen -n 10000 -type random\n./gen -n 10000 -type max_distances\n\n./gen -n 50000 -type random\n./gen -n 50000 -type small_values\n./gen -n 50000 -type large_values\n\n./gen -n 99999 -type sequential\n./gen -n 99999 -type reverse\n./gen -n 99999 -type random\n./gen -n 99999 -type powers\n\n./gen -n 100000 -type sequential\n./gen -n 100000 -type reverse\n./gen -n 100000 -type small_values\n./gen -n 100000 -type large_values\n./gen -n 100000 -type max_distances\n./gen -n 100000 -type powers\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:02.565556",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "341/B",
      "title": "B. Bubble Sort Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n (2 ≤ n ≤ 105). The next line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ n).",
      "output_spec": "OutputOutput a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy33 1 2OutputCopy2",
      "description": "B. Bubble Sort Graph\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n (2 ≤ n ≤ 105). The next line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ n).\n\nOutputOutput a single integer — the answer to the problem.\n\nInputCopy33 1 2OutputCopy2\n\nInputCopy33 1 2\n\nOutputCopy2\n\nNoteConsider the first example. Bubble sort swaps elements 3 and 1. We add edge (1, 3). Permutation is now [1, 3, 2]. Then bubble sort swaps elements 3 and 2. We add edge (2, 3). Permutation is now sorted. We have a graph with 3 vertices and 2 edges (1, 3) and (2, 3). Its maximal independent set is [1, 2].",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 341 和字母"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(s.size() == n, \"All a_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(s.size() == n, \"All a_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(s.size() == n, \"All a_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    \n    if (type == \"sorted\") {\n        // Generate a sorted permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (type == \"reverse_sorted\") {\n        // Generate a reverse sorted permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else if (type == \"random\") {\n        // Generate a random permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"almost_sorted\") {\n        // Generate an almost sorted permutation with k swaps\n        int k = opt<int>(\"k\", n / 10); // default k is n/10\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        for (int i = 0; i < k; ++i) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            swap(a[idx1], a[idx2]);\n        }\n    } else if (type == \"sawtooth\") {\n        // Generate a sawtooth pattern permutation\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = i / 2 + 1;\n            } else {\n                a[i] = n - i / 2;\n            }\n        }\n    } else if (type == \"small_inversions\") {\n        // Generate a permutation with small inversions\n        int k = opt<int>(\"k\", 1); // number of inversions per element\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        for (int i = 0; i < n - k; ++i) {\n            for (int j = 0; j < k; ++j) {\n                if (i + j + 1 < n) {\n                    swap(a[i + j], a[i + j + 1]);\n                }\n            }\n            i += k - 1;\n        }\n    } else {\n        // Default to random permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    }\n\n    // Output the permutation\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    \n    if (type == \"sorted\") {\n        // Generate a sorted permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (type == \"reverse_sorted\") {\n        // Generate a reverse sorted permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else if (type == \"random\") {\n        // Generate a random permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"almost_sorted\") {\n        // Generate an almost sorted permutation with k swaps\n        int k = opt<int>(\"k\", n / 10); // default k is n/10\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        for (int i = 0; i < k; ++i) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            swap(a[idx1], a[idx2]);\n        }\n    } else if (type == \"sawtooth\") {\n        // Generate a sawtooth pattern permutation\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = i / 2 + 1;\n            } else {\n                a[i] = n - i / 2;\n            }\n        }\n    } else if (type == \"small_inversions\") {\n        // Generate a permutation with small inversions\n        int k = opt<int>(\"k\", 1); // number of inversions per element\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        for (int i = 0; i < n - k; ++i) {\n            for (int j = 0; j < k; ++j) {\n                if (i + j + 1 < n) {\n                    swap(a[i + j], a[i + j + 1]);\n                }\n            }\n            i += k - 1;\n        }\n    } else {\n        // Default to random permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    }\n\n    // Output the permutation\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 2 -type sorted\n./gen -n 2 -type reverse_sorted\n./gen -n 2 -type random\n\n./gen -n 5 -type sorted\n./gen -n 5 -type reverse_sorted\n./gen -n 5 -type random\n./gen -n 5 -type almost_sorted -k 1\n./gen -n 5 -type sawtooth\n\n# Medium n\n./gen -n 100 -type sorted\n./gen -n 100 -type reverse_sorted\n./gen -n 100 -type random\n./gen -n 100 -type almost_sorted -k 10\n./gen -n 100 -type sawtooth\n./gen -n 100 -type small_inversions -k 2\n\n# Large n\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reverse_sorted\n./gen -n 1000 -type random\n./gen -n 1000 -type almost_sorted -k 50\n./gen -n 1000 -type sawtooth\n./gen -n 1000 -type small_inversions -k 3\n\n# Very large n\n./gen -n 100000 -type sorted\n./gen -n 100000 -type reverse_sorted\n./gen -n 100000 -type random\n./gen -n 100000 -type almost_sorted -k 1000\n./gen -n 100000 -type sawtooth\n./gen -n 100000 -type small_inversions -k 5\n\n# Edge cases\n./gen -n 99999 -type sorted\n./gen -n 99999 -type random\n./gen -n 2 -type sorted\n./gen -n 2 -type reverse_sorted\n\n# Max n, minimal inversions\n./gen -n 100000 -type almost_sorted -k 1\n./gen -n 100000 -type small_inversions -k 1\n\n# Random tests\n./gen -n 50000 -type random\n./gen -n 75000 -type random\n\n# Tests with n near limits\n./gen -n 99999 -type reverse_sorted\n./gen -n 100000 -type reverse_sorted\n\n# Custom test cases\n./gen -n 100000 -type almost_sorted -k 0    # Should be same as sorted\n./gen -n 100000 -type almost_sorted -k 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:04.537748",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "341/C",
      "title": "C. Яхуб и перестановки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (2 ≤ n ≤ 2000). Во второй строке записано n целых чисел, описывающих важную перестановку Яхуба, после того, как Яхубина заменила некоторые значения на -1. Гарантируется, что в заданной перестановке нет неподвижных точек. Также, гарантируется, что в заданной последовательности как минимум две -1 (минус единицы) и что никакое положительное число не встречается в перестановке более одного раза. Гарантируется, что при заданных ограничениях, существует хотя бы одна подходящая перестановка.",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество способов восстановления перестановки по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать5-1 -1 4 3 -1Выходные данныеСкопировать2",
      "description": "C. Яхуб и перестановки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (2 ≤ n ≤ 2000). Во второй строке записано n целых чисел, описывающих важную перестановку Яхуба, после того, как Яхубина заменила некоторые значения на -1. Гарантируется, что в заданной перестановке нет неподвижных точек. Также, гарантируется, что в заданной последовательности как минимум две -1 (минус единицы) и что никакое положительное число не встречается в перестановке более одного раза. Гарантируется, что при заданных ограничениях, существует хотя бы одна подходящая перестановка.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество способов восстановления перестановки по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать5-1 -1 4 3 -1Выходные данныеСкопировать2\n\nВходные данныеСкопировать5-1 -1 4 3 -1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере две перестановки, не имеющие неподвижных точек: [2, 5, 4, 3, 1] и [5, 1, 4, 3, 2]. У всех остальных перестановок была бы по крайней мере одна неподвижная точка.",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Всем привет!Мы приглашаем вас принять участие в Codeforces Round #198, который начнется в пятницу, 30 августа в 19:30 MSK . Авторами задач являются я и Linh (ll931110). Мы также являемся авторами Codeforces Round 191 (Div. 2). В тот раз участники были довольны задачами раунда. Мы надеемся, что этот раунд будет как минимум не хуже предыдущего.Linh придумал задачи D2-C/D1-A и D2-E/D1-C. Я придумал остальные задачи. Мы надеемся, что во время раунда вы потратите больше времени на обдумывание решений, нежели на написание кода. Хочется добавить, что задачи раунда не будут требовать от вас написания сложных алгоритмов. Вместо этого, все они требуют креативности, сложных рассуждений и терпения. Да, главный герой раунда — Iahub, как и в прошлый раз.Я хочу поблагодарить DamianS, Gerald и Aksenov239 за тестирование раунда. Без них работа по подготовке раунда была бы намного сложнее. Также, спасибо Delinur за перевод задач и MikeMirzayanov за отличную систему Codeforces и Polygon.Желаем вам высокого рейтинга и удовольствия от решения задач!UPD1 Будет использоваться динамическая разбалловка в обоих дивизионахUPD2 Спасибо всем, кто участвовал. Я надеюсь задачи вам показались интересными. Кажется, мое предсказание, что вы будете больше обдумывать задачи, нежели писать код, подтвердилось. Мои поздравления победителям.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 разбор (English)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1546
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 341 和字母"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "cout << ans << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "sum += a[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "sumpairs += A[i] * i - sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "sumpairs += A[i] * i - sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "sumpairs = sumpairs +  A[i] * i - sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "sumpairs = sumpairs +  A[i] * i - sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 13",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 14",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 15",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 16",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 17",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 18",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2005;\n\nint n;\nint a[MAXN];\nvector<int> positions, unused_numbers;\nvector<int> adj[MAXN]; // adj[i] contains indices of unused_numbers\nint match_to[MAXN];\nbool visited[MAXN];\n\nbool bpm(int u) {\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            visited[v] = true;\n            if (match_to[v] == -1 || bpm(match_to[v])) {\n                match_to[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    set<int> positive_numbers;\n    int num_neg_one = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i > 1)\n            inf.readSpace();\n        a[i] = inf.readInt(-1, n, \"a_i\");\n        if (a[i] != -1) {\n            ensuref(1 <= a[i] && a[i] <= n, \"Positive a_i must be between 1 and n\");\n            ensuref(positive_numbers.count(a[i]) == 0, \"Positive number %d occurs more than once\", a[i]);\n            positive_numbers.insert(a[i]);\n            ensuref(a[i] != i, \"Fixed point at position %d\", i);\n        } else {\n            num_neg_one++;\n        }\n    }\n    inf.readEoln();\n\n    ensuref(num_neg_one >= 2, \"There must be at least two -1 in the sequence\");\n\n    // Collect unused numbers\n    for (int x = 1; x <= n; ++x) {\n        if (positive_numbers.count(x) == 0) {\n            unused_numbers.push_back(x);\n        }\n    }\n\n    // Collect positions with -1\n    for (int i = 1; i <= n; ++i) {\n        if (a[i] == -1) {\n            positions.push_back(i);\n        }\n    }\n\n    int m = positions.size();\n    int k = unused_numbers.size();\n    for (int i = 0; i < m; ++i) {\n        int pos = positions[i];\n        adj[i].clear();\n        for (int j = 0; j < k; ++j) {\n            int num = unused_numbers[j];\n            if (num != pos) {\n                adj[i].push_back(j); // Edge from positions[i] to unused_numbers[j]\n            }\n        }\n    }\n\n    memset(match_to, -1, sizeof(match_to));\n\n    for (int u = 0; u < m; ++u) {\n        memset(visited, 0, sizeof(visited));\n        if (!bpm(u)) {\n            ensuref(false, \"Unable to reconstruct the permutation: no suitable assignment\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2005;\n\nint n;\nint a[MAXN];\nvector<int> positions, unused_numbers;\nvector<int> adj[MAXN]; // adj[i] contains indices of unused_numbers\nint match_to[MAXN];\nbool visited[MAXN];\n\nbool bpm(int u) {\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            visited[v] = true;\n            if (match_to[v] == -1 || bpm(match_to[v])) {\n                match_to[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    set<int> positive_numbers;\n    int num_neg_one = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i > 1)\n            inf.readSpace();\n        a[i] = inf.readInt(-1, n, \"a_i\");\n        if (a[i] != -1) {\n            ensuref(1 <= a[i] && a[i] <= n, \"Positive a_i must be between 1 and n\");\n            ensuref(positive_numbers.count(a[i]) == 0, \"Positive number %d occurs more than once\", a[i]);\n            positive_numbers.insert(a[i]);\n            ensuref(a[i] != i, \"Fixed point at position %d\", i);\n        } else {\n            num_neg_one++;\n        }\n    }\n    inf.readEoln();\n\n    ensuref(num_neg_one >= 2, \"There must be at least two -1 in the sequence\");\n\n    // Collect unused numbers\n    for (int x = 1; x <= n; ++x) {\n        if (positive_numbers.count(x) == 0) {\n            unused_numbers.push_back(x);\n        }\n    }\n\n    // Collect positions with -1\n    for (int i = 1; i <= n; ++i) {\n        if (a[i] == -1) {\n            positions.push_back(i);\n        }\n    }\n\n    int m = positions.size();\n    int k = unused_numbers.size();\n    for (int i = 0; i < m; ++i) {\n        int pos = positions[i];\n        adj[i].clear();\n        for (int j = 0; j < k; ++j) {\n            int num = unused_numbers[j];\n            if (num != pos) {\n                adj[i].push_back(j); // Edge from positions[i] to unused_numbers[j]\n            }\n        }\n    }\n\n    memset(match_to, -1, sizeof(match_to));\n\n    for (int u = 0; u < m; ++u) {\n        memset(visited, 0, sizeof(visited));\n        if (!bpm(u)) {\n            ensuref(false, \"Unable to reconstruct the permutation: no suitable assignment\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2005;\n\nint n;\nint a[MAXN];\nvector<int> positions, unused_numbers;\nvector<int> adj[MAXN]; // adj[i] contains indices of unused_numbers\nint match_to[MAXN];\nbool visited[MAXN];\n\nbool bpm(int u) {\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            visited[v] = true;\n            if (match_to[v] == -1 || bpm(match_to[v])) {\n                match_to[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    set<int> positive_numbers;\n    int num_neg_one = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i > 1)\n            inf.readSpace();\n        a[i] = inf.readInt(-1, n, \"a_i\");\n        if (a[i] != -1) {\n            ensuref(1 <= a[i] && a[i] <= n, \"Positive a_i must be between 1 and n\");\n            ensuref(positive_numbers.count(a[i]) == 0, \"Positive number %d occurs more than once\", a[i]);\n            positive_numbers.insert(a[i]);\n            ensuref(a[i] != i, \"Fixed point at position %d\", i);\n        } else {\n            num_neg_one++;\n        }\n    }\n    inf.readEoln();\n\n    ensuref(num_neg_one >= 2, \"There must be at least two -1 in the sequence\");\n\n    // Collect unused numbers\n    for (int x = 1; x <= n; ++x) {\n        if (positive_numbers.count(x) == 0) {\n            unused_numbers.push_back(x);\n        }\n    }\n\n    // Collect positions with -1\n    for (int i = 1; i <= n; ++i) {\n        if (a[i] == -1) {\n            positions.push_back(i);\n        }\n    }\n\n    int m = positions.size();\n    int k = unused_numbers.size();\n    for (int i = 0; i < m; ++i) {\n        int pos = positions[i];\n        adj[i].clear();\n        for (int j = 0; j < k; ++j) {\n            int num = unused_numbers[j];\n            if (num != pos) {\n                adj[i].push_back(j); // Edge from positions[i] to unused_numbers[j]\n            }\n        }\n    }\n\n    memset(match_to, -1, sizeof(match_to));\n\n    for (int u = 0; u < m; ++u) {\n        memset(visited, 0, sizeof(visited));\n        if (!bpm(u)) {\n            ensuref(false, \"Unable to reconstruct the permutation: no suitable assignment\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_derangement(int n) {\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i)\n        a[i] = i +1; // numbers from 1 to n\n\n    for(int i = n -1; i >= 0; --i) {\n        int j;\n        if (i == 0) {\n            if(a[0] == 1) {\n                j = rnd.next(1, n - 1);\n                swap(a[0], a[j]);\n            }\n            // else, no swap needed\n        } else {\n            do {\n                j = rnd.next(0, i);\n            } while(a[j] == i + 1);\n            swap(a[i], a[j]);\n        }\n    }\n\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p = generate_derangement(n);\n\n    int k; // number of positions to set to -1\n\n    if(type == \"max-unknown\" || type == \"all-unknown\") {\n        k = n;\n    } else if(type == \"min-unknown\") {\n        k = 2;\n    } else if(type == \"half-unknown\") {\n        k = max(2, n / 2);\n    } else { // random\n        k = rnd.next(2, n);\n    }\n\n    // Select k positions to set to -1\n    vector<int> positions(n);\n    for(int i = 0; i < n; ++i) positions[i] = i;\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> b(n);\n    for (int i = 0; i < n; ++i)\n        b[i] = p[i];\n\n    for(int i = 0; i < k; ++i) {\n        b[positions[i]] = -1;\n    }\n\n    // Ensure that b has at least two -1's\n    ensure(count(b.begin(), b.end(), -1) >= 2);\n\n    // Ensure that positive elements in b are not at their own position\n    for(int i = 0; i < n; ++i) {\n        if(b[i] != -1) {\n            ensure(b[i] != i +1);\n        }\n    }\n\n    // Ensure that each positive number occurs at most once in b\n    set<int> positive_numbers;\n    for(int i = 0; i < n; ++i) {\n        if(b[i] != -1) {\n            ensure(1 <= b[i] && b[i] <= n);\n            positive_numbers.insert(b[i]);\n        }\n    }\n    ensure(int(positive_numbers.size()) == n - k);\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output b[0..n-1]\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", b[i]);\n        if(i +1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_derangement(int n) {\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i)\n        a[i] = i +1; // numbers from 1 to n\n\n    for(int i = n -1; i >= 0; --i) {\n        int j;\n        if (i == 0) {\n            if(a[0] == 1) {\n                j = rnd.next(1, n - 1);\n                swap(a[0], a[j]);\n            }\n            // else, no swap needed\n        } else {\n            do {\n                j = rnd.next(0, i);\n            } while(a[j] == i + 1);\n            swap(a[i], a[j]);\n        }\n    }\n\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p = generate_derangement(n);\n\n    int k; // number of positions to set to -1\n\n    if(type == \"max-unknown\" || type == \"all-unknown\") {\n        k = n;\n    } else if(type == \"min-unknown\") {\n        k = 2;\n    } else if(type == \"half-unknown\") {\n        k = max(2, n / 2);\n    } else { // random\n        k = rnd.next(2, n);\n    }\n\n    // Select k positions to set to -1\n    vector<int> positions(n);\n    for(int i = 0; i < n; ++i) positions[i] = i;\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> b(n);\n    for (int i = 0; i < n; ++i)\n        b[i] = p[i];\n\n    for(int i = 0; i < k; ++i) {\n        b[positions[i]] = -1;\n    }\n\n    // Ensure that b has at least two -1's\n    ensure(count(b.begin(), b.end(), -1) >= 2);\n\n    // Ensure that positive elements in b are not at their own position\n    for(int i = 0; i < n; ++i) {\n        if(b[i] != -1) {\n            ensure(b[i] != i +1);\n        }\n    }\n\n    // Ensure that each positive number occurs at most once in b\n    set<int> positive_numbers;\n    for(int i = 0; i < n; ++i) {\n        if(b[i] != -1) {\n            ensure(1 <= b[i] && b[i] <= n);\n            positive_numbers.insert(b[i]);\n        }\n    }\n    ensure(int(positive_numbers.size()) == n - k);\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output b[0..n-1]\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", b[i]);\n        if(i +1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type min-unknown\n./gen -n 2 -type max-unknown\n./gen -n 2 -type random\n./gen -n 3 -type min-unknown\n./gen -n 3 -type max-unknown\n./gen -n 3 -type random\n./gen -n 4 -type min-unknown\n./gen -n 4 -type max-unknown\n./gen -n 4 -type random\n./gen -n 10 -type min-unknown\n./gen -n 10 -type max-unknown\n./gen -n 10 -type random\n./gen -n 100 -type min-unknown\n./gen -n 100 -type max-unknown\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 500 -type half-unknown\n./gen -n 1000 -type min-unknown\n./gen -n 1000 -type max-unknown\n./gen -n 1000 -type random\n./gen -n 1000 -type half-unknown\n./gen -n 1998 -type min-unknown\n./gen -n 1998 -type random\n./gen -n 1999 -type min-unknown\n./gen -n 1999 -type max-unknown\n./gen -n 1999 -type random\n./gen -n 1999 -type half-unknown\n./gen -n 2000 -type min-unknown\n./gen -n 2000 -type max-unknown\n./gen -n 2000 -type random\n./gen -n 2000 -type half-unknown\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:06.746158",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "341/D",
      "title": "D. Iahub and Xors",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers: n (1 ≤ n ≤ 1000) and m (1 ≤ m ≤ 105). The number m represents the number of operations you need to perform. Each of the next m lines contains five or six integers, depending on operation type. If the i-th operation from the input is a query, the first number from i-th line will be 1. It will be followed by four integers x0, y0, x1, y1. If the i-th operation is an update, the first number from the i-th line will be 2. It will be followed by five integers x0, y0, x1, y1, v. It is guaranteed that for each update operation, the following inequality holds: 0 ≤ v < 262. It is guaranteed that for each operation, the following inequalities hold: 1 ≤ x0 ≤ x1 ≤ n, 1 ≤ y0 ≤ y1 ≤ n.",
      "output_spec": "OutputFor each query operation, output on a new line the result.",
      "sample_tests": "ExamplesInputCopy3 52 1 1 2 2 12 1 3 2 3 22 3 1 3 3 31 2 2 3 31 2 2 3 2OutputCopy32",
      "description": "D. Iahub and Xors\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers: n (1 ≤ n ≤ 1000) and m (1 ≤ m ≤ 105). The number m represents the number of operations you need to perform. Each of the next m lines contains five or six integers, depending on operation type. If the i-th operation from the input is a query, the first number from i-th line will be 1. It will be followed by four integers x0, y0, x1, y1. If the i-th operation is an update, the first number from the i-th line will be 2. It will be followed by five integers x0, y0, x1, y1, v. It is guaranteed that for each update operation, the following inequality holds: 0 ≤ v < 262. It is guaranteed that for each operation, the following inequalities hold: 1 ≤ x0 ≤ x1 ≤ n, 1 ≤ y0 ≤ y1 ≤ n.\n\nOutputFor each query operation, output on a new line the result.\n\nInputCopy3 52 1 1 2 2 12 1 3 2 3 22 3 1 3 3 31 2 2 3 31 2 2 3 2OutputCopy32\n\nInputCopy3 52 1 1 2 2 12 1 3 2 3 22 3 1 3 3 31 2 2 3 31 2 2 3 2\n\nOutputCopy32\n\nNoteAfter the first 3 operations, the matrix will look like this: 1 1 21 1 23 3 3The fourth operation asks us to compute 1 xor 2 xor 3 xor 3 = 3.The fifth operation asks us to compute 1 xor 3 = 2.",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 341\\s*D"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++){\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        int x0 = inf.readInt(1, n, \"x0\");\n        inf.readSpace();\n        int y0 = inf.readInt(1, n, \"y0\");\n        inf.readSpace();\n        int x1 = inf.readInt(1, n, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, n, \"y1\");\n\n        if (t == 2) {\n            inf.readSpace();\n            long long v = inf.readLong(0, (1LL<<62) - 1, \"v\");\n        }\n        inf.readEoln();\n\n        ensuref(x0 <= x1, \"x0 (%d) should be less than or equal to x1 (%d)\", x0, x1);\n        ensuref(y0 <= y1, \"y0 (%d) should be less than or equal to y1 (%d)\", y0, y1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++){\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        int x0 = inf.readInt(1, n, \"x0\");\n        inf.readSpace();\n        int y0 = inf.readInt(1, n, \"y0\");\n        inf.readSpace();\n        int x1 = inf.readInt(1, n, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, n, \"y1\");\n\n        if (t == 2) {\n            inf.readSpace();\n            long long v = inf.readLong(0, (1LL<<62) - 1, \"v\");\n        }\n        inf.readEoln();\n\n        ensuref(x0 <= x1, \"x0 (%d) should be less than or equal to x1 (%d)\", x0, x1);\n        ensuref(y0 <= y1, \"y0 (%d) should be less than or equal to y1 (%d)\", y0, y1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++){\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        int x0 = inf.readInt(1, n, \"x0\");\n        inf.readSpace();\n        int y0 = inf.readInt(1, n, \"y0\");\n        inf.readSpace();\n        int x1 = inf.readInt(1, n, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, n, \"y1\");\n\n        if (t == 2) {\n            inf.readSpace();\n            long long v = inf.readLong(0, (1LL<<62) - 1, \"v\");\n        }\n        inf.readEoln();\n\n        ensuref(x0 <= x1, \"x0 (%d) should be less than or equal to x1 (%d)\", x0, x1);\n        ensuref(y0 <= y1, \"y0 (%d) should be less than or equal to y1 (%d)\", y0, y1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int op = rnd.next(1, 2);\n            int x0 = rnd.next(1, n);\n            int x1 = rnd.next(1, n);\n            if (x0 > x1) swap(x0, x1);\n            int y0 = rnd.next(1, n);\n            int y1 = rnd.next(1, n);\n            if (y0 > y1) swap(y0, y1);\n            if (op == 1) {\n                // Query\n                printf(\"1 %d %d %d %d\\n\", x0, y0, x1, y1);\n            } else {\n                // Update\n                unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n                printf(\"2 %d %d %d %d %llu\\n\", x0, y0, x1, y1, v);\n            }\n        }\n    } else if (type == \"full_updates\") {\n        // All updates cover the entire matrix\n        for (int i = 0; i < m; ++i) {\n            unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n            printf(\"2 1 1 %d %d %llu\\n\", n, n, v);\n        }\n    } else if (type == \"full_queries\") {\n        // All queries over the entire matrix\n        for (int i = 0; i < m; ++i) {\n            printf(\"1 1 1 %d %d\\n\", n, n);\n        }\n    } else if (type == \"single_cell\") {\n        // All operations over a single cell\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            int op = rnd.next(1, 2);\n            if (op == 1) {\n                // Query\n                printf(\"1 %d %d %d %d\\n\", x, y, x, y);\n            } else {\n                // Update\n                unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n                printf(\"2 %d %d %d %d %llu\\n\", x, y, x, y, v);\n            }\n        }\n    } else if (type == \"corner_cases\") {\n        // Updates with v = 0 and overlapping regions\n        for (int i = 0; i < m; ++i) {\n            if (i % 3 == 0) {\n                // Update with v = 0\n                int x0 = rnd.next(1, n);\n                int x1 = rnd.next(1, n);\n                if (x0 > x1) swap(x0, x1);\n                int y0 = rnd.next(1, n);\n                int y1 = rnd.next(1, n);\n                if (y0 > y1) swap(y0, y1);\n                printf(\"2 %d %d %d %d %d\\n\", x0, y0, x1, y1, 0);\n            } else if (i % 3 == 1) {\n                // Query\n                int x0 = rnd.next(1, n);\n                int x1 = rnd.next(1, n);\n                if (x0 > x1) swap(x0, x1);\n                int y0 = rnd.next(1, n);\n                int y1 = rnd.next(1, n);\n                if (y0 > y1) swap(y0, y1);\n                printf(\"1 %d %d %d %d\\n\", x0, y0, x1, y1);\n            } else {\n                // Update overlapping submatrix\n                int x0 = rnd.next(1, n / 2);\n                int x1 = rnd.next(n / 2, n);\n                int y0 = rnd.next(1, n / 2);\n                int y1 = rnd.next(n / 2, n);\n                unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n                printf(\"2 %d %d %d %d %llu\\n\", x0, y0, x1, y1, v);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < m; ++i) {\n            int op = rnd.next(1, 2);\n            int x0 = rnd.next(1, n);\n            int x1 = rnd.next(1, n);\n            if (x0 > x1) swap(x0, x1);\n            int y0 = rnd.next(1, n);\n            int y1 = rnd.next(1, n);\n            if (y0 > y1) swap(y0, y1);\n            if (op == 1) {\n                // Query\n                printf(\"1 %d %d %d %d\\n\", x0, y0, x1, y1);\n            } else {\n                // Update\n                unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n                printf(\"2 %d %d %d %d %llu\\n\", x0, y0, x1, y1, v);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int op = rnd.next(1, 2);\n            int x0 = rnd.next(1, n);\n            int x1 = rnd.next(1, n);\n            if (x0 > x1) swap(x0, x1);\n            int y0 = rnd.next(1, n);\n            int y1 = rnd.next(1, n);\n            if (y0 > y1) swap(y0, y1);\n            if (op == 1) {\n                // Query\n                printf(\"1 %d %d %d %d\\n\", x0, y0, x1, y1);\n            } else {\n                // Update\n                unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n                printf(\"2 %d %d %d %d %llu\\n\", x0, y0, x1, y1, v);\n            }\n        }\n    } else if (type == \"full_updates\") {\n        // All updates cover the entire matrix\n        for (int i = 0; i < m; ++i) {\n            unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n            printf(\"2 1 1 %d %d %llu\\n\", n, n, v);\n        }\n    } else if (type == \"full_queries\") {\n        // All queries over the entire matrix\n        for (int i = 0; i < m; ++i) {\n            printf(\"1 1 1 %d %d\\n\", n, n);\n        }\n    } else if (type == \"single_cell\") {\n        // All operations over a single cell\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            int op = rnd.next(1, 2);\n            if (op == 1) {\n                // Query\n                printf(\"1 %d %d %d %d\\n\", x, y, x, y);\n            } else {\n                // Update\n                unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n                printf(\"2 %d %d %d %d %llu\\n\", x, y, x, y, v);\n            }\n        }\n    } else if (type == \"corner_cases\") {\n        // Updates with v = 0 and overlapping regions\n        for (int i = 0; i < m; ++i) {\n            if (i % 3 == 0) {\n                // Update with v = 0\n                int x0 = rnd.next(1, n);\n                int x1 = rnd.next(1, n);\n                if (x0 > x1) swap(x0, x1);\n                int y0 = rnd.next(1, n);\n                int y1 = rnd.next(1, n);\n                if (y0 > y1) swap(y0, y1);\n                printf(\"2 %d %d %d %d %d\\n\", x0, y0, x1, y1, 0);\n            } else if (i % 3 == 1) {\n                // Query\n                int x0 = rnd.next(1, n);\n                int x1 = rnd.next(1, n);\n                if (x0 > x1) swap(x0, x1);\n                int y0 = rnd.next(1, n);\n                int y1 = rnd.next(1, n);\n                if (y0 > y1) swap(y0, y1);\n                printf(\"1 %d %d %d %d\\n\", x0, y0, x1, y1);\n            } else {\n                // Update overlapping submatrix\n                int x0 = rnd.next(1, n / 2);\n                int x1 = rnd.next(n / 2, n);\n                int y0 = rnd.next(1, n / 2);\n                int y1 = rnd.next(n / 2, n);\n                unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n                printf(\"2 %d %d %d %d %llu\\n\", x0, y0, x1, y1, v);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < m; ++i) {\n            int op = rnd.next(1, 2);\n            int x0 = rnd.next(1, n);\n            int x1 = rnd.next(1, n);\n            if (x0 > x1) swap(x0, x1);\n            int y0 = rnd.next(1, n);\n            int y1 = rnd.next(1, n);\n            if (y0 > y1) swap(y0, y1);\n            if (op == 1) {\n                // Query\n                printf(\"1 %d %d %d %d\\n\", x0, y0, x1, y1);\n            } else {\n                // Update\n                unsigned long long v = rnd.next((unsigned long long)0, (1ULL << 62) - 1);\n                printf(\"2 %d %d %d %d %llu\\n\", x0, y0, x1, y1, v);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type single_cell\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 20 -type full_updates\n./gen -n 10 -m 20 -type full_queries\n\n./gen -n 100 -m 1000 -type random\n./gen -n 100 -m 1000 -type single_cell\n./gen -n 100 -m 1000 -type corner_cases\n\n./gen -n 500 -m 5000 -type random\n./gen -n 500 -m 5000 -type full_updates\n./gen -n 500 -m 5000 -type full_queries\n\n./gen -n 1000 -m 10000 -type random\n./gen -n 1000 -m 10000 -type single_cell\n./gen -n 1000 -m 10000 -type corner_cases\n\n./gen -n 1000 -m 50000 -type random\n./gen -n 1000 -m 50000 -type full_updates\n./gen -n 1000 -m 50000 -type full_queries\n./gen -n 1000 -m 50000 -type single_cell\n./gen -n 1000 -m 50000 -type corner_cases\n\n./gen -n 1000 -m 100000 -type random\n./gen -n 1000 -m 100000 -type full_updates\n./gen -n 1000 -m 100000 -type full_queries\n\n./gen -n 1000 -m 100000 -type random\n./gen -n 1000 -m 100000 -type single_cell\n./gen -n 1000 -m 100000 -type corner_cases\n\n./gen -n 1000 -m 100000 -type random\n./gen -n 1000 -m 100000 -type random\n./gen -n 1000 -m 100000 -type random\n\n./gen -n 1000 -m 100000 -type full_updates\n./gen -n 1000 -m 100000 -type full_queries\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:08.681270",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "341/E",
      "title": "E. Candies Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (3 ≤ n ≤ 1000). The next line contains n non-negative integers: a1, a2, ..., an — sequence elements. It is guaranteed that sum of all numbers in sequence a is up to 106.",
      "output_spec": "OutputIn case there exists no solution, output -1. Otherwise, in the first line output integer c (0 ≤ c ≤ 106), representing number of moves in your solution. Each of the next c lines should contain two integers i and j (1 ≤ i, j ≤ n, i ≠ j): integers i, j in the kth line mean that at the k-th move you will move candies from the j-th box to the i-th one.",
      "sample_tests": "ExamplesInputCopy33 6 9OutputCopy22 31 3InputCopy30 1 0OutputCopy-1InputCopy40 1 1 0OutputCopy0",
      "description": "E. Candies Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (3 ≤ n ≤ 1000). The next line contains n non-negative integers: a1, a2, ..., an — sequence elements. It is guaranteed that sum of all numbers in sequence a is up to 106.\n\nOutputIn case there exists no solution, output -1. Otherwise, in the first line output integer c (0 ≤ c ≤ 106), representing number of moves in your solution. Each of the next c lines should contain two integers i and j (1 ≤ i, j ≤ n, i ≠ j): integers i, j in the kth line mean that at the k-th move you will move candies from the j-th box to the i-th one.\n\nInputCopy33 6 9OutputCopy22 31 3InputCopy30 1 0OutputCopy-1InputCopy40 1 1 0OutputCopy0\n\nInputCopy33 6 9\n\nOutputCopy22 31 3\n\nInputCopy30 1 0\n\nOutputCopy-1\n\nInputCopy40 1 1 0\n\nOutputCopy0\n\nNoteFor the first sample, after the first move the boxes will contain 3, 12 and 3 candies. After the second move, the boxes will contain 6, 12 and 0 candies. Now all candies are in exactly 2 boxes.For the second sample, you can observe that the given configuration is not valid, as all candies are in a single box and they should be in two boxes. Also, any move won't change the configuration, so there exists no solution.For the third sample, all candies are already in 2 boxes. Hence, no move is needed.",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 341\\s*E"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n    long long sum_a = 0;\n    for (int ai : a) sum_a += ai;\n    ensuref(sum_a <= 1000000, \"Sum of a_i should be at most 1000000, but it is %lld\", sum_a);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n    long long sum_a = 0;\n    for (int ai : a) sum_a += ai;\n    ensuref(sum_a <= 1000000, \"Sum of a_i should be at most 1000000, but it is %lld\", sum_a);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n    long long sum_a = 0;\n    for (int ai : a) sum_a += ai;\n    ensuref(sum_a <= 1000000, \"Sum of a_i should be at most 1000000, but it is %lld\", sum_a);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n\n    int n = inf.readInt(3, 1000);\n    vector<int> a(n+1); // 1-based indexing\n    for (int i = 1; i <= n; i++) {\n        a[i] = inf.readInt(0, 1000000);\n    }\n\n    int total_candies = accumulate(a.begin()+1, a.end(), 0);\n\n    vector<int> boxes = a; // Copy initial state\n\n    if (ouf.seekEof()) {\n        quitf(_wa, \"Contestant's output is empty\");\n    }\n\n    string token = ouf.readToken();\n\n    if (token == \"-1\") {\n        // Contestant claims no solution\n        // Check if problem is unsolvable\n        int non_zero_boxes = 0;\n        for (int i = 1; i <= n; i++) {\n            if (a[i] > 0) non_zero_boxes++;\n        }\n        if (non_zero_boxes < 2) {\n            // Correct, problem is unsolvable\n            quitf(_ok, \"Correct, the problem is unsolvable\");\n        } else {\n            // There is a solution\n            quitf(_wa, \"Contestant claimed no solution, but a solution exists\");\n        }\n    } else {\n        // Try to parse c\n        int c;\n        try {\n            c = stoi(token);\n        } catch (...) {\n            quitf(_wa, \"Failed to parse '%s' as integer for number of moves c\", token.c_str());\n        }\n        if (c < 0 || c > 1000000) {\n            quitf(_wa, \"Invalid number of moves c: %d\", c);\n        }\n\n        // Read c moves\n        for (int move = 1; move <= c; move++) {\n            int i = ouf.readInt(1, n, format(\"move %d: i\", move).c_str());\n            int j = ouf.readInt(1, n, format(\"move %d: j\", move).c_str());\n            if (i == j) {\n                quitf(_wa, \"In move %d, boxes i and j are same\", move);\n            }\n            if (boxes[i] > boxes[j]) {\n                quitf(_wa, \"In move %d, boxes[%d] = %d > boxes[%d] = %d before the move, violating ai ≤ aj\", move, i, boxes[i], j, boxes[j]);\n            }\n            int transfer_amount = boxes[i];\n            boxes[i] += transfer_amount;\n            boxes[j] -= transfer_amount;\n            if (boxes[j] < 0) {\n                quitf(_wa, \"In move %d, box %d has negative candies after move\", move, j);\n            }\n        }\n\n        // After moves, check total candies\n        int total_after = accumulate(boxes.begin()+1, boxes.end(), 0);\n        if (total_after != total_candies) {\n            quitf(_wa, \"Total number of candies changed after moves\");\n        }\n\n        // Check that exactly two boxes have candies\n        int non_zero_boxes = 0;\n        for (int i = 1; i <= n; i++) {\n            if (boxes[i] > 0) non_zero_boxes++;\n        }\n        if (non_zero_boxes != 2) {\n            quitf(_wa, \"After moves, number of boxes with candies is %d, expected 2\", non_zero_boxes);\n        }\n\n        // No extra output?\n        if (!ouf.seekEof()) {\n            quitf(_wa, \"Extra output after last move\");\n        }\n\n        quitf(_ok, \"Correct, final state has candies in two boxes\");\n    }\n\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"impossible_one_box\") {\n        // All candies are in one box (impossible case)\n        int total_candies = rnd.next(1, 1000000);\n        int box = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) a[i] = 0;\n        a[box] = total_candies;\n    } else if (type == \"exact_two_boxes\") {\n        // Candies are in exactly two boxes\n        int total_candies = rnd.next(1, 1000000);\n        int box1 = rnd.next(0, n - 1);\n        int box2 = rnd.next(0, n - 1);\n        while (box2 == box1) box2 = rnd.next(0, n - 1);\n        int candies1 = rnd.next(1, total_candies - 1);\n        int candies2 = total_candies - candies1;\n        for (int i = 0; i < n; ++i) a[i] = 0;\n        a[box1] = candies1;\n        a[box2] = candies2;\n    } else if (type == \"random_candies\") {\n        // Randomly distribute candies\n        int total_candies = rnd.next(1, 1000000);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int max_candies = min(remaining_candies, 1000000);\n                int candies = rnd.next(0, max_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_candies\") {\n        // Randomly distribute candies with total sum near maximum\n        int total_candies = 1000000 - rnd.next(0, n);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int max_candies = min(remaining_candies, 1000000);\n                int candies = rnd.next(0, max_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"zeros_and_ones\") {\n        // Candies are zeros and ones\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0,1);\n        }\n    } else if (type == \"decreasing_sequence\") {\n        // Candies are a decreasing sequence\n        int start_value = min(1000000, n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start_value - i;\n        }\n    } else if (type == \"increasing_sequence\") {\n        // Candies are an increasing sequence\n        int max_candies = min(1000000 / n, 1000);\n        int start_value = rnd.next(0, max_candies);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start_value + i;\n        }\n    } else if (type == \"zeros\") {\n        // All boxes have zero candies\n        for (int i = 0; i < n; ++i) a[i] = 0;\n    } else if (type == \"ones\") {\n        // All boxes have one candy\n        for (int i = 0; i < n; ++i) a[i] = 1;\n    } else if (type == \"min_n\") {\n        n = 3;\n        a.resize(n);\n        // Random candies for n = 3\n        int total_candies = rnd.next(0, 1000000);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int candies = rnd.next(0, remaining_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n    } else if (type == \"max_n\") {\n        n = 1000;\n        a.resize(n);\n        // Random candies for n = 1000\n        int total_candies = 1000000 - rnd.next(0, n);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int candies = rnd.next(0, remaining_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n    } else {\n        // Default to random_candies\n        int total_candies = rnd.next(1, 1000000);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int max_candies = min(remaining_candies, 1000000);\n                int candies = rnd.next(0, max_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n        shuffle(a.begin(), a.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a1 a2 ... an\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"impossible_one_box\") {\n        // All candies are in one box (impossible case)\n        int total_candies = rnd.next(1, 1000000);\n        int box = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) a[i] = 0;\n        a[box] = total_candies;\n    } else if (type == \"exact_two_boxes\") {\n        // Candies are in exactly two boxes\n        int total_candies = rnd.next(1, 1000000);\n        int box1 = rnd.next(0, n - 1);\n        int box2 = rnd.next(0, n - 1);\n        while (box2 == box1) box2 = rnd.next(0, n - 1);\n        int candies1 = rnd.next(1, total_candies - 1);\n        int candies2 = total_candies - candies1;\n        for (int i = 0; i < n; ++i) a[i] = 0;\n        a[box1] = candies1;\n        a[box2] = candies2;\n    } else if (type == \"random_candies\") {\n        // Randomly distribute candies\n        int total_candies = rnd.next(1, 1000000);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int max_candies = min(remaining_candies, 1000000);\n                int candies = rnd.next(0, max_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_candies\") {\n        // Randomly distribute candies with total sum near maximum\n        int total_candies = 1000000 - rnd.next(0, n);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int max_candies = min(remaining_candies, 1000000);\n                int candies = rnd.next(0, max_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"zeros_and_ones\") {\n        // Candies are zeros and ones\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0,1);\n        }\n    } else if (type == \"decreasing_sequence\") {\n        // Candies are a decreasing sequence\n        int start_value = min(1000000, n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start_value - i;\n        }\n    } else if (type == \"increasing_sequence\") {\n        // Candies are an increasing sequence\n        int max_candies = min(1000000 / n, 1000);\n        int start_value = rnd.next(0, max_candies);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start_value + i;\n        }\n    } else if (type == \"zeros\") {\n        // All boxes have zero candies\n        for (int i = 0; i < n; ++i) a[i] = 0;\n    } else if (type == \"ones\") {\n        // All boxes have one candy\n        for (int i = 0; i < n; ++i) a[i] = 1;\n    } else if (type == \"min_n\") {\n        n = 3;\n        a.resize(n);\n        // Random candies for n = 3\n        int total_candies = rnd.next(0, 1000000);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int candies = rnd.next(0, remaining_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n    } else if (type == \"max_n\") {\n        n = 1000;\n        a.resize(n);\n        // Random candies for n = 1000\n        int total_candies = 1000000 - rnd.next(0, n);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int candies = rnd.next(0, remaining_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n    } else {\n        // Default to random_candies\n        int total_candies = rnd.next(1, 1000000);\n        int remaining_candies = total_candies;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                a[i] = remaining_candies;\n            } else {\n                int max_candies = min(remaining_candies, 1000000);\n                int candies = rnd.next(0, max_candies);\n                a[i] = candies;\n                remaining_candies -= candies;\n            }\n        }\n        shuffle(a.begin(), a.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a1 a2 ... an\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type impossible_one_box\n./gen -n 3 -type exact_two_boxes\n./gen -n 3 -type zeros\n./gen -n 3 -type zeros_and_ones\n./gen -n 3 -type ones\n./gen -n 3 -type random_candies\n./gen -n 3 -type max_candies\n./gen -n 3 -type decreasing_sequence\n./gen -n 3 -type increasing_sequence\n./gen -n 3 -type min_n\n\n./gen -n 10 -type impossible_one_box\n./gen -n 10 -type exact_two_boxes\n./gen -n 10 -type zeros\n./gen -n 10 -type zeros_and_ones\n./gen -n 10 -type ones\n./gen -n 10 -type random_candies\n./gen -n 10 -type max_candies\n./gen -n 10 -type decreasing_sequence\n./gen -n 10 -type increasing_sequence\n\n./gen -n 100 -type impossible_one_box\n./gen -n 100 -type exact_two_boxes\n./gen -n 100 -type zeros\n./gen -n 100 -type zeros_and_ones\n./gen -n 100 -type ones\n./gen -n 100 -type random_candies\n./gen -n 100 -type max_candies\n./gen -n 100 -type decreasing_sequence\n./gen -n 100 -type increasing_sequence\n\n./gen -n 500 -type impossible_one_box\n./gen -n 500 -type exact_two_boxes\n./gen -n 500 -type zeros\n./gen -n 500 -type zeros_and_ones\n./gen -n 500 -type ones\n./gen -n 500 -type random_candies\n./gen -n 500 -type max_candies\n./gen -n 500 -type decreasing_sequence\n./gen -n 500 -type increasing_sequence\n\n./gen -n 1000 -type impossible_one_box\n./gen -n 1000 -type exact_two_boxes\n./gen -n 1000 -type zeros\n./gen -n 1000 -type zeros_and_ones\n./gen -n 1000 -type ones\n./gen -n 1000 -type random_candies\n./gen -n 1000 -type max_candies\n./gen -n 1000 -type decreasing_sequence\n./gen -n 1000 -type increasing_sequence\n./gen -n 1000 -type max_n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:10.810523",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "342/A",
      "title": "A. Xenia and Divisors",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (3 ≤ n ≤ 99999) — the number of elements in the sequence. The next line contains n positive integers, each of them is at most 7.It is guaranteed that n is divisible by 3.",
      "output_spec": "OutputIf the required partition exists, print  groups of three. Print each group as values of the elements it contains. You should print values in increasing order. Separate the groups and integers in groups by whitespaces. If there are multiple solutions, you can print any of them.If there is no solution, print -1.",
      "sample_tests": "ExamplesInputCopy61 1 1 2 2 2OutputCopy-1InputCopy62 2 1 1 4 6OutputCopy1 2 41 2 6",
      "description": "A. Xenia and Divisors\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (3 ≤ n ≤ 99999) — the number of elements in the sequence. The next line contains n positive integers, each of them is at most 7.It is guaranteed that n is divisible by 3.\n\nOutputIf the required partition exists, print  groups of three. Print each group as values of the elements it contains. You should print values in increasing order. Separate the groups and integers in groups by whitespaces. If there are multiple solutions, you can print any of them.If there is no solution, print -1.\n\nInputCopy61 1 1 2 2 2OutputCopy-1InputCopy62 2 1 1 4 6OutputCopy1 2 41 2 6\n\nInputCopy61 1 1 2 2 2\n\nOutputCopy-1\n\nInputCopy62 2 1 1 4 6\n\nOutputCopy1 2 41 2 6",
      "solutions": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces",
          "content": "Good day)Welcome to regular Codeforces round #199 for Div.2 participants. As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is standard — 500-1000-1500-2000-2500.We wish everyone good luck, high rating and excellent mood)UPD2: the contest is over, hope you enjoy it)Congratulations to winners:1) chixianglove2) Logvinov_Leon3) Yoshiap4) _moonlight UPD3: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8795",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 666
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces",
          "content": "342A - Xenia and DivisorsIn this problem you should guess that exists only three valid groups of three 1) 1, 2, 4 2) 1, 2, 6 3) 1, 3, 6 (You can see that integers 5 and 7 are bad).So, we will greedy take these groups of three. If some integers will be not used, the answer is -1. In other case, print found answer.342B - Xenia and SpiesThe problem is solved by greedy algorithm. We will pass the note only in correct direction. Also, if we can pass the note at the current moment of time, we do it. In other case, we will hold it and don't give it to neighbors (we can make this action at any moment of time). Obviously this algorithm is correct. You should only implement it carefully.342C - Cupboard and BalloonsIn the problem you should carefully get formula. The optimal solution put marbles by two in a row. And then put one marble upon others if it possible. The most difficulties were to deal with this last phase. In comments to the post were given formulas how to put the last marble (exactly in the middle). And there was a good beautiful illustration, which describes the situation.342D - Xenia and DominoesIn the problem you can count number of correct puzzles or substract number of incorrect puzzles from number of all puzzles. In any case you should count DP, where the state is (j, mask) — j — number of the last full column, mask — mask of the last column. This problem is equivalent to the well known problem about domino tiling or the problem about parquet.To get the solution of the whole problem I did the following. I try to attach one domino to each of 4 directions, then paint all three cells in black and count the number of correct puzzles. But in this case you will count some solutions several number of times. So you need to use inclusion exclusion formula for these 4 directions.342E - Xenia and TreeThe problem can be solved in different ways. The most easy idea is sqrt-optimization. Split all queries into sqrt(m) blocks. Each block we will process separately. Before processing each block, we should calculate minimum distances from every node to the closest red node using bfs. To answer the query we should update this value by shortest distances to red nodes in current block.The solution becomes simple. Every sqrt(m) queries we make simple bfs and for every node v WE calculate value d[v] — the shortest distance to some red node from node v. Then to answer the query of type 2 you should calculate min(d[v], dist(v, u)), where u — every red node, which becomes red in current block of length sqrt(m).Distance between two nodes dist(u, v) can be got using preprocessing for lca.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 342\\s*A"
          },
          "content_length": 2617
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 1",
          "code": "radius of the upper circle+t+radius of the lower circles",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 2",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 3",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 4",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 5",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "dist(u, v) = dist(root, u) + dist(root, v) - 2 * dist(root, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "rootDist[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "sparse[u][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "sparse[u][0] = parent[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dist[v] = Distance from v to the nearest red node, 0 if v is itself red",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dist[v] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "dist[u] = 1, isdiscovered[u] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "dist[y] = dist[w] +1, isdiscovered[y] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 99999, \"n\");\n    ensuref(n % 3 == 0, \"n must be divisible by 3\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 7, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 99999, \"n\");\n    ensuref(n % 3 == 0, \"n must be divisible by 3\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 7, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 99999, \"n\");\n    ensuref(n % 3 == 0, \"n must be divisible by 3\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 7, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint cnt_input[8];\nint cnt_participant[8];\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(3, 99999, \"n\");\n    if (n % 3 != 0)\n        quitf(_fail, \"n is not divisible by 3\");\n\n    // Read input numbers and count occurrences\n    memset(cnt_input, 0, sizeof(cnt_input));\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(1,7, format(\"a[%d]\", i+1).c_str());\n        cnt_input[x]++;\n    }\n\n    // Read participant's output\n    if (ouf.seekEof())\n        quitf(_wa, \"participant output is empty\");\n\n    string firstToken = ouf.readToken();\n    if (firstToken == \"-1\") {\n        // Participant claims no valid partition exists\n        // Now we need to check whether a valid partition can be made\n        // Copy counts from input\n        int cnt[8];\n        memcpy(cnt, cnt_input, sizeof(cnt));\n\n        vector<vector<int>> triplets;\n        bool possible = true;\n\n        while (true) {\n            if (cnt[1] > 0 && cnt[2] > 0 && cnt[4] > 0) {\n                cnt[1]--; cnt[2]--; cnt[4]--;\n                triplets.push_back({1, 2, 4});\n            } else if (cnt[1] > 0 && cnt[2] > 0 && cnt[6] > 0) {\n                cnt[1]--; cnt[2]--; cnt[6]--;\n                triplets.push_back({1, 2, 6});\n            } else if (cnt[1] > 0 && cnt[3] > 0 && cnt[6] > 0) {\n                cnt[1]--; cnt[3]--; cnt[6]--;\n                triplets.push_back({1, 3, 6});\n            } else {\n                break;\n            }\n        }\n\n        // Check for remaining counts\n        for (int i = 1; i <= 7; ++i) {\n            if (cnt[i] > 0) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (possible)\n            quitf(_wa, \"participant claims impossible, but a valid partition exists\");\n        else\n            quitf(_ok, \"correctly claimed no valid partition exists\");\n    } else {\n        // Participant provides a partition\n        // Rewind to first token\n        ouf.reset();\n\n        vector<int> participant_numbers;\n        while (!ouf.seekEof()) {\n            int x = ouf.readInt(1, 7, \"number\");\n            participant_numbers.push_back(x);\n        }\n\n        if (participant_numbers.size() != n)\n            quitf(_wa, \"expected %d numbers, but found %d numbers\", n, participant_numbers.size());\n\n        memset(cnt_participant, 0, sizeof(cnt_participant));\n        for (size_t i = 0; i < participant_numbers.size(); ++i) {\n            int x = participant_numbers[i];\n            if (x < 1 || x > 7)\n                quitf(_wa, \"number %d is out of valid range\", x);\n            cnt_participant[x]++;\n        }\n\n        // Check counts match\n        for (int i = 1; i <= 7; ++i) {\n            if (cnt_participant[i] != cnt_input[i])\n                quitf(_wa, \"count of number %d doesn't match input: expected %d, found %d\", \n                      i, cnt_input[i], cnt_participant[i]);\n        }\n\n        if (participant_numbers.size() % 3 != 0)\n            quitf(_wa, \"number of elements is not divisible by 3\");\n\n        for (size_t i = 0; i < participant_numbers.size(); i +=3) {\n            int a = participant_numbers[i];\n            int b = participant_numbers[i+1];\n            int c = participant_numbers[i+2];\n\n            if (!(a < b && b < c))\n                quitf(_wa, \"group %d elements are not in increasing order or not unique: %d %d %d\",\n                      (int)(i/3)+1, a, b, c);\n\n            if (b % a != 0)\n                quitf(_wa, \"in group %d, %d doesn't divide %d\", (int)(i/3)+1, a, b);\n            if (c % b != 0)\n                quitf(_wa, \"in group %d, %d doesn't divide %d\", (int)(i/3)+1, b, c);\n\n            // Check that the group is one of the valid triplets\n            if (!((a ==1 && b==2 && c==4) || \n                  (a==1 && b==2 && c==6) ||\n                  (a==1 && b==3 && c==6)))\n                quitf(_wa, \"group %d is not a valid triplet: %d %d %d\", \n                      (int)(i/3)+1, a, b, c);\n        }\n\n        quitf(_ok, \"found valid partition with %d groups\", n/3);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid\");\n\n    if (n % 3 != 0) {\n        fprintf(stderr, \"n must be divisible by 3\\n\");\n        exit(1);\n    }\n\n    vector<int> numbers;\n\n    if (type == \"valid\") {\n        // Generate a valid sequence where the partition is possible\n        int numTriplets = n / 3;\n\n        for(int i = 0; i < numTriplets; ++i) {\n            int tripletType = rnd.next(1, 4); // 1 to 4\n\n            if(tripletType == 1) {\n                // Triplet (1,2,4)\n                numbers.push_back(1);\n                numbers.push_back(2);\n                numbers.push_back(4);\n            } else if(tripletType == 2) {\n                // Triplet (1,2,6)\n                numbers.push_back(1);\n                numbers.push_back(2);\n                numbers.push_back(6);\n            } else if(tripletType == 3) {\n                // Triplet (1,3,6)\n                numbers.push_back(1);\n                numbers.push_back(3);\n                numbers.push_back(6);\n            } else {\n                // Triplet (2,4,6)\n                numbers.push_back(2);\n                numbers.push_back(4);\n                numbers.push_back(6);\n            }\n        }\n\n        // Shuffle the numbers\n        shuffle(numbers.begin(), numbers.end());\n\n    } else if (type == \"invalid_extra_numbers\") {\n        // Generate an invalid test case by including numbers 5 or 7\n        int numTriplets = n / 3;\n        for(int i = 0; i < numTriplets; ++i) {\n            int tripletType = rnd.next(1, 5); // 1 to 5\n\n            if(tripletType <= 4) {\n                // Valid triplets\n                if(tripletType == 1) {\n                    numbers.push_back(1);\n                    numbers.push_back(2);\n                    numbers.push_back(4);\n                } else if(tripletType == 2) {\n                    numbers.push_back(1);\n                    numbers.push_back(2);\n                    numbers.push_back(6);\n                } else if(tripletType == 3) {\n                    numbers.push_back(1);\n                    numbers.push_back(3);\n                    numbers.push_back(6);\n                } else {\n                    numbers.push_back(2);\n                    numbers.push_back(4);\n                    numbers.push_back(6);\n                }\n            } else {\n                // Invalid triplet including number 5 or 7\n                numbers.push_back(1);\n                numbers.push_back(5);\n                numbers.push_back(7);\n            }\n        }\n\n        // Shuffle the numbers\n        shuffle(numbers.begin(), numbers.end());\n\n    } else if (type == \"invalid_impossible_counts\") {\n        // Generate counts that cannot be matched into triplets\n        int cnt1 = n / 3;\n        int cnt2 = n / 3 - 1;\n        int cnt3 = 0;\n        int cnt4 = n / 3 + 1;\n        int cnt6 = n / 3;\n\n        // Counts designed to be impossible to form valid triplets\n        for(int i = 0; i < cnt1; ++i) numbers.push_back(1);\n        for(int i = 0; i < cnt2; ++i) numbers.push_back(2);\n        for(int i = 0; i < cnt3; ++i) numbers.push_back(3);\n        for(int i = 0; i < cnt4; ++i) numbers.push_back(4);\n        for(int i = 0; i < cnt6; ++i) numbers.push_back(6);\n\n        // Shuffle the numbers\n        shuffle(numbers.begin(), numbers.end());\n\n    } else if (type == \"random\") {\n        // Generate random numbers in [1,7]\n        for(int i = 0; i < n; ++i) {\n            int x = rnd.next(1, 7);\n            numbers.push_back(x);\n        }\n\n    } else if (type == \"min\") {\n        // Minimum valid test case\n        n = 3;\n        printf(\"%d\\n\", n);\n        numbers.push_back(1);\n        numbers.push_back(2);\n        numbers.push_back(6);\n\n    } else if (type == \"max\") {\n        // Maximum test case with numbers equal to 7\n        n = 99999;\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            numbers.push_back(7);\n        }\n\n    } else if (type == \"edge\") {\n        // Edge case with n = 3 and a valid triplet\n        n = 3;\n        numbers.push_back(1);\n        numbers.push_back(2);\n        numbers.push_back(6);\n\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n if not already printed\n    if(type != \"min\" && type != \"max\" && type != \"edge\") {\n        printf(\"%d\\n\", n);\n    }\n\n    // Output the numbers\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", numbers[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid\");\n\n    if (n % 3 != 0) {\n        fprintf(stderr, \"n must be divisible by 3\\n\");\n        exit(1);\n    }\n\n    vector<int> numbers;\n\n    if (type == \"valid\") {\n        // Generate a valid sequence where the partition is possible\n        int numTriplets = n / 3;\n\n        for(int i = 0; i < numTriplets; ++i) {\n            int tripletType = rnd.next(1, 4); // 1 to 4\n\n            if(tripletType == 1) {\n                // Triplet (1,2,4)\n                numbers.push_back(1);\n                numbers.push_back(2);\n                numbers.push_back(4);\n            } else if(tripletType == 2) {\n                // Triplet (1,2,6)\n                numbers.push_back(1);\n                numbers.push_back(2);\n                numbers.push_back(6);\n            } else if(tripletType == 3) {\n                // Triplet (1,3,6)\n                numbers.push_back(1);\n                numbers.push_back(3);\n                numbers.push_back(6);\n            } else {\n                // Triplet (2,4,6)\n                numbers.push_back(2);\n                numbers.push_back(4);\n                numbers.push_back(6);\n            }\n        }\n\n        // Shuffle the numbers\n        shuffle(numbers.begin(), numbers.end());\n\n    } else if (type == \"invalid_extra_numbers\") {\n        // Generate an invalid test case by including numbers 5 or 7\n        int numTriplets = n / 3;\n        for(int i = 0; i < numTriplets; ++i) {\n            int tripletType = rnd.next(1, 5); // 1 to 5\n\n            if(tripletType <= 4) {\n                // Valid triplets\n                if(tripletType == 1) {\n                    numbers.push_back(1);\n                    numbers.push_back(2);\n                    numbers.push_back(4);\n                } else if(tripletType == 2) {\n                    numbers.push_back(1);\n                    numbers.push_back(2);\n                    numbers.push_back(6);\n                } else if(tripletType == 3) {\n                    numbers.push_back(1);\n                    numbers.push_back(3);\n                    numbers.push_back(6);\n                } else {\n                    numbers.push_back(2);\n                    numbers.push_back(4);\n                    numbers.push_back(6);\n                }\n            } else {\n                // Invalid triplet including number 5 or 7\n                numbers.push_back(1);\n                numbers.push_back(5);\n                numbers.push_back(7);\n            }\n        }\n\n        // Shuffle the numbers\n        shuffle(numbers.begin(), numbers.end());\n\n    } else if (type == \"invalid_impossible_counts\") {\n        // Generate counts that cannot be matched into triplets\n        int cnt1 = n / 3;\n        int cnt2 = n / 3 - 1;\n        int cnt3 = 0;\n        int cnt4 = n / 3 + 1;\n        int cnt6 = n / 3;\n\n        // Counts designed to be impossible to form valid triplets\n        for(int i = 0; i < cnt1; ++i) numbers.push_back(1);\n        for(int i = 0; i < cnt2; ++i) numbers.push_back(2);\n        for(int i = 0; i < cnt3; ++i) numbers.push_back(3);\n        for(int i = 0; i < cnt4; ++i) numbers.push_back(4);\n        for(int i = 0; i < cnt6; ++i) numbers.push_back(6);\n\n        // Shuffle the numbers\n        shuffle(numbers.begin(), numbers.end());\n\n    } else if (type == \"random\") {\n        // Generate random numbers in [1,7]\n        for(int i = 0; i < n; ++i) {\n            int x = rnd.next(1, 7);\n            numbers.push_back(x);\n        }\n\n    } else if (type == \"min\") {\n        // Minimum valid test case\n        n = 3;\n        printf(\"%d\\n\", n);\n        numbers.push_back(1);\n        numbers.push_back(2);\n        numbers.push_back(6);\n\n    } else if (type == \"max\") {\n        // Maximum test case with numbers equal to 7\n        n = 99999;\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            numbers.push_back(7);\n        }\n\n    } else if (type == \"edge\") {\n        // Edge case with n = 3 and a valid triplet\n        n = 3;\n        numbers.push_back(1);\n        numbers.push_back(2);\n        numbers.push_back(6);\n\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n if not already printed\n    if(type != \"min\" && type != \"max\" && type != \"edge\") {\n        printf(\"%d\\n\", n);\n    }\n\n    // Output the numbers\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", numbers[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 6 -type valid\n./gen -n 6 -type invalid_extra_numbers\n./gen -n 6 -type invalid_impossible_counts\n./gen -n 6 -type random\n./gen -n 6 -type edge\n\n./gen -n 9 -type valid\n./gen -n 9 -type invalid_extra_numbers\n./gen -n 9 -type invalid_impossible_counts\n./gen -n 9 -type random\n\n./gen -n 12 -type valid\n./gen -n 12 -type invalid_extra_numbers\n./gen -n 12 -type invalid_impossible_counts\n./gen -n 12 -type random\n\n./gen -n 99999 -type valid\n./gen -n 99999 -type invalid_extra_numbers\n./gen -n 99999 -type invalid_impossible_counts\n./gen -n 99999 -type random\n\n./gen -n 99999 -type max\n./gen -n 3 -type min\n\n# Edge cases\n./gen -n 3 -type edge\n./gen -n 99999 -type edge\n\n# Random n values\n./gen -n 30000 -type valid\n./gen -n 60000 -type invalid_extra_numbers\n./gen -n 90000 -type invalid_impossible_counts\n./gen -n 30000 -type random\n\n# Small n values\n./gen -n 3 -type valid\n./gen -n 3 -type invalid_extra_numbers\n./gen -n 3 -type invalid_impossible_counts\n./gen -n 3 -type random\n\n# Mid-range n values\n./gen -n 15000 -type valid\n./gen -n 15000 -type invalid_extra_numbers\n./gen -n 15000 -type invalid_impossible_counts\n./gen -n 15000 -type random\n\n# Repeated runs to generate different random test cases\n./gen -n 99999 -type random\n./gen -n 99999 -type random\n./gen -n 99999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:12.486046",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "342/B",
      "title": "B. Xenia and Spies",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers n, m, s and f (1 ≤ n, m ≤ 105; 1 ≤ s, f ≤ n; s ≠ f; n ≥ 2). Each of the following m lines contains three integers ti, li, ri (1 ≤ ti ≤ 109, 1 ≤ li ≤ ri ≤ n). It is guaranteed that t1 < t2 < t3 < ... < tm.",
      "output_spec": "OutputPrint k characters in a line: the i-th character in the line must represent the spies' actions on step i. If on step i the spy with the note must pass the note to the spy with a lesser number, the i-th character should equal \"L\". If on step i the spy with the note must pass it to the spy with a larger number, the i-th character must equal \"R\". If the spy must keep the note at the i-th step, the i-th character must equal \"X\".As a result of applying the printed sequence of actions spy s must pass the note to spy f. The number of printed characters k must be as small as possible. Xenia must not catch the spies passing the note.If there are miltiple optimal solutions, you can print any of them. It is guaranteed that the answer exists.",
      "sample_tests": "ExamplesInputCopy3 5 1 31 1 22 2 33 3 34 1 110 1 3OutputCopyXXRR",
      "description": "B. Xenia and Spies\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four integers n, m, s and f (1 ≤ n, m ≤ 105; 1 ≤ s, f ≤ n; s ≠ f; n ≥ 2). Each of the following m lines contains three integers ti, li, ri (1 ≤ ti ≤ 109, 1 ≤ li ≤ ri ≤ n). It is guaranteed that t1 < t2 < t3 < ... < tm.\n\nOutputPrint k characters in a line: the i-th character in the line must represent the spies' actions on step i. If on step i the spy with the note must pass the note to the spy with a lesser number, the i-th character should equal \"L\". If on step i the spy with the note must pass it to the spy with a larger number, the i-th character must equal \"R\". If the spy must keep the note at the i-th step, the i-th character must equal \"X\".As a result of applying the printed sequence of actions spy s must pass the note to spy f. The number of printed characters k must be as small as possible. Xenia must not catch the spies passing the note.If there are miltiple optimal solutions, you can print any of them. It is guaranteed that the answer exists.\n\nInputCopy3 5 1 31 1 22 2 33 3 34 1 110 1 3OutputCopyXXRR\n\nInputCopy3 5 1 31 1 22 2 33 3 34 1 110 1 3\n\nOutputCopyXXRR",
      "solutions": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces",
          "content": "Good day)Welcome to regular Codeforces round #199 for Div.2 participants. As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is standard — 500-1000-1500-2000-2500.We wish everyone good luck, high rating and excellent mood)UPD2: the contest is over, hope you enjoy it)Congratulations to winners:1) chixianglove2) Logvinov_Leon3) Yoshiap4) _moonlight UPD3: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8795",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 666
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces",
          "content": "342A - Xenia and DivisorsIn this problem you should guess that exists only three valid groups of three 1) 1, 2, 4 2) 1, 2, 6 3) 1, 3, 6 (You can see that integers 5 and 7 are bad).So, we will greedy take these groups of three. If some integers will be not used, the answer is -1. In other case, print found answer.342B - Xenia and SpiesThe problem is solved by greedy algorithm. We will pass the note only in correct direction. Also, if we can pass the note at the current moment of time, we do it. In other case, we will hold it and don't give it to neighbors (we can make this action at any moment of time). Obviously this algorithm is correct. You should only implement it carefully.342C - Cupboard and BalloonsIn the problem you should carefully get formula. The optimal solution put marbles by two in a row. And then put one marble upon others if it possible. The most difficulties were to deal with this last phase. In comments to the post were given formulas how to put the last marble (exactly in the middle). And there was a good beautiful illustration, which describes the situation.342D - Xenia and DominoesIn the problem you can count number of correct puzzles or substract number of incorrect puzzles from number of all puzzles. In any case you should count DP, where the state is (j, mask) — j — number of the last full column, mask — mask of the last column. This problem is equivalent to the well known problem about domino tiling or the problem about parquet.To get the solution of the whole problem I did the following. I try to attach one domino to each of 4 directions, then paint all three cells in black and count the number of correct puzzles. But in this case you will count some solutions several number of times. So you need to use inclusion exclusion formula for these 4 directions.342E - Xenia and TreeThe problem can be solved in different ways. The most easy idea is sqrt-optimization. Split all queries into sqrt(m) blocks. Each block we will process separately. Before processing each block, we should calculate minimum distances from every node to the closest red node using bfs. To answer the query we should update this value by shortest distances to red nodes in current block.The solution becomes simple. Every sqrt(m) queries we make simple bfs and for every node v WE calculate value d[v] — the shortest distance to some red node from node v. Then to answer the query of type 2 you should calculate min(d[v], dist(v, u)), where u — every red node, which becomes red in current block of length sqrt(m).Distance between two nodes dist(u, v) can be got using preprocessing for lca.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 342\\s*B"
          },
          "content_length": 2617
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 1",
          "code": "radius of the upper circle+t+radius of the lower circles",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 2",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 3",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 4",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 5",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "dist(u, v) = dist(root, u) + dist(root, v) - 2 * dist(root, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "rootDist[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "sparse[u][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "sparse[u][0] = parent[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dist[v] = Distance from v to the nearest red node, 0 if v is itself red",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dist[v] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "dist[u] = 1, isdiscovered[u] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "dist[y] = dist[w] +1, isdiscovered[y] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int f = inf.readInt(1, n, \"f\");\n    inf.readEoln();\n\n    ensuref(s != f, \"s (%d) should not be equal to f (%d)\", s, f);\n\n    int prev_ti = 0;\n    for (int i = 0; i < m; i++) {\n        int t_i = inf.readInt(1, 1000000000, format(\"t[%d]\", i + 1));\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, format(\"l[%d]\", i + 1));\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, format(\"r[%d]\", i + 1));\n        inf.readEoln();\n\n        ensuref(t_i > prev_ti, \"t[%d]=%d should be greater than t[%d]=%d\", i + 1, t_i, i, prev_ti);\n\n        prev_ti = t_i;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int f = inf.readInt(1, n, \"f\");\n    inf.readEoln();\n\n    ensuref(s != f, \"s (%d) should not be equal to f (%d)\", s, f);\n\n    int prev_ti = 0;\n    for (int i = 0; i < m; i++) {\n        int t_i = inf.readInt(1, 1000000000, format(\"t[%d]\", i + 1));\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, format(\"l[%d]\", i + 1));\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, format(\"r[%d]\", i + 1));\n        inf.readEoln();\n\n        ensuref(t_i > prev_ti, \"t[%d]=%d should be greater than t[%d]=%d\", i + 1, t_i, i, prev_ti);\n\n        prev_ti = t_i;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int f = inf.readInt(1, n, \"f\");\n    inf.readEoln();\n\n    ensuref(s != f, \"s (%d) should not be equal to f (%d)\", s, f);\n\n    int prev_ti = 0;\n    for (int i = 0; i < m; i++) {\n        int t_i = inf.readInt(1, 1000000000, format(\"t[%d]\", i + 1));\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, format(\"l[%d]\", i + 1));\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, format(\"r[%d]\", i + 1));\n        inf.readEoln();\n\n        ensuref(t_i > prev_ti, \"t[%d]=%d should be greater than t[%d]=%d\", i + 1, t_i, i, prev_ti);\n\n        prev_ti = t_i;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We will store each watch interval as {t, l, r}, meaning on step t,\n// Xenia watches spies in the range [l, r].\nstruct Watch {\n    long long t;\n    int l, r;\n};\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read problem input from inf\n    long long n = inf.readLong();\n    long long m = inf.readLong();\n    long long s = inf.readLong();\n    long long f = inf.readLong();\n\n    // Read the watch intervals\n    vector<Watch> watches(m);\n    for (int i = 0; i < m; i++) {\n        watches[i].t = inf.readLong();\n        watches[i].l = inf.readInt();\n        watches[i].r = inf.readInt();\n    }\n\n    // For convenience, sort by t (though problem statement already guarantees t1 < t2 < ... < tm).\n    // Just to be sure:\n    sort(watches.begin(), watches.end(), [](auto &a, auto &b) {\n        return a.t < b.t;\n    });\n\n    // Read participant's answer as a string of actions\n    // It can have arbitrary length, so read a line.\n    // (We allow spaces in between or not, but typically a single token suffices.)\n    // We'll read the entire line from ouf and remove spaces.\n    string actionsRaw = ouf.readToken(); \n    // The above reads one contiguous token (no internal spaces). \n    // If the participant used spaces or line breaks, they'd become separate tokens \n    // and we could read them all and concatenate, but usually contest solutions do not do that.\n    // If they did, we'd read them in a loop. Here we assume a single token is enough.\n\n    // We'll simulate the participant's solution and ensure it obeys the watchers\n    // and ends exactly at spy f, with no extra steps, and check minimality.\n    long long pos = s;            // current holder's position\n    long long step = 0;          // step counter for participant's moves\n    int idxWatch = 0;            // index into watchers\n\n    // Simulate passing the note\n    for (char c : actionsRaw) {\n        // If we've already reached f, any extra actions are not minimal\n        if (pos == f) {\n            ouf.quitf(_wa, \"The note reached spy %lld before the end of the output (extra moves).\", f);\n        }\n\n        step += 1; // Next step\n        // Check whether there is a watch at this step\n        bool watching = false;\n        int L = -1, R = -1;\n        while (idxWatch < (int)m && watches[idxWatch].t == step) {\n            watching = true;\n            L = watches[idxWatch].l;\n            R = watches[idxWatch].r;\n            idxWatch++;\n        }\n\n        // Process the action\n        if (c == 'X') {\n            // \"Keep\" action is always valid (even if watched).\n            // No position change.\n        }\n        else if (c == 'R') {\n            if (pos == n) {\n                ouf.quitf(_wa, \"Trying to move right from the rightmost spy %lld.\", n);\n            }\n            // If watched, neither the spy with note nor neighbor can be in [L, R].\n            if (watching) {\n                if ((pos >= L && pos <= R) || (pos + 1 >= L && pos + 1 <= R)) {\n                    ouf.quitf(_wa, \"Passing to the right is blocked by watchers at step %lld.\", step);\n                }\n            }\n            // Move right\n            pos++;\n        }\n        else if (c == 'L') {\n            if (pos == 1) {\n                ouf.quitf(_wa, \"Trying to move left from the leftmost spy 1.\");\n            }\n            if (watching) {\n                if ((pos >= L && pos <= R) || (pos - 1 >= L && pos - 1 <= R)) {\n                    ouf.quitf(_wa, \"Passing to the left is blocked by watchers at step %lld.\", step);\n                }\n            }\n            // Move left\n            pos--;\n        }\n        else {\n            ouf.quitf(_wa, \"Invalid character '%c' in output (only X, L, R allowed).\", c);\n        }\n    }\n\n    // After all actions, we must end at spy f\n    if (pos != f) {\n        ouf.quitf(_wa, \"The note did not reach spy %lld (ended at %lld).\", f, pos);\n    }\n\n    // The participant used 'step' steps. If that is not minimal, it's WA.\n    long long usedSteps = step;\n\n    // Now compute the minimal number of steps K_min with a direct simulation.\n    // If s < f, the best direction is +1, if s > f, the best direction is -1.\n    // We skip exactly when watchers block passing. That yields the minimal solution length.\n    long long dir = (f > s ? 1 : -1);\n    long long posMin = s;\n    long long stepMin = 0;\n    int idxWMin = 0; // watchers pointer for minimal simulation\n\n    while (posMin != f) {\n        stepMin++;\n        // Check if watchers block this step\n        bool wActive = false;\n        int lBlk = -1, rBlk = -1;\n\n        // If watchers[idxWMin] has time == stepMin, read it\n        while (idxWMin < (int)m && watches[idxWMin].t == stepMin) {\n            wActive = true;\n            lBlk = watches[idxWMin].l;\n            rBlk = watches[idxWMin].r;\n            idxWMin++;\n        }\n\n        // Decide whether we can move or not\n        long long nxt = posMin + dir;\n        // Check boundaries\n        if (nxt < 1 || nxt > n) {\n            // Should never actually happen in a minimal route from s to f\n            // but let's be consistent: can't move out of range.\n            // So skip stay still\n            continue;\n        }\n\n        // If watchers block either posMin or nxt, we must skip\n        bool blocked = false;\n        if (wActive) {\n            if ((posMin >= lBlk && posMin <= rBlk) || (nxt >= lBlk && nxt <= rBlk)) {\n                blocked = true;\n            }\n        }\n\n        // If not blocked, move\n        if (!blocked) {\n            posMin = nxt;\n        }\n    }\n\n    long long K_min = stepMin;\n\n    if (usedSteps != K_min) {\n        ouf.quitf(_wa,\n                  \"Solution is not minimal. Your steps = %lld, minimal steps = %lld.\",\n                  usedSteps, K_min);\n    }\n\n    // Everything is correct\n    quitf(_ok, \"Correct minimal solution of length %lld.\", usedSteps);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    int f = opt<int>(\"f\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", 0);\n    int tmax = opt<int>(\"tmax\", 1e9);\n\n    // Ensure constraints\n    ensure(s != f);\n    ensure(1 <= s && s <= n);\n    ensure(1 <= f && f <= n);\n    ensure(1 <= n && n <= 100000);\n    ensure(0 <= m && m <= 100000);\n\n    vector<int> ti;\n    vector<int> li;\n    vector<int> ri;\n\n    if (type == \"random\") {\n        // Generate m random watches\n        ensure(m >= 0);\n        if (m > 0) {\n            set<int> t_set;\n            while ((int)t_set.size() < m) {\n                int t = rnd.next(1, tmax);\n                t_set.insert(t);\n            }\n            ti.assign(t_set.begin(), t_set.end());\n            sort(ti.begin(), ti.end());\n            for (int i = 0; i < m; ++i) {\n                int l = rnd.next(1, n);\n                int r = rnd.next(l, n);\n                li.push_back(l);\n                ri.push_back(r);\n            }\n        }\n    } else if (type == \"blocked_path\") {\n        // Generate watches that force the spy to wait at certain steps\n        int steps_needed = abs(f - s);\n        m = steps_needed; // We can watch the spy's current position at certain times\n\n        ti.resize(m);\n        li.resize(m);\n        ri.resize(m);\n\n        int t_current = 1;\n        int pos = s;\n        int dir = (f > s) ? 1 : -1;\n\n        // For each move, we make the spy wait an extra step\n        for (int i = 0; i < steps_needed; ++i) {\n            ti[i] = t_current;\n            li[i] = pos;\n            ri[i] = pos;\n\n            t_current += 2; // Spy can move on the next step\n            pos += dir;\n        }\n    } else if (type == \"no_watches\") {\n        // m = 0\n        m = 0;\n    } else if (type == \"max_moves\") {\n        // We try to maximize the number of steps\n        // We create watches to prevent the spy from moving as much as possible\n\n        int max_steps = min(tmax, 1000000); // limit the maximum number of steps\n        // We'll create watches at all steps except when the spy can move\n\n        vector<bool> is_watched(max_steps + 1, true);\n        int pos = s;\n        int dir = (f > s) ? 1 : -1;\n        int steps_needed = abs(f - s);\n        int steps_taken = 0;\n        int t_current = 1;\n\n        while (steps_taken < steps_needed && t_current <= max_steps) {\n            // The spies can move only when not watched\n            // We need to find steps where the spy can move\n            is_watched[t_current] = false; // The spy moves at this time\n\n            steps_taken++;\n            t_current++;\n            // Next, we watch the spy to prevent further movement\n            if (t_current <= max_steps) {\n                is_watched[t_current] = true;\n                t_current++;\n            }\n        }\n\n        // Now, we set 'm' and create 'ti', 'li', 'ri'\n        // Collect all the times when is_watched[t] == true\n\n        m = 0;\n        for (int t = 1; t <= t_current; ++t) {\n            if (is_watched[t]) m++;\n        }\n\n        ti.reserve(m);\n        li.reserve(m);\n        ri.reserve(m);\n\n        for (int t = 1; t <= t_current; ++t) {\n            if (is_watched[t]) {\n                ti.push_back(t);\n                li.push_back(1);\n                ri.push_back(n);\n            }\n        }\n    } else if (type == \"minimal_moves\") {\n        // Minimal moves, watches don't interfere\n        ensure(m >= 0);\n        if (m > 0) {\n            ti.resize(m);\n            li.resize(m);\n            ri.resize(m);\n            set<int> t_set;\n            while ((int)t_set.size() < m) {\n                int t = rnd.next(1, tmax);\n                t_set.insert(t);\n            }\n            ti.assign(t_set.begin(), t_set.end());\n            sort(ti.begin(), ti.end());\n            for (int i = 0; i < m; ++i) {\n                // Watch spies not on the path between s and f\n                int l, r;\n                if (s < f) {\n                    // Path is s to f\n                    if (n > f) {\n                        l = f + 1;\n                        r = n;\n                    } else if (s > 1) {\n                        l = 1;\n                        r = s - 1;\n                    } else {\n                        l = 1;\n                        r = 1;\n                    }\n                } else {\n                    // s > f\n                    if (f > 1) {\n                        l = 1;\n                        r = f - 1;\n                    } else if (s < n) {\n                        l = s +1;\n                        r = n;\n                    } else {\n                        l = n;\n                        r = n;\n                    }\n                }\n                if (l <= r) {\n                    li[i] = l;\n                    ri[i] = r;\n                } else {\n                    li[i] = ri[i] = s; // No valid interval, watch the starting spy\n                }\n            }\n        }\n    } else {\n        // other types can be implemented similarly\n    }\n\n    // Output n, m, s, f\n    printf(\"%d %d %d %d\\n\", n, m, s, f);\n\n    // Output the m watches\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", ti[i], li[i], ri[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    int f = opt<int>(\"f\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", 0);\n    int tmax = opt<int>(\"tmax\", 1e9);\n\n    // Ensure constraints\n    ensure(s != f);\n    ensure(1 <= s && s <= n);\n    ensure(1 <= f && f <= n);\n    ensure(1 <= n && n <= 100000);\n    ensure(0 <= m && m <= 100000);\n\n    vector<int> ti;\n    vector<int> li;\n    vector<int> ri;\n\n    if (type == \"random\") {\n        // Generate m random watches\n        ensure(m >= 0);\n        if (m > 0) {\n            set<int> t_set;\n            while ((int)t_set.size() < m) {\n                int t = rnd.next(1, tmax);\n                t_set.insert(t);\n            }\n            ti.assign(t_set.begin(), t_set.end());\n            sort(ti.begin(), ti.end());\n            for (int i = 0; i < m; ++i) {\n                int l = rnd.next(1, n);\n                int r = rnd.next(l, n);\n                li.push_back(l);\n                ri.push_back(r);\n            }\n        }\n    } else if (type == \"blocked_path\") {\n        // Generate watches that force the spy to wait at certain steps\n        int steps_needed = abs(f - s);\n        m = steps_needed; // We can watch the spy's current position at certain times\n\n        ti.resize(m);\n        li.resize(m);\n        ri.resize(m);\n\n        int t_current = 1;\n        int pos = s;\n        int dir = (f > s) ? 1 : -1;\n\n        // For each move, we make the spy wait an extra step\n        for (int i = 0; i < steps_needed; ++i) {\n            ti[i] = t_current;\n            li[i] = pos;\n            ri[i] = pos;\n\n            t_current += 2; // Spy can move on the next step\n            pos += dir;\n        }\n    } else if (type == \"no_watches\") {\n        // m = 0\n        m = 0;\n    } else if (type == \"max_moves\") {\n        // We try to maximize the number of steps\n        // We create watches to prevent the spy from moving as much as possible\n\n        int max_steps = min(tmax, 1000000); // limit the maximum number of steps\n        // We'll create watches at all steps except when the spy can move\n\n        vector<bool> is_watched(max_steps + 1, true);\n        int pos = s;\n        int dir = (f > s) ? 1 : -1;\n        int steps_needed = abs(f - s);\n        int steps_taken = 0;\n        int t_current = 1;\n\n        while (steps_taken < steps_needed && t_current <= max_steps) {\n            // The spies can move only when not watched\n            // We need to find steps where the spy can move\n            is_watched[t_current] = false; // The spy moves at this time\n\n            steps_taken++;\n            t_current++;\n            // Next, we watch the spy to prevent further movement\n            if (t_current <= max_steps) {\n                is_watched[t_current] = true;\n                t_current++;\n            }\n        }\n\n        // Now, we set 'm' and create 'ti', 'li', 'ri'\n        // Collect all the times when is_watched[t] == true\n\n        m = 0;\n        for (int t = 1; t <= t_current; ++t) {\n            if (is_watched[t]) m++;\n        }\n\n        ti.reserve(m);\n        li.reserve(m);\n        ri.reserve(m);\n\n        for (int t = 1; t <= t_current; ++t) {\n            if (is_watched[t]) {\n                ti.push_back(t);\n                li.push_back(1);\n                ri.push_back(n);\n            }\n        }\n    } else if (type == \"minimal_moves\") {\n        // Minimal moves, watches don't interfere\n        ensure(m >= 0);\n        if (m > 0) {\n            ti.resize(m);\n            li.resize(m);\n            ri.resize(m);\n            set<int> t_set;\n            while ((int)t_set.size() < m) {\n                int t = rnd.next(1, tmax);\n                t_set.insert(t);\n            }\n            ti.assign(t_set.begin(), t_set.end());\n            sort(ti.begin(), ti.end());\n            for (int i = 0; i < m; ++i) {\n                // Watch spies not on the path between s and f\n                int l, r;\n                if (s < f) {\n                    // Path is s to f\n                    if (n > f) {\n                        l = f + 1;\n                        r = n;\n                    } else if (s > 1) {\n                        l = 1;\n                        r = s - 1;\n                    } else {\n                        l = 1;\n                        r = 1;\n                    }\n                } else {\n                    // s > f\n                    if (f > 1) {\n                        l = 1;\n                        r = f - 1;\n                    } else if (s < n) {\n                        l = s +1;\n                        r = n;\n                    } else {\n                        l = n;\n                        r = n;\n                    }\n                }\n                if (l <= r) {\n                    li[i] = l;\n                    ri[i] = r;\n                } else {\n                    li[i] = ri[i] = s; // No valid interval, watch the starting spy\n                }\n            }\n        }\n    } else {\n        // other types can be implemented similarly\n    }\n\n    // Output n, m, s, f\n    printf(\"%d %d %d %d\\n\", n, m, s, f);\n\n    // Output the m watches\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", ti[i], li[i], ri[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -s 1 -f 5 -type no_watches\n./gen -n 5 -s 5 -f 1 -type no_watches\n./gen -n 5 -s 2 -f 4 -type random -m 2\n./gen -n 10 -s 1 -f 10 -type blocked_path\n./gen -n 10 -s 10 -f 1 -type blocked_path\n./gen -n 50 -s 25 -f 50 -type max_moves\n./gen -n 100 -s 100 -f 1 -type max_moves\n./gen -n 1000 -s 1 -f 1000 -type random -m 200\n./gen -n 1000 -s 500 -f 950 -type minimal_moves -m 100\n./gen -n 10000 -s 10000 -f 1 -type blocked_path\n./gen -n 100000 -s 1 -f 100000 -type minimal_moves -m 100000\n./gen -n 100000 -s 100000 -f 1 -type random -m 100000\n./gen -n 50000 -s 25000 -f 50000 -type max_moves\n./gen -n 2 -s 1 -f 2 -type random -m 100\n./gen -n 2 -s 2 -f 1 -type random -m 0\n./gen -n 1000 -s 1 -f 1000 -type no_watches\n./gen -n 1000 -s 1 -f 1000 -type blocked_path\n./gen -n 100000 -s 50000 -f 50001 -type random -m 100000 -tmax 1000000000\n./gen -n 99999 -s 1 -f 99999 -type minimal_moves -m 50000\n./gen -n 100000 -s 100000 -f 1 -type minimal_moves -m 0\n./gen -n 1000 -s 500 -f 500 -type no_watches\n./gen -n 1000 -s 1 -f 2 -type blocked_path\n./gen -n 100000 -s 12345 -f 54321 -type random -m 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:14.580527",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "342/C",
      "title": "C. Шкаф и шарики",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа r, h (1 ≤ r, h ≤ 107).",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальное количество шариков, которое поместится в шкаф.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1Выходные данныеСкопировать3Входные данныеСкопировать1 2Выходные данныеСкопировать5Входные данныеСкопировать2 1Выходные данныеСкопировать2",
      "description": "C. Шкаф и шарики\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа r, h (1 ≤ r, h ≤ 107).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальное количество шариков, которое поместится в шкаф.\n\nВыходные данные\n\nВходные данныеСкопировать1 1Выходные данныеСкопировать3Входные данныеСкопировать1 2Выходные данныеСкопировать5Входные данныеСкопировать2 1Выходные данныеСкопировать2\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces",
          "content": "Доброго времени суток)Приглашаем вас на очередной раунд Codeforces #199 для участников Div. 2. Как обычно, участники Div. 1 могут поучаствовать в этом соревновании вне конкурса.Задачи для вас готовили авторы Павел Холкин (HolkinPV) и Геральд Агапов (Gerald). Традиционно выражаем благодарность Михаилу Мирзаянову (MikeMirzayanov) за системы Codeforces и Polygon, а также Марии Беловой (Delinur), которая перевела условия задач. UPD: Распределение баллов по задачам будет стандартным — 500-1000-1500-2000-2500.Желаем всем участникам удачи, высокого рейтинга и удовольствия от решения задач)UPD2: итак соревнование завершилось, надеемся вам понравилось)Поздравляем победителей:1) chixianglove2) Logvinov_Leon3) Yoshiap4) _moonlight UPD3: разбор задач можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8795",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 766
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces",
          "content": "342A - Ксюша и делителиВ этой задаче нужно было догадаться, что существует только 3 корректные тройки:1) 1, 2, 42) 1, 2, 63) 1, 3, 6Будем жадно набирать их пока получается. Если остались какие то неиспользованные числа (в том числе 5 и 7, которые очевидно сразу являются плохими), то выведем -1. Иначе выведем найденный ответ.342B - Ксюша и шпионыЭта задача решается жадно. Будем всегда двигаться только по направлению от s до f. Причем, если в данный момент можно совершить действие, обязательно будем его совершать. Иначе не будем передавать записку соседу и оставим ее у себя (такой ход можно делать в любой ситуации). Очевидно, что такой подход приводит к правильному решению, остается его аккуратно реализовать.342C - Шкаф и шарикиВ задаче нужно было аккуратно выписать формулу. Оптимальное решение укладывает шарики по два в ряд, пока это возможно. А потом сверху кладет еще один шарик, если это возможно. Основная хитрость и сложность была именно в последнем шаге.В комментариях к посту были описаны формулы, как узнать, уместится ли в самом конце один шарик (в самую середину). А также был приведен красивый рисунок, который хорошо иллюстрирует ситуацию .342D - Ксюша и доминошкиВ этой задаче можно было как считать количество хороших расстановок, так и из общего числа вычесть плохие расстановки. В любом из решений нужно было уметь считать динамику по маскам, состояние (j, mask) — j — номер текущего полностью заполненного столбца, mask — маска того, что находится в последнем столбце (также этот прием называет динамикой по профилю). Это по сути известная задача о паркете (замощения поля доминошками). Как решать классическую задачу о паркете, можно узнать на известном сайте e-maxx.ru.Чтобы получить само решение задачи я поступал так. Пробовал к клетке с кружочком приписывать с четырех сторох доминошку, после этого все три клетки закрашивал в черный цвет и считал общее количество способов. Однако, чтобы не учитывать один ответ несколько раз, нужно использовать формулу включения исключения для этих четырех направлений. Это также известный прием, который позволяет правильно считать ответ для многих задач и не учитывать один ответ несколько раз.342E - Ксюша и деревоЗадачу можно было решать несколькими методами. Самый простой из них — корневая оптимизация. Разобьем запросы на sqrt(m) блоков. Каждый блок будем обрабатывать отдельно. Перед тем как обработать блок одним обходом в ширину посчитаем кратчайшие расстояния от красных вершин до всех остальных. Далее, чтобы выполнить запрос на вывод ответа из текущего блока нужно взять значение полученное обходом в ширину и обновить его расстояниями до красных вершин из текущего блока, которые покрасились до текущего запроса.Решение получается очень простым. Каждые sqrt(m) запросов запускаем обычный поиск в ширину и запоминаем для каждой вершины значение d[v] — кратчайшее расстояние от нее, до ближайшей красной. После этого, чтобы ответить на запрос типа 2, нужно взять min(d[v], dist(v, u)), где u — каждая новая красная вершина, которая стала красной именно в этом блоке длины sqrt(m).Расстояния между вершинами dist(u, v) на дереве можно было считать, используя предпосчет для lca.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 342\\s*C"
          },
          "content_length": 3158
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 1",
          "code": "answer = 0LL;\nanswer = (h / r) * 2LL;\nif(h % r == 0)\n{\n  answer++;\n}\nelse\n{\n  answer += 2LL;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 2",
          "code": "answer = 0LL;\nanswer = (h / r) * 2LL;\nif(h % r == 0)\n{\n  answer++;\n}\nelse\n{\n  answer += 2LL;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 3",
          "code": "radius of the upper circle+t+radius of the lower circles",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 4",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 5",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 6",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 7",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "ans1=2*(h*2+r)/(2*r);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "ans1=2*(h*2+r)/(2*r);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 3",
          "code": "ans2=1+2*(int)((2*h+r*(2-sqrt(3)))/(2*r));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 4",
          "code": "ans2=1+2*(int)((2*h+r*(2-sqrt(3)))/(2*r));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 5",
          "code": "(h + r/2) / r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 6",
          "code": "(2h + r) / 2r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 7",
          "code": "sqrt(r^2-(r/2)^2) = sqrt((3/4)r^2) = (sqrt(3)/2) * r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 8",
          "code": "(h + r/2 - (sqrt(3)/2) * r + r/2) = (h + r - (sqrt(3)/2) * r);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 9",
          "code": "h + r/2 - (sqrt(3)/2)r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 10",
          "code": "h + r/2 - (sqrt(3)/2)r + r/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 11",
          "code": "(2h + r (2 - sqrt(3) ) ) / 2r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 12",
          "code": "InputStream is = System.in;\n// graphSize - для хранения количества вершин графа, valueQuery - кол-во запросов\n    int graphSize, valueQuery, ch;\n    StringBuilder sbuild = new StringBuilder();\n    while((ch=is.read())!=10) sbuild.append((char)ch);\n    graphSize = Integer.parseInt(sbuild.substring(0, sbuild.indexOf(\" \")));\n    valueQuery = Integer.parseInt(sbuild.substring(sbuild.indexOf(\" \")+1));\n    sbuild.delete(0, sbuild.length());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 13",
          "code": "InputStream is = System.in;\n// graphSize - для хранения количества вершин графа, valueQuery - кол-во запросов\n    int graphSize, valueQuery, ch;\n    StringBuilder sbuild = new StringBuilder();\n    while((ch=is.read())!=10) sbuild.append((char)ch);\n    graphSize = Integer.parseInt(sbuild.substring(0, sbuild.indexOf(\" \")));\n    valueQuery = Integer.parseInt(sbuild.substring(sbuild.indexOf(\" \")+1));\n    sbuild.delete(0, sbuild.length());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 14",
          "code": "5 4\n1 2\n2 3\n2 4\n4 5\n2 1\n2 5\n1 2\n2 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 15",
          "code": "5 4\n1 2\n2 3\n2 4\n4 5\n2 1\n2 5\n1 2\n2 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 16",
          "code": "java.lang.NumberFormatException: For input string: \"4\n\"\n\n\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)\n\n\tat java.lang.Integer.parseInt(Integer.java:458)\n\n\tat java.lang.Integer.parseInt(Integer.java:499)\n\n\tat ZadachaE.main(ZadachaE.java:37)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 17",
          "code": "java.lang.NumberFormatException: For input string: \"4\n\"\n\n\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)\n\n\tat java.lang.Integer.parseInt(Integer.java:458)\n\n\tat java.lang.Integer.parseInt(Integer.java:499)\n\n\tat ZadachaE.main(ZadachaE.java:37)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 18",
          "code": "java.lang.NumberFormatException: For input string: \"4\n\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 19",
          "code": "java.lang.NumberFormatException: For input string: \"4\n\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 20",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 21",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 22",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 23",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 24",
          "code": "dist(u, v) = dist(root, u) + dist(root, v) - 2 * dist(root, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 25",
          "code": "rootDist[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 26",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 27",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 28",
          "code": "sparse[u][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 29",
          "code": "sparse[u][0] = parent[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 30",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 31",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 32",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 33",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 34",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 35",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 36",
          "code": "dist[v] = Distance from v to the nearest red node, 0 if v is itself red",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 37",
          "code": "dist[v] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 38",
          "code": "dist[u] = 1, isdiscovered[u] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 39",
          "code": "dist[y] = dist[w] +1, isdiscovered[y] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 40",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Разбор Задач - Codeforces - Code 41",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 10000000, \"r\");\n    inf.readSpace();\n    int h = inf.readInt(1, 10000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 10000000, \"r\");\n    inf.readSpace();\n    int h = inf.readInt(1, 10000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 10000000, \"r\");\n    inf.readSpace();\n    int h = inf.readInt(1, 10000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    string type = opt<string>(\"type\", \"random\");\n    int rmin = opt<int>(\"rmin\", 1);\n    int rmax = opt<int>(\"rmax\", 10000000);\n    int hmin = opt<int>(\"hmin\", 1);\n    int hmax = opt<int>(\"hmax\", 10000000);\n\n    int r, h;\n\n    if (type == \"min\") {\n        // Minimum values\n        r = 1;\n        h = 1;\n    } else if (type == \"max\") {\n        // Maximum values\n        r = 10000000;\n        h = 10000000;\n    } else if (type == \"equal\") {\n        // r equal to h\n        r = rnd.next(rmin, rmax);\n        h = r;\n    } else if (type == \"r_large\") {\n        // r is large, h is small\n        r = rmax;\n        h = rnd.next(hmin, hmax);\n    } else if (type == \"h_large\") {\n        // h is large, r is small\n        r = rnd.next(rmin, rmax);\n        h = hmax;\n    } else if (type == \"r_small\") {\n        // r is small, h is random\n        r = rmin;\n        h = rnd.next(hmin, hmax);\n    } else if (type == \"h_small\") {\n        // h is small, r is random\n        r = rnd.next(rmin, rmax);\n        h = hmin;\n    } else { // random\n        r = rnd.next(rmin, rmax);\n        h = rnd.next(hmin, hmax);\n    }\n\n    // Ensure r and h are within 1 and 10^7\n    r = max(1, min(r, 10000000));\n    h = max(1, min(h, 10000000));\n\n    printf(\"%d %d\\n\", r, h);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    string type = opt<string>(\"type\", \"random\");\n    int rmin = opt<int>(\"rmin\", 1);\n    int rmax = opt<int>(\"rmax\", 10000000);\n    int hmin = opt<int>(\"hmin\", 1);\n    int hmax = opt<int>(\"hmax\", 10000000);\n\n    int r, h;\n\n    if (type == \"min\") {\n        // Minimum values\n        r = 1;\n        h = 1;\n    } else if (type == \"max\") {\n        // Maximum values\n        r = 10000000;\n        h = 10000000;\n    } else if (type == \"equal\") {\n        // r equal to h\n        r = rnd.next(rmin, rmax);\n        h = r;\n    } else if (type == \"r_large\") {\n        // r is large, h is small\n        r = rmax;\n        h = rnd.next(hmin, hmax);\n    } else if (type == \"h_large\") {\n        // h is large, r is small\n        r = rnd.next(rmin, rmax);\n        h = hmax;\n    } else if (type == \"r_small\") {\n        // r is small, h is random\n        r = rmin;\n        h = rnd.next(hmin, hmax);\n    } else if (type == \"h_small\") {\n        // h is small, r is random\n        r = rnd.next(rmin, rmax);\n        h = hmin;\n    } else { // random\n        r = rnd.next(rmin, rmax);\n        h = rnd.next(hmin, hmax);\n    }\n\n    // Ensure r and h are within 1 and 10^7\n    r = max(1, min(r, 10000000));\n    h = max(1, min(h, 10000000));\n\n    printf(\"%d %d\\n\", r, h);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type equal -rmin 1 -rmax 1\n./gen -type equal -rmin 10000000 -rmax 10000000\n./gen -type equal -rmin 5000000 -rmax 5000000\n./gen -type equal -rmin 1 -rmax 10000000\n./gen\n./gen -type random -rmin 1 -rmax 10000000 -hmin 1 -hmax 10000000\n./gen -type r_large -rmax 10000000 -hmin 1 -hmax 1\n./gen -type r_large -rmax 10000000 -hmin 1 -hmax 10\n./gen -type h_large -rmin 1 -rmax 1 -hmax 10000000\n./gen -type h_large -rmin 1 -rmax 100 -hmax 10000000\n./gen -rmin 1 -rmax 10 -hmin 1 -hmax 10\n./gen -rmin 100 -rmax 1000 -hmin 100 -hmax 1000\n./gen -rmin 10000 -rmax 100000 -hmin 10000 -hmax 100000\n./gen -rmin 500000 -rmax 600000 -hmin 500000 -hmax 600000\n./gen -rmin 9000000 -rmax 10000000 -hmin 9000000 -hmax 10000000\n./gen -type random -rmin 1 -rmax 1 -hmin 1 -hmax 10000000\n./gen -type random -rmin 1 -rmax 10000000 -hmin 1 -hmax 1\n./gen -type random -rmin 10000000 -rmax 10000000 -hmin 1 -hmax 10000000\n./gen -type random -rmin 1 -rmax 10000000 -hmin 10000000 -hmax 10000000\n./gen -type random -rmin 100 -rmax 100 -hmin 100 -hmax 100\n./gen -type random -rmin 5000 -rmax 5000 -hmin 10000000 -hmax 10000000\n./gen -type random -rmin 9999999 -rmax 10000000 -hmin 1 -hmax 2\n./gen -type random -rmin 1 -rmax 2 -hmin 9999999 -hmax 10000000\n./gen -type random -rmin 5000000 -rmax 5000000 -hmin 5000000 -hmax 5000000\n./gen -type random -rmin 1 -rmax 10 -hmin 10000000 -hmax 10000000\n./gen -type random -rmin 10000000 -rmax 10000000 -hmin 1 -hmax 10\n./gen -rmin 1000000 -rmax 10000000 -hmin 1 -hmax 100\n./gen -rmin 1 -rmax 100 -hmin 1000000 -hmax 10000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:16.564083",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "342/D",
      "title": "D. Xenia and Dominoes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (3 ≤ n ≤ 104) — the puzzle's size. Each of the following three lines contains n characters — the description of the table. The j-th character of the i-th line equals \"X\" if the corresponding cell is forbidden; it equals \".\", if the corresponding cell is non-forbidden and \"O\", if the corresponding cell is marked with a circle.It is guaranteed that exactly one cell in the table is marked with a circle. It is guaranteed that all cells of a given table having at least one common point with the marked cell is non-forbidden.",
      "output_spec": "OutputPrint a single number — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy5....X.O......X.OutputCopy1InputCopy5......O........OutputCopy2InputCopy3........OOutputCopy4",
      "description": "D. Xenia and Dominoes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (3 ≤ n ≤ 104) — the puzzle's size. Each of the following three lines contains n characters — the description of the table. The j-th character of the i-th line equals \"X\" if the corresponding cell is forbidden; it equals \".\", if the corresponding cell is non-forbidden and \"O\", if the corresponding cell is marked with a circle.It is guaranteed that exactly one cell in the table is marked with a circle. It is guaranteed that all cells of a given table having at least one common point with the marked cell is non-forbidden.\n\nOutputPrint a single number — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy5....X.O......X.OutputCopy1InputCopy5......O........OutputCopy2InputCopy3........OOutputCopy4\n\nInputCopy5....X.O......X.\n\nOutputCopy1\n\nInputCopy5......O........\n\nOutputCopy2\n\nInputCopy3........O\n\nOutputCopy4\n\nNoteTwo puzzles are considered distinct if there is a pair of cells that contain one domino in one puzzle and do not contain it in the other one.",
      "solutions": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces",
          "content": "Good day)Welcome to regular Codeforces round #199 for Div.2 participants. As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is standard — 500-1000-1500-2000-2500.We wish everyone good luck, high rating and excellent mood)UPD2: the contest is over, hope you enjoy it)Congratulations to winners:1) chixianglove2) Logvinov_Leon3) Yoshiap4) _moonlight UPD3: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8795",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 666
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces",
          "content": "342A - Xenia and DivisorsIn this problem you should guess that exists only three valid groups of three 1) 1, 2, 4 2) 1, 2, 6 3) 1, 3, 6 (You can see that integers 5 and 7 are bad).So, we will greedy take these groups of three. If some integers will be not used, the answer is -1. In other case, print found answer.342B - Xenia and SpiesThe problem is solved by greedy algorithm. We will pass the note only in correct direction. Also, if we can pass the note at the current moment of time, we do it. In other case, we will hold it and don't give it to neighbors (we can make this action at any moment of time). Obviously this algorithm is correct. You should only implement it carefully.342C - Cupboard and BalloonsIn the problem you should carefully get formula. The optimal solution put marbles by two in a row. And then put one marble upon others if it possible. The most difficulties were to deal with this last phase. In comments to the post were given formulas how to put the last marble (exactly in the middle). And there was a good beautiful illustration, which describes the situation.342D - Xenia and DominoesIn the problem you can count number of correct puzzles or substract number of incorrect puzzles from number of all puzzles. In any case you should count DP, where the state is (j, mask) — j — number of the last full column, mask — mask of the last column. This problem is equivalent to the well known problem about domino tiling or the problem about parquet.To get the solution of the whole problem I did the following. I try to attach one domino to each of 4 directions, then paint all three cells in black and count the number of correct puzzles. But in this case you will count some solutions several number of times. So you need to use inclusion exclusion formula for these 4 directions.342E - Xenia and TreeThe problem can be solved in different ways. The most easy idea is sqrt-optimization. Split all queries into sqrt(m) blocks. Each block we will process separately. Before processing each block, we should calculate minimum distances from every node to the closest red node using bfs. To answer the query we should update this value by shortest distances to red nodes in current block.The solution becomes simple. Every sqrt(m) queries we make simple bfs and for every node v WE calculate value d[v] — the shortest distance to some red node from node v. Then to answer the query of type 2 you should calculate min(d[v], dist(v, u)), where u — every red node, which becomes red in current block of length sqrt(m).Distance between two nodes dist(u, v) can be got using preprocessing for lca.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 342\\s*D"
          },
          "content_length": 2617
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 1",
          "code": "radius of the upper circle+t+radius of the lower circles",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 2",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 3",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 4",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 5",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "dist(u, v) = dist(root, u) + dist(root, v) - 2 * dist(root, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "rootDist[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "sparse[u][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "sparse[u][0] = parent[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dist[v] = Distance from v to the nearest red node, 0 if v is itself red",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dist[v] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "dist[u] = 1, isdiscovered[u] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "dist[y] = dist[w] +1, isdiscovered[y] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(3, 10000, \"n\");\n    inf.readEoln();\n\n    vector<string> grid(3);\n\n    int total_O = 0;\n    int O_row = -1, O_col = -1;\n    for (int i = 0; i < 3; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == n, \"Line %d length is not equal to n\", i + 1);\n        for (int j = 0; j < n; ++j) {\n            char c = grid[i][j];\n            ensuref(c == 'X' || c == '.' || c == 'O', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n            if (c == 'O') {\n                total_O += 1;\n                O_row = i;\n                O_col = j;\n            }\n        }\n    }\n\n    ensuref(total_O == 1, \"There must be exactly one 'O' in the grid, found %d\", total_O);\n\n    // Check that all cells sharing at least one point with 'O' are non-forbidden\n    for (int dr = -1; dr <= 1; ++dr) {\n        for (int dc = -1; dc <= 1; ++dc) {\n            int r = O_row + dr;\n            int c = O_col + dc;\n            if (r >= 0 && r < 3 && c >= 0 && c < n) {\n                char cell = grid[r][c];\n                ensuref(cell != 'X', \"Cell at row %d, column %d shares a point with 'O' but is forbidden\", r + 1, c + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(3, 10000, \"n\");\n    inf.readEoln();\n\n    vector<string> grid(3);\n\n    int total_O = 0;\n    int O_row = -1, O_col = -1;\n    for (int i = 0; i < 3; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == n, \"Line %d length is not equal to n\", i + 1);\n        for (int j = 0; j < n; ++j) {\n            char c = grid[i][j];\n            ensuref(c == 'X' || c == '.' || c == 'O', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n            if (c == 'O') {\n                total_O += 1;\n                O_row = i;\n                O_col = j;\n            }\n        }\n    }\n\n    ensuref(total_O == 1, \"There must be exactly one 'O' in the grid, found %d\", total_O);\n\n    // Check that all cells sharing at least one point with 'O' are non-forbidden\n    for (int dr = -1; dr <= 1; ++dr) {\n        for (int dc = -1; dc <= 1; ++dc) {\n            int r = O_row + dr;\n            int c = O_col + dc;\n            if (r >= 0 && r < 3 && c >= 0 && c < n) {\n                char cell = grid[r][c];\n                ensuref(cell != 'X', \"Cell at row %d, column %d shares a point with 'O' but is forbidden\", r + 1, c + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(3, 10000, \"n\");\n    inf.readEoln();\n\n    vector<string> grid(3);\n\n    int total_O = 0;\n    int O_row = -1, O_col = -1;\n    for (int i = 0; i < 3; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == n, \"Line %d length is not equal to n\", i + 1);\n        for (int j = 0; j < n; ++j) {\n            char c = grid[i][j];\n            ensuref(c == 'X' || c == '.' || c == 'O', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n            if (c == 'O') {\n                total_O += 1;\n                O_row = i;\n                O_col = j;\n            }\n        }\n    }\n\n    ensuref(total_O == 1, \"There must be exactly one 'O' in the grid, found %d\", total_O);\n\n    // Check that all cells sharing at least one point with 'O' are non-forbidden\n    for (int dr = -1; dr <= 1; ++dr) {\n        for (int dc = -1; dc <= 1; ++dc) {\n            int r = O_row + dr;\n            int c = O_col + dc;\n            if (r >= 0 && r < 3 && c >= 0 && c < n) {\n                char cell = grid[r][c];\n                ensuref(cell != 'X', \"Cell at row %d, column %d shares a point with 'O' but is forbidden\", r + 1, c + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(3, string(n, '.'));\n\n    int oi, oj; // Position of 'O'\n\n    if (type == \"random\") {\n        // Get forbidden probability\n        double forbidden_prob = opt<double>(\"forbidden_prob\", 0.2);\n\n        // Pick random position for 'O'\n        oi = rnd.next(0, 2);\n        oj = rnd.next(0, n - 1);\n        grid[oi][oj] = 'O';\n\n        // Mark adjacent cells as reserved\n        vector<pair<int, int>> reserved;\n        reserved.push_back({oi, oj});\n        if (oi > 0) reserved.push_back({oi -1, oj});\n        if (oi < 2) reserved.push_back({oi +1, oj});\n        if (oj > 0) reserved.push_back({oi, oj -1});\n        if (oj < n -1) reserved.push_back({oi, oj +1});\n\n        set<pair<int, int>> reserved_set(reserved.begin(), reserved.end());\n\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (reserved_set.count({i, j}) == 0) {\n                    if (rnd.next() < forbidden_prob) {\n                        grid[i][j] = 'X';\n                    }\n                }\n            }\n        }\n\n    } else if (type == \"max_forbidden\") {\n        // All cells are forbidden except 'O' and its adjacent cells\n        // For 'O', choose a central position to ensure it has adjacent cells\n        oi = 1;\n        oj = n / 2;\n        grid[oi][oj] = 'O';\n\n        // Mark adjacent cells as '.'\n        vector<pair<int, int>> reserved;\n        reserved.push_back({oi, oj});\n        if (oi > 0) reserved.push_back({oi -1, oj});\n        if (oi < 2) reserved.push_back({oi +1, oj});\n        if (oj > 0) reserved.push_back({oi, oj -1});\n        if (oj < n -1) reserved.push_back({oi, oj +1});\n\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < n; ++j) {\n                grid[i][j] = 'X';\n            }\n        }\n        // Set reserved cells to '.'\n        for (auto p : reserved) {\n            int i = p.first, j = p.second;\n            if (i >= 0 && i < 3 && j >= 0 && j < n)\n                grid[i][j] = '.';\n        }\n\n    } else if (type == \"no_forbidden\") {\n        // All cells are non-forbidden, only 'O' is special\n        oi = 1;\n        oj = n / 2;\n        grid[oi][oj] = 'O';\n        // All other cells remain '.'\n\n    } else if (type == \"checkerboard\") {\n        // 'O' is at a random position\n        oi = rnd.next(0, 2);\n        oj = rnd.next(0, n -1);\n        grid[oi][oj] = 'O';\n\n        // Mark adjacent cells as reserved\n        vector<pair<int, int>> reserved;\n        reserved.push_back({oi, oj});\n        if (oi > 0) reserved.push_back({oi -1, oj});\n        if (oi < 2) reserved.push_back({oi +1, oj});\n        if (oj > 0) reserved.push_back({oi, oj -1});\n        if (oj < n -1) reserved.push_back({oi, oj +1});\n\n        set<pair<int, int>> reserved_set(reserved.begin(), reserved.end());\n\n        // Now fill the grid with 'X's in checkerboard pattern\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (reserved_set.count({i, j}) == 0) {\n                    if ((i + j) % 2 == 0)\n                        grid[i][j] = 'X';\n                }\n                // Else leave as '.'\n            }\n        }\n\n    } else {\n        // Undefined type\n        cerr << \"Undefined type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output grid\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(3, string(n, '.'));\n\n    int oi, oj; // Position of 'O'\n\n    if (type == \"random\") {\n        // Get forbidden probability\n        double forbidden_prob = opt<double>(\"forbidden_prob\", 0.2);\n\n        // Pick random position for 'O'\n        oi = rnd.next(0, 2);\n        oj = rnd.next(0, n - 1);\n        grid[oi][oj] = 'O';\n\n        // Mark adjacent cells as reserved\n        vector<pair<int, int>> reserved;\n        reserved.push_back({oi, oj});\n        if (oi > 0) reserved.push_back({oi -1, oj});\n        if (oi < 2) reserved.push_back({oi +1, oj});\n        if (oj > 0) reserved.push_back({oi, oj -1});\n        if (oj < n -1) reserved.push_back({oi, oj +1});\n\n        set<pair<int, int>> reserved_set(reserved.begin(), reserved.end());\n\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (reserved_set.count({i, j}) == 0) {\n                    if (rnd.next() < forbidden_prob) {\n                        grid[i][j] = 'X';\n                    }\n                }\n            }\n        }\n\n    } else if (type == \"max_forbidden\") {\n        // All cells are forbidden except 'O' and its adjacent cells\n        // For 'O', choose a central position to ensure it has adjacent cells\n        oi = 1;\n        oj = n / 2;\n        grid[oi][oj] = 'O';\n\n        // Mark adjacent cells as '.'\n        vector<pair<int, int>> reserved;\n        reserved.push_back({oi, oj});\n        if (oi > 0) reserved.push_back({oi -1, oj});\n        if (oi < 2) reserved.push_back({oi +1, oj});\n        if (oj > 0) reserved.push_back({oi, oj -1});\n        if (oj < n -1) reserved.push_back({oi, oj +1});\n\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < n; ++j) {\n                grid[i][j] = 'X';\n            }\n        }\n        // Set reserved cells to '.'\n        for (auto p : reserved) {\n            int i = p.first, j = p.second;\n            if (i >= 0 && i < 3 && j >= 0 && j < n)\n                grid[i][j] = '.';\n        }\n\n    } else if (type == \"no_forbidden\") {\n        // All cells are non-forbidden, only 'O' is special\n        oi = 1;\n        oj = n / 2;\n        grid[oi][oj] = 'O';\n        // All other cells remain '.'\n\n    } else if (type == \"checkerboard\") {\n        // 'O' is at a random position\n        oi = rnd.next(0, 2);\n        oj = rnd.next(0, n -1);\n        grid[oi][oj] = 'O';\n\n        // Mark adjacent cells as reserved\n        vector<pair<int, int>> reserved;\n        reserved.push_back({oi, oj});\n        if (oi > 0) reserved.push_back({oi -1, oj});\n        if (oi < 2) reserved.push_back({oi +1, oj});\n        if (oj > 0) reserved.push_back({oi, oj -1});\n        if (oj < n -1) reserved.push_back({oi, oj +1});\n\n        set<pair<int, int>> reserved_set(reserved.begin(), reserved.end());\n\n        // Now fill the grid with 'X's in checkerboard pattern\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (reserved_set.count({i, j}) == 0) {\n                    if ((i + j) % 2 == 0)\n                        grid[i][j] = 'X';\n                }\n                // Else leave as '.'\n            }\n        }\n\n    } else {\n        // Undefined type\n        cerr << \"Undefined type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output grid\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type max_forbidden\n./gen -n 3 -type no_forbidden\n./gen -n 3 -type checkerboard\n./gen -n 4 -type random\n./gen -n 4 -type max_forbidden\n./gen -n 4 -type no_forbidden\n./gen -n 4 -type checkerboard\n./gen -n 5 -type random\n./gen -n 5 -type max_forbidden\n./gen -n 5 -type no_forbidden\n./gen -n 5 -type checkerboard\n./gen -n 100 -type random\n./gen -n 100 -type checkerboard\n./gen -n 500 -type random -forbidden_prob 0.1\n./gen -n 500 -type random -forbidden_prob 0.3\n./gen -n 500 -type checkerboard\n./gen -n 1000 -type random -forbidden_prob 0.2\n./gen -n 1000 -type max_forbidden\n./gen -n 1000 -type no_forbidden\n./gen -n 5000 -type random -forbidden_prob 0.5\n./gen -n 5000 -type checkerboard\n./gen -n 10000 -type random -forbidden_prob 0.01\n./gen -n 10000 -type random -forbidden_prob 0.99\n./gen -n 10000 -type max_forbidden\n./gen -n 10000 -type no_forbidden\n./gen -n 10000 -type checkerboard\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:18.295920",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "342/E",
      "title": "E. Xenia and Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105) — the number of nodes in the tree and the number of queries. Next n - 1 lines contain the tree edges, the i-th line contains a pair of integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — an edge of the tree.Next m lines contain queries. Each query is specified as a pair of integers ti, vi (1 ≤ ti ≤ 2, 1 ≤ vi ≤ n). If ti = 1, then as a reply to the query we need to paint a blue node vi in red. If ti = 2, then we should reply to the query by printing the shortest distance from some red node to node vi.It is guaranteed that the given graph is a tree and that all queries are correct.",
      "output_spec": "OutputFor each second type query print the reply in a single line.",
      "sample_tests": "ExamplesInputCopy5 41 22 32 44 52 12 51 22 5OutputCopy032",
      "description": "E. Xenia and Tree\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105) — the number of nodes in the tree and the number of queries. Next n - 1 lines contain the tree edges, the i-th line contains a pair of integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — an edge of the tree.Next m lines contain queries. Each query is specified as a pair of integers ti, vi (1 ≤ ti ≤ 2, 1 ≤ vi ≤ n). If ti = 1, then as a reply to the query we need to paint a blue node vi in red. If ti = 2, then we should reply to the query by printing the shortest distance from some red node to node vi.It is guaranteed that the given graph is a tree and that all queries are correct.\n\nOutputFor each second type query print the reply in a single line.\n\nInputCopy5 41 22 32 44 52 12 51 22 5OutputCopy032\n\nInputCopy5 41 22 32 44 52 12 51 22 5\n\nOutputCopy032",
      "solutions": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces",
          "content": "Good day)Welcome to regular Codeforces round #199 for Div.2 participants. As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is standard — 500-1000-1500-2000-2500.We wish everyone good luck, high rating and excellent mood)UPD2: the contest is over, hope you enjoy it)Congratulations to winners:1) chixianglove2) Logvinov_Leon3) Yoshiap4) _moonlight UPD3: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8795",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 666
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces",
          "content": "342A - Xenia and DivisorsIn this problem you should guess that exists only three valid groups of three 1) 1, 2, 4 2) 1, 2, 6 3) 1, 3, 6 (You can see that integers 5 and 7 are bad).So, we will greedy take these groups of three. If some integers will be not used, the answer is -1. In other case, print found answer.342B - Xenia and SpiesThe problem is solved by greedy algorithm. We will pass the note only in correct direction. Also, if we can pass the note at the current moment of time, we do it. In other case, we will hold it and don't give it to neighbors (we can make this action at any moment of time). Obviously this algorithm is correct. You should only implement it carefully.342C - Cupboard and BalloonsIn the problem you should carefully get formula. The optimal solution put marbles by two in a row. And then put one marble upon others if it possible. The most difficulties were to deal with this last phase. In comments to the post were given formulas how to put the last marble (exactly in the middle). And there was a good beautiful illustration, which describes the situation.342D - Xenia and DominoesIn the problem you can count number of correct puzzles or substract number of incorrect puzzles from number of all puzzles. In any case you should count DP, where the state is (j, mask) — j — number of the last full column, mask — mask of the last column. This problem is equivalent to the well known problem about domino tiling or the problem about parquet.To get the solution of the whole problem I did the following. I try to attach one domino to each of 4 directions, then paint all three cells in black and count the number of correct puzzles. But in this case you will count some solutions several number of times. So you need to use inclusion exclusion formula for these 4 directions.342E - Xenia and TreeThe problem can be solved in different ways. The most easy idea is sqrt-optimization. Split all queries into sqrt(m) blocks. Each block we will process separately. Before processing each block, we should calculate minimum distances from every node to the closest red node using bfs. To answer the query we should update this value by shortest distances to red nodes in current block.The solution becomes simple. Every sqrt(m) queries we make simple bfs and for every node v WE calculate value d[v] — the shortest distance to some red node from node v. Then to answer the query of type 2 you should calculate min(d[v], dist(v, u)), where u — every red node, which becomes red in current block of length sqrt(m).Distance between two nodes dist(u, v) can be got using preprocessing for lca.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 342\\s*E"
          },
          "content_length": 2617
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 1",
          "code": "radius of the upper circle+t+radius of the lower circles",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 2",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 3",
          "code": "Res=Res+'X';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 4",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) - Codeforces - Code 5",
          "code": "100000 100000\n1 2\n2 3\n...\n99999 100000\n1 2\n2 100000\n1 3\n2 100000\n1 4\n2 100000\n....\n1 50001\n2 100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8795",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "AA.X.\nAA.0.\nAA.X.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "1. if we use vertical block and put it in first 2 rows. new state ----> (i,3)\n2. if we use vertical block and put it in last 2 rows. new state ----> (i,6)\n3. if we choose not to use vertical block we have to use 3 horizontal one ----> (i+1,7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "dist(u, v) = dist(root, u) + dist(root, v) - 2 * dist(root, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "rootDist[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "//Let MAX be the number of maximum nodes\nvector<int> adj[MAX];\nint rootDist[MAX], parent[MAX], depth[MAX];\n\n// cur = Current traversing node\n// prev = Node traversed before this one\nint dfs(int cur, int prev){\n    parent[cur] = prev;\n\n    for(int child : adj[cur]){\n        if(child != prev){\n            depth[child] = depth[cur] + 1;\n            rootDist[child] = rootDist[cur] + 1;\n            // Note: In the case of an unweighted tree,\n            // depth[n] == rootDist[n]\n\n            dfs(child, cur);\n\n        }\n    }\n}\n\ndfs(1, -1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "sparse[u][i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "sparse[u][0] = parent[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "// N = number of nodes as given in input\n// LN = ceil(log2(Max number of nodes))\n// Using 1-indexing for nodes\nint sparse[MAX][LN];\nmemset(sparse, -1, sizeof sparse);\n\nfor(int u = 1; u <= N; u++)\n    sparse[u][0] = parent[u];\n\nfor(int i = 1; i < LN; i++)\n    for(int u = 1; u <= N; u++)\n        //if the node has a 2**(i - 1)th parent\n        if(sparse[u][i - 1] != -1)\n            // the 2**i-th parent of u is equal to\n            // the 2**(i - 1)th parent of 2**(i - 1)th parent of u\n            sparse[u][i] = sparse [ sparse[u][i - 1] ] [i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "int lca(int u, int v){\n    if(depth[u] < depth[v])\n        swap(u, v);\n\n    // We use sparse table so we jump 2**i parents each time\n    // Taking only log time\n    for(int i = LN - 1; i >= 0; i--)\n        // If the 2**i-th parent of u isn't higher than v\n        if(depth[ sparse[u][i] ] >= depth[v])\n            // Go up 2**i parents\n            u = sparse[u][i];\n\n    // At this point, depth[u] == depth[v]\n    // If they happen to be the same node, that is the LCA\n    if(u == v)\n        return u;\n\n    for(int i = LN - 1; i >= 0; i--){\n        // If their ancestors aren't the same\n        if(sparse[u][i] != sparse[v][i]){\n            // Go up to their ancestor\n            u = sparse[u][i];\n            v = sparse[v][i];\n        }\n    }\n\n    // At this point, they're at the highest ancestor\n    // such that they're not the same, so one parent above\n    // must be their LCA\n\n    // 2**0 = 1, return first parent of u\n    return sparse[u][0];\n    // this is also equal to sparse[v][0]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "int dist(int u, int v){\n    int l = lca(u, v);\n    return rootDist[u] + rootDist[v] - 2 * rootDist[l];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dist[v] = Distance from v to the nearest red node, 0 if v is itself red",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dist[v] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "dist[u] = 1, isdiscovered[u] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "dist[y] = dist[w] +1, isdiscovered[y] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #199 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "void bfs(){\n    std::queue<int> bfslist;\n    int isdisc[N] = {0};\n    for (int i = 0; i < red.size(); i +=1){\n        int a = red[i];\n        reddist[a] = 0;\n        isdisc[i] = 1;\n        for (int j = 0; j < adjlist[a].size(); j +=1){\n            int b = adjlist[a][j];\n            if ((isred[b] == 1) && (isdisc[b] == 0)){\n                bfslist.push(b);\n                reddist[b] = 1;\n                isdisc[b] = 1;\n            }\n        }\n    }\n    while (!bfslist.empty()){\n            int a = bfslist.front();\n            bfslist.pop();\n            for (int i = 0; i < adjlist[a].size(); i +=1){\n                int b = adjlist[a][i];\n                if ((isred[b] ==1) && (isdisc[b] == 0)){\n                    bfslist.push(b);\n                    reddist[b] = reddist[a]+1;\n                    isdisc[b] = 1;\n                }\n            }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n    set<pair<int, int>> edgesSeen;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loop detected at edge %d: ai (%d) == bi (%d)\", i + 1, ai, bi);\n\n        pair<int, int> edge = make_pair(min(ai, bi), max(ai, bi));\n        ensuref(edgesSeen.count(edge) == 0, \"Duplicate edge between %d and %d\", ai, bi);\n        edgesSeen.insert(edge);\n\n        int rootA = find(ai);\n        int rootB = find(bi);\n        ensuref(rootA != rootB, \"Graph contains a cycle, edge between %d and %d creates a cycle\", ai, bi);\n\n        parent[rootA] = rootB;\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    for (int i = 0; i < m; ++i) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n    set<pair<int, int>> edgesSeen;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loop detected at edge %d: ai (%d) == bi (%d)\", i + 1, ai, bi);\n\n        pair<int, int> edge = make_pair(min(ai, bi), max(ai, bi));\n        ensuref(edgesSeen.count(edge) == 0, \"Duplicate edge between %d and %d\", ai, bi);\n        edgesSeen.insert(edge);\n\n        int rootA = find(ai);\n        int rootB = find(bi);\n        ensuref(rootA != rootB, \"Graph contains a cycle, edge between %d and %d creates a cycle\", ai, bi);\n\n        parent[rootA] = rootB;\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    for (int i = 0; i < m; ++i) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n    set<pair<int, int>> edgesSeen;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loop detected at edge %d: ai (%d) == bi (%d)\", i + 1, ai, bi);\n\n        pair<int, int> edge = make_pair(min(ai, bi), max(ai, bi));\n        ensuref(edgesSeen.count(edge) == 0, \"Duplicate edge between %d and %d\", ai, bi);\n        edgesSeen.insert(edge);\n\n        int rootA = find(ai);\n        int rootB = find(bi);\n        ensuref(rootA != rootB, \"Graph contains a cycle, edge between %d and %d creates a cycle\", ai, bi);\n\n        parent[rootA] = rootB;\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    for (int i = 0; i < m; ++i) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate the tree based on tree_type\n    vector<pair<int, int>> edges;\n\n    if (tree_type == \"chain\") {\n        // Create a chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Create a star centered at node 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"random\") {\n        // Generate a random tree\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({parent[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        function<void(int, int, int)> build_balanced = [&](int l, int r, int parent) {\n            if (l > r) return;\n            int mid = (l + r) / 2;\n            if (parent != -1) edges.push_back({parent, mid});\n            build_balanced(l, mid - 1, mid);\n            build_balanced(mid + 1, r, mid);\n        };\n        build_balanced(1, n, -1);\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate queries based on query_type\n    vector<pair<int, int>> queries;\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int v = rnd.next(1, n);\n            queries.push_back({t, v});\n        }\n    } else if (query_type == \"all_type1\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back({1, v});\n        }\n    } else if (query_type == \"all_type2\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back({2, v});\n        }\n    } else if (query_type == \"alternate\") {\n        for (int i = 0; i < m; ++i) {\n            int t = (i % 2) + 1;\n            int v = rnd.next(1, n);\n            queries.push_back({t, v});\n        }\n    } else if (query_type == \"paint_leaf_then_query\") {\n        // Paint leaf nodes and then query\n        vector<int> leaves;\n        vector<vector<int>> adj(n + 1);\n        for (auto& e : edges) {\n            adj[e.first].push_back(e.second);\n            adj[e.second].push_back(e.first);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (adj[i].size() == 1) {\n                leaves.push_back(i);\n            }\n        }\n        int num_leaves = min((int)leaves.size(), m);\n        for (int i = 0; i < num_leaves; ++i) {\n            queries.push_back({1, leaves[i]});\n        }\n        for (int i = num_leaves; i < m; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back({2, v});\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int v = rnd.next(1, n);\n            queries.push_back({t, v});\n        }\n    }\n\n    // Output queries\n    for (auto q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate the tree based on tree_type\n    vector<pair<int, int>> edges;\n\n    if (tree_type == \"chain\") {\n        // Create a chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Create a star centered at node 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"random\") {\n        // Generate a random tree\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({parent[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        function<void(int, int, int)> build_balanced = [&](int l, int r, int parent) {\n            if (l > r) return;\n            int mid = (l + r) / 2;\n            if (parent != -1) edges.push_back({parent, mid});\n            build_balanced(l, mid - 1, mid);\n            build_balanced(mid + 1, r, mid);\n        };\n        build_balanced(1, n, -1);\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate queries based on query_type\n    vector<pair<int, int>> queries;\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int v = rnd.next(1, n);\n            queries.push_back({t, v});\n        }\n    } else if (query_type == \"all_type1\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back({1, v});\n        }\n    } else if (query_type == \"all_type2\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back({2, v});\n        }\n    } else if (query_type == \"alternate\") {\n        for (int i = 0; i < m; ++i) {\n            int t = (i % 2) + 1;\n            int v = rnd.next(1, n);\n            queries.push_back({t, v});\n        }\n    } else if (query_type == \"paint_leaf_then_query\") {\n        // Paint leaf nodes and then query\n        vector<int> leaves;\n        vector<vector<int>> adj(n + 1);\n        for (auto& e : edges) {\n            adj[e.first].push_back(e.second);\n            adj[e.second].push_back(e.first);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (adj[i].size() == 1) {\n                leaves.push_back(i);\n            }\n        }\n        int num_leaves = min((int)leaves.size(), m);\n        for (int i = 0; i < num_leaves; ++i) {\n            queries.push_back({1, leaves[i]});\n        }\n        for (int i = num_leaves; i < m; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back({2, v});\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int v = rnd.next(1, n);\n            queries.push_back({t, v});\n        }\n    }\n\n    // Output queries\n    for (auto q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test 1: Small chain tree with alternating queries\n./gen -n 5 -m 5 -tree_type chain -query_type alternate\n\n# Test 2: Small star tree with random queries\n./gen -n 5 -m 5 -tree_type star -query_type random\n\n# Test 3: Small balanced tree with all type 1 queries\n./gen -n 5 -m 5 -tree_type balanced -query_type all_type1\n\n# Test 4: Small random tree with all type 2 queries\n./gen -n 5 -m 5 -tree_type random -query_type all_type2\n\n# Test 5: Medium chain tree with paint_leaf_then_query\n./gen -n 1000 -m 1000 -tree_type chain -query_type paint_leaf_then_query\n\n# Test 6: Medium star tree with random queries\n./gen -n 1000 -m 1000 -tree_type star -query_type random\n\n# Test 7: Medium balanced tree with alternate queries\n./gen -n 1000 -m 1000 -tree_type balanced -query_type alternate\n\n# Test 8: Medium random tree with random queries\n./gen -n 1000 -m 1000 -tree_type random -query_type random\n\n# Test 9: Large chain tree with random queries\n./gen -n 100000 -m 100000 -tree_type chain -query_type random\n\n# Test 10: Large star tree with random queries\n./gen -n 100000 -m 100000 -tree_type star -query_type random\n\n# Test 11: Large balanced tree with random queries\n./gen -n 100000 -m 100000 -tree_type balanced -query_type random\n\n# Test 12: Large random tree with all type1 queries\n./gen -n 100000 -m 100000 -tree_type random -query_type all_type1\n\n# Test 13: Large random tree with all type2 queries\n./gen -n 100000 -m 100000 -tree_type random -query_type all_type2\n\n# Test 14: Large random tree with alternate queries\n./gen -n 100000 -m 100000 -tree_type random -query_type alternate\n\n# Test 15: Large random tree with paint_leaf_then_query\n./gen -n 100000 -m 100000 -tree_type random -query_type paint_leaf_then_query\n\n# Test 16: Small tree with m=1, single query\n./gen -n 10 -m 1 -tree_type random -query_type random\n\n# Test 17: Small tree with m maximum, many queries\n./gen -n 10 -m 100000 -tree_type random -query_type random\n\n# Test 18: Tree with n = 2 (minimum size)\n./gen -n 2 -m 2 -tree_type chain -query_type alternate\n\n# Test 19: Tree with n = 2 and m = 100000\n./gen -n 2 -m 100000 -tree_type star -query_type random\n\n# Test 20: Tree with n maximum and m minimum\n./gen -n 100000 -m 1 -tree_type balanced -query_type random\n\n# Test 21: Random tree with custom queries\n./gen -n 50000 -m 50000 -tree_type random -query_type random\n\n# Test 22: Chain tree with all type 2 queries\n./gen -n 100000 -m 100000 -tree_type chain -query_type all_type2\n\n# Test 23: Star tree with all type 1 queries\n./gen -n 100000 -m 100000 -tree_type star -query_type all_type1\n\n# Test 24: Balanced tree with paint_leaf_then_query\n./gen -n 100000 -m 100000 -tree_type balanced -query_type paint_leaf_then_query\n\n# Test 25: Random tree with random queries\n./gen -n 100000 -m 100000 -tree_type random -query_type random\n\n# Test 26: Random tree with maximum node IDs\n./gen -n 100000 -m 100000 -tree_type random -query_type random\n\n# Test 27: Random tree with node IDs in reverse order\n./gen -n 100000 -m 100000 -tree_type random -query_type random\n\n# Test 28: Random tree with duplicates in queries (same node)\n./gen -n 50000 -m 50000 -tree_type random -query_type random\n\n# Test 29: Random tree with painting the same node repeatedly\n./gen -n 1000 -m 100000 -tree_type random -query_type all_type1\n\n# Test 30: Random tree with querying the same node repeatedly\n./gen -n 1000 -m 100000 -tree_type random -query_type all_type2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:19.998806",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "343/A",
      "title": "A. Рациональное сопротивление",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных через пробел записаны два целых числа a и b (1 ≤ a, b ≤ 1018). Гарантируется, что дробь  несократима. Гарантируется, что решение всегда существует.",
      "output_spec": "Выходные данныеВыведите единственное число — ответ на задачу.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать3 2Выходные данныеСкопировать3Входные данныеСкопировать199 200Выходные данныеСкопировать200",
      "description": "A. Рациональное сопротивление\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входных данных через пробел записаны два целых числа a и b (1 ≤ a, b ≤ 1018). Гарантируется, что дробь  несократима. Гарантируется, что решение всегда существует.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — ответ на задачу.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать3 2Выходные данныеСкопировать3Входные данныеСкопировать199 200Выходные данныеСкопировать200\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать199 200\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать200\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере хватает одного резистора.Во втором примере можно соединить два резистора параллельно, а полученный элемент соединить последовательно с третьим резистором. Таким образом получаем элемент с сопротивлением . С помощью двух резисторов такой элемент построить невозможно.",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Привет всем!Сегодня в 19:30 по Московскому времени состоится юбилейный Codeforces Round #200. Раунд будет проведен в обоих дивизионах и будет рейтинговым.Задачи раунда подготовили Евгений Вихров (gen), Андрей Вихров (andreyv) и Геральд Агапов (Gerald). Как всегда, выражаем благодарность Михаилу Мирзаянову (MikeMirzayanov) за системы Codeforces и Polygon. Отдельное спасибо Марии Беловой (Delinur) за перевод условий задач. В этом раунде вы поможете безумному учёному Майку реализовать его причудливые затеи и поставить необычные опыты. По мнению авторов, в задачах поддерживается хороший баланс математики и программирования. Также мы старались сделать условия задач по возможности короткими и понятными :] Как всегда, мы считаем, что каждый участник найдёт себе задачу по вкусу.Желаем всем участникам удачи и интересного раунда!UPD1: Разбалловка задач стандартная:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Поздравляем две лучших пятёрки победителей!DivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1071
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces",
          "content": "344A - МагнитыПо определению каждый островок состоит из последовательных одинаково направленных домино. Значит, в местах, где соседние домино направлены не одинаково, кончается один островок и начинается следующий. Значит, если таких мест x, то ответ равен x + 1.Сложность решения O(n). Автор задачи: gen.Бонус: Задача была придумана в день перед контестом и полностью дополнила физически направленный комплект для DivII :]344B - Простые молекулыПервое решение. Во-первых, заметим, что сумма a + b + c должна быть чётной, потому что каждое ребро прибавляет два к сумме. Теперь допустим, что между 1-ым и 2-ым, 2-ым и 3-им, 3-им и 1-ым атомами есть x, y и z связей, соответственно. Поэтому нам нужно решить систему x + z = a, y + x = b, z + y = c. Можно заметить, что решением этого уравнения являются длины касательных на треугольнике со сторонами a, b, c к его вписанной окружности, и равняются , , . Если бы в задаче просили проверить только, можно ли построить такую молекулу, то хватало бы проверить нестрогое неравенство треугольника для a, b, c.Второе решение. Переберём значение x. Для него значения y и z определены однозначно: y = b - x, z = a - x.Сложность решения O(1) / O(n). Авторы задачи: gen, andreyv.Бонус: Можете ли вы решить задачу для произвольного n? Когда и как можно построить связный граф?343A - Рациональное сопротивлениеЕсли с помощью k элементов можем получить дроби , то нетрудно посчитать, что с помощью k + 1 элементов можно получить дроби и . То есть прибавление одного элемента эквивалентно одному шагу алгоритма Эвклида для числителя и знаменателя в обратном направлении. Значит, ответ равняется количеству шагов стандартного алгоритма Эвклида.Сложность решения . Авторы задачи: gen, andreyv.Бонус: Вначале мы думали об общей задаче (можно соединять два любых элемента, как многие неправильно поняли задачу), однако случился момент эврики, и мы поняли, что данная задача неожиданно естественно сводится к НОД. Кстати, дерево результатов – http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Переменный токВначале решим другую задачу: дана строка, состоящая из символов A и B. Если i-тый символ А, то на i-том шаге верхний провод (на рисунке) кладётся поверх нижнего. Если i-тый символ B, то нижний провод (на рисунке) кладётся поверх верхнего. Заметим, что если символ А стоит рядом с символом B, то эти два заплетания можно распутать и получить ситуацию, которую описывает та же строка, в которой выкинуты эти два символа. Поэтому провода можно распутать тогда и только тогда, если количество А совпадает с количеством В в этой строке. Нашу задачу мы можем свести к вышеописанной следующим образом: на каждой нечётной позиции заменяем – на B, а + на A. На чётных позициях заменяем – на A, а + на B. Можно видеть, что сведение правильное, потому что на каждой чётной позиции – и + всегда стоят перевернутые относительно начала, а на каждой нечётной порядок совпадает с порядком начала.Сложность решения O(n). Авторы задачи: gen, andreyv.Бонус: Если тема вас заинтересовала, можете ознакомиться с теорией кос http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: усложнённый вариант задачи был предложен ещё на Round #142, но тогда в решении нашлась ошибка, и задача осталась лежать почти целый год.343C - Время чтенияБудем искать ответ t двоичным поиском. Рассмотрим конкретное значение t. Рассмотрим первую головку слева h[i], которая может считать p[0]. Если p[0] > h[i], то h[i] просто идёт направо t секунд, и читает все дорожки на пути. Если p[0] ≤ h[i], то у головки есть два выбора: идти направо секунд, затем налево и опять налево ещё h[i] - p[0] секунд; идти налево h[i] - p[0] секунд, затем направо h[i] - p[0] и опять направо t - 2·(h[i] - p[0]) секунд. Естественно, для h[i] выгоднее всего побывать в самой правой точке. Поэтому выбираем по . Дальше двигаем указатель на первую несчитанную дорожку, и повторяем алгоритм для h[i + 1], и.т.д. с каждой головкой.Сложность решения . Авторы задачи: gen, gorbunov.Бонус: Задача полностью реальна, если у диска есть только одна головка, и известно, какие данные нужно считать, то оптимальный алгоритм выбирает один из описанных двух вариантов. Это мы слушали на лекции вместе с gorbunov, и от скуки придумали такую задачу ;]343D - Водяное деревоНаучимся быстро красить целое поддерево. Для этого пронумеруем все вершины в порядке выхода DFS. Тогда каждое поддерево покрывает один непрерывный отрезок номеров вершин. Для каждой вершины запомним границы такого отрезка для поддерева с корнем в этой вершине. Тогда красить поддерево означает покрасить отрезок в дереве отрезков.Заведём дерево отрезков. Для него выполняется свойство: если вершина v была опустошена, и она до сир пор пуста, то эта вершина покрашена в дереве отрезков. В самом начале «опустошим» все вершины. То есть, покрасим все вершины в дереве отрезков. С помощью этого дерева можно эффективно обрабатывать запросы: Заполняем вершину v. Стираем всё поддерево v в дереве отрезков. Если до этого поддерево не было пустым, то красим родителя v. Опустошаем вершину v. Красим вершину v в дереве отрезков. Отвечаем, заполнена ли вершина v. Если в дереве отрезков сумма поддерева v не равна 0, значит есть такой потомок v, который опустошён сейчас, поэтому вершина v не заполнена. Идейно похожее, но более простое решение в написании предложил Shtrix.Сложность решения . Автор задачи: gen.Бонус: Некоторые участники могли заметить схожесть задачи с задачей Ball Machine из BOI 2013, однако решения этих задач имеют мало похожего.343E - Насосные станцииВ этой задаче нужно было найти такую перестановку вершин графа, что сумма максимальных потоков, пропущенных через каждую пару соседних вершин в перестановке, максимальна.Задача решается с помощью структуры данных дерево Гомори-Ху. Для данного взвешенного графа дерево обладает свойствами: Множество вершин дерева совпадает с множеством вершин графа. Максимальный поток в дереве между вершинами u и v равен максимальному потоку в графе между вершинами u и v. Такое дерево на удивление существует для любого взвешенного графа и строится за время O(n·maxFlow). Оказывается, что для данной задачи ответом является сумма весов рёбер в таком дереве.Докажем это утверждение индукцией по количеству вершин в дереве. Найдём ребро (u, v) с минимальным весом в дереве. Допустим, что для оптимальной перестановки вершин через это ребро проходит больше, чем один путь между парами соседних вершин в перестановке. Сотрём все такие пути, тогда в поддеревьях u и v остаётся в каждом по множеству несоединённых цепочек путей. Соединим все пути в каждом множестве в одну цепочку и получим две цепочки. Эти цепочки соединим одним путём s, который идёт через ребро (u, v). Получили перестановку, которая не хуже оптимальной. Для пути s ребро (u, v) является наименьшим, значит поток по этому пути равен весу этого ребра. Из индукции следует, что в поддеревьях u и v ответ равняется сумме ребёр. Добавляя к сумме вес ребра (u, v), получаем желаемое.Из предыдущего абзаца ясно также, как строить такую перестановку: Берём наименьшее ребро, для поддеревьев вершин рекурсивно строим цепочки и соединяем их в одну. Так как вершин мало, эту часть можно делать даже за O(n2).Сложность решения O(n·maxFlow). Авторы задачи: gen, Gerald.Бонус: Ближе к соревнованию мы решили сделать ограничения лояльней, поэтому прошли также решения, которые O(n2) раз вызывают поток и затем строят дерево Гомори-Ху. Надеемся, этот факт никого особенно не огорчил. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 343\\s*A"
          },
          "content_length": 7429
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 1",
          "code": "if ((c <> '+') and (c <> '-')) then break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 2",
          "code": "if ((c <> '+') and (c <> '-')) then break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 3",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 4",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 5",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 6",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 7",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 8",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b != 0LL) {\n        long long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    ensuref(gcd(a, b) == 1, \"The fraction a/b must be irreducible.\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b != 0LL) {\n        long long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    ensuref(gcd(a, b) == 1, \"The fraction a/b must be irreducible.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b != 0LL) {\n        long long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    ensuref(gcd(a, b) == 1, \"The fraction a/b must be irreducible.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\");\n    ll max_value = opt<ll>(\"max_value\", (ll)(1e18));\n    \n    ll a = 0, b = 0;\n\n    if (type == \"small\") {\n        // Generate small numbers\n        do {\n            a = rnd.next(1LL, 100LL);\n            b = rnd.next(1LL, 100LL);\n        } while (__gcd(a, b) != 1);\n\n    } else if (type == \"large\") {\n        // Generate large numbers\n        do {\n            a = rnd.next(max_value / 2, max_value);\n            b = rnd.next(max_value / 2, max_value);\n        } while (__gcd(a, b) != 1);\n\n    } else if (type == \"edge\") {\n        // Edge case where a = 1 and b is maximum\n        a = 1;\n        b = max_value;\n\n    } else if (type == \"edge_a1\") {\n        a = 1;\n        b = rnd.next(1LL, max_value);\n\n    } else if (type == \"edge_b1\") {\n        a = rnd.next(1LL, max_value);\n        b = 1;\n\n    } else if (type == \"adjacent\") {\n        // a and b are consecutive numbers, gcd(a,b)=1\n        ll x = rnd.next(2LL, max_value);\n        a = x - 1;\n        b = x;\n\n    } else if (type == \"random\") {\n        // Generate random numbers ensuring gcd(a,b)=1\n        do {\n            a = rnd.next(1LL, max_value);\n            b = rnd.next(1LL, max_value);\n        } while (__gcd(a, b) != 1);\n\n    } else if (type == \"max\") {\n        a = max_value;\n        b = max_value - 1;\n\n    } else if (type == \"sample1\") {\n        a = 1;\n        b = 1;\n\n    } else if (type == \"sample2\") {\n        a = 3;\n        b = 2;\n\n    } else if (type == \"sample3\") {\n        a = 199;\n        b = 200;\n\n    } else {\n        // Default to random\n        do {\n            a = rnd.next(1LL, max_value);\n            b = rnd.next(1LL, max_value);\n        } while (__gcd(a, b) != 1);\n    }\n\n    // Ensure that a and b are within [1, max_value]\n    a = max(1LL, min(a, max_value));\n    b = max(1LL, min(b, max_value));\n\n    printf(\"%lld %lld\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\");\n    ll max_value = opt<ll>(\"max_value\", (ll)(1e18));\n    \n    ll a = 0, b = 0;\n\n    if (type == \"small\") {\n        // Generate small numbers\n        do {\n            a = rnd.next(1LL, 100LL);\n            b = rnd.next(1LL, 100LL);\n        } while (__gcd(a, b) != 1);\n\n    } else if (type == \"large\") {\n        // Generate large numbers\n        do {\n            a = rnd.next(max_value / 2, max_value);\n            b = rnd.next(max_value / 2, max_value);\n        } while (__gcd(a, b) != 1);\n\n    } else if (type == \"edge\") {\n        // Edge case where a = 1 and b is maximum\n        a = 1;\n        b = max_value;\n\n    } else if (type == \"edge_a1\") {\n        a = 1;\n        b = rnd.next(1LL, max_value);\n\n    } else if (type == \"edge_b1\") {\n        a = rnd.next(1LL, max_value);\n        b = 1;\n\n    } else if (type == \"adjacent\") {\n        // a and b are consecutive numbers, gcd(a,b)=1\n        ll x = rnd.next(2LL, max_value);\n        a = x - 1;\n        b = x;\n\n    } else if (type == \"random\") {\n        // Generate random numbers ensuring gcd(a,b)=1\n        do {\n            a = rnd.next(1LL, max_value);\n            b = rnd.next(1LL, max_value);\n        } while (__gcd(a, b) != 1);\n\n    } else if (type == \"max\") {\n        a = max_value;\n        b = max_value - 1;\n\n    } else if (type == \"sample1\") {\n        a = 1;\n        b = 1;\n\n    } else if (type == \"sample2\") {\n        a = 3;\n        b = 2;\n\n    } else if (type == \"sample3\") {\n        a = 199;\n        b = 200;\n\n    } else {\n        // Default to random\n        do {\n            a = rnd.next(1LL, max_value);\n            b = rnd.next(1LL, max_value);\n        } while (__gcd(a, b) != 1);\n    }\n\n    // Ensure that a and b are within [1, max_value]\n    a = max(1LL, min(a, max_value));\n    b = max(1LL, min(b, max_value));\n\n    printf(\"%lld %lld\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type sample1\n./gen -type sample2\n./gen -type sample3\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type edge\n./gen -type edge_a1\n./gen -type edge_b1\n./gen -type adjacent\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max\n\n# Additional edge cases\n./gen -type edge_a1\n./gen -type edge_b1\n./gen -type adjacent\n\n# Testing different max_value parameters\n./gen -type random -max_value 1000\n./gen -type random -max_value 1000000\n./gen -type random -max_value 1000000000\n./gen -type large -max_value 10000000000000000\n\n# More random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:21.696616",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "343/B",
      "title": "B. Alternating Current",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains a sequence of characters \"+\" and \"-\" of length n (1 ≤ n ≤ 100000). The i-th (1 ≤ i ≤ n) position of the sequence contains the character \"+\", if on the i-th step from the wall the \"plus\" wire runs above the \"minus\" wire, and the character \"-\" otherwise.",
      "output_spec": "OutputPrint either \"Yes\" (without the quotes) if the wires can be untangled or \"No\" (without the quotes) if the wires cannot be untangled.",
      "sample_tests": "ExamplesInputCopy-++-OutputCopyYesInputCopy+-OutputCopyNoInputCopy++OutputCopyYesInputCopy-OutputCopyNo",
      "description": "B. Alternating Current\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains a sequence of characters \"+\" and \"-\" of length n (1 ≤ n ≤ 100000). The i-th (1 ≤ i ≤ n) position of the sequence contains the character \"+\", if on the i-th step from the wall the \"plus\" wire runs above the \"minus\" wire, and the character \"-\" otherwise.\n\nOutputPrint either \"Yes\" (without the quotes) if the wires can be untangled or \"No\" (without the quotes) if the wires cannot be untangled.\n\nInputCopy-++-OutputCopyYesInputCopy+-OutputCopyNoInputCopy++OutputCopyYesInputCopy-OutputCopyNo\n\nInputCopy-++-\n\nOutputCopyYes\n\nInputCopy+-\n\nOutputCopyNo\n\nInputCopy++\n\nOutputCopyYes\n\nOutputCopyNo\n\nNoteThe first testcase corresponds to the picture in the statement. To untangle the wires, one can first move the \"plus\" wire lower, thus eliminating the two crosses in the middle, and then draw it under the \"minus\" wire, eliminating also the remaining two crosses.In the second testcase the \"plus\" wire makes one full revolution around the \"minus\" wire. Thus the wires cannot be untangled:   In the third testcase the \"plus\" wire simply runs above the \"minus\" wire twice in sequence. The wires can be untangled by lifting \"plus\" and moving it higher:   In the fourth testcase the \"minus\" wire runs above the \"plus\" wire once. The wires cannot be untangled without moving the device itself:",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Hello everyone!The anniversary Codeforces Round #200 is scheduled to take place today at 7:30 PM Moscow time. The round will be held in both divisions and will be rated.The round problems were prepared by Evgeny Vihrov (gen), Andrey Vihrov (andreyv) and Gerald Agapov (Gerald). As always, we would like to thank Mike Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems, and also Maria Belova (Delinur) for translating the problem statements.In this round you will help mad scientist Mike to realise his peculiar ideas and carry out unusual experiments. The authors think that the problems constitute a good balance between mathematics and programming. We also tried to make the statements short and easy to read :] As always, we hope that every participant will find a problem to his taste.We wish you good luck and an interesting round!UPD1: Score distribution is standard:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Congratulations to the top 5 winners in each division!DivIDivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1108
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces",
          "content": "344A - MagnetsBy the definition each block consists of a number of consequent and equally oriented dominoes. That means that in places where adjacent dominoes are not oriented equally, one block ends and another block starts. So, if there are x such places, the answer is equal to x + 1.Solution complexity: O(n). Problem author: gen.Bonus: The problem was created a day before the contest and filled in the last part of a physically flavoured DivII complect. :]344B - Simple MoleculesFirst solution. First, the sum a + b + c should be even, since each bond adds 2 to the sum. Now let x, y, z be the number of bonds between 1st and 2nd, 2nd and 3rd, 3rd and 1st atoms, accordingly. So we have to solve the system x + z = a, y + x = b, z + y = c. Now observe that the solution to the system is the length of the tangents on the triangle with sides of length a, b, c to its inscribed circle, and are equal to , , . If the problem asked only the possibility of building such a molecule, we could just check if there exists (possibly degenerate) triangle with sides a, b, c.Second solution. Bruteforce all x values. For a fixed x values of y and z are defined uniquely: y = b - x, z = a - x.Solution complexity: O(1) / O(n). Problem authors: gen, andreyv.Bonus: Can you solve the problem for any vertex number n? When and how can such a graph be built?343A - Rational ResistanceIf a fraction can be obtained with k resistors, then it is simple to calculate that we can obtain fractions and with k + 1 resistors. So adding one resistor means performing one operation backwards in Euclidean algorithm. That means that the answer is equal to the number of steps in standard Euclidean algorithm.Solution complexity: . Problem authors: gen, andreyv.Бонус: At first we thought about the major problem (any two elements can be joined), but had a moment of eureka and got that the given problem unexpectedly naturally can be reduced to GCD. By the way, the result tree — http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Alternating CurrentLet us solve the following problem first: we are given a string of symbols A and B. If the i-th symbol is A, then at the i-th step the upper wire (see figure) is being put over the lower wire. If the i-th symbol is B, the lower wire is being put over the upper wire at i-th step. Observe that if some two symbols A and B are adjacent, we can untangle this place, throw the symbols out and obtain the string of length two symbols less. So the wires can be untangled iff the number of A's and B's in the string is the same. The given problem can be reduced to the described in a following fashion: in each odd position we change – to B and + to A. In each even position we change — to A and + to B. The reduction is correct, since on each even position the order of — and + are always swapped, and in each odd position their order is the same as in the beginning.Solution complexity: O(n). Problem authors: gen, andreyv.Bonus: If you are interested by this problem, you can learn about the braid theory http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: a harder version of this problem was planned already for Round #142, but the error in solution idea was found, and the problem was left to lay for almost a year.343C - Read TimeLet's search the answer t with the binary search. Fix some value of t. Look at the first head from the left h[i] that can read track p[0]. If p[0] > h[i], then h[i] goes to the right t seconds and reads all tracks on its way. Otherwise if p[0] ≤ h[i], then the head has two choices: go to the right seconds, then to the left and h[i] - p[0] again to the left; go to the left h[i] - p[0] seconds, then h[i] - p[0] to the right and t - 2·(h[i] - p[0]) again to the right. Obviously, for h[i] it is more advantageous to visit the track positioned as much as possible to the right. So we choose by . Then we move the pointer onto the first unread track, and repeat the algorithm for h[i + 1], and so on with each head.Solution complexity: . Problem authors: gen, gorbunov.Bonus: The problem is completely real, if the disk has only a single head, if we know, what tracks should be read; then the optimal algorithm chooses between the two choices described above. I and gorbunov were listening this on a lecture, and created the given problem out of boredom ;]343D - Water TreeLet's learn how to color a whole subtree. For that enumerate all vertices in post-order DFS. Then each subtree covers a single continious vertex number segment. For each vertex we store the bounds of such segment for a subtree with a root in this vertex. Then to color a subtree means to color a segment in a segment tree.Then create a segment tree that has a following property: if a vertex v was emptied, and is still empty, then this vertex is colored in the segment tree. In the beginning \"empty\" all the vertices. That is, color all the vertices in the segment tree. With this tree we can efficiently process the queries: Fill a vertex v. Clean the interval for the subtree of v. If before that some vertex of a subtree was empty, color the parent of v. Empty a vertex v. Color the vertex v in the segment tree. Reply whether a vertex v is filled. If in the segment tree at least one vertex is colored, then there is such a descendant of v that is empty now, so the vertex v is not filled. Shtrix noted that essentially the same solution can be implemented with only a single set.Solution complexity: . Problem author: gen.Bonus: Some participants could see the similarities with a problem Ball Machine from BOI 2013, but the solutions to the both problems are quite different.343E - Pumping StationsIn this problem we are asked to find such graph vertex permutation that maximizes the sum of the maximum flows sent between each two consequtive vertices in the permutation.The problem can be solved with Gomory-Hu tree data structure. For a given weighted graph the tree has the following properties: The vertex set of the tree and the graph is the same. The maximum flow between vertices u and v in the tree is equal to the maximum flow in the graph. Surprisingly, such a tree exists for any weighted graph, and can be built in O(n·maxFlow). It appears that the answer to the problem is equal to the sum of the edge weights in this tree.We prove this statement by induction on the number of the tree vertices. Pick the edge (u, v) with the smallest weight in the tree. Consider that in an optimal permutation more than one path between two adjacent verteces in the permutation passes through this edge. Erase all these paths, then each of the u and v subtrees holds a set of disjoint remaining paths from the permutation. For each set, join all the paths in one chain, obtaining two chains. These chains we join by a path s that goes trough the edge (u, v). Thus we have built a permutation that is not worse than the considered one. For a path s the edge (u, v) is the smallest, so the flow along this path is equal to the weight of this edge. It follows from the induction that in subtrees u and v the answer is equal to the sum of edges. By adding the weight of edge (u, v), we get the desired result.From the last paragraph it is clear how to build such a permutation: take the smallest edge, obtain two chains from the vertex subtrees recursively, and add them together to form a one chain. Since there are not many vertices, we can do this part in O(n2).Solution complexity: O(n·maxFlow). Problem authors: gen, Gerald.Bonus: Shortly before the contest we decided to make the constraints more loyal, so some solution that find Gomory-Hu tree by finding flow O(n2) times also passed. We hope that nobody is particularly saddened by this fact. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 343\\s*B"
          },
          "content_length": 7699
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 1",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 2",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 3",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 4",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 5",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 6",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the line, ensuring only '+' and '-' characters\n    string s = inf.readLine(\"[+-]+\", \"s\");\n\n    int n = s.length();\n    ensuref(1 <= n && n <= 100000, \"The length of the sequence must be between 1 and 1e5, but actual length is %d\", n);\n\n    // Ensure nothing else is in the input\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the line, ensuring only '+' and '-' characters\n    string s = inf.readLine(\"[+-]+\", \"s\");\n\n    int n = s.length();\n    ensuref(1 <= n && n <= 100000, \"The length of the sequence must be between 1 and 1e5, but actual length is %d\", n);\n\n    // Ensure nothing else is in the input\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the line, ensuring only '+' and '-' characters\n    string s = inf.readLine(\"[+-]+\", \"s\");\n\n    int n = s.length();\n    ensuref(1 <= n && n <= 100000, \"The length of the sequence must be between 1 and 1e5, but actual length is %d\", n);\n\n    // Ensure nothing else is in the input\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n    if (type == \"all_plus\") {\n        s = string(n, '+');\n    } else if (type == \"all_minus\") {\n        s = string(n, '-');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? '+' : '-';\n        }\n    } else if (type == \"untangle\") {\n        // Generate a sequence that can be untangled.\n        // e.g., total net twist is zero.\n        // Generate random sequence with equal number of '+' and '-'\n        int half = n / 2;\n        s = string(half, '+') + string(n - half, '-');\n        shuffle(s.begin(), s.end());\n        // Ensure net twist is zero\n        if ((n % 2) == 1) {\n            s += '+';\n            ++n;\n        }\n    } else if (type == \"no\") {\n        // Generate a sequence that cannot be untangled.\n        // e.g., net twist is non-zero.\n        int num_plus = n / 2 + 1;\n        int num_minus = n - num_plus;\n        s = string(num_plus, '+') + string(num_minus, '-');\n        shuffle(s.begin(), s.end());\n    } else if (type == \"random\") {\n        // Generate random sequence\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(2) ? '+' : '-';\n        }\n    } else if (type == \"prefix_plus\") {\n        // Generate sequence with a prefix of '+' signs\n        int prefix_len = rnd.next(1, n);\n        s = string(prefix_len, '+');\n        for (int i = prefix_len; i < n; ++i) {\n            s += rnd.next(2) ? '+' : '-';\n        }\n    } else if (type == \"prefix_minus\") {\n        // Generate sequence with a prefix of '-' signs\n        int prefix_len = rnd.next(1, n);\n        s = string(prefix_len, '-');\n        for (int i = prefix_len; i < n; ++i) {\n            s += rnd.next(2) ? '+' : '-';\n        }\n    } else if (type == \"block\") {\n        // Generate blocks of '+' and '-' signs\n        int block_size = opt<int>(\"block_size\", 10);\n        for (int i = 0; i < n; ) {\n            int len = min(block_size, n - i);\n            char c = rnd.next(2) ? '+' : '-';\n            s += string(len, c);\n            i += len;\n        }\n    } else {\n        // Default to random sequence\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(2) ? '+' : '-';\n        }\n    }\n    // Output the sequence\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n    if (type == \"all_plus\") {\n        s = string(n, '+');\n    } else if (type == \"all_minus\") {\n        s = string(n, '-');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? '+' : '-';\n        }\n    } else if (type == \"untangle\") {\n        // Generate a sequence that can be untangled.\n        // e.g., total net twist is zero.\n        // Generate random sequence with equal number of '+' and '-'\n        int half = n / 2;\n        s = string(half, '+') + string(n - half, '-');\n        shuffle(s.begin(), s.end());\n        // Ensure net twist is zero\n        if ((n % 2) == 1) {\n            s += '+';\n            ++n;\n        }\n    } else if (type == \"no\") {\n        // Generate a sequence that cannot be untangled.\n        // e.g., net twist is non-zero.\n        int num_plus = n / 2 + 1;\n        int num_minus = n - num_plus;\n        s = string(num_plus, '+') + string(num_minus, '-');\n        shuffle(s.begin(), s.end());\n    } else if (type == \"random\") {\n        // Generate random sequence\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(2) ? '+' : '-';\n        }\n    } else if (type == \"prefix_plus\") {\n        // Generate sequence with a prefix of '+' signs\n        int prefix_len = rnd.next(1, n);\n        s = string(prefix_len, '+');\n        for (int i = prefix_len; i < n; ++i) {\n            s += rnd.next(2) ? '+' : '-';\n        }\n    } else if (type == \"prefix_minus\") {\n        // Generate sequence with a prefix of '-' signs\n        int prefix_len = rnd.next(1, n);\n        s = string(prefix_len, '-');\n        for (int i = prefix_len; i < n; ++i) {\n            s += rnd.next(2) ? '+' : '-';\n        }\n    } else if (type == \"block\") {\n        // Generate blocks of '+' and '-' signs\n        int block_size = opt<int>(\"block_size\", 10);\n        for (int i = 0; i < n; ) {\n            int len = min(block_size, n - i);\n            char c = rnd.next(2) ? '+' : '-';\n            s += string(len, c);\n            i += len;\n        }\n    } else {\n        // Default to random sequence\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(2) ? '+' : '-';\n        }\n    }\n    // Output the sequence\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -type all_plus\n./gen -n 2 -type all_minus\n./gen -n 3 -type alternating\n./gen -n 4 -type untangle\n./gen -n 5 -type no\n./gen -n 6 -type random\n./gen -n 7 -type prefix_plus\n./gen -n 8 -type prefix_minus\n./gen -n 9 -type block -block_size 1\n\n# Medium n\n./gen -n 50 -type all_plus\n./gen -n 50 -type all_minus\n./gen -n 50 -type alternating\n./gen -n 50 -type untangle\n./gen -n 50 -type no\n./gen -n 50 -type random\n./gen -n 50 -type prefix_plus\n./gen -n 50 -type prefix_minus\n./gen -n 50 -type block -block_size 5\n\n# Large n\n./gen -n 100000 -type all_plus\n./gen -n 100000 -type all_minus\n./gen -n 100000 -type alternating\n./gen -n 100000 -type untangle\n./gen -n 100000 -type no\n./gen -n 100000 -type random\n./gen -n 100000 -type prefix_plus\n./gen -n 100000 -type prefix_minus\n./gen -n 100000 -type block -block_size 1000\n\n# Mixed cases\n./gen -n 99999 -type untangle\n./gen -n 50000 -type no\n./gen -n 100000 -type block -block_size 1\n./gen -n 100000 -type block -block_size 2\n./gen -n 100000 -type block -block_size 3\n./gen -n 100000 -type block -block_size 500\n./gen -n 100000 -type block -block_size 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:23.729502",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "343/C",
      "title": "C. Время чтения",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных через пробел даны два целых числа n, m (1 ≤ n, m ≤ 105) — количество головок диска и количество дорожек, данные которых нужно считать, соответственно. Во второй строке через пробел в порядке возрастания даны n различных целых чисел hi (1 ≤ hi ≤ 1010, hi < hi + 1) — начальные позиции головок. В третьей строке через пробел в порядке возрастания даны m различных целых чисел pi (1 ≤ pi ≤ 1010, pi < pi + 1) — номера дорожек, с которых нужно считать данные.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите единственное целое число — наименьшее время в секундах, за которое можно считать все нужные дорожки.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 42 5 61 3 6 8Выходные данныеСкопировать2Входные данныеСкопировать3 31 2 31 2 3Выходные данныеСкопировать0Входные данныеСкопировать1 2165142 200Выходные данныеСкопировать81",
      "description": "C. Время чтения\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных через пробел даны два целых числа n, m (1 ≤ n, m ≤ 105) — количество головок диска и количество дорожек, данные которых нужно считать, соответственно. Во второй строке через пробел в порядке возрастания даны n различных целых чисел hi (1 ≤ hi ≤ 1010, hi < hi + 1) — начальные позиции головок. В третьей строке через пробел в порядке возрастания даны m различных целых чисел pi (1 ≤ pi ≤ 1010, pi < pi + 1) — номера дорожек, с которых нужно считать данные.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — наименьшее время в секундах, за которое можно считать все нужные дорожки.\n\nВыходные данные\n\nВходные данныеСкопировать3 42 5 61 3 6 8Выходные данныеСкопировать2Входные данныеСкопировать3 31 2 31 2 3Выходные данныеСкопировать0Входные данныеСкопировать1 2165142 200Выходные данныеСкопировать81\n\nВходные данныеСкопировать3 42 5 61 3 6 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 31 2 31 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2165142 200\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать81\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый тест совпадает с рисунком. В данном случае данные дорожки можно считать за 2 секунды следующим образом:  за первую секунду переместить 1-ую головку налево и на следующей секунде оставить ее на месте;  вторую головку два раза переместить налево;  третью головку два раза переместить направо (причем 6-ая дорожка считана уже в самом начале работы диска). За 1 секунду дорожки считать невозможно, так как 3-я головка находится на расстоянии 2 от 8-ой дорожки.",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Привет всем!Сегодня в 19:30 по Московскому времени состоится юбилейный Codeforces Round #200. Раунд будет проведен в обоих дивизионах и будет рейтинговым.Задачи раунда подготовили Евгений Вихров (gen), Андрей Вихров (andreyv) и Геральд Агапов (Gerald). Как всегда, выражаем благодарность Михаилу Мирзаянову (MikeMirzayanov) за системы Codeforces и Polygon. Отдельное спасибо Марии Беловой (Delinur) за перевод условий задач. В этом раунде вы поможете безумному учёному Майку реализовать его причудливые затеи и поставить необычные опыты. По мнению авторов, в задачах поддерживается хороший баланс математики и программирования. Также мы старались сделать условия задач по возможности короткими и понятными :] Как всегда, мы считаем, что каждый участник найдёт себе задачу по вкусу.Желаем всем участникам удачи и интересного раунда!UPD1: Разбалловка задач стандартная:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Поздравляем две лучших пятёрки победителей!DivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1071
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces",
          "content": "344A - МагнитыПо определению каждый островок состоит из последовательных одинаково направленных домино. Значит, в местах, где соседние домино направлены не одинаково, кончается один островок и начинается следующий. Значит, если таких мест x, то ответ равен x + 1.Сложность решения O(n). Автор задачи: gen.Бонус: Задача была придумана в день перед контестом и полностью дополнила физически направленный комплект для DivII :]344B - Простые молекулыПервое решение. Во-первых, заметим, что сумма a + b + c должна быть чётной, потому что каждое ребро прибавляет два к сумме. Теперь допустим, что между 1-ым и 2-ым, 2-ым и 3-им, 3-им и 1-ым атомами есть x, y и z связей, соответственно. Поэтому нам нужно решить систему x + z = a, y + x = b, z + y = c. Можно заметить, что решением этого уравнения являются длины касательных на треугольнике со сторонами a, b, c к его вписанной окружности, и равняются , , . Если бы в задаче просили проверить только, можно ли построить такую молекулу, то хватало бы проверить нестрогое неравенство треугольника для a, b, c.Второе решение. Переберём значение x. Для него значения y и z определены однозначно: y = b - x, z = a - x.Сложность решения O(1) / O(n). Авторы задачи: gen, andreyv.Бонус: Можете ли вы решить задачу для произвольного n? Когда и как можно построить связный граф?343A - Рациональное сопротивлениеЕсли с помощью k элементов можем получить дроби , то нетрудно посчитать, что с помощью k + 1 элементов можно получить дроби и . То есть прибавление одного элемента эквивалентно одному шагу алгоритма Эвклида для числителя и знаменателя в обратном направлении. Значит, ответ равняется количеству шагов стандартного алгоритма Эвклида.Сложность решения . Авторы задачи: gen, andreyv.Бонус: Вначале мы думали об общей задаче (можно соединять два любых элемента, как многие неправильно поняли задачу), однако случился момент эврики, и мы поняли, что данная задача неожиданно естественно сводится к НОД. Кстати, дерево результатов – http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Переменный токВначале решим другую задачу: дана строка, состоящая из символов A и B. Если i-тый символ А, то на i-том шаге верхний провод (на рисунке) кладётся поверх нижнего. Если i-тый символ B, то нижний провод (на рисунке) кладётся поверх верхнего. Заметим, что если символ А стоит рядом с символом B, то эти два заплетания можно распутать и получить ситуацию, которую описывает та же строка, в которой выкинуты эти два символа. Поэтому провода можно распутать тогда и только тогда, если количество А совпадает с количеством В в этой строке. Нашу задачу мы можем свести к вышеописанной следующим образом: на каждой нечётной позиции заменяем – на B, а + на A. На чётных позициях заменяем – на A, а + на B. Можно видеть, что сведение правильное, потому что на каждой чётной позиции – и + всегда стоят перевернутые относительно начала, а на каждой нечётной порядок совпадает с порядком начала.Сложность решения O(n). Авторы задачи: gen, andreyv.Бонус: Если тема вас заинтересовала, можете ознакомиться с теорией кос http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: усложнённый вариант задачи был предложен ещё на Round #142, но тогда в решении нашлась ошибка, и задача осталась лежать почти целый год.343C - Время чтенияБудем искать ответ t двоичным поиском. Рассмотрим конкретное значение t. Рассмотрим первую головку слева h[i], которая может считать p[0]. Если p[0] > h[i], то h[i] просто идёт направо t секунд, и читает все дорожки на пути. Если p[0] ≤ h[i], то у головки есть два выбора: идти направо секунд, затем налево и опять налево ещё h[i] - p[0] секунд; идти налево h[i] - p[0] секунд, затем направо h[i] - p[0] и опять направо t - 2·(h[i] - p[0]) секунд. Естественно, для h[i] выгоднее всего побывать в самой правой точке. Поэтому выбираем по . Дальше двигаем указатель на первую несчитанную дорожку, и повторяем алгоритм для h[i + 1], и.т.д. с каждой головкой.Сложность решения . Авторы задачи: gen, gorbunov.Бонус: Задача полностью реальна, если у диска есть только одна головка, и известно, какие данные нужно считать, то оптимальный алгоритм выбирает один из описанных двух вариантов. Это мы слушали на лекции вместе с gorbunov, и от скуки придумали такую задачу ;]343D - Водяное деревоНаучимся быстро красить целое поддерево. Для этого пронумеруем все вершины в порядке выхода DFS. Тогда каждое поддерево покрывает один непрерывный отрезок номеров вершин. Для каждой вершины запомним границы такого отрезка для поддерева с корнем в этой вершине. Тогда красить поддерево означает покрасить отрезок в дереве отрезков.Заведём дерево отрезков. Для него выполняется свойство: если вершина v была опустошена, и она до сир пор пуста, то эта вершина покрашена в дереве отрезков. В самом начале «опустошим» все вершины. То есть, покрасим все вершины в дереве отрезков. С помощью этого дерева можно эффективно обрабатывать запросы: Заполняем вершину v. Стираем всё поддерево v в дереве отрезков. Если до этого поддерево не было пустым, то красим родителя v. Опустошаем вершину v. Красим вершину v в дереве отрезков. Отвечаем, заполнена ли вершина v. Если в дереве отрезков сумма поддерева v не равна 0, значит есть такой потомок v, который опустошён сейчас, поэтому вершина v не заполнена. Идейно похожее, но более простое решение в написании предложил Shtrix.Сложность решения . Автор задачи: gen.Бонус: Некоторые участники могли заметить схожесть задачи с задачей Ball Machine из BOI 2013, однако решения этих задач имеют мало похожего.343E - Насосные станцииВ этой задаче нужно было найти такую перестановку вершин графа, что сумма максимальных потоков, пропущенных через каждую пару соседних вершин в перестановке, максимальна.Задача решается с помощью структуры данных дерево Гомори-Ху. Для данного взвешенного графа дерево обладает свойствами: Множество вершин дерева совпадает с множеством вершин графа. Максимальный поток в дереве между вершинами u и v равен максимальному потоку в графе между вершинами u и v. Такое дерево на удивление существует для любого взвешенного графа и строится за время O(n·maxFlow). Оказывается, что для данной задачи ответом является сумма весов рёбер в таком дереве.Докажем это утверждение индукцией по количеству вершин в дереве. Найдём ребро (u, v) с минимальным весом в дереве. Допустим, что для оптимальной перестановки вершин через это ребро проходит больше, чем один путь между парами соседних вершин в перестановке. Сотрём все такие пути, тогда в поддеревьях u и v остаётся в каждом по множеству несоединённых цепочек путей. Соединим все пути в каждом множестве в одну цепочку и получим две цепочки. Эти цепочки соединим одним путём s, который идёт через ребро (u, v). Получили перестановку, которая не хуже оптимальной. Для пути s ребро (u, v) является наименьшим, значит поток по этому пути равен весу этого ребра. Из индукции следует, что в поддеревьях u и v ответ равняется сумме ребёр. Добавляя к сумме вес ребра (u, v), получаем желаемое.Из предыдущего абзаца ясно также, как строить такую перестановку: Берём наименьшее ребро, для поддеревьев вершин рекурсивно строим цепочки и соединяем их в одну. Так как вершин мало, эту часть можно делать даже за O(n2).Сложность решения O(n·maxFlow). Авторы задачи: gen, Gerald.Бонус: Ближе к соревнованию мы решили сделать ограничения лояльней, поэтому прошли также решения, которые O(n2) раз вызывают поток и затем строят дерево Гомори-Ху. Надеемся, этот факт никого особенно не огорчил. (;",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 343\\s*C"
          },
          "content_length": 7429
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 1",
          "code": "if ((c <> '+') and (c <> '-')) then break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 2",
          "code": "if ((c <> '+') and (c <> '-')) then break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 3",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 4",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 5",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 6",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 7",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 8",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read h_i\n    vector<long long> h = inf.readLongs(n, 1LL, 10000000000LL, \"h_i\");\n    inf.readEoln();\n\n    // Check that h_i < h_{i+1}\n    for(int i = 1; i < n; i++) {\n        ensuref(h[i-1] < h[i], \"h_i should be in strictly increasing order, but h[%d]=%I64d >= h[%d]=%I64d\", i-1, h[i-1], i, h[i]);\n    }\n\n    // Read p_i\n    vector<long long> p = inf.readLongs(m, 1LL, 10000000000LL, \"p_i\");\n    inf.readEoln();\n\n    // Check that p_i < p_{i+1}\n    for(int i = 1; i < m; i++) {\n        ensuref(p[i-1] < p[i], \"p_i should be in strictly increasing order, but p[%d]=%I64d >= p[%d]=%I64d\", i-1, p[i-1], i, p[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read h_i\n    vector<long long> h = inf.readLongs(n, 1LL, 10000000000LL, \"h_i\");\n    inf.readEoln();\n\n    // Check that h_i < h_{i+1}\n    for(int i = 1; i < n; i++) {\n        ensuref(h[i-1] < h[i], \"h_i should be in strictly increasing order, but h[%d]=%I64d >= h[%d]=%I64d\", i-1, h[i-1], i, h[i]);\n    }\n\n    // Read p_i\n    vector<long long> p = inf.readLongs(m, 1LL, 10000000000LL, \"p_i\");\n    inf.readEoln();\n\n    // Check that p_i < p_{i+1}\n    for(int i = 1; i < m; i++) {\n        ensuref(p[i-1] < p[i], \"p_i should be in strictly increasing order, but p[%d]=%I64d >= p[%d]=%I64d\", i-1, p[i-1], i, p[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read h_i\n    vector<long long> h = inf.readLongs(n, 1LL, 10000000000LL, \"h_i\");\n    inf.readEoln();\n\n    // Check that h_i < h_{i+1}\n    for(int i = 1; i < n; i++) {\n        ensuref(h[i-1] < h[i], \"h_i should be in strictly increasing order, but h[%d]=%I64d >= h[%d]=%I64d\", i-1, h[i-1], i, h[i]);\n    }\n\n    // Read p_i\n    vector<long long> p = inf.readLongs(m, 1LL, 10000000000LL, \"p_i\");\n    inf.readEoln();\n\n    // Check that p_i < p_{i+1}\n    for(int i = 1; i < m; i++) {\n        ensuref(p[i-1] < p[i], \"p_i should be in strictly increasing order, but p[%d]=%I64d >= p[%d]=%I64d\", i-1, p[i-1], i, p[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<ll> h, p;\n\n    if (type == \"random\") {\n        // Generate random positions for h\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        // Similarly for p\n        positions.clear();\n        while ((int)positions.size() < m) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        p.assign(positions.begin(), positions.end());\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"same_positions\") {\n        // All heads and targets are at the same positions\n        n = m = min(n, m);\n        h.resize(n);\n        p.resize(m);\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        p = h;\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"min_positions\") {\n        // All positions are at minimal value starting from 1\n        h.resize(n);\n        p.resize(m);\n        for (int i = 0; i < n; ++i) {\n            h[i] = i + 1;  // unique positions starting from 1\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = n + i + 1;  // unique positions after h\n        }\n    } else if (type == \"max_positions\") {\n        // All positions are at maximal value\n        h.resize(n);\n        p.resize(m);\n        ll max_pos = (ll)1e10;\n        for (int i = 0; i < n; ++i) {\n            h[i] = max_pos - n + i + 1;  // unique positions at the top end\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = max_pos - n - m + i + 1;  // unique positions before h\n        }\n    } else if (type == \"heads_cover_targets\") {\n        // All targets are covered by heads\n        n = m = min(n, m);\n        h.resize(n);\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        p = h;\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"heads_far_from_targets\") {\n        // Heads are far away from targets\n        h.resize(n);\n        p.resize(m);\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e9);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            ll pos = rnd.next((ll)1e9 + 1, (ll)1e10);\n            positions.insert(pos);\n        }\n        p.assign(positions.begin(), positions.end());\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"interleaved\") {\n        // Interleaved positions of heads and targets\n        h.resize(n);\n        p.resize(m);\n        ll pos = 1;\n        for (int i = 0; i < max(n, m); ++i) {\n            if (i < n) h[i] = pos++;\n            if (i < m) p[i] = pos++;\n        }\n        h.resize(n);\n        p.resize(m);\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"max_range\") {\n        // Positions cover the entire range from 1 to 1e10\n        h.resize(n);\n        p.resize(m);\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        p.assign(positions.begin(), positions.end());\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%lld\", h[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%lld\", p[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<ll> h, p;\n\n    if (type == \"random\") {\n        // Generate random positions for h\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        // Similarly for p\n        positions.clear();\n        while ((int)positions.size() < m) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        p.assign(positions.begin(), positions.end());\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"same_positions\") {\n        // All heads and targets are at the same positions\n        n = m = min(n, m);\n        h.resize(n);\n        p.resize(m);\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        p = h;\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"min_positions\") {\n        // All positions are at minimal value starting from 1\n        h.resize(n);\n        p.resize(m);\n        for (int i = 0; i < n; ++i) {\n            h[i] = i + 1;  // unique positions starting from 1\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = n + i + 1;  // unique positions after h\n        }\n    } else if (type == \"max_positions\") {\n        // All positions are at maximal value\n        h.resize(n);\n        p.resize(m);\n        ll max_pos = (ll)1e10;\n        for (int i = 0; i < n; ++i) {\n            h[i] = max_pos - n + i + 1;  // unique positions at the top end\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = max_pos - n - m + i + 1;  // unique positions before h\n        }\n    } else if (type == \"heads_cover_targets\") {\n        // All targets are covered by heads\n        n = m = min(n, m);\n        h.resize(n);\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        p = h;\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"heads_far_from_targets\") {\n        // Heads are far away from targets\n        h.resize(n);\n        p.resize(m);\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e9);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            ll pos = rnd.next((ll)1e9 + 1, (ll)1e10);\n            positions.insert(pos);\n        }\n        p.assign(positions.begin(), positions.end());\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"interleaved\") {\n        // Interleaved positions of heads and targets\n        h.resize(n);\n        p.resize(m);\n        ll pos = 1;\n        for (int i = 0; i < max(n, m); ++i) {\n            if (i < n) h[i] = pos++;\n            if (i < m) p[i] = pos++;\n        }\n        h.resize(n);\n        p.resize(m);\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    } else if (type == \"max_range\") {\n        // Positions cover the entire range from 1 to 1e10\n        h.resize(n);\n        p.resize(m);\n        set<ll> positions;\n        while ((int)positions.size() < n) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        h.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            ll pos = rnd.next(1LL, (ll)1e10);\n            positions.insert(pos);\n        }\n        p.assign(positions.begin(), positions.end());\n        sort(h.begin(), h.end());\n        sort(p.begin(), p.end());\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%lld\", h[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%lld\", p[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 10 -m 10 -type random\n\n# Larger random test cases\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n\n# Maximum size random test cases\n./gen -n 100000 -m 100000 -type random\n\n# Test cases where heads and targets are at same positions\n./gen -n 10 -m 10 -type same_positions\n./gen -n 1000 -m 1000 -type same_positions\n./gen -n 50000 -m 50000 -type same_positions\n\n# Test cases with minimal positions\n./gen -n 10 -m 10 -type min_positions\n./gen -n 1000 -m 1000 -type min_positions\n./gen -n 100000 -m 100000 -type min_positions\n\n# Test cases with maximal positions\n./gen -n 10 -m 10 -type max_positions\n./gen -n 1000 -m 1000 -type max_positions\n./gen -n 100000 -m 100000 -type max_positions\n\n# Test cases where heads cover targets\n./gen -n 10 -m 10 -type heads_cover_targets\n./gen -n 1000 -m 1000 -type heads_cover_targets\n./gen -n 100000 -m 100000 -type heads_cover_targets\n\n# Test cases where heads are far from targets\n./gen -n 10 -m 10 -type heads_far_from_targets\n./gen -n 1000 -m 1000 -type heads_far_from_targets\n./gen -n 100000 -m 100000 -type heads_far_from_targets\n\n# Interleaved positions\n./gen -n 10 -m 10 -type interleaved\n./gen -n 1000 -m 1000 -type interleaved\n./gen -n 50000 -m 50000 -type interleaved\n\n# Maximum range positions\n./gen -n 10 -m 10 -type max_range\n./gen -n 1000 -m 1000 -type max_range\n./gen -n 100000 -m 100000 -type max_range\n\n# Edge cases with minimal and maximal n and m\n./gen -n 1 -m 100000 -type random\n./gen -n 100000 -m 1 -type random\n./gen -n 1 -m 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:26.018651",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "343/D",
      "title": "D. Water Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n (1 ≤ n ≤ 500000) — the number of vertices in the tree. Each of the following n - 1 lines contains two space-separated numbers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — the edges of the tree.The next line contains a number q (1 ≤ q ≤ 500000) — the number of operations to perform. Each of the following q lines contains two space-separated numbers ci (1 ≤ ci ≤ 3), vi (1 ≤ vi ≤ n), where ci is the operation type (according to the numbering given in the statement), and vi is the vertex on which the operation is performed.It is guaranteed that the given graph is a tree.",
      "output_spec": "OutputFor each type 3 operation print 1 on a separate line if the vertex is full, and 0 if the vertex is empty. Print the answers to queries in the order in which the queries are given in the input.",
      "sample_tests": "ExamplesInputCopy51 25 12 34 2121 12 33 13 23 33 41 22 43 13 33 43 5OutputCopy00010101",
      "description": "D. Water Tree\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n (1 ≤ n ≤ 500000) — the number of vertices in the tree. Each of the following n - 1 lines contains two space-separated numbers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — the edges of the tree.The next line contains a number q (1 ≤ q ≤ 500000) — the number of operations to perform. Each of the following q lines contains two space-separated numbers ci (1 ≤ ci ≤ 3), vi (1 ≤ vi ≤ n), where ci is the operation type (according to the numbering given in the statement), and vi is the vertex on which the operation is performed.It is guaranteed that the given graph is a tree.\n\nOutputFor each type 3 operation print 1 on a separate line if the vertex is full, and 0 if the vertex is empty. Print the answers to queries in the order in which the queries are given in the input.\n\nInputCopy51 25 12 34 2121 12 33 13 23 33 41 22 43 13 33 43 5OutputCopy00010101\n\nInputCopy51 25 12 34 2121 12 33 13 23 33 41 22 43 13 33 43 5\n\nOutputCopy00010101",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Hello everyone!The anniversary Codeforces Round #200 is scheduled to take place today at 7:30 PM Moscow time. The round will be held in both divisions and will be rated.The round problems were prepared by Evgeny Vihrov (gen), Andrey Vihrov (andreyv) and Gerald Agapov (Gerald). As always, we would like to thank Mike Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems, and also Maria Belova (Delinur) for translating the problem statements.In this round you will help mad scientist Mike to realise his peculiar ideas and carry out unusual experiments. The authors think that the problems constitute a good balance between mathematics and programming. We also tried to make the statements short and easy to read :] As always, we hope that every participant will find a problem to his taste.We wish you good luck and an interesting round!UPD1: Score distribution is standard:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Congratulations to the top 5 winners in each division!DivIDivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1108
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces",
          "content": "344A - MagnetsBy the definition each block consists of a number of consequent and equally oriented dominoes. That means that in places where adjacent dominoes are not oriented equally, one block ends and another block starts. So, if there are x such places, the answer is equal to x + 1.Solution complexity: O(n). Problem author: gen.Bonus: The problem was created a day before the contest and filled in the last part of a physically flavoured DivII complect. :]344B - Simple MoleculesFirst solution. First, the sum a + b + c should be even, since each bond adds 2 to the sum. Now let x, y, z be the number of bonds between 1st and 2nd, 2nd and 3rd, 3rd and 1st atoms, accordingly. So we have to solve the system x + z = a, y + x = b, z + y = c. Now observe that the solution to the system is the length of the tangents on the triangle with sides of length a, b, c to its inscribed circle, and are equal to , , . If the problem asked only the possibility of building such a molecule, we could just check if there exists (possibly degenerate) triangle with sides a, b, c.Second solution. Bruteforce all x values. For a fixed x values of y and z are defined uniquely: y = b - x, z = a - x.Solution complexity: O(1) / O(n). Problem authors: gen, andreyv.Bonus: Can you solve the problem for any vertex number n? When and how can such a graph be built?343A - Rational ResistanceIf a fraction can be obtained with k resistors, then it is simple to calculate that we can obtain fractions and with k + 1 resistors. So adding one resistor means performing one operation backwards in Euclidean algorithm. That means that the answer is equal to the number of steps in standard Euclidean algorithm.Solution complexity: . Problem authors: gen, andreyv.Бонус: At first we thought about the major problem (any two elements can be joined), but had a moment of eureka and got that the given problem unexpectedly naturally can be reduced to GCD. By the way, the result tree — http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Alternating CurrentLet us solve the following problem first: we are given a string of symbols A and B. If the i-th symbol is A, then at the i-th step the upper wire (see figure) is being put over the lower wire. If the i-th symbol is B, the lower wire is being put over the upper wire at i-th step. Observe that if some two symbols A and B are adjacent, we can untangle this place, throw the symbols out and obtain the string of length two symbols less. So the wires can be untangled iff the number of A's and B's in the string is the same. The given problem can be reduced to the described in a following fashion: in each odd position we change – to B and + to A. In each even position we change — to A and + to B. The reduction is correct, since on each even position the order of — and + are always swapped, and in each odd position their order is the same as in the beginning.Solution complexity: O(n). Problem authors: gen, andreyv.Bonus: If you are interested by this problem, you can learn about the braid theory http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: a harder version of this problem was planned already for Round #142, but the error in solution idea was found, and the problem was left to lay for almost a year.343C - Read TimeLet's search the answer t with the binary search. Fix some value of t. Look at the first head from the left h[i] that can read track p[0]. If p[0] > h[i], then h[i] goes to the right t seconds and reads all tracks on its way. Otherwise if p[0] ≤ h[i], then the head has two choices: go to the right seconds, then to the left and h[i] - p[0] again to the left; go to the left h[i] - p[0] seconds, then h[i] - p[0] to the right and t - 2·(h[i] - p[0]) again to the right. Obviously, for h[i] it is more advantageous to visit the track positioned as much as possible to the right. So we choose by . Then we move the pointer onto the first unread track, and repeat the algorithm for h[i + 1], and so on with each head.Solution complexity: . Problem authors: gen, gorbunov.Bonus: The problem is completely real, if the disk has only a single head, if we know, what tracks should be read; then the optimal algorithm chooses between the two choices described above. I and gorbunov were listening this on a lecture, and created the given problem out of boredom ;]343D - Water TreeLet's learn how to color a whole subtree. For that enumerate all vertices in post-order DFS. Then each subtree covers a single continious vertex number segment. For each vertex we store the bounds of such segment for a subtree with a root in this vertex. Then to color a subtree means to color a segment in a segment tree.Then create a segment tree that has a following property: if a vertex v was emptied, and is still empty, then this vertex is colored in the segment tree. In the beginning \"empty\" all the vertices. That is, color all the vertices in the segment tree. With this tree we can efficiently process the queries: Fill a vertex v. Clean the interval for the subtree of v. If before that some vertex of a subtree was empty, color the parent of v. Empty a vertex v. Color the vertex v in the segment tree. Reply whether a vertex v is filled. If in the segment tree at least one vertex is colored, then there is such a descendant of v that is empty now, so the vertex v is not filled. Shtrix noted that essentially the same solution can be implemented with only a single set.Solution complexity: . Problem author: gen.Bonus: Some participants could see the similarities with a problem Ball Machine from BOI 2013, but the solutions to the both problems are quite different.343E - Pumping StationsIn this problem we are asked to find such graph vertex permutation that maximizes the sum of the maximum flows sent between each two consequtive vertices in the permutation.The problem can be solved with Gomory-Hu tree data structure. For a given weighted graph the tree has the following properties: The vertex set of the tree and the graph is the same. The maximum flow between vertices u and v in the tree is equal to the maximum flow in the graph. Surprisingly, such a tree exists for any weighted graph, and can be built in O(n·maxFlow). It appears that the answer to the problem is equal to the sum of the edge weights in this tree.We prove this statement by induction on the number of the tree vertices. Pick the edge (u, v) with the smallest weight in the tree. Consider that in an optimal permutation more than one path between two adjacent verteces in the permutation passes through this edge. Erase all these paths, then each of the u and v subtrees holds a set of disjoint remaining paths from the permutation. For each set, join all the paths in one chain, obtaining two chains. These chains we join by a path s that goes trough the edge (u, v). Thus we have built a permutation that is not worse than the considered one. For a path s the edge (u, v) is the smallest, so the flow along this path is equal to the weight of this edge. It follows from the induction that in subtrees u and v the answer is equal to the sum of edges. By adding the weight of edge (u, v), we get the desired result.From the last paragraph it is clear how to build such a permutation: take the smallest edge, obtain two chains from the vertex subtrees recursively, and add them together to form a one chain. Since there are not many vertices, we can do this part in O(n2).Solution complexity: O(n·maxFlow). Problem authors: gen, Gerald.Bonus: Shortly before the contest we decided to make the constraints more loyal, so some solution that find Gomory-Hu tree by finding flow O(n2) times also passed. We hope that nobody is particularly saddened by this fact. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 343\\s*D"
          },
          "content_length": 7699
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 1",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 2",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 3",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 4",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 5",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 6",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000 + 10;\n\nint parent[MAXN];\n\nint find_set(int v) {\n    if (parent[v] == v)\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a vertex to itself at line %d\", i + 2);\n\n        int pa = find_set(a);\n        int pb = find_set(b);\n\n        ensuref(pa != pb, \"Graph contains a cycle at edge %d (connecting %d and %d)\", i + 2, a, b);\n\n        parent[pb] = pa;\n    }\n    \n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int c = inf.readInt(1, 3, \"c_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000 + 10;\n\nint parent[MAXN];\n\nint find_set(int v) {\n    if (parent[v] == v)\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a vertex to itself at line %d\", i + 2);\n\n        int pa = find_set(a);\n        int pb = find_set(b);\n\n        ensuref(pa != pb, \"Graph contains a cycle at edge %d (connecting %d and %d)\", i + 2, a, b);\n\n        parent[pb] = pa;\n    }\n    \n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int c = inf.readInt(1, 3, \"c_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000 + 10;\n\nint parent[MAXN];\n\nint find_set(int v) {\n    if (parent[v] == v)\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a vertex to itself at line %d\", i + 2);\n\n        int pa = find_set(a);\n        int pb = find_set(b);\n\n        ensuref(pa != pb, \"Graph contains a cycle at edge %d (connecting %d and %d)\", i + 2, a, b);\n\n        parent[pb] = pa;\n    }\n    \n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int c = inf.readInt(1, 3, \"c_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line options\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string op_type = opt<string>(\"op\", \"random\");\n\n    ensure(n >= 1 && n <= 500000);\n    ensure(q >= 1 && q <= 500000);\n\n    // Generate tree\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        // Connect i to i - 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Connect all nodes to root 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        vector<int> nodes = {1};\n        int idx = 0;\n        while ((int)nodes.size() < n) {\n            int u = nodes[idx++];\n            int left = nodes.size() + 1;\n            if (left <= n) {\n                edges.push_back({u, left});\n                nodes.push_back(left);\n            }\n            int right = nodes.size() + 1;\n            if (right <= n) {\n                edges.push_back({u, right});\n                nodes.push_back(right);\n            }\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Now generate q operations\n    vector<pair<int, int>> operations;\n    if (op_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int ci = rnd.next(1, 3);\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"fills\") {\n        for (int i = 0; i < q; ++i) {\n            int ci;\n            if (i % 2 == 0) {\n                ci = 1; // Fill\n            } else {\n                ci = 3; // Query\n            }\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"empties\") {\n        for (int i = 0; i < q; ++i) {\n            int ci;\n            if (i % 2 == 0) {\n                ci = 2; // Empty\n            } else {\n                ci = 3; // Query\n            }\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"full_queries\") {\n        // All operations are queries\n        for (int i = 0; i < q; ++i) {\n            int ci = 3; // Query\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"special1\") {\n        // Alternate fills and empties and queries\n        vector<int> ops = {1, 2, 3}; // Fill, Empty, Query\n        for (int i = 0; i < q; ++i) {\n            int ci = ops[i % ops.size()];\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"special2\") {\n        // Fill root, empty random node, query random nodes\n        for (int i = 0; i < q; ++i) {\n            int ci;\n            int vi;\n            if (i % 4 == 0) {\n                ci = 1; // Fill\n                vi = 1; // Root\n            } else if (i % 4 == 1) {\n                ci = 2; // Empty\n                vi = rnd.next(1, n);\n            } else {\n                ci = 3; // Query\n                vi = rnd.next(1, n);\n            }\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"max_queries\") {\n        // Maximize the number of queries\n        for (int i = 0; i < q; ++i) {\n            int ci;\n            if (i < q / 2) {\n                ci = rnd.next(1, 2); // Fill or Empty\n            } else {\n                ci = 3; // Query\n            }\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    }\n\n    // Output q\n    printf(\"%d\\n\", q);\n    // Output operations\n    for (auto op : operations) {\n        printf(\"%d %d\\n\", op.first, op.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line options\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string op_type = opt<string>(\"op\", \"random\");\n\n    ensure(n >= 1 && n <= 500000);\n    ensure(q >= 1 && q <= 500000);\n\n    // Generate tree\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        // Connect i to i - 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Connect all nodes to root 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        vector<int> nodes = {1};\n        int idx = 0;\n        while ((int)nodes.size() < n) {\n            int u = nodes[idx++];\n            int left = nodes.size() + 1;\n            if (left <= n) {\n                edges.push_back({u, left});\n                nodes.push_back(left);\n            }\n            int right = nodes.size() + 1;\n            if (right <= n) {\n                edges.push_back({u, right});\n                nodes.push_back(right);\n            }\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Now generate q operations\n    vector<pair<int, int>> operations;\n    if (op_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int ci = rnd.next(1, 3);\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"fills\") {\n        for (int i = 0; i < q; ++i) {\n            int ci;\n            if (i % 2 == 0) {\n                ci = 1; // Fill\n            } else {\n                ci = 3; // Query\n            }\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"empties\") {\n        for (int i = 0; i < q; ++i) {\n            int ci;\n            if (i % 2 == 0) {\n                ci = 2; // Empty\n            } else {\n                ci = 3; // Query\n            }\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"full_queries\") {\n        // All operations are queries\n        for (int i = 0; i < q; ++i) {\n            int ci = 3; // Query\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"special1\") {\n        // Alternate fills and empties and queries\n        vector<int> ops = {1, 2, 3}; // Fill, Empty, Query\n        for (int i = 0; i < q; ++i) {\n            int ci = ops[i % ops.size()];\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"special2\") {\n        // Fill root, empty random node, query random nodes\n        for (int i = 0; i < q; ++i) {\n            int ci;\n            int vi;\n            if (i % 4 == 0) {\n                ci = 1; // Fill\n                vi = 1; // Root\n            } else if (i % 4 == 1) {\n                ci = 2; // Empty\n                vi = rnd.next(1, n);\n            } else {\n                ci = 3; // Query\n                vi = rnd.next(1, n);\n            }\n            operations.push_back({ci, vi});\n        }\n    } else if (op_type == \"max_queries\") {\n        // Maximize the number of queries\n        for (int i = 0; i < q; ++i) {\n            int ci;\n            if (i < q / 2) {\n                ci = rnd.next(1, 2); // Fill or Empty\n            } else {\n                ci = 3; // Query\n            }\n            int vi = rnd.next(1, n);\n            operations.push_back({ci, vi});\n        }\n    }\n\n    // Output q\n    printf(\"%d\\n\", q);\n    // Output operations\n    for (auto op : operations) {\n        printf(\"%d %d\\n\", op.first, op.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -tree chain -op random\n./gen -n 2 -q 2 -tree chain -op random\n./gen -n 2 -q 2 -tree star -op random\n./gen -n 10 -q 10 -tree chain -op random\n./gen -n 10 -q 10 -tree star -op random\n./gen -n 10 -q 10 -tree balanced -op random\n./gen -n 10 -q 10 -tree random -op random\n\n./gen -n 100 -q 100 -tree chain -op fills\n./gen -n 100 -q 100 -tree star -op empties\n./gen -n 100 -q 100 -tree balanced -op special1\n./gen -n 100 -q 100 -tree random -op special2\n\n./gen -n 1000 -q 1000 -tree chain -op random\n./gen -n 1000 -q 1000 -tree star -op random\n./gen -n 1000 -q 1000 -tree balanced -op random\n./gen -n 1000 -q 1000 -tree random -op random\n\n./gen -n 10000 -q 10000 -tree chain -op fills\n./gen -n 10000 -q 10000 -tree star -op empties\n./gen -n 10000 -q 10000 -tree balanced -op max_queries\n./gen -n 10000 -q 10000 -tree random -op full_queries\n\n./gen -n 100000 -q 100000 -tree chain -op random\n./gen -n 100000 -q 100000 -tree star -op special1\n./gen -n 100000 -q 100000 -tree balanced -op special2\n./gen -n 100000 -q 100000 -tree random -op random\n\n./gen -n 500000 -q 500000 -tree chain -op random\n./gen -n 500000 -q 500000 -tree star -op random\n./gen -n 500000 -q 500000 -tree balanced -op random\n./gen -n 500000 -q 500000 -tree random -op random\n./gen -n 500000 -q 500000 -tree chain -op max_queries\n./gen -n 500000 -q 500000 -tree star -op fills\n./gen -n 500000 -q 500000 -tree balanced -op empties\n./gen -n 500000 -q 500000 -tree random -op special2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:27.945958",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "343/E",
      "title": "E. Pumping Stations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers n and m (2 ≤ n ≤ 200, 1 ≤ m ≤ 1000) — the number of stations and pipes in the system, accordingly. The i-th of the next m lines contains three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 100) — the numbers of stations connected by the i-th pipe and the pipe's bandwidth, accordingly. It is guaranteed that any two stations are connected by at most one pipe and that there is a pipe path between any two stations.",
      "output_spec": "OutputOn the first line print a single integer — the maximum salary Mike can earn.On the second line print a space-separated permutation of n numbers from 1 to n — the numbers of stations in the sequence v1, v2, ..., vn. If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy6 111 2 101 6 82 3 42 5 22 6 33 4 53 5 43 6 24 5 74 6 25 6 3OutputCopy776 2 1 5 3 4",
      "description": "E. Pumping Stations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two space-separated integers n and m (2 ≤ n ≤ 200, 1 ≤ m ≤ 1000) — the number of stations and pipes in the system, accordingly. The i-th of the next m lines contains three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 100) — the numbers of stations connected by the i-th pipe and the pipe's bandwidth, accordingly. It is guaranteed that any two stations are connected by at most one pipe and that there is a pipe path between any two stations.\n\nOutputOn the first line print a single integer — the maximum salary Mike can earn.On the second line print a space-separated permutation of n numbers from 1 to n — the numbers of stations in the sequence v1, v2, ..., vn. If there are multiple answers, print any of them.\n\nInputCopy6 111 2 101 6 82 3 42 5 22 6 33 4 53 5 43 6 24 5 74 6 25 6 3OutputCopy776 2 1 5 3 4\n\nInputCopy6 111 2 101 6 82 3 42 5 22 6 33 4 53 5 43 6 24 5 74 6 25 6 3\n\nOutputCopy776 2 1 5 3 4",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Hello everyone!The anniversary Codeforces Round #200 is scheduled to take place today at 7:30 PM Moscow time. The round will be held in both divisions and will be rated.The round problems were prepared by Evgeny Vihrov (gen), Andrey Vihrov (andreyv) and Gerald Agapov (Gerald). As always, we would like to thank Mike Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems, and also Maria Belova (Delinur) for translating the problem statements.In this round you will help mad scientist Mike to realise his peculiar ideas and carry out unusual experiments. The authors think that the problems constitute a good balance between mathematics and programming. We also tried to make the statements short and easy to read :] As always, we hope that every participant will find a problem to his taste.We wish you good luck and an interesting round!UPD1: Score distribution is standard:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Congratulations to the top 5 winners in each division!DivIDivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1108
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces",
          "content": "344A - MagnetsBy the definition each block consists of a number of consequent and equally oriented dominoes. That means that in places where adjacent dominoes are not oriented equally, one block ends and another block starts. So, if there are x such places, the answer is equal to x + 1.Solution complexity: O(n). Problem author: gen.Bonus: The problem was created a day before the contest and filled in the last part of a physically flavoured DivII complect. :]344B - Simple MoleculesFirst solution. First, the sum a + b + c should be even, since each bond adds 2 to the sum. Now let x, y, z be the number of bonds between 1st and 2nd, 2nd and 3rd, 3rd and 1st atoms, accordingly. So we have to solve the system x + z = a, y + x = b, z + y = c. Now observe that the solution to the system is the length of the tangents on the triangle with sides of length a, b, c to its inscribed circle, and are equal to , , . If the problem asked only the possibility of building such a molecule, we could just check if there exists (possibly degenerate) triangle with sides a, b, c.Second solution. Bruteforce all x values. For a fixed x values of y and z are defined uniquely: y = b - x, z = a - x.Solution complexity: O(1) / O(n). Problem authors: gen, andreyv.Bonus: Can you solve the problem for any vertex number n? When and how can such a graph be built?343A - Rational ResistanceIf a fraction can be obtained with k resistors, then it is simple to calculate that we can obtain fractions and with k + 1 resistors. So adding one resistor means performing one operation backwards in Euclidean algorithm. That means that the answer is equal to the number of steps in standard Euclidean algorithm.Solution complexity: . Problem authors: gen, andreyv.Бонус: At first we thought about the major problem (any two elements can be joined), but had a moment of eureka and got that the given problem unexpectedly naturally can be reduced to GCD. By the way, the result tree — http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Alternating CurrentLet us solve the following problem first: we are given a string of symbols A and B. If the i-th symbol is A, then at the i-th step the upper wire (see figure) is being put over the lower wire. If the i-th symbol is B, the lower wire is being put over the upper wire at i-th step. Observe that if some two symbols A and B are adjacent, we can untangle this place, throw the symbols out and obtain the string of length two symbols less. So the wires can be untangled iff the number of A's and B's in the string is the same. The given problem can be reduced to the described in a following fashion: in each odd position we change – to B and + to A. In each even position we change — to A and + to B. The reduction is correct, since on each even position the order of — and + are always swapped, and in each odd position their order is the same as in the beginning.Solution complexity: O(n). Problem authors: gen, andreyv.Bonus: If you are interested by this problem, you can learn about the braid theory http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: a harder version of this problem was planned already for Round #142, but the error in solution idea was found, and the problem was left to lay for almost a year.343C - Read TimeLet's search the answer t with the binary search. Fix some value of t. Look at the first head from the left h[i] that can read track p[0]. If p[0] > h[i], then h[i] goes to the right t seconds and reads all tracks on its way. Otherwise if p[0] ≤ h[i], then the head has two choices: go to the right seconds, then to the left and h[i] - p[0] again to the left; go to the left h[i] - p[0] seconds, then h[i] - p[0] to the right and t - 2·(h[i] - p[0]) again to the right. Obviously, for h[i] it is more advantageous to visit the track positioned as much as possible to the right. So we choose by . Then we move the pointer onto the first unread track, and repeat the algorithm for h[i + 1], and so on with each head.Solution complexity: . Problem authors: gen, gorbunov.Bonus: The problem is completely real, if the disk has only a single head, if we know, what tracks should be read; then the optimal algorithm chooses between the two choices described above. I and gorbunov were listening this on a lecture, and created the given problem out of boredom ;]343D - Water TreeLet's learn how to color a whole subtree. For that enumerate all vertices in post-order DFS. Then each subtree covers a single continious vertex number segment. For each vertex we store the bounds of such segment for a subtree with a root in this vertex. Then to color a subtree means to color a segment in a segment tree.Then create a segment tree that has a following property: if a vertex v was emptied, and is still empty, then this vertex is colored in the segment tree. In the beginning \"empty\" all the vertices. That is, color all the vertices in the segment tree. With this tree we can efficiently process the queries: Fill a vertex v. Clean the interval for the subtree of v. If before that some vertex of a subtree was empty, color the parent of v. Empty a vertex v. Color the vertex v in the segment tree. Reply whether a vertex v is filled. If in the segment tree at least one vertex is colored, then there is such a descendant of v that is empty now, so the vertex v is not filled. Shtrix noted that essentially the same solution can be implemented with only a single set.Solution complexity: . Problem author: gen.Bonus: Some participants could see the similarities with a problem Ball Machine from BOI 2013, but the solutions to the both problems are quite different.343E - Pumping StationsIn this problem we are asked to find such graph vertex permutation that maximizes the sum of the maximum flows sent between each two consequtive vertices in the permutation.The problem can be solved with Gomory-Hu tree data structure. For a given weighted graph the tree has the following properties: The vertex set of the tree and the graph is the same. The maximum flow between vertices u and v in the tree is equal to the maximum flow in the graph. Surprisingly, such a tree exists for any weighted graph, and can be built in O(n·maxFlow). It appears that the answer to the problem is equal to the sum of the edge weights in this tree.We prove this statement by induction on the number of the tree vertices. Pick the edge (u, v) with the smallest weight in the tree. Consider that in an optimal permutation more than one path between two adjacent verteces in the permutation passes through this edge. Erase all these paths, then each of the u and v subtrees holds a set of disjoint remaining paths from the permutation. For each set, join all the paths in one chain, obtaining two chains. These chains we join by a path s that goes trough the edge (u, v). Thus we have built a permutation that is not worse than the considered one. For a path s the edge (u, v) is the smallest, so the flow along this path is equal to the weight of this edge. It follows from the induction that in subtrees u and v the answer is equal to the sum of edges. By adding the weight of edge (u, v), we get the desired result.From the last paragraph it is clear how to build such a permutation: take the smallest edge, obtain two chains from the vertex subtrees recursively, and add them together to form a one chain. Since there are not many vertices, we can do this part in O(n2).Solution complexity: O(n·maxFlow). Problem authors: gen, Gerald.Bonus: Shortly before the contest we decided to make the constraints more loyal, so some solution that find Gomory-Hu tree by finding flow O(n2) times also passed. We hope that nobody is particularly saddened by this fact. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 343\\s*E"
          },
          "content_length": 7699
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 1",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 2",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 3",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 4",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 5",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 6",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Union-Find (Disjoint Set Union) data structure for connectedness check\nstruct DSU {\n    vector<int> parent;\n    DSU(int n) {\n        parent.resize(n+1); // assuming nodes are numbered from 1 to n\n        for(int i = 1; i <= n; ++i)\n            parent[i] = i;\n    }\n    int find(int x) {\n        if(parent[x] != x)\n            parent[x] = find(parent[x]); // Path compression\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        int par_x = find(x);\n        int par_y = find(y);\n        if(par_x != par_y) {\n            parent[par_x] = par_y;\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges; // To check for duplicate edges\n    DSU dsu(n);\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge %d has ai == bi (%d)\", i+1, ai);\n        inf.readSpace();\n        int ci = inf.readInt(1, 100, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n        dsu.unite(ai, bi);\n    }\n\n    // Check that the graph is connected\n    int root = dsu.find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(dsu.find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Union-Find (Disjoint Set Union) data structure for connectedness check\nstruct DSU {\n    vector<int> parent;\n    DSU(int n) {\n        parent.resize(n+1); // assuming nodes are numbered from 1 to n\n        for(int i = 1; i <= n; ++i)\n            parent[i] = i;\n    }\n    int find(int x) {\n        if(parent[x] != x)\n            parent[x] = find(parent[x]); // Path compression\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        int par_x = find(x);\n        int par_y = find(y);\n        if(par_x != par_y) {\n            parent[par_x] = par_y;\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges; // To check for duplicate edges\n    DSU dsu(n);\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge %d has ai == bi (%d)\", i+1, ai);\n        inf.readSpace();\n        int ci = inf.readInt(1, 100, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n        dsu.unite(ai, bi);\n    }\n\n    // Check that the graph is connected\n    int root = dsu.find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(dsu.find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Union-Find (Disjoint Set Union) data structure for connectedness check\nstruct DSU {\n    vector<int> parent;\n    DSU(int n) {\n        parent.resize(n+1); // assuming nodes are numbered from 1 to n\n        for(int i = 1; i <= n; ++i)\n            parent[i] = i;\n    }\n    int find(int x) {\n        if(parent[x] != x)\n            parent[x] = find(parent[x]); // Path compression\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        int par_x = find(x);\n        int par_y = find(y);\n        if(par_x != par_y) {\n            parent[par_x] = par_y;\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges; // To check for duplicate edges\n    DSU dsu(n);\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge %d has ai == bi (%d)\", i+1, ai);\n        inf.readSpace();\n        int ci = inf.readInt(1, 100, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n        dsu.unite(ai, bi);\n    }\n\n    // Check that the graph is connected\n    int root = dsu.find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(dsu.find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 201;\n\nint n, m;\nint capacity[MAXN][MAXN];\nvector<int> adj[MAXN];\n\nint readAns(InStream& stream, vector<int>& v) {\n    int totalSalary = stream.readInt(0, INT_MAX, \"total salary\");\n    v = stream.readInts(n, 1, n, \"station sequence\");\n    if (set<int>(v.begin(), v.end()).size() != n)\n        stream.quitf(_wa, \"the sequence of stations is not a permutation\");\n    return totalSalary;\n}\n\nint bfs(int s, int t, vector<int>& parent, int cap[MAXN][MAXN]) {\n    fill(parent.begin(), parent.end(), -1);\n    parent[s] = -2;\n    queue<pair<int, int>> q;\n    q.push({s, INT_MAX});\n    while (!q.empty()) {\n        int cur = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n        for (int next = 1; next <= n; next++) {\n            if (parent[next] == -1 && cap[cur][next] > 0) {\n                parent[next] = cur;\n                int new_flow = min(flow, cap[cur][next]);\n                if (next == t)\n                    return new_flow;\n                q.push({next, new_flow});\n            }\n        }\n    }\n    return 0;\n}\n\nint maxflow(int s, int t, int cap[MAXN][MAXN]) {\n    int flow = 0;\n    vector<int> parent(n + 1);\n    int new_flow;\n    while (new_flow = bfs(s, t, parent, cap)) {\n        flow += new_flow;\n        int cur = t;\n        while (cur != s) {\n            int prev = parent[cur];\n            cap[prev][cur] -= new_flow;\n            cap[cur][prev] += new_flow;\n            cur = prev;\n        }\n    }\n    return flow;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    m = inf.readInt();\n    memset(capacity, 0, sizeof(capacity));\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt();\n        int b = inf.readInt();\n        int c = inf.readInt();\n        capacity[a][b] += c;\n        capacity[b][a] += c;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int jurySalary;\n    vector<int> jurySequence;\n    jurySalary = readAns(ans, jurySequence);\n\n    int participantSalary;\n    vector<int> participantSequence;\n    participantSalary = readAns(ouf, participantSequence);\n\n    // Check if participant's sequence is a permutation\n    if (set<int>(participantSequence.begin(), participantSequence.end()).size() != n)\n        quitf(_wa, \"the sequence of stations is not a permutation\");\n\n    int totalFlow = 0;\n    for (int i = 0; i < n - 1; i++) {\n        int vi = participantSequence[i];\n        int vi1 = participantSequence[i + 1];\n\n        int capCopy[MAXN][MAXN];\n        memcpy(capCopy, capacity, sizeof(capCopy));\n\n        // Remove all incoming edges to vi (source)\n        for (int u = 1; u <= n; u++) {\n            capCopy[u][vi] = 0;\n        }\n\n        // Remove all outgoing edges from vi1 (sink)\n        for (int u = 1; u <= n; u++) {\n            capCopy[vi1][u] = 0;\n        }\n\n        int flow = maxflow(vi, vi1, capCopy);\n        totalFlow += flow;\n    }\n\n    if (totalFlow != participantSalary)\n        quitf(_wa, \"the total flow (%d) does not match the participant's reported salary (%d)\", totalFlow, participantSalary);\n\n    if (participantSalary < jurySalary)\n        quitf(_wa, \"participant's salary (%d) is less than jury's salary (%d)\", participantSalary, jurySalary);\n    else if (participantSalary == jurySalary)\n        quitf(_ok, \"correct salary = %d\", participantSalary);\n    else\n        quitf(_fail, \"participant's salary (%d) is greater than jury's salary (%d)\", participantSalary, jurySalary);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    int minCapacity = opt<int>(\"minCapacity\", 1);\n    int maxCapacity = opt<int>(\"maxCapacity\", 100);\n\n    if (n < 2 || n > 200) {\n        cerr << \"n must be between 2 and 200.\\n\";\n        exit(1);\n    }\n\n    int max_possible_edges = n * (n - 1) / 2;\n    if (max_possible_edges > 1000) max_possible_edges = 1000;\n\n    if (m == -1) {\n        if (type == \"complete_graph\") {\n            m = n * (n - 1) / 2;\n            if (m > 1000) m = 1000;\n        } else if (type == \"dense_graph\") {\n            m = min(1000, n * (n - 1) / 2);\n        } else {\n            m = n - 1; // Minimal connected graph\n        }\n    } else {\n        if (m < n - 1) {\n            cerr << \"m cannot be less than n - 1 to ensure connectivity.\\n\";\n            exit(1);\n        }\n        if (m > max_possible_edges) {\n            cerr << \"m cannot be more than \" << max_possible_edges << \".\\n\";\n            exit(1);\n        }\n    }\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edge_set;\n\n    if (type == \"chain\") {\n        // Generate a chain graph\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i + 1));\n            edge_set.insert(make_pair(min(i, i + 1), max(i, i + 1)));\n        }\n    } else if (type == \"star\") {\n        // Generate a star graph\n        int center = 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(center, i));\n            edge_set.insert(make_pair(min(center, i), max(center, i)));\n        }\n    } else if (type == \"random_tree\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n            edge_set.insert(make_pair(min(u, v), max(u, v)));\n        }\n    } else if (type == \"complete_graph\") {\n        // Generate a complete graph\n        for (int i = 1; i <= n && edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && edges.size() < m; ++j) {\n                edges.push_back(make_pair(i, j));\n                edge_set.insert(make_pair(i, j));\n            }\n        }\n    } else if (type == \"random_graph\" || type == \"dense_graph\" || type == \"sparse_graph\") {\n        // Generate a random connected graph with m edges\n        // Start with a random spanning tree to ensure connectivity\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n            edge_set.insert(make_pair(min(u, v), max(u, v)));\n        }\n        // Add extra edges randomly until we have m edges\n        int extra_edges = m - (n - 1);\n        while (extra_edges > 0) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            auto edge = make_pair(min(u, v), max(u, v));\n            if (edge_set.count(edge)) continue;\n            edges.push_back(make_pair(u, v));\n            edge_set.insert(edge);\n            --extra_edges;\n        }\n    } else {\n        cerr << \"Unknown graph type.\\n\";\n        exit(1);\n    }\n\n    // Assign capacities to edges\n    vector<int> capacities;\n    for (size_t i = 0; i < edges.size(); ++i) {\n        capacities.push_back(rnd.next(minCapacity, maxCapacity));\n    }\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int c = capacities[i];\n        printf(\"%d %d %d\\n\", u, v, c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    int minCapacity = opt<int>(\"minCapacity\", 1);\n    int maxCapacity = opt<int>(\"maxCapacity\", 100);\n\n    if (n < 2 || n > 200) {\n        cerr << \"n must be between 2 and 200.\\n\";\n        exit(1);\n    }\n\n    int max_possible_edges = n * (n - 1) / 2;\n    if (max_possible_edges > 1000) max_possible_edges = 1000;\n\n    if (m == -1) {\n        if (type == \"complete_graph\") {\n            m = n * (n - 1) / 2;\n            if (m > 1000) m = 1000;\n        } else if (type == \"dense_graph\") {\n            m = min(1000, n * (n - 1) / 2);\n        } else {\n            m = n - 1; // Minimal connected graph\n        }\n    } else {\n        if (m < n - 1) {\n            cerr << \"m cannot be less than n - 1 to ensure connectivity.\\n\";\n            exit(1);\n        }\n        if (m > max_possible_edges) {\n            cerr << \"m cannot be more than \" << max_possible_edges << \".\\n\";\n            exit(1);\n        }\n    }\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edge_set;\n\n    if (type == \"chain\") {\n        // Generate a chain graph\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i + 1));\n            edge_set.insert(make_pair(min(i, i + 1), max(i, i + 1)));\n        }\n    } else if (type == \"star\") {\n        // Generate a star graph\n        int center = 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(center, i));\n            edge_set.insert(make_pair(min(center, i), max(center, i)));\n        }\n    } else if (type == \"random_tree\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n            edge_set.insert(make_pair(min(u, v), max(u, v)));\n        }\n    } else if (type == \"complete_graph\") {\n        // Generate a complete graph\n        for (int i = 1; i <= n && edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && edges.size() < m; ++j) {\n                edges.push_back(make_pair(i, j));\n                edge_set.insert(make_pair(i, j));\n            }\n        }\n    } else if (type == \"random_graph\" || type == \"dense_graph\" || type == \"sparse_graph\") {\n        // Generate a random connected graph with m edges\n        // Start with a random spanning tree to ensure connectivity\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n            edge_set.insert(make_pair(min(u, v), max(u, v)));\n        }\n        // Add extra edges randomly until we have m edges\n        int extra_edges = m - (n - 1);\n        while (extra_edges > 0) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            auto edge = make_pair(min(u, v), max(u, v));\n            if (edge_set.count(edge)) continue;\n            edges.push_back(make_pair(u, v));\n            edge_set.insert(edge);\n            --extra_edges;\n        }\n    } else {\n        cerr << \"Unknown graph type.\\n\";\n        exit(1);\n    }\n\n    // Assign capacities to edges\n    vector<int> capacities;\n    for (size_t i = 0; i < edges.size(); ++i) {\n        capacities.push_back(rnd.next(minCapacity, maxCapacity));\n    }\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int c = capacities[i];\n        printf(\"%d %d %d\\n\", u, v, c);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small graphs\n./gen -n 2 -type chain\n./gen -n 5 -type star\n./gen -n 10 -type random_tree\n./gen -n 10 -type random_graph -m 15\n./gen -n 10 -type complete_graph\n\n# Medium graphs\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type random_tree\n./gen -n 50 -type random_graph -m 100\n./gen -n 50 -type dense_graph\n./gen -n 50 -type random_graph -m 1225 -minCapacity 100 -maxCapacity 100\n\n# Large graphs\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type random_tree\n./gen -n 100 -type random_graph -m 500\n./gen -n 100 -type dense_graph\n./gen -n 100 -type random_graph -m 1000\n\n# Maximum size graphs\n./gen -n 200 -type random_tree\n./gen -n 200 -type chain\n./gen -n 200 -type star\n./gen -n 200 -type random_graph -m 1000\n./gen -n 200 -type dense_graph\n\n# Special capacity cases\n./gen -n 100 -type random_graph -m 300 -minCapacity 1 -maxCapacity 1    # All capacities are 1\n./gen -n 100 -type random_graph -m 300 -minCapacity 100 -maxCapacity 100 # All capacities are 100\n./gen -n 200 -type random_graph -m 1000 -minCapacity 1 -maxCapacity 1    # All capacities are 1\n./gen -n 200 -type random_graph -m 1000 -minCapacity 100 -maxCapacity 100 # All capacities are 100\n\n# Graphs designed to test capacity bottlenecks\n./gen -n 100 -type random_tree -minCapacity 1 -maxCapacity 100\n./gen -n 100 -type random_graph -m 200 -minCapacity 1 -maxCapacity 2\n./gen -n 100 -type random_graph -m 200 -minCapacity 99 -maxCapacity 100\n\n# Sparse graphs\n./gen -n 200 -type random_graph -m 199\n\n# Edge case: minimal m\n./gen -n 200 -type random_graph -m 199\n\n# Edge case: maximal m\n./gen -n 200 -type random_graph -m 1000\n\n# Dense graphs with varying capacities\n./gen -n 50 -type dense_graph -minCapacity 50 -maxCapacity 100\n./gen -n 100 -type dense_graph -minCapacity 1 -maxCapacity 50\n\n# Random graphs with specific capacities\n./gen -n 100 -type random_graph -m 400 -minCapacity 1 -maxCapacity 100\n./gen -n 100 -type random_graph -m 400 -minCapacity 50 -maxCapacity 50 # All capacities are 50\n\n# Complete graph with maximum edges (n=44 gives maximum edges ≤ 1000)\n./gen -n 44 -type complete_graph\n\n# Chain graph with maximum n\n./gen -n 200 -type chain -minCapacity 100 -maxCapacity 100\n\n# Star graph with minimum capacities\n./gen -n 200 -type star -minCapacity 1 -maxCapacity 1\n\n# Random tree with varying capacities\n./gen -n 200 -type random_tree -minCapacity 1 -maxCapacity 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:30.213283",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "344/A",
      "title": "A. Magnets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n (1 ≤ n ≤ 100000) — the number of magnets. Then n lines follow. The i-th line (1 ≤ i ≤ n) contains either characters \"01\", if Mike put the i-th magnet in the \"plus-minus\" position, or characters \"10\", if Mike put the magnet in the \"minus-plus\" position.",
      "output_spec": "OutputOn the single line of the output print the number of groups of magnets.",
      "sample_tests": "ExamplesInputCopy6101010011010OutputCopy3InputCopy401011010OutputCopy2",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n (1 ≤ n ≤ 100000) — the number of magnets. Then n lines follow. The i-th line (1 ≤ i ≤ n) contains either characters \"01\", if Mike put the i-th magnet in the \"plus-minus\" position, or characters \"10\", if Mike put the magnet in the \"minus-plus\" position.\n\nOutputOn the single line of the output print the number of groups of magnets.\n\nInputCopy6101010011010OutputCopy3InputCopy401011010OutputCopy2\n\nInputCopy6101010011010\n\nOutputCopy3\n\nInputCopy401011010\n\nOutputCopy2\n\nNoteThe first testcase corresponds to the figure. The testcase has three groups consisting of three, one and two magnets.The second testcase has two groups, each consisting of two magnets.",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Hello everyone!The anniversary Codeforces Round #200 is scheduled to take place today at 7:30 PM Moscow time. The round will be held in both divisions and will be rated.The round problems were prepared by Evgeny Vihrov (gen), Andrey Vihrov (andreyv) and Gerald Agapov (Gerald). As always, we would like to thank Mike Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems, and also Maria Belova (Delinur) for translating the problem statements.In this round you will help mad scientist Mike to realise his peculiar ideas and carry out unusual experiments. The authors think that the problems constitute a good balance between mathematics and programming. We also tried to make the statements short and easy to read :] As always, we hope that every participant will find a problem to his taste.We wish you good luck and an interesting round!UPD1: Score distribution is standard:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Congratulations to the top 5 winners in each division!DivIDivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1108
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces",
          "content": "344A - MagnetsBy the definition each block consists of a number of consequent and equally oriented dominoes. That means that in places where adjacent dominoes are not oriented equally, one block ends and another block starts. So, if there are x such places, the answer is equal to x + 1.Solution complexity: O(n). Problem author: gen.Bonus: The problem was created a day before the contest and filled in the last part of a physically flavoured DivII complect. :]344B - Simple MoleculesFirst solution. First, the sum a + b + c should be even, since each bond adds 2 to the sum. Now let x, y, z be the number of bonds between 1st and 2nd, 2nd and 3rd, 3rd and 1st atoms, accordingly. So we have to solve the system x + z = a, y + x = b, z + y = c. Now observe that the solution to the system is the length of the tangents on the triangle with sides of length a, b, c to its inscribed circle, and are equal to , , . If the problem asked only the possibility of building such a molecule, we could just check if there exists (possibly degenerate) triangle with sides a, b, c.Second solution. Bruteforce all x values. For a fixed x values of y and z are defined uniquely: y = b - x, z = a - x.Solution complexity: O(1) / O(n). Problem authors: gen, andreyv.Bonus: Can you solve the problem for any vertex number n? When and how can such a graph be built?343A - Rational ResistanceIf a fraction can be obtained with k resistors, then it is simple to calculate that we can obtain fractions and with k + 1 resistors. So adding one resistor means performing one operation backwards in Euclidean algorithm. That means that the answer is equal to the number of steps in standard Euclidean algorithm.Solution complexity: . Problem authors: gen, andreyv.Бонус: At first we thought about the major problem (any two elements can be joined), but had a moment of eureka and got that the given problem unexpectedly naturally can be reduced to GCD. By the way, the result tree — http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Alternating CurrentLet us solve the following problem first: we are given a string of symbols A and B. If the i-th symbol is A, then at the i-th step the upper wire (see figure) is being put over the lower wire. If the i-th symbol is B, the lower wire is being put over the upper wire at i-th step. Observe that if some two symbols A and B are adjacent, we can untangle this place, throw the symbols out and obtain the string of length two symbols less. So the wires can be untangled iff the number of A's and B's in the string is the same. The given problem can be reduced to the described in a following fashion: in each odd position we change – to B and + to A. In each even position we change — to A and + to B. The reduction is correct, since on each even position the order of — and + are always swapped, and in each odd position their order is the same as in the beginning.Solution complexity: O(n). Problem authors: gen, andreyv.Bonus: If you are interested by this problem, you can learn about the braid theory http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: a harder version of this problem was planned already for Round #142, but the error in solution idea was found, and the problem was left to lay for almost a year.343C - Read TimeLet's search the answer t with the binary search. Fix some value of t. Look at the first head from the left h[i] that can read track p[0]. If p[0] > h[i], then h[i] goes to the right t seconds and reads all tracks on its way. Otherwise if p[0] ≤ h[i], then the head has two choices: go to the right seconds, then to the left and h[i] - p[0] again to the left; go to the left h[i] - p[0] seconds, then h[i] - p[0] to the right and t - 2·(h[i] - p[0]) again to the right. Obviously, for h[i] it is more advantageous to visit the track positioned as much as possible to the right. So we choose by . Then we move the pointer onto the first unread track, and repeat the algorithm for h[i + 1], and so on with each head.Solution complexity: . Problem authors: gen, gorbunov.Bonus: The problem is completely real, if the disk has only a single head, if we know, what tracks should be read; then the optimal algorithm chooses between the two choices described above. I and gorbunov were listening this on a lecture, and created the given problem out of boredom ;]343D - Water TreeLet's learn how to color a whole subtree. For that enumerate all vertices in post-order DFS. Then each subtree covers a single continious vertex number segment. For each vertex we store the bounds of such segment for a subtree with a root in this vertex. Then to color a subtree means to color a segment in a segment tree.Then create a segment tree that has a following property: if a vertex v was emptied, and is still empty, then this vertex is colored in the segment tree. In the beginning \"empty\" all the vertices. That is, color all the vertices in the segment tree. With this tree we can efficiently process the queries: Fill a vertex v. Clean the interval for the subtree of v. If before that some vertex of a subtree was empty, color the parent of v. Empty a vertex v. Color the vertex v in the segment tree. Reply whether a vertex v is filled. If in the segment tree at least one vertex is colored, then there is such a descendant of v that is empty now, so the vertex v is not filled. Shtrix noted that essentially the same solution can be implemented with only a single set.Solution complexity: . Problem author: gen.Bonus: Some participants could see the similarities with a problem Ball Machine from BOI 2013, but the solutions to the both problems are quite different.343E - Pumping StationsIn this problem we are asked to find such graph vertex permutation that maximizes the sum of the maximum flows sent between each two consequtive vertices in the permutation.The problem can be solved with Gomory-Hu tree data structure. For a given weighted graph the tree has the following properties: The vertex set of the tree and the graph is the same. The maximum flow between vertices u and v in the tree is equal to the maximum flow in the graph. Surprisingly, such a tree exists for any weighted graph, and can be built in O(n·maxFlow). It appears that the answer to the problem is equal to the sum of the edge weights in this tree.We prove this statement by induction on the number of the tree vertices. Pick the edge (u, v) with the smallest weight in the tree. Consider that in an optimal permutation more than one path between two adjacent verteces in the permutation passes through this edge. Erase all these paths, then each of the u and v subtrees holds a set of disjoint remaining paths from the permutation. For each set, join all the paths in one chain, obtaining two chains. These chains we join by a path s that goes trough the edge (u, v). Thus we have built a permutation that is not worse than the considered one. For a path s the edge (u, v) is the smallest, so the flow along this path is equal to the weight of this edge. It follows from the induction that in subtrees u and v the answer is equal to the sum of edges. By adding the weight of edge (u, v), we get the desired result.From the last paragraph it is clear how to build such a permutation: take the smallest edge, obtain two chains from the vertex subtrees recursively, and add them together to form a one chain. Since there are not many vertices, we can do this part in O(n2).Solution complexity: O(n·maxFlow). Problem authors: gen, Gerald.Bonus: Shortly before the contest we decided to make the constraints more loyal, so some solution that find Gomory-Hu tree by finding flow O(n2) times also passed. We hope that nobody is particularly saddened by this fact. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 344\\s*A"
          },
          "content_length": 7699
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 1",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 2",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 3",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 4",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 5",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 6",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"(01|10)\", \"magnet\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"(01|10)\", \"magnet\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"(01|10)\", \"magnet\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int block_size = opt<int>(\"block_size\", 1);\n\n    vector<string> magnets(n);\n\n    if (type == \"all_same\") {\n        // All magnets have the same orientation\n        string orientation = rnd.next(2) ? \"10\" : \"01\";\n        fill(magnets.begin(), magnets.end(), orientation);\n    } else if (type == \"alternate\") {\n        // Magnets alternate between \"01\" and \"10\"\n        for (int i = 0; i < n; ++i) {\n            magnets[i] = (i % 2) ? \"10\" : \"01\";\n        }\n    } else if (type == \"blocks\") {\n        // Alternate blocks of magnets with a given block size\n        string orientations[2] = {\"10\", \"01\"};\n        int current = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i % block_size == 0 && i != 0)\n                current ^= 1;\n            magnets[i] = orientations[current];\n        }\n    } else if (type == \"one_change\") {\n        // All magnets have the same orientation except one change in the middle\n        string orientation = rnd.next(2) ? \"10\" : \"01\";\n        string opposite = (orientation == \"10\") ? \"01\" : \"10\";\n        for (int i = 0; i < n; ++i) {\n            if (i == n / 2)\n                magnets[i] = opposite;\n            else\n                magnets[i] = orientation;\n        }\n    } else if (type == \"random\") {\n        // Random orientations\n        for (int i = 0; i < n; ++i) {\n            magnets[i] = rnd.next(2) ? \"10\" : \"01\";\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", magnets[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int block_size = opt<int>(\"block_size\", 1);\n\n    vector<string> magnets(n);\n\n    if (type == \"all_same\") {\n        // All magnets have the same orientation\n        string orientation = rnd.next(2) ? \"10\" : \"01\";\n        fill(magnets.begin(), magnets.end(), orientation);\n    } else if (type == \"alternate\") {\n        // Magnets alternate between \"01\" and \"10\"\n        for (int i = 0; i < n; ++i) {\n            magnets[i] = (i % 2) ? \"10\" : \"01\";\n        }\n    } else if (type == \"blocks\") {\n        // Alternate blocks of magnets with a given block size\n        string orientations[2] = {\"10\", \"01\"};\n        int current = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i % block_size == 0 && i != 0)\n                current ^= 1;\n            magnets[i] = orientations[current];\n        }\n    } else if (type == \"one_change\") {\n        // All magnets have the same orientation except one change in the middle\n        string orientation = rnd.next(2) ? \"10\" : \"01\";\n        string opposite = (orientation == \"10\") ? \"01\" : \"10\";\n        for (int i = 0; i < n; ++i) {\n            if (i == n / 2)\n                magnets[i] = opposite;\n            else\n                magnets[i] = orientation;\n        }\n    } else if (type == \"random\") {\n        // Random orientations\n        for (int i = 0; i < n; ++i) {\n            magnets[i] = rnd.next(2) ? \"10\" : \"01\";\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", magnets[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type alternate\n./gen -n 1 -type random\n\n./gen -n 2 -type all_same\n./gen -n 2 -type alternate\n./gen -n 2 -type random\n\n./gen -n 5 -type all_same\n./gen -n 5 -type alternate\n./gen -n 5 -type random\n\n./gen -n 10 -type all_same\n./gen -n 10 -type alternate\n./gen -n 10 -type random\n\n./gen -n 100 -type all_same\n./gen -n 100 -type alternate\n./gen -n 100 -type blocks -block_size 10\n./gen -n 100 -type random\n./gen -n 100 -type one_change\n\n./gen -n 1000 -type all_same\n./gen -n 1000 -type alternate\n./gen -n 1000 -type blocks -block_size 50\n./gen -n 1000 -type random\n./gen -n 1000 -type one_change\n\n./gen -n 10000 -type all_same\n./gen -n 10000 -type alternate\n./gen -n 10000 -type blocks -block_size 100\n./gen -n 10000 -type random\n./gen -n 10000 -type one_change\n\n./gen -n 100000 -type all_same\n./gen -n 100000 -type alternate\n./gen -n 100000 -type blocks -block_size 1000\n./gen -n 100000 -type random\n./gen -n 100000 -type one_change\n\n# Edge cases with maximum size and specific patterns\n./gen -n 100000 -type all_same        # All magnets have the same orientation\n./gen -n 100000 -type alternate       # Magnets alternate orientations\n./gen -n 100000 -type random          # Random orientations\n./gen -n 100000 -type one_change      # One orientation change in the middle\n./gen -n 100000 -type blocks -block_size 50000  # Blocks of 50000 magnets\n./gen -n 100000 -type blocks -block_size 1      # Blocks of size 1 (same as alternate)\n./gen -n 100000 -type blocks -block_size 2      # Blocks of size 2\n./gen -n 100000 -type blocks -block_size 5000   # Blocks of size 5000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:31.892760",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "344/B",
      "title": "B. Simple Molecules",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 106) — the valence numbers of the given atoms.",
      "output_spec": "OutputIf such a molecule can be built, print three space-separated integers — the number of bonds between the 1-st and the 2-nd, the 2-nd and the 3-rd, the 3-rd and the 1-st atoms, correspondingly. If there are multiple solutions, output any of them. If there is no solution, print \"Impossible\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy1 1 2OutputCopy0 1 1InputCopy3 4 5OutputCopy1 3 2InputCopy4 1 1OutputCopyImpossible",
      "description": "B. Simple Molecules\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 106) — the valence numbers of the given atoms.\n\nOutputIf such a molecule can be built, print three space-separated integers — the number of bonds between the 1-st and the 2-nd, the 2-nd and the 3-rd, the 3-rd and the 1-st atoms, correspondingly. If there are multiple solutions, output any of them. If there is no solution, print \"Impossible\" (without the quotes).\n\nInputCopy1 1 2OutputCopy0 1 1InputCopy3 4 5OutputCopy1 3 2InputCopy4 1 1OutputCopyImpossible\n\nInputCopy1 1 2\n\nOutputCopy0 1 1\n\nInputCopy3 4 5\n\nOutputCopy1 3 2\n\nInputCopy4 1 1\n\nOutputCopyImpossible\n\nNoteThe first sample corresponds to the first figure. There are no bonds between atoms 1 and 2 in this case.The second sample corresponds to the second figure. There is one or more bonds between each pair of atoms.The third sample corresponds to the third figure. There is no solution, because an atom cannot form bonds with itself.The configuration in the fourth figure is impossible as each atom must have at least one atomic bond.",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Hello everyone!The anniversary Codeforces Round #200 is scheduled to take place today at 7:30 PM Moscow time. The round will be held in both divisions and will be rated.The round problems were prepared by Evgeny Vihrov (gen), Andrey Vihrov (andreyv) and Gerald Agapov (Gerald). As always, we would like to thank Mike Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems, and also Maria Belova (Delinur) for translating the problem statements.In this round you will help mad scientist Mike to realise his peculiar ideas and carry out unusual experiments. The authors think that the problems constitute a good balance between mathematics and programming. We also tried to make the statements short and easy to read :] As always, we hope that every participant will find a problem to his taste.We wish you good luck and an interesting round!UPD1: Score distribution is standard:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Congratulations to the top 5 winners in each division!DivIDivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1108
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces",
          "content": "344A - MagnetsBy the definition each block consists of a number of consequent and equally oriented dominoes. That means that in places where adjacent dominoes are not oriented equally, one block ends and another block starts. So, if there are x such places, the answer is equal to x + 1.Solution complexity: O(n). Problem author: gen.Bonus: The problem was created a day before the contest and filled in the last part of a physically flavoured DivII complect. :]344B - Simple MoleculesFirst solution. First, the sum a + b + c should be even, since each bond adds 2 to the sum. Now let x, y, z be the number of bonds between 1st and 2nd, 2nd and 3rd, 3rd and 1st atoms, accordingly. So we have to solve the system x + z = a, y + x = b, z + y = c. Now observe that the solution to the system is the length of the tangents on the triangle with sides of length a, b, c to its inscribed circle, and are equal to , , . If the problem asked only the possibility of building such a molecule, we could just check if there exists (possibly degenerate) triangle with sides a, b, c.Second solution. Bruteforce all x values. For a fixed x values of y and z are defined uniquely: y = b - x, z = a - x.Solution complexity: O(1) / O(n). Problem authors: gen, andreyv.Bonus: Can you solve the problem for any vertex number n? When and how can such a graph be built?343A - Rational ResistanceIf a fraction can be obtained with k resistors, then it is simple to calculate that we can obtain fractions and with k + 1 resistors. So adding one resistor means performing one operation backwards in Euclidean algorithm. That means that the answer is equal to the number of steps in standard Euclidean algorithm.Solution complexity: . Problem authors: gen, andreyv.Бонус: At first we thought about the major problem (any two elements can be joined), but had a moment of eureka and got that the given problem unexpectedly naturally can be reduced to GCD. By the way, the result tree — http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Alternating CurrentLet us solve the following problem first: we are given a string of symbols A and B. If the i-th symbol is A, then at the i-th step the upper wire (see figure) is being put over the lower wire. If the i-th symbol is B, the lower wire is being put over the upper wire at i-th step. Observe that if some two symbols A and B are adjacent, we can untangle this place, throw the symbols out and obtain the string of length two symbols less. So the wires can be untangled iff the number of A's and B's in the string is the same. The given problem can be reduced to the described in a following fashion: in each odd position we change – to B and + to A. In each even position we change — to A and + to B. The reduction is correct, since on each even position the order of — and + are always swapped, and in each odd position their order is the same as in the beginning.Solution complexity: O(n). Problem authors: gen, andreyv.Bonus: If you are interested by this problem, you can learn about the braid theory http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: a harder version of this problem was planned already for Round #142, but the error in solution idea was found, and the problem was left to lay for almost a year.343C - Read TimeLet's search the answer t with the binary search. Fix some value of t. Look at the first head from the left h[i] that can read track p[0]. If p[0] > h[i], then h[i] goes to the right t seconds and reads all tracks on its way. Otherwise if p[0] ≤ h[i], then the head has two choices: go to the right seconds, then to the left and h[i] - p[0] again to the left; go to the left h[i] - p[0] seconds, then h[i] - p[0] to the right and t - 2·(h[i] - p[0]) again to the right. Obviously, for h[i] it is more advantageous to visit the track positioned as much as possible to the right. So we choose by . Then we move the pointer onto the first unread track, and repeat the algorithm for h[i + 1], and so on with each head.Solution complexity: . Problem authors: gen, gorbunov.Bonus: The problem is completely real, if the disk has only a single head, if we know, what tracks should be read; then the optimal algorithm chooses between the two choices described above. I and gorbunov were listening this on a lecture, and created the given problem out of boredom ;]343D - Water TreeLet's learn how to color a whole subtree. For that enumerate all vertices in post-order DFS. Then each subtree covers a single continious vertex number segment. For each vertex we store the bounds of such segment for a subtree with a root in this vertex. Then to color a subtree means to color a segment in a segment tree.Then create a segment tree that has a following property: if a vertex v was emptied, and is still empty, then this vertex is colored in the segment tree. In the beginning \"empty\" all the vertices. That is, color all the vertices in the segment tree. With this tree we can efficiently process the queries: Fill a vertex v. Clean the interval for the subtree of v. If before that some vertex of a subtree was empty, color the parent of v. Empty a vertex v. Color the vertex v in the segment tree. Reply whether a vertex v is filled. If in the segment tree at least one vertex is colored, then there is such a descendant of v that is empty now, so the vertex v is not filled. Shtrix noted that essentially the same solution can be implemented with only a single set.Solution complexity: . Problem author: gen.Bonus: Some participants could see the similarities with a problem Ball Machine from BOI 2013, but the solutions to the both problems are quite different.343E - Pumping StationsIn this problem we are asked to find such graph vertex permutation that maximizes the sum of the maximum flows sent between each two consequtive vertices in the permutation.The problem can be solved with Gomory-Hu tree data structure. For a given weighted graph the tree has the following properties: The vertex set of the tree and the graph is the same. The maximum flow between vertices u and v in the tree is equal to the maximum flow in the graph. Surprisingly, such a tree exists for any weighted graph, and can be built in O(n·maxFlow). It appears that the answer to the problem is equal to the sum of the edge weights in this tree.We prove this statement by induction on the number of the tree vertices. Pick the edge (u, v) with the smallest weight in the tree. Consider that in an optimal permutation more than one path between two adjacent verteces in the permutation passes through this edge. Erase all these paths, then each of the u and v subtrees holds a set of disjoint remaining paths from the permutation. For each set, join all the paths in one chain, obtaining two chains. These chains we join by a path s that goes trough the edge (u, v). Thus we have built a permutation that is not worse than the considered one. For a path s the edge (u, v) is the smallest, so the flow along this path is equal to the weight of this edge. It follows from the induction that in subtrees u and v the answer is equal to the sum of edges. By adding the weight of edge (u, v), we get the desired result.From the last paragraph it is clear how to build such a permutation: take the smallest edge, obtain two chains from the vertex subtrees recursively, and add them together to form a one chain. Since there are not many vertices, we can do this part in O(n2).Solution complexity: O(n·maxFlow). Problem authors: gen, Gerald.Bonus: Shortly before the contest we decided to make the constraints more loyal, so some solution that find Gomory-Hu tree by finding flow O(n2) times also passed. We hope that nobody is particularly saddened by this fact. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 344\\s*B"
          },
          "content_length": 7699
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 1",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 2",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 3",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 4",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 5",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 6",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a solution exists\nbool isPossible(int a, int b, int c) {\n    long long tmp = (long long)b - a + c;\n    if (tmp % 2 != 0)\n        return false;\n    long long y = tmp / 2;\n    long long x = (long long)b - y;\n    long long z = (long long)c - y;\n    if (x < 0 || y < 0 || z < 0)\n        return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input values\n    int a = inf.readInt(1, 1000000);\n    int b = inf.readInt(1, 1000000);\n    int c = inf.readInt(1, 1000000);\n\n    // Read contestant's output\n    if (ouf.seekEof())\n        quitf(_wa, \"Unexpected end of output\");\n\n    string first_word = ouf.readToken();\n\n    if (lowerCase(first_word) == \"impossible\") {\n        if (isPossible(a, b, c)) {\n            quitf(_wa, \"Contestant outputs 'Impossible', but solution exists\");\n        } else {\n            quitf(_ok, \"Correct: Contestant outputs 'Impossible'\");\n        }\n    } else {\n        // Try to parse first_word as integer\n        int x;\n        try {\n            x = std::stoi(first_word);\n        } catch (...) {\n            quitf(_wa, \"Expected 'Impossible' or integer, got '%s'\", first_word.c_str());\n        }\n        int y = ouf.readInt();\n        int z = ouf.readInt();\n\n        if (x < 0 || y < 0 || z < 0) {\n            quitf(_wa, \"Bond counts must be non-negative integers\");\n        }\n\n        if (x + y != b) {\n            quitf(_wa, \"x + y = %d + %d = %d, expected %d\", x, y, x + y, b);\n        }\n\n        if (x + z != a) {\n            quitf(_wa, \"x + z = %d + %d = %d, expected %d\", x, z, x + z, a);\n        }\n\n        if (y + z != c) {\n            quitf(_wa, \"y + z = %d + %d = %d, expected %d\", y, z, y + z, c);\n        }\n\n        // All checks passed\n        quitf(_ok, \"Correct bonds: x = %d, y = %d, z = %d\", x, y, z);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int min_valence = opt<int>(\"min_valence\", 1);\n    int max_valence = opt<int>(\"max_valence\", 1000000);\n\n    int a, b, c;\n\n    if (type == \"random_valid_small\") {\n        min_valence = opt<int>(\"min_valence\", 1);\n        max_valence = opt<int>(\"max_valence\", 1000);\n        while (true) {\n            long long max_bond = max_valence;\n            long long n12 = rnd.next(0LL, max_bond);\n            long long n23 = rnd.next(0LL, max_bond);\n            long long n31 = rnd.next(0LL, max_bond);\n            a = n12 + n31;\n            b = n12 + n23;\n            c = n23 + n31;\n            if (a >= min_valence && a <= max_valence && b >= min_valence && b <= max_valence && c >= min_valence && c <= max_valence) {\n                int s1 = a + b - c;\n                int s2 = b + c - a;\n                int s3 = a + c - b;\n                if (s1 >= 0 && s2 >= 0 && s3 >= 0 && s1%2 == 0 && s2%2 == 0 && s3%2 == 0) {\n                    printf(\"%d %d %d\\n\", a, b, c);\n                    break;\n                }\n            }\n        }\n    } else if (type == \"random_valid_large\") {\n        min_valence = opt<int>(\"min_valence\", 1000);\n        max_valence = opt<int>(\"max_valence\", 1000000);\n        while (true) {\n            long long max_bond = max_valence;\n            long long n12 = rnd.next(0LL, max_bond);\n            long long n23 = rnd.next(0LL, max_bond);\n            long long n31 = rnd.next(0LL, max_bond);\n            a = n12 + n31;\n            b = n12 + n23;\n            c = n23 + n31;\n            if (a >= min_valence && a <= max_valence && b >= min_valence && b <= max_valence && c >= min_valence && c <= max_valence) {\n                int s1 = a + b - c;\n                int s2 = b + c - a;\n                int s3 = a + c - b;\n                if (s1 >= 0 && s2 >= 0 && s3 >= 0 && s1%2 == 0 && s2%2 == 0 && s3%2 == 0) {\n                    printf(\"%d %d %d\\n\", a, b, c);\n                    break;\n                }\n            }\n        }\n    } else if (type == \"impossible_negative\") {\n        while (true) {\n            a = rnd.next(min_valence, max_valence);\n            b = rnd.next(min_valence, max_valence);\n            c = rnd.next(min_valence, max_valence);\n            int s1 = a + b - c;\n            int s2 = b + c - a;\n            int s3 = a + c - b;\n            if (s1 < 0 || s2 < 0 || s3 < 0) {\n                printf(\"%d %d %d\\n\", a, b, c);\n                break;\n            }\n        }\n    } else if (type == \"impossible_odd\") {\n        while (true) {\n            a = rnd.next(min_valence, max_valence);\n            b = rnd.next(min_valence, max_valence);\n            c = rnd.next(min_valence, max_valence);\n            int s1 = a + b - c;\n            int s2 = b + c - a;\n            int s3 = a + c - b;\n            if ( (s1 > 0 && s1 %2 == 1) || (s2 > 0 && s2 %2 ==1) || (s3 >0 && s3 %2 ==1) ) {\n                printf(\"%d %d %d\\n\", a, b, c);\n                break;\n            }\n        }\n    } else if (type == \"minimal\") {\n        a = b = c = min_valence;\n        printf(\"%d %d %d\\n\", a, b, c);\n    } else if (type == \"maximal\") {\n        a = b = c = max_valence;\n        printf(\"%d %d %d\\n\", a, b, c);\n    } else if (type == \"sample1\") {\n        printf(\"1 1 2\\n\");\n    } else if (type == \"sample2\") {\n        printf(\"3 4 5\\n\");\n    } else if (type == \"sample3\") {\n        printf(\"4 1 1\\n\");\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int min_valence = opt<int>(\"min_valence\", 1);\n    int max_valence = opt<int>(\"max_valence\", 1000000);\n\n    int a, b, c;\n\n    if (type == \"random_valid_small\") {\n        min_valence = opt<int>(\"min_valence\", 1);\n        max_valence = opt<int>(\"max_valence\", 1000);\n        while (true) {\n            long long max_bond = max_valence;\n            long long n12 = rnd.next(0LL, max_bond);\n            long long n23 = rnd.next(0LL, max_bond);\n            long long n31 = rnd.next(0LL, max_bond);\n            a = n12 + n31;\n            b = n12 + n23;\n            c = n23 + n31;\n            if (a >= min_valence && a <= max_valence && b >= min_valence && b <= max_valence && c >= min_valence && c <= max_valence) {\n                int s1 = a + b - c;\n                int s2 = b + c - a;\n                int s3 = a + c - b;\n                if (s1 >= 0 && s2 >= 0 && s3 >= 0 && s1%2 == 0 && s2%2 == 0 && s3%2 == 0) {\n                    printf(\"%d %d %d\\n\", a, b, c);\n                    break;\n                }\n            }\n        }\n    } else if (type == \"random_valid_large\") {\n        min_valence = opt<int>(\"min_valence\", 1000);\n        max_valence = opt<int>(\"max_valence\", 1000000);\n        while (true) {\n            long long max_bond = max_valence;\n            long long n12 = rnd.next(0LL, max_bond);\n            long long n23 = rnd.next(0LL, max_bond);\n            long long n31 = rnd.next(0LL, max_bond);\n            a = n12 + n31;\n            b = n12 + n23;\n            c = n23 + n31;\n            if (a >= min_valence && a <= max_valence && b >= min_valence && b <= max_valence && c >= min_valence && c <= max_valence) {\n                int s1 = a + b - c;\n                int s2 = b + c - a;\n                int s3 = a + c - b;\n                if (s1 >= 0 && s2 >= 0 && s3 >= 0 && s1%2 == 0 && s2%2 == 0 && s3%2 == 0) {\n                    printf(\"%d %d %d\\n\", a, b, c);\n                    break;\n                }\n            }\n        }\n    } else if (type == \"impossible_negative\") {\n        while (true) {\n            a = rnd.next(min_valence, max_valence);\n            b = rnd.next(min_valence, max_valence);\n            c = rnd.next(min_valence, max_valence);\n            int s1 = a + b - c;\n            int s2 = b + c - a;\n            int s3 = a + c - b;\n            if (s1 < 0 || s2 < 0 || s3 < 0) {\n                printf(\"%d %d %d\\n\", a, b, c);\n                break;\n            }\n        }\n    } else if (type == \"impossible_odd\") {\n        while (true) {\n            a = rnd.next(min_valence, max_valence);\n            b = rnd.next(min_valence, max_valence);\n            c = rnd.next(min_valence, max_valence);\n            int s1 = a + b - c;\n            int s2 = b + c - a;\n            int s3 = a + c - b;\n            if ( (s1 > 0 && s1 %2 == 1) || (s2 > 0 && s2 %2 ==1) || (s3 >0 && s3 %2 ==1) ) {\n                printf(\"%d %d %d\\n\", a, b, c);\n                break;\n            }\n        }\n    } else if (type == \"minimal\") {\n        a = b = c = min_valence;\n        printf(\"%d %d %d\\n\", a, b, c);\n    } else if (type == \"maximal\") {\n        a = b = c = max_valence;\n        printf(\"%d %d %d\\n\", a, b, c);\n    } else if (type == \"sample1\") {\n        printf(\"1 1 2\\n\");\n    } else if (type == \"sample2\") {\n        printf(\"3 4 5\\n\");\n    } else if (type == \"sample3\") {\n        printf(\"4 1 1\\n\");\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type sample1\n./gen -type sample2\n./gen -type sample3\n\n./gen -type minimal\n\n./gen -type maximal\n\n./gen -type random_valid_small -min_valence 1 -max_valence 10\n./gen -type random_valid_small -min_valence 1 -max_valence 100\n./gen -type random_valid_small -min_valence 1 -max_valence 1000\n\n./gen -type random_valid_large -min_valence 1000 -max_valence 1000000\n./gen -type random_valid_large -min_valence 500000 -max_valence 1000000\n./gen -type random_valid_large -min_valence 1 -max_valence 1000000\n\n./gen -type impossible_negative -min_valence 1 -max_valence 1000\n./gen -type impossible_negative -min_valence 1 -max_valence 1000000\n\n./gen -type impossible_odd -min_valence 1 -max_valence 1000\n./gen -type impossible_odd -min_valence 1 -max_valence 1000000\n\n# Generate multiple random valid small test cases\n./gen -type random_valid_small -min_valence 1 -max_valence 1000\n./gen -type random_valid_small -min_valence 1 -max_valence 1000\n./gen -type random_valid_small -min_valence 1 -max_valence 1000\n./gen -type random_valid_small -min_valence 1 -max_valence 1000\n./gen -type random_valid_small -min_valence 1 -max_valence 1000\n\n# Generate multiple random valid large test cases\n./gen -type random_valid_large -min_valence 1 -max_valence 1000000\n./gen -type random_valid_large -min_valence 1 -max_valence 1000000\n./gen -type random_valid_large -min_valence 1 -max_valence 1000000\n./gen -type random_valid_large -min_valence 1 -max_valence 1000000\n./gen -type random_valid_large -min_valence 1 -max_valence 1000000\n\n# Generate multiple impossible_negative test cases\n./gen -type impossible_negative -min_valence 1 -max_valence 1000\n./gen -type impossible_negative -min_valence 1 -max_valence 1000000\n./gen -type impossible_negative -min_valence 1 -max_valence 1000000\n\n# Generate multiple impossible_odd test cases\n./gen -type impossible_odd -min_valence 1 -max_valence 1000\n./gen -type impossible_odd -min_valence 1 -max_valence 1000000\n./gen -type impossible_odd -min_valence 1 -max_valence 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:33.960191",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "344/C",
      "title": "C. Рациональное сопротивление",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных через пробел записаны два целых числа a и b (1 ≤ a, b ≤ 1018). Гарантируется, что дробь  несократима. Гарантируется, что решение всегда существует.",
      "output_spec": "Выходные данныеВыведите единственное число — ответ на задачу.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать3 2Выходные данныеСкопировать3Входные данныеСкопировать199 200Выходные данныеСкопировать200",
      "description": "C. Рациональное сопротивление\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входных данных через пробел записаны два целых числа a и b (1 ≤ a, b ≤ 1018). Гарантируется, что дробь  несократима. Гарантируется, что решение всегда существует.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — ответ на задачу.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать3 2Выходные данныеСкопировать3Входные данныеСкопировать199 200Выходные данныеСкопировать200\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать199 200\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать200\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере хватает одного резистора.Во втором примере можно соединить два резистора параллельно, а полученный элемент соединить последовательно с третьим резистором. Таким образом получаем элемент с сопротивлением . С помощью двух резисторов такой элемент построить невозможно.",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Привет всем!Сегодня в 19:30 по Московскому времени состоится юбилейный Codeforces Round #200. Раунд будет проведен в обоих дивизионах и будет рейтинговым.Задачи раунда подготовили Евгений Вихров (gen), Андрей Вихров (andreyv) и Геральд Агапов (Gerald). Как всегда, выражаем благодарность Михаилу Мирзаянову (MikeMirzayanov) за системы Codeforces и Polygon. Отдельное спасибо Марии Беловой (Delinur) за перевод условий задач. В этом раунде вы поможете безумному учёному Майку реализовать его причудливые затеи и поставить необычные опыты. По мнению авторов, в задачах поддерживается хороший баланс математики и программирования. Также мы старались сделать условия задач по возможности короткими и понятными :] Как всегда, мы считаем, что каждый участник найдёт себе задачу по вкусу.Желаем всем участникам удачи и интересного раунда!UPD1: Разбалловка задач стандартная:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Поздравляем две лучших пятёрки победителей!DivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1071
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces",
          "content": "344A - МагнитыПо определению каждый островок состоит из последовательных одинаково направленных домино. Значит, в местах, где соседние домино направлены не одинаково, кончается один островок и начинается следующий. Значит, если таких мест x, то ответ равен x + 1.Сложность решения O(n). Автор задачи: gen.Бонус: Задача была придумана в день перед контестом и полностью дополнила физически направленный комплект для DivII :]344B - Простые молекулыПервое решение. Во-первых, заметим, что сумма a + b + c должна быть чётной, потому что каждое ребро прибавляет два к сумме. Теперь допустим, что между 1-ым и 2-ым, 2-ым и 3-им, 3-им и 1-ым атомами есть x, y и z связей, соответственно. Поэтому нам нужно решить систему x + z = a, y + x = b, z + y = c. Можно заметить, что решением этого уравнения являются длины касательных на треугольнике со сторонами a, b, c к его вписанной окружности, и равняются , , . Если бы в задаче просили проверить только, можно ли построить такую молекулу, то хватало бы проверить нестрогое неравенство треугольника для a, b, c.Второе решение. Переберём значение x. Для него значения y и z определены однозначно: y = b - x, z = a - x.Сложность решения O(1) / O(n). Авторы задачи: gen, andreyv.Бонус: Можете ли вы решить задачу для произвольного n? Когда и как можно построить связный граф?343A - Рациональное сопротивлениеЕсли с помощью k элементов можем получить дроби , то нетрудно посчитать, что с помощью k + 1 элементов можно получить дроби и . То есть прибавление одного элемента эквивалентно одному шагу алгоритма Эвклида для числителя и знаменателя в обратном направлении. Значит, ответ равняется количеству шагов стандартного алгоритма Эвклида.Сложность решения . Авторы задачи: gen, andreyv.Бонус: Вначале мы думали об общей задаче (можно соединять два любых элемента, как многие неправильно поняли задачу), однако случился момент эврики, и мы поняли, что данная задача неожиданно естественно сводится к НОД. Кстати, дерево результатов – http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Переменный токВначале решим другую задачу: дана строка, состоящая из символов A и B. Если i-тый символ А, то на i-том шаге верхний провод (на рисунке) кладётся поверх нижнего. Если i-тый символ B, то нижний провод (на рисунке) кладётся поверх верхнего. Заметим, что если символ А стоит рядом с символом B, то эти два заплетания можно распутать и получить ситуацию, которую описывает та же строка, в которой выкинуты эти два символа. Поэтому провода можно распутать тогда и только тогда, если количество А совпадает с количеством В в этой строке. Нашу задачу мы можем свести к вышеописанной следующим образом: на каждой нечётной позиции заменяем – на B, а + на A. На чётных позициях заменяем – на A, а + на B. Можно видеть, что сведение правильное, потому что на каждой чётной позиции – и + всегда стоят перевернутые относительно начала, а на каждой нечётной порядок совпадает с порядком начала.Сложность решения O(n). Авторы задачи: gen, andreyv.Бонус: Если тема вас заинтересовала, можете ознакомиться с теорией кос http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: усложнённый вариант задачи был предложен ещё на Round #142, но тогда в решении нашлась ошибка, и задача осталась лежать почти целый год.343C - Время чтенияБудем искать ответ t двоичным поиском. Рассмотрим конкретное значение t. Рассмотрим первую головку слева h[i], которая может считать p[0]. Если p[0] > h[i], то h[i] просто идёт направо t секунд, и читает все дорожки на пути. Если p[0] ≤ h[i], то у головки есть два выбора: идти направо секунд, затем налево и опять налево ещё h[i] - p[0] секунд; идти налево h[i] - p[0] секунд, затем направо h[i] - p[0] и опять направо t - 2·(h[i] - p[0]) секунд. Естественно, для h[i] выгоднее всего побывать в самой правой точке. Поэтому выбираем по . Дальше двигаем указатель на первую несчитанную дорожку, и повторяем алгоритм для h[i + 1], и.т.д. с каждой головкой.Сложность решения . Авторы задачи: gen, gorbunov.Бонус: Задача полностью реальна, если у диска есть только одна головка, и известно, какие данные нужно считать, то оптимальный алгоритм выбирает один из описанных двух вариантов. Это мы слушали на лекции вместе с gorbunov, и от скуки придумали такую задачу ;]343D - Водяное деревоНаучимся быстро красить целое поддерево. Для этого пронумеруем все вершины в порядке выхода DFS. Тогда каждое поддерево покрывает один непрерывный отрезок номеров вершин. Для каждой вершины запомним границы такого отрезка для поддерева с корнем в этой вершине. Тогда красить поддерево означает покрасить отрезок в дереве отрезков.Заведём дерево отрезков. Для него выполняется свойство: если вершина v была опустошена, и она до сир пор пуста, то эта вершина покрашена в дереве отрезков. В самом начале «опустошим» все вершины. То есть, покрасим все вершины в дереве отрезков. С помощью этого дерева можно эффективно обрабатывать запросы: Заполняем вершину v. Стираем всё поддерево v в дереве отрезков. Если до этого поддерево не было пустым, то красим родителя v. Опустошаем вершину v. Красим вершину v в дереве отрезков. Отвечаем, заполнена ли вершина v. Если в дереве отрезков сумма поддерева v не равна 0, значит есть такой потомок v, который опустошён сейчас, поэтому вершина v не заполнена. Идейно похожее, но более простое решение в написании предложил Shtrix.Сложность решения . Автор задачи: gen.Бонус: Некоторые участники могли заметить схожесть задачи с задачей Ball Machine из BOI 2013, однако решения этих задач имеют мало похожего.343E - Насосные станцииВ этой задаче нужно было найти такую перестановку вершин графа, что сумма максимальных потоков, пропущенных через каждую пару соседних вершин в перестановке, максимальна.Задача решается с помощью структуры данных дерево Гомори-Ху. Для данного взвешенного графа дерево обладает свойствами: Множество вершин дерева совпадает с множеством вершин графа. Максимальный поток в дереве между вершинами u и v равен максимальному потоку в графе между вершинами u и v. Такое дерево на удивление существует для любого взвешенного графа и строится за время O(n·maxFlow). Оказывается, что для данной задачи ответом является сумма весов рёбер в таком дереве.Докажем это утверждение индукцией по количеству вершин в дереве. Найдём ребро (u, v) с минимальным весом в дереве. Допустим, что для оптимальной перестановки вершин через это ребро проходит больше, чем один путь между парами соседних вершин в перестановке. Сотрём все такие пути, тогда в поддеревьях u и v остаётся в каждом по множеству несоединённых цепочек путей. Соединим все пути в каждом множестве в одну цепочку и получим две цепочки. Эти цепочки соединим одним путём s, который идёт через ребро (u, v). Получили перестановку, которая не хуже оптимальной. Для пути s ребро (u, v) является наименьшим, значит поток по этому пути равен весу этого ребра. Из индукции следует, что в поддеревьях u и v ответ равняется сумме ребёр. Добавляя к сумме вес ребра (u, v), получаем желаемое.Из предыдущего абзаца ясно также, как строить такую перестановку: Берём наименьшее ребро, для поддеревьев вершин рекурсивно строим цепочки и соединяем их в одну. Так как вершин мало, эту часть можно делать даже за O(n2).Сложность решения O(n·maxFlow). Авторы задачи: gen, Gerald.Бонус: Ближе к соревнованию мы решили сделать ограничения лояльней, поэтому прошли также решения, которые O(n2) раз вызывают поток и затем строят дерево Гомори-Ху. Надеемся, этот факт никого особенно не огорчил. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 344 和字母"
          },
          "content_length": 7429
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 1",
          "code": "if ((c <> '+') and (c <> '-')) then break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 2",
          "code": "if ((c <> '+') and (c <> '-')) then break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 3",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 4",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 5",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 6",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 7",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #200 - Codeforces - Code 8",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b != 0LL) {\n        long long t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n    ensuref(gcd(a, b) == 1LL, \"Fraction a/b must be irreducible\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b != 0LL) {\n        long long t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n    ensuref(gcd(a, b) == 1LL, \"Fraction a/b must be irreducible\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b != 0LL) {\n        long long t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n    ensuref(gcd(a, b) == 1LL, \"Fraction a/b must be irreducible\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This generator produces exactly one test case each time it is executed.\n    It generates two integers a and b (1 <= a, b <= 10^18), ensuring gcd(a, b) = 1.\n    The fraction a/b is thus irreducible, satisfying the problem constraints.\n\n    Usage:\n      1) If \"type\" is \"random\", the program reads a \"range\" parameter (long long).\n         It will generate a random pair (a, b) with 1 <= a,b <= range and gcd(a, b) = 1.\n\n      2) If \"type\" is \"special\", the program reads an integer \"idx\", and picks a pair\n         from a predefined list of tricky corner cases to print.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // A list of special pairs for the \"special\" mode, ensuring gcd(a, b) = 1.\n    // Each pair is carefully chosen to exercise corner cases in contestants' solutions.\n    static vector<pair<long long, long long>> specialCases = {\n        {1LL, 1LL},                                // Minimal case\n        {3LL, 2LL},                                // Example from the statement\n        {199LL, 200LL},                            // Another example from the statement\n        {2LL, 999983LL},                           // Small + large prime\n        {999983LL, 2LL},                           // Large prime + small\n        {999983LL, 999984LL},                      // Consecutive numbers near a prime\n        {999999999999999989LL, 1LL},               // Very large prime + 1\n        {1LL, 1000000000000000000LL},              // 1 and a max boundary\n        {299999999999999993LL, 299999999999999994LL}, // Consecutive large numbers\n        {1000000000000000000LL, 999999999999999999LL}, // Another pair near the boundary\n        {999999999999999983LL, 999999999999999982LL}  // Very large consecutive numbers\n    };\n\n    if (type == \"special\") {\n        int idx = opt<int>(\"idx\", 0);\n        // Safely pick one special pair\n        pair<long long, long long> p = specialCases[idx % specialCases.size()];\n        cout << p.first << \" \" << p.second << \"\\n\";\n    } else {\n        // \"random\" mode (default)\n        long long r = opt<long long>(\"range\", 1000000LL); // default range if not provided\n        long long a, b;\n        while (true) {\n            a = rnd.next(1LL, r);\n            b = rnd.next(1LL, r);\n            if (std::gcd(a, b) == 1) {\n                cout << a << \" \" << b << \"\\n\";\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This generator produces exactly one test case each time it is executed.\n    It generates two integers a and b (1 <= a, b <= 10^18), ensuring gcd(a, b) = 1.\n    The fraction a/b is thus irreducible, satisfying the problem constraints.\n\n    Usage:\n      1) If \"type\" is \"random\", the program reads a \"range\" parameter (long long).\n         It will generate a random pair (a, b) with 1 <= a,b <= range and gcd(a, b) = 1.\n\n      2) If \"type\" is \"special\", the program reads an integer \"idx\", and picks a pair\n         from a predefined list of tricky corner cases to print.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // A list of special pairs for the \"special\" mode, ensuring gcd(a, b) = 1.\n    // Each pair is carefully chosen to exercise corner cases in contestants' solutions.\n    static vector<pair<long long, long long>> specialCases = {\n        {1LL, 1LL},                                // Minimal case\n        {3LL, 2LL},                                // Example from the statement\n        {199LL, 200LL},                            // Another example from the statement\n        {2LL, 999983LL},                           // Small + large prime\n        {999983LL, 2LL},                           // Large prime + small\n        {999983LL, 999984LL},                      // Consecutive numbers near a prime\n        {999999999999999989LL, 1LL},               // Very large prime + 1\n        {1LL, 1000000000000000000LL},              // 1 and a max boundary\n        {299999999999999993LL, 299999999999999994LL}, // Consecutive large numbers\n        {1000000000000000000LL, 999999999999999999LL}, // Another pair near the boundary\n        {999999999999999983LL, 999999999999999982LL}  // Very large consecutive numbers\n    };\n\n    if (type == \"special\") {\n        int idx = opt<int>(\"idx\", 0);\n        // Safely pick one special pair\n        pair<long long, long long> p = specialCases[idx % specialCases.size()];\n        cout << p.first << \" \" << p.second << \"\\n\";\n    } else {\n        // \"random\" mode (default)\n        long long r = opt<long long>(\"range\", 1000000LL); // default range if not provided\n        long long a, b;\n        while (true) {\n            a = rnd.next(1LL, r);\n            b = rnd.next(1LL, r);\n            if (std::gcd(a, b) == 1) {\n                cout << a << \" \" << b << \"\\n\";\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 distinct commands to generate test cases.\n# Each command prints exactly one test case (a single line with two integers).\n\n# 1) Special corner cases, using different idx values:\n./gen -type special -idx 0\n./gen -type special -idx 1\n./gen -type special -idx 2\n./gen -type special -idx 3\n./gen -type special -idx 4\n./gen -type special -idx 5\n./gen -type special -idx 6\n./gen -type special -idx 7\n./gen -type special -idx 8\n./gen -type special -idx 9\n./gen -type special -idx 10\n\n# 2) Random small range:\n./gen -type random -range 10\n./gen -type random -range 100\n\n# 3) Medium range:\n./gen -type random -range 1000\n./gen -type random -range 999999\n\n# 4) Larger ranges:\n./gen -type random -range 1000000000\n./gen -type random -range 9999999999999999\n\n# 5) Very large range (close to 10^18):\n./gen -type random -range 999999999999999999\n./gen -type random -range 1000000000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:36.017625",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "344/D",
      "title": "D. Alternating Current",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains a sequence of characters \"+\" and \"-\" of length n (1 ≤ n ≤ 100000). The i-th (1 ≤ i ≤ n) position of the sequence contains the character \"+\", if on the i-th step from the wall the \"plus\" wire runs above the \"minus\" wire, and the character \"-\" otherwise.",
      "output_spec": "OutputPrint either \"Yes\" (without the quotes) if the wires can be untangled or \"No\" (without the quotes) if the wires cannot be untangled.",
      "sample_tests": "ExamplesInputCopy-++-OutputCopyYesInputCopy+-OutputCopyNoInputCopy++OutputCopyYesInputCopy-OutputCopyNo",
      "description": "D. Alternating Current\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains a sequence of characters \"+\" and \"-\" of length n (1 ≤ n ≤ 100000). The i-th (1 ≤ i ≤ n) position of the sequence contains the character \"+\", if on the i-th step from the wall the \"plus\" wire runs above the \"minus\" wire, and the character \"-\" otherwise.\n\nOutputPrint either \"Yes\" (without the quotes) if the wires can be untangled or \"No\" (without the quotes) if the wires cannot be untangled.\n\nInputCopy-++-OutputCopyYesInputCopy+-OutputCopyNoInputCopy++OutputCopyYesInputCopy-OutputCopyNo\n\nInputCopy-++-\n\nOutputCopyYes\n\nInputCopy+-\n\nOutputCopyNo\n\nInputCopy++\n\nOutputCopyYes\n\nOutputCopyNo\n\nNoteThe first testcase corresponds to the picture in the statement. To untangle the wires, one can first move the \"plus\" wire lower, thus eliminating the two crosses in the middle, and then draw it under the \"minus\" wire, eliminating also the remaining two crosses.In the second testcase the \"plus\" wire makes one full revolution around the \"minus\" wire. Thus the wires cannot be untangled:   In the third testcase the \"plus\" wire simply runs above the \"minus\" wire twice in sequence. The wires can be untangled by lifting \"plus\" and moving it higher:   In the fourth testcase the \"minus\" wire runs above the \"plus\" wire once. The wires cannot be untangled without moving the device itself:",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Hello everyone!The anniversary Codeforces Round #200 is scheduled to take place today at 7:30 PM Moscow time. The round will be held in both divisions and will be rated.The round problems were prepared by Evgeny Vihrov (gen), Andrey Vihrov (andreyv) and Gerald Agapov (Gerald). As always, we would like to thank Mike Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems, and also Maria Belova (Delinur) for translating the problem statements.In this round you will help mad scientist Mike to realise his peculiar ideas and carry out unusual experiments. The authors think that the problems constitute a good balance between mathematics and programming. We also tried to make the statements short and easy to read :] As always, we hope that every participant will find a problem to his taste.We wish you good luck and an interesting round!UPD1: Score distribution is standard:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Congratulations to the top 5 winners in each division!DivIDivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1108
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces",
          "content": "344A - MagnetsBy the definition each block consists of a number of consequent and equally oriented dominoes. That means that in places where adjacent dominoes are not oriented equally, one block ends and another block starts. So, if there are x such places, the answer is equal to x + 1.Solution complexity: O(n). Problem author: gen.Bonus: The problem was created a day before the contest and filled in the last part of a physically flavoured DivII complect. :]344B - Simple MoleculesFirst solution. First, the sum a + b + c should be even, since each bond adds 2 to the sum. Now let x, y, z be the number of bonds between 1st and 2nd, 2nd and 3rd, 3rd and 1st atoms, accordingly. So we have to solve the system x + z = a, y + x = b, z + y = c. Now observe that the solution to the system is the length of the tangents on the triangle with sides of length a, b, c to its inscribed circle, and are equal to , , . If the problem asked only the possibility of building such a molecule, we could just check if there exists (possibly degenerate) triangle with sides a, b, c.Second solution. Bruteforce all x values. For a fixed x values of y and z are defined uniquely: y = b - x, z = a - x.Solution complexity: O(1) / O(n). Problem authors: gen, andreyv.Bonus: Can you solve the problem for any vertex number n? When and how can such a graph be built?343A - Rational ResistanceIf a fraction can be obtained with k resistors, then it is simple to calculate that we can obtain fractions and with k + 1 resistors. So adding one resistor means performing one operation backwards in Euclidean algorithm. That means that the answer is equal to the number of steps in standard Euclidean algorithm.Solution complexity: . Problem authors: gen, andreyv.Бонус: At first we thought about the major problem (any two elements can be joined), but had a moment of eureka and got that the given problem unexpectedly naturally can be reduced to GCD. By the way, the result tree — http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Alternating CurrentLet us solve the following problem first: we are given a string of symbols A and B. If the i-th symbol is A, then at the i-th step the upper wire (see figure) is being put over the lower wire. If the i-th symbol is B, the lower wire is being put over the upper wire at i-th step. Observe that if some two symbols A and B are adjacent, we can untangle this place, throw the symbols out and obtain the string of length two symbols less. So the wires can be untangled iff the number of A's and B's in the string is the same. The given problem can be reduced to the described in a following fashion: in each odd position we change – to B and + to A. In each even position we change — to A and + to B. The reduction is correct, since on each even position the order of — and + are always swapped, and in each odd position their order is the same as in the beginning.Solution complexity: O(n). Problem authors: gen, andreyv.Bonus: If you are interested by this problem, you can learn about the braid theory http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: a harder version of this problem was planned already for Round #142, but the error in solution idea was found, and the problem was left to lay for almost a year.343C - Read TimeLet's search the answer t with the binary search. Fix some value of t. Look at the first head from the left h[i] that can read track p[0]. If p[0] > h[i], then h[i] goes to the right t seconds and reads all tracks on its way. Otherwise if p[0] ≤ h[i], then the head has two choices: go to the right seconds, then to the left and h[i] - p[0] again to the left; go to the left h[i] - p[0] seconds, then h[i] - p[0] to the right and t - 2·(h[i] - p[0]) again to the right. Obviously, for h[i] it is more advantageous to visit the track positioned as much as possible to the right. So we choose by . Then we move the pointer onto the first unread track, and repeat the algorithm for h[i + 1], and so on with each head.Solution complexity: . Problem authors: gen, gorbunov.Bonus: The problem is completely real, if the disk has only a single head, if we know, what tracks should be read; then the optimal algorithm chooses between the two choices described above. I and gorbunov were listening this on a lecture, and created the given problem out of boredom ;]343D - Water TreeLet's learn how to color a whole subtree. For that enumerate all vertices in post-order DFS. Then each subtree covers a single continious vertex number segment. For each vertex we store the bounds of such segment for a subtree with a root in this vertex. Then to color a subtree means to color a segment in a segment tree.Then create a segment tree that has a following property: if a vertex v was emptied, and is still empty, then this vertex is colored in the segment tree. In the beginning \"empty\" all the vertices. That is, color all the vertices in the segment tree. With this tree we can efficiently process the queries: Fill a vertex v. Clean the interval for the subtree of v. If before that some vertex of a subtree was empty, color the parent of v. Empty a vertex v. Color the vertex v in the segment tree. Reply whether a vertex v is filled. If in the segment tree at least one vertex is colored, then there is such a descendant of v that is empty now, so the vertex v is not filled. Shtrix noted that essentially the same solution can be implemented with only a single set.Solution complexity: . Problem author: gen.Bonus: Some participants could see the similarities with a problem Ball Machine from BOI 2013, but the solutions to the both problems are quite different.343E - Pumping StationsIn this problem we are asked to find such graph vertex permutation that maximizes the sum of the maximum flows sent between each two consequtive vertices in the permutation.The problem can be solved with Gomory-Hu tree data structure. For a given weighted graph the tree has the following properties: The vertex set of the tree and the graph is the same. The maximum flow between vertices u and v in the tree is equal to the maximum flow in the graph. Surprisingly, such a tree exists for any weighted graph, and can be built in O(n·maxFlow). It appears that the answer to the problem is equal to the sum of the edge weights in this tree.We prove this statement by induction on the number of the tree vertices. Pick the edge (u, v) with the smallest weight in the tree. Consider that in an optimal permutation more than one path between two adjacent verteces in the permutation passes through this edge. Erase all these paths, then each of the u and v subtrees holds a set of disjoint remaining paths from the permutation. For each set, join all the paths in one chain, obtaining two chains. These chains we join by a path s that goes trough the edge (u, v). Thus we have built a permutation that is not worse than the considered one. For a path s the edge (u, v) is the smallest, so the flow along this path is equal to the weight of this edge. It follows from the induction that in subtrees u and v the answer is equal to the sum of edges. By adding the weight of edge (u, v), we get the desired result.From the last paragraph it is clear how to build such a permutation: take the smallest edge, obtain two chains from the vertex subtrees recursively, and add them together to form a one chain. Since there are not many vertices, we can do this part in O(n2).Solution complexity: O(n·maxFlow). Problem authors: gen, Gerald.Bonus: Shortly before the contest we decided to make the constraints more loyal, so some solution that find Gomory-Hu tree by finding flow O(n2) times also passed. We hope that nobody is particularly saddened by this fact. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 344 和字母"
          },
          "content_length": 7699
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 1",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 2",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 3",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 4",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 5",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 6",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[+-]{1,100000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[+-]{1,100000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[+-]{1,100000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint delta(int i, char c) {\n    if (i % 2 == 0) {\n        return (c == '-') ? 1 : -1;\n    } else {\n        return (c == '-') ? -1 : 1;\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '+'); // Initialize to '+'\n\n    if (type == \"plus_only\") {\n        // All '+', twist will be negative\n        // s = string(n, '+'); // Already initialized\n    } else if (type == \"minus_only\") {\n        s = string(n, '-');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '+' : '-';\n        }\n    } else if (type == \"reverse_alternating\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '-' : '+';\n        }\n    } else if (type == \"random_yes\") {\n        // Random, twist == 0\n        int twist = 0;\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '+' : '-';\n            twist += delta(i, s[i]);\n        }\n        // Adjust twist to zero\n        while (twist != 0) {\n            // Try flipping characters to reduce twist\n            bool changed = false;\n            for (int i = n - 1; i >= 0; --i) {\n                int delta_i = delta(i, s[i]);\n                int delta_change = -2 * delta_i; // Flipping c will change delta by -2*delta_i\n                if (abs(twist + delta_change) < abs(twist)) {\n                    s[i] = (s[i] == '+') ? '-' : '+';\n                    twist += delta_change;\n                    changed = true;\n                    if (twist == 0) break;\n                }\n            }\n            if (!changed) break; // Not able to reduce twist to zero\n        }\n    } else if (type == \"random_no\") {\n        // Random, twist != 0\n        int twist = 0;\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '+' : '-';\n            twist += delta(i, s[i]);\n        }\n        if (twist == 0) {\n            // Flip last character to make twist != 0\n            int i = n - 1;\n            int delta_i = delta(i, s[i]);\n            s[i] = (s[i] == '+') ? '-' : '+';\n            twist += -2 * delta_i;\n        }\n    } else if (type == \"special_case\") {\n        // Specific patterns that may cause errors in solutions\n        // For example, have long sequences of the same character\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) s[i] = '+';\n        for (int i = m; i < n; ++i) s[i] = '-';\n        // This may create a large twist\n    } else {\n        // Default is random\n        // Random string of '+' and '-'\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '+' : '-';\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint delta(int i, char c) {\n    if (i % 2 == 0) {\n        return (c == '-') ? 1 : -1;\n    } else {\n        return (c == '-') ? -1 : 1;\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '+'); // Initialize to '+'\n\n    if (type == \"plus_only\") {\n        // All '+', twist will be negative\n        // s = string(n, '+'); // Already initialized\n    } else if (type == \"minus_only\") {\n        s = string(n, '-');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '+' : '-';\n        }\n    } else if (type == \"reverse_alternating\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '-' : '+';\n        }\n    } else if (type == \"random_yes\") {\n        // Random, twist == 0\n        int twist = 0;\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '+' : '-';\n            twist += delta(i, s[i]);\n        }\n        // Adjust twist to zero\n        while (twist != 0) {\n            // Try flipping characters to reduce twist\n            bool changed = false;\n            for (int i = n - 1; i >= 0; --i) {\n                int delta_i = delta(i, s[i]);\n                int delta_change = -2 * delta_i; // Flipping c will change delta by -2*delta_i\n                if (abs(twist + delta_change) < abs(twist)) {\n                    s[i] = (s[i] == '+') ? '-' : '+';\n                    twist += delta_change;\n                    changed = true;\n                    if (twist == 0) break;\n                }\n            }\n            if (!changed) break; // Not able to reduce twist to zero\n        }\n    } else if (type == \"random_no\") {\n        // Random, twist != 0\n        int twist = 0;\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '+' : '-';\n            twist += delta(i, s[i]);\n        }\n        if (twist == 0) {\n            // Flip last character to make twist != 0\n            int i = n - 1;\n            int delta_i = delta(i, s[i]);\n            s[i] = (s[i] == '+') ? '-' : '+';\n            twist += -2 * delta_i;\n        }\n    } else if (type == \"special_case\") {\n        // Specific patterns that may cause errors in solutions\n        // For example, have long sequences of the same character\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) s[i] = '+';\n        for (int i = m; i < n; ++i) s[i] = '-';\n        // This may create a large twist\n    } else {\n        // Default is random\n        // Random string of '+' and '-'\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '+' : '-';\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type plus_only\n./gen -n 1 -type minus_only\n./gen -n 1 -type alternating\n./gen -n 1 -type reverse_alternating\n./gen -n 1 -type random_yes\n./gen -n 1 -type random_no\n./gen -n 1 -type random\n\n./gen -n 2 -type plus_only\n./gen -n 2 -type minus_only\n./gen -n 2 -type alternating\n./gen -n 2 -type reverse_alternating\n./gen -n 2 -type random_yes\n./gen -n 2 -type random_no\n./gen -n 2 -type random\n\n./gen -n 10 -type plus_only\n./gen -n 10 -type minus_only\n./gen -n 10 -type alternating\n./gen -n 10 -type reverse_alternating\n./gen -n 10 -type random_yes\n./gen -n 10 -type random_no\n./gen -n 10 -type special_case\n./gen -n 10 -type random\n\n./gen -n 100 -type random_yes\n./gen -n 100 -type random_no\n./gen -n 100 -type special_case\n\n./gen -n 1000 -type random_yes\n./gen -n 1000 -type random_no\n\n./gen -n 10000 -type random_yes\n./gen -n 10000 -type random_no\n\n./gen -n 99999 -type random_yes\n./gen -n 100000 -type plus_only\n./gen -n 100000 -type minus_only\n./gen -n 100000 -type random_no\n./gen -n 99999 -type special_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:38.518122",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "344/E",
      "title": "E. Read Time",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers n, m (1 ≤ n, m ≤ 105) — the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers hi in ascending order (1 ≤ hi ≤ 1010, hi < hi + 1) — the initial positions of the heads. The third line contains m distinct integers pi in ascending order (1 ≤ pi ≤ 1010, pi < pi + 1) - the numbers of tracks to read.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint a single number — the minimum time required, in seconds, to read all the needed tracks.",
      "sample_tests": "ExamplesInputCopy3 42 5 61 3 6 8OutputCopy2InputCopy3 31 2 31 2 3OutputCopy0InputCopy1 2165142 200OutputCopy81",
      "description": "E. Read Time\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two space-separated integers n, m (1 ≤ n, m ≤ 105) — the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers hi in ascending order (1 ≤ hi ≤ 1010, hi < hi + 1) — the initial positions of the heads. The third line contains m distinct integers pi in ascending order (1 ≤ pi ≤ 1010, pi < pi + 1) - the numbers of tracks to read.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint a single number — the minimum time required, in seconds, to read all the needed tracks.\n\nInputCopy3 42 5 61 3 6 8OutputCopy2InputCopy3 31 2 31 2 3OutputCopy0InputCopy1 2165142 200OutputCopy81\n\nInputCopy3 42 5 61 3 6 8\n\nOutputCopy2\n\nInputCopy3 31 2 31 2 3\n\nOutputCopy0\n\nInputCopy1 2165142 200\n\nOutputCopy81\n\nNoteThe first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way:   during the first second move the 1-st head to the left and let it stay there;  move the second head to the left twice;  move the third head to the right twice (note that the 6-th track has already been read at the beginning). One cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.",
      "solutions": [
        {
          "title": "Codeforces Round #200 - Codeforces",
          "content": "Hello everyone!The anniversary Codeforces Round #200 is scheduled to take place today at 7:30 PM Moscow time. The round will be held in both divisions and will be rated.The round problems were prepared by Evgeny Vihrov (gen), Andrey Vihrov (andreyv) and Gerald Agapov (Gerald). As always, we would like to thank Mike Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems, and also Maria Belova (Delinur) for translating the problem statements.In this round you will help mad scientist Mike to realise his peculiar ideas and carry out unusual experiments. The authors think that the problems constitute a good balance between mathematics and programming. We also tried to make the statements short and easy to read :] As always, we hope that every participant will find a problem to his taste.We wish you good luck and an interesting round!UPD1: Score distribution is standard:DivI: 500 1000 1500 2000 2500DivII: 500 1000 1500 2000 2500UPD2: Congratulations to the top 5 winners in each division!DivIDivI tourist KADR SillyHook06 niyaznigmatul Igor_Kudryashov DivII Giraffy jzc ryad0m Kamilot API",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8851",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1108
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces",
          "content": "344A - MagnetsBy the definition each block consists of a number of consequent and equally oriented dominoes. That means that in places where adjacent dominoes are not oriented equally, one block ends and another block starts. So, if there are x such places, the answer is equal to x + 1.Solution complexity: O(n). Problem author: gen.Bonus: The problem was created a day before the contest and filled in the last part of a physically flavoured DivII complect. :]344B - Simple MoleculesFirst solution. First, the sum a + b + c should be even, since each bond adds 2 to the sum. Now let x, y, z be the number of bonds between 1st and 2nd, 2nd and 3rd, 3rd and 1st atoms, accordingly. So we have to solve the system x + z = a, y + x = b, z + y = c. Now observe that the solution to the system is the length of the tangents on the triangle with sides of length a, b, c to its inscribed circle, and are equal to , , . If the problem asked only the possibility of building such a molecule, we could just check if there exists (possibly degenerate) triangle with sides a, b, c.Second solution. Bruteforce all x values. For a fixed x values of y and z are defined uniquely: y = b - x, z = a - x.Solution complexity: O(1) / O(n). Problem authors: gen, andreyv.Bonus: Can you solve the problem for any vertex number n? When and how can such a graph be built?343A - Rational ResistanceIf a fraction can be obtained with k resistors, then it is simple to calculate that we can obtain fractions and with k + 1 resistors. So adding one resistor means performing one operation backwards in Euclidean algorithm. That means that the answer is equal to the number of steps in standard Euclidean algorithm.Solution complexity: . Problem authors: gen, andreyv.Бонус: At first we thought about the major problem (any two elements can be joined), but had a moment of eureka and got that the given problem unexpectedly naturally can be reduced to GCD. By the way, the result tree — http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree.343B - Alternating CurrentLet us solve the following problem first: we are given a string of symbols A and B. If the i-th symbol is A, then at the i-th step the upper wire (see figure) is being put over the lower wire. If the i-th symbol is B, the lower wire is being put over the upper wire at i-th step. Observe that if some two symbols A and B are adjacent, we can untangle this place, throw the symbols out and obtain the string of length two symbols less. So the wires can be untangled iff the number of A's and B's in the string is the same. The given problem can be reduced to the described in a following fashion: in each odd position we change – to B and + to A. In each even position we change — to A and + to B. The reduction is correct, since on each even position the order of — and + are always swapped, and in each odd position their order is the same as in the beginning.Solution complexity: O(n). Problem authors: gen, andreyv.Bonus: If you are interested by this problem, you can learn about the braid theory http://en.wikipedia.org/wiki/Braid_theory :] Fun fact: a harder version of this problem was planned already for Round #142, but the error in solution idea was found, and the problem was left to lay for almost a year.343C - Read TimeLet's search the answer t with the binary search. Fix some value of t. Look at the first head from the left h[i] that can read track p[0]. If p[0] > h[i], then h[i] goes to the right t seconds and reads all tracks on its way. Otherwise if p[0] ≤ h[i], then the head has two choices: go to the right seconds, then to the left and h[i] - p[0] again to the left; go to the left h[i] - p[0] seconds, then h[i] - p[0] to the right and t - 2·(h[i] - p[0]) again to the right. Obviously, for h[i] it is more advantageous to visit the track positioned as much as possible to the right. So we choose by . Then we move the pointer onto the first unread track, and repeat the algorithm for h[i + 1], and so on with each head.Solution complexity: . Problem authors: gen, gorbunov.Bonus: The problem is completely real, if the disk has only a single head, if we know, what tracks should be read; then the optimal algorithm chooses between the two choices described above. I and gorbunov were listening this on a lecture, and created the given problem out of boredom ;]343D - Water TreeLet's learn how to color a whole subtree. For that enumerate all vertices in post-order DFS. Then each subtree covers a single continious vertex number segment. For each vertex we store the bounds of such segment for a subtree with a root in this vertex. Then to color a subtree means to color a segment in a segment tree.Then create a segment tree that has a following property: if a vertex v was emptied, and is still empty, then this vertex is colored in the segment tree. In the beginning \"empty\" all the vertices. That is, color all the vertices in the segment tree. With this tree we can efficiently process the queries: Fill a vertex v. Clean the interval for the subtree of v. If before that some vertex of a subtree was empty, color the parent of v. Empty a vertex v. Color the vertex v in the segment tree. Reply whether a vertex v is filled. If in the segment tree at least one vertex is colored, then there is such a descendant of v that is empty now, so the vertex v is not filled. Shtrix noted that essentially the same solution can be implemented with only a single set.Solution complexity: . Problem author: gen.Bonus: Some participants could see the similarities with a problem Ball Machine from BOI 2013, but the solutions to the both problems are quite different.343E - Pumping StationsIn this problem we are asked to find such graph vertex permutation that maximizes the sum of the maximum flows sent between each two consequtive vertices in the permutation.The problem can be solved with Gomory-Hu tree data structure. For a given weighted graph the tree has the following properties: The vertex set of the tree and the graph is the same. The maximum flow between vertices u and v in the tree is equal to the maximum flow in the graph. Surprisingly, such a tree exists for any weighted graph, and can be built in O(n·maxFlow). It appears that the answer to the problem is equal to the sum of the edge weights in this tree.We prove this statement by induction on the number of the tree vertices. Pick the edge (u, v) with the smallest weight in the tree. Consider that in an optimal permutation more than one path between two adjacent verteces in the permutation passes through this edge. Erase all these paths, then each of the u and v subtrees holds a set of disjoint remaining paths from the permutation. For each set, join all the paths in one chain, obtaining two chains. These chains we join by a path s that goes trough the edge (u, v). Thus we have built a permutation that is not worse than the considered one. For a path s the edge (u, v) is the smallest, so the flow along this path is equal to the weight of this edge. It follows from the induction that in subtrees u and v the answer is equal to the sum of edges. By adding the weight of edge (u, v), we get the desired result.From the last paragraph it is clear how to build such a permutation: take the smallest edge, obtain two chains from the vertex subtrees recursively, and add them together to form a one chain. Since there are not many vertices, we can do this part in O(n2).Solution complexity: O(n·maxFlow). Problem authors: gen, Gerald.Bonus: Shortly before the contest we decided to make the constraints more loyal, so some solution that find Gomory-Hu tree by finding flow O(n2) times also passed. We hope that nobody is particularly saddened by this fact. (;",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8860",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 344 和字母"
          },
          "content_length": 7699
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #200 - Codeforces - Code 1",
          "code": "l1=5;  r1=7;  while (l1+1 < r1)  {  m1=(l1+r1)/2;  if (true) l1=m1; else r1=m1-1;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8851",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 1",
          "code": "adding one resistor means performing one operation backwards in Euclidean algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 2",
          "code": "resistorReqiored(a-b,b) = 1 + resistorRequired(a-2b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 3",
          "code": "resistorRequired(a-(q-1)*b ,b) = 1 + resistorRequired(a-q*b,b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 4",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 5",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, i, b[100], ans;\n    scanf(\"%d\", &a);\n    for(i = 0; i < a; ++i){\n        scanf(\"%d\", &b[i]);\n    }\n    ans = 1;\n    for(i = 0; i < (a-1); ++i){\n        if(b[i] != b[i + 1]){\n            ++ans;}\n    }\n    printf(\"%d\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #200 Tutorial - Codeforces - Code 6",
          "code": "Alternating Current",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8860",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<long long> h = inf.readLongs(n, 1LL, 10000000000LL, \"h\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(h[i] < h[i + 1], \"h[%d] = %lld is not less than h[%d] = %lld\", i + 1, h[i], i + 2, h[i + 1]);\n    }\n\n    vector<long long> p = inf.readLongs(m, 1LL, 10000000000LL, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < m; ++i) {\n        ensuref(p[i] < p[i + 1], \"p[%d] = %lld is not less than p[%d] = %lld\", i + 1, p[i], i + 2, p[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<long long> h = inf.readLongs(n, 1LL, 10000000000LL, \"h\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(h[i] < h[i + 1], \"h[%d] = %lld is not less than h[%d] = %lld\", i + 1, h[i], i + 2, h[i + 1]);\n    }\n\n    vector<long long> p = inf.readLongs(m, 1LL, 10000000000LL, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < m; ++i) {\n        ensuref(p[i] < p[i + 1], \"p[%d] = %lld is not less than p[%d] = %lld\", i + 1, p[i], i + 2, p[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<long long> h = inf.readLongs(n, 1LL, 10000000000LL, \"h\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(h[i] < h[i + 1], \"h[%d] = %lld is not less than h[%d] = %lld\", i + 1, h[i], i + 2, h[i + 1]);\n    }\n\n    vector<long long> p = inf.readLongs(m, 1LL, 10000000000LL, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < m; ++i) {\n        ensuref(p[i] < p[i + 1], \"p[%d] = %lld is not less than p[%d] = %lld\", i + 1, p[i], i + 2, p[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> h, p;\n\n    if (type == \"small\") {\n        // n and m small, positions in [1, 10]\n        n = min(n, 10);\n        m = min(m, 10);\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1, 10));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1, 10));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"max\") {\n        // n, m up to 1e5, positions up to 1e10\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"overlap_h_p\") {\n        // h_i and p_i are the same\n        n = min(n, m);\n        set<long long> hs;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p = h;\n        m = n;\n    } else if (type == \"opposite\") {\n        // Heads in middle, tracks on both sides\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(5000000000LL, 6000000000LL));\n        }\n        while ((int)ps.size() < m / 2) {\n            ps.insert(rnd.next(1LL, 4000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(7000000000LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"max_positions\") {\n        // h_i near 1e10, p_i near 1\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(9000000000LL, 10000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 1000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"min_positions\") {\n        // h_i near 1, p_i near 1e10\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 1000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(9000000000LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"far_apart\") {\n        // h_i and p_i are far apart\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 2000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(8000000000LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"one_head\") {\n        // n = 1, m large\n        n = 1;\n        set<long long> hs, ps;\n        hs.insert(rnd.next(1LL, 10000000000LL));\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"one_track\") {\n        // m = 1, n large\n        m = 1;\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        ps.insert(rnd.next(1LL, 10000000000LL));\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"random\") {\n        // Random positions\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else {\n        // Default to random\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    }\n\n    sort(h.begin(), h.end());\n    sort(p.begin(), p.end());\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output h_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", h[i], i + 1 < n ? ' ' : '\\n');\n    }\n\n    // Output p_i\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld%c\", p[i], i + 1 < m ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> h, p;\n\n    if (type == \"small\") {\n        // n and m small, positions in [1, 10]\n        n = min(n, 10);\n        m = min(m, 10);\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1, 10));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1, 10));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"max\") {\n        // n, m up to 1e5, positions up to 1e10\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"overlap_h_p\") {\n        // h_i and p_i are the same\n        n = min(n, m);\n        set<long long> hs;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p = h;\n        m = n;\n    } else if (type == \"opposite\") {\n        // Heads in middle, tracks on both sides\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(5000000000LL, 6000000000LL));\n        }\n        while ((int)ps.size() < m / 2) {\n            ps.insert(rnd.next(1LL, 4000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(7000000000LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"max_positions\") {\n        // h_i near 1e10, p_i near 1\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(9000000000LL, 10000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 1000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"min_positions\") {\n        // h_i near 1, p_i near 1e10\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 1000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(9000000000LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"far_apart\") {\n        // h_i and p_i are far apart\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 2000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(8000000000LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"one_head\") {\n        // n = 1, m large\n        n = 1;\n        set<long long> hs, ps;\n        hs.insert(rnd.next(1LL, 10000000000LL));\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"one_track\") {\n        // m = 1, n large\n        m = 1;\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        ps.insert(rnd.next(1LL, 10000000000LL));\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else if (type == \"random\") {\n        // Random positions\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    } else {\n        // Default to random\n        set<long long> hs, ps;\n        while ((int)hs.size() < n) {\n            hs.insert(rnd.next(1LL, 10000000000LL));\n        }\n        while ((int)ps.size() < m) {\n            ps.insert(rnd.next(1LL, 10000000000LL));\n        }\n        h.assign(hs.begin(), hs.end());\n        p.assign(ps.begin(), ps.end());\n    }\n\n    sort(h.begin(), h.end());\n    sort(p.begin(), p.end());\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output h_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", h[i], i + 1 < n ? ' ' : '\\n');\n    }\n\n    // Output p_i\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld%c\", p[i], i + 1 < m ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type small\n./gen -n 10 -m 10 -type small\n./gen -n 2 -m 3 -type small\n\n./gen -n 100000 -m 100000 -type max\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type overlap_h_p\n./gen -n 100000 -m 100000 -type opposite\n./gen -n 100000 -m 100000 -type max_positions\n./gen -n 100000 -m 100000 -type min_positions\n./gen -n 100000 -m 100000 -type far_apart\n\n./gen -n 1 -m 100000 -type one_head\n./gen -n 100000 -m 1 -type one_track\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 50000 -m 50000 -type random\n./gen -n 99999 -m 99999 -type random\n\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 10 -m 10 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 100000 -m 1000 -type random\n./gen -n 1000 -m 100000 -type random\n\n./gen -n 1 -m 1 -type min_positions\n./gen -n 1 -m 1 -type max_positions\n\n./gen -n 50000 -m 50000 -type opposite\n./gen -n 50000 -m 50000 -type far_apart\n./gen -n 100000 -m 100000 -type overlap_h_p\n\n./gen -n 1 -m 1 -type overlap_h_p\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:40.421122",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "346/A",
      "title": "A. Alice and Bob",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (2 ≤ n ≤ 100) — the initial number of elements in the set. The second line contains n distinct space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the elements of the set.",
      "output_spec": "OutputPrint a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).",
      "sample_tests": "ExamplesInputCopy22 3OutputCopyAliceInputCopy25 3OutputCopyAliceInputCopy35 6 7OutputCopyBob",
      "description": "A. Alice and Bob\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (2 ≤ n ≤ 100) — the initial number of elements in the set. The second line contains n distinct space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the elements of the set.\n\nOutputPrint a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).\n\nInputCopy22 3OutputCopyAliceInputCopy25 3OutputCopyAliceInputCopy35 6 7OutputCopyBob\n\nInputCopy22 3\n\nOutputCopyAlice\n\nInputCopy25 3\n\nOutputCopyAlice\n\nInputCopy35 6 7\n\nOutputCopyBob\n\nNoteConsider the first test sample. Alice moves first, and the only move she can do is to choose 2 and 3, then to add 1 to the set. Next Bob moves, there is no valid move anymore, so the winner is Alice.",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Hello everyone!Codeforces Round #201 is scheduled to take place at Friday, Sep. 20th at 19:30 MSK(23:30 CST)Setters are: CMHJT and me.Testers are: error202, havaliza and tourist.Thanks to MinakoKojima for her help in rewrite the statements into codeforces style, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Special thanks to tourist and Gerald in giving advise about the problems so we could put them in a more proper order. 500 — 1000 — 1500 — 2000 — 2500.We are going to use standard score distribution in both divisions. The problems are not so hard, but you need more thinking rather than coding.Good luck!UPD1: Congratulations to the top 5 winners in each division!DivI1.cgy4ever2.rng_583.PavelKunyavskiy4.Egor5.liympandaDivII1.Thrax2.renannewbie3.socksister014.SJTU_WengJian5.cat_leopardUPD2: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 909
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 346 和字母"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"The integers a_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"The integers a_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"The integers a_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000); // Default maxAi is 1e9\n\n    vector<int> a;\n\n    if (type == \"small_random\") {\n        // Generate small random numbers\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxAi);\n            a.push_back(ai);\n        }\n    } else if (type == \"large_random\") {\n        // Generate large random numbers\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxAi);\n            a.push_back(ai);\n        }\n    } else if (type == \"consecutive\") {\n        // Generate consecutive numbers\n        int start = rnd.next(1, maxAi - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a.push_back(start + i);\n        }\n    } else if (type == \"same_parity\") {\n        // Generate numbers with the same parity (all even or all odd)\n        int parity = rnd.next(0, 1); // 0 for even, 1 for odd\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxAi / 2) * 2 + parity;\n            if (ai > maxAi) ai -= 2;\n            a.push_back(ai);\n        }\n    } else if (type == \"big_numbers\") {\n        // Generate big numbers close to maxAi\n        for (int i = 0; i < n; ++i) {\n            int ai = maxAi - rnd.next(0, min(maxAi - 1, 1000));\n            a.push_back(ai);\n        }\n    } else if (type == \"small_numbers\") {\n        // Generate small numbers\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, min(maxAi, 1000));\n            a.push_back(ai);\n        }\n    } else {\n        // Default random numbers\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxAi);\n            a.push_back(ai);\n        }\n    }\n\n    // Ensure all elements are unique\n    sort(a.begin(), a.end());\n    a.erase(unique(a.begin(), a.end()), a.end());\n\n    // Add more unique numbers if necessary\n    while ((int)a.size() < n) {\n        int ai = rnd.next(1, maxAi);\n        if (!binary_search(a.begin(), a.end(), ai)) {\n            a.push_back(ai);\n            sort(a.begin(), a.end());\n        }\n    }\n\n    // Shuffle the array\n    shuffle(a.begin(), a.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000); // Default maxAi is 1e9\n\n    vector<int> a;\n\n    if (type == \"small_random\") {\n        // Generate small random numbers\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxAi);\n            a.push_back(ai);\n        }\n    } else if (type == \"large_random\") {\n        // Generate large random numbers\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxAi);\n            a.push_back(ai);\n        }\n    } else if (type == \"consecutive\") {\n        // Generate consecutive numbers\n        int start = rnd.next(1, maxAi - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a.push_back(start + i);\n        }\n    } else if (type == \"same_parity\") {\n        // Generate numbers with the same parity (all even or all odd)\n        int parity = rnd.next(0, 1); // 0 for even, 1 for odd\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxAi / 2) * 2 + parity;\n            if (ai > maxAi) ai -= 2;\n            a.push_back(ai);\n        }\n    } else if (type == \"big_numbers\") {\n        // Generate big numbers close to maxAi\n        for (int i = 0; i < n; ++i) {\n            int ai = maxAi - rnd.next(0, min(maxAi - 1, 1000));\n            a.push_back(ai);\n        }\n    } else if (type == \"small_numbers\") {\n        // Generate small numbers\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, min(maxAi, 1000));\n            a.push_back(ai);\n        }\n    } else {\n        // Default random numbers\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxAi);\n            a.push_back(ai);\n        }\n    }\n\n    // Ensure all elements are unique\n    sort(a.begin(), a.end());\n    a.erase(unique(a.begin(), a.end()), a.end());\n\n    // Add more unique numbers if necessary\n    while ((int)a.size() < n) {\n        int ai = rnd.next(1, maxAi);\n        if (!binary_search(a.begin(), a.end(), ai)) {\n            a.push_back(ai);\n            sort(a.begin(), a.end());\n        }\n    }\n\n    // Shuffle the array\n    shuffle(a.begin(), a.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type small_random -maxAi 10\n./gen -n 2 -type consecutive -maxAi 10\n./gen -n 2 -type same_parity -maxAi 10\n./gen -n 2 -type big_numbers\n./gen -n 2 -type small_numbers\n./gen -n 5 -type small_random -maxAi 10\n./gen -n 5 -type consecutive -maxAi 10\n./gen -n 5 -type same_parity -maxAi 10\n./gen -n 5 -type big_numbers\n./gen -n 5 -type small_numbers\n./gen -n 10 -type small_random\n./gen -n 10 -type consecutive\n./gen -n 10 -type same_parity\n./gen -n 10 -type big_numbers\n./gen -n 10 -type small_numbers\n./gen -n 20 -type small_random\n./gen -n 20 -type consecutive\n./gen -n 20 -type same_parity\n./gen -n 20 -type big_numbers\n./gen -n 20 -type small_numbers\n./gen -n 50 -type large_random\n./gen -n 50 -type big_numbers\n./gen -n 50 -type small_numbers\n./gen -n 50 -type consecutive\n./gen -n 50 -type same_parity\n./gen -n 80 -type large_random\n./gen -n 80 -type big_numbers\n./gen -n 80 -type small_numbers\n./gen -n 80 -type consecutive\n./gen -n 80 -type same_parity\n./gen -n 90 -type random\n./gen -n 90 -type big_numbers\n./gen -n 90 -type small_numbers\n./gen -n 90 -type consecutive\n./gen -n 90 -type same_parity\n./gen -n 100 -type random\n./gen -n 100 -type big_numbers\n./gen -n 100 -type small_numbers\n./gen -n 100 -type consecutive\n./gen -n 100 -type same_parity\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:42.460840",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "346/B",
      "title": "B. Lucky Common Subsequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe input contains three strings in three separate lines: s1, s2 and virus (1 ≤ |s1|, |s2|, |virus| ≤ 100). Each string consists only of uppercase English letters.",
      "output_spec": "OutputOutput the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted. If there is no valid common subsequence, output 0.",
      "sample_tests": "ExamplesInputCopyAJKEQSLOBSROFGZOVGURWZLWVLUXTHOZOutputCopyORZInputCopyAAAAOutputCopy0",
      "description": "B. Lucky Common Subsequence\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains three strings in three separate lines: s1, s2 and virus (1 ≤ |s1|, |s2|, |virus| ≤ 100). Each string consists only of uppercase English letters.\n\nOutputOutput the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted. If there is no valid common subsequence, output 0.\n\nInputCopyAJKEQSLOBSROFGZOVGURWZLWVLUXTHOZOutputCopyORZInputCopyAAAAOutputCopy0\n\nInputCopyAJKEQSLOBSROFGZOVGURWZLWVLUXTHOZ\n\nOutputCopyORZ\n\nInputCopyAAAA\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Hello everyone!Codeforces Round #201 is scheduled to take place at Friday, Sep. 20th at 19:30 MSK(23:30 CST)Setters are: CMHJT and me.Testers are: error202, havaliza and tourist.Thanks to MinakoKojima for her help in rewrite the statements into codeforces style, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Special thanks to tourist and Gerald in giving advise about the problems so we could put them in a more proper order. 500 — 1000 — 1500 — 2000 — 2500.We are going to use standard score distribution in both divisions. The problems are not so hard, but you need more thinking rather than coding.Good luck!UPD1: Congratulations to the top 5 winners in each division!DivI1.cgy4ever2.rng_583.PavelKunyavskiy4.Egor5.liympandaDivII1.Thrax2.renannewbie3.socksister014.SJTU_WengJian5.cat_leopardUPD2: the editorial is published here",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 909
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 346 和字母"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"[A-Z]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[A-Z]{1,100}\", \"s2\");\n    string virus = inf.readLine(\"[A-Z]{1,100}\", \"virus\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"[A-Z]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[A-Z]{1,100}\", \"s2\");\n    string virus = inf.readLine(\"[A-Z]{1,100}\", \"virus\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"[A-Z]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[A-Z]{1,100}\", \"s2\");\n    string virus = inf.readLine(\"[A-Z]{1,100}\", \"virus\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s1, s2, virus;\nint n, m, vlen;\n\nvector<vector<vector<int>>> dp;\n\nvector<vector<int>> aut; // automaton for virus\n\nvoid build_automaton(string &virus) {\n    int vlen = virus.length();\n    vector<int> lps(vlen);\n    lps[0] = 0;\n    for(int i = 1; i < vlen; i++) {\n        int len = lps[i-1];\n        while(len > 0 && virus[i] != virus[len])\n            len = lps[len-1];\n        if(virus[i] == virus[len])\n            len++;\n        lps[i] = len;\n    }\n\n    aut.assign(vlen + 1, vector<int>(26, 0));\n    for(int state = 0; state <= vlen; state++) {\n        for(char c = 'A'; c <= 'Z'; c++) {\n            if(state < vlen && c == virus[state]) {\n                aut[state][c - 'A'] = state + 1;\n            } else {\n                if(state == 0) {\n                    aut[state][c - 'A'] = 0;\n                } else {\n                    aut[state][c - 'A'] = aut[lps[state - 1]][c - 'A'];\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    s1 = inf.readString();\n    s2 = inf.readString();\n    virus = inf.readString();\n    n = s1.length();\n    m = s2.length();\n    vlen = virus.length();\n\n    build_automaton(virus);\n\n    // dp[i][j][k] = maximum length at position i in s1, j in s2, and state k in automaton\n    dp.assign(n + 1, vector<vector<int>>(m + 1, vector<int>(vlen, -1)));\n    dp[0][0][0] = 0;\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            for (int k = 0; k < vlen; k++) {\n                if (dp[i][j][k] == -1)\n                    continue;\n                if (i < n && dp[i + 1][j][k] < dp[i][j][k])\n                    dp[i + 1][j][k] = dp[i][j][k];\n                if (j < m && dp[i][j + 1][k] < dp[i][j][k])\n                    dp[i][j + 1][k] = dp[i][j][k];\n                if (i < n && j < m && s1[i] == s2[j]) {\n                    char c = s1[i];\n                    int new_k = aut[k][c - 'A'];\n                    if (new_k < vlen && dp[i + 1][j + 1][new_k] < dp[i][j][k] + 1)\n                        dp[i + 1][j + 1][new_k] = dp[i][j][k] + 1;\n                }\n            }\n        }\n    }\n    // Find the maximum length\n    int max_len = 0;\n    for (int k = 0; k < vlen; k++) {\n        if (dp[n][m][k] > max_len)\n            max_len = dp[n][m][k];\n    }\n\n    // Now read participant's answer\n    string pans = ouf.readString();\n\n    if (max_len == 0) {\n        if (pans == \"0\") {\n            quitf(_ok, \"Correct answer: 0\");\n        } else {\n            quitf(_wa, \"Output should be 0 but participant output \\\"%s\\\"\", pans.c_str());\n        }\n    } else {\n        if (pans == \"0\") {\n            quitf(_wa, \"There exists a common subsequence of length %d\", max_len);\n        }\n        // Check length\n        if ((int)pans.length() != max_len) {\n            quitf(_wa, \"Participant's subsequence length %d is not maximum %d\", (int)pans.length(), max_len);\n        }\n        // Check if pans is a subsequence of s1\n        int idx1 = 0;\n        for (char c : pans) {\n            while (idx1 < n && s1[idx1] != c)\n                idx1++;\n            if (idx1 == n) {\n                quitf(_wa, \"Participant's output is not a subsequence of s1\");\n            }\n            idx1++;\n        }\n        // Check if pans is a subsequence of s2\n        int idx2 = 0;\n        for (char c : pans) {\n            while (idx2 < m && s2[idx2] != c)\n                idx2++;\n            if (idx2 == m) {\n                quitf(_wa, \"Participant's output is not a subsequence of s2\");\n            }\n            idx2++;\n        }\n        // Check if pans contains virus as substring\n        int state = 0;\n        for (char c : pans) {\n            state = aut[state][c - 'A'];\n            if (state == vlen) {\n                quitf(_wa, \"Participant's output contains virus as substring\");\n            }\n        }\n        // All checks passed\n        quitf(_ok, \"Found subsequence of length %d\", max_len);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_string(int length, const string& alphabet) {\n    string s;\n    for (int i = 0; i < length; ++i)\n        s += alphabet[rnd.next(0, (int)alphabet.size() - 1)];\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len_s1 = opt<int>(\"len_s1\", 10);\n    int len_s2 = opt<int>(\"len_s2\", 10);\n    int len_virus = opt<int>(\"len_virus\", 2);\n    string type = opt<string>(\"type\", \"random\");\n\n    const string uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    string s1, s2, virus;\n\n    if (type == \"random\") {\n        s1 = random_string(len_s1, uppercase);\n        s2 = random_string(len_s2, uppercase);\n        virus = random_string(len_virus, uppercase);\n    } else if (type == \"no_common_subsequence\") {\n        // Generate s1 and s2 with disjoint character sets\n        int alpha_size = uppercase.size();\n        int half = alpha_size / 2;\n        string first_half = uppercase.substr(0, half);\n        string second_half = uppercase.substr(half);\n\n        s1 = random_string(len_s1, first_half);\n        s2 = random_string(len_s2, second_half);\n        virus = random_string(len_virus, uppercase);\n    } else if (type == \"max_common_subsequence\") {\n        // s1 and s2 are the same\n        s1 = random_string(len_s1, uppercase);\n        s2 = s1;\n        virus = random_string(len_virus, uppercase);\n    } else if (type == \"virus_not_in_s1_s2\") {\n        s1 = random_string(len_s1, uppercase);\n        s2 = random_string(len_s2, uppercase);\n        // Ensure virus is not in s1 or s2\n        set<char> used_chars(s1.begin(), s1.end());\n        used_chars.insert(s2.begin(), s2.end());\n        string unused_chars;\n        for (char c = 'A'; c <= 'Z'; ++c) {\n            if (used_chars.find(c) == used_chars.end())\n                unused_chars += c;\n        }\n        if (unused_chars.empty()) {\n            // All letters used, cannot generate virus not in s1 or s2\n            virus = \"Z\"; // Arbitrary character\n        } else {\n            virus = random_string(len_virus, unused_chars);\n        }\n    } else if (type == \"virus_in_all_subsequences\") {\n        // Make any common subsequence include virus\n        virus = random_string(len_virus, uppercase);\n        s1 = virus + random_string(len_s1 - len_virus, uppercase);\n        s2 = virus + random_string(len_s2 - len_virus, uppercase);\n        shuffle(s1.begin(), s1.end());\n        shuffle(s2.begin(), s2.end());\n    } else {\n        // Default to random\n        s1 = random_string(len_s1, uppercase);\n        s2 = random_string(len_s2, uppercase);\n        virus = random_string(len_virus, uppercase);\n    }\n\n    // Output s1, s2, virus\n    printf(\"%s\\n%s\\n%s\\n\", s1.c_str(), s2.c_str(), virus.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_string(int length, const string& alphabet) {\n    string s;\n    for (int i = 0; i < length; ++i)\n        s += alphabet[rnd.next(0, (int)alphabet.size() - 1)];\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len_s1 = opt<int>(\"len_s1\", 10);\n    int len_s2 = opt<int>(\"len_s2\", 10);\n    int len_virus = opt<int>(\"len_virus\", 2);\n    string type = opt<string>(\"type\", \"random\");\n\n    const string uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    string s1, s2, virus;\n\n    if (type == \"random\") {\n        s1 = random_string(len_s1, uppercase);\n        s2 = random_string(len_s2, uppercase);\n        virus = random_string(len_virus, uppercase);\n    } else if (type == \"no_common_subsequence\") {\n        // Generate s1 and s2 with disjoint character sets\n        int alpha_size = uppercase.size();\n        int half = alpha_size / 2;\n        string first_half = uppercase.substr(0, half);\n        string second_half = uppercase.substr(half);\n\n        s1 = random_string(len_s1, first_half);\n        s2 = random_string(len_s2, second_half);\n        virus = random_string(len_virus, uppercase);\n    } else if (type == \"max_common_subsequence\") {\n        // s1 and s2 are the same\n        s1 = random_string(len_s1, uppercase);\n        s2 = s1;\n        virus = random_string(len_virus, uppercase);\n    } else if (type == \"virus_not_in_s1_s2\") {\n        s1 = random_string(len_s1, uppercase);\n        s2 = random_string(len_s2, uppercase);\n        // Ensure virus is not in s1 or s2\n        set<char> used_chars(s1.begin(), s1.end());\n        used_chars.insert(s2.begin(), s2.end());\n        string unused_chars;\n        for (char c = 'A'; c <= 'Z'; ++c) {\n            if (used_chars.find(c) == used_chars.end())\n                unused_chars += c;\n        }\n        if (unused_chars.empty()) {\n            // All letters used, cannot generate virus not in s1 or s2\n            virus = \"Z\"; // Arbitrary character\n        } else {\n            virus = random_string(len_virus, unused_chars);\n        }\n    } else if (type == \"virus_in_all_subsequences\") {\n        // Make any common subsequence include virus\n        virus = random_string(len_virus, uppercase);\n        s1 = virus + random_string(len_s1 - len_virus, uppercase);\n        s2 = virus + random_string(len_s2 - len_virus, uppercase);\n        shuffle(s1.begin(), s1.end());\n        shuffle(s2.begin(), s2.end());\n    } else {\n        // Default to random\n        s1 = random_string(len_s1, uppercase);\n        s2 = random_string(len_s2, uppercase);\n        virus = random_string(len_virus, uppercase);\n    }\n\n    // Output s1, s2, virus\n    printf(\"%s\\n%s\\n%s\\n\", s1.c_str(), s2.c_str(), virus.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len_s1 10 -len_s2 10 -len_virus 2 -type random\n./gen -len_s1 1 -len_s2 1 -len_virus 1 -type random\n./gen -len_s1 100 -len_s2 100 -len_virus 1 -type random\n./gen -len_s1 100 -len_s2 100 -len_virus 100 -type random\n./gen -len_s1 50 -len_s2 50 -len_virus 50 -type random\n\n./gen -len_s1 10 -len_s2 10 -len_virus 2 -type no_common_subsequence\n./gen -len_s1 100 -len_s2 100 -len_virus 5 -type no_common_subsequence\n\n./gen -len_s1 100 -len_s2 100 -len_virus 2 -type max_common_subsequence\n./gen -len_s1 50 -len_s2 50 -len_virus 10 -type max_common_subsequence\n\n./gen -len_s1 100 -len_s2 100 -len_virus 10 -type virus_not_in_s1_s2\n./gen -len_s1 50 -len_s2 50 -len_virus 5 -type virus_not_in_s1_s2\n./gen -len_s1 100 -len_s2 100 -len_virus 25 -type virus_not_in_s1_s2\n\n./gen -len_s1 100 -len_s2 100 -len_virus 2 -type virus_in_all_subsequences\n./gen -len_s1 50 -len_s2 50 -len_virus 5 -type virus_in_all_subsequences\n\n# Edge cases\n\n# s1 and s2 are of minimal length\n./gen -len_s1 1 -len_s2 1 -len_virus 1 -type max_common_subsequence\n\n# virus is longer than s1 and s2\n./gen -len_s1 10 -len_s2 10 -len_virus 20 -type random\n\n# virus is the full alphabet\n./gen -len_s1 10 -len_s2 10 -len_virus 26 -type random\n\n# s1 and s2 have no common subsequence, virus is irrelevant\n./gen -len_s1 50 -len_s2 50 -len_virus 10 -type no_common_subsequence\n\n# s1 and s2 share only one character\n./gen -len_s1 50 -len_s2 50 -len_virus 1 -type random\n\n# virus is a single character common to s1 and s2\n./gen -len_s1 50 -len_s2 50 -len_virus 1 -type max_common_subsequence\n\n# s1 and s2 consist of the same character repeated\n./gen -len_s1 100 -len_s2 100 -len_virus 1 -type max_common_subsequence\n\n# s1 and s2 consist of the same character, virus is that character repeated longer\n./gen -len_s1 50 -len_s2 50 -len_virus 50 -type max_common_subsequence\n\n# virus overlaps in s1 and s2\n./gen -len_s1 100 -len_s2 100 -len_virus 5 -type virus_in_all_subsequences\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:44.572492",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "346/C",
      "title": "C. Number Transformation II",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤  n ≤ 105). The second line contains n space-separated integers x1, x2, ..., xn (2 ≤  xi ≤ 109). The third line contains two integers a and b (0  ≤ b ≤  a ≤ 109, a - b ≤ 106).",
      "output_spec": "OutputPrint a single integer — the required minimum number of moves needed to transform number a into number b.",
      "sample_tests": "ExamplesInputCopy33 4 530 17OutputCopy6InputCopy35 6 71000 200OutputCopy206",
      "description": "C. Number Transformation II\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤  n ≤ 105). The second line contains n space-separated integers x1, x2, ..., xn (2 ≤  xi ≤ 109). The third line contains two integers a and b (0  ≤ b ≤  a ≤ 109, a - b ≤ 106).\n\nOutputPrint a single integer — the required minimum number of moves needed to transform number a into number b.\n\nInputCopy33 4 530 17OutputCopy6InputCopy35 6 71000 200OutputCopy206\n\nInputCopy33 4 530 17\n\nOutputCopy6\n\nInputCopy35 6 71000 200\n\nOutputCopy206",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Hello everyone!Codeforces Round #201 is scheduled to take place at Friday, Sep. 20th at 19:30 MSK(23:30 CST)Setters are: CMHJT and me.Testers are: error202, havaliza and tourist.Thanks to MinakoKojima for her help in rewrite the statements into codeforces style, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Special thanks to tourist and Gerald in giving advise about the problems so we could put them in a more proper order. 500 — 1000 — 1500 — 2000 — 2500.We are going to use standard score distribution in both divisions. The problems are not so hard, but you need more thinking rather than coding.Good luck!UPD1: Congratulations to the top 5 winners in each division!DivI1.cgy4ever2.rng_583.PavelKunyavskiy4.Egor5.liympandaDivII1.Thrax2.renannewbie3.socksister014.SJTU_WengJian5.cat_leopardUPD2: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 909
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 346 和字母"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000); // n ∈ [1, 1e5]\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 2, 1000000000); // xi ∈ [2, 1e9], n of them\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000000000); // a ∈ [0, 1e9]\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000); // b ∈ [0, 1e9]\n    inf.readEoln();\n\n    ensuref(b <= a, \"b (%d) should be less than or equal to a (%d)\", b, a);\n    ensuref(a - b <= 1000000, \"Difference between a (%d) and b (%d) should be at most 1e6\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000); // n ∈ [1, 1e5]\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 2, 1000000000); // xi ∈ [2, 1e9], n of them\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000000000); // a ∈ [0, 1e9]\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000); // b ∈ [0, 1e9]\n    inf.readEoln();\n\n    ensuref(b <= a, \"b (%d) should be less than or equal to a (%d)\", b, a);\n    ensuref(a - b <= 1000000, \"Difference between a (%d) and b (%d) should be at most 1e6\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000); // n ∈ [1, 1e5]\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 2, 1000000000); // xi ∈ [2, 1e9], n of them\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000000000); // a ∈ [0, 1e9]\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000); // b ∈ [0, 1e9]\n    inf.readEoln();\n\n    ensuref(b <= a, \"b (%d) should be less than or equal to a (%d)\", b, a);\n    ensuref(a - b <= 1000000, \"Difference between a (%d) and b (%d) should be at most 1e6\", a, b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Optional parameters (if needed)\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n\n    // Adjust n if necessary\n    if (type == \"min_n\") n = 1;\n    if (type == \"max_n\") n = int(1e5);\n\n    vector<int> xi(n);\n\n    if (type == \"random\") {\n        // Random xi in [2, 1e9]\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"min_n\") {\n        // n is set to 1\n        xi[0] = rnd.next(2, int(1e9));\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"max_n\") {\n        // n is set to 1e5\n        xi.resize(n);\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"min_xi\") {\n        // All xi[i] = 2\n        for(int i = 0; i < n; ++i)\n            xi[i] = 2;\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"max_xi\") {\n        // All xi[i] = 1e9\n        for(int i = 0; i < n; ++i)\n            xi[i] = int(1e9);\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"a_eq_b\" || type == \"a_minus_b_min\") {\n        // a == b\n        int a_max = int(1e9);\n        a = rnd.next(0, a_max);\n        b = a;\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n    } else if (type == \"a_minus_b_max\") {\n        // a - b == 1e6\n        int diff = int(1e6);\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n    } else if (type == \"xi_divides_a\") {\n        // At least one xi divides a\n        for(int i = 0; i < n; ++i){\n            xi[i] = rnd.next(2, int(1e9));\n        }\n        int idx = rnd.next(0, n-1);\n        int x = xi[idx]; // xi[idx] divides a\n        int max_k = int(1e9) / x;\n        max_k = max(max_k, 1);\n        int k = rnd.next(1, max_k);\n        a = x * k;\n        // Ensure a ≤ 1e9\n        if (a > int(1e9)) a = int(1e9);\n        int diff = rnd.next(0, std::min(int(1e6), a));\n        b = a - diff;\n    } else if (type == \"xi_does_not_divide_a\") {\n        // No xi divides a\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(std::max(diff + 1, 1), int(1e9));\n        b = a - diff;\n        for(int i = 0; i < n; ++i){\n            xi[i] = rnd.next(2, int(1e9));\n            // Ensure xi[i] does not divide a\n            while (a % xi[i] == 0){\n                xi[i] = rnd.next(2, int(1e9));\n            }\n        }\n    } else {\n        // Default: random test case\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi\n    for(int i = 0; i < n; ++i){\n        printf(\"%d%c\", xi[i], i == n-1 ? '\\n' : ' ');\n    }\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Optional parameters (if needed)\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n\n    // Adjust n if necessary\n    if (type == \"min_n\") n = 1;\n    if (type == \"max_n\") n = int(1e5);\n\n    vector<int> xi(n);\n\n    if (type == \"random\") {\n        // Random xi in [2, 1e9]\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"min_n\") {\n        // n is set to 1\n        xi[0] = rnd.next(2, int(1e9));\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"max_n\") {\n        // n is set to 1e5\n        xi.resize(n);\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"min_xi\") {\n        // All xi[i] = 2\n        for(int i = 0; i < n; ++i)\n            xi[i] = 2;\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"max_xi\") {\n        // All xi[i] = 1e9\n        for(int i = 0; i < n; ++i)\n            xi[i] = int(1e9);\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    } else if (type == \"a_eq_b\" || type == \"a_minus_b_min\") {\n        // a == b\n        int a_max = int(1e9);\n        a = rnd.next(0, a_max);\n        b = a;\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n    } else if (type == \"a_minus_b_max\") {\n        // a - b == 1e6\n        int diff = int(1e6);\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n    } else if (type == \"xi_divides_a\") {\n        // At least one xi divides a\n        for(int i = 0; i < n; ++i){\n            xi[i] = rnd.next(2, int(1e9));\n        }\n        int idx = rnd.next(0, n-1);\n        int x = xi[idx]; // xi[idx] divides a\n        int max_k = int(1e9) / x;\n        max_k = max(max_k, 1);\n        int k = rnd.next(1, max_k);\n        a = x * k;\n        // Ensure a ≤ 1e9\n        if (a > int(1e9)) a = int(1e9);\n        int diff = rnd.next(0, std::min(int(1e6), a));\n        b = a - diff;\n    } else if (type == \"xi_does_not_divide_a\") {\n        // No xi divides a\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(std::max(diff + 1, 1), int(1e9));\n        b = a - diff;\n        for(int i = 0; i < n; ++i){\n            xi[i] = rnd.next(2, int(1e9));\n            // Ensure xi[i] does not divide a\n            while (a % xi[i] == 0){\n                xi[i] = rnd.next(2, int(1e9));\n            }\n        }\n    } else {\n        // Default: random test case\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, int(1e9));\n        int diff = rnd.next(0, int(1e6));\n        a = rnd.next(diff, int(1e9));\n        b = a - diff;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi\n    for(int i = 0; i < n; ++i){\n        printf(\"%d%c\", xi[i], i == n-1 ? '\\n' : ' ');\n    }\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_n\n./gen -n 1 -type max_xi\n./gen -n 1 -type min_xi\n./gen -n 1 -type a_eq_b\n\n./gen -n 2 -type xi_divides_a\n./gen -n 2 -type xi_does_not_divide_a\n\n./gen -n 10 -type random\n./gen -n 10 -type a_minus_b_min\n./gen -n 10 -type a_minus_b_max\n\n./gen -n 1000 -type random\n./gen -n 1000 -type min_xi\n./gen -n 1000 -type max_xi\n\n./gen -n 10000 -type random\n./gen -n 10000 -type xi_divides_a\n./gen -n 10000 -type xi_does_not_divide_a\n\n./gen -n 100000 -type random\n./gen -n 100000 -type max_n\n\n./gen -n 100000 -type min_xi\n./gen -n 100000 -type max_xi\n\n./gen -n 100000 -type a_eq_b\n./gen -n 100000 -type a_minus_b_max\n./gen -n 100000 -type xi_divides_a\n./gen -n 100000 -type xi_does_not_divide_a\n\n./gen -n 99999 -type random\n\n./gen -n 12345 -type random\n./gen -n 54321 -type random\n./gen -n 100000 -type a_minus_b_min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:46.705884",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "346/D",
      "title": "D. Управляем роботом",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест6 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n (1 ≤ n ≤ 106) — количество вершин графа, и m (1 ≤ m ≤ 106) — количество ребер. Затем следует m строк, в каждой строке записано два целых числа, ui и vi (1 ≤ ui, vi ≤ n; vi ≠ ui), эти целые числа обозначают направленное ребро, проходящее из вершины ui в вершину vi. В последней строке записано два целых числа, s и t (1 ≤ s, t ≤ n).Гарантируется, что граф не содержит петель и кратных ребер.",
      "output_spec": "Выходные данныеЕсли выполнить поставленную цель возможно, выведите требуемое минимальное количество приказов в худшем случае. Иначе выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 61 22 11 33 12 43 41 4Выходные данныеСкопировать1Входные данныеСкопировать4 51 22 11 32 43 41 4Выходные данныеСкопировать1",
      "description": "D. Управляем роботом\n\nограничение по времени на тест6 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа n (1 ≤ n ≤ 106) — количество вершин графа, и m (1 ≤ m ≤ 106) — количество ребер. Затем следует m строк, в каждой строке записано два целых числа, ui и vi (1 ≤ ui, vi ≤ n; vi ≠ ui), эти целые числа обозначают направленное ребро, проходящее из вершины ui в вершину vi. В последней строке записано два целых числа, s и t (1 ≤ s, t ≤ n).Гарантируется, что граф не содержит петель и кратных ребер.\n\nВходные данные\n\nВыходные данныеЕсли выполнить поставленную цель возможно, выведите требуемое минимальное количество приказов в худшем случае. Иначе выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать4 61 22 11 33 12 43 41 4Выходные данныеСкопировать1Входные данныеСкопировать4 51 22 11 32 43 41 4Выходные данныеСкопировать1\n\nВходные данныеСкопировать4 61 22 11 33 12 43 41 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 51 22 11 32 43 41 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример. Изначально робот находится в вершине номер 1. Таким образом, на первом шагу робот может пойти в вершину 2 или 3. В зависимости от выбора робота, mzry1992 должна отдать приказ роботу. Приказ направляет его в вершину 4. Если mzry1992 не отдает приказа роботу на вершине 2 или 3, то робот может выбрать «плохое» исходящее ребро (вернуться в вершину 1) согласно закону № 3. Таким образом, ответ — один.",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Всем привет!Codeforces Round #201 пройдет в пятницу, 20-го сентября в пятницу, 20-го сентября в 19:30 MSK(23:30 CST)Авторы задач: CMHJT и я.Тестеры: error202, havaliza и tourist.Мы хотим сказать спасибо MinakoKojima за обработку условий, Delinur за перевод условий задач на русский язык, и MikeMirzayanov за разработку мощной платформы для подготовки контестов.Особая благодарность пользователям tourist и Gerald за их советы по задачам, теперь задачи расположены в наиболее правильном порядке. 500 — 1000 — 1500 — 2000 — 2500.Будет использоваться стандартная разбалловка в обоих дивизионах. Задачи будут не очень сложными, но вам потребуется думать гораздо больше нежели писать код.Удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 689
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 346 和字母"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edgeSet;\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Edge %d: No self-loops allowed (ui != vi)\", i+1);\n        pair<int,int> edge = make_pair(ui, vi);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Edge %d: Duplicate edge (%d, %d)\", i+1, ui, vi);\n        edgeSet.insert(edge);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edgeSet;\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Edge %d: No self-loops allowed (ui != vi)\", i+1);\n        pair<int,int> edge = make_pair(ui, vi);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Edge %d: Duplicate edge (%d, %d)\", i+1, ui, vi);\n        edgeSet.insert(edge);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edgeSet;\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Edge %d: No self-loops allowed (ui != vi)\", i+1);\n        pair<int,int> edge = make_pair(ui, vi);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Edge %d: Duplicate edge (%d, %d)\", i+1, ui, vi);\n        edgeSet.insert(edge);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int s = opt<int>(\"s\", 1);\n    int t = opt<int>(\"t\", n);\n    \n    int m;\n    vector<pair<int, int>> edges;\n    \n    if (type == \"path\") {\n        // Generate a simple path from s to t\n        m = n - 1;\n        if (m > 1000000) {\n            m = 1000000;\n            n = m + 1;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.emplace_back(i, i + 1);\n        }\n    } else if (type == \"NoPath\") {\n        // Generate two disconnected components\n        n = max(n, 2);\n        m = n - 2;\n        if (m > 1000000) {\n            m = 1000000;\n            n = m + 2;\n        }\n        int mid = n / 2;\n        for (int i = 1; i < mid; ++i) {\n            edges.emplace_back(i, i + 1);\n        }\n        for (int i = mid + 1; i < n; ++i) {\n            edges.emplace_back(i, i + 1);\n        }\n        s = 1;\n        t = n;\n    } else if (type == \"cyclic\") {\n        // Generate a graph with cycles\n        m = n;\n        if (m > 1000000) {\n            m = 1000000;\n            n = m;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.emplace_back(i, i + 1);\n        }\n        edges.emplace_back(n, s); // Create cycle\n    } else if (type == \"random\") {\n        // Generate a random connected graph\n        int m_param = opt<int>(\"m\", -1);\n        if (m_param == -1) {\n            m = n - 1 + rnd.next(0, min(n * 2, 1000000) - (n - 1));\n            m = min(m, 1000000);\n        } else {\n            m = min(m_param, 1000000);\n        }\n        // Generate random spanning tree\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i) perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n        for (int i = 1; i < n; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.emplace_back(u, v);\n        }\n        set<pair<int, int>> existing_edges(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v && !existing_edges.count({u, v})) {\n                edges.emplace_back(u, v);\n                existing_edges.insert({u, v});\n            }\n        }\n    } else if (type == \"MaxOrders\") {\n        // Generate a graph where minimal required orders is large\n        int k = opt<int>(\"k\", n -1); // Number of extra edges\n        m = (n - 1) + k;\n        m = min(m, 1000000);\n        if (m < n -1) {\n            n = m + 1;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.emplace_back(i, i + 1); // Correct path\n        }\n        set<pair<int, int>> existing_edges(edges.begin(), edges.end());\n        for (int i = 0; i < k && (int)edges.size() < m; ++i) {\n            int u = rnd.next(1, n - 1);\n            if (u != s && !existing_edges.count({u, s})) {\n                edges.emplace_back(u, s); // Edge back to s\n                existing_edges.insert({u, s});\n            }\n        }\n    } else {\n        // Default: random graph\n    }\n\n    // Ensure total m ≤ 1e6\n    m = min((int)edges.size(), 1000000);\n    edges.resize(m);\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n    printf(\"%d %d\\n\", s, t);\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int s = opt<int>(\"s\", 1);\n    int t = opt<int>(\"t\", n);\n    \n    int m;\n    vector<pair<int, int>> edges;\n    \n    if (type == \"path\") {\n        // Generate a simple path from s to t\n        m = n - 1;\n        if (m > 1000000) {\n            m = 1000000;\n            n = m + 1;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.emplace_back(i, i + 1);\n        }\n    } else if (type == \"NoPath\") {\n        // Generate two disconnected components\n        n = max(n, 2);\n        m = n - 2;\n        if (m > 1000000) {\n            m = 1000000;\n            n = m + 2;\n        }\n        int mid = n / 2;\n        for (int i = 1; i < mid; ++i) {\n            edges.emplace_back(i, i + 1);\n        }\n        for (int i = mid + 1; i < n; ++i) {\n            edges.emplace_back(i, i + 1);\n        }\n        s = 1;\n        t = n;\n    } else if (type == \"cyclic\") {\n        // Generate a graph with cycles\n        m = n;\n        if (m > 1000000) {\n            m = 1000000;\n            n = m;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.emplace_back(i, i + 1);\n        }\n        edges.emplace_back(n, s); // Create cycle\n    } else if (type == \"random\") {\n        // Generate a random connected graph\n        int m_param = opt<int>(\"m\", -1);\n        if (m_param == -1) {\n            m = n - 1 + rnd.next(0, min(n * 2, 1000000) - (n - 1));\n            m = min(m, 1000000);\n        } else {\n            m = min(m_param, 1000000);\n        }\n        // Generate random spanning tree\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i) perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n        for (int i = 1; i < n; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.emplace_back(u, v);\n        }\n        set<pair<int, int>> existing_edges(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v && !existing_edges.count({u, v})) {\n                edges.emplace_back(u, v);\n                existing_edges.insert({u, v});\n            }\n        }\n    } else if (type == \"MaxOrders\") {\n        // Generate a graph where minimal required orders is large\n        int k = opt<int>(\"k\", n -1); // Number of extra edges\n        m = (n - 1) + k;\n        m = min(m, 1000000);\n        if (m < n -1) {\n            n = m + 1;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.emplace_back(i, i + 1); // Correct path\n        }\n        set<pair<int, int>> existing_edges(edges.begin(), edges.end());\n        for (int i = 0; i < k && (int)edges.size() < m; ++i) {\n            int u = rnd.next(1, n - 1);\n            if (u != s && !existing_edges.count({u, s})) {\n                edges.emplace_back(u, s); // Edge back to s\n                existing_edges.insert({u, s});\n            }\n        }\n    } else {\n        // Default: random graph\n    }\n\n    // Ensure total m ≤ 1e6\n    m = min((int)edges.size(), 1000000);\n    edges.resize(m);\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n    printf(\"%d %d\\n\", s, t);\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 5 -type path\n./gen -n 5 -type NoPath\n./gen -n 5 -type cyclic\n./gen -n 5 -type random\n./gen -n 5 -type MaxOrders -k 2\n\n# Medium test cases\n./gen -n 1000 -type path\n./gen -n 1000 -type NoPath\n./gen -n 1000 -type cyclic\n./gen -n 1000 -type random\n./gen -n 1000 -type MaxOrders -k 500\n\n# Large test cases\n./gen -n 100000 -type path\n./gen -n 100000 -type NoPath\n./gen -n 100000 -type cyclic\n./gen -n 100000 -type random\n./gen -n 100000 -type MaxOrders -k 50000\n\n# Maximum test cases\n./gen -n 1000000 -type path\n./gen -n 1000000 -type NoPath\n./gen -n 1000000 -type cyclic\n./gen -n 1000000 -type random -m 1000000\n./gen -n 1000000 -type MaxOrders -k 500000\n\n# Random test cases with different m\n./gen -n 1000000 -type random -m 500000\n./gen -n 1000000 -type random -m 1000000\n\n# MaxOrders with varying k\n./gen -n 1000000 -type MaxOrders -k 1000000\n./gen -n 1000000 -type MaxOrders -k 1\n./gen -n 1000000 -type MaxOrders -k 999999\n\n# Edge cases\n./gen -n 2 -type path\n./gen -n 2 -type NoPath\n./gen -n 2 -type cyclic\n./gen -n 2 -type MaxOrders -k 1\n\n# Random small graphs\n./gen -n 10 -type random -m 15\n./gen -n 50 -type random -m 100\n\n# Random medium graphs\n./gen -n 5000 -type random -m 10000\n./gen -n 10000 -type random -m 20000\n\n# Random MaxOrders with small k\n./gen -n 100000 -type MaxOrders -k 1\n./gen -n 100000 -type MaxOrders -k 99999\n\n# Cyclic graphs\n./gen -n 1000000 -type cyclic\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:48.784324",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "346/E",
      "title": "E. Doodle Jump",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer t (1 ≤ t ≤ 104) — the number of problem instances. Each of the next t lines contains four integers a, n, p and h (1 ≤ a ≤ 109, 1 ≤ n < p ≤ 109, 0 ≤ h ≤ 109). It's guaranteed that a and p are co-prime.",
      "output_spec": "OutputFor each problem instance, if the Doodler can reach the highest platform, output \"YES\", otherwise output \"NO\".",
      "sample_tests": "ExamplesInputCopy37 4 12 27 1 9 47 4 12 3OutputCopyNONOYES",
      "description": "E. Doodle Jump\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer t (1 ≤ t ≤ 104) — the number of problem instances. Each of the next t lines contains four integers a, n, p and h (1 ≤ a ≤ 109, 1 ≤ n < p ≤ 109, 0 ≤ h ≤ 109). It's guaranteed that a and p are co-prime.\n\nOutputFor each problem instance, if the Doodler can reach the highest platform, output \"YES\", otherwise output \"NO\".\n\nInputCopy37 4 12 27 1 9 47 4 12 3OutputCopyNONOYES\n\nInputCopy37 4 12 27 1 9 47 4 12 3\n\nOutputCopyNONOYES",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Hello everyone!Codeforces Round #201 is scheduled to take place at Friday, Sep. 20th at 19:30 MSK(23:30 CST)Setters are: CMHJT and me.Testers are: error202, havaliza and tourist.Thanks to MinakoKojima for her help in rewrite the statements into codeforces style, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Special thanks to tourist and Gerald in giving advise about the problems so we could put them in a more proper order. 500 — 1000 — 1500 — 2000 — 2500.We are going to use standard score distribution in both divisions. The problems are not so hard, but you need more thinking rather than coding.Good luck!UPD1: Congratulations to the top 5 winners in each division!DivI1.cgy4ever2.rng_583.PavelKunyavskiy4.Egor5.liympandaDivII1.Thrax2.renannewbie3.socksister014.SJTU_WengJian5.cat_leopardUPD2: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 909
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 346 和字母"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {  // Function to compute Greatest Common Divisor\n    while (b != 0) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10000, \"t\");  // Read t and ensure it is in [1, 10000]\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int a = inf.readInt(1, 1000000000, \"a\");  // Read a and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int n = inf.readInt(1, 1000000000, \"n\");  // Read n and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int p = inf.readInt(1, 1000000000, \"p\");  // Read p and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int h = inf.readInt(0, 1000000000, \"h\");  // Read h and ensure it is in [0, 1e9]\n        inf.readEoln();\n        ensuref(n < p, \"n must be less than p, but n=%d, p=%d\", n, p);  // Ensure n < p\n        ensuref(gcd(a, p) == 1, \"a and p must be coprime, but gcd(%d, %d) = %d\", a, p, gcd(a, p));  // Ensure a and p are coprime\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {  // Function to compute Greatest Common Divisor\n    while (b != 0) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10000, \"t\");  // Read t and ensure it is in [1, 10000]\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int a = inf.readInt(1, 1000000000, \"a\");  // Read a and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int n = inf.readInt(1, 1000000000, \"n\");  // Read n and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int p = inf.readInt(1, 1000000000, \"p\");  // Read p and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int h = inf.readInt(0, 1000000000, \"h\");  // Read h and ensure it is in [0, 1e9]\n        inf.readEoln();\n        ensuref(n < p, \"n must be less than p, but n=%d, p=%d\", n, p);  // Ensure n < p\n        ensuref(gcd(a, p) == 1, \"a and p must be coprime, but gcd(%d, %d) = %d\", a, p, gcd(a, p));  // Ensure a and p are coprime\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {  // Function to compute Greatest Common Divisor\n    while (b != 0) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10000, \"t\");  // Read t and ensure it is in [1, 10000]\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int a = inf.readInt(1, 1000000000, \"a\");  // Read a and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int n = inf.readInt(1, 1000000000, \"n\");  // Read n and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int p = inf.readInt(1, 1000000000, \"p\");  // Read p and ensure it is in [1, 1e9]\n        inf.readSpace();\n        int h = inf.readInt(0, 1000000000, \"h\");  // Read h and ensure it is in [0, 1e9]\n        inf.readEoln();\n        ensuref(n < p, \"n must be less than p, but n=%d, p=%d\", n, p);  // Ensure n < p\n        ensuref(gcd(a, p) == 1, \"a and p must be coprime, but gcd(%d, %d) = %d\", a, p, gcd(a, p));  // Ensure a and p are coprime\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to generate two co-prime numbers a and p, with 1 ≤ a ≤ max_a, 1 ≤ p ≤ max_p\nvoid generate_coprime_numbers(long long &a, long long &p, long long max_a, long long max_p) {\n    // Randomly choose p in [2, max_p]\n    p = rnd.next(2LL, max_p); // p ≥ 2\n    // Now choose a in [1, p-1], as we need n < p, so p ≥ n+1 ≥ 2\n    // So a ∈ [1, p-1], gcd(a, p) = 1\n    do {\n        a = rnd.next(1LL, p-1);\n    } while (__gcd(a, p) != 1);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    long long t = opt<long long>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    printf(\"%lld\\n\", t);\n    \n    for (int i = 0; i < t; ++i) {\n        long long a, n, p, h;\n        \n        if (type == \"random\") {\n            // Random values within constraints\n            generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            n = rnd.next(1LL, p - 1);\n            h = rnd.next(0LL, 1000000000LL);\n        } else if (type == \"max\") {\n            // Maximum values within constraints\n            p = 1000000000LL;\n            a = p - 1;\n            if (__gcd(a, p) != 1) a = p - 2; // Adjust a if necessary\n            n = p - 1;\n            h = 1000000000LL;\n        } else if (type == \"min\") {\n            // Minimum values within constraints\n            p = 2;\n            a = 1;\n            n = 1;\n            h = 0;\n        } else if (type == \"h_zero\") {\n            // h = 0\n            generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            n = rnd.next(1LL, p - 1);\n            h = 0;\n        } else if (type == \"cannot_reach\") {\n            // Generate cases where Doodler cannot reach the highest platform\n            h = 0;\n            // Let's choose a and p such that h(1) ≠ 0\n            do {\n                generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            } while ((a * 1LL) % p == 0); // Ensure h(1) ≠ 0\n            n = rnd.next(1LL, p - 1);\n        } else if (type == \"can_reach\") {\n            // Generate cases where Doodler can reach the highest platform\n            h = 1000000000LL;\n            generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            n = rnd.next(1LL, p -1);\n        } else if (type == \"special\") {\n            // Generate special cases that might cause incorrect solutions to fail\n            p = rnd.next(2LL, 1000000000LL);\n            do {\n                a = rnd.next(1LL, p -1);\n            } while (__gcd(a, p) != 1);\n            n = p - 1;\n            h = rnd.next(0LL, 10LL); // Small h\n        } else {\n            // Default to random\n            generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            n = rnd.next(1LL, p - 1);\n            h = rnd.next(0LL, 1000000000LL);\n        }\n        \n        printf(\"%lld %lld %lld %lld\\n\", a, n, p, h);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to generate two co-prime numbers a and p, with 1 ≤ a ≤ max_a, 1 ≤ p ≤ max_p\nvoid generate_coprime_numbers(long long &a, long long &p, long long max_a, long long max_p) {\n    // Randomly choose p in [2, max_p]\n    p = rnd.next(2LL, max_p); // p ≥ 2\n    // Now choose a in [1, p-1], as we need n < p, so p ≥ n+1 ≥ 2\n    // So a ∈ [1, p-1], gcd(a, p) = 1\n    do {\n        a = rnd.next(1LL, p-1);\n    } while (__gcd(a, p) != 1);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    long long t = opt<long long>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    printf(\"%lld\\n\", t);\n    \n    for (int i = 0; i < t; ++i) {\n        long long a, n, p, h;\n        \n        if (type == \"random\") {\n            // Random values within constraints\n            generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            n = rnd.next(1LL, p - 1);\n            h = rnd.next(0LL, 1000000000LL);\n        } else if (type == \"max\") {\n            // Maximum values within constraints\n            p = 1000000000LL;\n            a = p - 1;\n            if (__gcd(a, p) != 1) a = p - 2; // Adjust a if necessary\n            n = p - 1;\n            h = 1000000000LL;\n        } else if (type == \"min\") {\n            // Minimum values within constraints\n            p = 2;\n            a = 1;\n            n = 1;\n            h = 0;\n        } else if (type == \"h_zero\") {\n            // h = 0\n            generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            n = rnd.next(1LL, p - 1);\n            h = 0;\n        } else if (type == \"cannot_reach\") {\n            // Generate cases where Doodler cannot reach the highest platform\n            h = 0;\n            // Let's choose a and p such that h(1) ≠ 0\n            do {\n                generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            } while ((a * 1LL) % p == 0); // Ensure h(1) ≠ 0\n            n = rnd.next(1LL, p - 1);\n        } else if (type == \"can_reach\") {\n            // Generate cases where Doodler can reach the highest platform\n            h = 1000000000LL;\n            generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            n = rnd.next(1LL, p -1);\n        } else if (type == \"special\") {\n            // Generate special cases that might cause incorrect solutions to fail\n            p = rnd.next(2LL, 1000000000LL);\n            do {\n                a = rnd.next(1LL, p -1);\n            } while (__gcd(a, p) != 1);\n            n = p - 1;\n            h = rnd.next(0LL, 10LL); // Small h\n        } else {\n            // Default to random\n            generate_coprime_numbers(a, p, 1000000000LL, 1000000000LL);\n            n = rnd.next(1LL, p - 1);\n            h = rnd.next(0LL, 1000000000LL);\n        }\n        \n        printf(\"%lld %lld %lld %lld\\n\", a, n, p, h);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type min\n./gen -t 1 -type max\n./gen -t 1 -type h_zero\n./gen -t 1 -type can_reach\n./gen -t 1 -type cannot_reach\n./gen -t 1 -type special\n./gen -t 10 -type random\n./gen -t 10 -type h_zero\n./gen -t 10 -type can_reach\n./gen -t 10 -type cannot_reach\n./gen -t 10 -type special\n./gen -t 100 -type random\n./gen -t 100 -type h_zero\n./gen -t 100 -type can_reach\n./gen -t 100 -type cannot_reach\n./gen -t 100 -type special\n./gen -t 1000 -type random\n./gen -t 1000 -type h_zero\n./gen -t 1000 -type can_reach\n./gen -t 1000 -type cannot_reach\n./gen -t 1000 -type special\n./gen -t 5000 -type random\n./gen -t 10000 -type max\n./gen -t 10000 -type random\n./gen -t 10000 -type h_zero\n./gen -t 10000 -type can_reach\n./gen -t 10000 -type cannot_reach\n./gen -t 10000 -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:50.606109",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "347/A",
      "title": "A. Difference Row",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (2 ≤ n ≤ 100). The second line contains n space-separated integers a1, a2, ..., an (|ai| ≤ 1000).",
      "output_spec": "OutputPrint the required sequence x1, x2, ..., xn. Sequence x should be the lexicographically smallest permutation of a that corresponds to an arrangement of the largest possible value.",
      "sample_tests": "ExamplesInputCopy5100 -100 50 0 -50OutputCopy100 -50 0 50 -100",
      "description": "A. Difference Row\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (2 ≤ n ≤ 100). The second line contains n space-separated integers a1, a2, ..., an (|ai| ≤ 1000).\n\nOutputPrint the required sequence x1, x2, ..., xn. Sequence x should be the lexicographically smallest permutation of a that corresponds to an arrangement of the largest possible value.\n\nInputCopy5100 -100 50 0 -50OutputCopy100 -50 0 50 -100\n\nInputCopy5100 -100 50 0 -50\n\nOutputCopy100 -50 0 50 -100\n\nNoteIn the sample test case, the value of the output arrangement is (100 - ( - 50)) + (( - 50) - 0) + (0 - 50) + (50 - ( - 100)) = 200. No other arrangement has a larger value, and among all arrangements with the value of 200, the output arrangement is the lexicographically smallest one.Sequence x1, x2, ... , xp is lexicographically smaller than sequence y1, y2, ... , yp if there exists an integer r (0 ≤ r < p) such that x1 = y1, x2 = y2, ... , xr = yr and xr + 1 < yr + 1.",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Hello everyone!Codeforces Round #201 is scheduled to take place at Friday, Sep. 20th at 19:30 MSK(23:30 CST)Setters are: CMHJT and me.Testers are: error202, havaliza and tourist.Thanks to MinakoKojima for her help in rewrite the statements into codeforces style, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Special thanks to tourist and Gerald in giving advise about the problems so we could put them in a more proper order. 500 — 1000 — 1500 — 2000 — 2500.We are going to use standard score distribution in both divisions. The problems are not so hard, but you need more thinking rather than coding.Good luck!UPD1: Congratulations to the top 5 winners in each division!DivI1.cgy4ever2.rng_583.PavelKunyavskiy4.Egor5.liympandaDivII1.Thrax2.renannewbie3.socksister014.SJTU_WengJian5.cat_leopardUPD2: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 909
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if(type == \"random\"){\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(-1000, 1000);\n        }\n    } else if(type == \"all_same\"){\n        int val = rnd.next(-1000, 1000);\n        for(int i = 0; i < n; ++i){\n            a[i] = val;\n        }\n    } else if(type == \"ascending\"){\n        a[0] = rnd.next(-1000, 1000 - 10 * n);\n        for(int i = 1; i < n; ++i){\n            a[i] = a[i-1] + rnd.next(1, 10);\n            if(a[i] > 1000) a[i] = 1000;\n        }\n    } else if(type == \"descending\"){\n        a[0] = rnd.next(-1000 + 10 * n, 1000);\n        for(int i = 1; i < n; ++i){\n            a[i] = a[i-1] - rnd.next(1,10);\n            if(a[i] < -1000) a[i] = -1000;\n        }\n    } else if(type == \"duplicates\"){\n        int vals = rnd.next(1, n/2 + 1);\n        vector<int> unique_vals;\n        for(int i = 0; i < vals; ++i){\n            unique_vals.push_back(rnd.next(-1000, 1000));\n        }\n        for(int i = 0; i < n; ++i){\n            a[i] = unique_vals[rnd.next(0, vals -1)];\n        }\n    } else if(type == \"max_min_multiple\"){\n        int max_val = rnd.next(500, 1000);\n        int min_val = rnd.next(-1000, -500);\n        int max_count = rnd.next(1, n/2);\n        int min_count = rnd.next(1, n - max_count);\n        vector<int> vals;\n        for(int i = 0; i < max_count; ++i)\n            vals.push_back(max_val);\n        for(int i = 0; i < min_count; ++i)\n            vals.push_back(min_val);\n        while((int)vals.size() < n){\n            vals.push_back(rnd.next(min_val+1, max_val-1));\n        }\n        shuffle(vals.begin(), vals.end());\n        a = vals;\n    } else if(type == \"all_positive\"){\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(1,1000);\n        }\n    } else if(type == \"all_negative\"){\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(-1000,-1);\n        }\n    } else if(type == \"alternating_signs\"){\n        for(int i = 0; i < n; ++i){\n            int val = rnd.next(1, 1000);\n            if(i%2 == 0) val *= -1;\n            a[i] = val;\n        }\n    } else if(type == \"max_at_1000_min_at_minus_1000\"){\n        a[0] = 1000;\n        a[n-1] = -1000;\n        for(int i = 1; i < n-1; ++i){\n            a[i] = rnd.next(-999,999);\n        }\n        // Positions of max and min are fixed\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(-1000, 1000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%d\", a[i]);\n        if(i != n-1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if(type == \"random\"){\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(-1000, 1000);\n        }\n    } else if(type == \"all_same\"){\n        int val = rnd.next(-1000, 1000);\n        for(int i = 0; i < n; ++i){\n            a[i] = val;\n        }\n    } else if(type == \"ascending\"){\n        a[0] = rnd.next(-1000, 1000 - 10 * n);\n        for(int i = 1; i < n; ++i){\n            a[i] = a[i-1] + rnd.next(1, 10);\n            if(a[i] > 1000) a[i] = 1000;\n        }\n    } else if(type == \"descending\"){\n        a[0] = rnd.next(-1000 + 10 * n, 1000);\n        for(int i = 1; i < n; ++i){\n            a[i] = a[i-1] - rnd.next(1,10);\n            if(a[i] < -1000) a[i] = -1000;\n        }\n    } else if(type == \"duplicates\"){\n        int vals = rnd.next(1, n/2 + 1);\n        vector<int> unique_vals;\n        for(int i = 0; i < vals; ++i){\n            unique_vals.push_back(rnd.next(-1000, 1000));\n        }\n        for(int i = 0; i < n; ++i){\n            a[i] = unique_vals[rnd.next(0, vals -1)];\n        }\n    } else if(type == \"max_min_multiple\"){\n        int max_val = rnd.next(500, 1000);\n        int min_val = rnd.next(-1000, -500);\n        int max_count = rnd.next(1, n/2);\n        int min_count = rnd.next(1, n - max_count);\n        vector<int> vals;\n        for(int i = 0; i < max_count; ++i)\n            vals.push_back(max_val);\n        for(int i = 0; i < min_count; ++i)\n            vals.push_back(min_val);\n        while((int)vals.size() < n){\n            vals.push_back(rnd.next(min_val+1, max_val-1));\n        }\n        shuffle(vals.begin(), vals.end());\n        a = vals;\n    } else if(type == \"all_positive\"){\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(1,1000);\n        }\n    } else if(type == \"all_negative\"){\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(-1000,-1);\n        }\n    } else if(type == \"alternating_signs\"){\n        for(int i = 0; i < n; ++i){\n            int val = rnd.next(1, 1000);\n            if(i%2 == 0) val *= -1;\n            a[i] = val;\n        }\n    } else if(type == \"max_at_1000_min_at_minus_1000\"){\n        a[0] = 1000;\n        a[n-1] = -1000;\n        for(int i = 1; i < n-1; ++i){\n            a[i] = rnd.next(-999,999);\n        }\n        // Positions of max and min are fixed\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(-1000, 1000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%d\", a[i]);\n        if(i != n-1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small N (n=2)\n./gen -n 2 -type random\n./gen -n 2 -type all_same\n./gen -n 2 -type ascending\n./gen -n 2 -type descending\n./gen -n 2 -type all_positive\n./gen -n 2 -type all_negative\n./gen -n 2 -type duplicates\n./gen -n 2 -type max_min_multiple\n./gen -n 2 -type alternating_signs\n./gen -n 2 -type max_at_1000_min_at_minus_1000\n\n# Medium N (n=50)\n./gen -n 50 -type random\n./gen -n 50 -type all_same\n./gen -n 50 -type ascending\n./gen -n 50 -type descending\n./gen -n 50 -type all_positive\n./gen -n 50 -type all_negative\n./gen -n 50 -type duplicates\n./gen -n 50 -type max_min_multiple\n./gen -n 50 -type alternating_signs\n./gen -n 50 -type max_at_1000_min_at_minus_1000\n\n# Large N (n=100)\n./gen -n 100 -type random\n./gen -n 100 -type all_same\n./gen -n 100 -type ascending\n./gen -n 100 -type descending\n./gen -n 100 -type all_positive\n./gen -n 100 -type all_negative\n./gen -n 100 -type duplicates\n./gen -n 100 -type max_min_multiple\n./gen -n 100 -type alternating_signs\n./gen -n 100 -type max_at_1000_min_at_minus_1000\n\n# Edge N values\n./gen -n 99 -type random\n./gen -n 2 -type random\n\n# Random N\n./gen -n 73 -type random\n./gen -n 37 -type random\n\n# Random N with specific type\n./gen -n 73 -type duplicates\n./gen -n 37 -type max_min_multiple\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:52.335146",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "347/B",
      "title": "B. Fixed Points",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105). The second line contains n integers a0, a1, ..., an - 1 — the given permutation.",
      "output_spec": "OutputPrint a single integer — the maximum possible number of fixed points in the permutation after at most one swap operation.",
      "sample_tests": "ExamplesInputCopy50 1 3 4 2OutputCopy3",
      "description": "B. Fixed Points\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105). The second line contains n integers a0, a1, ..., an - 1 — the given permutation.\n\nOutputPrint a single integer — the maximum possible number of fixed points in the permutation after at most one swap operation.\n\nInputCopy50 1 3 4 2OutputCopy3\n\nInputCopy50 1 3 4 2\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Hello everyone!Codeforces Round #201 is scheduled to take place at Friday, Sep. 20th at 19:30 MSK(23:30 CST)Setters are: CMHJT and me.Testers are: error202, havaliza and tourist.Thanks to MinakoKojima for her help in rewrite the statements into codeforces style, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Special thanks to tourist and Gerald in giving advise about the problems so we could put them in a more proper order. 500 — 1000 — 1500 — 2000 — 2500.We are going to use standard score distribution in both divisions. The problems are not so hard, but you need more thinking rather than coding.Good luck!UPD1: Congratulations to the top 5 winners in each division!DivI1.cgy4ever2.rng_583.PavelKunyavskiy4.Egor5.liympandaDivII1.Thrax2.renannewbie3.socksister014.SJTU_WengJian5.cat_leopardUPD2: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 909
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    // Read permutation a\n    vector<int> a = inf.readInts(n, 0, n - 1);\n    inf.readEoln();\n\n    // Check that a is a permutation of 0 to n - 1\n    vector<bool> used(n, false);\n    for (int i = 0; i < n; ++i) {\n        ensuref(!used[a[i]], \"Duplicate element found: %d\", a[i]);\n        used[a[i]] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    // Read permutation a\n    vector<int> a = inf.readInts(n, 0, n - 1);\n    inf.readEoln();\n\n    // Check that a is a permutation of 0 to n - 1\n    vector<bool> used(n, false);\n    for (int i = 0; i < n; ++i) {\n        ensuref(!used[a[i]], \"Duplicate element found: %d\", a[i]);\n        used[a[i]] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    // Read permutation a\n    vector<int> a = inf.readInts(n, 0, n - 1);\n    inf.readEoln();\n\n    // Check that a is a permutation of 0 to n - 1\n    vector<bool> used(n, false);\n    for (int i = 0; i < n; ++i) {\n        ensuref(!used[a[i]], \"Duplicate element found: %d\", a[i]);\n        used[a[i]] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> perm(n);\n\n    if (type == \"identity\") {\n        /* Generate the identity permutation */\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n    } else if (type == \"random\") {\n        /* Generate a random permutation */\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n    } else if (type == \"no_fixed_point\") {\n        /* Generate a permutation with no fixed points (derangement) */\n        if (n == 1) {\n            perm[0] = 0; // Only possible permutation\n        } else {\n            for (int i = 0; i < n; ++i)\n                perm[i] = i;\n            for (int i = 0; i < n - 1; i++) {\n                int j = rnd.next(i + 1, n - 1);\n                swap(perm[i], perm[j]);\n            }\n            for(int i = 0; i < n; ++i) {\n                if(perm[i] == i) {\n                    if(i < n - 1)\n                        swap(perm[i], perm[i + 1]);\n                    else\n                        swap(perm[i], perm[i - 1]);\n                }\n            }\n        }\n    } else if (type == \"mutual\" || type == \"max_pairs\") {\n        /* Generate a permutation with as many mutual pairs as possible */\n        for(int i = 0; i < n; ++i)\n            perm[i] = i;\n        for(int i = 0; i + 1 < n; i += 2) {\n            perm[i] = i + 1;\n            perm[i + 1] = i;\n        }\n        if(n % 2 == 1) {\n            if(perm[n - 1] == n - 1) {\n                perm[n - 1] = perm[0];\n                perm[0] = n - 1;\n            }\n        }\n    } else if (type == \"single_swap\") {\n        /* Generate a permutation where swapping any pair can only increase fixed points by 1 */\n        if(n == 1) {\n            perm[0] = 0;\n        } else {\n            for(int i = 0; i < n; ++i)\n                perm[i] = (i + 1) % n;\n        }\n    } else if (type == \"single_mutual\") {\n        /* Generate a permutation with one mutual pair and no other fixed points */\n        if(n == 1) {\n            perm[0] = 0;\n        } else {\n            for(int i = 0; i < n; ++i)\n                perm[i] = (i + 1) % n;\n            perm[0] = n - 1;\n            perm[n - 1] = 0;\n        }\n    } else {\n        /* Default to random permutation */\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n    }\n    \n    /* Output */\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", perm[i]);\n        if(i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> perm(n);\n\n    if (type == \"identity\") {\n        /* Generate the identity permutation */\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n    } else if (type == \"random\") {\n        /* Generate a random permutation */\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n    } else if (type == \"no_fixed_point\") {\n        /* Generate a permutation with no fixed points (derangement) */\n        if (n == 1) {\n            perm[0] = 0; // Only possible permutation\n        } else {\n            for (int i = 0; i < n; ++i)\n                perm[i] = i;\n            for (int i = 0; i < n - 1; i++) {\n                int j = rnd.next(i + 1, n - 1);\n                swap(perm[i], perm[j]);\n            }\n            for(int i = 0; i < n; ++i) {\n                if(perm[i] == i) {\n                    if(i < n - 1)\n                        swap(perm[i], perm[i + 1]);\n                    else\n                        swap(perm[i], perm[i - 1]);\n                }\n            }\n        }\n    } else if (type == \"mutual\" || type == \"max_pairs\") {\n        /* Generate a permutation with as many mutual pairs as possible */\n        for(int i = 0; i < n; ++i)\n            perm[i] = i;\n        for(int i = 0; i + 1 < n; i += 2) {\n            perm[i] = i + 1;\n            perm[i + 1] = i;\n        }\n        if(n % 2 == 1) {\n            if(perm[n - 1] == n - 1) {\n                perm[n - 1] = perm[0];\n                perm[0] = n - 1;\n            }\n        }\n    } else if (type == \"single_swap\") {\n        /* Generate a permutation where swapping any pair can only increase fixed points by 1 */\n        if(n == 1) {\n            perm[0] = 0;\n        } else {\n            for(int i = 0; i < n; ++i)\n                perm[i] = (i + 1) % n;\n        }\n    } else if (type == \"single_mutual\") {\n        /* Generate a permutation with one mutual pair and no other fixed points */\n        if(n == 1) {\n            perm[0] = 0;\n        } else {\n            for(int i = 0; i < n; ++i)\n                perm[i] = (i + 1) % n;\n            perm[0] = n - 1;\n            perm[n - 1] = 0;\n        }\n    } else {\n        /* Default to random permutation */\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n    }\n    \n    /* Output */\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", perm[i]);\n        if(i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type identity\n./gen -n 1 -type random\n./gen -n 1 -type no_fixed_point\n\n./gen -n 2 -type identity\n./gen -n 2 -type random\n./gen -n 2 -type no_fixed_point\n./gen -n 2 -type mutual\n\n./gen -n 10 -type identity\n./gen -n 10 -type random\n./gen -n 10 -type no_fixed_point\n./gen -n 10 -type mutual\n./gen -n 10 -type single_swap\n\n./gen -n 100 -type random\n./gen -n 100 -type no_fixed_point\n./gen -n 100 -type mutual\n./gen -n 100 -type single_swap\n\n./gen -n 1000 -type identity\n./gen -n 1000 -type random\n./gen -n 1000 -type no_fixed_point\n./gen -n 1000 -type mutual\n./gen -n 1000 -type single_swap\n\n./gen -n 10000 -type random\n./gen -n 10000 -type no_fixed_point\n./gen -n 10000 -type mutual\n./gen -n 10000 -type single_swap\n\n./gen -n 100000 -type identity\n./gen -n 100000 -type random\n./gen -n 100000 -type no_fixed_point\n./gen -n 100000 -type mutual\n./gen -n 100000 -type single_swap\n\n./gen -n 100000 -type single_mutual\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:54.395417",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "347/C",
      "title": "C. Алиса и Боб",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (2 ≤ n ≤ 100) — исходное количество элементов в множестве. Во второй строке записано n различных целых чисел a1, a2, ..., an (1 ≤ ai ≤ 109), разделенных пробелом, — элементы множества.",
      "output_spec": "Выходные данныеВ единственной строке выведите имя победителя. Если победит Алиса, выведите «Alice», а если победит Боб, то «Bob» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать22 3Выходные данныеСкопироватьAliceВходные данныеСкопировать25 3Выходные данныеСкопироватьAliceВходные данныеСкопировать35 6 7Выходные данныеСкопироватьBob",
      "description": "C. Алиса и Боб\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (2 ≤ n ≤ 100) — исходное количество элементов в множестве. Во второй строке записано n различных целых чисел a1, a2, ..., an (1 ≤ ai ≤ 109), разделенных пробелом, — элементы множества.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите имя победителя. Если победит Алиса, выведите «Alice», а если победит Боб, то «Bob» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать22 3Выходные данныеСкопироватьAliceВходные данныеСкопировать25 3Выходные данныеСкопироватьAliceВходные данныеСкопировать35 6 7Выходные данныеСкопироватьBob\n\nВходные данныеСкопировать22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьAlice\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать25 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьAlice\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать35 6 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьBob\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример. Сперва ходит Алиса. Она может сделать только один ход: выбрать 2 и 3, а затем добавить ко множеству 1. Затем ходит Боб, допустимых ходов не остается и побеждает Алиса.",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Всем привет!Codeforces Round #201 пройдет в пятницу, 20-го сентября в пятницу, 20-го сентября в 19:30 MSK(23:30 CST)Авторы задач: CMHJT и я.Тестеры: error202, havaliza и tourist.Мы хотим сказать спасибо MinakoKojima за обработку условий, Delinur за перевод условий задач на русский язык, и MikeMirzayanov за разработку мощной платформы для подготовки контестов.Особая благодарность пользователям tourist и Gerald за их советы по задачам, теперь задачи расположены в наиболее правильном порядке. 500 — 1000 — 1500 — 2000 — 2500.Будет использоваться стандартная разбалловка в обоих дивизионах. Задачи будут не очень сложными, но вам потребуется думать гораздо больше нежели писать код.Удачи!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 689
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random integers between 1 and 1e9\n        set<int> used;\n        for (int i = 0; i < n;) {\n            int x = rnd.next(1, 1000000000);\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i++] = x;\n            }\n        }\n    } else if (type == \"no_moves\") {\n        // Generate elements where all possible differences are in the set\n        // Use consecutive numbers so that differences are already included\n        int start = rnd.next(1, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"long_game\") {\n        // Generate elements where differences are not in the set\n        // Use large gaps between numbers to maximize possible moves\n        set<int> used;\n        int delta = 10000000; // Large delta to avoid immediate differences\n        int start = rnd.next(1, max(1, 1000000000 - delta * n));\n        for (int i = 0; i < n; ++i) {\n            int x = start + i * delta;\n            if (x > 1000000000) x = 1000000000 - i; // Adjust if exceeding limit\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i] = x;\n            } else {\n                a[i] = x - 1; // Adjust slightly to ensure uniqueness\n                used.insert(a[i]);\n            }\n        }\n    } else if (type == \"min_numbers\") {\n        // All numbers are small, close to 1\n        set<int> used;\n        for (int i = 0; i < n;) {\n            int x = rnd.next(1, n * 10);\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i++] = x;\n            }\n        }\n    } else if (type == \"max_numbers\") {\n        // All numbers are large, close to 1e9\n        set<int> used;\n        for (int i = 0; i < n;) {\n            int x = rnd.next(1000000000 - n * 10, 1000000000);\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i++] = x;\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        set<int> used;\n        for (int i = 0; i < n;) {\n            int x = rnd.next(1, 1000000000);\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i++] = x;\n            }\n        }\n    }\n\n    // Output n and the elements\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random integers between 1 and 1e9\n        set<int> used;\n        for (int i = 0; i < n;) {\n            int x = rnd.next(1, 1000000000);\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i++] = x;\n            }\n        }\n    } else if (type == \"no_moves\") {\n        // Generate elements where all possible differences are in the set\n        // Use consecutive numbers so that differences are already included\n        int start = rnd.next(1, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"long_game\") {\n        // Generate elements where differences are not in the set\n        // Use large gaps between numbers to maximize possible moves\n        set<int> used;\n        int delta = 10000000; // Large delta to avoid immediate differences\n        int start = rnd.next(1, max(1, 1000000000 - delta * n));\n        for (int i = 0; i < n; ++i) {\n            int x = start + i * delta;\n            if (x > 1000000000) x = 1000000000 - i; // Adjust if exceeding limit\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i] = x;\n            } else {\n                a[i] = x - 1; // Adjust slightly to ensure uniqueness\n                used.insert(a[i]);\n            }\n        }\n    } else if (type == \"min_numbers\") {\n        // All numbers are small, close to 1\n        set<int> used;\n        for (int i = 0; i < n;) {\n            int x = rnd.next(1, n * 10);\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i++] = x;\n            }\n        }\n    } else if (type == \"max_numbers\") {\n        // All numbers are large, close to 1e9\n        set<int> used;\n        for (int i = 0; i < n;) {\n            int x = rnd.next(1000000000 - n * 10, 1000000000);\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i++] = x;\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        set<int> used;\n        for (int i = 0; i < n;) {\n            int x = rnd.next(1, 1000000000);\n            if (used.count(x) == 0) {\n                used.insert(x);\n                a[i++] = x;\n            }\n        }\n    }\n\n    // Output n and the elements\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type no_moves\n./gen -n 2 -type long_game\n./gen -n 2 -type min_numbers\n./gen -n 2 -type max_numbers\n\n./gen -n 5 -type random\n./gen -n 5 -type no_moves\n./gen -n 5 -type long_game\n./gen -n 5 -type min_numbers\n./gen -n 5 -type max_numbers\n\n./gen -n 10 -type random\n./gen -n 10 -type no_moves\n./gen -n 10 -type long_game\n./gen -n 10 -type min_numbers\n./gen -n 10 -type max_numbers\n\n./gen -n 50 -type random\n./gen -n 50 -type no_moves\n./gen -n 50 -type long_game\n./gen -n 50 -type min_numbers\n./gen -n 50 -type max_numbers\n\n./gen -n 100 -type random\n./gen -n 100 -type no_moves\n./gen -n 100 -type long_game\n./gen -n 100 -type min_numbers\n./gen -n 100 -type max_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:56.087330",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "347/D",
      "title": "D. Lucky Common Subsequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe input contains three strings in three separate lines: s1, s2 and virus (1 ≤ |s1|, |s2|, |virus| ≤ 100). Each string consists only of uppercase English letters.",
      "output_spec": "OutputOutput the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted. If there is no valid common subsequence, output 0.",
      "sample_tests": "ExamplesInputCopyAJKEQSLOBSROFGZOVGURWZLWVLUXTHOZOutputCopyORZInputCopyAAAAOutputCopy0",
      "description": "D. Lucky Common Subsequence\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains three strings in three separate lines: s1, s2 and virus (1 ≤ |s1|, |s2|, |virus| ≤ 100). Each string consists only of uppercase English letters.\n\nOutputOutput the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted. If there is no valid common subsequence, output 0.\n\nInputCopyAJKEQSLOBSROFGZOVGURWZLWVLUXTHOZOutputCopyORZInputCopyAAAAOutputCopy0\n\nInputCopyAJKEQSLOBSROFGZOVGURWZLWVLUXTHOZ\n\nOutputCopyORZ\n\nInputCopyAAAA\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Hello everyone!Codeforces Round #201 is scheduled to take place at Friday, Sep. 20th at 19:30 MSK(23:30 CST)Setters are: CMHJT and me.Testers are: error202, havaliza and tourist.Thanks to MinakoKojima for her help in rewrite the statements into codeforces style, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Special thanks to tourist and Gerald in giving advise about the problems so we could put them in a more proper order. 500 — 1000 — 1500 — 2000 — 2500.We are going to use standard score distribution in both divisions. The problems are not so hard, but you need more thinking rather than coding.Good luck!UPD1: Congratulations to the top 5 winners in each division!DivI1.cgy4ever2.rng_583.PavelKunyavskiy4.Egor5.liympandaDivII1.Thrax2.renannewbie3.socksister014.SJTU_WengJian5.cat_leopardUPD2: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 909
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[A-Z]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[A-Z]{1,100}\", \"s2\");\n    string virus = inf.readLine(\"[A-Z]{1,100}\", \"virus\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[A-Z]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[A-Z]{1,100}\", \"s2\");\n    string virus = inf.readLine(\"[A-Z]{1,100}\", \"virus\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[A-Z]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[A-Z]{1,100}\", \"s2\");\n    string virus = inf.readLine(\"[A-Z]{1,100}\", \"virus\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll read the jury's solution (ans) and the participant's solution (ouf),\n// check if each is valid, and compare their lengths.\n//\n// Validity conditions for a solution string sol are:\n// 1) If sol is not \"0\", it must be a common subsequence of s1 and s2.\n// 2) It must not contain 'virus' as a substring.\n// 3) If sol is \"0\", it represents an empty solution. (length = 0)\n//\n// After reading both, we compare lengths:\n//  - If jury's length > participant's length => _wa (participant gave a worse solution).\n//  - If jury's length == participant's length => _ok (accepted).\n//  - If jury's length < participant's length => _fail (jury solution not maximal or participant found something unexpected).\n\nstring s1, s2, virus;\n\n// Check if 'sub' is a subsequence of 'str'\nbool isSubsequence(const string &sub, const string &str) {\n    int i = 0, j = 0;\n    while (i < (int)sub.size() && j < (int)str.size()) {\n        if (sub[i] == str[j]) i++;\n        j++;\n    }\n    return (i == (int)sub.size());\n}\n\n// Read and validate an answer from the given stream\n// Returns the length of the subsequence if valid, otherwise calls quitf with the appropriate verdict.\nint readAns(InStream &stream) {\n    // The solution should be a single token\n    string sol = stream.readToken();\n\n    if (sol == \"0\") {\n        // The user claims there is no valid solution, treat length as 0\n        return 0;\n    }\n\n    // Check the 'virus' substring condition\n    if (sol.find(virus) != string::npos) {\n        stream.quitf(_wa, \"the answer contains the forbidden substring '%s'\", virus.c_str());\n    }\n\n    // Check subsequence conditions\n    if (!isSubsequence(sol, s1)) {\n        stream.quitf(_wa, \"the answer is not a subsequence of s1\");\n    }\n    if (!isSubsequence(sol, s2)) {\n        stream.quitf(_wa, \"the answer is not a subsequence of s2\");\n    }\n\n    return (int)sol.size();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read s1, s2, virus from the input file\n    s1 = inf.readToken();\n    s2 = inf.readToken();\n    virus = inf.readToken();\n\n    // Read and validate jury's answer\n    int jans = readAns(ans);\n    // Read and validate participant's answer\n    int pans = readAns(ouf);\n\n    // Compare\n    if (jans > pans)\n        quitf(_wa, \"jury's answer is better (length %d) than participant's answer (length %d)\",\n              jans, pans);\n    else if (jans == pans)\n        quitf(_ok, \"answers match with length %d\", pans);\n    else\n        quitf(_fail, \"participant's answer is longer (%d) than jury's answer (%d)\",\n              pans, jans);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // strings to output\n    string s1, s2, virus;\n\n    if (type == \"random\") {\n        // Generate s1 of length n\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        // Generate s2 of length m\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n        // Generate virus of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"same\") {\n        int len = min(n, m);\n        string common = \"\";\n        for (int i = 0; i < len; i++) {\n            common += (char)('A' + rnd.next(26));\n        }\n        s1 = common;\n        s2 = common;\n        // Adjust lengths of s1 and s2 if n and m are not equal\n        while ((int)s1.length() < n) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        while ((int)s2.length() < m) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n        // Generate virus of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"no_common\") {\n        // s1 uses letters 'A'-'M'\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(13));\n        }\n        // s2 uses letters 'N'-'Z'\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('N' + rnd.next(13));\n        }\n        // Generate virus of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"virus_not_in_strings\") {\n        // Generate s1 and s2 using letters 'A'-'Y' (excluding 'Z')\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(25)); // 'A' to 'Y'\n        }\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('A' + rnd.next(25));\n        }\n        // Virus uses 'Z's\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += 'Z';\n        }\n    } else if (type == \"only_virus_common\") {\n        // Generate virus of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n\n        // s1 uses letters from 'A'-'M' excluding virus letters\n        set<char> virus_letters(virus.begin(), virus.end());\n\n        vector<char> s1_letters;\n        for (char c = 'A'; c <= 'M'; c++) {\n            if (virus_letters.count(c) == 0) {\n                s1_letters.push_back(c);\n            }\n        }\n        // s2 uses letters from 'N'-'Z' excluding virus letters\n        vector<char> s2_letters;\n        for (char c = 'N'; c <= 'Z'; c++) {\n            if (virus_letters.count(c) == 0) {\n                s2_letters.push_back(c);\n            }\n        }\n\n        // Build s1\n        int positions_in_s1 = n - k;\n        s1 = virus;\n        // Insert other letters into s1\n        for (int i = 0; i < positions_in_s1; i++) {\n            s1 += s1_letters[rnd.next(s1_letters.size())];\n        }\n        // Shuffle s1\n        shuffle(s1.begin(), s1.end());\n\n        // Build s2\n        int positions_in_s2 = m - k;\n        s2 = virus;\n        // Insert other letters into s2\n        for (int i = 0; i < positions_in_s2; i++) {\n            s2 += s2_letters[rnd.next(s2_letters.size())];\n        }\n        // Shuffle s2\n        shuffle(s2.begin(), s2.end());\n    } else if (type == \"max_virus\") {\n        // virus length is k\n        if (k > 26) {\n            // We need to repeat letters since only 26 letters available\n            virus = \"\";\n            for (int i = 0; i < k; i++) {\n                virus += (char)('A' + rnd.next(26));\n            }\n        } else {\n            // Use all letters\n            vector<char> letters;\n            for (char c = 'A'; c <= 'Z'; c++) {\n                letters.push_back(c);\n            }\n            shuffle(letters.begin(), letters.end());\n            virus = \"\";\n            for (int i = 0; i < k; i++) {\n                virus += letters[i];\n            }\n        }\n        // Generate s1 and s2 randomly\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"no_valid_lcs\") {\n        // Generate s1 and s2 so that any common subsequence contains virus as a substring\n        // We can do this by setting s1 and s2 to be the virus repeated\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n        s1 = virus;\n        s2 = virus;\n        // Now we can append virus letters to s1 and s2 until they reach lengths n and m\n        while ((int)s1.length() < n) {\n            s1 += virus[rnd.next(virus.size())];\n        }\n        while ((int)s2.length() < m) {\n            s2 += virus[rnd.next(virus.size())];\n        }\n    } else if (type == \"best_subsequence_contains_virus\") {\n        // Generate s1 and s2 such that their LCS contains virus as a substring, but there's also a shorter LCS which avoids virus\n        // For simplicity, let's do the following:\n        // Let virus be of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n        // s1 = virus + random letters\n        s1 = virus;\n        int extra_s1 = n - k;\n        for (int i = 0; i < extra_s1; i++) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        // s2 = virus + random letters\n        s2 = virus;\n        int extra_s2 = m - k;\n        for (int i = 0; i < extra_s2; i++) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n        // Now shuffle s1 and s2, ensuring virus remains intact in both\n        // So we can generate positions for virus to be inserted\n        vector<int> positions_s1(n);\n        iota(positions_s1.begin(), positions_s1.end(), 0);\n        shuffle(positions_s1.begin(), positions_s1.end());\n        vector<int> virus_positions_s1(positions_s1.begin(), positions_s1.begin() + k);\n        sort(virus_positions_s1.begin(), virus_positions_s1.end());\n        string new_s1(n, ' ');\n        int idx_s1 = 0, idx_virus = 0, idx_extra = k;\n        for (int i = 0; i < n; i++) {\n            if (idx_virus < k && i == virus_positions_s1[idx_virus]) {\n                new_s1[i] = virus[idx_virus];\n                idx_virus++;\n            } else {\n                new_s1[i] = s1[idx_extra++];\n            }\n        }\n        s1 = new_s1;\n\n        vector<int> positions_s2(m);\n        iota(positions_s2.begin(), positions_s2.end(), 0);\n        shuffle(positions_s2.begin(), positions_s2.end());\n        vector<int> virus_positions_s2(positions_s2.begin(), positions_s2.begin() + k);\n        sort(virus_positions_s2.begin(), virus_positions_s2.end());\n        string new_s2(m, ' ');\n        int idx_s2 = 0;\n        idx_virus = 0;\n        idx_extra = k;\n        for (int i = 0; i < m; i++) {\n            if (idx_virus < k && i == virus_positions_s2[idx_virus]) {\n                new_s2[i] = virus[idx_virus];\n                idx_virus++;\n            } else {\n                new_s2[i] = s2[idx_extra++];\n            }\n        }\n        s2 = new_s2;\n\n    } else {\n        // Default to random\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n    }\n\n    // Output s1, s2, virus\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n    printf(\"%s\\n\", virus.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // strings to output\n    string s1, s2, virus;\n\n    if (type == \"random\") {\n        // Generate s1 of length n\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        // Generate s2 of length m\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n        // Generate virus of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"same\") {\n        int len = min(n, m);\n        string common = \"\";\n        for (int i = 0; i < len; i++) {\n            common += (char)('A' + rnd.next(26));\n        }\n        s1 = common;\n        s2 = common;\n        // Adjust lengths of s1 and s2 if n and m are not equal\n        while ((int)s1.length() < n) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        while ((int)s2.length() < m) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n        // Generate virus of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"no_common\") {\n        // s1 uses letters 'A'-'M'\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(13));\n        }\n        // s2 uses letters 'N'-'Z'\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('N' + rnd.next(13));\n        }\n        // Generate virus of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"virus_not_in_strings\") {\n        // Generate s1 and s2 using letters 'A'-'Y' (excluding 'Z')\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(25)); // 'A' to 'Y'\n        }\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('A' + rnd.next(25));\n        }\n        // Virus uses 'Z's\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += 'Z';\n        }\n    } else if (type == \"only_virus_common\") {\n        // Generate virus of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n\n        // s1 uses letters from 'A'-'M' excluding virus letters\n        set<char> virus_letters(virus.begin(), virus.end());\n\n        vector<char> s1_letters;\n        for (char c = 'A'; c <= 'M'; c++) {\n            if (virus_letters.count(c) == 0) {\n                s1_letters.push_back(c);\n            }\n        }\n        // s2 uses letters from 'N'-'Z' excluding virus letters\n        vector<char> s2_letters;\n        for (char c = 'N'; c <= 'Z'; c++) {\n            if (virus_letters.count(c) == 0) {\n                s2_letters.push_back(c);\n            }\n        }\n\n        // Build s1\n        int positions_in_s1 = n - k;\n        s1 = virus;\n        // Insert other letters into s1\n        for (int i = 0; i < positions_in_s1; i++) {\n            s1 += s1_letters[rnd.next(s1_letters.size())];\n        }\n        // Shuffle s1\n        shuffle(s1.begin(), s1.end());\n\n        // Build s2\n        int positions_in_s2 = m - k;\n        s2 = virus;\n        // Insert other letters into s2\n        for (int i = 0; i < positions_in_s2; i++) {\n            s2 += s2_letters[rnd.next(s2_letters.size())];\n        }\n        // Shuffle s2\n        shuffle(s2.begin(), s2.end());\n    } else if (type == \"max_virus\") {\n        // virus length is k\n        if (k > 26) {\n            // We need to repeat letters since only 26 letters available\n            virus = \"\";\n            for (int i = 0; i < k; i++) {\n                virus += (char)('A' + rnd.next(26));\n            }\n        } else {\n            // Use all letters\n            vector<char> letters;\n            for (char c = 'A'; c <= 'Z'; c++) {\n                letters.push_back(c);\n            }\n            shuffle(letters.begin(), letters.end());\n            virus = \"\";\n            for (int i = 0; i < k; i++) {\n                virus += letters[i];\n            }\n        }\n        // Generate s1 and s2 randomly\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"no_valid_lcs\") {\n        // Generate s1 and s2 so that any common subsequence contains virus as a substring\n        // We can do this by setting s1 and s2 to be the virus repeated\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n        s1 = virus;\n        s2 = virus;\n        // Now we can append virus letters to s1 and s2 until they reach lengths n and m\n        while ((int)s1.length() < n) {\n            s1 += virus[rnd.next(virus.size())];\n        }\n        while ((int)s2.length() < m) {\n            s2 += virus[rnd.next(virus.size())];\n        }\n    } else if (type == \"best_subsequence_contains_virus\") {\n        // Generate s1 and s2 such that their LCS contains virus as a substring, but there's also a shorter LCS which avoids virus\n        // For simplicity, let's do the following:\n        // Let virus be of length k\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n        // s1 = virus + random letters\n        s1 = virus;\n        int extra_s1 = n - k;\n        for (int i = 0; i < extra_s1; i++) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        // s2 = virus + random letters\n        s2 = virus;\n        int extra_s2 = m - k;\n        for (int i = 0; i < extra_s2; i++) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n        // Now shuffle s1 and s2, ensuring virus remains intact in both\n        // So we can generate positions for virus to be inserted\n        vector<int> positions_s1(n);\n        iota(positions_s1.begin(), positions_s1.end(), 0);\n        shuffle(positions_s1.begin(), positions_s1.end());\n        vector<int> virus_positions_s1(positions_s1.begin(), positions_s1.begin() + k);\n        sort(virus_positions_s1.begin(), virus_positions_s1.end());\n        string new_s1(n, ' ');\n        int idx_s1 = 0, idx_virus = 0, idx_extra = k;\n        for (int i = 0; i < n; i++) {\n            if (idx_virus < k && i == virus_positions_s1[idx_virus]) {\n                new_s1[i] = virus[idx_virus];\n                idx_virus++;\n            } else {\n                new_s1[i] = s1[idx_extra++];\n            }\n        }\n        s1 = new_s1;\n\n        vector<int> positions_s2(m);\n        iota(positions_s2.begin(), positions_s2.end(), 0);\n        shuffle(positions_s2.begin(), positions_s2.end());\n        vector<int> virus_positions_s2(positions_s2.begin(), positions_s2.begin() + k);\n        sort(virus_positions_s2.begin(), virus_positions_s2.end());\n        string new_s2(m, ' ');\n        int idx_s2 = 0;\n        idx_virus = 0;\n        idx_extra = k;\n        for (int i = 0; i < m; i++) {\n            if (idx_virus < k && i == virus_positions_s2[idx_virus]) {\n                new_s2[i] = virus[idx_virus];\n                idx_virus++;\n            } else {\n                new_s2[i] = s2[idx_extra++];\n            }\n        }\n        s2 = new_s2;\n\n    } else {\n        // Default to random\n        s1 = \"\";\n        for (int i = 0; i < n; i++) {\n            s1 += (char)('A' + rnd.next(26));\n        }\n        s2 = \"\";\n        for (int i = 0; i < m; i++) {\n            s2 += (char)('A' + rnd.next(26));\n        }\n        virus = \"\";\n        for (int i = 0; i < k; i++) {\n            virus += (char)('A' + rnd.next(26));\n        }\n    }\n\n    // Output s1, s2, virus\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n    printf(\"%s\\n\", virus.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -k 3 -type random\n./gen -n 50 -m 50 -k 25 -type random\n./gen -n 100 -m 100 -k 50 -type random\n\n./gen -n 5 -m 5 -k 3 -type same\n./gen -n 50 -m 50 -k 25 -type same\n./gen -n 100 -m 100 -k 50 -type same\n\n./gen -n 5 -m 5 -k 3 -type no_common\n./gen -n 50 -m 50 -k 25 -type no_common\n\n./gen -n 5 -m 5 -k 3 -type virus_not_in_strings\n./gen -n 50 -m 50 -k 10 -type virus_not_in_strings\n./gen -n 100 -m 100 -k 1 -type virus_not_in_strings\n./gen -n 100 -m 100 -k 5 -type virus_not_in_strings\n\n./gen -n 5 -m 5 -k 3 -type only_virus_common\n./gen -n 50 -m 50 -k 25 -type only_virus_common\n./gen -n 100 -m 100 -k 1 -type only_virus_common\n\n./gen -n 100 -m 100 -k 100 -type max_virus\n./gen -n 50 -m 50 -k 100 -type max_virus\n\n./gen -n 5 -m 5 -k 3 -type no_valid_lcs\n./gen -n 50 -m 50 -k 25 -type no_valid_lcs\n\n./gen -n 50 -m 50 -k 10 -type best_subsequence_contains_virus\n\n./gen -n 1 -m 1 -k 1 -type random\n\n./gen -n 100 -m 100 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:11:58.429647",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "347/E",
      "title": "E. Number Transformation II",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤  n ≤ 105). The second line contains n space-separated integers x1, x2, ..., xn (2 ≤  xi ≤ 109). The third line contains two integers a and b (0  ≤ b ≤  a ≤ 109, a - b ≤ 106).",
      "output_spec": "OutputPrint a single integer — the required minimum number of moves needed to transform number a into number b.",
      "sample_tests": "ExamplesInputCopy33 4 530 17OutputCopy6InputCopy35 6 71000 200OutputCopy206",
      "description": "E. Number Transformation II\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤  n ≤ 105). The second line contains n space-separated integers x1, x2, ..., xn (2 ≤  xi ≤ 109). The third line contains two integers a and b (0  ≤ b ≤  a ≤ 109, a - b ≤ 106).\n\nOutputPrint a single integer — the required minimum number of moves needed to transform number a into number b.\n\nInputCopy33 4 530 17OutputCopy6InputCopy35 6 71000 200OutputCopy206\n\nInputCopy33 4 530 17\n\nOutputCopy6\n\nInputCopy35 6 71000 200\n\nOutputCopy206",
      "solutions": [
        {
          "title": "Codeforces Round #201 - Codeforces",
          "content": "Hello everyone!Codeforces Round #201 is scheduled to take place at Friday, Sep. 20th at 19:30 MSK(23:30 CST)Setters are: CMHJT and me.Testers are: error202, havaliza and tourist.Thanks to MinakoKojima for her help in rewrite the statements into codeforces style, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.Special thanks to tourist and Gerald in giving advise about the problems so we could put them in a more proper order. 500 — 1000 — 1500 — 2000 — 2500.We are going to use standard score distribution in both divisions. The problems are not so hard, but you need more thinking rather than coding.Good luck!UPD1: Congratulations to the top 5 winners in each division!DivI1.cgy4ever2.rng_583.PavelKunyavskiy4.Egor5.liympandaDivII1.Thrax2.renannewbie3.socksister014.SJTU_WengJian5.cat_leopardUPD2: the editorial is published here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 909
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces",
          "content": "OverviewIn DIV 1, there are 4 interesting problems together with a normal one. We think it is reasonable because we can't have a round fullly with intelligence. Problem A, C have weak pretests while others intended to be strong. About more then 200 participants solve A in the early 45mins, then a few of them start from C while most of the other start from B. Problem B is a rather standard problem, but if you're unfamiliar with the algorithm, it can be very hard. Problem C is a more intersting problem. As the name implies, there was a similar version in the previous round before, but this time it has a brand new constrains.(So here we have a psychology experiment: could different constrains make people thinking in a slightly different way?ww)The standard solution of problem C is O((b - a) + nlogn). The first expected correct solution was written by zeliboba. http://codeforces.com/contest/346/submission/4512654After that, some people start to solve problem D. Problem D looks like a hard dp problem on a graph at the first glance, the key point is how to avoid the circle in the transfer equation. It turn out to be elegant after you could found a right order of the evaluation. Problem E is challenging which you need find a way to transform the original question into a smaller scale, and cut off many many corner cases ... And in the very end, you find a way like binary search to get O(logn) as the time complexity. No one manage to solve problem E during the contest, maybe Petr is the man who closest to it.The winner comes to cgy4ever, because he found the draw-black in his previous C submission during the very beginning even when there is nobody hack him! He resubmit it decisively and get back when finished problem D. After that, he use the same trick which made him failed before to hack others and got a handsomely rewards. The second place went to rng_58, because of the combination of decent speed in A, B, C, D.Problem B belongs to me, problem C belongs to CMHJT and others belong to UESTC_Nocturne. The illustrator of problem C is Chairman Miao(貓主席).EditorialProblem A. Alice and BobBrief description:Alice and Bob play a game, the rules are as follows: First, they will get a set of n distinct numbers. And then they take turns to do the following operations. During each operation, either Alice or Bob can choose two different numbers x and y from the set, as long as |x - y| is not in the set, then they add it to the set. The person who can not choose two numbers successfully will lose the game. The question is who will finally win the game if both of them do operations optimally. Remember that Alice always goes first.Analysis:First, no matter what happend, the number set we get at the very endding will be same all the time. Let's say d = gcd{xi}. Then the set in the endding will be some things like {d, 2d, 3d, ... max{xi}}. So there is always max{xi} / d — n rounds. And what we should do rest is to check the parity of this value.Problem B. Lucky Common SubsequenceBrief description:You have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.Analysis:This is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.When consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).Problem C. Number Transformation IIBrief description:You have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.Analysis:I bet there is a few people know the greedy method even if he/she have solved the early version before.Codeforces #153 Div 1. Problem C. Number TransformationLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].In the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.So the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLEProblem D. Robot ControlLet's dp from t to s.dp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vHere dp[u] means, the minimum number of orders mzry1992 needs to send in the worst case. The left-hand-side is sending order while the right-hand side is not. At the beginning, we have dp[t] = 1, and dp[s] will be the answer.We can see there is circular dependence in this equation, in this situation, one standard method is using Bellman-Ford algorithm to evaluate the dp function.But it is not appropriate for this problem.(In fact, we add a part of targeted datas in pretest, these datas are enough to block most of our Bellman-Ford algorithm, although there is still a few participator can get accepted by Bellman-Ford algorithm during the contest.Check rares.buhai's solutiondp[u] = min(min(dp[v]) + 1 , max(dp[v])) | u->vThe expected solution is evaluating the dp function as the increased value of dp[u] itself. Further analysis shows, wheather we decided sending order or not in u can be judged as the out-degree of u. while (!Q.empty()) {\n u = Q.front(), Q.pop_front()\n for each edge from v to u\n --out_degree[v]\n\tif (out_degree[v] == 0) {\n relax dp[v] by dp[u]\n if success, add v to the front of Q\n\t}\n\telse{\n\t relax dp[v] by dp[u] + 1\n\t if success, add v to the back of Q\n }\t\n }Check Ra16bit's solution to see how it works.Problem E. Doodle JumpBrief description:You have been give a, p, n, h (gcd(a, p) = 1), For each ai mod p, (i∈[1, n]), check weather the maximum distance in neighborhood after sorting is <= h. Analysis:Take a =5, p =23 for example ... Divided the numbers in group. 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 18We start a new group when the number > PWe found the difference between the elements of the first group is 5, The subsequent is filling some gap between the them ...After some observation we could found that we should only consider into one gap ...(e.g. [0, 5] or [15, 20] or [20, 25] ... ) 0 5 10 15 20\n2 7 12 17 22\n4 9 14 19\n1 6 11 16That says .. a =5, p =23 is roughly equal to some things in small scale?So let's check it in detail. Lemma 1. In any case, the gap after 20 won't better than any gap before it. 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16For example, in this case, the gap after 20 is: 20, 22 And it has 16 in [15, 17] but no 21. Is there any chance that [20, 23] is better than [15, 20]?No, that is because, when there is no 21, then (19+5)%23 = 1, go to next floor. and there is no corresponding gap after 20 ([22, 24]) for this gap ([17, 19])So we only need to consider [15, 20] ... and we found [15, 20] is roughly equal to [0, 5] e.g. : 15 20 17 19 16 18 \nequal: 0 5 2 4 1 3we say 'roughly' because we havn't check some boundary case like there is 3 but on 18 ... 0 5 10 15 20 \n2 7 12 17 22\n4 9 14 19\n1 6 11 16 21\n3 8 13 If it happend, we should remove the number 3. .. If we can remove the element 5, then we can from a=5, p=23 to a'=2, p'=5 ...(n' = an/p, a' = a-p%a, if there is 3 but no 18, n'=n'-1)The rest things is to discuss wheather 5 is necessary or not.Let's we have: 0 2 4\n1 3If the 2*n'<5, then there is only one floor, the answer is max(2, 5-2*n'). If there is more than one floor, we could conclude that 5 is useless.Proof: Elemets in 1st floor is: 0 a 2a 3a ...Let's say the maximum elements in 1st floor is x, then the minimum element in the 2nd floor is b0 = x+a-p, because b0 — a = x-p, so the difference between b0 and a is equal to the difference between x and p. That is, we can consider [b0, a] rather than [x, p], when there is a element insert in [b0, a], there must be some element insert in [x, p] in the same position.So we have have succeeded to transform our original problem into a small one. Of couse, this problem havn't been solved, we haven't consider the time complexity. Says a' = a — p%a, when p = a+1, then a' = a-1, but we have a equal to 10^9, it won't work.But, let's we have A1, A2, ... An ... and we subtract d from all of them, the answer won't be changed. So we can use p%a substitute for a-p%a, this is equivalent to we subtract %p% from all of them ...So we set a' = min(a-p%a, p%a), so a'<=a/2, therefore, the final time complexity is O(logn).You can check Petr 's solution for detail.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8903",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9075
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #201 - Codeforces - Code 1",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 2",
          "code": "The problems are not so hard, but you need more thinking rather then coding.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 3",
          "code": "(b - a + n) log n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 4",
          "code": "g 2*g 3*g ... MAX_NUMBER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 5",
          "code": "g =  gcd(a[1], a[2], ... a[n])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 6",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 - Codeforces - Code 7",
          "code": "ZZZZZRR\nZZZZZRR\nZR",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 1",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 2",
          "code": "while (!Q.empty()) {\n    u = Q.front(), Q.pop_front()\n    for each edge from v to u\n        --out_degree[v]\n\tif (out_degree[v] == 0) {\n           relax dp[v] by dp[u]\n           if success, add v to the front of Q\n\t}\n\telse{\n\t   relax dp[v] by dp[u] + 1\n\t   if success, add v to the back of Q\n        }\t\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 3",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 4",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13  18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 5",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 6",
          "code": "0  5  10  15  20\n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 7",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 8",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 9",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 10",
          "code": "e.g. :    15 20 17 19 16 18 \nequal:     0  5  2  4  1  3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 11",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 12",
          "code": "0  5  10  15  20 \n2  7  12  17  22\n4  9  14  19\n1  6  11  16  21\n3  8  13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 13",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 14",
          "code": "0 a 2a 3a ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 15",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 16",
          "code": "0) DP[i][j][0] means that finded LCS not ends on \"v\" or \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"a\")\n\n1) DP[i][j][1] means that finded LCS ends on \"v\", but not on \"vi\" or \"vir\" or \"viru\" or \"virus\". (example: \"av\")\n\n2) DP[i][j][2] means that finded LCS ends on \"vi\", but not on \"vir\" or \"viru\" or \"virus\". (example: \"avi\")\t\n\n3) DP[i][j][3] means that finded LCS ends on \"vir\", but not on \"viru\" or \"virus\". (example: \"avir\")\n\n4) DP[i][j][4] means that finded LCS ends on \"viru\", but not on \"virus\". (example: \"aviru\")\n\nWe take \"longest suffix of LCS that equal prefix of virus\", because virus could be: \"vvvvv\" or \"ababv\" (and infinite others)\n  If LCS = \"avvv\" - it ends on \"v\",\"vv\",\"vvv\". (virus = \"vvvvv\")\n  If LCS = \"aabab\" - it ends on \"ab\" and \"abab\". (virus = \"ababv\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #201 Editorial - Codeforces - Code 17",
          "code": "a = a - a%x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8903",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> xi = inf.readInts(n, 2, 1000000000);\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n\n    ensuref(b <= a, \"b(%d) must be less than or equal to a(%d)\", b, a);\n    ensuref(a - b <= 1000000, \"Difference a(%d) - b(%d) must be less than or equal to 1e6\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> xi = inf.readInts(n, 2, 1000000000);\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n\n    ensuref(b <= a, \"b(%d) must be less than or equal to a(%d)\", b, a);\n    ensuref(a - b <= 1000000, \"Difference a(%d) - b(%d) must be less than or equal to 1e6\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> xi = inf.readInts(n, 2, 1000000000);\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n\n    ensuref(b <= a, \"b(%d) must be less than or equal to a(%d)\", b, a);\n    ensuref(a - b <= 1000000, \"Difference a(%d) - b(%d) must be less than or equal to 1e6\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> get_divisors(int x) {\n    vector<int> divisors;\n    for(int i = 1; i * 1LL * i <= x; ++i) {\n        if (x % i == 0) {\n            if (i >= 2 && i <= 1000000000) divisors.push_back(i);\n            int j = x / i;\n            if (j != i && j >=2 && j<= 1000000000) divisors.push_back(j);\n        }\n    }\n    return divisors;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 100000);\n    int d = opt<int>(\"d\", 1000000);\n    int amax = opt<int>(\"amax\", 1000000000);\n    string xi_type = opt<string>(\"xi_type\", \"random\");\n\n    // Generate 'a' and 'b'\n    int min_a = d;\n    int max_a = min(amax, 1000000000);\n    int a = rnd.next(min_a, max_a);\n    int b = a - d;\n\n    assert(0 <= b && b <= a && a <= 1000000000 && a - b == d);\n\n    vector<int> xi(n);\n\n    if (xi_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(2, 1000000000);\n        }\n    } else if (xi_type == \"min\") {\n        // All xi = 2\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 2;\n        }\n    } else if (xi_type == \"max\") {\n        // All xi = 1e9\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1000000000;\n        }\n    } else if (xi_type == \"divides_a\") {\n        // xi divides 'a'\n        vector<int> divisors = get_divisors(a);\n        if (divisors.empty()) {\n            xi[0] = 2;\n            for (int i = 1; i < n; ++i) {\n                xi[i] = rnd.next(2, 1000000000);\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                xi[i] = divisors[rnd.next(divisors.size())];\n            }\n        }\n    } else if (xi_type == \"divides_aplus1\") {\n        // xi divides 'a + 1'\n        vector<int> divisors = get_divisors(a + 1);\n        if (divisors.empty()) {\n            xi[0] = 2;\n            for (int i = 1; i < n; ++i) {\n                xi[i] = rnd.next(2, 1000000000);\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                xi[i] = divisors[rnd.next(divisors.size())];\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(2, 1000000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> get_divisors(int x) {\n    vector<int> divisors;\n    for(int i = 1; i * 1LL * i <= x; ++i) {\n        if (x % i == 0) {\n            if (i >= 2 && i <= 1000000000) divisors.push_back(i);\n            int j = x / i;\n            if (j != i && j >=2 && j<= 1000000000) divisors.push_back(j);\n        }\n    }\n    return divisors;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 100000);\n    int d = opt<int>(\"d\", 1000000);\n    int amax = opt<int>(\"amax\", 1000000000);\n    string xi_type = opt<string>(\"xi_type\", \"random\");\n\n    // Generate 'a' and 'b'\n    int min_a = d;\n    int max_a = min(amax, 1000000000);\n    int a = rnd.next(min_a, max_a);\n    int b = a - d;\n\n    assert(0 <= b && b <= a && a <= 1000000000 && a - b == d);\n\n    vector<int> xi(n);\n\n    if (xi_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(2, 1000000000);\n        }\n    } else if (xi_type == \"min\") {\n        // All xi = 2\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 2;\n        }\n    } else if (xi_type == \"max\") {\n        // All xi = 1e9\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1000000000;\n        }\n    } else if (xi_type == \"divides_a\") {\n        // xi divides 'a'\n        vector<int> divisors = get_divisors(a);\n        if (divisors.empty()) {\n            xi[0] = 2;\n            for (int i = 1; i < n; ++i) {\n                xi[i] = rnd.next(2, 1000000000);\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                xi[i] = divisors[rnd.next(divisors.size())];\n            }\n        }\n    } else if (xi_type == \"divides_aplus1\") {\n        // xi divides 'a + 1'\n        vector<int> divisors = get_divisors(a + 1);\n        if (divisors.empty()) {\n            xi[0] = 2;\n            for (int i = 1; i < n; ++i) {\n                xi[i] = rnd.next(2, 1000000000);\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                xi[i] = divisors[rnd.next(divisors.size())];\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(2, 1000000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d 0 -amax 1 -xi_type min\n./gen -n 1 -d 0 -amax 1 -xi_type max\n\n./gen -n 1 -d 0 -xi_type random\n./gen -n 1 -d 1 -xi_type random\n\n./gen -n 1 -d 1000000 -xi_type random\n\n./gen -n 100000 -d 0 -xi_type min\n./gen -n 100000 -d 0 -xi_type max\n\n./gen -n 100000 -d 1000000 -xi_type random\n\n./gen -n 100000 -d 1000000 -xi_type divides_a\n\n./gen -n 100000 -d 1000000 -xi_type divides_aplus1\n\n./gen -n 100000 -d 1000000 -xi_type min\n\n./gen -n 100000 -d 1000000 -xi_type max\n\n./gen -n 100000 -d 123456 -xi_type random\n\n./gen -n 100000 -d 999999 -xi_type divides_a\n\n./gen -n 100000 -d 500000 -amax 500000000 -xi_type random\n\n./gen -n 50000 -d 1000000 -amax 1000000000 -xi_type divides_aplus1\n\n./gen -n 100000 -d 0 -amax 1000000000 -xi_type random\n\n./gen -n 100000 -d 1 -amax 1000000000 -xi_type random\n\n./gen -n 100000 -d 1000 -amax 1000000000 -xi_type random\n\n./gen -n 100000 -d 100 -amax 1000000000 -xi_type random\n\n./gen -n 50000 -d 500000 -xi_type min\n\n./gen -n 50000 -d 500000 -xi_type max\n\n./gen -n 1000 -d 500000 -xi_type random\n\n./gen -n 1000 -d 500000 -xi_type divides_a\n\n./gen -n 1000 -d 500000 -xi_type divides_aplus1\n\n./gen -n 50000 -d 500000 -xi_type divides_a\n\n./gen -n 50000 -d 500000 -xi_type divides_aplus1\n\n./gen -n 100000 -d 0 -xi_type random\n\n./gen -n 100000 -d 1000000 -xi_type random\n\n./gen -n 100000 -d 1000000 -xi_type divides_a\n\n./gen -n 100000 -d 1000000 -xi_type divides_aplus1\n\n./gen -n 2 -d 1 -xi_type random\n\n./gen -n 99999 -d 500000 -xi_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:00.467258",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "348/A",
      "title": "A. Mafia",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (3 ≤ n ≤ 105). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the i-th number in the list is the number of rounds the i-th person wants to play.",
      "output_spec": "OutputIn a single line print a single integer — the minimum number of game rounds the friends need to let the i-th person play at least ai rounds.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy33 2 2OutputCopy4InputCopy42 2 2 2OutputCopy3",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (3 ≤ n ≤ 105). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the i-th number in the list is the number of rounds the i-th person wants to play.\n\nOutputIn a single line print a single integer — the minimum number of game rounds the friends need to let the i-th person play at least ai rounds.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy33 2 2OutputCopy4InputCopy42 2 2 2OutputCopy3\n\nInputCopy33 2 2\n\nOutputCopy4\n\nInputCopy42 2 2 2\n\nOutputCopy3\n\nNoteYou don't need to know the rules of \"Mafia\" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #202 will take place today, September 27 at 19:30 MSK.The idea behind the round was born when my friends and I were interning at Facebook this summer. This round probably has the highest number of authors for a Codeforces round to date. The authors of the problems are Azizkhan Almakhan azizkhan, Michael Kolupaev al13n, Filip Hlasek fhlasek, Ivan Mandura budabudimir and myself, Igor Demidov caustique.Maxim Korystov dark_ai, Alexander Fedulin Jughead and Ibragim Ismailov ibra, Vladimir Chalyshev cmd and Sergey Sklyanichenko Sklyack helped us with preparation of the round.The ideas behind the 2 problems were inspired by Anton Ermilov ant.ermilov and Dmitry Krasnov navi-spb.Testers of the round are Alexey Safronov yarrr and Alexey Shmelev ashmelev.I would also like to thank Gerald Agapov Gerald for his help in preparing the contest.I hope you find problems interesting and diverse. I'm sure that everyone will find the problem to their liking.Scores are as usual 500-1000-1500-2000-2500.Good luck and have fun!Congratulations to the winners!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Attention! Editorial for all problems is available!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Editorial for Codeforces Round #202 - Codeforces",
          "content": "349A - Cinema LineIn the problem you need to decide whether cashier can give a change to all customers if the price of the ticket is 25 rubles and there's 3 kinds of bills: 25, 50 and 100 rubles. There's no money in the ticket office in the beginning.Let's consider 3 cases. Customer has 25 rubles hence he doesn't need a change. Customer has 50 rubles hence we have to give him 25 rubles back. Customer has 100 rubles hence we need to give him 75 rubles back. It can be done in 2 ways. 75=25+50 и 75=25+25+25. Notice that it's always worth to try 25+50 first and then 25+25+25. It's true because bills of 25 rubles can be used both to give change for 50 and 100 rubles and bills of 50 rubles can be used only to give change for 100 rubles so we need to save as much 25 ruble bills as possible. The solution is to keep track of the number of 25 and 50 ruble bills and act greedily when giving change to 100 rubles — try 25+50 first and then 25+25+25.349B - Color the FenceIn the problem you're asked to write the largest possible number given number of paint that you have and number of paint that you need to write each digit.Longer number means larger number so it's worth to write the longest possible number. Because of that we choose the largest digit among those that require the least number of paint. Let the number of paint for that digit d be equal to x, and we have v liters of paint total. Then we can write number of the length .Now we know the length of the number, let it be len. Write down temporary result – string of length len, consisting of digits d. We have supply of v–len·x liters of paint. In order to enhance the answer, we can try to update the number from the beginning and swap each digit with the maximal possible. It's true because numbers of the equal length are compared in the highest digits first. Among digits that are greater than current we choose one that we have enough paint for and then update answer and current number of paint.If the length of the answer is 0 then you need to output -1.348A - MafiaIn the problem you need to find out how many games you need to play in order to make all people happy. It means that each of them played as many games as he wanted.Let the answer be x games. Notice that max(a1, a2, …, an) ≤ x. Then i-th player can be game supervisor in x–ai games. If we sum up we get — it's the number of games in which players are ready to be supervisor. This number must be greater or equal to x — our answer. Don't forget about that condition: max(a1, a2, …, an) ≤ x.348B - Apple TreeIn the problem you need to find out minimal number of apples that you need to remove in order to make tree balanced.Notice, that if we know the value in the root then we know values in all other vertices. The value in the leaf is equal to the value in the root divided to the product of the powers of all vertices on the path between root and leaf.For every vertex let's calculate di — minimal number in that vertex (not zero) in order to make tree balanced. For leaves di = 1, for all other vertices di is equal to k·lcm(dj1, dj2, ..., djk), where j1, j2, ..., jk — sons of the vertex i. Let's calculate si — sum in the subtree of the vertex i. All that can be done using one depth first search from the root of the tree.Using second depth first search one can calculate for every vertex maximal number that we can write in it and satisfty all conditions. More precisely, given vertex i and k of its sons j1, j2, ..., jk. Then if m = min(sj1, sj2, ..., sjk) and — minimal number, that we can write to the sons of vertex i, then it's worth to write numbers to the sons of vertex i. Remains we add to the answer.348C - Subset SumsThis problem is about data structures.First step of the solution is to divide sets to heavy and light. Light ones are those that contains less than elements. All other sets are heavy.Key observation is that every light set contains less than elements and number of heavy sets doesn't exceed because we have upper bound for sum of the sizes of all sets.In order to effectively answer queries, for every set (both light and heavy) we calculate size of the intersection of this set and each heavy set. It can be done with time and memory . For every heavy set we create boolean array of size O(n). In i-th cell of this array we store how many elements i in given set. Then for each element and each heavy set we can check for O(1) time whether element is in the set.Now let's consider 4 possible cases: Add to the light set. Traverse all numbers in the set and add the value from the query to each of them. Then traverse all heavy sets and add (size of intersection * the value from the query). Time is . Add to the heavy set. Just update the counter for the heavy set. Time is O(1). Answer to the query for the light set. Traverse all numbers in the set and add values to the answer. Then traverse all heavy sets and add to the answer (answer for this heavy set * size of intersection with the set in the query). Time is . Answer to the query for the heavy set. Take already calculated answer, then traverse all heavy sets and add (answer for this heavy set * size of intersection with the set in the query). Time is . We have O(n) queries so total time is .348D - TurtlesIn the problem you're asked to find the number of pairs of non-intersecting paths between left upper and right lower corners of the grid. You can use following lemma for that. Thanks to rng_58 for the link. More precisely, considering our problem, this lemma states that given sets of initial A = {a1, a2} and final B = {b1, b2} points, the answer is equal to the following determinant: where f(x, y) — is equal to the number of paths from point x to point y. You can calculate this function using dynamic programming.Finally we need to decide what sets of initial and final points we choose. You can take A = {(0, 1), (1, 0)} and B = {(n - 2, m - 1), (n - 1, m - 2)} in order to make paths non-intersecting even in 2 points.348E - PilgrimsLet’s build a simple solution at first and then we will try to improve it to solve problem more effectively given the constraints.For every vertex let’s find the list of the farthest vertices. Let’s find vertices on the intersection of the paths between current vertex and each vertex from the list that don’t contain monasteries. If we remove any of these vertices then every vertex from the list is unreachable from the current monastery. For every vertex from the intersection increment the counter. Then the answer for the problem is the maximum among all counters and the number of such maxima.Let’s solve the problem more effectively using the same idea. Let’s make the tree with root. For every vertex we will find the list of the farthest vertices only in the subtree. While traversing the tree using depth first search we return the largest depth in the subtree and the number of the vertex where it was reached. Among all of the sons of the current vertex we choose the maximum of depths. If maximum is reached one time then we return the same answer that was returned from the son. If the answer was reached more than one time then we return the number of the current vertex. Essentially, we find LCA of the farthest vertices according to the current vertex. Before quitting the vertex we increment the values on the segment between current vertex and found LCA. One can use Eulerian tour and segment tree for adding on the segment.Finally, the last stage of solving the problem – to solve it for the case when the farthest vertex is not in the subtree of the current vertex. For solving of that subproblem we use the same idea that was used in the problem of the finding the maximal path in the tree. For every vertex we keep 3 maximums – 3 farthest vertices in the subtree. When we go down to the subtree, we pass 2 remaining maximums too. In that way, when we’re in any vertex, we can decide whether there’s a path not in the subtree (it means, going up) of the same or larger length. If there’re 2 paths of the same length in the subtree and not in the subtree, it means that for the pilgrim from the current monastery there’s always a path no matter what town was destroyed. If one of the quantities is larger then we choose the segment in Eulerian tour and increment the value on the segment. The case where there’s several paths (at least 2) out of the subtree of the same maximal length, is the same with the case in the subtree.LCA and segment tree can be solved effectively in O(logN) time per query so the total memory and time is O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 348\\s*A"
          },
          "content_length": 8548
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    long long min_ai = opt<long long>(\"min_ai\", 1);\n    long long max_ai = opt<long long>(\"max_ai\", 1000000000); // 1e9\n\n    vector<long long> a(n);\n\n    if (type == \"all_same\") {\n        // All ai are the same value\n        long long ai_value = opt<long long>(\"value\", max_ai); // default to max_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = ai_value;\n        }\n    } else if (type == \"max_ai\") {\n        // One ai is maximum, rest are min_ai\n        int pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai;\n        }\n        a[pos] = max_ai;\n    } else if (type == \"min_ai\") {\n        // All ai are min_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai;\n        }\n    } else if (type == \"one_large_rest_small\") {\n        // One ai is large, rest are small\n        int pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai;\n        }\n        a[pos] = max_ai;\n    } else if (type == \"increasing\") {\n        // ai increase from min_ai to max_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai + (long long)(max_ai - min_ai) * i / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        // ai decrease from max_ai to min_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_ai - (long long)(max_ai - min_ai) * i / (n - 1);\n        }\n    } else {\n        // Random ai between min_ai and max_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(min_ai, max_ai);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    long long min_ai = opt<long long>(\"min_ai\", 1);\n    long long max_ai = opt<long long>(\"max_ai\", 1000000000); // 1e9\n\n    vector<long long> a(n);\n\n    if (type == \"all_same\") {\n        // All ai are the same value\n        long long ai_value = opt<long long>(\"value\", max_ai); // default to max_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = ai_value;\n        }\n    } else if (type == \"max_ai\") {\n        // One ai is maximum, rest are min_ai\n        int pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai;\n        }\n        a[pos] = max_ai;\n    } else if (type == \"min_ai\") {\n        // All ai are min_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai;\n        }\n    } else if (type == \"one_large_rest_small\") {\n        // One ai is large, rest are small\n        int pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai;\n        }\n        a[pos] = max_ai;\n    } else if (type == \"increasing\") {\n        // ai increase from min_ai to max_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai + (long long)(max_ai - min_ai) * i / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        // ai decrease from max_ai to min_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_ai - (long long)(max_ai - min_ai) * i / (n - 1);\n        }\n    } else {\n        // Random ai between min_ai and max_ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(min_ai, max_ai);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type min_ai\n./gen -n 3 -type max_ai\n./gen -n 3 -type all_same -value 2\n./gen -n 3 -type one_large_rest_small\n./gen -n 3 -type random\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n\n./gen -n 10 -type min_ai\n./gen -n 10 -type max_ai\n./gen -n 10 -type all_same -value 5\n./gen -n 10 -type one_large_rest_small\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n\n./gen -n 100 -type min_ai\n./gen -n 100 -type max_ai\n./gen -n 100 -type all_same -value 1000000000\n./gen -n 100 -type one_large_rest_small\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n\n./gen -n 1000 -type min_ai\n./gen -n 1000 -type max_ai\n./gen -n 1000 -type all_same -value 100\n./gen -n 1000 -type one_large_rest_small\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n\n./gen -n 100000 -type min_ai\n./gen -n 100000 -type max_ai\n./gen -n 100000 -type all_same -value 1000000000\n./gen -n 100000 -type one_large_rest_small\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:02.140153",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "348/B",
      "title": "B. Яблоня",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (2 ≤ n ≤ 105) — количество вершин в дереве. В следующей строке записаны n целых чисел a1, a2, ..., an (0 ≤ ai ≤ 108), где ai обозначает количество яблок в вершине с номером i. Гарантируется, что количество яблок в вершинах, не являющихся листьями, равно нулю.Затем следует n - 1 строк, описывающих ребра дерева. В каждой строке записана пара целых чисел xi, yi (1 ≤ xi, yi ≤ n, xi ≠ yi) — номера вершин, соединенных ребром дерева.Вершины дерева пронумерованы от 1 до n, а вершина с номером 1 является корнем дерева.",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимальное количество яблок, которое нужно удалить, чтобы сбалансировать дерево.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать60 0 12 13 5 61 21 31 42 52 6Выходные данныеСкопировать6",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (2 ≤ n ≤ 105) — количество вершин в дереве. В следующей строке записаны n целых чисел a1, a2, ..., an (0 ≤ ai ≤ 108), где ai обозначает количество яблок в вершине с номером i. Гарантируется, что количество яблок в вершинах, не являющихся листьями, равно нулю.Затем следует n - 1 строк, описывающих ребра дерева. В каждой строке записана пара целых чисел xi, yi (1 ≤ xi, yi ≤ n, xi ≠ yi) — номера вершин, соединенных ребром дерева.Вершины дерева пронумерованы от 1 до n, а вершина с номером 1 является корнем дерева.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимальное количество яблок, которое нужно удалить, чтобы сбалансировать дерево.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать60 0 12 13 5 61 21 31 42 52 6Выходные данныеСкопировать6\n\nВходные данныеСкопировать60 0 12 13 5 61 21 31 42 52 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Привет, Codeforces!Сегодня, 27 сентября в 19:30 МСК, состоится Codeforces Round #202.Идея раунда зародилась у меня и моих друзей, когда мы стажировались в Facebook этим летом. Возможно, у этого раунда рекордное для Codeforces количество авторов. Авторами задач стали Азизхан Алмахан azizkhan, Михаил Колупаев al13n, Филип Хласек fhlasek, Иван Мандура budabudimir и я, Игорь Демидов caustique.В подготовке раунда нам помогали Максим Корыстов dark_ai, Александр Федулин Jughead, Ибрагим Исмаилов ibra, Владимир Чалышев cmd и Сергей Скляниченко Sklyack.Идеи 2 задач мне подали Антон Ермилов ant.ermilov и Дмитрий Краснов navi-spb.Тестировали раунд Алексей Сафронов yarrr и Алексей Шмелев ashmelev.Также я хотел бы поблагодарить Геральда Агапова Gerald за помощь в подготовке контеста.Надеюсь, задачи Вам покажутся разнообразными и интересными. Уверен, что каждый найдет себе задачу по вкусу.Разбалловка стандартная 500-1000-1500-2000-2500.Желаю удачи и удовольствия от решения задач!Поздравляем победителей!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Внимание! Появился разбор всех задач на обоих языках!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1183
        },
        {
          "title": "Разбор задач Codeforces Round #202 - Codeforces",
          "content": "349A - Очередь в киноВ задаче требовалось выяснить, может ли кассир выдать сдачу всем посетителям кинотеатра, если билет стоит 25 рублей, у посетителей купюры номиналом 25, 50 и 100 и в кассе изначально нет денег.Рассмотрим 3 различных случая. Если у посетителя 25 рублей, то сдачу ему давать не нужно. Если у посетителя 50 рублей, то мы должны дать ему 25 рублей сдачи. Если у посетителя 100 рублей, то мы должны дать ему 75 рублей сдачи. Это можно сделать двумя способами. 75=25+50 и 75=25+25+25. Заметим, что всегда выгодно попробовать сначала первый способ, а потом второй. Это верно потому, что купюры номиналом 25 рублей могут быть использован как для выдачи сдачи на 50 рублей, так и на 100 рублей, а сами купюры номиналом 50 рублей могут использоваться только для выдачи сдачи на 100 рублей. Таким образом решение – поддерживать количество купюр номиналом 25 и 50 рублей и при выдаче сдачи на 100 рублей действовать жадно – сначала пробовать выдать 25+50 рублей, а иначе 25+25+25 рублей.349B - Раскраска забораВ задаче требовалось выяснить наибольшее число, которое можно написать, используя заданное количество краски, если на каждую цифру тратится также известное количество краски.Поскольку чем длиннее число, тем оно больше, нам выгодно написать число наибольшей длины. Для этого выберем цифру, на которую нужно меньше всего краски. Пусть количество краски для написания этой цифры d равно x, а всего у нас есть v литров краски. Тогда мы можем написать число длины .Таким образом мы выяснили длину числа, пусть она равна len. Запишем промежуточный результат – строку длины len, состоящую из цифр d. У нас в запасе еще осталось v–len·x краски. Чтобы улучшить ответ, будем идти от начала числа и пробовать заменить каждую цифру на максимально возможную. Это верно потому, что числа одинаковой длины сравниваются сначала по старшим разрядам. Среди цифр больше текущей выбираем максимальную среди тех, на которую хватает краски, и обновляем текущее количество краски и ответ.Если ответ длины 0, то нужно вывести -1.348A - МафияВ задаче требовалось определить, сколько игр нужно сыграть, чтобы все игроки остались довольны и сыграли как минимум столько игр, сколько они хотят.Пусть ответ – это x игр. Заметим, что max(a1, a2, …, an) ≤ x. Тогда i-ый игрок может в x–ai играх быть ведущим. Если просуммировать по всем игрокам, то получим — это количество игр, в которых игроки согласны быть ведущими. Это число должно быть не меньше x — нашего ответа. Также следует не забыть требование, что max(a1, a2, …, an) ≤ x.348B - ЯблоняВ задаче требовалось выяснить, какое минимальное количество яблок нужно удалить, чтобы сделать дерево сбалансированным.Заметим, что если мы знаем значение в корне, то знаем значения во всех остальных вершинах. Значение в листе равняется значению в корне, поделенному на произведение степеней вершин на пути от корня до листа.Для каждой вершины посчитаем величину di — какое минимальное число (не ноль) в ней должно быть записано, чтобы дерево по-прежнему могло быть сбалансированным. Для листьев di = 1, для остальных вершин di равен k·lcm(dj1, dj2, ..., djk), где j1, j2, ..., jk — сыновья вершины i. Также посчитаем величину si — сумму в поддереве вершины i. Все это можно сделать за один обход в глубину из корня дерева.Вторым обходом в глубину мы можем посчитать для каждой вершины максимальное число, которое мы в нее можем записать, так чтобы удовлетворить ограничениям. А именно, пусть дана вершина i и k ее сыновей j1, j2, ..., jk. Тогда если m = min(sj1, sj2, ..., sjk), а — минимальное число, которое мы можем записать в сыновей вершины i, нам выгодно записать в сыновей вершины i числа . Остатки, а именно , добавим к ответу.348C - Суммы подмножествВ этой задаче на структуры данных требовалось использовать корневую эвристику или, по-другому, sqrt-декомпозицию.Первый шаг решения состоял в том, чтобы разделить множества на легкие и тяжелые. Легкими назовем множества, которые содержат меньше элементов, а тяжелыми все остальные.Ключевое наблюдение. В любом легком множестве меньше элементов, а количество тяжелых множеств также не превосходит , так как есть ограничение на сумму размеров множеств.Чтобы эффективно отвечать на запросы, для каждого множества (как легкого, так и тяжелого) посчитаем размеры его пересечения со всеми тяжелыми множествами. Это можно сделать за время и память . Для каждого тяжелого множества создадим булевский массив размера O(n), в i-ой ячейке которого будем хранить, сколько элементов i в этом множестве. Затем для каждого элемента и каждого тяжелого множества будем за O(1) проверять, содержится ли элемент в тяжелом множестве.Теперь рассмотрим 4 возможных запроса: Добавление к легкому множеству. Пройдем по всем числам множества и к каждому добавим нужное значение. Дальше пройдем по всем тяжелым множествам и к каждому добавим (размер пересечения * значение в запросе). Время работы . Добавление к тяжелому множеству. Просто увеличим счетчик для данного тяжелого множества на значение в запросе. Время работы O(1). Ответ на запрос для легкого множества. Проходим по всем числам, добавляем значения к ответу. Затем проходим по всем тяжелым множествам и добавляем к ответу (добавление для данного тяжелого множества * размер пересечения со множеством в запросе). Время работы . Ответ на запрос для тяжелого множества. Берем уже посчитанный ответ, затем проходим по тяжелым множествам и добавляем (добавление для данного тяжелого множества * размер пересечения со множеством в запросе). Время работы . Итого, если у нас O(n) запросов, то суммарное время работы .348D - ЧерепашкиВ задаче требовалось найти количество пар непересекающихся путей из левого верхнего в правый нижний угол таблицы. Для этого можно воспользоваться следующей леммой. Спасибо rng_58 за ссылку. А именно, если переформулировать применительно к нашему случаю, то лемма утверждает, что если есть множества начальных A = {a1, a2} и конечных B = {b1, b2} точек, то ответ можно посчитать, как следующий определитель: где f(x, y) — количество путей из точки x в точку y. Эту величину уже можно посчитать квадратной динамикой.Наконец, заметим, что для того, чтобы свести исходную задачу к этой, нам нужно сделать пути, которые не имеют совсем совпадающих точек — в исходной задаче разрешаются пересечения в первой и последней точках пути. Для этого в качестве множеств A и B мы можем взять точки A = {(0, 1), (1, 0)} и B = {(n - 2, m - 1), (n - 1, m - 2)}348E - ПилигримыДавайте сначала построим простое решение этой задачи, а затем попробуем решить ее эффективно, учитывая данные ограничения.Для каждой вершины найдем список наиболее удаленных вершин. Найдем вершины на пересечении путей от текущей вершины до каждой вершины из списка, в которых нет монастырей. Если мы удалим любую из этих вершин, то каждая вершина из списка будет недостижима из текущего монастыря. У каждой вершины из этого пересечения увеличим счетчик на единицу. Тогда ответ на задачу – максимум из счетчиков для всех вершин и количество таких максимумов.Теперь решим задачу более эффективно, но используя ту же идею. Подвесим дерево за корень. Будем для каждой вершины искать список наиболее удаленных вершин только в ее поддереве. При обходе дерева в глубину из каждой вершины возвращаем наибольшую глубину в поддереве и номер вершины, на которой он достигается. Среди всех сыновей вершины выберем максимум из глубин. Если максимум достигается один раз, то вернем из текущей вершины тот же ответ, что был возвращен из сына. Если максимум достигается более одного раза, то вернем из текущей вершины номер текущей вершины. По сути, таким образом мы находим LCA всех наиболее удаленных от текущей вершины вершин. Перед выходом из вершины прибавляем единицу на отрезке от текущей вершины до найденного LCA. Это можно сделать, если хранить эйлеров обход графа и использовать дерево отрезков для прибавления на отрезке.Наконец, последний этап решения задачи – решить ее для случая, когда наиболее удаленная вершина или их список находятся необязательно в поддереве текущей вершины. Для решения этой подзадачи используем ту же идею, которая используется при нахождении максимального по длине пути в дереве. Для каждой вершины будем хранить 3 максимума – 3 наиболее удаленные вершины в ее поддереве. Когда мы спускаемся в какое-то поддерево, то передаем заодно и 2 оставшихся максимума. Таким образом, находясь в любой вершине, мы можем решить, существует ли путь не в поддереве (то есть уходящий наверх) такой же или большей длины. Если в поддереве и вне его пути одинаковой длины, то это означает, что для пилигрима из текущего монастыря всегда найдется хотя бы один путь, какой бы город не удалили. Если одна из величин больше, то мы выбираем нужный отрезок в эйлеровом обходе дерева и увеличиваем на нем значение на единицу. Случай, когда есть несколько путей (то есть хотя бы 2) вне поддерева одинаковой максимальной длины, обрабатывается аналогично такому же случаю в поддереве.Поскольку дерево отрезков может отвечать на запрос за O(logN) времени, а задачу LCA можно эффективно решить методом двоичного подъема за то же время, то затраты времени и памяти равны O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 348\\s*B"
          },
          "content_length": 9089
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\"); // n between 2 and 1e5\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\"); // Read n integers a_i between 0 and 1e8\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1); // Adjacency list (1-indexed)\n    vector<int> parent(n + 1);\n    iota(parent.begin(), parent.end(), 0); // Initialize for Union-Find\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        ensuref(x != y, \"Graph contains a cycle between vertex %d and %d\", x, y);\n        parent[y] = x;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops allowed (%d == %d)\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        unite(u, v); // Union-Find to check for cycles\n    }\n\n    // Check that the graph is connected\n    int root_parent = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root_parent, \"Graph is not connected at vertex %d\", i);\n    }\n\n    // Identify internal nodes and ensure their a_i is zero\n    vector<int> degree(n + 1);\n    for (int u = 1; u <= n; ++u) {\n        degree[u] = adj[u].size();\n    }\n\n    for (int u = 1; u <= n; ++u) {\n        if (u == 1 || degree[u] > 1) { // Internal node\n            ensuref(a[u - 1] == 0, \"Non-leaf vertex %d must have a_i == 0\", u);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\"); // n between 2 and 1e5\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\"); // Read n integers a_i between 0 and 1e8\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1); // Adjacency list (1-indexed)\n    vector<int> parent(n + 1);\n    iota(parent.begin(), parent.end(), 0); // Initialize for Union-Find\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        ensuref(x != y, \"Graph contains a cycle between vertex %d and %d\", x, y);\n        parent[y] = x;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops allowed (%d == %d)\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        unite(u, v); // Union-Find to check for cycles\n    }\n\n    // Check that the graph is connected\n    int root_parent = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root_parent, \"Graph is not connected at vertex %d\", i);\n    }\n\n    // Identify internal nodes and ensure their a_i is zero\n    vector<int> degree(n + 1);\n    for (int u = 1; u <= n; ++u) {\n        degree[u] = adj[u].size();\n    }\n\n    for (int u = 1; u <= n; ++u) {\n        if (u == 1 || degree[u] > 1) { // Internal node\n            ensuref(a[u - 1] == 0, \"Non-leaf vertex %d must have a_i == 0\", u);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\"); // n between 2 and 1e5\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\"); // Read n integers a_i between 0 and 1e8\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1); // Adjacency list (1-indexed)\n    vector<int> parent(n + 1);\n    iota(parent.begin(), parent.end(), 0); // Initialize for Union-Find\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        ensuref(x != y, \"Graph contains a cycle between vertex %d and %d\", x, y);\n        parent[y] = x;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops allowed (%d == %d)\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        unite(u, v); // Union-Find to check for cycles\n    }\n\n    // Check that the graph is connected\n    int root_parent = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root_parent, \"Graph is not connected at vertex %d\", i);\n    }\n\n    // Identify internal nodes and ensure their a_i is zero\n    vector<int> degree(n + 1);\n    for (int u = 1; u <= n; ++u) {\n        degree[u] = adj[u].size();\n    }\n\n    for (int u = 1; u <= n; ++u) {\n        if (u == 1 || degree[u] > 1) { // Internal node\n            ensuref(a[u - 1] == 0, \"Non-leaf vertex %d must have a_i == 0\", u);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string apple_type = opt<string>(\"apple_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<vector<int>> tree(n + 1); // 1-based indexing\n\n    if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"binary\") {\n        // Complete binary tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = i / 2;\n            edges.push_back({parent, i});\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree\n        int k = rnd.next(2, n-1); // Position where the tree splits\n        for (int i = 2; i <= k; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        for (int i = k + 1; i <= n; ++i) {\n            edges.push_back({k, i});\n        }\n    } else if (tree_type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Build adjacency list and degree count\n    vector<int> degree(n + 1, 0);\n    for (auto edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n        degree[u]++;\n        degree[v]++;\n    }\n\n    // Identify leaves: nodes with degree == 1 and not the root (vertex 1)\n    vector<int> leaves;\n    for (int i = 1; i <= n; ++i) {\n        if ((i != 1 && degree[i] == 1) || (i == 1 && degree[i] == 0)) {\n            leaves.push_back(i);\n        }\n    }\n\n    // Now assign apples to leaves according to apple_type\n    vector<int> a(n + 1, 0);\n\n    if (apple_type == \"zeros\") {\n        // All leaves have zero apples\n        for (int leaf : leaves) {\n            a[leaf] = 0;\n        }\n    } else if (apple_type == \"ones\") {\n        // All leaves have apples = 1\n        for (int leaf : leaves) {\n            a[leaf] = 1;\n        }\n    } else if (apple_type == \"max\") {\n        // All leaves have apples = 1e8\n        for (int leaf : leaves) {\n            a[leaf] = 100000000;\n        }\n    } else if (apple_type == \"random\") {\n        // Random apples between 0 and 1e8\n        for (int leaf : leaves) {\n            a[leaf] = rnd.next(0, 100000000);\n        }\n    } else if (apple_type == \"single\") {\n        // Only one leaf has apples\n        int idx = rnd.next(0, (int)leaves.size() -1);\n        a[leaves[idx]] = rnd.next(1, 100000000);\n        for (int i = 0; i < (int)leaves.size(); ++i) {\n            if (i != idx) {\n                a[leaves[i]] = 0;\n            }\n        }\n    } else if (apple_type == \"increasing\") {\n        // Apples in leaves are in increasing order starting from 1\n        int cnt = 1;\n        for (int leaf : leaves) {\n            a[leaf] = cnt++;\n        }\n    } else if (apple_type == \"decreasing\") {\n        // Apples in leaves are in decreasing order starting from number of leaves\n        int cnt = leaves.size();\n        for (int leaf : leaves) {\n            a[leaf] = cnt--;\n        }\n    } else {\n        // Default to random apples\n        for (int leaf : leaves) {\n            a[leaf] = rnd.next(0, 100000000);\n        }\n    }\n\n    // Create permutation of node labels\n    vector<int> perm(n + 1);\n    perm[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 2, perm.end());\n\n    // Map old labels to new labels\n    vector<int> a_new(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        a_new[perm[i]] = a[i];\n    }\n    // Update edges\n    vector<pair<int, int>> edges_new;\n    for (auto edge : edges) {\n        int u = perm[edge.first];\n        int v = perm[edge.second];\n        edges_new.push_back({u, v});\n    }\n    // Reassign a to a_new\n    a = a_new;\n    // Reassign edges to edges_new\n    edges = edges_new;\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto edge : edges) {\n        if (rnd.next(0,1)) {\n            printf(\"%d %d\\n\", edge.first, edge.second);\n        } else {\n            printf(\"%d %d\\n\", edge.second, edge.first);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string apple_type = opt<string>(\"apple_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<vector<int>> tree(n + 1); // 1-based indexing\n\n    if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"binary\") {\n        // Complete binary tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = i / 2;\n            edges.push_back({parent, i});\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree\n        int k = rnd.next(2, n-1); // Position where the tree splits\n        for (int i = 2; i <= k; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        for (int i = k + 1; i <= n; ++i) {\n            edges.push_back({k, i});\n        }\n    } else if (tree_type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Build adjacency list and degree count\n    vector<int> degree(n + 1, 0);\n    for (auto edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n        degree[u]++;\n        degree[v]++;\n    }\n\n    // Identify leaves: nodes with degree == 1 and not the root (vertex 1)\n    vector<int> leaves;\n    for (int i = 1; i <= n; ++i) {\n        if ((i != 1 && degree[i] == 1) || (i == 1 && degree[i] == 0)) {\n            leaves.push_back(i);\n        }\n    }\n\n    // Now assign apples to leaves according to apple_type\n    vector<int> a(n + 1, 0);\n\n    if (apple_type == \"zeros\") {\n        // All leaves have zero apples\n        for (int leaf : leaves) {\n            a[leaf] = 0;\n        }\n    } else if (apple_type == \"ones\") {\n        // All leaves have apples = 1\n        for (int leaf : leaves) {\n            a[leaf] = 1;\n        }\n    } else if (apple_type == \"max\") {\n        // All leaves have apples = 1e8\n        for (int leaf : leaves) {\n            a[leaf] = 100000000;\n        }\n    } else if (apple_type == \"random\") {\n        // Random apples between 0 and 1e8\n        for (int leaf : leaves) {\n            a[leaf] = rnd.next(0, 100000000);\n        }\n    } else if (apple_type == \"single\") {\n        // Only one leaf has apples\n        int idx = rnd.next(0, (int)leaves.size() -1);\n        a[leaves[idx]] = rnd.next(1, 100000000);\n        for (int i = 0; i < (int)leaves.size(); ++i) {\n            if (i != idx) {\n                a[leaves[i]] = 0;\n            }\n        }\n    } else if (apple_type == \"increasing\") {\n        // Apples in leaves are in increasing order starting from 1\n        int cnt = 1;\n        for (int leaf : leaves) {\n            a[leaf] = cnt++;\n        }\n    } else if (apple_type == \"decreasing\") {\n        // Apples in leaves are in decreasing order starting from number of leaves\n        int cnt = leaves.size();\n        for (int leaf : leaves) {\n            a[leaf] = cnt--;\n        }\n    } else {\n        // Default to random apples\n        for (int leaf : leaves) {\n            a[leaf] = rnd.next(0, 100000000);\n        }\n    }\n\n    // Create permutation of node labels\n    vector<int> perm(n + 1);\n    perm[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 2, perm.end());\n\n    // Map old labels to new labels\n    vector<int> a_new(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        a_new[perm[i]] = a[i];\n    }\n    // Update edges\n    vector<pair<int, int>> edges_new;\n    for (auto edge : edges) {\n        int u = perm[edge.first];\n        int v = perm[edge.second];\n        edges_new.push_back({u, v});\n    }\n    // Reassign a to a_new\n    a = a_new;\n    // Reassign edges to edges_new\n    edges = edges_new;\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto edge : edges) {\n        if (rnd.next(0,1)) {\n            printf(\"%d %d\\n\", edge.first, edge.second);\n        } else {\n            printf(\"%d %d\\n\", edge.second, edge.first);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -tree_type chain -apple_type ones\n./gen -n 2 -tree_type star -apple_type ones\n./gen -n 2 -tree_type random -apple_type ones\n\n./gen -n 5 -tree_type chain -apple_type zeros\n./gen -n 5 -tree_type star -apple_type ones\n./gen -n 5 -tree_type binary -apple_type random\n\n./gen -n 10 -tree_type chain -apple_type increasing\n./gen -n 10 -tree_type star -apple_type decreasing\n./gen -n 10 -tree_type binary -apple_type ones\n./gen -n 10 -tree_type random -apple_type random\n\n./gen -n 100 -tree_type chain -apple_type zeros\n./gen -n 100 -tree_type chain -apple_type ones\n./gen -n 100 -tree_type skewed -apple_type max\n./gen -n 100 -tree_type star -apple_type random\n\n./gen -n 1000 -tree_type binary -apple_type increasing\n./gen -n 1000 -tree_type skewed -apple_type decreasing\n./gen -n 1000 -tree_type random -apple_type random\n./gen -n 1000 -tree_type random -apple_type single\n\n./gen -n 10000 -tree_type random -apple_type zeros\n./gen -n 10000 -tree_type random -apple_type ones\n./gen -n 10000 -tree_type random -apple_type random\n./gen -n 10000 -tree_type chain -apple_type ones\n\n./gen -n 100000 -tree_type random -apple_type random\n./gen -n 100000 -tree_type star -apple_type max\n./gen -n 100000 -tree_type binary -apple_type random\n./gen -n 100000 -tree_type chain -apple_type decreasing\n\n./gen -n 99999 -tree_type skewed -apple_type zeros\n./gen -n 100000 -tree_type chain -apple_type single\n./gen -n 100000 -tree_type chain -apple_type increasing\n./gen -n 100000 -tree_type skewed -apple_type decreasing\n\n# Edge cases\n./gen -n 2 -tree_type chain -apple_type zeros\n./gen -n 2 -tree_type chain -apple_type max\n\n# Random cases\n./gen -n 100000 -tree_type random -apple_type random\n./gen -n 100000 -tree_type random -apple_type random\n\n# Ensuring non-root leaves\n./gen -n 2 -tree_type star -apple_type ones\n\n# All leaves attached to root\n./gen -n 100000 -tree_type star -apple_type ones\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:04.225356",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "348/C",
      "title": "C. Subset Sums",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, m, q (1 ≤ n, m, q ≤ 105). The second line contains n integers a1, a2, ..., an (|ai| ≤ 108) — elements of array a. Each of the following m lines describes one set of indices. The k-th line first contains a positive integer, representing the number of elements in set (|Sk|), then follow |Sk| distinct integers Sk, 1, Sk, 2, ..., Sk, |Sk| (1 ≤ Sk, i ≤ n) — elements of set Sk.The next q lines contain queries. Each query looks like either \"? k\" or \"+ k x\" and sits on a single line. For all queries the following limits are held: 1 ≤ k ≤ m, |x| ≤ 108. The queries are given in order they need to be answered.It is guaranteed that the sum of sizes of all sets Sk doesn't exceed 105.",
      "output_spec": "OutputAfter each first type query print the required sum on a single line.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy5 3 55 -5 5 1 -42 1 24 2 1 4 52 2 5? 2+ 3 4? 1+ 2 1? 2OutputCopy-349",
      "description": "C. Subset Sums\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m, q (1 ≤ n, m, q ≤ 105). The second line contains n integers a1, a2, ..., an (|ai| ≤ 108) — elements of array a. Each of the following m lines describes one set of indices. The k-th line first contains a positive integer, representing the number of elements in set (|Sk|), then follow |Sk| distinct integers Sk, 1, Sk, 2, ..., Sk, |Sk| (1 ≤ Sk, i ≤ n) — elements of set Sk.The next q lines contain queries. Each query looks like either \"? k\" or \"+ k x\" and sits on a single line. For all queries the following limits are held: 1 ≤ k ≤ m, |x| ≤ 108. The queries are given in order they need to be answered.It is guaranteed that the sum of sizes of all sets Sk doesn't exceed 105.\n\nOutputAfter each first type query print the required sum on a single line.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy5 3 55 -5 5 1 -42 1 24 2 1 4 52 2 5? 2+ 3 4? 1+ 2 1? 2OutputCopy-349\n\nInputCopy5 3 55 -5 5 1 -42 1 24 2 1 4 52 2 5? 2+ 3 4? 1+ 2 1? 2\n\nOutputCopy-349",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #202 will take place today, September 27 at 19:30 MSK.The idea behind the round was born when my friends and I were interning at Facebook this summer. This round probably has the highest number of authors for a Codeforces round to date. The authors of the problems are Azizkhan Almakhan azizkhan, Michael Kolupaev al13n, Filip Hlasek fhlasek, Ivan Mandura budabudimir and myself, Igor Demidov caustique.Maxim Korystov dark_ai, Alexander Fedulin Jughead and Ibragim Ismailov ibra, Vladimir Chalyshev cmd and Sergey Sklyanichenko Sklyack helped us with preparation of the round.The ideas behind the 2 problems were inspired by Anton Ermilov ant.ermilov and Dmitry Krasnov navi-spb.Testers of the round are Alexey Safronov yarrr and Alexey Shmelev ashmelev.I would also like to thank Gerald Agapov Gerald for his help in preparing the contest.I hope you find problems interesting and diverse. I'm sure that everyone will find the problem to their liking.Scores are as usual 500-1000-1500-2000-2500.Good luck and have fun!Congratulations to the winners!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Attention! Editorial for all problems is available!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Editorial for Codeforces Round #202 - Codeforces",
          "content": "349A - Cinema LineIn the problem you need to decide whether cashier can give a change to all customers if the price of the ticket is 25 rubles and there's 3 kinds of bills: 25, 50 and 100 rubles. There's no money in the ticket office in the beginning.Let's consider 3 cases. Customer has 25 rubles hence he doesn't need a change. Customer has 50 rubles hence we have to give him 25 rubles back. Customer has 100 rubles hence we need to give him 75 rubles back. It can be done in 2 ways. 75=25+50 и 75=25+25+25. Notice that it's always worth to try 25+50 first and then 25+25+25. It's true because bills of 25 rubles can be used both to give change for 50 and 100 rubles and bills of 50 rubles can be used only to give change for 100 rubles so we need to save as much 25 ruble bills as possible. The solution is to keep track of the number of 25 and 50 ruble bills and act greedily when giving change to 100 rubles — try 25+50 first and then 25+25+25.349B - Color the FenceIn the problem you're asked to write the largest possible number given number of paint that you have and number of paint that you need to write each digit.Longer number means larger number so it's worth to write the longest possible number. Because of that we choose the largest digit among those that require the least number of paint. Let the number of paint for that digit d be equal to x, and we have v liters of paint total. Then we can write number of the length .Now we know the length of the number, let it be len. Write down temporary result – string of length len, consisting of digits d. We have supply of v–len·x liters of paint. In order to enhance the answer, we can try to update the number from the beginning and swap each digit with the maximal possible. It's true because numbers of the equal length are compared in the highest digits first. Among digits that are greater than current we choose one that we have enough paint for and then update answer and current number of paint.If the length of the answer is 0 then you need to output -1.348A - MafiaIn the problem you need to find out how many games you need to play in order to make all people happy. It means that each of them played as many games as he wanted.Let the answer be x games. Notice that max(a1, a2, …, an) ≤ x. Then i-th player can be game supervisor in x–ai games. If we sum up we get — it's the number of games in which players are ready to be supervisor. This number must be greater or equal to x — our answer. Don't forget about that condition: max(a1, a2, …, an) ≤ x.348B - Apple TreeIn the problem you need to find out minimal number of apples that you need to remove in order to make tree balanced.Notice, that if we know the value in the root then we know values in all other vertices. The value in the leaf is equal to the value in the root divided to the product of the powers of all vertices on the path between root and leaf.For every vertex let's calculate di — minimal number in that vertex (not zero) in order to make tree balanced. For leaves di = 1, for all other vertices di is equal to k·lcm(dj1, dj2, ..., djk), where j1, j2, ..., jk — sons of the vertex i. Let's calculate si — sum in the subtree of the vertex i. All that can be done using one depth first search from the root of the tree.Using second depth first search one can calculate for every vertex maximal number that we can write in it and satisfty all conditions. More precisely, given vertex i and k of its sons j1, j2, ..., jk. Then if m = min(sj1, sj2, ..., sjk) and — minimal number, that we can write to the sons of vertex i, then it's worth to write numbers to the sons of vertex i. Remains we add to the answer.348C - Subset SumsThis problem is about data structures.First step of the solution is to divide sets to heavy and light. Light ones are those that contains less than elements. All other sets are heavy.Key observation is that every light set contains less than elements and number of heavy sets doesn't exceed because we have upper bound for sum of the sizes of all sets.In order to effectively answer queries, for every set (both light and heavy) we calculate size of the intersection of this set and each heavy set. It can be done with time and memory . For every heavy set we create boolean array of size O(n). In i-th cell of this array we store how many elements i in given set. Then for each element and each heavy set we can check for O(1) time whether element is in the set.Now let's consider 4 possible cases: Add to the light set. Traverse all numbers in the set and add the value from the query to each of them. Then traverse all heavy sets and add (size of intersection * the value from the query). Time is . Add to the heavy set. Just update the counter for the heavy set. Time is O(1). Answer to the query for the light set. Traverse all numbers in the set and add values to the answer. Then traverse all heavy sets and add to the answer (answer for this heavy set * size of intersection with the set in the query). Time is . Answer to the query for the heavy set. Take already calculated answer, then traverse all heavy sets and add (answer for this heavy set * size of intersection with the set in the query). Time is . We have O(n) queries so total time is .348D - TurtlesIn the problem you're asked to find the number of pairs of non-intersecting paths between left upper and right lower corners of the grid. You can use following lemma for that. Thanks to rng_58 for the link. More precisely, considering our problem, this lemma states that given sets of initial A = {a1, a2} and final B = {b1, b2} points, the answer is equal to the following determinant: where f(x, y) — is equal to the number of paths from point x to point y. You can calculate this function using dynamic programming.Finally we need to decide what sets of initial and final points we choose. You can take A = {(0, 1), (1, 0)} and B = {(n - 2, m - 1), (n - 1, m - 2)} in order to make paths non-intersecting even in 2 points.348E - PilgrimsLet’s build a simple solution at first and then we will try to improve it to solve problem more effectively given the constraints.For every vertex let’s find the list of the farthest vertices. Let’s find vertices on the intersection of the paths between current vertex and each vertex from the list that don’t contain monasteries. If we remove any of these vertices then every vertex from the list is unreachable from the current monastery. For every vertex from the intersection increment the counter. Then the answer for the problem is the maximum among all counters and the number of such maxima.Let’s solve the problem more effectively using the same idea. Let’s make the tree with root. For every vertex we will find the list of the farthest vertices only in the subtree. While traversing the tree using depth first search we return the largest depth in the subtree and the number of the vertex where it was reached. Among all of the sons of the current vertex we choose the maximum of depths. If maximum is reached one time then we return the same answer that was returned from the son. If the answer was reached more than one time then we return the number of the current vertex. Essentially, we find LCA of the farthest vertices according to the current vertex. Before quitting the vertex we increment the values on the segment between current vertex and found LCA. One can use Eulerian tour and segment tree for adding on the segment.Finally, the last stage of solving the problem – to solve it for the case when the farthest vertex is not in the subtree of the current vertex. For solving of that subproblem we use the same idea that was used in the problem of the finding the maximal path in the tree. For every vertex we keep 3 maximums – 3 farthest vertices in the subtree. When we go down to the subtree, we pass 2 remaining maximums too. In that way, when we’re in any vertex, we can decide whether there’s a path not in the subtree (it means, going up) of the same or larger length. If there’re 2 paths of the same length in the subtree and not in the subtree, it means that for the pilgrim from the current monastery there’s always a path no matter what town was destroyed. If one of the quantities is larger then we choose the segment in Eulerian tour and increment the value on the segment. The case where there’s several paths (at least 2) out of the subtree of the same maximal length, is the same with the case in the subtree.LCA and segment tree can be solved effectively in O(logN) time per query so the total memory and time is O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 348\\s*C"
          },
          "content_length": 8548
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -100000000, 100000000, \"a_i\");\n    inf.readEoln();\n\n    int sum_sk = 0;\n    for (int i = 0; i < m; i++) {\n        int sz = inf.readInt(1, 100000, \"size of Sk\");\n        sum_sk += sz;\n        ensuref(sum_sk <= 100000, \"Sum of sizes of all sets Sk exceed 1e5\");\n\n        inf.readSpace();\n        vector<int> sk = inf.readInts(sz, 1, n, \"Sk_i\");\n        inf.readEoln();\n\n        set<int> sk_set(sk.begin(), sk.end());\n        ensuref(sk_set.size() == sz, \"Sk_i are not distinct in set %d\", i + 1);\n    }\n\n    for (int i = 0; i < q; i++) {\n        string cmd = inf.readToken();\n        ensuref(cmd == \"?\" || cmd == \"+\", \"Invalid command '%s' at line %d\", cmd.c_str(), i + m + n + 3);\n\n        inf.readSpace();\n        int k = inf.readInt(1, m, \"k\");\n\n        if (cmd == \"+\") {\n            inf.readSpace();\n            int x = inf.readInt(-100000000, 100000000, \"x\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -100000000, 100000000, \"a_i\");\n    inf.readEoln();\n\n    int sum_sk = 0;\n    for (int i = 0; i < m; i++) {\n        int sz = inf.readInt(1, 100000, \"size of Sk\");\n        sum_sk += sz;\n        ensuref(sum_sk <= 100000, \"Sum of sizes of all sets Sk exceed 1e5\");\n\n        inf.readSpace();\n        vector<int> sk = inf.readInts(sz, 1, n, \"Sk_i\");\n        inf.readEoln();\n\n        set<int> sk_set(sk.begin(), sk.end());\n        ensuref(sk_set.size() == sz, \"Sk_i are not distinct in set %d\", i + 1);\n    }\n\n    for (int i = 0; i < q; i++) {\n        string cmd = inf.readToken();\n        ensuref(cmd == \"?\" || cmd == \"+\", \"Invalid command '%s' at line %d\", cmd.c_str(), i + m + n + 3);\n\n        inf.readSpace();\n        int k = inf.readInt(1, m, \"k\");\n\n        if (cmd == \"+\") {\n            inf.readSpace();\n            int x = inf.readInt(-100000000, 100000000, \"x\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -100000000, 100000000, \"a_i\");\n    inf.readEoln();\n\n    int sum_sk = 0;\n    for (int i = 0; i < m; i++) {\n        int sz = inf.readInt(1, 100000, \"size of Sk\");\n        sum_sk += sz;\n        ensuref(sum_sk <= 100000, \"Sum of sizes of all sets Sk exceed 1e5\");\n\n        inf.readSpace();\n        vector<int> sk = inf.readInts(sz, 1, n, \"Sk_i\");\n        inf.readEoln();\n\n        set<int> sk_set(sk.begin(), sk.end());\n        ensuref(sk_set.size() == sz, \"Sk_i are not distinct in set %d\", i + 1);\n    }\n\n    for (int i = 0; i < q; i++) {\n        string cmd = inf.readToken();\n        ensuref(cmd == \"?\" || cmd == \"+\", \"Invalid command '%s' at line %d\", cmd.c_str(), i + m + n + 3);\n\n        inf.readSpace();\n        int k = inf.readInt(1, m, \"k\");\n\n        if (cmd == \"+\") {\n            inf.readSpace();\n            int x = inf.readInt(-100000000, 100000000, \"x\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generateDistinctIndices(int n, int k) {\n    assert(k <= n);\n    vector<int> indices;\n    if (k * 5 <= n) {\n        set<int> s;\n        while ((int)s.size() < k) {\n            int idx = rnd.next(1, n);\n            s.insert(idx);\n        }\n        indices.assign(s.begin(), s.end());\n    } else {\n        indices.resize(n);\n        for (int i = 0; i < n; ++i) indices[i] = i+1;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n    }\n    return indices;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints are met\n    assert(1 <= n && n <= 100000);\n    assert(1 <= m && m <= 100000);\n    assert(1 <= q && q <= 100000);\n\n    // Generate array a\n    vector<int> a(n);\n\n    if (type == \"large_ai\") {\n        // Use maximum values\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000000, 100000000);\n        }\n    } else if (type == \"small_ai\") {\n        // Use small numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10,10);\n        }\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"negative_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000000, -1);\n        }\n    } else {\n        // Random ai in range [-1e8, 1e8]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000000, 100000000);\n        }\n    }\n\n    // Now generate m sets\n\n    // Sum of all set sizes must <= 1e5\n    long long total_set_size = 0;\n\n    vector<vector<int>> sets(m);\n\n    if (type == \"single_large_set\") {\n        // m=1, set size up to 1e5\n        m = 1;\n        sets.resize(1);\n        int set_size = min(n, 100000);\n        total_set_size = set_size;\n        sets[0] = generateDistinctIndices(n, set_size);\n    } else if (type == \"multiple_singleton_sets\") {\n        // m up to 1e5, each set size is 1\n        m = min(m, 100000);\n        sets.resize(m);\n        total_set_size = m;\n        for (int i = 0; i < m; ++i) {\n            sets[i].push_back(rnd.next(1, n));\n        }\n    } else if (type == \"overlapping_sets\") {\n        // generate sets with overlapping indices\n        total_set_size = 0;\n        int avg_set_size = 100;\n        for (int i = 0; i < m; ++i) {\n            int set_size = rnd.next(1, min(avg_set_size, n));\n            if (total_set_size + set_size > 100000) {\n                set_size = 100000 - total_set_size;\n            }\n            if (set_size <= 0) {\n                m = i;\n                sets.resize(m);\n                break;\n            }\n            sets[i] = generateDistinctIndices(n, set_size);\n            total_set_size += set_size;\n        }\n    } else if (type == \"disjoint_sets\") {\n        // divide n indices into m disjoint sets\n        m = min(m, n);\n        sets.resize(m);\n        int idx = 1;\n        int base_set_size = n / m;\n        int rem = n % m;\n        total_set_size = 0;\n        for (int i = 0; i < m; ++i) {\n            int curr_set_size = base_set_size + (i < rem ? 1 : 0);\n            if (total_set_size + curr_set_size > 100000) {\n                curr_set_size = 100000 - total_set_size;\n            }\n            if (curr_set_size <= 0) {\n                m = i;\n                sets.resize(m);\n                break;\n            }\n            sets[i].resize(curr_set_size);\n            for (int j = 0; j < curr_set_size; ++j) {\n                sets[i][j] = idx++;\n            }\n            total_set_size += curr_set_size;\n        }\n    } else if (type == \"few_large_sets\") {\n        // Few sets with large sizes\n        m = min(m, 10);\n        sets.resize(m);\n        int set_size = min(n, 100000 / m);\n        for (int i = 0; i < m; ++i) {\n            if (total_set_size + set_size > 100000) {\n                set_size = 100000 - total_set_size;\n            }\n            if (set_size <= 0) {\n                m = i;\n                sets.resize(m);\n                break;\n            }\n            sets[i] = generateDistinctIndices(n, set_size);\n            total_set_size += set_size;\n        }\n    } else if (type == \"same_sets\") {\n        // All sets are the same\n        vector<int> common_set = generateDistinctIndices(n, min(100000, n));\n        for (int i = 0; i < m; ++i) {\n            sets[i] = common_set;\n        }\n        total_set_size = (long long)m * common_set.size();\n        if (total_set_size > 100000) {\n            // Adjust m\n            m = 100000 / common_set.size();\n            sets.resize(m);\n            total_set_size = (long long)m * common_set.size();\n        }\n    } else {\n        // Random sets\n        total_set_size = 0;\n        for (int i = 0; i < m; ++i) {\n            int set_size = rnd.next(1, min(1000, n));\n            if (total_set_size + set_size > 100000) {\n                set_size = 100000 - total_set_size;\n            }\n            if (set_size <= 0) {\n                m = i;\n                sets.resize(m);\n                break;\n            }\n            sets[i] = generateDistinctIndices(n, set_size);\n            total_set_size += set_size;\n        }\n    }\n\n    // Now generate q queries\n    vector<string> queries(q);\n    if (type == \"only_queries_type1\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, m);\n            queries[i] = \"? \" + to_string(k);\n        }\n    } else if (type == \"only_queries_type2\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, m);\n            int x;\n            if (type == \"negative_values\")\n                x = rnd.next(-100000000, -1);\n            else\n                x = rnd.next(-100000000, 100000000);\n            queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n        }\n    } else if (type == \"alternating_queries\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, m);\n            if (i % 2 == 0) {\n                queries[i] = \"? \" + to_string(k);\n            } else {\n                int x = rnd.next(-100000000, 100000000);\n                queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n            }\n        }\n    } else if (type == \"queries_on_same_set\") {\n        int k = rnd.next(1, m);\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1, 2);\n            if (query_type == 1) {\n                queries[i] = \"? \" + to_string(k);\n            } else {\n                int x = rnd.next(-100000000, 100000000);\n                queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n            }\n        }\n    } else if (type == \"negative_values\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1, 2);\n            int k = rnd.next(1, m);\n            if (query_type == 1) {\n                queries[i] = \"? \" + to_string(k);\n            } else {\n                int x = rnd.next(-100000000, -1);\n                queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n            }\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1, 2);\n            int k = rnd.next(1, m);\n            if (query_type == 1) {\n                queries[i] = \"? \" + to_string(k);\n            } else {\n                int x = rnd.next(-100000000, 100000000);\n                queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n            }\n        }\n    }\n\n    // Now output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n-1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output m sets\n    for (int i = 0; i < m; ++i) {\n        int set_size = sets[i].size();\n        printf(\"%d\", set_size);\n        for (int j = 0; j < set_size; ++j) {\n            printf(\" %d\", sets[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Output q queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generateDistinctIndices(int n, int k) {\n    assert(k <= n);\n    vector<int> indices;\n    if (k * 5 <= n) {\n        set<int> s;\n        while ((int)s.size() < k) {\n            int idx = rnd.next(1, n);\n            s.insert(idx);\n        }\n        indices.assign(s.begin(), s.end());\n    } else {\n        indices.resize(n);\n        for (int i = 0; i < n; ++i) indices[i] = i+1;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n    }\n    return indices;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints are met\n    assert(1 <= n && n <= 100000);\n    assert(1 <= m && m <= 100000);\n    assert(1 <= q && q <= 100000);\n\n    // Generate array a\n    vector<int> a(n);\n\n    if (type == \"large_ai\") {\n        // Use maximum values\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000000, 100000000);\n        }\n    } else if (type == \"small_ai\") {\n        // Use small numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10,10);\n        }\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"negative_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000000, -1);\n        }\n    } else {\n        // Random ai in range [-1e8, 1e8]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000000, 100000000);\n        }\n    }\n\n    // Now generate m sets\n\n    // Sum of all set sizes must <= 1e5\n    long long total_set_size = 0;\n\n    vector<vector<int>> sets(m);\n\n    if (type == \"single_large_set\") {\n        // m=1, set size up to 1e5\n        m = 1;\n        sets.resize(1);\n        int set_size = min(n, 100000);\n        total_set_size = set_size;\n        sets[0] = generateDistinctIndices(n, set_size);\n    } else if (type == \"multiple_singleton_sets\") {\n        // m up to 1e5, each set size is 1\n        m = min(m, 100000);\n        sets.resize(m);\n        total_set_size = m;\n        for (int i = 0; i < m; ++i) {\n            sets[i].push_back(rnd.next(1, n));\n        }\n    } else if (type == \"overlapping_sets\") {\n        // generate sets with overlapping indices\n        total_set_size = 0;\n        int avg_set_size = 100;\n        for (int i = 0; i < m; ++i) {\n            int set_size = rnd.next(1, min(avg_set_size, n));\n            if (total_set_size + set_size > 100000) {\n                set_size = 100000 - total_set_size;\n            }\n            if (set_size <= 0) {\n                m = i;\n                sets.resize(m);\n                break;\n            }\n            sets[i] = generateDistinctIndices(n, set_size);\n            total_set_size += set_size;\n        }\n    } else if (type == \"disjoint_sets\") {\n        // divide n indices into m disjoint sets\n        m = min(m, n);\n        sets.resize(m);\n        int idx = 1;\n        int base_set_size = n / m;\n        int rem = n % m;\n        total_set_size = 0;\n        for (int i = 0; i < m; ++i) {\n            int curr_set_size = base_set_size + (i < rem ? 1 : 0);\n            if (total_set_size + curr_set_size > 100000) {\n                curr_set_size = 100000 - total_set_size;\n            }\n            if (curr_set_size <= 0) {\n                m = i;\n                sets.resize(m);\n                break;\n            }\n            sets[i].resize(curr_set_size);\n            for (int j = 0; j < curr_set_size; ++j) {\n                sets[i][j] = idx++;\n            }\n            total_set_size += curr_set_size;\n        }\n    } else if (type == \"few_large_sets\") {\n        // Few sets with large sizes\n        m = min(m, 10);\n        sets.resize(m);\n        int set_size = min(n, 100000 / m);\n        for (int i = 0; i < m; ++i) {\n            if (total_set_size + set_size > 100000) {\n                set_size = 100000 - total_set_size;\n            }\n            if (set_size <= 0) {\n                m = i;\n                sets.resize(m);\n                break;\n            }\n            sets[i] = generateDistinctIndices(n, set_size);\n            total_set_size += set_size;\n        }\n    } else if (type == \"same_sets\") {\n        // All sets are the same\n        vector<int> common_set = generateDistinctIndices(n, min(100000, n));\n        for (int i = 0; i < m; ++i) {\n            sets[i] = common_set;\n        }\n        total_set_size = (long long)m * common_set.size();\n        if (total_set_size > 100000) {\n            // Adjust m\n            m = 100000 / common_set.size();\n            sets.resize(m);\n            total_set_size = (long long)m * common_set.size();\n        }\n    } else {\n        // Random sets\n        total_set_size = 0;\n        for (int i = 0; i < m; ++i) {\n            int set_size = rnd.next(1, min(1000, n));\n            if (total_set_size + set_size > 100000) {\n                set_size = 100000 - total_set_size;\n            }\n            if (set_size <= 0) {\n                m = i;\n                sets.resize(m);\n                break;\n            }\n            sets[i] = generateDistinctIndices(n, set_size);\n            total_set_size += set_size;\n        }\n    }\n\n    // Now generate q queries\n    vector<string> queries(q);\n    if (type == \"only_queries_type1\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, m);\n            queries[i] = \"? \" + to_string(k);\n        }\n    } else if (type == \"only_queries_type2\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, m);\n            int x;\n            if (type == \"negative_values\")\n                x = rnd.next(-100000000, -1);\n            else\n                x = rnd.next(-100000000, 100000000);\n            queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n        }\n    } else if (type == \"alternating_queries\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, m);\n            if (i % 2 == 0) {\n                queries[i] = \"? \" + to_string(k);\n            } else {\n                int x = rnd.next(-100000000, 100000000);\n                queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n            }\n        }\n    } else if (type == \"queries_on_same_set\") {\n        int k = rnd.next(1, m);\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1, 2);\n            if (query_type == 1) {\n                queries[i] = \"? \" + to_string(k);\n            } else {\n                int x = rnd.next(-100000000, 100000000);\n                queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n            }\n        }\n    } else if (type == \"negative_values\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1, 2);\n            int k = rnd.next(1, m);\n            if (query_type == 1) {\n                queries[i] = \"? \" + to_string(k);\n            } else {\n                int x = rnd.next(-100000000, -1);\n                queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n            }\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1, 2);\n            int k = rnd.next(1, m);\n            if (query_type == 1) {\n                queries[i] = \"? \" + to_string(k);\n            } else {\n                int x = rnd.next(-100000000, 100000000);\n                queries[i] = \"+ \" + to_string(k) + \" \" + to_string(x);\n            }\n        }\n    }\n\n    // Now output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n-1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output m sets\n    for (int i = 0; i < m; ++i) {\n        int set_size = sets[i].size();\n        printf(\"%d\", set_size);\n        for (int j = 0; j < set_size; ++j) {\n            printf(\" %d\", sets[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Output q queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Command format: ./gen -n N -m M -q Q -type TYPE\n\n# Small input test cases\n./gen -n 5 -m 5 -q 5 -type small\n./gen -n 10 -m 10 -q 10 -type small\n\n# Maximum n\n./gen -n 100000 -m 1000 -q 1000 -type max_n\n\n# Maximum m\n./gen -n 1000 -m 100000 -q 1000 -type max_m\n\n# Maximum q\n./gen -n 1000 -m 1000 -q 100000 -type max_q\n\n# Single large set\n./gen -n 100000 -m 1 -q 100000 -type single_large_set\n\n# Multiple singleton sets\n./gen -n 100000 -m 100000 -q 100000 -type multiple_singleton_sets\n\n# Overlapping sets\n./gen -n 100000 -m 1000 -q 100000 -type overlapping_sets\n\n# Disjoint sets\n./gen -n 100000 -m 1000 -q 100000 -type disjoint_sets\n\n# Only queries type 1\n./gen -n 10000 -m 1000 -q 100000 -type only_queries_type1\n\n# Only queries type 2\n./gen -n 10000 -m 1000 -q 100000 -type only_queries_type2\n\n# Large ai\n./gen -n 100000 -m 1000 -q 1000 -type large_ai\n\n# Large x in updates (Note: large x is already covered in random types)\n./gen -n 100000 -m 1000 -q 100000 -type random\n\n# Maximal everything\n./gen -n 100000 -m 100000 -q 100000 -type random\n\n# Alternating queries\n./gen -n 100000 -m 1000 -q 100000 -type alternating_queries\n\n# All zero ai\n./gen -n 100000 -m 1000 -q 100000 -type all_zero\n\n# Small ai values\n./gen -n 100000 -m 1000 -q 100000 -type small_ai\n\n# Few large sets\n./gen -n 100000 -m 10 -q 100000 -type few_large_sets\n\n# All sets are the same\n./gen -n 100000 -m 1000 -q 100000 -type same_sets\n\n# Queries on the same set\n./gen -n 100000 -m 1000 -q 100000 -type queries_on_same_set\n\n# Negative ai and x\n./gen -n 100000 -m 1000 -q 100000 -type negative_values\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:06.601947",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "348/D",
      "title": "D. Черепашки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n, m (2 ≤ n, m ≤ 3000). В каждой из следующих n строк записано m символов — описание таблицы. Свободные клетки обозначаются символом «.», клетки с препятствиями — символом «#».Гарантируется, что левая верхняя и правая нижняя клетки свободны.",
      "output_spec": "Выходные данныеВ единственной строке выведите целое число — количество пар непересекающихся путей из клетки (1, 1) в клетку (n, m) по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать4 5......###..###......Выходные данныеСкопировать1Входные данныеСкопировать2 3......Выходные данныеСкопировать1",
      "description": "D. Черепашки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n, m (2 ≤ n, m ≤ 3000). В каждой из следующих n строк записано m символов — описание таблицы. Свободные клетки обозначаются символом «.», клетки с препятствиями — символом «#».Гарантируется, что левая верхняя и правая нижняя клетки свободны.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите целое число — количество пар непересекающихся путей из клетки (1, 1) в клетку (n, m) по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать4 5......###..###......Выходные данныеСкопировать1Входные данныеСкопировать2 3......Выходные данныеСкопировать1\n\nВходные данныеСкопировать4 5......###..###......\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3......\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Привет, Codeforces!Сегодня, 27 сентября в 19:30 МСК, состоится Codeforces Round #202.Идея раунда зародилась у меня и моих друзей, когда мы стажировались в Facebook этим летом. Возможно, у этого раунда рекордное для Codeforces количество авторов. Авторами задач стали Азизхан Алмахан azizkhan, Михаил Колупаев al13n, Филип Хласек fhlasek, Иван Мандура budabudimir и я, Игорь Демидов caustique.В подготовке раунда нам помогали Максим Корыстов dark_ai, Александр Федулин Jughead, Ибрагим Исмаилов ibra, Владимир Чалышев cmd и Сергей Скляниченко Sklyack.Идеи 2 задач мне подали Антон Ермилов ant.ermilov и Дмитрий Краснов navi-spb.Тестировали раунд Алексей Сафронов yarrr и Алексей Шмелев ashmelev.Также я хотел бы поблагодарить Геральда Агапова Gerald за помощь в подготовке контеста.Надеюсь, задачи Вам покажутся разнообразными и интересными. Уверен, что каждый найдет себе задачу по вкусу.Разбалловка стандартная 500-1000-1500-2000-2500.Желаю удачи и удовольствия от решения задач!Поздравляем победителей!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Внимание! Появился разбор всех задач на обоих языках!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1183
        },
        {
          "title": "Разбор задач Codeforces Round #202 - Codeforces",
          "content": "349A - Очередь в киноВ задаче требовалось выяснить, может ли кассир выдать сдачу всем посетителям кинотеатра, если билет стоит 25 рублей, у посетителей купюры номиналом 25, 50 и 100 и в кассе изначально нет денег.Рассмотрим 3 различных случая. Если у посетителя 25 рублей, то сдачу ему давать не нужно. Если у посетителя 50 рублей, то мы должны дать ему 25 рублей сдачи. Если у посетителя 100 рублей, то мы должны дать ему 75 рублей сдачи. Это можно сделать двумя способами. 75=25+50 и 75=25+25+25. Заметим, что всегда выгодно попробовать сначала первый способ, а потом второй. Это верно потому, что купюры номиналом 25 рублей могут быть использован как для выдачи сдачи на 50 рублей, так и на 100 рублей, а сами купюры номиналом 50 рублей могут использоваться только для выдачи сдачи на 100 рублей. Таким образом решение – поддерживать количество купюр номиналом 25 и 50 рублей и при выдаче сдачи на 100 рублей действовать жадно – сначала пробовать выдать 25+50 рублей, а иначе 25+25+25 рублей.349B - Раскраска забораВ задаче требовалось выяснить наибольшее число, которое можно написать, используя заданное количество краски, если на каждую цифру тратится также известное количество краски.Поскольку чем длиннее число, тем оно больше, нам выгодно написать число наибольшей длины. Для этого выберем цифру, на которую нужно меньше всего краски. Пусть количество краски для написания этой цифры d равно x, а всего у нас есть v литров краски. Тогда мы можем написать число длины .Таким образом мы выяснили длину числа, пусть она равна len. Запишем промежуточный результат – строку длины len, состоящую из цифр d. У нас в запасе еще осталось v–len·x краски. Чтобы улучшить ответ, будем идти от начала числа и пробовать заменить каждую цифру на максимально возможную. Это верно потому, что числа одинаковой длины сравниваются сначала по старшим разрядам. Среди цифр больше текущей выбираем максимальную среди тех, на которую хватает краски, и обновляем текущее количество краски и ответ.Если ответ длины 0, то нужно вывести -1.348A - МафияВ задаче требовалось определить, сколько игр нужно сыграть, чтобы все игроки остались довольны и сыграли как минимум столько игр, сколько они хотят.Пусть ответ – это x игр. Заметим, что max(a1, a2, …, an) ≤ x. Тогда i-ый игрок может в x–ai играх быть ведущим. Если просуммировать по всем игрокам, то получим — это количество игр, в которых игроки согласны быть ведущими. Это число должно быть не меньше x — нашего ответа. Также следует не забыть требование, что max(a1, a2, …, an) ≤ x.348B - ЯблоняВ задаче требовалось выяснить, какое минимальное количество яблок нужно удалить, чтобы сделать дерево сбалансированным.Заметим, что если мы знаем значение в корне, то знаем значения во всех остальных вершинах. Значение в листе равняется значению в корне, поделенному на произведение степеней вершин на пути от корня до листа.Для каждой вершины посчитаем величину di — какое минимальное число (не ноль) в ней должно быть записано, чтобы дерево по-прежнему могло быть сбалансированным. Для листьев di = 1, для остальных вершин di равен k·lcm(dj1, dj2, ..., djk), где j1, j2, ..., jk — сыновья вершины i. Также посчитаем величину si — сумму в поддереве вершины i. Все это можно сделать за один обход в глубину из корня дерева.Вторым обходом в глубину мы можем посчитать для каждой вершины максимальное число, которое мы в нее можем записать, так чтобы удовлетворить ограничениям. А именно, пусть дана вершина i и k ее сыновей j1, j2, ..., jk. Тогда если m = min(sj1, sj2, ..., sjk), а — минимальное число, которое мы можем записать в сыновей вершины i, нам выгодно записать в сыновей вершины i числа . Остатки, а именно , добавим к ответу.348C - Суммы подмножествВ этой задаче на структуры данных требовалось использовать корневую эвристику или, по-другому, sqrt-декомпозицию.Первый шаг решения состоял в том, чтобы разделить множества на легкие и тяжелые. Легкими назовем множества, которые содержат меньше элементов, а тяжелыми все остальные.Ключевое наблюдение. В любом легком множестве меньше элементов, а количество тяжелых множеств также не превосходит , так как есть ограничение на сумму размеров множеств.Чтобы эффективно отвечать на запросы, для каждого множества (как легкого, так и тяжелого) посчитаем размеры его пересечения со всеми тяжелыми множествами. Это можно сделать за время и память . Для каждого тяжелого множества создадим булевский массив размера O(n), в i-ой ячейке которого будем хранить, сколько элементов i в этом множестве. Затем для каждого элемента и каждого тяжелого множества будем за O(1) проверять, содержится ли элемент в тяжелом множестве.Теперь рассмотрим 4 возможных запроса: Добавление к легкому множеству. Пройдем по всем числам множества и к каждому добавим нужное значение. Дальше пройдем по всем тяжелым множествам и к каждому добавим (размер пересечения * значение в запросе). Время работы . Добавление к тяжелому множеству. Просто увеличим счетчик для данного тяжелого множества на значение в запросе. Время работы O(1). Ответ на запрос для легкого множества. Проходим по всем числам, добавляем значения к ответу. Затем проходим по всем тяжелым множествам и добавляем к ответу (добавление для данного тяжелого множества * размер пересечения со множеством в запросе). Время работы . Ответ на запрос для тяжелого множества. Берем уже посчитанный ответ, затем проходим по тяжелым множествам и добавляем (добавление для данного тяжелого множества * размер пересечения со множеством в запросе). Время работы . Итого, если у нас O(n) запросов, то суммарное время работы .348D - ЧерепашкиВ задаче требовалось найти количество пар непересекающихся путей из левого верхнего в правый нижний угол таблицы. Для этого можно воспользоваться следующей леммой. Спасибо rng_58 за ссылку. А именно, если переформулировать применительно к нашему случаю, то лемма утверждает, что если есть множества начальных A = {a1, a2} и конечных B = {b1, b2} точек, то ответ можно посчитать, как следующий определитель: где f(x, y) — количество путей из точки x в точку y. Эту величину уже можно посчитать квадратной динамикой.Наконец, заметим, что для того, чтобы свести исходную задачу к этой, нам нужно сделать пути, которые не имеют совсем совпадающих точек — в исходной задаче разрешаются пересечения в первой и последней точках пути. Для этого в качестве множеств A и B мы можем взять точки A = {(0, 1), (1, 0)} и B = {(n - 2, m - 1), (n - 1, m - 2)}348E - ПилигримыДавайте сначала построим простое решение этой задачи, а затем попробуем решить ее эффективно, учитывая данные ограничения.Для каждой вершины найдем список наиболее удаленных вершин. Найдем вершины на пересечении путей от текущей вершины до каждой вершины из списка, в которых нет монастырей. Если мы удалим любую из этих вершин, то каждая вершина из списка будет недостижима из текущего монастыря. У каждой вершины из этого пересечения увеличим счетчик на единицу. Тогда ответ на задачу – максимум из счетчиков для всех вершин и количество таких максимумов.Теперь решим задачу более эффективно, но используя ту же идею. Подвесим дерево за корень. Будем для каждой вершины искать список наиболее удаленных вершин только в ее поддереве. При обходе дерева в глубину из каждой вершины возвращаем наибольшую глубину в поддереве и номер вершины, на которой он достигается. Среди всех сыновей вершины выберем максимум из глубин. Если максимум достигается один раз, то вернем из текущей вершины тот же ответ, что был возвращен из сына. Если максимум достигается более одного раза, то вернем из текущей вершины номер текущей вершины. По сути, таким образом мы находим LCA всех наиболее удаленных от текущей вершины вершин. Перед выходом из вершины прибавляем единицу на отрезке от текущей вершины до найденного LCA. Это можно сделать, если хранить эйлеров обход графа и использовать дерево отрезков для прибавления на отрезке.Наконец, последний этап решения задачи – решить ее для случая, когда наиболее удаленная вершина или их список находятся необязательно в поддереве текущей вершины. Для решения этой подзадачи используем ту же идею, которая используется при нахождении максимального по длине пути в дереве. Для каждой вершины будем хранить 3 максимума – 3 наиболее удаленные вершины в ее поддереве. Когда мы спускаемся в какое-то поддерево, то передаем заодно и 2 оставшихся максимума. Таким образом, находясь в любой вершине, мы можем решить, существует ли путь не в поддереве (то есть уходящий наверх) такой же или большей длины. Если в поддереве и вне его пути одинаковой длины, то это означает, что для пилигрима из текущего монастыря всегда найдется хотя бы один путь, какой бы город не удалили. Если одна из величин больше, то мы выбираем нужный отрезок в эйлеровом обходе дерева и увеличиваем на нем значение на единицу. Случай, когда есть несколько путей (то есть хотя бы 2) вне поддерева одинаковой максимальной длины, обрабатывается аналогично такому же случаю в поддереве.Поскольку дерево отрезков может отвечать на запрос за O(logN) времени, а задачу LCA можно эффективно решить методом двоичного подъема за то же время, то затраты времени и памяти равны O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 348\\s*D"
          },
          "content_length": 9089
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 3000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[.#]{\" + to_string(m) + \"}\";\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine(pattern, \"line \" + to_string(i+1));\n    }\n\n    ensuref(grid[0][0] == '.', \"The upper-left cell (1,1) must be empty.\");\n    ensuref(grid[n-1][m-1] == '.', \"The lower-right cell (n,m) must be empty.\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 3000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[.#]{\" + to_string(m) + \"}\";\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine(pattern, \"line \" + to_string(i+1));\n    }\n\n    ensuref(grid[0][0] == '.', \"The upper-left cell (1,1) must be empty.\");\n    ensuref(grid[n-1][m-1] == '.', \"The lower-right cell (n,m) must be empty.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 3000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[.#]{\" + to_string(m) + \"}\";\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine(pattern, \"line \" + to_string(i+1));\n    }\n\n    ensuref(grid[0][0] == '.', \"The upper-left cell (1,1) must be empty.\");\n    ensuref(grid[n-1][m-1] == '.', \"The lower-right cell (n,m) must be empty.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 10);\n    string type = opt<string>(\"type\", \"random\");\n    double obstacle_prob = opt<double>(\"obstacle_prob\", 0.2);\n\n    vector<string> grid;\n\n    if (type == \"full\") {\n        // All cells are '.' (no obstacles)\n        grid = vector<string>(n, string(m, '.'));\n\n    } else if (type == \"empty\") {\n        // All cells are '#' except start and end\n        grid = vector<string>(n, string(m, '#'));\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"onepath\") {\n        // Only one path exists\n        grid = vector<string>(n, string(m, '#'));\n        for (int i = 0; i < n; ++i)\n            grid[i][0] = '.';\n        for (int j = 0; j < m; ++j)\n            grid[n - 1][j] = '.';\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"impossible\") {\n        // No paths exist, even for one turtle\n        grid = vector<string>(n, string(m, '.'));\n        if (n > 1)\n            grid[1][0] = '#';\n        if (m > 1)\n            grid[0][1] = '#';\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"zero_paths\") {\n        // Paths exist, but any pair of paths must intersect\n        // For simplicity, we use a fixed small grid\n        n = 3;\n        m = 3;\n        grid = {\n            \"...\",\n            \".#.\",\n            \"...\"\n        };\n\n    } else if (type == \"random\") {\n        // Random obstacles with specified probability\n        grid = vector<string>(n, string(m, '.'));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next(0.0, 1.0) < obstacle_prob)\n                    grid[i][j] = '#';\n        // Ensure start and end are clear\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"checkerboard\") {\n        // Obstacles in a checkerboard pattern\n        grid = vector<string>(n, string(m, '.'));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i + j) % 2 == 1)\n                    grid[i][j] = '#';\n        // Ensure start and end are clear\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"minimum\") {\n        // Minimum size grid: n=2, m=2\n        n = 2;\n        m = 2;\n        grid = vector<string>(n, string(m, '.'));\n\n    } else if (type == \"maximum\") {\n        // Maximum size grid: n=3000, m=3000\n        n = 3000;\n        m = 3000;\n        grid = vector<string>(n, string(m, '.'));\n\n    } else {\n        // Default to random grid if unknown type\n        grid = vector<string>(n, string(m, '.'));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next(0.0, 1.0) < obstacle_prob)\n                    grid[i][j] = '#';\n        // Ensure start and end are clear\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 10);\n    string type = opt<string>(\"type\", \"random\");\n    double obstacle_prob = opt<double>(\"obstacle_prob\", 0.2);\n\n    vector<string> grid;\n\n    if (type == \"full\") {\n        // All cells are '.' (no obstacles)\n        grid = vector<string>(n, string(m, '.'));\n\n    } else if (type == \"empty\") {\n        // All cells are '#' except start and end\n        grid = vector<string>(n, string(m, '#'));\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"onepath\") {\n        // Only one path exists\n        grid = vector<string>(n, string(m, '#'));\n        for (int i = 0; i < n; ++i)\n            grid[i][0] = '.';\n        for (int j = 0; j < m; ++j)\n            grid[n - 1][j] = '.';\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"impossible\") {\n        // No paths exist, even for one turtle\n        grid = vector<string>(n, string(m, '.'));\n        if (n > 1)\n            grid[1][0] = '#';\n        if (m > 1)\n            grid[0][1] = '#';\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"zero_paths\") {\n        // Paths exist, but any pair of paths must intersect\n        // For simplicity, we use a fixed small grid\n        n = 3;\n        m = 3;\n        grid = {\n            \"...\",\n            \".#.\",\n            \"...\"\n        };\n\n    } else if (type == \"random\") {\n        // Random obstacles with specified probability\n        grid = vector<string>(n, string(m, '.'));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next(0.0, 1.0) < obstacle_prob)\n                    grid[i][j] = '#';\n        // Ensure start and end are clear\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"checkerboard\") {\n        // Obstacles in a checkerboard pattern\n        grid = vector<string>(n, string(m, '.'));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i + j) % 2 == 1)\n                    grid[i][j] = '#';\n        // Ensure start and end are clear\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n\n    } else if (type == \"minimum\") {\n        // Minimum size grid: n=2, m=2\n        n = 2;\n        m = 2;\n        grid = vector<string>(n, string(m, '.'));\n\n    } else if (type == \"maximum\") {\n        // Maximum size grid: n=3000, m=3000\n        n = 3000;\n        m = 3000;\n        grid = vector<string>(n, string(m, '.'));\n\n    } else {\n        // Default to random grid if unknown type\n        grid = vector<string>(n, string(m, '.'));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next(0.0, 1.0) < obstacle_prob)\n                    grid[i][j] = '#';\n        // Ensure start and end are clear\n        grid[0][0] = '.';\n        grid[n - 1][m - 1] = '.';\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grid with no obstacles (minimum size)\n./gen -type minimum\n\n# Small grid with all obstacles except start and end (no paths)\n./gen -n 2 -m 2 -type empty\n\n# Small grid where paths exist but any pair of paths must intersect (zero_paths)\n./gen -type zero_paths\n\n# Grid with no possible paths (impossible)\n./gen -n 5 -m 5 -type impossible\n\n# Grid with only one possible path (onepath)\n./gen -n 5 -m 5 -type onepath\n\n# Checkerboard pattern of obstacles in a small grid\n./gen -n 5 -m 5 -type checkerboard\n\n# Random grid with low obstacle probability\n./gen -n 10 -m 10 -type random -obstacle_prob 0.1\n\n# Random grid with high obstacle probability\n./gen -n 10 -m 10 -type random -obstacle_prob 0.5\n\n# Grid with no obstacles (full) at moderate size\n./gen -n 50 -m 50 -type full\n\n# Grid with all obstacles except start and end at moderate size (no paths)\n./gen -n 50 -m 50 -type empty\n\n# Checkerboard pattern in a moderate size grid\n./gen -n 50 -m 50 -type checkerboard\n\n# Random grid with obstacle probability 0.3 at moderate size\n./gen -n 50 -m 50 -type random -obstacle_prob 0.3\n\n# Grid with maximum size and no obstacles\n./gen -type maximum\n\n# Grid with maximum size and checkerboard pattern\n./gen -n 3000 -m 3000 -type checkerboard\n\n# Random grid with obstacle probability 0.05 at maximum size\n./gen -n 3000 -m 3000 -type random -obstacle_prob 0.05\n\n# Random grid with obstacle probability 0.25 at maximum size\n./gen -n 3000 -m 3000 -type random -obstacle_prob 0.25\n\n# Random grid with obstacle probability 0.5 at maximum size\n./gen -n 3000 -m 3000 -type random -obstacle_prob 0.5\n\n# Grid with only one possible path at large size\n./gen -n 3000 -m 3000 -type onepath\n\n# Grid with no possible paths at large size\n./gen -n 3000 -m 3000 -type empty\n\n# Grid where paths exist but any pair must intersect in a larger grid\n./gen -n 10 -m 10 -type zero_paths\n\n# Grid with maximum possible size and no obstacles (testing maximum input constraints)\n./gen -n 3000 -m 3000 -type full\n\n# Grid with maximum size and obstacles in every cell except start and end\n./gen -n 3000 -m 3000 -type empty\n\n# Checkerboard pattern in maximum size grid\n./gen -n 3000 -m 3000 -type checkerboard\n\n# Random grid with obstacle probability 0.01 at maximum size\n./gen -n 3000 -m 3000 -type random -obstacle_prob 0.01\n\n# Random grid with obstacle probability 0.99 at maximum size\n./gen -n 3000 -m 3000 -type random -obstacle_prob 0.99\n\n# Small grid with random obstacles to test randomness\n./gen -n 5 -m 5 -type random -obstacle_prob 0.3\n\n# Moderate grid with random obstacles to test varying obstacle probabilities\n./gen -n 100 -m 100 -type random -obstacle_prob 0.2\n\n# Large grid with random obstacles and medium obstacle probability\n./gen -n 1000 -m 1000 -type random -obstacle_prob 0.4\n\n# Maximum size grid with random obstacles and low obstacle probability\n./gen -n 3000 -m 3000 -type random -obstacle_prob 0.05\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:08.922734",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "348/E",
      "title": "E. Pilgrims",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n (3 ≤ n ≤ 105) and m (2 ≤ m < n). The next line contains m distinct integers representing indices of towns that contain monasteries.Next n - 1 lines contain three integers each, ai, bi, ci, indicating that there is an edge between towns ai and bi of length ci (1 ≤ ai, bi ≤ n, 1 ≤ ci ≤ 1000, ai ≠ bi).",
      "output_spec": "OutputOutput two integers: the maximum number of pilgrims Walter can make unhappy and the number of ways in which he can make his plan come true.",
      "sample_tests": "ExamplesInputCopy8 57 2 5 4 81 2 12 3 21 4 14 5 21 6 16 7 86 8 10OutputCopy5 1",
      "description": "E. Pilgrims\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n (3 ≤ n ≤ 105) and m (2 ≤ m < n). The next line contains m distinct integers representing indices of towns that contain monasteries.Next n - 1 lines contain three integers each, ai, bi, ci, indicating that there is an edge between towns ai and bi of length ci (1 ≤ ai, bi ≤ n, 1 ≤ ci ≤ 1000, ai ≠ bi).\n\nOutputOutput two integers: the maximum number of pilgrims Walter can make unhappy and the number of ways in which he can make his plan come true.\n\nInputCopy8 57 2 5 4 81 2 12 3 21 4 14 5 21 6 16 7 86 8 10OutputCopy5 1\n\nInputCopy8 57 2 5 4 81 2 12 3 21 4 14 5 21 6 16 7 86 8 10\n\nOutputCopy5 1",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #202 will take place today, September 27 at 19:30 MSK.The idea behind the round was born when my friends and I were interning at Facebook this summer. This round probably has the highest number of authors for a Codeforces round to date. The authors of the problems are Azizkhan Almakhan azizkhan, Michael Kolupaev al13n, Filip Hlasek fhlasek, Ivan Mandura budabudimir and myself, Igor Demidov caustique.Maxim Korystov dark_ai, Alexander Fedulin Jughead and Ibragim Ismailov ibra, Vladimir Chalyshev cmd and Sergey Sklyanichenko Sklyack helped us with preparation of the round.The ideas behind the 2 problems were inspired by Anton Ermilov ant.ermilov and Dmitry Krasnov navi-spb.Testers of the round are Alexey Safronov yarrr and Alexey Shmelev ashmelev.I would also like to thank Gerald Agapov Gerald for his help in preparing the contest.I hope you find problems interesting and diverse. I'm sure that everyone will find the problem to their liking.Scores are as usual 500-1000-1500-2000-2500.Good luck and have fun!Congratulations to the winners!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Attention! Editorial for all problems is available!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Editorial for Codeforces Round #202 - Codeforces",
          "content": "349A - Cinema LineIn the problem you need to decide whether cashier can give a change to all customers if the price of the ticket is 25 rubles and there's 3 kinds of bills: 25, 50 and 100 rubles. There's no money in the ticket office in the beginning.Let's consider 3 cases. Customer has 25 rubles hence he doesn't need a change. Customer has 50 rubles hence we have to give him 25 rubles back. Customer has 100 rubles hence we need to give him 75 rubles back. It can be done in 2 ways. 75=25+50 и 75=25+25+25. Notice that it's always worth to try 25+50 first and then 25+25+25. It's true because bills of 25 rubles can be used both to give change for 50 and 100 rubles and bills of 50 rubles can be used only to give change for 100 rubles so we need to save as much 25 ruble bills as possible. The solution is to keep track of the number of 25 and 50 ruble bills and act greedily when giving change to 100 rubles — try 25+50 first and then 25+25+25.349B - Color the FenceIn the problem you're asked to write the largest possible number given number of paint that you have and number of paint that you need to write each digit.Longer number means larger number so it's worth to write the longest possible number. Because of that we choose the largest digit among those that require the least number of paint. Let the number of paint for that digit d be equal to x, and we have v liters of paint total. Then we can write number of the length .Now we know the length of the number, let it be len. Write down temporary result – string of length len, consisting of digits d. We have supply of v–len·x liters of paint. In order to enhance the answer, we can try to update the number from the beginning and swap each digit with the maximal possible. It's true because numbers of the equal length are compared in the highest digits first. Among digits that are greater than current we choose one that we have enough paint for and then update answer and current number of paint.If the length of the answer is 0 then you need to output -1.348A - MafiaIn the problem you need to find out how many games you need to play in order to make all people happy. It means that each of them played as many games as he wanted.Let the answer be x games. Notice that max(a1, a2, …, an) ≤ x. Then i-th player can be game supervisor in x–ai games. If we sum up we get — it's the number of games in which players are ready to be supervisor. This number must be greater or equal to x — our answer. Don't forget about that condition: max(a1, a2, …, an) ≤ x.348B - Apple TreeIn the problem you need to find out minimal number of apples that you need to remove in order to make tree balanced.Notice, that if we know the value in the root then we know values in all other vertices. The value in the leaf is equal to the value in the root divided to the product of the powers of all vertices on the path between root and leaf.For every vertex let's calculate di — minimal number in that vertex (not zero) in order to make tree balanced. For leaves di = 1, for all other vertices di is equal to k·lcm(dj1, dj2, ..., djk), where j1, j2, ..., jk — sons of the vertex i. Let's calculate si — sum in the subtree of the vertex i. All that can be done using one depth first search from the root of the tree.Using second depth first search one can calculate for every vertex maximal number that we can write in it and satisfty all conditions. More precisely, given vertex i and k of its sons j1, j2, ..., jk. Then if m = min(sj1, sj2, ..., sjk) and — minimal number, that we can write to the sons of vertex i, then it's worth to write numbers to the sons of vertex i. Remains we add to the answer.348C - Subset SumsThis problem is about data structures.First step of the solution is to divide sets to heavy and light. Light ones are those that contains less than elements. All other sets are heavy.Key observation is that every light set contains less than elements and number of heavy sets doesn't exceed because we have upper bound for sum of the sizes of all sets.In order to effectively answer queries, for every set (both light and heavy) we calculate size of the intersection of this set and each heavy set. It can be done with time and memory . For every heavy set we create boolean array of size O(n). In i-th cell of this array we store how many elements i in given set. Then for each element and each heavy set we can check for O(1) time whether element is in the set.Now let's consider 4 possible cases: Add to the light set. Traverse all numbers in the set and add the value from the query to each of them. Then traverse all heavy sets and add (size of intersection * the value from the query). Time is . Add to the heavy set. Just update the counter for the heavy set. Time is O(1). Answer to the query for the light set. Traverse all numbers in the set and add values to the answer. Then traverse all heavy sets and add to the answer (answer for this heavy set * size of intersection with the set in the query). Time is . Answer to the query for the heavy set. Take already calculated answer, then traverse all heavy sets and add (answer for this heavy set * size of intersection with the set in the query). Time is . We have O(n) queries so total time is .348D - TurtlesIn the problem you're asked to find the number of pairs of non-intersecting paths between left upper and right lower corners of the grid. You can use following lemma for that. Thanks to rng_58 for the link. More precisely, considering our problem, this lemma states that given sets of initial A = {a1, a2} and final B = {b1, b2} points, the answer is equal to the following determinant: where f(x, y) — is equal to the number of paths from point x to point y. You can calculate this function using dynamic programming.Finally we need to decide what sets of initial and final points we choose. You can take A = {(0, 1), (1, 0)} and B = {(n - 2, m - 1), (n - 1, m - 2)} in order to make paths non-intersecting even in 2 points.348E - PilgrimsLet’s build a simple solution at first and then we will try to improve it to solve problem more effectively given the constraints.For every vertex let’s find the list of the farthest vertices. Let’s find vertices on the intersection of the paths between current vertex and each vertex from the list that don’t contain monasteries. If we remove any of these vertices then every vertex from the list is unreachable from the current monastery. For every vertex from the intersection increment the counter. Then the answer for the problem is the maximum among all counters and the number of such maxima.Let’s solve the problem more effectively using the same idea. Let’s make the tree with root. For every vertex we will find the list of the farthest vertices only in the subtree. While traversing the tree using depth first search we return the largest depth in the subtree and the number of the vertex where it was reached. Among all of the sons of the current vertex we choose the maximum of depths. If maximum is reached one time then we return the same answer that was returned from the son. If the answer was reached more than one time then we return the number of the current vertex. Essentially, we find LCA of the farthest vertices according to the current vertex. Before quitting the vertex we increment the values on the segment between current vertex and found LCA. One can use Eulerian tour and segment tree for adding on the segment.Finally, the last stage of solving the problem – to solve it for the case when the farthest vertex is not in the subtree of the current vertex. For solving of that subproblem we use the same idea that was used in the problem of the finding the maximal path in the tree. For every vertex we keep 3 maximums – 3 farthest vertices in the subtree. When we go down to the subtree, we pass 2 remaining maximums too. In that way, when we’re in any vertex, we can decide whether there’s a path not in the subtree (it means, going up) of the same or larger length. If there’re 2 paths of the same length in the subtree and not in the subtree, it means that for the pilgrim from the current monastery there’s always a path no matter what town was destroyed. If one of the quantities is larger then we choose the segment in Eulerian tour and increment the value on the segment. The case where there’s several paths (at least 2) out of the subtree of the same maximal length, is the same with the case in the subtree.LCA and segment tree can be solved effectively in O(logN) time per query so the total memory and time is O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 348\\s*E"
          },
          "content_length": 8548
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, n - 1, \"m\");\n    inf.readEoln();\n\n    vector<int> monasteries = inf.readInts(m, 1, n, \"monasteries\");\n    inf.readEoln();\n\n    // Check that monasteries are in distinct towns\n    set<int> monastery_set(monasteries.begin(), monasteries.end());\n    ensuref((int)monastery_set.size() == m, \"Monasteries should be in distinct towns\");\n\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        ensuref(a != b, \"Edge cannot connect a node to itself at edge %d\", i + 1);\n        inf.readSpace();\n        int c = inf.readInt(1, 1000, \"ci\");\n        inf.readEoln();\n\n        edges.push_back({a - 1, b - 1}); // Use zero-based indices for DSU\n    }\n\n    // Initialize DSU\n    for (int i = 0; i < n; ++i)\n        parent[i] = i;\n\n    // Check for cycles and build DSU\n    for (int i = 0; i < n - 1; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle involving edge %d\", i + 1);\n        parent[pu] = pv;\n    }\n\n    // Check that the graph is connected\n    int root = find(0);\n    for (int i = 1; i < n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, n - 1, \"m\");\n    inf.readEoln();\n\n    vector<int> monasteries = inf.readInts(m, 1, n, \"monasteries\");\n    inf.readEoln();\n\n    // Check that monasteries are in distinct towns\n    set<int> monastery_set(monasteries.begin(), monasteries.end());\n    ensuref((int)monastery_set.size() == m, \"Monasteries should be in distinct towns\");\n\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        ensuref(a != b, \"Edge cannot connect a node to itself at edge %d\", i + 1);\n        inf.readSpace();\n        int c = inf.readInt(1, 1000, \"ci\");\n        inf.readEoln();\n\n        edges.push_back({a - 1, b - 1}); // Use zero-based indices for DSU\n    }\n\n    // Initialize DSU\n    for (int i = 0; i < n; ++i)\n        parent[i] = i;\n\n    // Check for cycles and build DSU\n    for (int i = 0; i < n - 1; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle involving edge %d\", i + 1);\n        parent[pu] = pv;\n    }\n\n    // Check that the graph is connected\n    int root = find(0);\n    for (int i = 1; i < n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, n - 1, \"m\");\n    inf.readEoln();\n\n    vector<int> monasteries = inf.readInts(m, 1, n, \"monasteries\");\n    inf.readEoln();\n\n    // Check that monasteries are in distinct towns\n    set<int> monastery_set(monasteries.begin(), monasteries.end());\n    ensuref((int)monastery_set.size() == m, \"Monasteries should be in distinct towns\");\n\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        ensuref(a != b, \"Edge cannot connect a node to itself at edge %d\", i + 1);\n        inf.readSpace();\n        int c = inf.readInt(1, 1000, \"ci\");\n        inf.readEoln();\n\n        edges.push_back({a - 1, b - 1}); // Use zero-based indices for DSU\n    }\n\n    // Initialize DSU\n    for (int i = 0; i < n; ++i)\n        parent[i] = i;\n\n    // Check for cycles and build DSU\n    for (int i = 0; i < n - 1; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle involving edge %d\", i + 1);\n        parent[pu] = pv;\n    }\n\n    // Check that the graph is connected\n    int root = find(0);\n    for (int i = 1; i < n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_tree(int n, string tree_type, vector<pair<int,int>>& edges, vector<vector<int>>& adj) {\n    if (tree_type == \"chain\") {\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i+1});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"balanced\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({i/2, i});\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n    // Build adjacency list\n    adj.resize(n + 1);\n    for (auto e : edges) {\n        int u = e.first;\n        int v = e.second;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n}\n\nvoid assign_weights(int n, vector<int>& weights, string weight_type) {\n    if (weight_type == \"uniform\") {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(1);\n        }\n    } else if (weight_type == \"random\") {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(rnd.next(1, 1000));\n        }\n    } else if (weight_type == \"maximal\") {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(1000);\n        }\n    } else if (weight_type == \"minimal\") {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(1);\n        }\n    } else {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(rnd.next(1, 1000));\n        }\n    }\n}\n\nvoid place_monasteries(int n, int m, string monastery_placement, vector<int>& monasteries, vector<vector<int>>& adj) {\n    if (monastery_placement == \"leaves\") {\n        vector<int> leaves;\n        for (int i = 1; i <= n; i++) {\n            if (adj[i].size() == 1) {\n                leaves.push_back(i);\n            }\n        }\n        for (int i = 1; i <= n && (int)leaves.size() < m; i++) {\n            if (adj[i].size() > 1) {\n                leaves.push_back(i);\n            }\n        }\n        shuffle(leaves.begin(), leaves.end());\n        for (int i = 0; i < m && i < (int)leaves.size(); i++) {\n            monasteries.push_back(leaves[i]);\n        }\n    } else if (monastery_placement == \"center\") {\n        vector<pair<int,int>> degree_nodes;\n        for (int i = 1; i <= n; i++) {\n            degree_nodes.push_back({-(int)adj[i].size(), i}); \n        }\n        sort(degree_nodes.begin(), degree_nodes.end());\n        for (int i = 0; i < m && i < n; i++) {\n            monasteries.push_back(degree_nodes[i].second);\n        }\n    } else if (monastery_placement == \"random\") {\n        set<int> st;\n        while ((int)st.size() < m) {\n            int node = rnd.next(1, n);\n            st.insert(node);\n        }\n        for (int node : st) {\n            monasteries.push_back(node);\n        }\n    } else {\n        set<int> st;\n        while ((int)st.size() < m) {\n            int node = rnd.next(1, n);\n            st.insert(node);\n        }\n        for (int node : st) {\n            monasteries.push_back(node);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"type\", \"random\");\n    string monastery_placement = opt<string>(\"monastery\", \"random\");\n    string weight_type = opt<string>(\"weight\", \"random\");\n    vector<pair<int,int>> edges;\n    vector<vector<int>> adj;\n    generate_tree(n, tree_type, edges, adj);\n    vector<int> weights;\n    assign_weights(n, weights, weight_type);\n    vector<int> monasteries;\n    place_monasteries(n, m, monastery_placement, monasteries, adj);\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    sort(monasteries.begin(), monasteries.end());\n    for (int i = 0; i < m; i++) {\n        printf(\"%d%c\", monasteries[i], i == m - 1 ? '\\n' : ' ');\n    }\n    // Shuffle nodes\n    vector<int> perm(n+1);\n    for (int i = 1; i <= n; i++) perm[i] = i;\n    shuffle(perm.begin()+1, perm.end());\n    // Update edges with permutated node indices\n    for (auto &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n        if (rnd.next(0,1)) swap(e.first, e.second); \n    }\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    // Output edges with weights\n    for (int i = 0; i < n - 1; i++) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int c = weights[i];\n        printf(\"%d %d %d\\n\", u, v, c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_tree(int n, string tree_type, vector<pair<int,int>>& edges, vector<vector<int>>& adj) {\n    if (tree_type == \"chain\") {\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i+1});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"balanced\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({i/2, i});\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n    // Build adjacency list\n    adj.resize(n + 1);\n    for (auto e : edges) {\n        int u = e.first;\n        int v = e.second;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n}\n\nvoid assign_weights(int n, vector<int>& weights, string weight_type) {\n    if (weight_type == \"uniform\") {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(1);\n        }\n    } else if (weight_type == \"random\") {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(rnd.next(1, 1000));\n        }\n    } else if (weight_type == \"maximal\") {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(1000);\n        }\n    } else if (weight_type == \"minimal\") {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(1);\n        }\n    } else {\n        for (int i = 0; i < n - 1; i++) {\n            weights.push_back(rnd.next(1, 1000));\n        }\n    }\n}\n\nvoid place_monasteries(int n, int m, string monastery_placement, vector<int>& monasteries, vector<vector<int>>& adj) {\n    if (monastery_placement == \"leaves\") {\n        vector<int> leaves;\n        for (int i = 1; i <= n; i++) {\n            if (adj[i].size() == 1) {\n                leaves.push_back(i);\n            }\n        }\n        for (int i = 1; i <= n && (int)leaves.size() < m; i++) {\n            if (adj[i].size() > 1) {\n                leaves.push_back(i);\n            }\n        }\n        shuffle(leaves.begin(), leaves.end());\n        for (int i = 0; i < m && i < (int)leaves.size(); i++) {\n            monasteries.push_back(leaves[i]);\n        }\n    } else if (monastery_placement == \"center\") {\n        vector<pair<int,int>> degree_nodes;\n        for (int i = 1; i <= n; i++) {\n            degree_nodes.push_back({-(int)adj[i].size(), i}); \n        }\n        sort(degree_nodes.begin(), degree_nodes.end());\n        for (int i = 0; i < m && i < n; i++) {\n            monasteries.push_back(degree_nodes[i].second);\n        }\n    } else if (monastery_placement == \"random\") {\n        set<int> st;\n        while ((int)st.size() < m) {\n            int node = rnd.next(1, n);\n            st.insert(node);\n        }\n        for (int node : st) {\n            monasteries.push_back(node);\n        }\n    } else {\n        set<int> st;\n        while ((int)st.size() < m) {\n            int node = rnd.next(1, n);\n            st.insert(node);\n        }\n        for (int node : st) {\n            monasteries.push_back(node);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"type\", \"random\");\n    string monastery_placement = opt<string>(\"monastery\", \"random\");\n    string weight_type = opt<string>(\"weight\", \"random\");\n    vector<pair<int,int>> edges;\n    vector<vector<int>> adj;\n    generate_tree(n, tree_type, edges, adj);\n    vector<int> weights;\n    assign_weights(n, weights, weight_type);\n    vector<int> monasteries;\n    place_monasteries(n, m, monastery_placement, monasteries, adj);\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    sort(monasteries.begin(), monasteries.end());\n    for (int i = 0; i < m; i++) {\n        printf(\"%d%c\", monasteries[i], i == m - 1 ? '\\n' : ' ');\n    }\n    // Shuffle nodes\n    vector<int> perm(n+1);\n    for (int i = 1; i <= n; i++) perm[i] = i;\n    shuffle(perm.begin()+1, perm.end());\n    // Update edges with permutated node indices\n    for (auto &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n        if (rnd.next(0,1)) swap(e.first, e.second); \n    }\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    // Output edges with weights\n    for (int i = 0; i < n - 1; i++) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int c = weights[i];\n        printf(\"%d %d %d\\n\", u, v, c);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 2 -type chain -monastery leaves -weight minimal\n./gen -n 100000 -m 2 -type chain -monastery leaves -weight minimal\n./gen -n 100000 -m 99999 -type chain -monastery leaves -weight minimal\n./gen -n 100000 -m 50000 -type random -monastery random -weight random\n./gen -n 100000 -m 50000 -type balanced -monastery random -weight random\n./gen -n 100000 -m 2 -type star -monastery leaves -weight maximal\n./gen -n 100000 -m 50000 -type chain -monastery leaves -weight maximal\n./gen -n 100000 -m 50000 -type chain -monastery leaves -weight minimal\n./gen -n 100000 -m 25000 -type random -monastery random -weight uniform\n./gen -n 100000 -m 1000 -type balanced -monastery center -weight random\n./gen -n 100000 -m 1000 -type star -monastery center -weight random\n./gen -n 100000 -m 20000 -type random -monastery leaves -weight random\n./gen -n 100000 -m 1000 -type chain -monastery random -weight random\n./gen -n 10 -m 5 -type random -monastery random -weight random\n./gen -n 10 -m 9 -type balanced -monastery center -weight uniform\n./gen -n 100 -m 99 -type star -monastery random -weight maximal\n./gen -n 100000 -m 2 -type random -monastery random -weight random\n./gen -n 100000 -m 50000 -type random -monastery random -weight maximal\n./gen -n 100000 -m 50000 -type random -monastery random -weight minimal\n./gen -n 100000 -m 50000 -type random -monastery random -weight random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:10.999021",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "349/A",
      "title": "A. Очередь в кино",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество людей в очереди. В следующей строке записаны n целых чисел, каждое из которых равно 25, 50 или 100 — номиналы купюр у людей. Числа заданы в порядке от начала очереди (от кассы) к концу очереди.",
      "output_spec": "Выходные данныеВыведите «YES» (без кавычек) если кассир сможет продать билет каждому и выдать сдачу, или «NO» (без кавычек) иначе.",
      "sample_tests": "ПримерыВходные данныеСкопировать425 25 50 50Выходные данныеСкопироватьYESВходные данныеСкопировать225 100Выходные данныеСкопироватьNOВходные данныеСкопировать450 50 25 25Выходные данныеСкопироватьNO",
      "description": "A. Очередь в кино\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество людей в очереди. В следующей строке записаны n целых чисел, каждое из которых равно 25, 50 или 100 — номиналы купюр у людей. Числа заданы в порядке от начала очереди (от кассы) к концу очереди.\n\nВходные данные\n\nВыходные данныеВыведите «YES» (без кавычек) если кассир сможет продать билет каждому и выдать сдачу, или «NO» (без кавычек) иначе.\n\nВыходные данные\n\nВходные данныеСкопировать425 25 50 50Выходные данныеСкопироватьYESВходные данныеСкопировать225 100Выходные данныеСкопироватьNOВходные данныеСкопировать450 50 25 25Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать425 25 50 50\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать225 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать450 50 25 25\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Привет, Codeforces!Сегодня, 27 сентября в 19:30 МСК, состоится Codeforces Round #202.Идея раунда зародилась у меня и моих друзей, когда мы стажировались в Facebook этим летом. Возможно, у этого раунда рекордное для Codeforces количество авторов. Авторами задач стали Азизхан Алмахан azizkhan, Михаил Колупаев al13n, Филип Хласек fhlasek, Иван Мандура budabudimir и я, Игорь Демидов caustique.В подготовке раунда нам помогали Максим Корыстов dark_ai, Александр Федулин Jughead, Ибрагим Исмаилов ibra, Владимир Чалышев cmd и Сергей Скляниченко Sklyack.Идеи 2 задач мне подали Антон Ермилов ant.ermilov и Дмитрий Краснов navi-spb.Тестировали раунд Алексей Сафронов yarrr и Алексей Шмелев ashmelev.Также я хотел бы поблагодарить Геральда Агапова Gerald за помощь в подготовке контеста.Надеюсь, задачи Вам покажутся разнообразными и интересными. Уверен, что каждый найдет себе задачу по вкусу.Разбалловка стандартная 500-1000-1500-2000-2500.Желаю удачи и удовольствия от решения задач!Поздравляем победителей!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Внимание! Появился разбор всех задач на обоих языках!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1183
        },
        {
          "title": "Разбор задач Codeforces Round #202 - Codeforces",
          "content": "349A - Очередь в киноВ задаче требовалось выяснить, может ли кассир выдать сдачу всем посетителям кинотеатра, если билет стоит 25 рублей, у посетителей купюры номиналом 25, 50 и 100 и в кассе изначально нет денег.Рассмотрим 3 различных случая. Если у посетителя 25 рублей, то сдачу ему давать не нужно. Если у посетителя 50 рублей, то мы должны дать ему 25 рублей сдачи. Если у посетителя 100 рублей, то мы должны дать ему 75 рублей сдачи. Это можно сделать двумя способами. 75=25+50 и 75=25+25+25. Заметим, что всегда выгодно попробовать сначала первый способ, а потом второй. Это верно потому, что купюры номиналом 25 рублей могут быть использован как для выдачи сдачи на 50 рублей, так и на 100 рублей, а сами купюры номиналом 50 рублей могут использоваться только для выдачи сдачи на 100 рублей. Таким образом решение – поддерживать количество купюр номиналом 25 и 50 рублей и при выдаче сдачи на 100 рублей действовать жадно – сначала пробовать выдать 25+50 рублей, а иначе 25+25+25 рублей.349B - Раскраска забораВ задаче требовалось выяснить наибольшее число, которое можно написать, используя заданное количество краски, если на каждую цифру тратится также известное количество краски.Поскольку чем длиннее число, тем оно больше, нам выгодно написать число наибольшей длины. Для этого выберем цифру, на которую нужно меньше всего краски. Пусть количество краски для написания этой цифры d равно x, а всего у нас есть v литров краски. Тогда мы можем написать число длины .Таким образом мы выяснили длину числа, пусть она равна len. Запишем промежуточный результат – строку длины len, состоящую из цифр d. У нас в запасе еще осталось v–len·x краски. Чтобы улучшить ответ, будем идти от начала числа и пробовать заменить каждую цифру на максимально возможную. Это верно потому, что числа одинаковой длины сравниваются сначала по старшим разрядам. Среди цифр больше текущей выбираем максимальную среди тех, на которую хватает краски, и обновляем текущее количество краски и ответ.Если ответ длины 0, то нужно вывести -1.348A - МафияВ задаче требовалось определить, сколько игр нужно сыграть, чтобы все игроки остались довольны и сыграли как минимум столько игр, сколько они хотят.Пусть ответ – это x игр. Заметим, что max(a1, a2, …, an) ≤ x. Тогда i-ый игрок может в x–ai играх быть ведущим. Если просуммировать по всем игрокам, то получим — это количество игр, в которых игроки согласны быть ведущими. Это число должно быть не меньше x — нашего ответа. Также следует не забыть требование, что max(a1, a2, …, an) ≤ x.348B - ЯблоняВ задаче требовалось выяснить, какое минимальное количество яблок нужно удалить, чтобы сделать дерево сбалансированным.Заметим, что если мы знаем значение в корне, то знаем значения во всех остальных вершинах. Значение в листе равняется значению в корне, поделенному на произведение степеней вершин на пути от корня до листа.Для каждой вершины посчитаем величину di — какое минимальное число (не ноль) в ней должно быть записано, чтобы дерево по-прежнему могло быть сбалансированным. Для листьев di = 1, для остальных вершин di равен k·lcm(dj1, dj2, ..., djk), где j1, j2, ..., jk — сыновья вершины i. Также посчитаем величину si — сумму в поддереве вершины i. Все это можно сделать за один обход в глубину из корня дерева.Вторым обходом в глубину мы можем посчитать для каждой вершины максимальное число, которое мы в нее можем записать, так чтобы удовлетворить ограничениям. А именно, пусть дана вершина i и k ее сыновей j1, j2, ..., jk. Тогда если m = min(sj1, sj2, ..., sjk), а — минимальное число, которое мы можем записать в сыновей вершины i, нам выгодно записать в сыновей вершины i числа . Остатки, а именно , добавим к ответу.348C - Суммы подмножествВ этой задаче на структуры данных требовалось использовать корневую эвристику или, по-другому, sqrt-декомпозицию.Первый шаг решения состоял в том, чтобы разделить множества на легкие и тяжелые. Легкими назовем множества, которые содержат меньше элементов, а тяжелыми все остальные.Ключевое наблюдение. В любом легком множестве меньше элементов, а количество тяжелых множеств также не превосходит , так как есть ограничение на сумму размеров множеств.Чтобы эффективно отвечать на запросы, для каждого множества (как легкого, так и тяжелого) посчитаем размеры его пересечения со всеми тяжелыми множествами. Это можно сделать за время и память . Для каждого тяжелого множества создадим булевский массив размера O(n), в i-ой ячейке которого будем хранить, сколько элементов i в этом множестве. Затем для каждого элемента и каждого тяжелого множества будем за O(1) проверять, содержится ли элемент в тяжелом множестве.Теперь рассмотрим 4 возможных запроса: Добавление к легкому множеству. Пройдем по всем числам множества и к каждому добавим нужное значение. Дальше пройдем по всем тяжелым множествам и к каждому добавим (размер пересечения * значение в запросе). Время работы . Добавление к тяжелому множеству. Просто увеличим счетчик для данного тяжелого множества на значение в запросе. Время работы O(1). Ответ на запрос для легкого множества. Проходим по всем числам, добавляем значения к ответу. Затем проходим по всем тяжелым множествам и добавляем к ответу (добавление для данного тяжелого множества * размер пересечения со множеством в запросе). Время работы . Ответ на запрос для тяжелого множества. Берем уже посчитанный ответ, затем проходим по тяжелым множествам и добавляем (добавление для данного тяжелого множества * размер пересечения со множеством в запросе). Время работы . Итого, если у нас O(n) запросов, то суммарное время работы .348D - ЧерепашкиВ задаче требовалось найти количество пар непересекающихся путей из левого верхнего в правый нижний угол таблицы. Для этого можно воспользоваться следующей леммой. Спасибо rng_58 за ссылку. А именно, если переформулировать применительно к нашему случаю, то лемма утверждает, что если есть множества начальных A = {a1, a2} и конечных B = {b1, b2} точек, то ответ можно посчитать, как следующий определитель: где f(x, y) — количество путей из точки x в точку y. Эту величину уже можно посчитать квадратной динамикой.Наконец, заметим, что для того, чтобы свести исходную задачу к этой, нам нужно сделать пути, которые не имеют совсем совпадающих точек — в исходной задаче разрешаются пересечения в первой и последней точках пути. Для этого в качестве множеств A и B мы можем взять точки A = {(0, 1), (1, 0)} и B = {(n - 2, m - 1), (n - 1, m - 2)}348E - ПилигримыДавайте сначала построим простое решение этой задачи, а затем попробуем решить ее эффективно, учитывая данные ограничения.Для каждой вершины найдем список наиболее удаленных вершин. Найдем вершины на пересечении путей от текущей вершины до каждой вершины из списка, в которых нет монастырей. Если мы удалим любую из этих вершин, то каждая вершина из списка будет недостижима из текущего монастыря. У каждой вершины из этого пересечения увеличим счетчик на единицу. Тогда ответ на задачу – максимум из счетчиков для всех вершин и количество таких максимумов.Теперь решим задачу более эффективно, но используя ту же идею. Подвесим дерево за корень. Будем для каждой вершины искать список наиболее удаленных вершин только в ее поддереве. При обходе дерева в глубину из каждой вершины возвращаем наибольшую глубину в поддереве и номер вершины, на которой он достигается. Среди всех сыновей вершины выберем максимум из глубин. Если максимум достигается один раз, то вернем из текущей вершины тот же ответ, что был возвращен из сына. Если максимум достигается более одного раза, то вернем из текущей вершины номер текущей вершины. По сути, таким образом мы находим LCA всех наиболее удаленных от текущей вершины вершин. Перед выходом из вершины прибавляем единицу на отрезке от текущей вершины до найденного LCA. Это можно сделать, если хранить эйлеров обход графа и использовать дерево отрезков для прибавления на отрезке.Наконец, последний этап решения задачи – решить ее для случая, когда наиболее удаленная вершина или их список находятся необязательно в поддереве текущей вершины. Для решения этой подзадачи используем ту же идею, которая используется при нахождении максимального по длине пути в дереве. Для каждой вершины будем хранить 3 максимума – 3 наиболее удаленные вершины в ее поддереве. Когда мы спускаемся в какое-то поддерево, то передаем заодно и 2 оставшихся максимума. Таким образом, находясь в любой вершине, мы можем решить, существует ли путь не в поддереве (то есть уходящий наверх) такой же или большей длины. Если в поддереве и вне его пути одинаковой длины, то это означает, что для пилигрима из текущего монастыря всегда найдется хотя бы один путь, какой бы город не удалили. Если одна из величин больше, то мы выбираем нужный отрезок в эйлеровом обходе дерева и увеличиваем на нем значение на единицу. Случай, когда есть несколько путей (то есть хотя бы 2) вне поддерева одинаковой максимальной длины, обрабатывается аналогично такому же случаю в поддереве.Поскольку дерево отрезков может отвечать на запрос за O(logN) времени, а задачу LCA можно эффективно решить методом двоичного подъема за то же время, то затраты времени и памяти равны O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 349\\s*A"
          },
          "content_length": 9089
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> bills = inf.readInts(n, 25, 100, \"bills\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int bill = bills[i];\n        ensuref(bill == 25 || bill == 50 || bill == 100,\n                \"bill[%d] should be 25, 50, or 100, but found %d\", i + 1, bill);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> bills = inf.readInts(n, 25, 100, \"bills\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int bill = bills[i];\n        ensuref(bill == 25 || bill == 50 || bill == 100,\n                \"bill[%d] should be 25, 50, or 100, but found %d\", i + 1, bill);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> bills = inf.readInts(n, 25, 100, \"bills\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int bill = bills[i];\n        ensuref(bill == 25 || bill == 50 || bill == 100,\n                \"bill[%d] should be 25, 50, or 100, but found %d\", i + 1, bill);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> bills(n);\n\n    static const int bills_options[] = {25,50,100};\n\n    if (type == \"all25\") {\n        // All customers have 25 rubles bills.\n        fill(bills.begin(), bills.end(), 25);\n    } else if (type == \"all50\") {\n        // All customers have 50 rubles bills.\n        fill(bills.begin(), bills.end(), 50);\n    } else if (type == \"all100\") {\n        // All customers have 100 rubles bills.\n        fill(bills.begin(), bills.end(), 100);\n    } else if (type == \"random\") {\n        // Random bills\n        for (int i = 0; i < n; ++i) {\n            bills[i] = bills_options[rnd.next(3)];\n        }\n    } else if (type == \"fail_early\") {\n        // The clerk cannot make change early in the line\n        // For example, first customer has 50 rubles\n        if (n >= 1)\n            bills[0] = 50;\n        for (int i = 1; i < n; ++i) {\n            bills[i] = 25;\n        }\n    } else if (type == \"fail_late\") {\n        // The clerk cannot make change later in the line\n        // Build up some 25s and 50s, then 100s when clerk cannot make change\n        int limit = max(1, n/2);\n        for (int i = 0; i < limit; ++i) {\n            bills[i] = 25;\n        }\n        for (int i = limit; i < n; ++i) {\n            bills[i] = 100;\n        }\n    } else if (type == \"altern25_50\") {\n        // Alternating 25 and 50 rubles bills\n        for (int i = 0; i < n; ++i) {\n            bills[i] = (i % 2 == 0) ? 25 : 50;\n        }\n    } else if (type == \"altern25_100\") {\n        // Alternating 25 and 100 rubles bills\n        for (int i = 0; i < n; ++i) {\n            bills[i] = (i % 2 == 0) ? 25 : 100;\n        }\n    } else if (type == \"stress\") {\n        // Max n, random bills with more 50s and 100s\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(5);\n            if (x <= 1)\n                bills[i] = 25;\n            else if (x <= 3)\n                bills[i] = 50;\n            else\n                bills[i] = 100;\n        }\n    } else if (type == \"tricky\") {\n        // A tricky case designed to expose specific logic errors\n        // E.g., the clerk has a choice between giving change with 50+25 or three 25s.\n        if (n >= 6) {\n            bills[0] = 25;\n            bills[1] = 25;\n            bills[2] = 50;\n            bills[3] = 50;\n            bills[4] = 100;\n            bills[5] = 100;\n            for (int i = 6; i < n; ++i) {\n                bills[i] = bills_options[rnd.next(3)];\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < n; ++i) {\n                bills[i] = bills_options[rnd.next(3)];\n            }\n        }\n    } else if (type == \"max_random\") {\n        // Max n, random bills\n        for (int i = 0; i < n; ++i) {\n            bills[i] = bills_options[rnd.next(3)];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            bills[i] = bills_options[rnd.next(3)];\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bills[i], i + 1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> bills(n);\n\n    static const int bills_options[] = {25,50,100};\n\n    if (type == \"all25\") {\n        // All customers have 25 rubles bills.\n        fill(bills.begin(), bills.end(), 25);\n    } else if (type == \"all50\") {\n        // All customers have 50 rubles bills.\n        fill(bills.begin(), bills.end(), 50);\n    } else if (type == \"all100\") {\n        // All customers have 100 rubles bills.\n        fill(bills.begin(), bills.end(), 100);\n    } else if (type == \"random\") {\n        // Random bills\n        for (int i = 0; i < n; ++i) {\n            bills[i] = bills_options[rnd.next(3)];\n        }\n    } else if (type == \"fail_early\") {\n        // The clerk cannot make change early in the line\n        // For example, first customer has 50 rubles\n        if (n >= 1)\n            bills[0] = 50;\n        for (int i = 1; i < n; ++i) {\n            bills[i] = 25;\n        }\n    } else if (type == \"fail_late\") {\n        // The clerk cannot make change later in the line\n        // Build up some 25s and 50s, then 100s when clerk cannot make change\n        int limit = max(1, n/2);\n        for (int i = 0; i < limit; ++i) {\n            bills[i] = 25;\n        }\n        for (int i = limit; i < n; ++i) {\n            bills[i] = 100;\n        }\n    } else if (type == \"altern25_50\") {\n        // Alternating 25 and 50 rubles bills\n        for (int i = 0; i < n; ++i) {\n            bills[i] = (i % 2 == 0) ? 25 : 50;\n        }\n    } else if (type == \"altern25_100\") {\n        // Alternating 25 and 100 rubles bills\n        for (int i = 0; i < n; ++i) {\n            bills[i] = (i % 2 == 0) ? 25 : 100;\n        }\n    } else if (type == \"stress\") {\n        // Max n, random bills with more 50s and 100s\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(5);\n            if (x <= 1)\n                bills[i] = 25;\n            else if (x <= 3)\n                bills[i] = 50;\n            else\n                bills[i] = 100;\n        }\n    } else if (type == \"tricky\") {\n        // A tricky case designed to expose specific logic errors\n        // E.g., the clerk has a choice between giving change with 50+25 or three 25s.\n        if (n >= 6) {\n            bills[0] = 25;\n            bills[1] = 25;\n            bills[2] = 50;\n            bills[3] = 50;\n            bills[4] = 100;\n            bills[5] = 100;\n            for (int i = 6; i < n; ++i) {\n                bills[i] = bills_options[rnd.next(3)];\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < n; ++i) {\n                bills[i] = bills_options[rnd.next(3)];\n            }\n        }\n    } else if (type == \"max_random\") {\n        // Max n, random bills\n        for (int i = 0; i < n; ++i) {\n            bills[i] = bills_options[rnd.next(3)];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            bills[i] = bills_options[rnd.next(3)];\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bills[i], i + 1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all25\n./gen -n 1 -type all50\n./gen -n 1 -type all100\n\n./gen -n 2 -type all25\n./gen -n 2 -type all50\n./gen -n 2 -type all100\n./gen -n 2 -type altern25_50\n./gen -n 2 -type altern25_100\n\n./gen -n 4 -type fail_early\n./gen -n 4 -type fail_late\n./gen -n 4 -type tricky\n\n./gen -n 5 -type random\n\n./gen -n 10 -type random\n./gen -n 10 -type altern25_50\n./gen -n 10 -type altern25_100\n\n./gen -n 20 -type random\n\n./gen -n 50 -type all25\n\n./gen -n 100 -type random\n./gen -n 100 -type stress\n\n./gen -n 1000 -type max_random\n./gen -n 1000 -type stress\n\n./gen -n 5000 -type fail_late\n\n./gen -n 10000 -type random\n\n./gen -n 50000 -type altern25_100\n./gen -n 50000 -type tricky\n\n./gen -n 99999 -type random\n\n./gen -n 100000 -type all25\n./gen -n 100000 -type all50\n./gen -n 100000 -type random\n./gen -n 100000 -type max_random\n./gen -n 100000 -type stress\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:13.087304",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "349/B",
      "title": "B. Color the Fence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a positive integer v (0 ≤ v ≤ 106). The second line contains nine positive integers a1, a2, ..., a9 (1 ≤ ai ≤ 105).",
      "output_spec": "OutputPrint the maximum number Igor can write on the fence. If he has too little paint for any digit (so, he cannot write anything), print -1.",
      "sample_tests": "ExamplesInputCopy55 4 3 2 1 2 3 4 5OutputCopy55555InputCopy29 11 1 12 5 8 9 10 6OutputCopy33InputCopy01 1 1 1 1 1 1 1 1OutputCopy-1",
      "description": "B. Color the Fence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a positive integer v (0 ≤ v ≤ 106). The second line contains nine positive integers a1, a2, ..., a9 (1 ≤ ai ≤ 105).\n\nOutputPrint the maximum number Igor can write on the fence. If he has too little paint for any digit (so, he cannot write anything), print -1.\n\nInputCopy55 4 3 2 1 2 3 4 5OutputCopy55555InputCopy29 11 1 12 5 8 9 10 6OutputCopy33InputCopy01 1 1 1 1 1 1 1 1OutputCopy-1\n\nInputCopy55 4 3 2 1 2 3 4 5\n\nOutputCopy55555\n\nInputCopy29 11 1 12 5 8 9 10 6\n\nOutputCopy33\n\nInputCopy01 1 1 1 1 1 1 1 1\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #202 will take place today, September 27 at 19:30 MSK.The idea behind the round was born when my friends and I were interning at Facebook this summer. This round probably has the highest number of authors for a Codeforces round to date. The authors of the problems are Azizkhan Almakhan azizkhan, Michael Kolupaev al13n, Filip Hlasek fhlasek, Ivan Mandura budabudimir and myself, Igor Demidov caustique.Maxim Korystov dark_ai, Alexander Fedulin Jughead and Ibragim Ismailov ibra, Vladimir Chalyshev cmd and Sergey Sklyanichenko Sklyack helped us with preparation of the round.The ideas behind the 2 problems were inspired by Anton Ermilov ant.ermilov and Dmitry Krasnov navi-spb.Testers of the round are Alexey Safronov yarrr and Alexey Shmelev ashmelev.I would also like to thank Gerald Agapov Gerald for his help in preparing the contest.I hope you find problems interesting and diverse. I'm sure that everyone will find the problem to their liking.Scores are as usual 500-1000-1500-2000-2500.Good luck and have fun!Congratulations to the winners!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Attention! Editorial for all problems is available!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Editorial for Codeforces Round #202 - Codeforces",
          "content": "349A - Cinema LineIn the problem you need to decide whether cashier can give a change to all customers if the price of the ticket is 25 rubles and there's 3 kinds of bills: 25, 50 and 100 rubles. There's no money in the ticket office in the beginning.Let's consider 3 cases. Customer has 25 rubles hence he doesn't need a change. Customer has 50 rubles hence we have to give him 25 rubles back. Customer has 100 rubles hence we need to give him 75 rubles back. It can be done in 2 ways. 75=25+50 и 75=25+25+25. Notice that it's always worth to try 25+50 first and then 25+25+25. It's true because bills of 25 rubles can be used both to give change for 50 and 100 rubles and bills of 50 rubles can be used only to give change for 100 rubles so we need to save as much 25 ruble bills as possible. The solution is to keep track of the number of 25 and 50 ruble bills and act greedily when giving change to 100 rubles — try 25+50 first and then 25+25+25.349B - Color the FenceIn the problem you're asked to write the largest possible number given number of paint that you have and number of paint that you need to write each digit.Longer number means larger number so it's worth to write the longest possible number. Because of that we choose the largest digit among those that require the least number of paint. Let the number of paint for that digit d be equal to x, and we have v liters of paint total. Then we can write number of the length .Now we know the length of the number, let it be len. Write down temporary result – string of length len, consisting of digits d. We have supply of v–len·x liters of paint. In order to enhance the answer, we can try to update the number from the beginning and swap each digit with the maximal possible. It's true because numbers of the equal length are compared in the highest digits first. Among digits that are greater than current we choose one that we have enough paint for and then update answer and current number of paint.If the length of the answer is 0 then you need to output -1.348A - MafiaIn the problem you need to find out how many games you need to play in order to make all people happy. It means that each of them played as many games as he wanted.Let the answer be x games. Notice that max(a1, a2, …, an) ≤ x. Then i-th player can be game supervisor in x–ai games. If we sum up we get — it's the number of games in which players are ready to be supervisor. This number must be greater or equal to x — our answer. Don't forget about that condition: max(a1, a2, …, an) ≤ x.348B - Apple TreeIn the problem you need to find out minimal number of apples that you need to remove in order to make tree balanced.Notice, that if we know the value in the root then we know values in all other vertices. The value in the leaf is equal to the value in the root divided to the product of the powers of all vertices on the path between root and leaf.For every vertex let's calculate di — minimal number in that vertex (not zero) in order to make tree balanced. For leaves di = 1, for all other vertices di is equal to k·lcm(dj1, dj2, ..., djk), where j1, j2, ..., jk — sons of the vertex i. Let's calculate si — sum in the subtree of the vertex i. All that can be done using one depth first search from the root of the tree.Using second depth first search one can calculate for every vertex maximal number that we can write in it and satisfty all conditions. More precisely, given vertex i and k of its sons j1, j2, ..., jk. Then if m = min(sj1, sj2, ..., sjk) and — minimal number, that we can write to the sons of vertex i, then it's worth to write numbers to the sons of vertex i. Remains we add to the answer.348C - Subset SumsThis problem is about data structures.First step of the solution is to divide sets to heavy and light. Light ones are those that contains less than elements. All other sets are heavy.Key observation is that every light set contains less than elements and number of heavy sets doesn't exceed because we have upper bound for sum of the sizes of all sets.In order to effectively answer queries, for every set (both light and heavy) we calculate size of the intersection of this set and each heavy set. It can be done with time and memory . For every heavy set we create boolean array of size O(n). In i-th cell of this array we store how many elements i in given set. Then for each element and each heavy set we can check for O(1) time whether element is in the set.Now let's consider 4 possible cases: Add to the light set. Traverse all numbers in the set and add the value from the query to each of them. Then traverse all heavy sets and add (size of intersection * the value from the query). Time is . Add to the heavy set. Just update the counter for the heavy set. Time is O(1). Answer to the query for the light set. Traverse all numbers in the set and add values to the answer. Then traverse all heavy sets and add to the answer (answer for this heavy set * size of intersection with the set in the query). Time is . Answer to the query for the heavy set. Take already calculated answer, then traverse all heavy sets and add (answer for this heavy set * size of intersection with the set in the query). Time is . We have O(n) queries so total time is .348D - TurtlesIn the problem you're asked to find the number of pairs of non-intersecting paths between left upper and right lower corners of the grid. You can use following lemma for that. Thanks to rng_58 for the link. More precisely, considering our problem, this lemma states that given sets of initial A = {a1, a2} and final B = {b1, b2} points, the answer is equal to the following determinant: where f(x, y) — is equal to the number of paths from point x to point y. You can calculate this function using dynamic programming.Finally we need to decide what sets of initial and final points we choose. You can take A = {(0, 1), (1, 0)} and B = {(n - 2, m - 1), (n - 1, m - 2)} in order to make paths non-intersecting even in 2 points.348E - PilgrimsLet’s build a simple solution at first and then we will try to improve it to solve problem more effectively given the constraints.For every vertex let’s find the list of the farthest vertices. Let’s find vertices on the intersection of the paths between current vertex and each vertex from the list that don’t contain monasteries. If we remove any of these vertices then every vertex from the list is unreachable from the current monastery. For every vertex from the intersection increment the counter. Then the answer for the problem is the maximum among all counters and the number of such maxima.Let’s solve the problem more effectively using the same idea. Let’s make the tree with root. For every vertex we will find the list of the farthest vertices only in the subtree. While traversing the tree using depth first search we return the largest depth in the subtree and the number of the vertex where it was reached. Among all of the sons of the current vertex we choose the maximum of depths. If maximum is reached one time then we return the same answer that was returned from the son. If the answer was reached more than one time then we return the number of the current vertex. Essentially, we find LCA of the farthest vertices according to the current vertex. Before quitting the vertex we increment the values on the segment between current vertex and found LCA. One can use Eulerian tour and segment tree for adding on the segment.Finally, the last stage of solving the problem – to solve it for the case when the farthest vertex is not in the subtree of the current vertex. For solving of that subproblem we use the same idea that was used in the problem of the finding the maximal path in the tree. For every vertex we keep 3 maximums – 3 farthest vertices in the subtree. When we go down to the subtree, we pass 2 remaining maximums too. In that way, when we’re in any vertex, we can decide whether there’s a path not in the subtree (it means, going up) of the same or larger length. If there’re 2 paths of the same length in the subtree and not in the subtree, it means that for the pilgrim from the current monastery there’s always a path no matter what town was destroyed. If one of the quantities is larger then we choose the segment in Eulerian tour and increment the value on the segment. The case where there’s several paths (at least 2) out of the subtree of the same maximal length, is the same with the case in the subtree.LCA and segment tree can be solved effectively in O(logN) time per query so the total memory and time is O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 349\\s*B"
          },
          "content_length": 8548
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int v = inf.readInt(0, 1000000, \"v\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(9, 1, 100000);\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int v = inf.readInt(0, 1000000, \"v\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(9, 1, 100000);\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int v = inf.readInt(0, 1000000, \"v\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(9, 1, 100000);\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read input from the input file\n    int v = inf.readInt(0, 1000000, \"v\");\n    vector<int> cost(10); // cost[1..9], cost[0] is unused\n    for (int i = 1; i <= 9; ++i) {\n        cost[i] = inf.readInt(1, 100000, format(\"a%d\", i).c_str());\n    }\n    \n    // Compute the minimum cost among all digits\n    int min_cost = *min_element(cost.begin() + 1, cost.end());\n    if (min_cost > v) {\n        // Igor cannot write any digit\n        min_cost = v + 1; // Ensure min_cost > v\n    }\n    \n    // Calculate the maximum length of the number Igor can write\n    int max_len = v / min_cost;\n    \n    // Generate the maximum possible number (as a string)\n    string max_number = \"\";\n    if (max_len == 0) {\n        max_number = \"-1\";\n    } else {\n        int remaining_paint = v;\n        for (int i = 0; i < max_len; ++i) {\n            // Try to place the largest possible digit at each position\n            for (int d = 9; d >= 1; --d) {\n                int cost_diff = cost[d] - min_cost;\n                if (remaining_paint - cost[d] >= (max_len - i - 1) * min_cost &&\n                    remaining_paint >= cost[d]) {\n                    max_number += char('0' + d);\n                    remaining_paint -= cost[d];\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Read the contestant's output\n    string contestant_output = ouf.readString();\n    \n    // Helper function to check if a string represents a valid number\n    auto is_valid_number = [](const string& s) {\n        for (char c : s) {\n            if (!isdigit(c) || c == '0') return false;\n        }\n        return true;\n    };\n    \n    // Check if the contestant's output is \"-1\"\n    if (contestant_output == \"-1\") {\n        if (max_number == \"-1\") {\n            quitf(_ok, \"Correctly reported that no number can be written.\");\n        } else {\n            quitf(_wa, \"A number can be written, but contestant reported -1.\");\n        }\n    } else {\n        // Validate the contestant's output\n        if (!is_valid_number(contestant_output)) {\n            quitf(_wa, \"Output contains invalid characters or zeros.\");\n        }\n        // Check if the total cost does not exceed v\n        long long total_cost = 0;\n        for (char c : contestant_output) {\n            int d = c - '0';\n            total_cost += cost[d];\n            if (total_cost > v) {\n                quitf(_wa, \"Total cost exceeds v.\");\n            }\n        }\n        if (total_cost > v) {\n            quitf(_wa, \"Total cost exceeds v.\");\n        }\n        // Check if the contestant's number is of maximum possible length\n        if ((int)contestant_output.size() < max_len) {\n            quitf(_wa, \"Number is shorter than maximum possible length.\");\n        }\n        // Check if the contestant's number is the maximal possible number\n        if ((int)contestant_output.size() == max_len) {\n            if (contestant_output < max_number) {\n                quitf(_wa, \"Number is not the maximum possible value.\");\n            } else {\n                quitf(_ok, \"Correct number of maximum possible value.\");\n            }\n        } else {\n            quitf(_wa, \"Number length does not match maximum possible length.\");\n        }\n    }\n    \n    quitf(_fail, \"Unexpected error.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int v = opt<int>(\"v\", rnd.next(0,1000000));\n    string type = opt<string>(\"type\", \"random\");\n    int minCost = opt<int>(\"minCost\",1);\n    int maxCost = opt<int>(\"maxCost\",100000);\n    int specialDigit = opt<int>(\"specialDigit\",1);\n\n    // Ensure minCost <= maxCost and both within [1,100000]\n    minCost = max(1, min(minCost, maxCost));\n    maxCost = min(100000, max(minCost, maxCost));\n    vector<int> a(10);\n\n    if (type == \"random\") {\n        for (int d = 1; d <=9; ++d) {\n            a[d] = rnd.next(minCost, maxCost);\n        }\n    } else if (type == \"increasing\") {\n        a[1] = rnd.next(minCost, maxCost);\n        for (int d = 2; d <= 9; ++d) {\n            int lower = max(a[d-1], minCost);\n            int upper = maxCost;\n            a[d] = rnd.next(lower, upper);\n        }\n    } else if (type == \"decreasing\") {\n        a[1] = rnd.next(minCost, maxCost);\n        for (int d = 2; d <= 9; ++d) {\n            int lower = minCost;\n            int upper = a[d-1];\n            a[d] = rnd.next(lower, upper);\n        }\n    } else if (type == \"all_same\") {\n        int cost = rnd.next(minCost, maxCost);\n        for (int d =1; d<=9; ++d) {\n            a[d] = cost;\n        }\n    } else if (type == \"onlyone\") {\n        specialDigit = max(1, min(9, specialDigit));\n        int maxValidCost = min(maxCost, v > 0 ? v : 100000);\n        int minValidCost = minCost;\n        if (maxValidCost >= minValidCost) {\n            a[specialDigit] = rnd.next(minValidCost, maxValidCost);\n        } else {\n            a[specialDigit] = minCost;\n        }\n        for (int d =1; d<=9; ++d) {\n            if (d != specialDigit) {\n                a[d] = max(v+1, 1);\n                a[d] = min(a[d], 100000);\n            }\n        }\n    } else if (type == \"minathigh\") {\n        int range = maxCost - minCost;\n        int step = max(1, range / 8);\n        for (int i = 9; i >=1; --i) {\n            a[i] = min(maxCost, minCost + step * (9 - i));\n        }\n    } else if (type == \"maxathigh\") {\n        int range = maxCost - minCost;\n        int step = max(1, range / 8);\n        for (int i = 1; i <=9; ++i) {\n            a[i] = min(maxCost, minCost + step * (i - 1));\n        }\n    } else {\n        // Default to random if unknown type\n        for (int d = 1; d <=9; ++d) {\n            a[d] = rnd.next(minCost, maxCost);\n        }\n    }\n\n    // Output v\n    printf(\"%d\\n\", v);\n    // Output ai's\n    for (int d = 1; d <= 9; ++d) {\n        printf(\"%d%c\", a[d], (d==9)?'\\n':' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int v = opt<int>(\"v\", rnd.next(0,1000000));\n    string type = opt<string>(\"type\", \"random\");\n    int minCost = opt<int>(\"minCost\",1);\n    int maxCost = opt<int>(\"maxCost\",100000);\n    int specialDigit = opt<int>(\"specialDigit\",1);\n\n    // Ensure minCost <= maxCost and both within [1,100000]\n    minCost = max(1, min(minCost, maxCost));\n    maxCost = min(100000, max(minCost, maxCost));\n    vector<int> a(10);\n\n    if (type == \"random\") {\n        for (int d = 1; d <=9; ++d) {\n            a[d] = rnd.next(minCost, maxCost);\n        }\n    } else if (type == \"increasing\") {\n        a[1] = rnd.next(minCost, maxCost);\n        for (int d = 2; d <= 9; ++d) {\n            int lower = max(a[d-1], minCost);\n            int upper = maxCost;\n            a[d] = rnd.next(lower, upper);\n        }\n    } else if (type == \"decreasing\") {\n        a[1] = rnd.next(minCost, maxCost);\n        for (int d = 2; d <= 9; ++d) {\n            int lower = minCost;\n            int upper = a[d-1];\n            a[d] = rnd.next(lower, upper);\n        }\n    } else if (type == \"all_same\") {\n        int cost = rnd.next(minCost, maxCost);\n        for (int d =1; d<=9; ++d) {\n            a[d] = cost;\n        }\n    } else if (type == \"onlyone\") {\n        specialDigit = max(1, min(9, specialDigit));\n        int maxValidCost = min(maxCost, v > 0 ? v : 100000);\n        int minValidCost = minCost;\n        if (maxValidCost >= minValidCost) {\n            a[specialDigit] = rnd.next(minValidCost, maxValidCost);\n        } else {\n            a[specialDigit] = minCost;\n        }\n        for (int d =1; d<=9; ++d) {\n            if (d != specialDigit) {\n                a[d] = max(v+1, 1);\n                a[d] = min(a[d], 100000);\n            }\n        }\n    } else if (type == \"minathigh\") {\n        int range = maxCost - minCost;\n        int step = max(1, range / 8);\n        for (int i = 9; i >=1; --i) {\n            a[i] = min(maxCost, minCost + step * (9 - i));\n        }\n    } else if (type == \"maxathigh\") {\n        int range = maxCost - minCost;\n        int step = max(1, range / 8);\n        for (int i = 1; i <=9; ++i) {\n            a[i] = min(maxCost, minCost + step * (i - 1));\n        }\n    } else {\n        // Default to random if unknown type\n        for (int d = 1; d <=9; ++d) {\n            a[d] = rnd.next(minCost, maxCost);\n        }\n    }\n\n    // Output v\n    printf(\"%d\\n\", v);\n    // Output ai's\n    for (int d = 1; d <= 9; ++d) {\n        printf(\"%d%c\", a[d], (d==9)?'\\n':' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# v=0 cases\n./gen -v 0 -type random\n./gen -v 0 -type onlyone -specialDigit 3\n./gen -v 0 -type increasing\n./gen -v 0 -type decreasing\n\n# v=1 cases\n./gen -v 1 -type random\n./gen -v 1 -type onlyone -specialDigit 5\n./gen -v 1 -type minathigh\n\n# v=maximum value cases\n./gen -v 1000000 -type random\n./gen -v 1000000 -type onlyone -specialDigit 9\n./gen -v 1000000 -type maxathigh\n\n# v=mid values\n./gen -v 500000 -type random\n./gen -v 500000 -type increasing\n./gen -v 500000 -type decreasing\n./gen -v 500000 -type all_same\n./gen -v 500000 -type minathigh\n./gen -v 500000 -type maxathigh\n\n# minCost and maxCost variations\n./gen -v 500000 -type random -minCost 1 -maxCost 1\n./gen -v 500000 -type all_same -minCost 1 -maxCost 1\n./gen -v 500000 -type random -minCost 1 -maxCost 100000\n./gen -v 500000 -type random -minCost 100000 -maxCost 100000\n./gen -v 500000 -type all_same -minCost 100000 -maxCost 100000\n\n# Testing with minCost = maxCost\n./gen -v 500000 -type random -minCost 50000 -maxCost 50000\n./gen -v 500000 -type minathigh -minCost 50000 -maxCost 50000\n./gen -v 500000 -type maxathigh -minCost 50000 -maxCost 50000\n\n# special digits in 'onlyone' type\n./gen -v 999999 -type onlyone -specialDigit 1\n./gen -v 999999 -type onlyone -specialDigit 5\n./gen -v 999999 -type onlyone -specialDigit 9\n\n# special cases with minimal cost at high digits\n./gen -v 999999 -type minathigh -minCost 1 -maxCost 100000\n./gen -v 999999 -type maxathigh -minCost 1 -maxCost 100000\n\n# Edge cases with minCost > maxCost (the generator will adjust minCost and maxCost appropriately)\n./gen -v 500000 -type random -minCost 100000 -maxCost 1\n\n# Random v values\n./gen -v 123456 -type random\n./gen -v 654321 -type random\n./gen -v 111111 -type random\n./gen -v 222222 -type random\n./gen -v 333333 -type random\n\n# Random v and random types\nfor v in 200000 400000 600000 800000 1000000; do\n    ./gen -v $v -type random\n    ./gen -v $v -type increasing\n    ./gen -v $v -type decreasing\ndone\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:14.934985",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "349/C",
      "title": "C. Mafia",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (3 ≤ n ≤ 105). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the i-th number in the list is the number of rounds the i-th person wants to play.",
      "output_spec": "OutputIn a single line print a single integer — the minimum number of game rounds the friends need to let the i-th person play at least ai rounds.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy33 2 2OutputCopy4InputCopy42 2 2 2OutputCopy3",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (3 ≤ n ≤ 105). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the i-th number in the list is the number of rounds the i-th person wants to play.\n\nOutputIn a single line print a single integer — the minimum number of game rounds the friends need to let the i-th person play at least ai rounds.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy33 2 2OutputCopy4InputCopy42 2 2 2OutputCopy3\n\nInputCopy33 2 2\n\nOutputCopy4\n\nInputCopy42 2 2 2\n\nOutputCopy3\n\nNoteYou don't need to know the rules of \"Mafia\" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #202 will take place today, September 27 at 19:30 MSK.The idea behind the round was born when my friends and I were interning at Facebook this summer. This round probably has the highest number of authors for a Codeforces round to date. The authors of the problems are Azizkhan Almakhan azizkhan, Michael Kolupaev al13n, Filip Hlasek fhlasek, Ivan Mandura budabudimir and myself, Igor Demidov caustique.Maxim Korystov dark_ai, Alexander Fedulin Jughead and Ibragim Ismailov ibra, Vladimir Chalyshev cmd and Sergey Sklyanichenko Sklyack helped us with preparation of the round.The ideas behind the 2 problems were inspired by Anton Ermilov ant.ermilov and Dmitry Krasnov navi-spb.Testers of the round are Alexey Safronov yarrr and Alexey Shmelev ashmelev.I would also like to thank Gerald Agapov Gerald for his help in preparing the contest.I hope you find problems interesting and diverse. I'm sure that everyone will find the problem to their liking.Scores are as usual 500-1000-1500-2000-2500.Good luck and have fun!Congratulations to the winners!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Attention! Editorial for all problems is available!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Editorial for Codeforces Round #202 - Codeforces",
          "content": "349A - Cinema LineIn the problem you need to decide whether cashier can give a change to all customers if the price of the ticket is 25 rubles and there's 3 kinds of bills: 25, 50 and 100 rubles. There's no money in the ticket office in the beginning.Let's consider 3 cases. Customer has 25 rubles hence he doesn't need a change. Customer has 50 rubles hence we have to give him 25 rubles back. Customer has 100 rubles hence we need to give him 75 rubles back. It can be done in 2 ways. 75=25+50 и 75=25+25+25. Notice that it's always worth to try 25+50 first and then 25+25+25. It's true because bills of 25 rubles can be used both to give change for 50 and 100 rubles and bills of 50 rubles can be used only to give change for 100 rubles so we need to save as much 25 ruble bills as possible. The solution is to keep track of the number of 25 and 50 ruble bills and act greedily when giving change to 100 rubles — try 25+50 first and then 25+25+25.349B - Color the FenceIn the problem you're asked to write the largest possible number given number of paint that you have and number of paint that you need to write each digit.Longer number means larger number so it's worth to write the longest possible number. Because of that we choose the largest digit among those that require the least number of paint. Let the number of paint for that digit d be equal to x, and we have v liters of paint total. Then we can write number of the length .Now we know the length of the number, let it be len. Write down temporary result – string of length len, consisting of digits d. We have supply of v–len·x liters of paint. In order to enhance the answer, we can try to update the number from the beginning and swap each digit with the maximal possible. It's true because numbers of the equal length are compared in the highest digits first. Among digits that are greater than current we choose one that we have enough paint for and then update answer and current number of paint.If the length of the answer is 0 then you need to output -1.348A - MafiaIn the problem you need to find out how many games you need to play in order to make all people happy. It means that each of them played as many games as he wanted.Let the answer be x games. Notice that max(a1, a2, …, an) ≤ x. Then i-th player can be game supervisor in x–ai games. If we sum up we get — it's the number of games in which players are ready to be supervisor. This number must be greater or equal to x — our answer. Don't forget about that condition: max(a1, a2, …, an) ≤ x.348B - Apple TreeIn the problem you need to find out minimal number of apples that you need to remove in order to make tree balanced.Notice, that if we know the value in the root then we know values in all other vertices. The value in the leaf is equal to the value in the root divided to the product of the powers of all vertices on the path between root and leaf.For every vertex let's calculate di — minimal number in that vertex (not zero) in order to make tree balanced. For leaves di = 1, for all other vertices di is equal to k·lcm(dj1, dj2, ..., djk), where j1, j2, ..., jk — sons of the vertex i. Let's calculate si — sum in the subtree of the vertex i. All that can be done using one depth first search from the root of the tree.Using second depth first search one can calculate for every vertex maximal number that we can write in it and satisfty all conditions. More precisely, given vertex i and k of its sons j1, j2, ..., jk. Then if m = min(sj1, sj2, ..., sjk) and — minimal number, that we can write to the sons of vertex i, then it's worth to write numbers to the sons of vertex i. Remains we add to the answer.348C - Subset SumsThis problem is about data structures.First step of the solution is to divide sets to heavy and light. Light ones are those that contains less than elements. All other sets are heavy.Key observation is that every light set contains less than elements and number of heavy sets doesn't exceed because we have upper bound for sum of the sizes of all sets.In order to effectively answer queries, for every set (both light and heavy) we calculate size of the intersection of this set and each heavy set. It can be done with time and memory . For every heavy set we create boolean array of size O(n). In i-th cell of this array we store how many elements i in given set. Then for each element and each heavy set we can check for O(1) time whether element is in the set.Now let's consider 4 possible cases: Add to the light set. Traverse all numbers in the set and add the value from the query to each of them. Then traverse all heavy sets and add (size of intersection * the value from the query). Time is . Add to the heavy set. Just update the counter for the heavy set. Time is O(1). Answer to the query for the light set. Traverse all numbers in the set and add values to the answer. Then traverse all heavy sets and add to the answer (answer for this heavy set * size of intersection with the set in the query). Time is . Answer to the query for the heavy set. Take already calculated answer, then traverse all heavy sets and add (answer for this heavy set * size of intersection with the set in the query). Time is . We have O(n) queries so total time is .348D - TurtlesIn the problem you're asked to find the number of pairs of non-intersecting paths between left upper and right lower corners of the grid. You can use following lemma for that. Thanks to rng_58 for the link. More precisely, considering our problem, this lemma states that given sets of initial A = {a1, a2} and final B = {b1, b2} points, the answer is equal to the following determinant: where f(x, y) — is equal to the number of paths from point x to point y. You can calculate this function using dynamic programming.Finally we need to decide what sets of initial and final points we choose. You can take A = {(0, 1), (1, 0)} and B = {(n - 2, m - 1), (n - 1, m - 2)} in order to make paths non-intersecting even in 2 points.348E - PilgrimsLet’s build a simple solution at first and then we will try to improve it to solve problem more effectively given the constraints.For every vertex let’s find the list of the farthest vertices. Let’s find vertices on the intersection of the paths between current vertex and each vertex from the list that don’t contain monasteries. If we remove any of these vertices then every vertex from the list is unreachable from the current monastery. For every vertex from the intersection increment the counter. Then the answer for the problem is the maximum among all counters and the number of such maxima.Let’s solve the problem more effectively using the same idea. Let’s make the tree with root. For every vertex we will find the list of the farthest vertices only in the subtree. While traversing the tree using depth first search we return the largest depth in the subtree and the number of the vertex where it was reached. Among all of the sons of the current vertex we choose the maximum of depths. If maximum is reached one time then we return the same answer that was returned from the son. If the answer was reached more than one time then we return the number of the current vertex. Essentially, we find LCA of the farthest vertices according to the current vertex. Before quitting the vertex we increment the values on the segment between current vertex and found LCA. One can use Eulerian tour and segment tree for adding on the segment.Finally, the last stage of solving the problem – to solve it for the case when the farthest vertex is not in the subtree of the current vertex. For solving of that subproblem we use the same idea that was used in the problem of the finding the maximal path in the tree. For every vertex we keep 3 maximums – 3 farthest vertices in the subtree. When we go down to the subtree, we pass 2 remaining maximums too. In that way, when we’re in any vertex, we can decide whether there’s a path not in the subtree (it means, going up) of the same or larger length. If there’re 2 paths of the same length in the subtree and not in the subtree, it means that for the pilgrim from the current monastery there’s always a path no matter what town was destroyed. If one of the quantities is larger then we choose the segment in Eulerian tour and increment the value on the segment. The case where there’s several paths (at least 2) out of the subtree of the same maximal length, is the same with the case in the subtree.LCA and segment tree can be solved effectively in O(logN) time per query so the total memory and time is O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 349 和字母"
          },
          "content_length": 8548
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    \n    if (type == \"all_ones\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"all_max\") {\n        // All ai = 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"one_large_rest_small\") {\n        // One ai = 1e9, rest ai = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        int idx = rnd.next(0, n-1);\n        a[idx] = 1000000000;\n    } else if (type == \"increasing\") {\n        // ai from 1 to 1e9 in increasing order\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 + (long long)i * (1000000000LL - 1) / (n - 1);\n            if (a[i] > 1000000000) a[i] = 1000000000;\n        }\n    } else if (type == \"decreasing\") {\n        // ai from 1e9 to 1 in decreasing order\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000 - (long long)i * (1000000000LL - 1) / (n - 1);\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else if (type == \"maxai_greater\") {\n        // Construct ai such that max(ai) > ceil(sum(ai)/(n-1))\n        assert(n >= 3);\n        int s = 1000000000;\n        a[0] = s; // max(ai)\n        long long sum_ai = (long long)s * (n - 1) - 1;\n        long long rest_sum = sum_ai - a[0];\n        int avg = rest_sum / (n - 1);\n        for (int i = 1; i < n; ++i) {\n            a[i] = avg;\n        }\n        long long assigned_sum = (long long)avg * (n - 1);\n        int i = 1;\n        while (assigned_sum < rest_sum) {\n            a[i]++;\n            assigned_sum++;\n            i++;\n            if (i == n) i = 1;\n        }\n    } else if (type == \"sum_nminus1_greater\") {\n        // Construct ai such that ceil(sum(ai)/(n-1)) > max(ai)\n        int s = 1;\n        a[0] = s; // max(ai)\n        long long sum_ai = (long long)s * (n - 1) + 1;\n        long long rest_sum = sum_ai - a[0];\n        int avg = rest_sum / (n -1);\n        for (int i = 1; i < n; ++i) {\n            a[i] = avg;\n        }\n        long long assigned_sum = (long long)avg * (n - 1);\n        int i = 1;\n        while (assigned_sum < rest_sum) {\n            a[i]++;\n            assigned_sum++;\n            i++;\n            if (i == n) i = 1;\n        }\n    } else if (type == \"maxai_equals\") {\n        // Construct ai such that max(ai) == ceil(sum(ai)/(n -1))\n        int s = rnd.next(1, 1000000000);\n        a[0] = s;\n        long long sum_ai = (long long)s * (n - 1);\n        long long rest_sum = sum_ai - a[0];\n        int avg = rest_sum / (n -1);\n        for (int i = 1; i < n; ++i) {\n            a[i] = avg;\n        }\n    } else {\n        // Random ai between 1 and 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    \n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    \n    if (type == \"all_ones\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"all_max\") {\n        // All ai = 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"one_large_rest_small\") {\n        // One ai = 1e9, rest ai = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        int idx = rnd.next(0, n-1);\n        a[idx] = 1000000000;\n    } else if (type == \"increasing\") {\n        // ai from 1 to 1e9 in increasing order\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 + (long long)i * (1000000000LL - 1) / (n - 1);\n            if (a[i] > 1000000000) a[i] = 1000000000;\n        }\n    } else if (type == \"decreasing\") {\n        // ai from 1e9 to 1 in decreasing order\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000 - (long long)i * (1000000000LL - 1) / (n - 1);\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else if (type == \"maxai_greater\") {\n        // Construct ai such that max(ai) > ceil(sum(ai)/(n-1))\n        assert(n >= 3);\n        int s = 1000000000;\n        a[0] = s; // max(ai)\n        long long sum_ai = (long long)s * (n - 1) - 1;\n        long long rest_sum = sum_ai - a[0];\n        int avg = rest_sum / (n - 1);\n        for (int i = 1; i < n; ++i) {\n            a[i] = avg;\n        }\n        long long assigned_sum = (long long)avg * (n - 1);\n        int i = 1;\n        while (assigned_sum < rest_sum) {\n            a[i]++;\n            assigned_sum++;\n            i++;\n            if (i == n) i = 1;\n        }\n    } else if (type == \"sum_nminus1_greater\") {\n        // Construct ai such that ceil(sum(ai)/(n-1)) > max(ai)\n        int s = 1;\n        a[0] = s; // max(ai)\n        long long sum_ai = (long long)s * (n - 1) + 1;\n        long long rest_sum = sum_ai - a[0];\n        int avg = rest_sum / (n -1);\n        for (int i = 1; i < n; ++i) {\n            a[i] = avg;\n        }\n        long long assigned_sum = (long long)avg * (n - 1);\n        int i = 1;\n        while (assigned_sum < rest_sum) {\n            a[i]++;\n            assigned_sum++;\n            i++;\n            if (i == n) i = 1;\n        }\n    } else if (type == \"maxai_equals\") {\n        // Construct ai such that max(ai) == ceil(sum(ai)/(n -1))\n        int s = rnd.next(1, 1000000000);\n        a[0] = s;\n        long long sum_ai = (long long)s * (n - 1);\n        long long rest_sum = sum_ai - a[0];\n        int avg = rest_sum / (n -1);\n        for (int i = 1; i < n; ++i) {\n            a[i] = avg;\n        }\n    } else {\n        // Random ai between 1 and 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    \n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type all_ones\n./gen -n 3 -type all_max\n./gen -n 3 -type one_large_rest_small\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type maxai_greater\n./gen -n 3 -type sum_nminus1_greater\n./gen -n 3 -type maxai_equals\n./gen -n 3 -type random\n\n./gen -n 10 -type all_ones\n./gen -n 10 -type all_max\n./gen -n 10 -type one_large_rest_small\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type maxai_greater\n./gen -n 10 -type sum_nminus1_greater\n./gen -n 10 -type maxai_equals\n./gen -n 10 -type random\n\n./gen -n 1000 -type all_ones\n./gen -n 1000 -type all_max\n./gen -n 1000 -type one_large_rest_small\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type maxai_greater\n./gen -n 1000 -type sum_nminus1_greater\n./gen -n 1000 -type maxai_equals\n./gen -n 1000 -type random\n\n./gen -n 100000 -type all_ones\n./gen -n 100000 -type all_max\n./gen -n 100000 -type one_large_rest_small\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type maxai_greater\n./gen -n 100000 -type sum_nminus1_greater\n./gen -n 100000 -type maxai_equals\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:16.658838",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "349/D",
      "title": "D. Apple Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 105), showing the number of vertices in the tree. The next line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 108), ai is the number of apples in the vertex number i. The number of apples in non-leaf vertices is guaranteed to be zero. Then follow n - 1 lines, describing the tree edges. Each line contains a pair of integers xi, yi (1 ≤ xi, yi ≤ n, xi ≠ yi) — the vertices connected by an edge. The vertices are indexed from 1 to n. Vertex 1 is the root.",
      "output_spec": "OutputPrint a single integer — the minimum number of apples to remove in order to make the tree balanced.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the sin, cout streams cin, cout or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy60 0 12 13 5 61 21 31 42 52 6OutputCopy6",
      "description": "D. Apple Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 105), showing the number of vertices in the tree. The next line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 108), ai is the number of apples in the vertex number i. The number of apples in non-leaf vertices is guaranteed to be zero. Then follow n - 1 lines, describing the tree edges. Each line contains a pair of integers xi, yi (1 ≤ xi, yi ≤ n, xi ≠ yi) — the vertices connected by an edge. The vertices are indexed from 1 to n. Vertex 1 is the root.\n\nOutputPrint a single integer — the minimum number of apples to remove in order to make the tree balanced.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the sin, cout streams cin, cout or the %I64d specifier.\n\nInputCopy60 0 12 13 5 61 21 31 42 52 6OutputCopy6\n\nInputCopy60 0 12 13 5 61 21 31 42 52 6\n\nOutputCopy6",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Hello, Codeforces!Codeforces Round #202 will take place today, September 27 at 19:30 MSK.The idea behind the round was born when my friends and I were interning at Facebook this summer. This round probably has the highest number of authors for a Codeforces round to date. The authors of the problems are Azizkhan Almakhan azizkhan, Michael Kolupaev al13n, Filip Hlasek fhlasek, Ivan Mandura budabudimir and myself, Igor Demidov caustique.Maxim Korystov dark_ai, Alexander Fedulin Jughead and Ibragim Ismailov ibra, Vladimir Chalyshev cmd and Sergey Sklyanichenko Sklyack helped us with preparation of the round.The ideas behind the 2 problems were inspired by Anton Ermilov ant.ermilov and Dmitry Krasnov navi-spb.Testers of the round are Alexey Safronov yarrr and Alexey Shmelev ashmelev.I would also like to thank Gerald Agapov Gerald for his help in preparing the contest.I hope you find problems interesting and diverse. I'm sure that everyone will find the problem to their liking.Scores are as usual 500-1000-1500-2000-2500.Good luck and have fun!Congratulations to the winners!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Attention! Editorial for all problems is available!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1261
        },
        {
          "title": "Editorial for Codeforces Round #202 - Codeforces",
          "content": "349A - Cinema LineIn the problem you need to decide whether cashier can give a change to all customers if the price of the ticket is 25 rubles and there's 3 kinds of bills: 25, 50 and 100 rubles. There's no money in the ticket office in the beginning.Let's consider 3 cases. Customer has 25 rubles hence he doesn't need a change. Customer has 50 rubles hence we have to give him 25 rubles back. Customer has 100 rubles hence we need to give him 75 rubles back. It can be done in 2 ways. 75=25+50 и 75=25+25+25. Notice that it's always worth to try 25+50 first and then 25+25+25. It's true because bills of 25 rubles can be used both to give change for 50 and 100 rubles and bills of 50 rubles can be used only to give change for 100 rubles so we need to save as much 25 ruble bills as possible. The solution is to keep track of the number of 25 and 50 ruble bills and act greedily when giving change to 100 rubles — try 25+50 first and then 25+25+25.349B - Color the FenceIn the problem you're asked to write the largest possible number given number of paint that you have and number of paint that you need to write each digit.Longer number means larger number so it's worth to write the longest possible number. Because of that we choose the largest digit among those that require the least number of paint. Let the number of paint for that digit d be equal to x, and we have v liters of paint total. Then we can write number of the length .Now we know the length of the number, let it be len. Write down temporary result – string of length len, consisting of digits d. We have supply of v–len·x liters of paint. In order to enhance the answer, we can try to update the number from the beginning and swap each digit with the maximal possible. It's true because numbers of the equal length are compared in the highest digits first. Among digits that are greater than current we choose one that we have enough paint for and then update answer and current number of paint.If the length of the answer is 0 then you need to output -1.348A - MafiaIn the problem you need to find out how many games you need to play in order to make all people happy. It means that each of them played as many games as he wanted.Let the answer be x games. Notice that max(a1, a2, …, an) ≤ x. Then i-th player can be game supervisor in x–ai games. If we sum up we get — it's the number of games in which players are ready to be supervisor. This number must be greater or equal to x — our answer. Don't forget about that condition: max(a1, a2, …, an) ≤ x.348B - Apple TreeIn the problem you need to find out minimal number of apples that you need to remove in order to make tree balanced.Notice, that if we know the value in the root then we know values in all other vertices. The value in the leaf is equal to the value in the root divided to the product of the powers of all vertices on the path between root and leaf.For every vertex let's calculate di — minimal number in that vertex (not zero) in order to make tree balanced. For leaves di = 1, for all other vertices di is equal to k·lcm(dj1, dj2, ..., djk), where j1, j2, ..., jk — sons of the vertex i. Let's calculate si — sum in the subtree of the vertex i. All that can be done using one depth first search from the root of the tree.Using second depth first search one can calculate for every vertex maximal number that we can write in it and satisfty all conditions. More precisely, given vertex i and k of its sons j1, j2, ..., jk. Then if m = min(sj1, sj2, ..., sjk) and — minimal number, that we can write to the sons of vertex i, then it's worth to write numbers to the sons of vertex i. Remains we add to the answer.348C - Subset SumsThis problem is about data structures.First step of the solution is to divide sets to heavy and light. Light ones are those that contains less than elements. All other sets are heavy.Key observation is that every light set contains less than elements and number of heavy sets doesn't exceed because we have upper bound for sum of the sizes of all sets.In order to effectively answer queries, for every set (both light and heavy) we calculate size of the intersection of this set and each heavy set. It can be done with time and memory . For every heavy set we create boolean array of size O(n). In i-th cell of this array we store how many elements i in given set. Then for each element and each heavy set we can check for O(1) time whether element is in the set.Now let's consider 4 possible cases: Add to the light set. Traverse all numbers in the set and add the value from the query to each of them. Then traverse all heavy sets and add (size of intersection * the value from the query). Time is . Add to the heavy set. Just update the counter for the heavy set. Time is O(1). Answer to the query for the light set. Traverse all numbers in the set and add values to the answer. Then traverse all heavy sets and add to the answer (answer for this heavy set * size of intersection with the set in the query). Time is . Answer to the query for the heavy set. Take already calculated answer, then traverse all heavy sets and add (answer for this heavy set * size of intersection with the set in the query). Time is . We have O(n) queries so total time is .348D - TurtlesIn the problem you're asked to find the number of pairs of non-intersecting paths between left upper and right lower corners of the grid. You can use following lemma for that. Thanks to rng_58 for the link. More precisely, considering our problem, this lemma states that given sets of initial A = {a1, a2} and final B = {b1, b2} points, the answer is equal to the following determinant: where f(x, y) — is equal to the number of paths from point x to point y. You can calculate this function using dynamic programming.Finally we need to decide what sets of initial and final points we choose. You can take A = {(0, 1), (1, 0)} and B = {(n - 2, m - 1), (n - 1, m - 2)} in order to make paths non-intersecting even in 2 points.348E - PilgrimsLet’s build a simple solution at first and then we will try to improve it to solve problem more effectively given the constraints.For every vertex let’s find the list of the farthest vertices. Let’s find vertices on the intersection of the paths between current vertex and each vertex from the list that don’t contain monasteries. If we remove any of these vertices then every vertex from the list is unreachable from the current monastery. For every vertex from the intersection increment the counter. Then the answer for the problem is the maximum among all counters and the number of such maxima.Let’s solve the problem more effectively using the same idea. Let’s make the tree with root. For every vertex we will find the list of the farthest vertices only in the subtree. While traversing the tree using depth first search we return the largest depth in the subtree and the number of the vertex where it was reached. Among all of the sons of the current vertex we choose the maximum of depths. If maximum is reached one time then we return the same answer that was returned from the son. If the answer was reached more than one time then we return the number of the current vertex. Essentially, we find LCA of the farthest vertices according to the current vertex. Before quitting the vertex we increment the values on the segment between current vertex and found LCA. One can use Eulerian tour and segment tree for adding on the segment.Finally, the last stage of solving the problem – to solve it for the case when the farthest vertex is not in the subtree of the current vertex. For solving of that subproblem we use the same idea that was used in the problem of the finding the maximal path in the tree. For every vertex we keep 3 maximums – 3 farthest vertices in the subtree. When we go down to the subtree, we pass 2 remaining maximums too. In that way, when we’re in any vertex, we can decide whether there’s a path not in the subtree (it means, going up) of the same or larger length. If there’re 2 paths of the same length in the subtree and not in the subtree, it means that for the pilgrim from the current monastery there’s always a path no matter what town was destroyed. If one of the quantities is larger then we choose the segment in Eulerian tour and increment the value on the segment. The case where there’s several paths (at least 2) out of the subtree of the same maximal length, is the same with the case in the subtree.LCA and segment tree can be solved effectively in O(logN) time per query so the total memory and time is O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 349 和字母"
          },
          "content_length": 8548
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_A = 100000000;\n\nint parent[100005];\nint find(int u) {\n    if(parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\nvoid union_sets(int u, int v) {\n    parent[u] = v;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    vector<vector<int>> adj(n+1);\n    for(int i=1; i<=n; i++) parent[i] = i;\n    int component_count = n;\n\n    for(int i = 0; i < n - 1; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Edge can't connect node to itself: %d\", xi);\n        int x_min = min(xi, yi);\n        int x_max = max(xi, yi);\n        pair<int,int> p = make_pair(x_min, x_max);\n        ensuref(edges.find(p) == edges.end(), \"Multiple edges between %d and %d\", x_min, x_max);\n        edges.insert(p);\n        int fu = find(xi);\n        int fv = find(yi);\n        ensuref(fu != fv, \"Graph contains cycle when adding edge between %d and %d\", xi, yi);\n        union_sets(fu, fv);\n        component_count--;\n        adj[xi].push_back(yi);\n        adj[yi].push_back(xi);\n    }\n    ensuref(component_count == 1, \"Graph is not connected\");\n    // Now perform DFS to find leaves and ensure that non-leaf nodes have ai == 0\n    vector<bool> is_leaf(n+1, true);\n    vector<bool> visited(n+1, false);\n    function<void(int,int)> dfs = [&](int u, int p) {\n        visited[u] = true;\n        for(int v : adj[u]) {\n            if(v != p) {\n                is_leaf[u] = false;\n                dfs(v, u);\n            }\n        }\n    };\n    dfs(1, 0);\n    for(int u = 1; u <= n; u++) {\n        if(!is_leaf[u]) {\n            ensuref(a[u-1] == 0, \"Non-leaf node %d must have ai == 0\", u);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_A = 100000000;\n\nint parent[100005];\nint find(int u) {\n    if(parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\nvoid union_sets(int u, int v) {\n    parent[u] = v;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    vector<vector<int>> adj(n+1);\n    for(int i=1; i<=n; i++) parent[i] = i;\n    int component_count = n;\n\n    for(int i = 0; i < n - 1; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Edge can't connect node to itself: %d\", xi);\n        int x_min = min(xi, yi);\n        int x_max = max(xi, yi);\n        pair<int,int> p = make_pair(x_min, x_max);\n        ensuref(edges.find(p) == edges.end(), \"Multiple edges between %d and %d\", x_min, x_max);\n        edges.insert(p);\n        int fu = find(xi);\n        int fv = find(yi);\n        ensuref(fu != fv, \"Graph contains cycle when adding edge between %d and %d\", xi, yi);\n        union_sets(fu, fv);\n        component_count--;\n        adj[xi].push_back(yi);\n        adj[yi].push_back(xi);\n    }\n    ensuref(component_count == 1, \"Graph is not connected\");\n    // Now perform DFS to find leaves and ensure that non-leaf nodes have ai == 0\n    vector<bool> is_leaf(n+1, true);\n    vector<bool> visited(n+1, false);\n    function<void(int,int)> dfs = [&](int u, int p) {\n        visited[u] = true;\n        for(int v : adj[u]) {\n            if(v != p) {\n                is_leaf[u] = false;\n                dfs(v, u);\n            }\n        }\n    };\n    dfs(1, 0);\n    for(int u = 1; u <= n; u++) {\n        if(!is_leaf[u]) {\n            ensuref(a[u-1] == 0, \"Non-leaf node %d must have ai == 0\", u);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_A = 100000000;\n\nint parent[100005];\nint find(int u) {\n    if(parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\nvoid union_sets(int u, int v) {\n    parent[u] = v;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    vector<vector<int>> adj(n+1);\n    for(int i=1; i<=n; i++) parent[i] = i;\n    int component_count = n;\n\n    for(int i = 0; i < n - 1; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Edge can't connect node to itself: %d\", xi);\n        int x_min = min(xi, yi);\n        int x_max = max(xi, yi);\n        pair<int,int> p = make_pair(x_min, x_max);\n        ensuref(edges.find(p) == edges.end(), \"Multiple edges between %d and %d\", x_min, x_max);\n        edges.insert(p);\n        int fu = find(xi);\n        int fv = find(yi);\n        ensuref(fu != fv, \"Graph contains cycle when adding edge between %d and %d\", xi, yi);\n        union_sets(fu, fv);\n        component_count--;\n        adj[xi].push_back(yi);\n        adj[yi].push_back(xi);\n    }\n    ensuref(component_count == 1, \"Graph is not connected\");\n    // Now perform DFS to find leaves and ensure that non-leaf nodes have ai == 0\n    vector<bool> is_leaf(n+1, true);\n    vector<bool> visited(n+1, false);\n    function<void(int,int)> dfs = [&](int u, int p) {\n        visited[u] = true;\n        for(int v : adj[u]) {\n            if(v != p) {\n                is_leaf[u] = false;\n                dfs(v, u);\n            }\n        }\n    };\n    dfs(1, 0);\n    for(int u = 1; u <= n; u++) {\n        if(!is_leaf[u]) {\n            ensuref(a[u-1] == 0, \"Non-leaf node %d must have ai == 0\", u);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree = opt<string>(\"tree\", \"random\");\n    string apples = opt<string>(\"apples\", \"random\");\n\n    // Generate tree based on tree type\n    vector<pair<int,int>> edges;\n\n    if (tree == \"random\") {\n        // Build random tree rooted at node 1\n        vector<int> parent(n+1);\n        parent[1] = 0; // Root\n\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n    }\n    else if (tree == \"chain\") {\n        // Build a chain from 1 to n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i-1, i});\n        }\n    }\n    else if (tree == \"star\") {\n        // Build a star with root 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    }\n    else if (tree == \"balanced\") {\n        // Build a balanced tree\n        // For simplicity, we'll build a binary tree\n        vector<int> nodes = {1};\n        int idx = 2;\n        while (idx <= n) {\n            vector<int> next_nodes;\n            for (int u : nodes) {\n                if (idx <= n) {\n                    edges.push_back({u, idx});\n                    next_nodes.push_back(idx++);\n                }\n                if (idx <= n) {\n                    edges.push_back({u, idx});\n                    next_nodes.push_back(idx++);\n                }\n            }\n            nodes = next_nodes;\n        }\n    }\n    else if (tree == \"unbalanced\") {\n        // Build an unbalanced tree\n        int current = 1;\n        for (int i = 2; i <= n/2; ++i) {\n            edges.push_back({current, i});\n            current = i;\n        }\n        // Remaining nodes connected to root\n        for (int i = n/2+1; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    }\n    else {\n        // Default to random\n        vector<int> parent(n+1);\n        parent[1] = 0; // Root\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Now, assign apples to leaves\n    // First, find leaves\n    vector<int> degree(n+1, 0);\n    for (auto &e : edges) {\n        degree[e.first]++;\n        degree[e.second]++;\n    }\n    // Root may have degree 1 even if it's not a leaf\n    degree[1]++; // To ensure root is not considered a leaf\n\n    vector<int> apples_list(n+1, 0); // From node 1 to n\n\n    if (apples == \"allzero\") {\n        // No apples on leaves\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                apples_list[i] = 0;\n            }\n        }\n    }\n    else if (apples == \"allmax\") {\n        // Max apples on leaves\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                apples_list[i] = 100000000;\n            }\n        }\n    }\n    else if (apples == \"random\") {\n        // Random apples on leaves\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                apples_list[i] = rnd.next(0, 100000000);\n            }\n        }\n    }\n    else if (apples == \"maxrequired\") {\n        // Assign apples to maximize the number to remove\n        // Assign max apples to one leaf, zeros to others\n        bool assigned = false;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                if (!assigned) {\n                    apples_list[i] = 100000000;\n                    assigned = true;\n                } else {\n                    apples_list[i] = 0;\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                apples_list[i] = rnd.next(0, 100000000);\n            }\n        }\n    }\n\n    // Output according to problem format\n\n    // Print n\n    printf(\"%d\\n\", n);\n\n    // Print a1, a2, ..., an\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", apples_list[i], (i == n ? '\\n' : ' '));\n    }\n\n    // Print edges\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree = opt<string>(\"tree\", \"random\");\n    string apples = opt<string>(\"apples\", \"random\");\n\n    // Generate tree based on tree type\n    vector<pair<int,int>> edges;\n\n    if (tree == \"random\") {\n        // Build random tree rooted at node 1\n        vector<int> parent(n+1);\n        parent[1] = 0; // Root\n\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n    }\n    else if (tree == \"chain\") {\n        // Build a chain from 1 to n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i-1, i});\n        }\n    }\n    else if (tree == \"star\") {\n        // Build a star with root 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    }\n    else if (tree == \"balanced\") {\n        // Build a balanced tree\n        // For simplicity, we'll build a binary tree\n        vector<int> nodes = {1};\n        int idx = 2;\n        while (idx <= n) {\n            vector<int> next_nodes;\n            for (int u : nodes) {\n                if (idx <= n) {\n                    edges.push_back({u, idx});\n                    next_nodes.push_back(idx++);\n                }\n                if (idx <= n) {\n                    edges.push_back({u, idx});\n                    next_nodes.push_back(idx++);\n                }\n            }\n            nodes = next_nodes;\n        }\n    }\n    else if (tree == \"unbalanced\") {\n        // Build an unbalanced tree\n        int current = 1;\n        for (int i = 2; i <= n/2; ++i) {\n            edges.push_back({current, i});\n            current = i;\n        }\n        // Remaining nodes connected to root\n        for (int i = n/2+1; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    }\n    else {\n        // Default to random\n        vector<int> parent(n+1);\n        parent[1] = 0; // Root\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i-1);\n            edges.push_back({parent[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Now, assign apples to leaves\n    // First, find leaves\n    vector<int> degree(n+1, 0);\n    for (auto &e : edges) {\n        degree[e.first]++;\n        degree[e.second]++;\n    }\n    // Root may have degree 1 even if it's not a leaf\n    degree[1]++; // To ensure root is not considered a leaf\n\n    vector<int> apples_list(n+1, 0); // From node 1 to n\n\n    if (apples == \"allzero\") {\n        // No apples on leaves\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                apples_list[i] = 0;\n            }\n        }\n    }\n    else if (apples == \"allmax\") {\n        // Max apples on leaves\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                apples_list[i] = 100000000;\n            }\n        }\n    }\n    else if (apples == \"random\") {\n        // Random apples on leaves\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                apples_list[i] = rnd.next(0, 100000000);\n            }\n        }\n    }\n    else if (apples == \"maxrequired\") {\n        // Assign apples to maximize the number to remove\n        // Assign max apples to one leaf, zeros to others\n        bool assigned = false;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                if (!assigned) {\n                    apples_list[i] = 100000000;\n                    assigned = true;\n                } else {\n                    apples_list[i] = 0;\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != 1) {\n                apples_list[i] = rnd.next(0, 100000000);\n            }\n        }\n    }\n\n    // Output according to problem format\n\n    // Print n\n    printf(\"%d\\n\", n);\n\n    // Print a1, a2, ..., an\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", apples_list[i], (i == n ? '\\n' : ' '));\n    }\n\n    // Print edges\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -tree chain -apples allzero\n./gen -n 2 -tree chain -apples random\n./gen -n 3 -tree chain -apples allmax\n./gen -n 5 -tree star -apples random\n./gen -n 5 -tree star -apples allzero\n./gen -n 5 -tree star -apples allmax\n./gen -n 10 -tree random -apples random\n./gen -n 10 -tree chain -apples random\n./gen -n 10 -tree balanced -apples random\n./gen -n 50 -tree balanced -apples random\n./gen -n 50 -tree unbalanced -apples random\n./gen -n 100 -tree random -apples allzero\n./gen -n 100 -tree random -apples allmax\n./gen -n 100 -tree random -apples random\n./gen -n 1000 -tree random -apples allmax\n./gen -n 1000 -tree chain -apples allzero\n./gen -n 5000 -tree chain -apples maxrequired\n./gen -n 5000 -tree star -apples random\n./gen -n 10000 -tree unbalanced -apples maxrequired\n./gen -n 20000 -tree balanced -apples random\n./gen -n 40000 -tree random -apples random\n./gen -n 80000 -tree balanced -apples random\n./gen -n 99999 -tree random -apples random\n./gen -n 100000 -tree balanced -apples random\n./gen -n 100000 -tree random -apples random\n./gen -n 100000 -tree chain -apples allzero\n./gen -n 100000 -tree chain -apples allmax\n./gen -n 100000 -tree unbalanced -apples maxrequired\n./gen -n 100000 -tree star -apples maxrequired\n./gen -n 100000 -tree star -apples random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:18.571660",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "349/E",
      "title": "E. Суммы подмножеств",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записаны целые числа n, m, q (1 ≤ n, m, q ≤ 105). В следующей строке записаны n целых чисел a1, a2, ..., an (|ai| ≤ 108) — элементы массива a.Каждая из следующих m строк описывает одно множество индексов. В k-ой строке сначала записано целое положительное число, обозначающее количество элементов в множестве (|Sk|), а затем даны |Sk| различных целых чисел Sk, 1, Sk, 2, ..., Sk, |Sk| (1 ≤ Sk, i ≤ n) — элементы множества Sk.В следующих q строках заданы запросы. Каждый запрос имеет вид «? k» или «+ k x» и находится на отдельной строчке. Для всех запросов выполняются ограничения: 1 ≤ k ≤ m, |x| ≤ 108. Запросы заданы в том порядке, в котором их нужно выполнять.Гарантируется, что сумма размеров всех множеств Sk не превосходит 105.",
      "output_spec": "Выходные данныеПосле каждого запроса первого типа, выведите искомую сумму в отдельной строке.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 3 55 -5 5 1 -42 1 24 2 1 4 52 2 5? 2+ 3 4? 1+ 2 1? 2Выходные данныеСкопировать-349",
      "description": "E. Суммы подмножеств\n\nограничение по времени на тест3 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны целые числа n, m, q (1 ≤ n, m, q ≤ 105). В следующей строке записаны n целых чисел a1, a2, ..., an (|ai| ≤ 108) — элементы массива a.Каждая из следующих m строк описывает одно множество индексов. В k-ой строке сначала записано целое положительное число, обозначающее количество элементов в множестве (|Sk|), а затем даны |Sk| различных целых чисел Sk, 1, Sk, 2, ..., Sk, |Sk| (1 ≤ Sk, i ≤ n) — элементы множества Sk.В следующих q строках заданы запросы. Каждый запрос имеет вид «? k» или «+ k x» и находится на отдельной строчке. Для всех запросов выполняются ограничения: 1 ≤ k ≤ m, |x| ≤ 108. Запросы заданы в том порядке, в котором их нужно выполнять.Гарантируется, что сумма размеров всех множеств Sk не превосходит 105.\n\nВходные данные\n\nВыходные данныеПосле каждого запроса первого типа, выведите искомую сумму в отдельной строке.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать5 3 55 -5 5 1 -42 1 24 2 1 4 52 2 5? 2+ 3 4? 1+ 2 1? 2Выходные данныеСкопировать-349\n\nВходные данныеСкопировать5 3 55 -5 5 1 -42 1 24 2 1 4 52 2 5? 2+ 3 4? 1+ 2 1? 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-349\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #202 - Codeforces",
          "content": "Привет, Codeforces!Сегодня, 27 сентября в 19:30 МСК, состоится Codeforces Round #202.Идея раунда зародилась у меня и моих друзей, когда мы стажировались в Facebook этим летом. Возможно, у этого раунда рекордное для Codeforces количество авторов. Авторами задач стали Азизхан Алмахан azizkhan, Михаил Колупаев al13n, Филип Хласек fhlasek, Иван Мандура budabudimir и я, Игорь Демидов caustique.В подготовке раунда нам помогали Максим Корыстов dark_ai, Александр Федулин Jughead, Ибрагим Исмаилов ibra, Владимир Чалышев cmd и Сергей Скляниченко Sklyack.Идеи 2 задач мне подали Антон Ермилов ant.ermilov и Дмитрий Краснов navi-spb.Тестировали раунд Алексей Сафронов yarrr и Алексей Шмелев ashmelev.Также я хотел бы поблагодарить Геральда Агапова Gerald за помощь в подготовке контеста.Надеюсь, задачи Вам покажутся разнообразными и интересными. Уверен, что каждый найдет себе задачу по вкусу.Разбалловка стандартная 500-1000-1500-2000-2500.Желаю удачи и удовольствия от решения задач!Поздравляем победителей!Div. 1 ilyakor rng_58 EnumerativeCombinatorics ftiasch phtniit SillyHook06 niyaznigmatul Div. 2 zhk love_kd alex_k arpit11293 Внимание! Появился разбор всех задач на обоих языках!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1183
        },
        {
          "title": "Разбор задач Codeforces Round #202 - Codeforces",
          "content": "349A - Очередь в киноВ задаче требовалось выяснить, может ли кассир выдать сдачу всем посетителям кинотеатра, если билет стоит 25 рублей, у посетителей купюры номиналом 25, 50 и 100 и в кассе изначально нет денег.Рассмотрим 3 различных случая. Если у посетителя 25 рублей, то сдачу ему давать не нужно. Если у посетителя 50 рублей, то мы должны дать ему 25 рублей сдачи. Если у посетителя 100 рублей, то мы должны дать ему 75 рублей сдачи. Это можно сделать двумя способами. 75=25+50 и 75=25+25+25. Заметим, что всегда выгодно попробовать сначала первый способ, а потом второй. Это верно потому, что купюры номиналом 25 рублей могут быть использован как для выдачи сдачи на 50 рублей, так и на 100 рублей, а сами купюры номиналом 50 рублей могут использоваться только для выдачи сдачи на 100 рублей. Таким образом решение – поддерживать количество купюр номиналом 25 и 50 рублей и при выдаче сдачи на 100 рублей действовать жадно – сначала пробовать выдать 25+50 рублей, а иначе 25+25+25 рублей.349B - Раскраска забораВ задаче требовалось выяснить наибольшее число, которое можно написать, используя заданное количество краски, если на каждую цифру тратится также известное количество краски.Поскольку чем длиннее число, тем оно больше, нам выгодно написать число наибольшей длины. Для этого выберем цифру, на которую нужно меньше всего краски. Пусть количество краски для написания этой цифры d равно x, а всего у нас есть v литров краски. Тогда мы можем написать число длины .Таким образом мы выяснили длину числа, пусть она равна len. Запишем промежуточный результат – строку длины len, состоящую из цифр d. У нас в запасе еще осталось v–len·x краски. Чтобы улучшить ответ, будем идти от начала числа и пробовать заменить каждую цифру на максимально возможную. Это верно потому, что числа одинаковой длины сравниваются сначала по старшим разрядам. Среди цифр больше текущей выбираем максимальную среди тех, на которую хватает краски, и обновляем текущее количество краски и ответ.Если ответ длины 0, то нужно вывести -1.348A - МафияВ задаче требовалось определить, сколько игр нужно сыграть, чтобы все игроки остались довольны и сыграли как минимум столько игр, сколько они хотят.Пусть ответ – это x игр. Заметим, что max(a1, a2, …, an) ≤ x. Тогда i-ый игрок может в x–ai играх быть ведущим. Если просуммировать по всем игрокам, то получим — это количество игр, в которых игроки согласны быть ведущими. Это число должно быть не меньше x — нашего ответа. Также следует не забыть требование, что max(a1, a2, …, an) ≤ x.348B - ЯблоняВ задаче требовалось выяснить, какое минимальное количество яблок нужно удалить, чтобы сделать дерево сбалансированным.Заметим, что если мы знаем значение в корне, то знаем значения во всех остальных вершинах. Значение в листе равняется значению в корне, поделенному на произведение степеней вершин на пути от корня до листа.Для каждой вершины посчитаем величину di — какое минимальное число (не ноль) в ней должно быть записано, чтобы дерево по-прежнему могло быть сбалансированным. Для листьев di = 1, для остальных вершин di равен k·lcm(dj1, dj2, ..., djk), где j1, j2, ..., jk — сыновья вершины i. Также посчитаем величину si — сумму в поддереве вершины i. Все это можно сделать за один обход в глубину из корня дерева.Вторым обходом в глубину мы можем посчитать для каждой вершины максимальное число, которое мы в нее можем записать, так чтобы удовлетворить ограничениям. А именно, пусть дана вершина i и k ее сыновей j1, j2, ..., jk. Тогда если m = min(sj1, sj2, ..., sjk), а — минимальное число, которое мы можем записать в сыновей вершины i, нам выгодно записать в сыновей вершины i числа . Остатки, а именно , добавим к ответу.348C - Суммы подмножествВ этой задаче на структуры данных требовалось использовать корневую эвристику или, по-другому, sqrt-декомпозицию.Первый шаг решения состоял в том, чтобы разделить множества на легкие и тяжелые. Легкими назовем множества, которые содержат меньше элементов, а тяжелыми все остальные.Ключевое наблюдение. В любом легком множестве меньше элементов, а количество тяжелых множеств также не превосходит , так как есть ограничение на сумму размеров множеств.Чтобы эффективно отвечать на запросы, для каждого множества (как легкого, так и тяжелого) посчитаем размеры его пересечения со всеми тяжелыми множествами. Это можно сделать за время и память . Для каждого тяжелого множества создадим булевский массив размера O(n), в i-ой ячейке которого будем хранить, сколько элементов i в этом множестве. Затем для каждого элемента и каждого тяжелого множества будем за O(1) проверять, содержится ли элемент в тяжелом множестве.Теперь рассмотрим 4 возможных запроса: Добавление к легкому множеству. Пройдем по всем числам множества и к каждому добавим нужное значение. Дальше пройдем по всем тяжелым множествам и к каждому добавим (размер пересечения * значение в запросе). Время работы . Добавление к тяжелому множеству. Просто увеличим счетчик для данного тяжелого множества на значение в запросе. Время работы O(1). Ответ на запрос для легкого множества. Проходим по всем числам, добавляем значения к ответу. Затем проходим по всем тяжелым множествам и добавляем к ответу (добавление для данного тяжелого множества * размер пересечения со множеством в запросе). Время работы . Ответ на запрос для тяжелого множества. Берем уже посчитанный ответ, затем проходим по тяжелым множествам и добавляем (добавление для данного тяжелого множества * размер пересечения со множеством в запросе). Время работы . Итого, если у нас O(n) запросов, то суммарное время работы .348D - ЧерепашкиВ задаче требовалось найти количество пар непересекающихся путей из левого верхнего в правый нижний угол таблицы. Для этого можно воспользоваться следующей леммой. Спасибо rng_58 за ссылку. А именно, если переформулировать применительно к нашему случаю, то лемма утверждает, что если есть множества начальных A = {a1, a2} и конечных B = {b1, b2} точек, то ответ можно посчитать, как следующий определитель: где f(x, y) — количество путей из точки x в точку y. Эту величину уже можно посчитать квадратной динамикой.Наконец, заметим, что для того, чтобы свести исходную задачу к этой, нам нужно сделать пути, которые не имеют совсем совпадающих точек — в исходной задаче разрешаются пересечения в первой и последней точках пути. Для этого в качестве множеств A и B мы можем взять точки A = {(0, 1), (1, 0)} и B = {(n - 2, m - 1), (n - 1, m - 2)}348E - ПилигримыДавайте сначала построим простое решение этой задачи, а затем попробуем решить ее эффективно, учитывая данные ограничения.Для каждой вершины найдем список наиболее удаленных вершин. Найдем вершины на пересечении путей от текущей вершины до каждой вершины из списка, в которых нет монастырей. Если мы удалим любую из этих вершин, то каждая вершина из списка будет недостижима из текущего монастыря. У каждой вершины из этого пересечения увеличим счетчик на единицу. Тогда ответ на задачу – максимум из счетчиков для всех вершин и количество таких максимумов.Теперь решим задачу более эффективно, но используя ту же идею. Подвесим дерево за корень. Будем для каждой вершины искать список наиболее удаленных вершин только в ее поддереве. При обходе дерева в глубину из каждой вершины возвращаем наибольшую глубину в поддереве и номер вершины, на которой он достигается. Среди всех сыновей вершины выберем максимум из глубин. Если максимум достигается один раз, то вернем из текущей вершины тот же ответ, что был возвращен из сына. Если максимум достигается более одного раза, то вернем из текущей вершины номер текущей вершины. По сути, таким образом мы находим LCA всех наиболее удаленных от текущей вершины вершин. Перед выходом из вершины прибавляем единицу на отрезке от текущей вершины до найденного LCA. Это можно сделать, если хранить эйлеров обход графа и использовать дерево отрезков для прибавления на отрезке.Наконец, последний этап решения задачи – решить ее для случая, когда наиболее удаленная вершина или их список находятся необязательно в поддереве текущей вершины. Для решения этой подзадачи используем ту же идею, которая используется при нахождении максимального по длине пути в дереве. Для каждой вершины будем хранить 3 максимума – 3 наиболее удаленные вершины в ее поддереве. Когда мы спускаемся в какое-то поддерево, то передаем заодно и 2 оставшихся максимума. Таким образом, находясь в любой вершине, мы можем решить, существует ли путь не в поддереве (то есть уходящий наверх) такой же или большей длины. Если в поддереве и вне его пути одинаковой длины, то это означает, что для пилигрима из текущего монастыря всегда найдется хотя бы один путь, какой бы город не удалили. Если одна из величин больше, то мы выбираем нужный отрезок в эйлеровом обходе дерева и увеличиваем на нем значение на единицу. Случай, когда есть несколько путей (то есть хотя бы 2) вне поддерева одинаковой максимальной длины, обрабатывается аналогично такому же случаю в поддереве.Поскольку дерево отрезков может отвечать на запрос за O(logN) времени, а задачу LCA можно эффективно решить методом двоичного подъема за то же время, то затраты времени и памяти равны O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 349 和字母"
          },
          "content_length": 9089
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #202 - Codeforces - Code 1",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 2",
          "code": "3 4 4 5 10 10 10 10 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 3",
          "code": "25 25 25 50 50 50 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #202 - Codeforces - Code 4",
          "code": "for(int j = 8; i >= 0; j--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -100000000, 100000000, \"a\");\n    inf.readEoln();\n\n    int total_size = 0;\n    for (int k = 1; k <= m; k++) {\n        int size = inf.readInt(1, 100000, \"|S_\" + to_string(k) + \"|\");\n        total_size += size;\n        ensuref(total_size <= 100000, \"Sum of sizes of Sk exceeds 100000\");\n        if (size > 0) {\n            inf.readSpace();\n        }\n        vector<int> Sk = inf.readInts(size, 1, n, \"S_\" + to_string(k));\n        inf.readEoln();\n\n        set<int> s(Sk.begin(), Sk.end());\n        ensuref(s.size() == Sk.size(), \"Set %d has duplicate indices\", k);\n    }\n\n    for (int i = 1; i <= q; i++) {\n        string line = inf.readLine();\n        istringstream iss(line);\n        vector<string> tokens;\n        string token;\n        while (iss >> token) {\n            tokens.push_back(token);\n        }\n        ensuref(!tokens.empty(), \"Empty query line at line %d\", i);\n\n        if (tokens[0] == \"?\") {\n            ensuref(tokens.size() == 2, \"Invalid format for query at line %d\", i);\n            int k;\n            try {\n                k = stoi(tokens[1]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer k in query at line %d\", i);\n            }\n            ensuref(1 <= k && k <= m, \"k out of range in query at line %d\", i);\n\n        } else if (tokens[0] == \"+\") {\n            ensuref(tokens.size() == 3, \"Invalid format for query at line %d\", i);\n            int k;\n            try {\n                k = stoi(tokens[1]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer k in query at line %d\", i);\n            }\n            ensuref(1 <= k && k <= m, \"k out of range in query at line %d\", i);\n\n            long long x;\n            try {\n                x = stoll(tokens[2]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer x in query at line %d\", i);\n            }\n            ensuref(abs(x) <= 100000000, \"x out of range in query at line %d\", i);\n        } else {\n            ensuref(false, \"Invalid query type at line %d\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -100000000, 100000000, \"a\");\n    inf.readEoln();\n\n    int total_size = 0;\n    for (int k = 1; k <= m; k++) {\n        int size = inf.readInt(1, 100000, \"|S_\" + to_string(k) + \"|\");\n        total_size += size;\n        ensuref(total_size <= 100000, \"Sum of sizes of Sk exceeds 100000\");\n        if (size > 0) {\n            inf.readSpace();\n        }\n        vector<int> Sk = inf.readInts(size, 1, n, \"S_\" + to_string(k));\n        inf.readEoln();\n\n        set<int> s(Sk.begin(), Sk.end());\n        ensuref(s.size() == Sk.size(), \"Set %d has duplicate indices\", k);\n    }\n\n    for (int i = 1; i <= q; i++) {\n        string line = inf.readLine();\n        istringstream iss(line);\n        vector<string> tokens;\n        string token;\n        while (iss >> token) {\n            tokens.push_back(token);\n        }\n        ensuref(!tokens.empty(), \"Empty query line at line %d\", i);\n\n        if (tokens[0] == \"?\") {\n            ensuref(tokens.size() == 2, \"Invalid format for query at line %d\", i);\n            int k;\n            try {\n                k = stoi(tokens[1]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer k in query at line %d\", i);\n            }\n            ensuref(1 <= k && k <= m, \"k out of range in query at line %d\", i);\n\n        } else if (tokens[0] == \"+\") {\n            ensuref(tokens.size() == 3, \"Invalid format for query at line %d\", i);\n            int k;\n            try {\n                k = stoi(tokens[1]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer k in query at line %d\", i);\n            }\n            ensuref(1 <= k && k <= m, \"k out of range in query at line %d\", i);\n\n            long long x;\n            try {\n                x = stoll(tokens[2]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer x in query at line %d\", i);\n            }\n            ensuref(abs(x) <= 100000000, \"x out of range in query at line %d\", i);\n        } else {\n            ensuref(false, \"Invalid query type at line %d\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -100000000, 100000000, \"a\");\n    inf.readEoln();\n\n    int total_size = 0;\n    for (int k = 1; k <= m; k++) {\n        int size = inf.readInt(1, 100000, \"|S_\" + to_string(k) + \"|\");\n        total_size += size;\n        ensuref(total_size <= 100000, \"Sum of sizes of Sk exceeds 100000\");\n        if (size > 0) {\n            inf.readSpace();\n        }\n        vector<int> Sk = inf.readInts(size, 1, n, \"S_\" + to_string(k));\n        inf.readEoln();\n\n        set<int> s(Sk.begin(), Sk.end());\n        ensuref(s.size() == Sk.size(), \"Set %d has duplicate indices\", k);\n    }\n\n    for (int i = 1; i <= q; i++) {\n        string line = inf.readLine();\n        istringstream iss(line);\n        vector<string> tokens;\n        string token;\n        while (iss >> token) {\n            tokens.push_back(token);\n        }\n        ensuref(!tokens.empty(), \"Empty query line at line %d\", i);\n\n        if (tokens[0] == \"?\") {\n            ensuref(tokens.size() == 2, \"Invalid format for query at line %d\", i);\n            int k;\n            try {\n                k = stoi(tokens[1]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer k in query at line %d\", i);\n            }\n            ensuref(1 <= k && k <= m, \"k out of range in query at line %d\", i);\n\n        } else if (tokens[0] == \"+\") {\n            ensuref(tokens.size() == 3, \"Invalid format for query at line %d\", i);\n            int k;\n            try {\n                k = stoi(tokens[1]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer k in query at line %d\", i);\n            }\n            ensuref(1 <= k && k <= m, \"k out of range in query at line %d\", i);\n\n            long long x;\n            try {\n                x = stoll(tokens[2]);\n            } catch(...) {\n                ensuref(false, \"Invalid integer x in query at line %d\", i);\n            }\n            ensuref(abs(x) <= 100000000, \"x out of range in query at line %d\", i);\n        } else {\n            ensuref(false, \"Invalid query type at line %d\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"n out of bounds\\n\");\n        exit(1);\n    }\n    if (m < 1 || m > 100000) {\n        fprintf(stderr, \"m out of bounds\\n\");\n        exit(1);\n    }\n    if (q < 1 || q > 100000) {\n        fprintf(stderr, \"q out of bounds\\n\");\n        exit(1);\n    }\n\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = rnd.next(-100000000, 100000000);\n    }\n\n    vector<vector<int>> S(m);\n    int total_S_size = 0;\n\n    // Generate sets S[0..m-1] based on type\n    if (type == \"small\") {\n        // Small random test cases\n        int max_S_size = min(10, n);\n        total_S_size = 0;\n        for (int i = 0; i < m; ++i) {\n            int sz = rnd.next(1, max_S_size);\n            total_S_size += sz;\n            S[i].resize(sz);\n            set<int> used_indices;\n            for (int j = 0; j < sz; ++j) {\n                int idx;\n                do {\n                    idx = rnd.next(1, n);\n                } while (used_indices.count(idx));\n                used_indices.insert(idx);\n                S[i][j] = idx;\n            }\n        }\n\n    } else if (type == \"max\") {\n        // Maximum sizes\n        if (m > 100000) m = 100000;\n        total_S_size = m;\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(1, n);\n            S[i].push_back(idx);\n        }\n\n    } else if (type == \"large_single_set\") {\n        // One or few large sets\n        m = min(m, 10);\n        total_S_size = 0;\n        int remaining_size = 100000; // total_S_size ≤ 1e5\n\n        for (int i = 0; i < m; ++i) {\n            int sz = remaining_size / (m - i);\n            if (sz > n) sz = n;\n            total_S_size += sz;\n            remaining_size -= sz;\n            S[i].resize(sz);\n            for (int j = 0; j < sz; ++j) {\n                S[i][j] = j + 1; // indices from 1 to sz\n            }\n            shuffle(S[i].begin(), S[i].end());\n        }\n\n    } else if (type == \"many_small_sets\") {\n        // Many small sets of size 1\n        m = min(m, 100000);\n        total_S_size = m;\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(1, n);\n            S[i].push_back(idx);\n        }\n\n    } else if (type == \"overlapping\") {\n        // Overlapping sets\n        m = min(m, 500);\n        total_S_size = 0;\n        int avg_S_size = 100000 / m;\n        for (int i = 0; i < m; ++i) {\n            int sz = avg_S_size;\n            if (i < 100000 % m) sz++;\n            total_S_size += sz;\n            set<int> used_indices;\n            S[i].resize(sz);\n            for (int j = 0; j < sz; ++j) {\n                int idx;\n                do {\n                    idx = rnd.next(1, n);\n                } while (used_indices.count(idx));\n                used_indices.insert(idx);\n                S[i][j] = idx;\n            }\n        }\n    } else if (type == \"disjoint\") {\n        // Disjoint sets\n        m = min(m, n);\n        total_S_size = min(n, 100000);\n        int cur_idx = 1;\n        for (int i = 0; i < m; ++i) {\n            int sz = total_S_size / m;\n            if (i < total_S_size % m) sz++;\n            S[i].resize(sz);\n            for (int j = 0; j < sz; ++j) {\n                if (cur_idx > n) break;\n                S[i][j] = cur_idx++;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random sets\n        total_S_size = 0;\n        int max_S_size = min(n, 10000);\n        for (int i = 0; i < m; ++i) {\n            int sz = rnd.next(1, max_S_size);\n            if (total_S_size + sz > 100000) sz = 100000 - total_S_size;\n            if (sz <= 0) break;\n            total_S_size += sz;\n            set<int> used_indices;\n            S[i].resize(sz);\n            for (int j = 0; j < sz; ++j) {\n                int idx;\n                do {\n                    idx = rnd.next(1, n);\n                } while (used_indices.count(idx));\n                used_indices.insert(idx);\n                S[i][j] = idx;\n            }\n        }\n        m = S.size(); // Adjust m if fewer sets generated\n    } else {\n        fprintf(stderr, \"Unknown type\\n\");\n        exit(1);\n    }\n\n    // Now generate queries\n    vector<string> queries;\n    for (int i = 0; i < q; ++i) {\n        // Randomly decide query type\n        int query_type = rnd.next(1, 2);\n        int k = rnd.next(1, m);\n        if (query_type == 1) {\n            // \"? k\"\n            queries.push_back(\"? \" + to_string(k));\n        } else {\n            // \"+ k x\"\n            int x = rnd.next(-100000000, 100000000);\n            queries.push_back(\"+ \" + to_string(k) + \" \" + to_string(x));\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, q);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", (int)S[i].size());\n        for (int x : S[i]) {\n            printf(\" %d\", x);\n        }\n        printf(\"\\n\");\n    }\n    for (string& s : queries) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"n out of bounds\\n\");\n        exit(1);\n    }\n    if (m < 1 || m > 100000) {\n        fprintf(stderr, \"m out of bounds\\n\");\n        exit(1);\n    }\n    if (q < 1 || q > 100000) {\n        fprintf(stderr, \"q out of bounds\\n\");\n        exit(1);\n    }\n\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = rnd.next(-100000000, 100000000);\n    }\n\n    vector<vector<int>> S(m);\n    int total_S_size = 0;\n\n    // Generate sets S[0..m-1] based on type\n    if (type == \"small\") {\n        // Small random test cases\n        int max_S_size = min(10, n);\n        total_S_size = 0;\n        for (int i = 0; i < m; ++i) {\n            int sz = rnd.next(1, max_S_size);\n            total_S_size += sz;\n            S[i].resize(sz);\n            set<int> used_indices;\n            for (int j = 0; j < sz; ++j) {\n                int idx;\n                do {\n                    idx = rnd.next(1, n);\n                } while (used_indices.count(idx));\n                used_indices.insert(idx);\n                S[i][j] = idx;\n            }\n        }\n\n    } else if (type == \"max\") {\n        // Maximum sizes\n        if (m > 100000) m = 100000;\n        total_S_size = m;\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(1, n);\n            S[i].push_back(idx);\n        }\n\n    } else if (type == \"large_single_set\") {\n        // One or few large sets\n        m = min(m, 10);\n        total_S_size = 0;\n        int remaining_size = 100000; // total_S_size ≤ 1e5\n\n        for (int i = 0; i < m; ++i) {\n            int sz = remaining_size / (m - i);\n            if (sz > n) sz = n;\n            total_S_size += sz;\n            remaining_size -= sz;\n            S[i].resize(sz);\n            for (int j = 0; j < sz; ++j) {\n                S[i][j] = j + 1; // indices from 1 to sz\n            }\n            shuffle(S[i].begin(), S[i].end());\n        }\n\n    } else if (type == \"many_small_sets\") {\n        // Many small sets of size 1\n        m = min(m, 100000);\n        total_S_size = m;\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(1, n);\n            S[i].push_back(idx);\n        }\n\n    } else if (type == \"overlapping\") {\n        // Overlapping sets\n        m = min(m, 500);\n        total_S_size = 0;\n        int avg_S_size = 100000 / m;\n        for (int i = 0; i < m; ++i) {\n            int sz = avg_S_size;\n            if (i < 100000 % m) sz++;\n            total_S_size += sz;\n            set<int> used_indices;\n            S[i].resize(sz);\n            for (int j = 0; j < sz; ++j) {\n                int idx;\n                do {\n                    idx = rnd.next(1, n);\n                } while (used_indices.count(idx));\n                used_indices.insert(idx);\n                S[i][j] = idx;\n            }\n        }\n    } else if (type == \"disjoint\") {\n        // Disjoint sets\n        m = min(m, n);\n        total_S_size = min(n, 100000);\n        int cur_idx = 1;\n        for (int i = 0; i < m; ++i) {\n            int sz = total_S_size / m;\n            if (i < total_S_size % m) sz++;\n            S[i].resize(sz);\n            for (int j = 0; j < sz; ++j) {\n                if (cur_idx > n) break;\n                S[i][j] = cur_idx++;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random sets\n        total_S_size = 0;\n        int max_S_size = min(n, 10000);\n        for (int i = 0; i < m; ++i) {\n            int sz = rnd.next(1, max_S_size);\n            if (total_S_size + sz > 100000) sz = 100000 - total_S_size;\n            if (sz <= 0) break;\n            total_S_size += sz;\n            set<int> used_indices;\n            S[i].resize(sz);\n            for (int j = 0; j < sz; ++j) {\n                int idx;\n                do {\n                    idx = rnd.next(1, n);\n                } while (used_indices.count(idx));\n                used_indices.insert(idx);\n                S[i][j] = idx;\n            }\n        }\n        m = S.size(); // Adjust m if fewer sets generated\n    } else {\n        fprintf(stderr, \"Unknown type\\n\");\n        exit(1);\n    }\n\n    // Now generate queries\n    vector<string> queries;\n    for (int i = 0; i < q; ++i) {\n        // Randomly decide query type\n        int query_type = rnd.next(1, 2);\n        int k = rnd.next(1, m);\n        if (query_type == 1) {\n            // \"? k\"\n            queries.push_back(\"? \" + to_string(k));\n        } else {\n            // \"+ k x\"\n            int x = rnd.next(-100000000, 100000000);\n            queries.push_back(\"+ \" + to_string(k) + \" \" + to_string(x));\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, q);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", (int)S[i].size());\n        for (int x : S[i]) {\n            printf(\" %d\", x);\n        }\n        printf(\"\\n\");\n    }\n    for (string& s : queries) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -q 5 -type small\n./gen -n 10 -m 5 -q 10 -type small\n./gen -n 50 -m 20 -q 50 -type small\n\n./gen -n 100000 -m 100000 -q 100000 -type max\n\n./gen -n 100000 -m 2 -q 100000 -type large_single_set\n./gen -n 100000 -m 5 -q 100000 -type large_single_set\n./gen -n 100000 -m 10 -q 100000 -type large_single_set\n\n./gen -n 100000 -m 100000 -q 100000 -type many_small_sets\n./gen -n 100000 -m 50000 -q 100000 -type many_small_sets\n./gen -n 100000 -m 25000 -q 100000 -type many_small_sets\n\n./gen -n 100000 -m 500 -q 100000 -type overlapping\n./gen -n 100000 -m 1000 -q 100000 -type overlapping\n./gen -n 100000 -m 2000 -q 100000 -type overlapping\n\n./gen -n 100000 -m 50000 -q 100000 -type disjoint\n./gen -n 100000 -m 100000 -q 100000 -type disjoint\n./gen -n 99999 -m 99999 -q 99999 -type disjoint\n\n./gen -n 100000 -m 1000 -q 100000 -type random\n./gen -n 50000 -m 50000 -q 100000 -type random\n./gen -n 100000 -m 1 -q 100000 -type random\n\n./gen -n 10 -m 1 -q 10 -type large_single_set\n./gen -n 100000 -m 1 -q 100000 -type large_single_set\n\n./gen -n 2 -m 2 -q 2 -type small\n\n./gen -n 10 -m 10 -q 10 -type many_small_sets\n./gen -n 100 -m 100 -q 100 -type many_small_sets\n\n./gen -n 100000 -m 50 -q 100000 -type overlapping\n\n./gen -n 100000 -m 100000 -q 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:20.420637",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "350/A",
      "title": "A. TL",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n, m (1 ≤ n, m ≤ 100). Во второй строке записаны n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 100) — время работы каждого из n верных решений в секундах. В третьей строке записаны m целых чисел через пробел b1, b2, ..., bm (1 ≤ bi ≤ 100) — время работы каждого из m неверных решений в секундах.",
      "output_spec": "Выходные данныеЕсли подходящее значение TL существует, выведите его. Иначе, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 64 5 28 9 6 10 7 11Выходные данныеСкопировать5Входные данныеСкопировать3 13 4 56Выходные данныеСкопировать-1",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n, m (1 ≤ n, m ≤ 100). Во второй строке записаны n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 100) — время работы каждого из n верных решений в секундах. В третьей строке записаны m целых чисел через пробел b1, b2, ..., bm (1 ≤ bi ≤ 100) — время работы каждого из m неверных решений в секундах.\n\nВходные данные\n\nВыходные данныеЕсли подходящее значение TL существует, выведите его. Иначе, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать3 64 5 28 9 6 10 7 11Выходные данныеСкопировать5Входные данныеСкопировать3 13 4 56Выходные данныеСкопировать-1\n\nВходные данныеСкопировать3 64 5 28 9 6 10 7 11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 13 4 56\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "Всем привет! Скоро (1 октября, 19:30 MSK) состоится очередной Codeforces Round #203 для участников Div. 2. Как обычно, Div. 1 участники смогут поучаствовать в этом раунде вне конкурса.Автором раунда являюсь я. Хочется сказать большое спасибо Гере Агапову (Gerald) за помощь в подготовке и за хорошие предложения по задачам. Спасибо Лось Илье (IlyaLos) за тестирование задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon. Также спасибо Игнатьеву Александру (aiMR) за тестирование задач и идею одной из них.Удачи!UPD: Будет использоваться динамическое распределение баллов. Задачи расположены в порядке увеличения сложности (по мнению авторов).UPD: Поздравляем победителей! fanhqme FAU.COACH Witalia sokian UPD: Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 804
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "350A - TLПусть v = min(ai), p = max(ai), c = min(bi). Тогда если max(2 * v, p) < c, то ответ max(2 * v, p). Иначе ответ  - 1.Авторское решение: 4632352350B - КурортВ этой задаче достаточно было реализовать следующее. По сути там задан граф, в виде массива предков для каждой вершины. Поскольку у каждой вершины максимум один предок, то для каждой вершины, являющейся отелем запустим такой алгоритм: будем подниматься по предкам prev[v] до тех пор, пока не встретим вершину со степенью исхода большей единицы. Степень исхода лучше посчитать заранее. После всего обновим ответ.Асимптотика решения O(n) по времени и O(n) по памяти.Авторское решение: 4632399350C - БомбыГлавная идея, это отсортировать все точки в порядке возрастания величины |xi| + |yi|. Дальше будем обрабатывать каждую точку жадно, максимум за шесть ходов. А именно, пусть мы хотим дойти сейчас до точки (x, y). Пусть x ≠ 0. Тогда нам нужно переместиться ровно на |x| в нужном направлении (если x < 0 то по направлению L, x > 0 — R). Аналогично сделаем для y-координаты. Теперь мы пришли в точку (x, y), возьмем в этой точке бомбу, и аналогично вернемся назад. Почему верно сортировать по так называемому манхэттенскому расстоянию? Понятно, что если мы посмотрим на путь, который мы получили, можно заметить, что все точки пути имеют меньшее манхэттенское расстояние, а значит их мы обработаем раньше.Асимптотика авторского решения Авторское решение: 4632478350D - Поиск совБудем решать задачу в целых числах. Поэтому всегда будем строить прямую в целых числах. Операцией нормализации прямой будем называть следующее: Пусть у нас есть прямая Ax + By + C. Пусть также g = gcd(A, gcd(B, C)) (gcd(0, 0) = 0).Если А < 0 (или A = 0 и B < 0), то умножим уравнение на -1 и поделим все коэффициенты на g.Теперь решение. Будем поддерживать два отображения (map<> на С++, TreeMap(HashMap) на Java) из прямой, в множество точек (некоторые точки могут встречаться несколько раз). В первом отображении в качестве множества точек мы будем хранить левые границы отрезков, во втором правые границы отрезков (в отсортированном виде).Заранее по каждому отрезку построим прямую, нормализуем ее, и поддержим наши указанные выше множества множества. Далее, для каждого возможного уравнения отсортируем указанные множества.Теперь переберем две окружности. Проверим, что расстояние между их центрами больше суммы радиусов и что радиусы одинаковы. Пусть мы построили прямую через центры (x1, y1) и (x2, y2). Перпендикулярная ей прямая, проходящая через центр отрезка [(x1, y1), (x2, y2)] будет иметь уравнение A = 2(x1 - x2), B = 2(y1 - y2), C =  - ((x1 - x2) * (x1 + x2) + (y1 - y2) * (y1 + y2)). После этого бинарным поиском по множеству точек, соответствующих указанной прямой, найдем две величины: cntL — количество отрезков, у которых левая граница правее ((x1 + x2) / 2, (y1 + y2) / 2) и cntR — количество отрезков, у которых правая граница левее ((x1 + x2) / 2, (y1 + y2) / 2). Тогда к ответу нужно прибавить величину cntV - cntR - cntL, где cntV — количество отрезков соответствующих заданной прямой в отображении.Итого, решение за .Код: 4632546350E - Неверный ФлойдРешение задачи очень простое, главное придумать почему это верно. Будем действовать так: построим граф с максимальным возможным количеством ребер, потом удалим лишнее. Во-первых, если k =  = n, то ответ -1. Иначе зафиксируем некоторую помеченную вершину, например a1. Возьмем в наш граф все ребра, кроме ребер вида a1 <  -  > x, где x — помеченная вершина. Теперь почему так действовать верно. Если алгоритм Валеры работает неверно, значит существуют пара вершин (i, j) такая, что кратчайшее расстояние посчитано неверно. Значит, на кратчайшем пути из вершины i в вершину j есть хотя бы одна не помеченная вершина (причем, что важно, она не должна совпадать ни с i, ни с j. Если бы такой вершины не было, кратчайшее расстояние посчиталось бы верно. Более того, не нарушая общности, будем считать, что кратчайшее расстояние между i и j равно двум, а алгоритм Валеры нашел больше. Далее, для более формального доказательства нужно рассмотреть случаи, в зависимости от того какой тип имеет каждая из вершин (i, j), однако я рассмотрю случай, когда мы получим больше всего ребер, а именно когда и i, и j — помеченные вершины (а их по условию всегда не меньше двух :)). Во-первых, проведем все ребра во между не зафиксированными ребрами. Дальше проведем и из i и из j ребра в не помеченные вершины. После этого проведем из i все ребра в помеченные, кроме вершины j. Понятно, что больше добавлять ребер нельзя, так как иначе алгоритм Валеры посчитает все верно. Таким образом, мы проведем ровно ребер.Код: 4632600 BONUS Простой бонус. Можете ли вы для аналогичных входных построить граф, где алгоритм Валеры будет работать верно?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9042",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 350\\s*A"
          },
          "content_length": 4739
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 1",
          "code": "System.out.println()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 2",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 3",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 4",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 5",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 6",
          "code": "if(abs(d1.x) == abs(d2.x))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 7",
          "code": "return (abs(a.x)==abs(b.x))?(abs(a.y)<abs(b.y)):(abs(a.x)<abs(b.x));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces - Code 1",
          "code": "vector<int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9042",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces - Code 2",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9042",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces - Code 3",
          "code": "lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9042",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces - Code 4",
          "code": "vector<int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9042",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n), bi(m);\n\n    if (type == \"random\") {\n        // Generate random ai and bi in the range [1, 100]\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 100);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(1, 100);\n    } else if (type == \"overlap\") {\n        // Generate ai and bi with overlapping ranges\n        int lower = rnd.next(1, 50);\n        int upper = rnd.next(lower, 100);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(lower, upper);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(lower, upper);\n    } else if (type == \"nonoverlap\") {\n        // Generate ai and bi with non-overlapping ranges\n        int max_ai = rnd.next(1, 50);\n        int min_bi = rnd.next(max_ai + 1, 100);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, max_ai);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(min_bi, 100);\n    } else if (type == \"all_equal_ai\") {\n        // All ai are equal\n        int val = rnd.next(1, 100);\n        for(int i = 0; i < n; ++i)\n            ai[i] = val;\n        // Random bi\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(1, 100);\n    } else if (type == \"all_equal_bi\") {\n        // All bi are equal\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 100);\n        int val = rnd.next(1, 100);\n        for(int i = 0; i < m; ++i)\n            bi[i] = val;\n    } else if (type == \"max\") {\n        // ai and bi are maximum values\n        for(int i = 0; i < n; ++i)\n            ai[i] = 100;\n        for(int i = 0; i < m; ++i)\n            bi[i] = 100;\n    } else if (type == \"min\") {\n        // ai and bi are minimum values\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n        for(int i = 0; i < m; ++i)\n            bi[i] = 1;\n    } else if (type == \"edge_v_equal_s\") {\n        // Make v = s = t, where s = max(max(ai), 2 * min(ai)), t = min(bi) - 1\n        int min_ai = rnd.next(1, 50);\n        int min_bi = 2 * min_ai + 1;\n        for(int i = 0; i < n; ++i)\n            ai[i] = min_ai;\n        for(int i = 0; i < m; ++i)\n            bi[i] = min_bi;\n    } else if (type == \"no_valid_v\") {\n        // Construct test case where no valid v exists\n        int max_ai = rnd.next(1, 50);\n        int min_bi = rnd.next(1, 100);\n        int s = max(max_ai, 2 * max_ai);\n        int t = min_bi - 1;\n        while (s <= t) {\n            max_ai = rnd.next(1, 50);\n            min_bi = rnd.next(max(s + 1, max_ai + 1), 100);\n            s = max(max_ai, 2 * max_ai);\n            t = min_bi -1;\n        }\n        for(int i = 0; i < n; ++i)\n            ai[i] = max_ai;\n        for(int i = 0; i < m; ++i)\n            bi[i] = min_bi;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output ai\n    for(int i =0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n\n    // Output bi\n    for(int i =0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", bi[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n), bi(m);\n\n    if (type == \"random\") {\n        // Generate random ai and bi in the range [1, 100]\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 100);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(1, 100);\n    } else if (type == \"overlap\") {\n        // Generate ai and bi with overlapping ranges\n        int lower = rnd.next(1, 50);\n        int upper = rnd.next(lower, 100);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(lower, upper);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(lower, upper);\n    } else if (type == \"nonoverlap\") {\n        // Generate ai and bi with non-overlapping ranges\n        int max_ai = rnd.next(1, 50);\n        int min_bi = rnd.next(max_ai + 1, 100);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, max_ai);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(min_bi, 100);\n    } else if (type == \"all_equal_ai\") {\n        // All ai are equal\n        int val = rnd.next(1, 100);\n        for(int i = 0; i < n; ++i)\n            ai[i] = val;\n        // Random bi\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(1, 100);\n    } else if (type == \"all_equal_bi\") {\n        // All bi are equal\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 100);\n        int val = rnd.next(1, 100);\n        for(int i = 0; i < m; ++i)\n            bi[i] = val;\n    } else if (type == \"max\") {\n        // ai and bi are maximum values\n        for(int i = 0; i < n; ++i)\n            ai[i] = 100;\n        for(int i = 0; i < m; ++i)\n            bi[i] = 100;\n    } else if (type == \"min\") {\n        // ai and bi are minimum values\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n        for(int i = 0; i < m; ++i)\n            bi[i] = 1;\n    } else if (type == \"edge_v_equal_s\") {\n        // Make v = s = t, where s = max(max(ai), 2 * min(ai)), t = min(bi) - 1\n        int min_ai = rnd.next(1, 50);\n        int min_bi = 2 * min_ai + 1;\n        for(int i = 0; i < n; ++i)\n            ai[i] = min_ai;\n        for(int i = 0; i < m; ++i)\n            bi[i] = min_bi;\n    } else if (type == \"no_valid_v\") {\n        // Construct test case where no valid v exists\n        int max_ai = rnd.next(1, 50);\n        int min_bi = rnd.next(1, 100);\n        int s = max(max_ai, 2 * max_ai);\n        int t = min_bi - 1;\n        while (s <= t) {\n            max_ai = rnd.next(1, 50);\n            min_bi = rnd.next(max(s + 1, max_ai + 1), 100);\n            s = max(max_ai, 2 * max_ai);\n            t = min_bi -1;\n        }\n        for(int i = 0; i < n; ++i)\n            ai[i] = max_ai;\n        for(int i = 0; i < m; ++i)\n            bi[i] = min_bi;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output ai\n    for(int i =0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n\n    // Output bi\n    for(int i =0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", bi[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 1 -m 100 -type random\n./gen -n 100 -m 1 -type random\n\n./gen -n 10 -m 10 -type overlap\n./gen -n 100 -m 100 -type overlap\n\n./gen -n 10 -m 10 -type nonoverlap\n./gen -n 100 -m 100 -type nonoverlap\n\n./gen -n 10 -m 10 -type all_equal_ai\n./gen -n 100 -m 100 -type all_equal_ai\n\n./gen -n 10 -m 10 -type all_equal_bi\n./gen -n 100 -m 100 -type all_equal_bi\n\n./gen -n 10 -m 10 -type min\n./gen -n 100 -m 100 -type min\n\n./gen -n 10 -m 10 -type max\n./gen -n 100 -m 100 -type max\n\n./gen -n 10 -m 10 -type edge_v_equal_s\n./gen -n 100 -m 100 -type edge_v_equal_s\n\n./gen -n 10 -m 10 -type no_valid_v\n./gen -n 100 -m 100 -type no_valid_v\n\n./gen -n 1 -m 1 -type all_equal_ai\n./gen -n 1 -m 100 -type all_equal_bi\n./gen -n 50 -m 50 -type random\n./gen -n 75 -m 25 -type nonoverlap\n./gen -n 25 -m 75 -type overlap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:22.611475",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "350/B",
      "title": "B. Resort",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of objects.The second line contains n space-separated integers type1, type2, ..., typen — the types of the objects. If typei equals zero, then the i-th object is the mountain. If typei equals one, then the i-th object is the hotel. It is guaranteed that at least one object is a hotel.The third line of the input contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ n) — the description of the ski tracks. If number ai equals zero, then there is no such object v, that has a ski track built from v to i. If number ai doesn't equal zero, that means that there is a track built from object ai to object i.",
      "output_spec": "OutputIn the first line print k — the maximum possible path length for Valera. In the second line print k integers v1, v2, ..., vk — the path. If there are multiple solutions, you can print any of them.",
      "sample_tests": "ExamplesInputCopy50 0 0 0 10 1 2 3 4OutputCopy51 2 3 4 5InputCopy50 0 1 0 10 1 2 2 4OutputCopy24 5InputCopy41 0 0 02 3 4 2OutputCopy11",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of objects.The second line contains n space-separated integers type1, type2, ..., typen — the types of the objects. If typei equals zero, then the i-th object is the mountain. If typei equals one, then the i-th object is the hotel. It is guaranteed that at least one object is a hotel.The third line of the input contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ n) — the description of the ski tracks. If number ai equals zero, then there is no such object v, that has a ski track built from v to i. If number ai doesn't equal zero, that means that there is a track built from object ai to object i.\n\nOutputIn the first line print k — the maximum possible path length for Valera. In the second line print k integers v1, v2, ..., vk — the path. If there are multiple solutions, you can print any of them.\n\nInputCopy50 0 0 0 10 1 2 3 4OutputCopy51 2 3 4 5InputCopy50 0 1 0 10 1 2 2 4OutputCopy24 5InputCopy41 0 0 02 3 4 2OutputCopy11\n\nInputCopy50 0 0 0 10 1 2 3 4\n\nOutputCopy51 2 3 4 5\n\nInputCopy50 0 1 0 10 1 2 2 4\n\nOutputCopy24 5\n\nInputCopy41 0 0 02 3 4 2\n\nOutputCopy11",
      "solutions": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on October 1 at 19:30 MSK) you are lucky to participate in Codeforces Round #203 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) for testing of problems, Alexander Ignatyev (aiMR) for testing of problems and for idea of one of the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova (Delinur) for translation of statements.Good luck!UPD:Scoring will be dynamic. Problems are sorted by increasing order of difficulty.UPD: Congratulations to winners: fanhqme FAU.COACH Witalia sokian UPD: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 741
        },
        {
          "title": "Editorial Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "350A - TLLet's v = min(ai), p = max(ai), c = min(bi). So, if max(2 * v, p) < c, then answer is max(2 * v, p), else answer is  - 1.Author solution: 4632352350B - ResortInput data represents a graph, by using a array of parents of every vertex. Because every vertex has at most one parent, we can use following solution: we will go up to parent of vertex v (prev[v]) until not found vertex with the outcome degree  ≥ 2. It is better to calculate outcome degrees in advance. After all, we will update the answer.This algorithm works in O(n).Author solution: 4632399350C - BombsFirst of all, Let's sort all point by increasing of value |xi| + |yi|, all points we will process by using this order. We will process each point greedily, by using maximum six moves. Now we want to come to the point (x, y). Let's x ≠ 0. Then we need to move exactly |x| in the dir direction (if x < 0 the dir is L, x > 0 — R). Similarly we will work with y-coordinates of point (x, y). Now we at the point (x, y), let's pick a bomb at point (x, y). After that we should come back to point (0, 0). Why it is correct to sort all point by increasing of Manhattan distance? If you will look at the path that we have received, you can notice that all points of path have lower Manhattan distance, i.e. we will process this points earlier.This solution works in Authors solution: 4632478350D - Looking for OwlsIt's possible to solve this problem by using only integer calculations. Normalization of the line Ax + By + C is following operation: we multiply our equation on the value , where g = gcd(A, gcd(B, C)), if A < 0 (orA = 0andB < 0) then sgn equals to  - 1, else sgn equals to 1.Now the solution. We will have two maps (map<> in С++, TreeMap(HashMap) in Java) to a set of points (it's possible that some points will have multiply occurrence into the set). In first map we will store right boundaries of the segments, in second — left boundaries (in increasing order).In advance for every segment we will build a normalized line, and for this normalized line we will put in our maps left and right segments of the segment.After all, for every fixed line let's sort our sets.Let's fix two different circles. After that, let's check that distance beetween them is greater then sum their radiuses, also you should check that circles has same radius. We can assume that we builded a line between centers of circles (x1, y1) and (x2, y2). Perpendicular to this line will have next coefficients (center of the segment [(x1, y1), (x2, y2)] also will belong to the next line) A = 2(x1 - x2), B = 2(y1 - y2), C =  - ((x1 - x2) * (x1 + x2) + (y1 - y2) * (y1 + y2)). After that you need to calculate values cntL, cntR by using binary search on set of points that lie on this line. cntL — amount of left boundaries that lie on the right side of point ((x1 + x2) / 2, (y1 + y2) / 2), cntR -- amount of right boundaries that lie on the left side of the point ((x1 + x2) / 2, (y1 + y2) / 2). After that you should add to answer value cntV - cntR - cntL,l where cntV — amount of segments, that lie on the nolmalized line.Total complexity: .solution: 4632546350E - Wrong FloydLet's do the following: construct the graph with the maximum possible number of edges and then remove the excess. First of all, you can notice that if k = n answer is  - 1. Else let's fix some marked vertex, for example a1. Let's put in our graph all edges except edges beetween a1 and x, where x — an another marked vertex. So, why this algorithm is correct? If Valera's algorithm is wrong, then there are a ''bad'' pair of vertexes (i, j). ``Bad'' pair is a pair for that Valera's algorithm works wrong. So, there are not marked vertex v on the shortest path from i to j, and v ≠ i, and v ≠ j. Without loss of generality, we can assume, that distance beetween i and j equals to 2, but Valera's algorithm gives greater answer. There are some cases, that depends on the type of vertexes i, j. But we can look only at the case where (i, j) are marked vertexes. First, add to the graph all edges beetween not fixed (i, j) vertexes. Second, add to the graph edges beetween some fixed vertex (i or j) and some not marked vertex. Third, add to the graph edges beetween i and some marked vertex v, where v ≠ j. It's simple to understand, that if we add some another edge, the Valera's algorithm will work correctly. Total amount of edges is .BONUS Simple bonus. For same contrains (n, m, k) can you build a graph, where Valera's code works correctly? Код: 4632600",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9042",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 350\\s*B"
          },
          "content_length": 4491
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 1",
          "code": "System.out.println()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 2",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 3",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 4",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 5",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 6",
          "code": "if(abs(d1.x) == abs(d2.x))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 7",
          "code": "return (abs(a.x)==abs(b.x))?(abs(a.y)<abs(b.y)):(abs(a.x)<abs(b.x));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> type = inf.readInts(n, 0, 1, \"type\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n, \"a\");\n    inf.readEoln();\n\n    int hotel_count = 0;\n    for (int i = 0; i < n; ++i) {\n        ensuref(type[i] == 0 || type[i] == 1, \"type[%d] must be 0 or 1\", i + 1);\n        if (type[i] == 1) {\n            hotel_count++;\n        }\n    }\n    ensuref(hotel_count >= 1, \"At least one hotel must exist\");\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(0 <= a[i] && a[i] <= n, \"a[%d] must be between 0 and %d\", i + 1, n);\n        if (a[i] != 0) {\n            ensuref(1 <= a[i] && a[i] <= n, \"Invalid edge from node %d to node %d\", a[i], i + 1);\n            ensuref(type[a[i] - 1] == 0, \"Edge from node %d to node %d but node %d is not a mountain\", a[i], i + 1, a[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> type = inf.readInts(n, 0, 1, \"type\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n, \"a\");\n    inf.readEoln();\n\n    int hotel_count = 0;\n    for (int i = 0; i < n; ++i) {\n        ensuref(type[i] == 0 || type[i] == 1, \"type[%d] must be 0 or 1\", i + 1);\n        if (type[i] == 1) {\n            hotel_count++;\n        }\n    }\n    ensuref(hotel_count >= 1, \"At least one hotel must exist\");\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(0 <= a[i] && a[i] <= n, \"a[%d] must be between 0 and %d\", i + 1, n);\n        if (a[i] != 0) {\n            ensuref(1 <= a[i] && a[i] <= n, \"Invalid edge from node %d to node %d\", a[i], i + 1);\n            ensuref(type[a[i] - 1] == 0, \"Edge from node %d to node %d but node %d is not a mountain\", a[i], i + 1, a[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> type = inf.readInts(n, 0, 1, \"type\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n, \"a\");\n    inf.readEoln();\n\n    int hotel_count = 0;\n    for (int i = 0; i < n; ++i) {\n        ensuref(type[i] == 0 || type[i] == 1, \"type[%d] must be 0 or 1\", i + 1);\n        if (type[i] == 1) {\n            hotel_count++;\n        }\n    }\n    ensuref(hotel_count >= 1, \"At least one hotel must exist\");\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(0 <= a[i] && a[i] <= n, \"a[%d] must be between 0 and %d\", i + 1, n);\n        if (a[i] != 0) {\n            ensuref(1 <= a[i] && a[i] <= n, \"Invalid edge from node %d to node %d\", a[i], i + 1);\n            ensuref(type[a[i] - 1] == 0, \"Edge from node %d to node %d but node %d is not a mountain\", a[i], i + 1, a[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    vector<int> type(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        type[i] = inf.readInt(0, 1, format(\"type[%d]\", i).c_str());\n    }\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        a[i] = inf.readInt(0, n, format(\"a[%d]\", i).c_str());\n    }\n\n    int kmax = ans.readInt(1, n, \"kmax\");\n    int k = ouf.readInt(1, n, \"k\");\n    if (k < kmax) {\n        quitf(_wa, \"Your path length %d is less than maximal possible length %d\", k, kmax);\n    } else if (k > kmax) {\n        quitf(_fail, \"Participant's path length %d is greater than maximal possible length %d\", k, kmax);\n    }\n\n    vector<int> path(k);\n    set<int> used;\n    for (int i = 0; i < k; ++i) {\n        path[i] = ouf.readInt(1, n, format(\"path[%d]\", i + 1).c_str());\n        if (used.count(path[i])) {\n            quitf(_wa, \"Object %d is used more than once in the path\", path[i]);\n        }\n        used.insert(path[i]);\n    }\n    // Validate the path\n    for (int i = 0; i < k - 1; ++i) {\n        int vi = path[i];\n        int vi1 = path[i + 1];\n        if (a[vi1] != vi) {\n            quitf(_wa, \"Invalid path at position %d: a[%d] = %d, expected %d\", i + 2, vi1, a[vi1], vi);\n        }\n        if (type[vi] != 0) {\n            quitf(_wa, \"Object %d is not a mountain\", vi);\n        }\n    }\n    if (type[path[k - 1]] != 1) {\n        quitf(_wa, \"The last object %d is not a hotel\", path[k - 1]);\n    }\n    if (k == kmax)\n        quitf(_ok, \"Correct path of maximal length %d\", k);\n    else\n        quitf(_wa, \"Incorrect path length\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> types(n + 1, 0); // types[1..n], 0 for mountain, 1 for hotel\n    vector<int> a(n + 1, 0); // a[1..n], ai represents the node u such that there is a track from u to i (i.e., u->i)\n\n    if (type == \"chain\") {\n        // Build a chain from node 1 to node n\n        for (int i = 1; i <= n; ++i) {\n            if (i < n)\n                types[i] = 0; // Mountains\n            else\n                types[i] = 1; // Last node is a hotel\n        }\n        for (int i = 2; i <= n; ++i) {\n            a[i] = i - 1; // Edge from node i-1 to node i\n        }\n    } else if (type == \"branching\") {\n        // Build a tree with branching nodes\n        // Initialize types: all mountains initially\n        for (int i = 1; i <= n; ++i)\n            types[i] = 0;\n\n        // Ensure at least one hotel\n        int num_hotels = rnd.next(1, max(1, n / 10));\n        set<int> hotel_nodes;\n        while ((int)hotel_nodes.size() < num_hotels) {\n            int hotel_node = rnd.next(1, n);\n            types[hotel_node] = 1; // Hotel\n            hotel_nodes.insert(hotel_node);\n        }\n\n        // Prepare list of available nodes for assigning incoming edges\n        vector<int> nodes_without_incoming;\n        for (int i = 1; i <= n; ++i)\n            nodes_without_incoming.push_back(i);\n\n        // Remove hotel nodes from nodes that can have outgoing edges\n        vector<int> nodes_with_outgoing;\n        for (int i = 1; i <= n; ++i)\n            if (types[i] == 0) // Mountains can have outgoing edges\n                nodes_with_outgoing.push_back(i);\n\n        // Shuffle nodes\n        shuffle(nodes_with_outgoing.begin(), nodes_with_outgoing.end());\n\n        // Assign edges\n        for (int i = 0; i < (int)nodes_with_outgoing.size(); ++i) {\n            int u = nodes_with_outgoing[i];\n            int num_children = rnd.next(0, 3); // Decide number of outgoing edges (0 to 3)\n            for (int j = 0; j < num_children && !nodes_without_incoming.empty(); ++j) {\n                // Select a node v without incoming edges and not u\n                int idx = rnd.next(0, (int)nodes_without_incoming.size() - 1);\n                int v = nodes_without_incoming[idx];\n\n                if (v == u) {\n                    // Avoid self-loop\n                    continue;\n                }\n                if (a[v] != 0) {\n                    // Node already has an incoming edge\n                    continue;\n                }\n                a[v] = u; // Edge from u to v\n                // Remove v from nodes_without_incoming\n                nodes_without_incoming[idx] = nodes_without_incoming.back();\n                nodes_without_incoming.pop_back();\n            }\n        }\n    } else if (type == \"star\") {\n        // Build a star: one mountain connected to many hotels\n        int center = rnd.next(1, n);\n        types[center] = 0; // Mountain in the center\n\n        // Assign hotels to the rest of the nodes\n        for (int i = 1; i <= n; ++i)\n            if (i != center)\n                types[i] = 1; // Hotels\n\n        // Connect center to all hotels\n        for (int i = 1; i <= n; ++i) {\n            if (i != center) {\n                a[i] = center; // Edge from center to hotel i\n            }\n        }\n    } else if (type == \"random\") {\n        // Assign random types, ensure at least one hotel\n        int num_hotels = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i)\n            types[i] = 0; // All mountains initially\n\n        for (int i = 0; i < num_hotels; ++i) {\n            int hotel_node = rnd.next(1, n);\n            types[hotel_node] = 1; // Hotel\n        }\n\n        // Build random edges\n        vector<int> nodes_without_incoming;\n        for (int i = 1; i <= n; ++i)\n            nodes_without_incoming.push_back(i);\n\n        shuffle(nodes_without_incoming.begin(), nodes_without_incoming.end());\n        for (int i = 0; i < n; ++i) {\n            int u = nodes_without_incoming[i];\n            if (types[u] == 1)\n                continue; // Hotels have no outgoing edges\n            int have_outgoing = rnd.next(0, 1); // Randomly decide if u has outgoing edge\n            if (have_outgoing && i + 1 < n) {\n                int v = nodes_without_incoming[i + 1];\n                if (v != u && a[v] == 0) {\n                    a[v] = u; // Edge from u to v\n                }\n            }\n        }\n    } else if (type == \"maximal_paths\") {\n        // Build multiple maximal paths of maximum possible length\n        int num_paths = rnd.next(1, max(1, n / 1000));\n        int nodes_per_path = n / num_paths;\n        int current_node = 1;\n        for (int path = 0; path < num_paths; ++path) {\n            int path_length = nodes_per_path;\n            if (path == num_paths - 1)\n                path_length = n - current_node + 1; // Remaining nodes\n            for (int i = 0; i < path_length; ++i) {\n                int node = current_node + i;\n                if (i < path_length - 1)\n                    types[node] = 0; // Mountain\n                else\n                    types[node] = 1; // Hotel\n\n                if (i > 0)\n                    a[node] = node - 1; // Edge from node-1 to node\n            }\n            current_node += path_length;\n        }\n    } else if (type == \"single_node\") {\n        // Single node, which is a hotel\n        n = 1;\n        types.resize(n + 1);\n        a.resize(n + 1);\n        types[1] = 1;\n        a[1] = 0;\n    } else {\n        // Default to random\n        // Similar implementation as the \"random\" type\n        // ...\n    }\n\n    // Ensure at least one hotel exists\n    bool has_hotel = false;\n    for (int i = 1; i <= n; ++i)\n        if (types[i] == 1)\n            has_hotel = true;\n    if (!has_hotel)\n        types[n] = 1; // Set last node as hotel\n\n    // Output the generated test case\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", types[i]);\n        if (i < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> types(n + 1, 0); // types[1..n], 0 for mountain, 1 for hotel\n    vector<int> a(n + 1, 0); // a[1..n], ai represents the node u such that there is a track from u to i (i.e., u->i)\n\n    if (type == \"chain\") {\n        // Build a chain from node 1 to node n\n        for (int i = 1; i <= n; ++i) {\n            if (i < n)\n                types[i] = 0; // Mountains\n            else\n                types[i] = 1; // Last node is a hotel\n        }\n        for (int i = 2; i <= n; ++i) {\n            a[i] = i - 1; // Edge from node i-1 to node i\n        }\n    } else if (type == \"branching\") {\n        // Build a tree with branching nodes\n        // Initialize types: all mountains initially\n        for (int i = 1; i <= n; ++i)\n            types[i] = 0;\n\n        // Ensure at least one hotel\n        int num_hotels = rnd.next(1, max(1, n / 10));\n        set<int> hotel_nodes;\n        while ((int)hotel_nodes.size() < num_hotels) {\n            int hotel_node = rnd.next(1, n);\n            types[hotel_node] = 1; // Hotel\n            hotel_nodes.insert(hotel_node);\n        }\n\n        // Prepare list of available nodes for assigning incoming edges\n        vector<int> nodes_without_incoming;\n        for (int i = 1; i <= n; ++i)\n            nodes_without_incoming.push_back(i);\n\n        // Remove hotel nodes from nodes that can have outgoing edges\n        vector<int> nodes_with_outgoing;\n        for (int i = 1; i <= n; ++i)\n            if (types[i] == 0) // Mountains can have outgoing edges\n                nodes_with_outgoing.push_back(i);\n\n        // Shuffle nodes\n        shuffle(nodes_with_outgoing.begin(), nodes_with_outgoing.end());\n\n        // Assign edges\n        for (int i = 0; i < (int)nodes_with_outgoing.size(); ++i) {\n            int u = nodes_with_outgoing[i];\n            int num_children = rnd.next(0, 3); // Decide number of outgoing edges (0 to 3)\n            for (int j = 0; j < num_children && !nodes_without_incoming.empty(); ++j) {\n                // Select a node v without incoming edges and not u\n                int idx = rnd.next(0, (int)nodes_without_incoming.size() - 1);\n                int v = nodes_without_incoming[idx];\n\n                if (v == u) {\n                    // Avoid self-loop\n                    continue;\n                }\n                if (a[v] != 0) {\n                    // Node already has an incoming edge\n                    continue;\n                }\n                a[v] = u; // Edge from u to v\n                // Remove v from nodes_without_incoming\n                nodes_without_incoming[idx] = nodes_without_incoming.back();\n                nodes_without_incoming.pop_back();\n            }\n        }\n    } else if (type == \"star\") {\n        // Build a star: one mountain connected to many hotels\n        int center = rnd.next(1, n);\n        types[center] = 0; // Mountain in the center\n\n        // Assign hotels to the rest of the nodes\n        for (int i = 1; i <= n; ++i)\n            if (i != center)\n                types[i] = 1; // Hotels\n\n        // Connect center to all hotels\n        for (int i = 1; i <= n; ++i) {\n            if (i != center) {\n                a[i] = center; // Edge from center to hotel i\n            }\n        }\n    } else if (type == \"random\") {\n        // Assign random types, ensure at least one hotel\n        int num_hotels = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i)\n            types[i] = 0; // All mountains initially\n\n        for (int i = 0; i < num_hotels; ++i) {\n            int hotel_node = rnd.next(1, n);\n            types[hotel_node] = 1; // Hotel\n        }\n\n        // Build random edges\n        vector<int> nodes_without_incoming;\n        for (int i = 1; i <= n; ++i)\n            nodes_without_incoming.push_back(i);\n\n        shuffle(nodes_without_incoming.begin(), nodes_without_incoming.end());\n        for (int i = 0; i < n; ++i) {\n            int u = nodes_without_incoming[i];\n            if (types[u] == 1)\n                continue; // Hotels have no outgoing edges\n            int have_outgoing = rnd.next(0, 1); // Randomly decide if u has outgoing edge\n            if (have_outgoing && i + 1 < n) {\n                int v = nodes_without_incoming[i + 1];\n                if (v != u && a[v] == 0) {\n                    a[v] = u; // Edge from u to v\n                }\n            }\n        }\n    } else if (type == \"maximal_paths\") {\n        // Build multiple maximal paths of maximum possible length\n        int num_paths = rnd.next(1, max(1, n / 1000));\n        int nodes_per_path = n / num_paths;\n        int current_node = 1;\n        for (int path = 0; path < num_paths; ++path) {\n            int path_length = nodes_per_path;\n            if (path == num_paths - 1)\n                path_length = n - current_node + 1; // Remaining nodes\n            for (int i = 0; i < path_length; ++i) {\n                int node = current_node + i;\n                if (i < path_length - 1)\n                    types[node] = 0; // Mountain\n                else\n                    types[node] = 1; // Hotel\n\n                if (i > 0)\n                    a[node] = node - 1; // Edge from node-1 to node\n            }\n            current_node += path_length;\n        }\n    } else if (type == \"single_node\") {\n        // Single node, which is a hotel\n        n = 1;\n        types.resize(n + 1);\n        a.resize(n + 1);\n        types[1] = 1;\n        a[1] = 0;\n    } else {\n        // Default to random\n        // Similar implementation as the \"random\" type\n        // ...\n    }\n\n    // Ensure at least one hotel exists\n    bool has_hotel = false;\n    for (int i = 1; i <= n; ++i)\n        if (types[i] == 1)\n            has_hotel = true;\n    if (!has_hotel)\n        types[n] = 1; // Set last node as hotel\n\n    // Output the generated test case\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", types[i]);\n        if (i < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small chain\n./gen -n 5 -type chain\n\n# Small branching tree\n./gen -n 5 -type branching\n\n# Small star\n./gen -n 5 -type star\n\n# Random small graph\n./gen -n 5 -type random\n\n# Medium chain\n./gen -n 100 -type chain\n\n# Medium branching tree\n./gen -n 100 -type branching\n\n# Medium star\n./gen -n 100 -type star\n\n# Random medium graph\n./gen -n 100 -type random\n\n# Large chain\n./gen -n 10000 -type chain\n\n# Large branching tree\n./gen -n 10000 -type branching\n\n# Large star\n./gen -n 10000 -type star\n\n# Random large graph\n./gen -n 10000 -type random\n\n# Maximal paths (multiple long paths)\n./gen -n 100000 -type maximal_paths\n\n# Single node (edge case)\n./gen -n 1 -type single_node\n\n# Chain of maximum size\n./gen -n 100000 -type chain\n\n# Branching to test multiple outgoing edges\n./gen -n 100000 -type branching\n\n# Star with maximum hotels\n./gen -n 100000 -type star\n\n# Random graph with maximum nodes\n./gen -n 100000 -type random\n\n# Random small graph with varied degrees\n./gen -n 50 -type random\n\n# Chain with minimal nodes\n./gen -n 2 -type chain\n\n# Branching with minimal nodes\n./gen -n 2 -type branching\n\n# Random graph with minimal nodes\n./gen -n 2 -type random\n\n# Chain with all mountains except last node hotel\n./gen -n 100000 -type chain\n\n# Multiple small paths\n./gen -n 100000 -type maximal_paths\n\n# Edge case with no edges\n./gen -n 100000 -type single_node\n\n# Random graph to test edge conditions\n./gen -n 99999 -type random\n\n# Branching tree with many outgoing edges\n./gen -n 100000 -type branching\n\n# Star graph to test how the solution handles many hotels\n./gen -n 100000 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:24.317800",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "350/C",
      "title": "C. Bombs",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of bombs on the coordinate plane. Next n lines contain two integers each. The i-th line contains numbers (xi, yi) ( - 109 ≤ xi, yi ≤ 109) — the coordinates of the i-th bomb. It is guaranteed that no two bombs are located at the same point and no bomb is at point (0, 0).",
      "output_spec": "OutputIn a single line print a single integer k — the minimum number of operations needed to destroy all bombs. On the next lines print the descriptions of these k operations. If there are multiple sequences, you can print any of them. It is guaranteed that there is the solution where k ≤ 106.",
      "sample_tests": "ExamplesInputCopy21 1-1 -1OutputCopy121 1 R1 1 U21 1 L1 1 D31 1 L1 1 D21 1 R1 1 U3InputCopy35 00 51 0OutputCopy121 1 R21 1 L31 5 R21 5 L31 5 U21 5 D3",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of bombs on the coordinate plane. Next n lines contain two integers each. The i-th line contains numbers (xi, yi) ( - 109 ≤ xi, yi ≤ 109) — the coordinates of the i-th bomb. It is guaranteed that no two bombs are located at the same point and no bomb is at point (0, 0).\n\nOutputIn a single line print a single integer k — the minimum number of operations needed to destroy all bombs. On the next lines print the descriptions of these k operations. If there are multiple sequences, you can print any of them. It is guaranteed that there is the solution where k ≤ 106.\n\nInputCopy21 1-1 -1OutputCopy121 1 R1 1 U21 1 L1 1 D31 1 L1 1 D21 1 R1 1 U3InputCopy35 00 51 0OutputCopy121 1 R21 1 L31 5 R21 5 L31 5 U21 5 D3\n\nInputCopy21 1-1 -1\n\nOutputCopy121 1 R1 1 U21 1 L1 1 D31 1 L1 1 D21 1 R1 1 U3\n\nInputCopy35 00 51 0\n\nOutputCopy121 1 R21 1 L31 5 R21 5 L31 5 U21 5 D3",
      "solutions": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on October 1 at 19:30 MSK) you are lucky to participate in Codeforces Round #203 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) for testing of problems, Alexander Ignatyev (aiMR) for testing of problems and for idea of one of the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova (Delinur) for translation of statements.Good luck!UPD:Scoring will be dynamic. Problems are sorted by increasing order of difficulty.UPD: Congratulations to winners: fanhqme FAU.COACH Witalia sokian UPD: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 741
        },
        {
          "title": "Editorial Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "350A - TLLet's v = min(ai), p = max(ai), c = min(bi). So, if max(2 * v, p) < c, then answer is max(2 * v, p), else answer is  - 1.Author solution: 4632352350B - ResortInput data represents a graph, by using a array of parents of every vertex. Because every vertex has at most one parent, we can use following solution: we will go up to parent of vertex v (prev[v]) until not found vertex with the outcome degree  ≥ 2. It is better to calculate outcome degrees in advance. After all, we will update the answer.This algorithm works in O(n).Author solution: 4632399350C - BombsFirst of all, Let's sort all point by increasing of value |xi| + |yi|, all points we will process by using this order. We will process each point greedily, by using maximum six moves. Now we want to come to the point (x, y). Let's x ≠ 0. Then we need to move exactly |x| in the dir direction (if x < 0 the dir is L, x > 0 — R). Similarly we will work with y-coordinates of point (x, y). Now we at the point (x, y), let's pick a bomb at point (x, y). After that we should come back to point (0, 0). Why it is correct to sort all point by increasing of Manhattan distance? If you will look at the path that we have received, you can notice that all points of path have lower Manhattan distance, i.e. we will process this points earlier.This solution works in Authors solution: 4632478350D - Looking for OwlsIt's possible to solve this problem by using only integer calculations. Normalization of the line Ax + By + C is following operation: we multiply our equation on the value , where g = gcd(A, gcd(B, C)), if A < 0 (orA = 0andB < 0) then sgn equals to  - 1, else sgn equals to 1.Now the solution. We will have two maps (map<> in С++, TreeMap(HashMap) in Java) to a set of points (it's possible that some points will have multiply occurrence into the set). In first map we will store right boundaries of the segments, in second — left boundaries (in increasing order).In advance for every segment we will build a normalized line, and for this normalized line we will put in our maps left and right segments of the segment.After all, for every fixed line let's sort our sets.Let's fix two different circles. After that, let's check that distance beetween them is greater then sum their radiuses, also you should check that circles has same radius. We can assume that we builded a line between centers of circles (x1, y1) and (x2, y2). Perpendicular to this line will have next coefficients (center of the segment [(x1, y1), (x2, y2)] also will belong to the next line) A = 2(x1 - x2), B = 2(y1 - y2), C =  - ((x1 - x2) * (x1 + x2) + (y1 - y2) * (y1 + y2)). After that you need to calculate values cntL, cntR by using binary search on set of points that lie on this line. cntL — amount of left boundaries that lie on the right side of point ((x1 + x2) / 2, (y1 + y2) / 2), cntR -- amount of right boundaries that lie on the left side of the point ((x1 + x2) / 2, (y1 + y2) / 2). After that you should add to answer value cntV - cntR - cntL,l where cntV — amount of segments, that lie on the nolmalized line.Total complexity: .solution: 4632546350E - Wrong FloydLet's do the following: construct the graph with the maximum possible number of edges and then remove the excess. First of all, you can notice that if k = n answer is  - 1. Else let's fix some marked vertex, for example a1. Let's put in our graph all edges except edges beetween a1 and x, where x — an another marked vertex. So, why this algorithm is correct? If Valera's algorithm is wrong, then there are a ''bad'' pair of vertexes (i, j). ``Bad'' pair is a pair for that Valera's algorithm works wrong. So, there are not marked vertex v on the shortest path from i to j, and v ≠ i, and v ≠ j. Without loss of generality, we can assume, that distance beetween i and j equals to 2, but Valera's algorithm gives greater answer. There are some cases, that depends on the type of vertexes i, j. But we can look only at the case where (i, j) are marked vertexes. First, add to the graph all edges beetween not fixed (i, j) vertexes. Second, add to the graph edges beetween some fixed vertex (i or j) and some not marked vertex. Third, add to the graph edges beetween i and some marked vertex v, where v ≠ j. It's simple to understand, that if we add some another edge, the Valera's algorithm will work correctly. Total amount of edges is .BONUS Simple bonus. For same contrains (n, m, k) can you build a graph, where Valera's code works correctly? Код: 4632600",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9042",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 350\\s*C"
          },
          "content_length": 4491
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 1",
          "code": "System.out.println()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 2",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 3",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 4",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 5",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 6",
          "code": "if(abs(d1.x) == abs(d2.x))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 7",
          "code": "return (abs(a.x)==abs(b.x))?(abs(a.y)<abs(b.y)):(abs(a.x)<abs(b.x));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"Bomb cannot be at (0, 0) at line %d\", i + 2);\n\n        auto res = points.insert({xi, yi});\n        ensuref(res.second, \"Bomb position (%d, %d) is duplicated at line %d\", xi, yi, i + 2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"Bomb cannot be at (0, 0) at line %d\", i + 2);\n\n        auto res = points.insert({xi, yi});\n        ensuref(res.second, \"Bomb position (%d, %d) is duplicated at line %d\", xi, yi, i + 2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"Bomb cannot be at (0, 0) at line %d\", i + 2);\n\n        auto res = points.insert({xi, yi});\n        ensuref(res.second, \"Bomb position (%d, %d) is duplicated at line %d\", xi, yi, i + 2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MAX_K = 1000000;\n\nint n;\nset<pii> bombs; // set of bomb positions\n\nmap<int, set<int> > bombs_on_row; // y -> set of x\nmap<int, set<int> > bombs_on_col; // x -> set of y\n\nint min_k; // minimal operations from judge's answer\n\nvoid readInput() {\n    n = inf.readInt(1, 100000, \"n\");\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-1000000000, 1000000000, \"xi\");\n        int y = inf.readInt(-1000000000, 1000000000, \"yi\");\n        if (x == 0 && y == 0)\n            inf.quitf(_fail, \"Bomb at (0,0) is not allowed\");\n        if (!bombs.insert(make_pair(x, y)).second)\n            inf.quitf(_fail, \"Duplicate bomb at (%d,%d)\", x, y);\n        bombs_on_row[y].insert(x);\n        bombs_on_col[x].insert(y);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    readInput();\n\n    min_k = ans.readInt(0, MAX_K, \"k in judge's answer\");\n\n    int k = ouf.readInt(0, MAX_K, \"k in participant's answer\");\n\n    if (k != min_k) {\n        quitf(_wa, \"Minimal number of operations is %d, but participant has %d operations\", min_k, k);\n    }\n\n    int robot_x = 0, robot_y = 0;\n    bool has_bomb = false;\n\n    for (int op_num = 1; op_num <= k; ++op_num) {\n        int op_type = ouf.readInt(1, 3, \"operation type\");\n\n        if (op_type == 1) {\n            // Move operation\n            int steps = ouf.readInt(1, 1000000000, \"steps\");\n            string dir = ouf.readToken();\n            if (dir != \"L\" && dir != \"R\" && dir != \"U\" && dir != \"D\")\n                quitf(_wa, \"Invalid direction '%s' in operation %d\", dir.c_str(), op_num);\n\n            int dx = 0, dy = 0;\n            if (dir == \"L\") dx = -1;\n            else if (dir == \"R\") dx = 1;\n            else if (dir == \"U\") dy = 1;\n            else if (dir == \"D\") dy = -1;\n\n            int nx = robot_x + dx * steps;\n            int ny = robot_y + dy * steps;\n\n            // Check for bombs along the path (excluding destination)\n            if (dx != 0) {\n                // Moving along x\n                int y = robot_y;\n                int x1 = robot_x + dx;\n                int x2 = robot_x + dx * (steps - 1);\n                if (dx > 0) {\n                    auto it1 = bombs_on_row[y].upper_bound(x1 - 1);\n                    auto it2 = bombs_on_row[y].upper_bound(x2);\n                    if (it1 != it2)\n                        quitf(_wa, \"Bomb encountered during move at (%d,%d) in operation %d\", *it1, y, op_num);\n                } else {\n                    auto it1 = bombs_on_row[y].lower_bound(x2);\n                    auto it2 = bombs_on_row[y].lower_bound(x1 + 1);\n                    if (it1 != it2)\n                        quitf(_wa, \"Bomb encountered during move at (%d,%d) in operation %d\", *it1, y, op_num);\n                }\n            } else {\n                // Moving along y\n                int x = robot_x;\n                int y1 = robot_y + dy;\n                int y2 = robot_y + dy * (steps - 1);\n                if (dy > 0) {\n                    auto it1 = bombs_on_col[x].upper_bound(y1 - 1);\n                    auto it2 = bombs_on_col[x].upper_bound(y2);\n                    if (it1 != it2)\n                        quitf(_wa, \"Bomb encountered during move at (%d,%d) in operation %d\", x, *it1, op_num);\n                } else {\n                    auto it1 = bombs_on_col[x].lower_bound(y2);\n                    auto it2 = bombs_on_col[x].lower_bound(y1 + 1);\n                    if (it1 != it2)\n                        quitf(_wa, \"Bomb encountered during move at (%d,%d) in operation %d\", x, *it1, op_num);\n                }\n            }\n\n            robot_x = nx;\n            robot_y = ny;\n\n        } else if (op_type == 2) {\n            // Pick up bomb\n            if (has_bomb)\n                quitf(_wa, \"Already carrying a bomb when trying to pick up at operation %d\", op_num);\n            pii pos = make_pair(robot_x, robot_y);\n            if (bombs.find(pos) == bombs.end())\n                quitf(_wa, \"No bomb at position (%d,%d) to pick up at operation %d\", robot_x, robot_y, op_num);\n            bombs.erase(pos);\n            bombs_on_row[robot_y].erase(robot_x);\n            bombs_on_col[robot_x].erase(robot_y);\n            has_bomb = true;\n        } else if (op_type == 3) {\n            // Destroy bomb\n            if (!has_bomb)\n                quitf(_wa, \"No bomb to destroy at operation %d\", op_num);\n            if (robot_x != 0 || robot_y != 0)\n                quitf(_wa, \"Robot not at (0,0) when trying to destroy bomb at operation %d\", op_num);\n            has_bomb = false;\n        }\n    }\n\n    if (has_bomb)\n        quitf(_wa, \"Robot still carrying a bomb at the end\");\n\n    if (!bombs.empty())\n        quitf(_wa, \"%d bombs remaining at the end\", (int)bombs.size());\n\n    quitf(_ok, \"All bombs destroyed with minimal number of operations %d\", min_k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring type;\n\nvector<pair<int64_t, int64_t>> bombs;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate n random bombs with coordinates in the range [-1e9, 1e9]\n        // ensuring no two bombs are at the same point and not at (0, 0)\n        set<pair<int64_t, int64_t>> used;\n        while ((int)bombs.size() < n) {\n            int64_t xi = rnd.next(-1000000000LL, 1000000000LL);\n            int64_t yi = rnd.next(-1000000000LL, 1000000000LL);\n            if (xi == 0 && yi == 0) continue;\n\n            pair<int64_t, int64_t> p = make_pair(xi, yi);\n            if (used.count(p)) continue;\n\n            used.insert(p);\n            bombs.push_back(p);\n        }\n    } else if (type == \"dense_near_origin\") {\n        // Generate bombs densely packed near the origin within a square\n        // Calculate limit to have enough positions\n        int64_t L = ceil(sqrt(n));\n        if (L > 1000000000LL) L = 1000000000LL;\n\n        set<pair<int64_t, int64_t>> positions;\n        for (int64_t xi = -L; xi <= L; ++xi) {\n            for (int64_t yi = -L; yi <= L; ++yi) {\n                if (xi == 0 && yi == 0) continue;\n                positions.insert(make_pair(xi, yi));\n            }\n        }\n\n        if ((int)positions.size() < n) {\n            cerr << \"Not enough positions in dense_near_origin\" << endl;\n            return 1;\n        }\n\n        vector<pair<int64_t, int64_t>> all_positions(positions.begin(), positions.end());\n        shuffle(all_positions.begin(), all_positions.end());\n        bombs.assign(all_positions.begin(), all_positions.begin() + n);\n    } else if (type == \"line_x\") {\n        // Generate bombs along x-axis (y = 0), xi != 0, no duplicates\n        set<int64_t> used_x;\n        while ((int)bombs.size() < n) {\n            int64_t xi = rnd.next(-1000000000LL, 1000000000LL);\n            if (xi == 0) continue;\n            if (used_x.count(xi)) continue;\n            used_x.insert(xi);\n            bombs.push_back(make_pair(xi, 0LL));\n        }\n    } else if (type == \"line_y\") {\n        // Generate bombs along y-axis (x = 0), yi != 0, no duplicates\n        set<int64_t> used_y;\n        while ((int)bombs.size() < n) {\n            int64_t yi = rnd.next(-1000000000LL, 1000000000LL);\n            if (yi == 0) continue;\n            if (used_y.count(yi)) continue;\n            used_y.insert(yi);\n            bombs.push_back(make_pair(0LL, yi));\n        }\n    } else if (type == \"diagonal\") {\n        // Generate bombs along the line x = y, xi != 0, no duplicates\n        set<int64_t> used_xi;\n        while ((int)bombs.size() < n) {\n            int64_t xi = rnd.next(-1000000000LL, 1000000000LL);\n            if (xi == 0) continue;\n            if (used_xi.count(xi)) continue;\n            used_xi.insert(xi);\n            bombs.push_back(make_pair(xi, xi));\n        }\n    } else if (type == \"max_coords\") {\n        // Generate bombs at positions with maximum coordinate values\n        for (int64_t i = 0; i < n; ++i) {\n            int64_t xi, yi;\n            if (i % 4 == 0) {\n                xi = 1000000000LL - i;\n                yi = 1000000000LL;\n            } else if (i % 4 == 1) {\n                xi = -1000000000LL + i;\n                yi = 1000000000LL;\n            } else if (i % 4 == 2) {\n                xi = 1000000000LL - i;\n                yi = -1000000000LL;\n            } else {\n                xi = -1000000000LL + i;\n                yi = -1000000000LL;\n            }\n            if (xi == 0) xi = 1;\n            if (yi == 0) yi = 1;\n            bombs.push_back(make_pair(xi, yi));\n        }\n    } else {\n        cerr << \"Invalid test type\" << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%lld %lld\\n\", bombs[i].first, bombs[i].second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring type;\n\nvector<pair<int64_t, int64_t>> bombs;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate n random bombs with coordinates in the range [-1e9, 1e9]\n        // ensuring no two bombs are at the same point and not at (0, 0)\n        set<pair<int64_t, int64_t>> used;\n        while ((int)bombs.size() < n) {\n            int64_t xi = rnd.next(-1000000000LL, 1000000000LL);\n            int64_t yi = rnd.next(-1000000000LL, 1000000000LL);\n            if (xi == 0 && yi == 0) continue;\n\n            pair<int64_t, int64_t> p = make_pair(xi, yi);\n            if (used.count(p)) continue;\n\n            used.insert(p);\n            bombs.push_back(p);\n        }\n    } else if (type == \"dense_near_origin\") {\n        // Generate bombs densely packed near the origin within a square\n        // Calculate limit to have enough positions\n        int64_t L = ceil(sqrt(n));\n        if (L > 1000000000LL) L = 1000000000LL;\n\n        set<pair<int64_t, int64_t>> positions;\n        for (int64_t xi = -L; xi <= L; ++xi) {\n            for (int64_t yi = -L; yi <= L; ++yi) {\n                if (xi == 0 && yi == 0) continue;\n                positions.insert(make_pair(xi, yi));\n            }\n        }\n\n        if ((int)positions.size() < n) {\n            cerr << \"Not enough positions in dense_near_origin\" << endl;\n            return 1;\n        }\n\n        vector<pair<int64_t, int64_t>> all_positions(positions.begin(), positions.end());\n        shuffle(all_positions.begin(), all_positions.end());\n        bombs.assign(all_positions.begin(), all_positions.begin() + n);\n    } else if (type == \"line_x\") {\n        // Generate bombs along x-axis (y = 0), xi != 0, no duplicates\n        set<int64_t> used_x;\n        while ((int)bombs.size() < n) {\n            int64_t xi = rnd.next(-1000000000LL, 1000000000LL);\n            if (xi == 0) continue;\n            if (used_x.count(xi)) continue;\n            used_x.insert(xi);\n            bombs.push_back(make_pair(xi, 0LL));\n        }\n    } else if (type == \"line_y\") {\n        // Generate bombs along y-axis (x = 0), yi != 0, no duplicates\n        set<int64_t> used_y;\n        while ((int)bombs.size() < n) {\n            int64_t yi = rnd.next(-1000000000LL, 1000000000LL);\n            if (yi == 0) continue;\n            if (used_y.count(yi)) continue;\n            used_y.insert(yi);\n            bombs.push_back(make_pair(0LL, yi));\n        }\n    } else if (type == \"diagonal\") {\n        // Generate bombs along the line x = y, xi != 0, no duplicates\n        set<int64_t> used_xi;\n        while ((int)bombs.size() < n) {\n            int64_t xi = rnd.next(-1000000000LL, 1000000000LL);\n            if (xi == 0) continue;\n            if (used_xi.count(xi)) continue;\n            used_xi.insert(xi);\n            bombs.push_back(make_pair(xi, xi));\n        }\n    } else if (type == \"max_coords\") {\n        // Generate bombs at positions with maximum coordinate values\n        for (int64_t i = 0; i < n; ++i) {\n            int64_t xi, yi;\n            if (i % 4 == 0) {\n                xi = 1000000000LL - i;\n                yi = 1000000000LL;\n            } else if (i % 4 == 1) {\n                xi = -1000000000LL + i;\n                yi = 1000000000LL;\n            } else if (i % 4 == 2) {\n                xi = 1000000000LL - i;\n                yi = -1000000000LL;\n            } else {\n                xi = -1000000000LL + i;\n                yi = -1000000000LL;\n            }\n            if (xi == 0) xi = 1;\n            if (yi == 0) yi = 1;\n            bombs.push_back(make_pair(xi, yi));\n        }\n    } else {\n        cerr << \"Invalid test type\" << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%lld %lld\\n\", bombs[i].first, bombs[i].second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n./gen -n 1 -type dense_near_origin\n./gen -n 1000 -type dense_near_origin\n./gen -n 10000 -type dense_near_origin\n./gen -n 100000 -type dense_near_origin\n\n./gen -n 1000 -type line_x\n./gen -n 10000 -type line_x\n./gen -n 100000 -type line_x\n\n./gen -n 1000 -type line_y\n./gen -n 10000 -type line_y\n./gen -n 100000 -type line_y\n\n./gen -n 1000 -type diagonal\n./gen -n 10000 -type diagonal\n./gen -n 100000 -type diagonal\n\n./gen -n 1000 -type max_coords\n./gen -n 10000 -type max_coords\n./gen -n 100000 -type max_coords\n\n./gen -n 500 -type random\n./gen -n 500 -type dense_near_origin\n\n./gen -n 5000 -type random\n./gen -n 5000 -type dense_near_origin\n\n./gen -n 50000 -type random\n./gen -n 50000 -type dense_near_origin\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:26.609036",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "350/D",
      "title": "D. Поиск сов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа — n и m (1 ≤ n ≤ 3·105, 2 ≤ m ≤ 1500). Далее в n строках записаны по четыре целых числа x1, y1, x2, y2 — координаты двух концов текущего отрезка. Гарантируется, что каждый отрезок имеет положительную длину.Затем в m строках записаны по три целых числа xi, yi, ri — координаты центра и радиус i-ой окружности. Все координаты — целые числа, не превосходящие 104 по абсолютной величине. Радиус — целое положительное число, не превосходящее 104.Гарантируется, что все отрезки и все окружности являются различными.",
      "output_spec": "Выходные данныеВыведите единственное число — ответ на задачу. Пожалуйста, не используйте спецификатор %lld для вывода 64-битных чисел на С++. Рекомендуется использовать поток cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 23 2 3 -20 0 26 0 2Выходные данныеСкопировать1Входные данныеСкопировать3 20 0 0 10 -1 0 10 -1 0 02 0 1-2 0 1Выходные данныеСкопировать3Входные данныеСкопировать1 2-1 0 1 0-100 0 1100 0 1Выходные данныеСкопировать0",
      "description": "D. Поиск сов\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа — n и m (1 ≤ n ≤ 3·105, 2 ≤ m ≤ 1500). Далее в n строках записаны по четыре целых числа x1, y1, x2, y2 — координаты двух концов текущего отрезка. Гарантируется, что каждый отрезок имеет положительную длину.Затем в m строках записаны по три целых числа xi, yi, ri — координаты центра и радиус i-ой окружности. Все координаты — целые числа, не превосходящие 104 по абсолютной величине. Радиус — целое положительное число, не превосходящее 104.Гарантируется, что все отрезки и все окружности являются различными.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — ответ на задачу. Пожалуйста, не используйте спецификатор %lld для вывода 64-битных чисел на С++. Рекомендуется использовать поток cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать1 23 2 3 -20 0 26 0 2Выходные данныеСкопировать1Входные данныеСкопировать3 20 0 0 10 -1 0 10 -1 0 02 0 1-2 0 1Выходные данныеСкопировать3Входные данныеСкопировать1 2-1 0 1 0-100 0 1100 0 1Выходные данныеСкопировать0\n\nВходные данныеСкопировать1 23 2 3 -20 0 26 0 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 20 0 0 10 -1 0 10 -1 0 02 0 1-2 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2-1 0 1 0-100 0 1100 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЭто сова из первого примера. Она сидит и ждет, когда вы ее посчитаете.",
      "solutions": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "Всем привет! Скоро (1 октября, 19:30 MSK) состоится очередной Codeforces Round #203 для участников Div. 2. Как обычно, Div. 1 участники смогут поучаствовать в этом раунде вне конкурса.Автором раунда являюсь я. Хочется сказать большое спасибо Гере Агапову (Gerald) за помощь в подготовке и за хорошие предложения по задачам. Спасибо Лось Илье (IlyaLos) за тестирование задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon. Также спасибо Игнатьеву Александру (aiMR) за тестирование задач и идею одной из них.Удачи!UPD: Будет использоваться динамическое распределение баллов. Задачи расположены в порядке увеличения сложности (по мнению авторов).UPD: Поздравляем победителей! fanhqme FAU.COACH Witalia sokian UPD: Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 804
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "350A - TLПусть v = min(ai), p = max(ai), c = min(bi). Тогда если max(2 * v, p) < c, то ответ max(2 * v, p). Иначе ответ  - 1.Авторское решение: 4632352350B - КурортВ этой задаче достаточно было реализовать следующее. По сути там задан граф, в виде массива предков для каждой вершины. Поскольку у каждой вершины максимум один предок, то для каждой вершины, являющейся отелем запустим такой алгоритм: будем подниматься по предкам prev[v] до тех пор, пока не встретим вершину со степенью исхода большей единицы. Степень исхода лучше посчитать заранее. После всего обновим ответ.Асимптотика решения O(n) по времени и O(n) по памяти.Авторское решение: 4632399350C - БомбыГлавная идея, это отсортировать все точки в порядке возрастания величины |xi| + |yi|. Дальше будем обрабатывать каждую точку жадно, максимум за шесть ходов. А именно, пусть мы хотим дойти сейчас до точки (x, y). Пусть x ≠ 0. Тогда нам нужно переместиться ровно на |x| в нужном направлении (если x < 0 то по направлению L, x > 0 — R). Аналогично сделаем для y-координаты. Теперь мы пришли в точку (x, y), возьмем в этой точке бомбу, и аналогично вернемся назад. Почему верно сортировать по так называемому манхэттенскому расстоянию? Понятно, что если мы посмотрим на путь, который мы получили, можно заметить, что все точки пути имеют меньшее манхэттенское расстояние, а значит их мы обработаем раньше.Асимптотика авторского решения Авторское решение: 4632478350D - Поиск совБудем решать задачу в целых числах. Поэтому всегда будем строить прямую в целых числах. Операцией нормализации прямой будем называть следующее: Пусть у нас есть прямая Ax + By + C. Пусть также g = gcd(A, gcd(B, C)) (gcd(0, 0) = 0).Если А < 0 (или A = 0 и B < 0), то умножим уравнение на -1 и поделим все коэффициенты на g.Теперь решение. Будем поддерживать два отображения (map<> на С++, TreeMap(HashMap) на Java) из прямой, в множество точек (некоторые точки могут встречаться несколько раз). В первом отображении в качестве множества точек мы будем хранить левые границы отрезков, во втором правые границы отрезков (в отсортированном виде).Заранее по каждому отрезку построим прямую, нормализуем ее, и поддержим наши указанные выше множества множества. Далее, для каждого возможного уравнения отсортируем указанные множества.Теперь переберем две окружности. Проверим, что расстояние между их центрами больше суммы радиусов и что радиусы одинаковы. Пусть мы построили прямую через центры (x1, y1) и (x2, y2). Перпендикулярная ей прямая, проходящая через центр отрезка [(x1, y1), (x2, y2)] будет иметь уравнение A = 2(x1 - x2), B = 2(y1 - y2), C =  - ((x1 - x2) * (x1 + x2) + (y1 - y2) * (y1 + y2)). После этого бинарным поиском по множеству точек, соответствующих указанной прямой, найдем две величины: cntL — количество отрезков, у которых левая граница правее ((x1 + x2) / 2, (y1 + y2) / 2) и cntR — количество отрезков, у которых правая граница левее ((x1 + x2) / 2, (y1 + y2) / 2). Тогда к ответу нужно прибавить величину cntV - cntR - cntL, где cntV — количество отрезков соответствующих заданной прямой в отображении.Итого, решение за .Код: 4632546350E - Неверный ФлойдРешение задачи очень простое, главное придумать почему это верно. Будем действовать так: построим граф с максимальным возможным количеством ребер, потом удалим лишнее. Во-первых, если k =  = n, то ответ -1. Иначе зафиксируем некоторую помеченную вершину, например a1. Возьмем в наш граф все ребра, кроме ребер вида a1 <  -  > x, где x — помеченная вершина. Теперь почему так действовать верно. Если алгоритм Валеры работает неверно, значит существуют пара вершин (i, j) такая, что кратчайшее расстояние посчитано неверно. Значит, на кратчайшем пути из вершины i в вершину j есть хотя бы одна не помеченная вершина (причем, что важно, она не должна совпадать ни с i, ни с j. Если бы такой вершины не было, кратчайшее расстояние посчиталось бы верно. Более того, не нарушая общности, будем считать, что кратчайшее расстояние между i и j равно двум, а алгоритм Валеры нашел больше. Далее, для более формального доказательства нужно рассмотреть случаи, в зависимости от того какой тип имеет каждая из вершин (i, j), однако я рассмотрю случай, когда мы получим больше всего ребер, а именно когда и i, и j — помеченные вершины (а их по условию всегда не меньше двух :)). Во-первых, проведем все ребра во между не зафиксированными ребрами. Дальше проведем и из i и из j ребра в не помеченные вершины. После этого проведем из i все ребра в помеченные, кроме вершины j. Понятно, что больше добавлять ребер нельзя, так как иначе алгоритм Валеры посчитает все верно. Таким образом, мы проведем ровно ребер.Код: 4632600 BONUS Простой бонус. Можете ли вы для аналогичных входных построить граф, где алгоритм Валеры будет работать верно?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9042",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 350\\s*D"
          },
          "content_length": 4739
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 1",
          "code": "System.out.println()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 2",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 3",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 4",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 5",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 6",
          "code": "if(abs(d1.x) == abs(d2.x))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 7",
          "code": "return (abs(a.x)==abs(b.x))?(abs(a.y)<abs(b.y)):(abs(a.x)<abs(b.x));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces - Code 1",
          "code": "vector<int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9042",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces - Code 2",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9042",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces - Code 3",
          "code": "lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9042",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #203 (Div. 2) - Codeforces - Code 4",
          "code": "vector<int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9042",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Segment {\n    int x1, y1, x2, y2;\n    bool operator==(const Segment& other) const {\n        return x1 == other.x1 && y1 == other.y1 &&\n               x2 == other.x2 && y2 == other.y2;\n    }\n};\n\nstruct SegmentHash {\n    size_t operator()(const Segment& s) const {\n        size_t h1 = hash<int>()(s.x1);\n        size_t h2 = hash<int>()(s.y1);\n        size_t h3 = hash<int>()(s.x2);\n        size_t h4 = hash<int>()(s.y2);\n        size_t h = h1;\n        h = h * 1000003 + h2;\n        h = h * 1000003 + h3;\n        h = h * 1000003 + h4;\n        return h;\n    }\n};\n\nstruct Circle {\n    int xi, yi, ri;\n    bool operator==(const Circle& other) const {\n        return xi == other.xi && yi == other.yi && ri == other.ri;\n    }\n};\n\nstruct CircleHash {\n    size_t operator()(const Circle& c) const {\n        size_t h1 = hash<int>()(c.xi);\n        size_t h2 = hash<int>()(c.yi);\n        size_t h3 = hash<int>()(c.ri);\n        size_t h = h1;\n        h = h * 1000003 + h2;\n        h = h * 1000003 + h3;\n        return h;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1500, \"m\");\n    inf.readEoln();\n\n    unordered_set<Segment, SegmentHash> segments;\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(-10000, 10000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(-10000, 10000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(-10000, 10000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(-10000, 10000, \"y2\");\n        inf.readEoln();\n\n        // Check that the segment has positive length\n        ensuref(x1 != x2 || y1 != y2, \"Segment length must be positive\");\n\n        Segment s = { x1, y1, x2, y2 };\n        auto res = segments.insert(s);\n        ensuref(res.second, \"Segments must be distinct\");\n    }\n\n    unordered_set<Circle, CircleHash> circles;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readEoln();\n\n        Circle c = { xi, yi, ri };\n        auto res = circles.insert(c);\n        ensuref(res.second, \"Circles must be distinct\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Segment {\n    int x1, y1, x2, y2;\n    bool operator==(const Segment& other) const {\n        return x1 == other.x1 && y1 == other.y1 &&\n               x2 == other.x2 && y2 == other.y2;\n    }\n};\n\nstruct SegmentHash {\n    size_t operator()(const Segment& s) const {\n        size_t h1 = hash<int>()(s.x1);\n        size_t h2 = hash<int>()(s.y1);\n        size_t h3 = hash<int>()(s.x2);\n        size_t h4 = hash<int>()(s.y2);\n        size_t h = h1;\n        h = h * 1000003 + h2;\n        h = h * 1000003 + h3;\n        h = h * 1000003 + h4;\n        return h;\n    }\n};\n\nstruct Circle {\n    int xi, yi, ri;\n    bool operator==(const Circle& other) const {\n        return xi == other.xi && yi == other.yi && ri == other.ri;\n    }\n};\n\nstruct CircleHash {\n    size_t operator()(const Circle& c) const {\n        size_t h1 = hash<int>()(c.xi);\n        size_t h2 = hash<int>()(c.yi);\n        size_t h3 = hash<int>()(c.ri);\n        size_t h = h1;\n        h = h * 1000003 + h2;\n        h = h * 1000003 + h3;\n        return h;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1500, \"m\");\n    inf.readEoln();\n\n    unordered_set<Segment, SegmentHash> segments;\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(-10000, 10000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(-10000, 10000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(-10000, 10000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(-10000, 10000, \"y2\");\n        inf.readEoln();\n\n        // Check that the segment has positive length\n        ensuref(x1 != x2 || y1 != y2, \"Segment length must be positive\");\n\n        Segment s = { x1, y1, x2, y2 };\n        auto res = segments.insert(s);\n        ensuref(res.second, \"Segments must be distinct\");\n    }\n\n    unordered_set<Circle, CircleHash> circles;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readEoln();\n\n        Circle c = { xi, yi, ri };\n        auto res = circles.insert(c);\n        ensuref(res.second, \"Circles must be distinct\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Segment {\n    int x1, y1, x2, y2;\n    bool operator==(const Segment& other) const {\n        return x1 == other.x1 && y1 == other.y1 &&\n               x2 == other.x2 && y2 == other.y2;\n    }\n};\n\nstruct SegmentHash {\n    size_t operator()(const Segment& s) const {\n        size_t h1 = hash<int>()(s.x1);\n        size_t h2 = hash<int>()(s.y1);\n        size_t h3 = hash<int>()(s.x2);\n        size_t h4 = hash<int>()(s.y2);\n        size_t h = h1;\n        h = h * 1000003 + h2;\n        h = h * 1000003 + h3;\n        h = h * 1000003 + h4;\n        return h;\n    }\n};\n\nstruct Circle {\n    int xi, yi, ri;\n    bool operator==(const Circle& other) const {\n        return xi == other.xi && yi == other.yi && ri == other.ri;\n    }\n};\n\nstruct CircleHash {\n    size_t operator()(const Circle& c) const {\n        size_t h1 = hash<int>()(c.xi);\n        size_t h2 = hash<int>()(c.yi);\n        size_t h3 = hash<int>()(c.ri);\n        size_t h = h1;\n        h = h * 1000003 + h2;\n        h = h * 1000003 + h3;\n        return h;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1500, \"m\");\n    inf.readEoln();\n\n    unordered_set<Segment, SegmentHash> segments;\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(-10000, 10000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(-10000, 10000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(-10000, 10000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(-10000, 10000, \"y2\");\n        inf.readEoln();\n\n        // Check that the segment has positive length\n        ensuref(x1 != x2 || y1 != y2, \"Segment length must be positive\");\n\n        Segment s = { x1, y1, x2, y2 };\n        auto res = segments.insert(s);\n        ensuref(res.second, \"Segments must be distinct\");\n    }\n\n    unordered_set<Circle, CircleHash> circles;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readEoln();\n\n        Circle c = { xi, yi, ri };\n        auto res = circles.insert(c);\n        ensuref(res.second, \"Circles must be distinct\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    ensure(n >= 1 && n <= 300000);\n    ensure(m >= 2 && m <= 1500);\n\n    vector<int> x1(n), y1(n), x2(n), y2(n);\n    vector<int> xi(m), yi(m), ri(m);\n\n    if (type == \"random\") {\n        // Generate random segments\n        set<tuple<int, int, int, int>> segments;\n        for (int i = 0; i < n; ++i) {\n            while (true) {\n                int x1_i = rnd.next(-10000, 10000);\n                int y1_i = rnd.next(-10000, 10000);\n                int x2_i = rnd.next(-10000, 10000);\n                int y2_i = rnd.next(-10000, 10000);\n\n                // Ensure segment has positive length\n                if (x1_i == x2_i && y1_i == y2_i)\n                    continue;\n\n                auto sg = make_tuple(x1_i, y1_i, x2_i, y2_i);\n                auto sgrev = make_tuple(x2_i, y2_i, x1_i, y1_i);\n                if (segments.count(sg) || segments.count(sgrev))\n                    continue;\n\n                segments.insert(sg);\n                x1[i] = x1_i;\n                y1[i] = y1_i;\n                x2[i] = x2_i;\n                y2[i] = y2_i;\n                break;\n            }\n        }\n\n        // Generate random circles\n        set<tuple<int, int, int>> circles;\n        for (int i = 0; i < m; ++i) {\n            while (true) {\n                int xi_i = rnd.next(-10000, 10000);\n                int yi_i = rnd.next(-10000, 10000);\n                int ri_i = rnd.next(1, 10000);\n\n                auto cir = make_tuple(xi_i, yi_i, ri_i);\n                if (circles.count(cir))\n                    continue;\n\n                circles.insert(cir);\n                xi[i] = xi_i;\n                yi[i] = yi_i;\n                ri[i] = ri_i;\n                break;\n            }\n        }\n    } else if (type == \"line\") {\n        // Generate segments along y=0\n        int delta_x = 20000 / max(1, n - 1);\n        int start_x = -10000;\n        for (int i = 0; i < n; ++i) {\n            int x_start = start_x + i * delta_x;\n            int x_end = x_start + delta_x / 2;\n            if (x_end > 10000)\n                x_end = 10000;\n\n            if (x_start == x_end)\n                x_end += 1; // Ensure positive length\n\n            x1[i] = x_start;\n            y1[i] = 0;\n            x2[i] = x_end;\n            y2[i] = 0;\n        }\n\n        // Generate circles symmetric with respect to y=0\n        set<tuple<int, int, int>> circles;\n        int num_pairs = m / 2;\n        int remaining = m % 2;\n        int delta_cx = 20000 / max(1, num_pairs);\n        for (int i = 0; i < num_pairs; ++i) {\n            int c_x = start_x + i * delta_cx + delta_cx / 2;\n            int c_y = rnd.next(1000, 9000);\n            int radius = rnd.next(1, 1000);\n\n            // First circle\n            xi[2 * i] = c_x;\n            yi[2 * i] = c_y;\n            ri[2 * i] = radius;\n\n            // Second circle (symmetric)\n            xi[2 * i + 1] = c_x;\n            yi[2 * i + 1] = -c_y;\n            ri[2 * i + 1] = radius;\n        }\n\n        // If m is odd, add one more circle\n        if (remaining) {\n            xi[m - 1] = rnd.next(-10000, 10000);\n            yi[m - 1] = rnd.next(-10000, 10000);\n            ri[m - 1] = rnd.next(1, 10000);\n        }\n    } else if (type == \"zero\") {\n        // Generate segments randomly\n        set<tuple<int, int, int, int>> segments;\n        for (int i = 0; i < n; ++i) {\n            while (true) {\n                int x1_i = rnd.next(-10000, 10000);\n                int y1_i = rnd.next(-10000, 10000);\n                int x2_i = rnd.next(-10000, 10000);\n                int y2_i = rnd.next(-10000, 10000);\n\n                // Ensure segment has positive length\n                if (x1_i == x2_i && y1_i == y2_i)\n                    continue;\n\n                auto sg = make_tuple(x1_i, y1_i, x2_i, y2_i);\n                auto sgrev = make_tuple(x2_i, y2_i, x1_i, y1_i);\n                if (segments.count(sg) || segments.count(sgrev))\n                    continue;\n\n                segments.insert(sg);\n                x1[i] = x1_i;\n                y1[i] = y1_i;\n                x2[i] = x2_i;\n                y2[i] = y2_i;\n                break;\n            }\n        }\n\n        // Generate overlapping circles (circles with the same center)\n        int center_x = rnd.next(-10000, 10000);\n        int center_y = rnd.next(-10000, 10000);\n        set<int> radii;\n        for (int i = 0; i < m; ++i) {\n            while (true) {\n                int ri_i = rnd.next(1, 10000);\n                if (radii.count(ri_i))\n                    continue;\n                radii.insert(ri_i);\n                xi[i] = center_x;\n                yi[i] = center_y;\n                ri[i] = ri_i;\n                break;\n            }\n        }\n    } else if (type == \"manyowls\") {\n        // Generate segments along y=0\n        for (int i = 0; i < n; ++i) {\n            x1[i] = -10000 + (20000 / n) * i;\n            x2[i] = x1[i];\n            y1[i] = -10000;\n            y2[i] = 10000;\n        }\n\n        // Generate circles in grid symmetric with respect to x and y axes\n        int grid_size = sqrt(m);\n        int idx = 0;\n        set<tuple<int, int, int>> circles;\n        for (int i = 0; i < grid_size && idx < m; ++i) {\n            for (int j = 0; j < grid_size && idx < m; ++j) {\n                int c_x = -5000 + i * 10000 / grid_size;\n                int c_y = -5000 + j * 10000 / grid_size;\n                int radius = rnd.next(1, 10000);\n\n                auto cir = make_tuple(c_x, c_y, radius);\n                if (circles.count(cir))\n                    continue;\n                circles.insert(cir);\n                xi[idx] = c_x;\n                yi[idx] = c_y;\n                ri[idx] = radius;\n                idx++;\n            }\n        }\n        while (idx < m) {\n            xi[idx] = rnd.next(-10000, 10000);\n            yi[idx] = rnd.next(-10000, 10000);\n            ri[idx] = rnd.next(1, 10000);\n            idx++;\n        }\n    } else {\n        // Default to random if type is unknown\n        // (same as 'random' type)\n        set<tuple<int, int, int, int>> segments;\n        for (int i = 0; i < n; ++i) {\n            while (true) {\n                int x1_i = rnd.next(-10000, 10000);\n                int y1_i = rnd.next(-10000, 10000);\n                int x2_i = rnd.next(-10000, 10000);\n                int y2_i = rnd.next(-10000, 10000);\n\n                // Ensure segment has positive length\n                if (x1_i == x2_i && y1_i == y2_i)\n                    continue;\n\n                auto sg = make_tuple(x1_i, y1_i, x2_i, y2_i);\n                auto sgrev = make_tuple(x2_i, y2_i, x1_i, y1_i);\n                if (segments.count(sg) || segments.count(sgrev))\n                    continue;\n\n                segments.insert(sg);\n                x1[i] = x1_i;\n                y1[i] = y1_i;\n                x2[i] = x2_i;\n                y2[i] = y2_i;\n                break;\n            }\n        }\n\n        // Generate random circles\n        set<tuple<int, int, int>> circles;\n        for (int i = 0; i < m; ++i) {\n            while (true) {\n                int xi_i = rnd.next(-10000, 10000);\n                int yi_i = rnd.next(-10000, 10000);\n                int ri_i = rnd.next(1, 10000);\n\n                auto cir = make_tuple(xi_i, yi_i, ri_i);\n                if (circles.count(cir))\n                    continue;\n\n                circles.insert(cir);\n                xi[i] = xi_i;\n                yi[i] = yi_i;\n                ri[i] = ri_i;\n                break;\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output segments\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", x1[i], y1[i], x2[i], y2[i]);\n    }\n\n    // Output circles\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", xi[i], yi[i], ri[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    ensure(n >= 1 && n <= 300000);\n    ensure(m >= 2 && m <= 1500);\n\n    vector<int> x1(n), y1(n), x2(n), y2(n);\n    vector<int> xi(m), yi(m), ri(m);\n\n    if (type == \"random\") {\n        // Generate random segments\n        set<tuple<int, int, int, int>> segments;\n        for (int i = 0; i < n; ++i) {\n            while (true) {\n                int x1_i = rnd.next(-10000, 10000);\n                int y1_i = rnd.next(-10000, 10000);\n                int x2_i = rnd.next(-10000, 10000);\n                int y2_i = rnd.next(-10000, 10000);\n\n                // Ensure segment has positive length\n                if (x1_i == x2_i && y1_i == y2_i)\n                    continue;\n\n                auto sg = make_tuple(x1_i, y1_i, x2_i, y2_i);\n                auto sgrev = make_tuple(x2_i, y2_i, x1_i, y1_i);\n                if (segments.count(sg) || segments.count(sgrev))\n                    continue;\n\n                segments.insert(sg);\n                x1[i] = x1_i;\n                y1[i] = y1_i;\n                x2[i] = x2_i;\n                y2[i] = y2_i;\n                break;\n            }\n        }\n\n        // Generate random circles\n        set<tuple<int, int, int>> circles;\n        for (int i = 0; i < m; ++i) {\n            while (true) {\n                int xi_i = rnd.next(-10000, 10000);\n                int yi_i = rnd.next(-10000, 10000);\n                int ri_i = rnd.next(1, 10000);\n\n                auto cir = make_tuple(xi_i, yi_i, ri_i);\n                if (circles.count(cir))\n                    continue;\n\n                circles.insert(cir);\n                xi[i] = xi_i;\n                yi[i] = yi_i;\n                ri[i] = ri_i;\n                break;\n            }\n        }\n    } else if (type == \"line\") {\n        // Generate segments along y=0\n        int delta_x = 20000 / max(1, n - 1);\n        int start_x = -10000;\n        for (int i = 0; i < n; ++i) {\n            int x_start = start_x + i * delta_x;\n            int x_end = x_start + delta_x / 2;\n            if (x_end > 10000)\n                x_end = 10000;\n\n            if (x_start == x_end)\n                x_end += 1; // Ensure positive length\n\n            x1[i] = x_start;\n            y1[i] = 0;\n            x2[i] = x_end;\n            y2[i] = 0;\n        }\n\n        // Generate circles symmetric with respect to y=0\n        set<tuple<int, int, int>> circles;\n        int num_pairs = m / 2;\n        int remaining = m % 2;\n        int delta_cx = 20000 / max(1, num_pairs);\n        for (int i = 0; i < num_pairs; ++i) {\n            int c_x = start_x + i * delta_cx + delta_cx / 2;\n            int c_y = rnd.next(1000, 9000);\n            int radius = rnd.next(1, 1000);\n\n            // First circle\n            xi[2 * i] = c_x;\n            yi[2 * i] = c_y;\n            ri[2 * i] = radius;\n\n            // Second circle (symmetric)\n            xi[2 * i + 1] = c_x;\n            yi[2 * i + 1] = -c_y;\n            ri[2 * i + 1] = radius;\n        }\n\n        // If m is odd, add one more circle\n        if (remaining) {\n            xi[m - 1] = rnd.next(-10000, 10000);\n            yi[m - 1] = rnd.next(-10000, 10000);\n            ri[m - 1] = rnd.next(1, 10000);\n        }\n    } else if (type == \"zero\") {\n        // Generate segments randomly\n        set<tuple<int, int, int, int>> segments;\n        for (int i = 0; i < n; ++i) {\n            while (true) {\n                int x1_i = rnd.next(-10000, 10000);\n                int y1_i = rnd.next(-10000, 10000);\n                int x2_i = rnd.next(-10000, 10000);\n                int y2_i = rnd.next(-10000, 10000);\n\n                // Ensure segment has positive length\n                if (x1_i == x2_i && y1_i == y2_i)\n                    continue;\n\n                auto sg = make_tuple(x1_i, y1_i, x2_i, y2_i);\n                auto sgrev = make_tuple(x2_i, y2_i, x1_i, y1_i);\n                if (segments.count(sg) || segments.count(sgrev))\n                    continue;\n\n                segments.insert(sg);\n                x1[i] = x1_i;\n                y1[i] = y1_i;\n                x2[i] = x2_i;\n                y2[i] = y2_i;\n                break;\n            }\n        }\n\n        // Generate overlapping circles (circles with the same center)\n        int center_x = rnd.next(-10000, 10000);\n        int center_y = rnd.next(-10000, 10000);\n        set<int> radii;\n        for (int i = 0; i < m; ++i) {\n            while (true) {\n                int ri_i = rnd.next(1, 10000);\n                if (radii.count(ri_i))\n                    continue;\n                radii.insert(ri_i);\n                xi[i] = center_x;\n                yi[i] = center_y;\n                ri[i] = ri_i;\n                break;\n            }\n        }\n    } else if (type == \"manyowls\") {\n        // Generate segments along y=0\n        for (int i = 0; i < n; ++i) {\n            x1[i] = -10000 + (20000 / n) * i;\n            x2[i] = x1[i];\n            y1[i] = -10000;\n            y2[i] = 10000;\n        }\n\n        // Generate circles in grid symmetric with respect to x and y axes\n        int grid_size = sqrt(m);\n        int idx = 0;\n        set<tuple<int, int, int>> circles;\n        for (int i = 0; i < grid_size && idx < m; ++i) {\n            for (int j = 0; j < grid_size && idx < m; ++j) {\n                int c_x = -5000 + i * 10000 / grid_size;\n                int c_y = -5000 + j * 10000 / grid_size;\n                int radius = rnd.next(1, 10000);\n\n                auto cir = make_tuple(c_x, c_y, radius);\n                if (circles.count(cir))\n                    continue;\n                circles.insert(cir);\n                xi[idx] = c_x;\n                yi[idx] = c_y;\n                ri[idx] = radius;\n                idx++;\n            }\n        }\n        while (idx < m) {\n            xi[idx] = rnd.next(-10000, 10000);\n            yi[idx] = rnd.next(-10000, 10000);\n            ri[idx] = rnd.next(1, 10000);\n            idx++;\n        }\n    } else {\n        // Default to random if type is unknown\n        // (same as 'random' type)\n        set<tuple<int, int, int, int>> segments;\n        for (int i = 0; i < n; ++i) {\n            while (true) {\n                int x1_i = rnd.next(-10000, 10000);\n                int y1_i = rnd.next(-10000, 10000);\n                int x2_i = rnd.next(-10000, 10000);\n                int y2_i = rnd.next(-10000, 10000);\n\n                // Ensure segment has positive length\n                if (x1_i == x2_i && y1_i == y2_i)\n                    continue;\n\n                auto sg = make_tuple(x1_i, y1_i, x2_i, y2_i);\n                auto sgrev = make_tuple(x2_i, y2_i, x1_i, y1_i);\n                if (segments.count(sg) || segments.count(sgrev))\n                    continue;\n\n                segments.insert(sg);\n                x1[i] = x1_i;\n                y1[i] = y1_i;\n                x2[i] = x2_i;\n                y2[i] = y2_i;\n                break;\n            }\n        }\n\n        // Generate random circles\n        set<tuple<int, int, int>> circles;\n        for (int i = 0; i < m; ++i) {\n            while (true) {\n                int xi_i = rnd.next(-10000, 10000);\n                int yi_i = rnd.next(-10000, 10000);\n                int ri_i = rnd.next(1, 10000);\n\n                auto cir = make_tuple(xi_i, yi_i, ri_i);\n                if (circles.count(cir))\n                    continue;\n\n                circles.insert(cir);\n                xi[i] = xi_i;\n                yi[i] = yi_i;\n                ri[i] = ri_i;\n                break;\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output segments\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", x1[i], y1[i], x2[i], y2[i]);\n    }\n\n    // Output circles\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", xi[i], yi[i], ri[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type random\n./gen -n 1 -m 2 -type line\n./gen -n 1 -m 2 -type zero\n./gen -n 1 -m 2 -type manyowls\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type line\n./gen -n 10 -m 10 -type zero\n./gen -n 10 -m 10 -type manyowls\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type line\n./gen -n 100 -m 100 -type zero\n./gen -n 100 -m 100 -type manyowls\n\n./gen -n 1000 -m 500 -type random\n./gen -n 1000 -m 500 -type line\n./gen -n 1000 -m 500 -type zero\n./gen -n 1000 -m 500 -type manyowls\n\n./gen -n 10000 -m 1000 -type random\n./gen -n 10000 -m 1000 -type line\n./gen -n 10000 -m 1000 -type zero\n./gen -n 10000 -m 1000 -type manyowls\n\n./gen -n 300000 -m 1500 -type random\n./gen -n 300000 -m 1500 -type line\n./gen -n 300000 -m 1500 -type zero\n./gen -n 300000 -m 1500 -type manyowls\n\n./gen -n 3 -m 2 -type random\n./gen -n 3 -m 2 -type line\n./gen -n 3 -m 2 -type zero\n./gen -n 3 -m 2 -type manyowls\n\n./gen -n 50000 -m 1500 -type random\n./gen -n 50000 -m 1500 -type line\n./gen -n 50000 -m 1500 -type zero\n./gen -n 50000 -m 1500 -type manyowls\n\n./gen -n 200000 -m 1000 -type random\n./gen -n 200000 -m 1000 -type line\n./gen -n 200000 -m 1000 -type zero\n./gen -n 200000 -m 1000 -type manyowls\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:28.940343",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "350/E",
      "title": "E. Wrong Floyd",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n, m, k (3 ≤ n ≤ 300, 2 ≤ k ≤ n , ) — the number of vertexes, the number of edges and the number of marked vertexes. The second line of the input contains k space-separated integers a1, a2, ... ak (1 ≤ ai ≤ n) — the numbers of the marked vertexes. It is guaranteed that all numbers ai are distinct.",
      "output_spec": "OutputIf the graph doesn't exist, print -1 on a single line. Otherwise, print m lines, each containing two integers u, v — the description of the edges of the graph Valera's been looking for.",
      "sample_tests": "ExamplesInputCopy3 2 21 2OutputCopy1 32 3InputCopy3 3 21 2OutputCopy-1",
      "description": "E. Wrong Floyd\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integers n, m, k (3 ≤ n ≤ 300, 2 ≤ k ≤ n , ) — the number of vertexes, the number of edges and the number of marked vertexes. The second line of the input contains k space-separated integers a1, a2, ... ak (1 ≤ ai ≤ n) — the numbers of the marked vertexes. It is guaranteed that all numbers ai are distinct.\n\nOutputIf the graph doesn't exist, print -1 on a single line. Otherwise, print m lines, each containing two integers u, v — the description of the edges of the graph Valera's been looking for.\n\nInputCopy3 2 21 2OutputCopy1 32 3InputCopy3 3 21 2OutputCopy-1\n\nInputCopy3 2 21 2\n\nOutputCopy1 32 3\n\nInputCopy3 3 21 2\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on October 1 at 19:30 MSK) you are lucky to participate in Codeforces Round #203 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) for testing of problems, Alexander Ignatyev (aiMR) for testing of problems and for idea of one of the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova (Delinur) for translation of statements.Good luck!UPD:Scoring will be dynamic. Problems are sorted by increasing order of difficulty.UPD: Congratulations to winners: fanhqme FAU.COACH Witalia sokian UPD: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 741
        },
        {
          "title": "Editorial Codeforces Round #203 (Div. 2) - Codeforces",
          "content": "350A - TLLet's v = min(ai), p = max(ai), c = min(bi). So, if max(2 * v, p) < c, then answer is max(2 * v, p), else answer is  - 1.Author solution: 4632352350B - ResortInput data represents a graph, by using a array of parents of every vertex. Because every vertex has at most one parent, we can use following solution: we will go up to parent of vertex v (prev[v]) until not found vertex with the outcome degree  ≥ 2. It is better to calculate outcome degrees in advance. After all, we will update the answer.This algorithm works in O(n).Author solution: 4632399350C - BombsFirst of all, Let's sort all point by increasing of value |xi| + |yi|, all points we will process by using this order. We will process each point greedily, by using maximum six moves. Now we want to come to the point (x, y). Let's x ≠ 0. Then we need to move exactly |x| in the dir direction (if x < 0 the dir is L, x > 0 — R). Similarly we will work with y-coordinates of point (x, y). Now we at the point (x, y), let's pick a bomb at point (x, y). After that we should come back to point (0, 0). Why it is correct to sort all point by increasing of Manhattan distance? If you will look at the path that we have received, you can notice that all points of path have lower Manhattan distance, i.e. we will process this points earlier.This solution works in Authors solution: 4632478350D - Looking for OwlsIt's possible to solve this problem by using only integer calculations. Normalization of the line Ax + By + C is following operation: we multiply our equation on the value , where g = gcd(A, gcd(B, C)), if A < 0 (orA = 0andB < 0) then sgn equals to  - 1, else sgn equals to 1.Now the solution. We will have two maps (map<> in С++, TreeMap(HashMap) in Java) to a set of points (it's possible that some points will have multiply occurrence into the set). In first map we will store right boundaries of the segments, in second — left boundaries (in increasing order).In advance for every segment we will build a normalized line, and for this normalized line we will put in our maps left and right segments of the segment.After all, for every fixed line let's sort our sets.Let's fix two different circles. After that, let's check that distance beetween them is greater then sum their radiuses, also you should check that circles has same radius. We can assume that we builded a line between centers of circles (x1, y1) and (x2, y2). Perpendicular to this line will have next coefficients (center of the segment [(x1, y1), (x2, y2)] also will belong to the next line) A = 2(x1 - x2), B = 2(y1 - y2), C =  - ((x1 - x2) * (x1 + x2) + (y1 - y2) * (y1 + y2)). After that you need to calculate values cntL, cntR by using binary search on set of points that lie on this line. cntL — amount of left boundaries that lie on the right side of point ((x1 + x2) / 2, (y1 + y2) / 2), cntR -- amount of right boundaries that lie on the left side of the point ((x1 + x2) / 2, (y1 + y2) / 2). After that you should add to answer value cntV - cntR - cntL,l where cntV — amount of segments, that lie on the nolmalized line.Total complexity: .solution: 4632546350E - Wrong FloydLet's do the following: construct the graph with the maximum possible number of edges and then remove the excess. First of all, you can notice that if k = n answer is  - 1. Else let's fix some marked vertex, for example a1. Let's put in our graph all edges except edges beetween a1 and x, where x — an another marked vertex. So, why this algorithm is correct? If Valera's algorithm is wrong, then there are a ''bad'' pair of vertexes (i, j). ``Bad'' pair is a pair for that Valera's algorithm works wrong. So, there are not marked vertex v on the shortest path from i to j, and v ≠ i, and v ≠ j. Without loss of generality, we can assume, that distance beetween i and j equals to 2, but Valera's algorithm gives greater answer. There are some cases, that depends on the type of vertexes i, j. But we can look only at the case where (i, j) are marked vertexes. First, add to the graph all edges beetween not fixed (i, j) vertexes. Second, add to the graph edges beetween some fixed vertex (i or j) and some not marked vertex. Third, add to the graph edges beetween i and some marked vertex v, where v ≠ j. It's simple to understand, that if we add some another edge, the Valera's algorithm will work correctly. Total amount of edges is .BONUS Simple bonus. For same contrains (n, m, k) can you build a graph, where Valera's code works correctly? Код: 4632600",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9042",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 350\\s*E"
          },
          "content_length": 4491
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 1",
          "code": "System.out.println()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 2",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 3",
          "code": "// std::sort(..., ..., cmp) ;\nbool cmp(dot d1, dot d2){\n\treturn abs(d1.x)+abs(d1.y) < abs(d2.x)+abs(d2.y) ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 4",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 5",
          "code": "bool cmp(dot d1, dot d2){\n\tif(d1.x == d2.x)\treturn abs(d1.y) < abs(d2.y) ;\n\treturn abs(d1.x) < abs(d2.x) ; // move x first, y second.\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 6",
          "code": "if(abs(d1.x) == abs(d2.x))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #203 (Div. 2) - Codeforces - Code 7",
          "code": "return (abs(a.x)==abs(b.x))?(abs(a.y)<abs(b.y)):(abs(a.x)<abs(b.x));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9003",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, n * (n - 1) / 2, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a(k);\n    set<int> s;\n    for (int i = 0; i < k; i++) {\n        a[i] = inf.readInt(1, n, \"a_i\");\n        ensuref(!s.count(a[i]), \"ai are not distinct\");\n        s.insert(a[i]);\n        if (i + 1 < k)\n            inf.readSpace();\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, n * (n - 1) / 2, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a(k);\n    set<int> s;\n    for (int i = 0; i < k; i++) {\n        a[i] = inf.readInt(1, n, \"a_i\");\n        ensuref(!s.count(a[i]), \"ai are not distinct\");\n        s.insert(a[i]);\n        if (i + 1 < k)\n            inf.readSpace();\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, n * (n - 1) / 2, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a(k);\n    set<int> s;\n    for (int i = 0; i < k; i++) {\n        a[i] = inf.readInt(1, n, \"a_i\");\n        ensuref(!s.count(a[i]), \"ai are not distinct\");\n        s.insert(a[i]);\n        if (i + 1 < k)\n            inf.readSpace();\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n, m, k;\nvector<int> a;\n\n// Function to read and parse the contestant's or jury's output.\n// Returns true if the output is -1 (indicating no solution), false otherwise.\n// If the output is a graph, it fills the adjacency matrix and edge list.\nbool readAndVerifyAnswer(InStream& stream, vector<vector<int>>& adjMatrix, vector<vector<int>>& adjList) {\n    // Read the first token\n    int firstValue = stream.readInt(-1, n, \"first value\");\n    if (firstValue == -1) {\n        return true; // No solution\n    } else {\n        // The output should be m edges\n        int u = firstValue;\n        int v = stream.readInt(1, n, \"second value\");\n        if (u < 1 || u > n || v < 1 || v > n || u == v) {\n            stream.quitf(_wa, \"Invalid edge (%d, %d)\", u, v);\n        }\n        set<pair<int, int>> edges;\n        edges.insert({min(u, v), max(u, v)});\n        adjMatrix[u - 1][v - 1] = 1;\n        adjMatrix[v - 1][u - 1] = 1;\n        adjList[u - 1].push_back(v - 1);\n        adjList[v - 1].push_back(u - 1);\n\n        for (int i = 1; i < m; ++i) {\n            u = stream.readInt(1, n, \"edge u\");\n            v = stream.readInt(1, n, \"edge v\");\n            if (u < 1 || u > n || v < 1 || v > n || u == v) {\n                stream.quitf(_wa, \"Invalid edge (%d, %d)\", u, v);\n            }\n            pair<int, int> edge = {min(u, v), max(u, v)};\n            if (edges.count(edge)) {\n                stream.quitf(_wa, \"Multiple edges between %d and %d\", u, v);\n            }\n            edges.insert(edge);\n            adjMatrix[u - 1][v - 1] = 1;\n            adjMatrix[v - 1][u - 1] = 1;\n            adjList[u - 1].push_back(v - 1);\n            adjList[v - 1].push_back(u - 1);\n        }\n        // Check for extra output\n        if (!stream.seekEof()) {\n            stream.quitf(_wa, \"Extra data in the output\");\n        }\n        // Check if the graph is connected\n        vector<bool> visited(n, false);\n        queue<int> q;\n        q.push(0);\n        visited[0] = true;\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            for (int neighbor : adjList[curr]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push(neighbor);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (!visited[i]) {\n                stream.quitf(_wa, \"The graph is not connected\");\n            }\n        }\n        return false; // Indicates that there is a solution\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(3, 300, \"n\");\n    m = inf.readInt(n - 1, n * (n - 1) / 2, \"m\");\n    k = inf.readInt(2, n, \"k\");\n    a.resize(k);\n    set<int> markedVertices;\n    for (int i = 0; i < k; ++i) {\n        a[i] = inf.readInt(1, n, format(\"a[%d]\", i + 1));\n        if (markedVertices.count(a[i])) {\n            quitf(_fail, \"Input error: Marked vertex %d appears multiple times\", a[i]);\n        }\n        markedVertices.insert(a[i]);\n    }\n\n    // Read the jury's answer\n    vector<vector<int>> ansAdjMatrix(n, vector<int>(n, INF));\n    vector<vector<int>> ansAdjList(n);\n    bool juryNoSolution = readAndVerifyAnswer(ans, ansAdjMatrix, ansAdjList);\n\n    // Read the contestant's output\n    vector<vector<int>> oufAdjMatrix(n, vector<int>(n, INF));\n    vector<vector<int>> oufAdjList(n);\n    bool contestantNoSolution = readAndVerifyAnswer(ouf, oufAdjMatrix, oufAdjList);\n\n    if (contestantNoSolution) {\n        if (juryNoSolution) {\n            quitf(_ok, \"No solution exists, and participant correctly outputs -1\");\n        } else {\n            quitf(_wa, \"Participant failed to find a solution when one exists\");\n        }\n    } else {\n        if (juryNoSolution) {\n            quitf(_fail, \"Participant found a solution when jury did not\");\n        }\n        // Participant provided a graph, need to verify it\n        // Compute the correct shortest distances (standard Floyd-Warshall)\n        vector<vector<int>> correctDist(n, vector<int>(n, INF));\n        for (int i = 0; i < n; ++i) {\n            correctDist[i][i] = 0;\n        }\n        for (int u = 0; u < n; ++u) {\n            for (int v : oufAdjList[u]) {\n                correctDist[u][v] = 1;\n            }\n        }\n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (correctDist[i][k] + correctDist[k][j] < correctDist[i][j]) {\n                        correctDist[i][j] = correctDist[i][k] + correctDist[k][j];\n                    }\n                }\n            }\n        }\n        // Simulate Valera's code\n        vector<vector<int>> valeraDist(n, vector<int>(n, INF));\n        for (int i = 0; i < n; ++i) {\n            valeraDist[i][i] = 0;\n        }\n        for (int u = 0; u < n; ++u) {\n            for (int v : oufAdjList[u]) {\n                valeraDist[u][v] = 1;\n            }\n        }\n        for (int idx = 0; idx < k; ++idx) {\n            int v = a[idx] - 1; // Convert to 0-based index\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (valeraDist[i][v] + valeraDist[v][j] < valeraDist[i][j]) {\n                        valeraDist[i][j] = valeraDist[i][v] + valeraDist[v][j];\n                    }\n                }\n            }\n        }\n        // Compare the distances\n        bool incorrect = false;\n        for (int i = 0; i < n && !incorrect; ++i) {\n            for (int j = 0; j < n && !incorrect; ++j) {\n                if (correctDist[i][j] != valeraDist[i][j]) {\n                    incorrect = true;\n                }\n            }\n        }\n        if (incorrect) {\n            quitf(_ok, \"Participant's graph is correct\");\n        } else {\n            quitf(_wa, \"Participant's graph does not cause Valera's code to compute incorrect distances\");\n        }\n    }\n    // Should not reach here\n    quitf(_fail, \"Unexpected end of checker\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", -1);\n    string answer = opt<string>(\"answer\", \"exist\");\n\n    // Ensure constraints\n    if (n < 3 || n > 300) {\n        fprintf(stderr, \"Error: n must be between 3 and 300\\n\");\n        exit(1);\n    }\n\n    if (answer == \"no\") {\n        k = n;\n    } else {\n        if (k == -1) {\n            fprintf(stderr, \"Error: k is required when answer is 'exist'\\n\");\n            exit(1);\n        }\n        if (k < 2 || k > n) {\n            fprintf(stderr, \"Error: k must be between 2 and n\\n\");\n            exit(1);\n        }\n    }\n\n    if (m < n -1 || m > n * (n - 1) / 2) {\n        fprintf(stderr, \"Error: m must be between n-1 and n(n-1)/2\\n\");\n        exit(1);\n    }\n\n    // Generate k distinct marked vertices in [1..n]\n    vector<int> vertices(n);\n    for (int i = 0; i < n; ++i)\n        vertices[i] = i + 1;\n    shuffle(vertices.begin(), vertices.end());\n    vector<int> marked(vertices.begin(), vertices.begin() + k);\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output k marked vertices\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d%c\", marked[i], (i + 1 == k) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", -1);\n    string answer = opt<string>(\"answer\", \"exist\");\n\n    // Ensure constraints\n    if (n < 3 || n > 300) {\n        fprintf(stderr, \"Error: n must be between 3 and 300\\n\");\n        exit(1);\n    }\n\n    if (answer == \"no\") {\n        k = n;\n    } else {\n        if (k == -1) {\n            fprintf(stderr, \"Error: k is required when answer is 'exist'\\n\");\n            exit(1);\n        }\n        if (k < 2 || k > n) {\n            fprintf(stderr, \"Error: k must be between 2 and n\\n\");\n            exit(1);\n        }\n    }\n\n    if (m < n -1 || m > n * (n - 1) / 2) {\n        fprintf(stderr, \"Error: m must be between n-1 and n(n-1)/2\\n\");\n        exit(1);\n    }\n\n    // Generate k distinct marked vertices in [1..n]\n    vector<int> vertices(n);\n    for (int i = 0; i < n; ++i)\n        vertices[i] = i + 1;\n    shuffle(vertices.begin(), vertices.end());\n    vector<int> marked(vertices.begin(), vertices.begin() + k);\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output k marked vertices\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d%c\", marked[i], (i + 1 == k) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases where the answer is 'no' (graph does not exist)\n./gen -n 3 -m 3 -answer no\n./gen -n 4 -m 6 -answer no\n./gen -n 5 -m 10 -answer no\n./gen -n 10 -m 45 -answer no\n./gen -n 20 -m 190 -answer no\n./gen -n 50 -m 1225 -answer no\n./gen -n 100 -m 4950 -answer no\n./gen -n 150 -m 11175 -answer no\n./gen -n 200 -m 19900 -answer no\n./gen -n 250 -m 31125 -answer no\n./gen -n 300 -m 44850 -answer no\n\n# Test cases where the answer is 'exist' (graph exists)\n./gen -n 3 -m 2 -k 2 -answer exist\n./gen -n 4 -m 3 -k 2 -answer exist\n./gen -n 5 -m 4 -k 2 -answer exist\n./gen -n 5 -m 4 -k 3 -answer exist\n./gen -n 5 -m 4 -k 5 -answer exist\n./gen -n 10 -m 9 -k 2 -answer exist\n./gen -n 10 -m 15 -k 3 -answer exist\n./gen -n 20 -m 30 -k 5 -answer exist\n./gen -n 50 -m 100 -k 25 -answer exist\n./gen -n 100 -m 200 -k 50 -answer exist\n./gen -n 150 -m 300 -k 75 -answer exist\n./gen -n 200 -m 500 -k 100 -answer exist\n./gen -n 250 -m 700 -k 125 -answer exist\n./gen -n 300 -m 1000 -k 150 -answer exist\n\n# Edge cases\n./gen -n 3 -m 2 -k 2 -answer exist\n./gen -n 3 -m 3 -answer no\n./gen -n 300 -m 300 -k 2 -answer exist\n./gen -n 300 -m 300 -answer no\n\n# Random cases\n./gen -n 20 -m 40 -k 10 -answer exist\n./gen -n 50 -m 1225 -k 49 -answer exist\n./gen -n 100 -m 300 -k 99 -answer exist\n./gen -n 200 -m 5000 -k 100 -answer exist\n./gen -n 250 -m 10000 -k 150 -answer exist\n\n# Cases with maximum k\n./gen -n 5 -m 4 -k 5 -answer exist\n./gen -n 10 -m 9 -k 10 -answer exist\n./gen -n 100 -m 200 -k 100 -answer exist\n./gen -n 300 -m 1000 -k 300 -answer exist\n\n# Cases where k is minimum\n./gen -n 100 -m 300 -k 2 -answer exist\n./gen -n 200 -m 500 -k 2 -answer exist\n./gen -n 300 -m 1000 -k 2 -answer exist\n\n# Large cases\n./gen -n 300 -m 299 -k 150 -answer exist\n./gen -n 300 -m 44850 -k 299 -answer exist\n\n# Cases where the answer is 'no' with varying m\n./gen -n 10 -m 9 -answer no\n./gen -n 10 -m 15 -answer no\n./gen -n 10 -m 45 -answer no\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:31.051003",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "351/A",
      "title": "A. Jeff and Rounding",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2000). The next line contains 2n real numbers a1, a2, ..., a2n (0 ≤ ai ≤ 10000), given with exactly three digits after the decimal point. The numbers are separated by spaces.",
      "output_spec": "OutputIn a single line print a single real number — the required difference with exactly three digits after the decimal point.",
      "sample_tests": "ExamplesInputCopy30.000 0.500 0.750 1.000 2.000 3.000OutputCopy0.250InputCopy34469.000 6526.000 4864.000 9356.383 7490.000 995.896OutputCopy0.279",
      "description": "A. Jeff and Rounding\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 2000). The next line contains 2n real numbers a1, a2, ..., a2n (0 ≤ ai ≤ 10000), given with exactly three digits after the decimal point. The numbers are separated by spaces.\n\nOutputIn a single line print a single real number — the required difference with exactly three digits after the decimal point.\n\nInputCopy30.000 0.500 0.750 1.000 2.000 3.000OutputCopy0.250InputCopy34469.000 6526.000 4864.000 9356.383 7490.000 995.896OutputCopy0.279\n\nInputCopy30.000 0.500 0.750 1.000 2.000 3.000\n\nOutputCopy0.250\n\nInputCopy34469.000 6526.000 4864.000 9356.383 7490.000 995.896\n\nOutputCopy0.279\n\nNoteIn the first test case you need to perform the operations as follows: (i = 1, j = 4), (i = 2, j = 3), (i = 5, j = 6). In this case, the difference will equal |(0 + 0.5 + 0.75 + 1 + 2 + 3) - (0 + 0 + 1 + 1 + 2 + 3)| = 0.25.",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Hello everyone!Codeforces Round #204 will take place on Friday, October 4th at 19:30 MSK. This is my eights Codeforces round and I hope not the last.I'd like to thank Gerald, yvasyliv, Cenadar and Zlobober for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values for the first division: 1000-1000-1500-2000-2000.Problem point values for the second division: standart. Tutorial. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 522
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces",
          "content": "Editorial for Codeforces Round #204352A - Jeff and DigitsSolution is looking for few cases:1. If we do not have zeros, then the answer is -1.2. If we have less than 9 fives, then the answer is 0.3. Otherwise, the answer is:4. 1. The maximum number of fives divisible by 94. 2. All zeros, we have 352B - Jeff and PeriodsWe will go through the array from left to right. At each step, we will store the arrays:1. nextx — the last occurrence of the number x2. periodx — period, which occurs x3. failx — whether a time when the number of x no longer fit Now, when we get a new number we considering the case when it is the first, second or occurred more than twice.All the cases described in any past system testing solution. 351A - Jeff and RoundingInitially, we should remember the number of integers — C. On next step we will round down all numbers and count the sum. Now we can change the sum, rounding up some numbers, with those not matter what kind of, the main thing — how many. Consider a couple what we could get:1. (int, int) (c1)2. (int, double) (c2)3. (double, int) (c3)4. (double, double) (c4) Iterate over the number of pairs of the first type. Then we know the total number of second and third type and number of the fourth type:1. c2 + c3 = C - 2c12. c4 = N - (c1  +  c2  +  c3)Check to see if you can get such numbers (enough for us count of integers and real numbers, respectively). We find that we can round up from c4 to c4 + c2 + c3 numbers. We will find the best choise. 351B - Jeff and Furikote that after each step, the number of inversions in the permutation is changed by 1. Let us turn to the inversions of the permutation — let them be I pcs. It is clear that when we have one inversion, then the answer — 1. Now we will see how to use it further:1. it is clear that after a Jeff's step inversions will become lower by 12. it is clear that after a Furik's step inversions will be on 1 lowerwith porbability of 0, 5, and on 1 greater with probability of 0, 5.3. we have the formula for an answer ansI = 1 + 1 + ansI - 1 - 1 × 0.5 + ansI - 1 + 1 × 0.54. after transformation we have ansI = 4 + ansI - 2. 351C - Jeff and BracketsHow to solve the problem for small NM? Just use the dynamic programming dpi, j — minimum cost to build i first brackets with the balance j. Transfers are simple:1. dpi, j + ai + 1 -> dpi + 1, j + 12. dpi, j + bi + 1 -> dpi + 1, j - 13. we make transfers only when balance will be non-negative4. starting state dp0, 0 = 0 In this problem, we can assume that the balance will never exceed 2N. The proof is left as homework. And by using this fact problem can be done by erecting a matrix to the power:1. lets Ti, j — cost of transfer from balance i to balance j, using N brackets2. (TM)0, 0 — answer to the problem 351D - Jeff and Removing PeriodsAfter the first request we can sort the numbers and for further moves will be able to remove all occurrences of a certain number. So the answer is the number of different numbers + 1 if there is no number, occurrence of which form an arithmetic progression. Number of different numbers on a segment — standart problem, can be done O(N1.5) with offline algorithm. The problem about finding the right number will be solved in a similar algorithm:1. lets sort queries like pairs (li / 300, ri), we use integer dividing2. learn how to move from the interval (l, r) to intervals (l - 1, r), (l + 1, r), (l, r - 1), (l, r + 1) with complexcity O(1)3. by means of such an operation will move from one segment to the next, in the amount of the operation algorithm will works O(N1.5) It remains to learn how to make the change on the interval by 1 element. Such a problem can be solved quite simply:1. we craete deque for all value of numbers in array2. depending on changes in the segment will add / remove items to the start / end of the respective deque3. check whether the resulting deque is arithmetic progression. it will be homework. 351E - Jeff and PermutationWe make the zero step, replace the elements on their modules. The first thing you need to understand the way in which we will build our response. After selecting a few ways to understand the fact that initially you need to determine the sign of the largest numbers. Consider the case where the current step we have only one maximal element. It is clear that if you put a sign - all the elements on the left of this will form an inversion, while on the right there will be no inversions. If we do not put a sign - it will all be the opposite. We select the best one and cross out the number of the array, it will not affect to some inversion. Now we should understand how to read the response when the highs more than one. We write the dynamics dp[i][j] — how much inversions can you get, when we looked at the first i higest values and j from them lefted as possitive. Of these dynamics is not difficult to make the transition and get the answer. And so we have a simple and short algorithm:1. Iterates until the array is not empty2. Find all the maximal elements3. Calculate dynamics and find right signs4. Remove elements from an array For more details view any passed system tests solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9070",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 351\\s*A"
          },
          "content_length": 5147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 1",
          "code": "Amount required to Ceil index j - Amount required to floor index i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 2",
          "code": "= (1-A[j]) - A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 3",
          "code": "(1-A[j]) - A[i] = 1 - A[j] - A[i] = (1-A[i]) - A[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 4",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 5",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 6",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 7",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 8",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 9",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 10",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 11",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 12",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 13",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n    ensuref(!line.empty(), \"Line is empty\");\n\n    ensuref(line.front() != ' ', \"Line starts with a space\");\n    ensuref(line.back() != ' ', \"Line ends with a space\");\n\n    int token_count = 0;\n    size_t pos = 0;\n    while (pos < line.size()) {\n        // Find next space\n        size_t space_pos = line.find(' ', pos);\n\n        string token;\n        if (space_pos == string::npos) {\n            // Last token\n            token = line.substr(pos);\n            pos = line.size();\n        } else {\n            // Token from pos to space_pos - pos\n            token = line.substr(pos, space_pos - pos);\n            pos = space_pos + 1;\n\n            ensuref(pos < line.size(), \"Line ends with space\");\n            ensuref(line[pos] != ' ', \"Multiple spaces between tokens at position %zu\", pos);\n        }\n\n        // Process token\n        ensuref(!token.empty(), \"Empty token at position %d\", token_count+1);\n\n        ensuref(regex_match(token, regex(\"[0-9]+\\\\.[0-9]{3}\")), \"Token '%s' doesn't match the required format\", token.c_str());\n\n        double x = atof(token.c_str());\n        ensuref(0.0 <= x && x <= 10000.0, \"Value %s = %.3f is not in [0, 10000]\", token.c_str(), x);\n\n        token_count++;\n    }\n\n    ensuref(token_count == 2 * n, \"Expected %d tokens, but read %d tokens\", 2 * n, token_count);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n    ensuref(!line.empty(), \"Line is empty\");\n\n    ensuref(line.front() != ' ', \"Line starts with a space\");\n    ensuref(line.back() != ' ', \"Line ends with a space\");\n\n    int token_count = 0;\n    size_t pos = 0;\n    while (pos < line.size()) {\n        // Find next space\n        size_t space_pos = line.find(' ', pos);\n\n        string token;\n        if (space_pos == string::npos) {\n            // Last token\n            token = line.substr(pos);\n            pos = line.size();\n        } else {\n            // Token from pos to space_pos - pos\n            token = line.substr(pos, space_pos - pos);\n            pos = space_pos + 1;\n\n            ensuref(pos < line.size(), \"Line ends with space\");\n            ensuref(line[pos] != ' ', \"Multiple spaces between tokens at position %zu\", pos);\n        }\n\n        // Process token\n        ensuref(!token.empty(), \"Empty token at position %d\", token_count+1);\n\n        ensuref(regex_match(token, regex(\"[0-9]+\\\\.[0-9]{3}\")), \"Token '%s' doesn't match the required format\", token.c_str());\n\n        double x = atof(token.c_str());\n        ensuref(0.0 <= x && x <= 10000.0, \"Value %s = %.3f is not in [0, 10000]\", token.c_str(), x);\n\n        token_count++;\n    }\n\n    ensuref(token_count == 2 * n, \"Expected %d tokens, but read %d tokens\", 2 * n, token_count);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n    ensuref(!line.empty(), \"Line is empty\");\n\n    ensuref(line.front() != ' ', \"Line starts with a space\");\n    ensuref(line.back() != ' ', \"Line ends with a space\");\n\n    int token_count = 0;\n    size_t pos = 0;\n    while (pos < line.size()) {\n        // Find next space\n        size_t space_pos = line.find(' ', pos);\n\n        string token;\n        if (space_pos == string::npos) {\n            // Last token\n            token = line.substr(pos);\n            pos = line.size();\n        } else {\n            // Token from pos to space_pos - pos\n            token = line.substr(pos, space_pos - pos);\n            pos = space_pos + 1;\n\n            ensuref(pos < line.size(), \"Line ends with space\");\n            ensuref(line[pos] != ' ', \"Multiple spaces between tokens at position %zu\", pos);\n        }\n\n        // Process token\n        ensuref(!token.empty(), \"Empty token at position %d\", token_count+1);\n\n        ensuref(regex_match(token, regex(\"[0-9]+\\\\.[0-9]{3}\")), \"Token '%s' doesn't match the required format\", token.c_str());\n\n        double x = atof(token.c_str());\n        ensuref(0.0 <= x && x <= 10000.0, \"Value %s = %.3f is not in [0, 10000]\", token.c_str(), x);\n\n        token_count++;\n    }\n\n    ensuref(token_count == 2 * n, \"Expected %d tokens, but read %d tokens\", 2 * n, token_count);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<double> a(2 * n);\n\n    if (type == \"random\") {\n        // Random ai's between 0.000 and 10000.000, with exactly 3 decimal digits\n        for (int i = 0; i < 2 * n; ++i) {\n            long long x = rnd.next(0LL, 10000000LL);\n            a[i] = x / 1000.0;\n        }\n\n    } else if (type == \"integers\") {\n        // All ai's are integers between 0 and 10000, printed with .000\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 10000);\n            a[i] = (double)integer_part;\n        }\n\n    } else if (type == \"fractionals\") {\n        // All ai's have non-zero fractional parts\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 9999);\n            int decimal_part = rnd.next(1, 999);\n            a[i] = integer_part + decimal_part / 1000.0;\n        }\n\n    } else if (type == \"fractionals_close_to_zero\") {\n        // Fractional parts close to 0\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 10000);\n            int decimal_part = rnd.next(1, 10);\n            if (integer_part == 10000) decimal_part = 0;\n            a[i] = integer_part + decimal_part / 1000.0;\n        }\n\n    } else if (type == \"fractionals_close_to_one\") {\n        // Fractional parts close to 0.999\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 9999);\n            int decimal_part = rnd.next(990, 999);\n            a[i] = integer_part + decimal_part / 1000.0;\n        }\n\n    } else if (type == \"half_integers\") {\n        // All ai's have fractional part exactly .500\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 10000);\n            if (integer_part == 10000) {\n                a[i] = 10000.000;\n            } else {\n                a[i] = integer_part + 0.500;\n            }\n        }\n\n    } else if (type == \"small_numbers\") {\n        // All ai's are small numbers between 0.001 and 0.999\n        for (int i = 0; i < 2 * n; ++i) {\n            int decimal_part = rnd.next(1, 999);\n            a[i] = decimal_part / 1000.0;\n        }\n\n    } else if (type == \"large_numbers\") {\n        // All ai's are large numbers close to 10000.000\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(9990, 10000);\n            int decimal_part = rnd.next(0, 999);\n            if (integer_part == 10000) decimal_part = 0;\n            a[i] = integer_part + decimal_part / 1000.0;\n        }\n\n    } else {\n        // Default to random\n        for (int i = 0; i < 2 * n; ++i) {\n            long long x = rnd.next(0LL, 10000000LL);\n            a[i] = x / 1000.0;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai's with exactly three digits after the decimal point\n    for (int i = 0; i < 2 * n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%.3f\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<double> a(2 * n);\n\n    if (type == \"random\") {\n        // Random ai's between 0.000 and 10000.000, with exactly 3 decimal digits\n        for (int i = 0; i < 2 * n; ++i) {\n            long long x = rnd.next(0LL, 10000000LL);\n            a[i] = x / 1000.0;\n        }\n\n    } else if (type == \"integers\") {\n        // All ai's are integers between 0 and 10000, printed with .000\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 10000);\n            a[i] = (double)integer_part;\n        }\n\n    } else if (type == \"fractionals\") {\n        // All ai's have non-zero fractional parts\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 9999);\n            int decimal_part = rnd.next(1, 999);\n            a[i] = integer_part + decimal_part / 1000.0;\n        }\n\n    } else if (type == \"fractionals_close_to_zero\") {\n        // Fractional parts close to 0\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 10000);\n            int decimal_part = rnd.next(1, 10);\n            if (integer_part == 10000) decimal_part = 0;\n            a[i] = integer_part + decimal_part / 1000.0;\n        }\n\n    } else if (type == \"fractionals_close_to_one\") {\n        // Fractional parts close to 0.999\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 9999);\n            int decimal_part = rnd.next(990, 999);\n            a[i] = integer_part + decimal_part / 1000.0;\n        }\n\n    } else if (type == \"half_integers\") {\n        // All ai's have fractional part exactly .500\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(0, 10000);\n            if (integer_part == 10000) {\n                a[i] = 10000.000;\n            } else {\n                a[i] = integer_part + 0.500;\n            }\n        }\n\n    } else if (type == \"small_numbers\") {\n        // All ai's are small numbers between 0.001 and 0.999\n        for (int i = 0; i < 2 * n; ++i) {\n            int decimal_part = rnd.next(1, 999);\n            a[i] = decimal_part / 1000.0;\n        }\n\n    } else if (type == \"large_numbers\") {\n        // All ai's are large numbers close to 10000.000\n        for (int i = 0; i < 2 * n; ++i) {\n            int integer_part = rnd.next(9990, 10000);\n            int decimal_part = rnd.next(0, 999);\n            if (integer_part == 10000) decimal_part = 0;\n            a[i] = integer_part + decimal_part / 1000.0;\n        }\n\n    } else {\n        // Default to random\n        for (int i = 0; i < 2 * n; ++i) {\n            long long x = rnd.next(0LL, 10000000LL);\n            a[i] = x / 1000.0;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai's with exactly three digits after the decimal point\n    for (int i = 0; i < 2 * n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%.3f\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type integers\n./gen -n 1 -type fractionals\n./gen -n 1 -type fractionals_close_to_zero\n./gen -n 1 -type fractionals_close_to_one\n./gen -n 1 -type half_integers\n./gen -n 1 -type small_numbers\n./gen -n 1 -type large_numbers\n\n./gen -n 2 -type random\n./gen -n 2 -type integers\n./gen -n 2 -type fractionals\n\n./gen -n 10 -type random\n./gen -n 10 -type integers\n./gen -n 10 -type fractionals\n\n./gen -n 100 -type random\n./gen -n 100 -type integers\n./gen -n 100 -type fractionals\n\n./gen -n 500 -type random\n./gen -n 500 -type fractionals_close_to_zero\n./gen -n 500 -type fractionals_close_to_one\n./gen -n 500 -type half_integers\n\n./gen -n 1000 -type random\n./gen -n 1000 -type small_numbers\n./gen -n 1000 -type large_numbers\n\n./gen -n 2000 -type random\n./gen -n 2000 -type integers\n./gen -n 2000 -type fractionals\n./gen -n 2000 -type fractionals_close_to_zero\n./gen -n 2000 -type fractionals_close_to_one\n./gen -n 2000 -type half_integers\n./gen -n 2000 -type small_numbers\n./gen -n 2000 -type large_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:32.749709",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "351/B",
      "title": "B. Джефф и Фурик",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 3000). Следующая строка содержит n различных целых чисел p1, p2, ..., pn (1 ≤ pi ≤ n) — перестановка p. Числа разделены пробелами.",
      "output_spec": "Выходные данныеВ единственную строку выведите вещественное число — ответ на задачу. Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать21 2Выходные данныеСкопировать0.000000Входные данныеСкопировать53 5 2 4 1Выходные данныеСкопировать13.000000",
      "description": "B. Джефф и Фурик\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 3000). Следующая строка содержит n различных целых чисел p1, p2, ..., pn (1 ≤ pi ≤ n) — перестановка p. Числа разделены пробелами.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите вещественное число — ответ на задачу. Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать21 2Выходные данныеСкопировать0.000000Входные данныеСкопировать53 5 2 4 1Выходные данныеСкопировать13.000000\n\nВходные данныеСкопировать21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать53 5 2 4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13.000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте последовательность уже отсортирована, следовательно — ответ 0.",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Всем привет!Совсем скоро, 4 октября в 19:30 MSK состоится Codeforces Round #204, автором которого являюсь я. Это мой восьмой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald), Евгену Василиву(yvasyliv), Максиму Бевзе(Cenadar) и Максиму Ахмедову(Zlobober) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе: 1000-1000-1500-2000-2000.Разбалловка во втором дивизионе: стандарт. Разбор. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 551
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces",
          "content": "Разбор задач Codeforces Round #204352A - Джефф и цифрыРассмотрим решение как разбор случаев:1. Если у нас нету нулей, то ответ -1.2. Если у нас меньше чем 9 пятерок, то ответ 0.3. Иначе ответ имеет вид:4. 1. максимальное количество пятерок, кратное 94. 2. все нули, что у нас есть 352B - Джефф и периодыБудем идти по массиву слева направо. На каждом шаге будем хранить массивы:1. nextx — последнее вхождение числа x2. periodx — период, с которым встречается x3. failx — был ли момент, когда число x перестало подходить Теперь когда мы получаем число рассматриваем случай, когда оно первое, второе или встречалось больше чем два раза.Все случаи описаны в любом прошедшем системное тестирование решении. 351A - Джефф и округленияИзначально запомним количество целых чисел — C. Далее округлим все числа вниз, и посчитаем сумму. Теперь мы можем изменить сумму, округлив некоторые числа вверх, при чем не важно какие именно, главное — сколько. Рассмотрим пары, которые могли получится (описанные в условии, первая компонента — число, округленное вниз, вторая — число, округленное вверх):1. (int, int) (c1)2. (int, double) (c2)3. (double, int) (c3)4. (double, double) (c4) Переберем количество пар первого типа c1. Тогда мы знаем суммарное количество вторых и третьих типов и количество четвертого типа:1. c2 + c3 = C - 2c12. c4 = N-(c1 + c2 + c3).Проверим, можно ли получить такие числа (хватит ли нам целых и действительных чисел соответственно). Получим, что мы можем округлить вверх от c4 до c4 + c2 + c3 чисел. Найдем среди них самое подходящее и обновим ответ. 351B - Джефф и ФурикЗаметим что после каждого шага количество инверсий в перестановке изменится на 1. Перейдем от перестановки к инверсиям — пусть их будет I штук. Понятно, что когда у нас одна инверсия, то ответ — 1. Теперь поймем, как это использовать дальше:1. понятно, что после хода Джеффа инверсий станет на 1 меньше2. понятно, что после хода Фурика инверсий станет на 1 меньше с вероятностью 0, 5, и на 1 больше с вероятностью 0, 5.3. имеем формулу для ответа ansI = 1 + 1 + ansI — 1 — 1 × 0.5 + ansI — 1 + 1 × 0.54. после преобразования получим ansI = 4 + ansI — 2.351C - Джефф и скобкиКак решить задачу для маленького NM? Просто использовать динамику dpi, j — минимальная стоимость построить i первых скобок с балансом j. Переходы просты:1. dpi, j + ai + 1 -> dpi + 1, j + 12. dpi, j + bi + 1 -> dpi + 1, j - 13. переходы делаем только, если результирующий баланс не отрицателен4. стартовые значения dp0, 0 = 0 В данной задаче можем считать, что баланс никогда не превысит 2N. Доказательство этого факта оставим как домашнее задание. А использую этот факт задачу можно решить возводя матрицу в степень:1. пусть Ti, j — цена перехода от баланса i к балансу j с помощью N скобок2. (TM)0, 0 — ответ на задачу 351D - Джефф и удаление периодовПосле первого запроса мы можем отсортировать числа и в за дальнейшие ходы сможем удалять все вхождения некоторого числа. Таким образом ответ это количество различных чисел + 1, если не найдется числа, вхождения которого образовывают арифметическую прогрессию. Количество различных чисел на под отрезке в оффлайне — стандартная задача, описанная на многих ресурсах, решается за O(N1.5). Задачу про поиск нужного элемента будем решать аналогичным способом:1. отсортируем запросы как пары (li / 300, ri), деление целочисленное2. научимся переходить от отрезка (l, r) к (l - 1, r), (l + 1, r), (l, r - 1), (l, r + 1) за O(1)3. с помощью таких операция будем переходить от одного отрезка к следующему, в сумме операция выйдет O(N1.5) Осталось научится делать изменение отрезка на 1 элемент. Такую задачу решать достаточно просто:1. заведем deque для всех значений чисел2. в зависимости от изменения отрезка будем добавлять/удалять элемент в начало/конец соответственного deque3. проверим, является ли полученный deque арифметической прогрессией. это останется домашним заданием 351E - Джефф и перестановкаСделаем нулевой шаг, заменим элементы на их модули. Первое, нужно понять каким способом мы будем строить наш ответ. После подбора нескольких способов поймем факт, что изначально нужно определять знак у больших чисел. Рассмотрим случай, когда на текущем шаге у нас только один максимальный элемент. Понятно, что если поставить знак -, то все элементы слева от текущего будут образовывать инверсии, а справа нет. Если же мы не будем ставить знак -, то все будет наоборот. Выберем лучший вариант и вычеркнем число из массива, больше оно не будет влиять на инверсии. Теперь поймем, как считать ответ, когда максимумов больше одного. Напишем динамику dp[i][j] — сколько можно получить инверсий, когда мы рассмотрели первых i максимумов и j из них оставили положительными. Из такой динамики не сложно сделать переходы и получить ответ. И так имеем простой и короткий алгоритм:1. делаем итерации пока массив не пуст2. найдем все максимальные элементы3. с помощью динамики определим знаки, которые нужно поставить элементам4. удалим элементы из массива Для уточнения деталей решений просмотрите любое прошедшее системное тестирование решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9070",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 351\\s*B"
          },
          "content_length": 5042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 1",
          "code": "Amount required to Ceil index j - Amount required to floor index i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 2",
          "code": "= (1-A[j]) - A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 3",
          "code": "(1-A[j]) - A[i] = 1 - A[j] - A[i] = (1-A[i]) - A[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 4",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 5",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 6",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 7",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 8",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 9",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 10",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 11",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 12",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 13",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    set<int> s(p.begin(), p.end());\n    ensuref(s.size() == n, \"All p_i should be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    set<int> s(p.begin(), p.end());\n    ensuref(s.size() == n, \"All p_i should be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    set<int> s(p.begin(), p.end());\n    ensuref(s.size() == n, \"All p_i should be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1);  // number of swaps for 'few_swaps' type\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = i + 1;\n\n    if (type == \"sorted\") {\n        // Already sorted\n    } else if (type == \"reversed\") {\n        reverse(p.begin(), p.end());\n    } else if (type == \"random\") {\n        shuffle(p.begin(), p.end());\n    } else if (type == \"almost_sorted\") {\n        // Swap some adjacent pairs\n        int swaps = min(k, n-1);\n        for (int i = 0; i < swaps; ++i) {\n            int idx = rnd.next(0, n - 2);\n            swap(p[idx], p[idx + 1]);\n        }\n    } else if (type == \"almost_reversed\") {\n        reverse(p.begin(), p.end());\n        int swaps = min(k, n-1);\n        for (int i = 0; i < swaps; ++i) {\n            int idx = rnd.next(0, n - 2);\n            swap(p[idx], p[idx + 1]);\n        }\n    } else if (type == \"few_swaps\") {\n        int swaps = min(k, n*(n-1)/2);\n        for (int i = 0; i < swaps; ++i) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            while (idx2 == idx1) idx2 = rnd.next(0, n - 1);\n            swap(p[idx1], p[idx2]);\n        }\n    } else if (type == \"sawtooth\") {\n        vector<int> small, large;\n        for (int i = 1; i <= n/2; ++i)\n            small.push_back(i);\n        for (int i = n/2 + 1; i <= n; ++i)\n            large.push_back(i);\n        shuffle(small.begin(), small.end());\n        shuffle(large.begin(), large.end());\n        p.clear();\n        int i = 0, j = 0;\n        while (i < small.size() && j < large.size()) {\n            p.push_back(large[j++]);\n            p.push_back(small[i++]);\n        }\n        while (i < small.size())\n            p.push_back(small[i++]);\n        while (j < large.size())\n            p.push_back(large[j++]);\n    } else {\n        // Default to random\n        shuffle(p.begin(), p.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%d\", p[i]);\n        if (i + 1 != n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1);  // number of swaps for 'few_swaps' type\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = i + 1;\n\n    if (type == \"sorted\") {\n        // Already sorted\n    } else if (type == \"reversed\") {\n        reverse(p.begin(), p.end());\n    } else if (type == \"random\") {\n        shuffle(p.begin(), p.end());\n    } else if (type == \"almost_sorted\") {\n        // Swap some adjacent pairs\n        int swaps = min(k, n-1);\n        for (int i = 0; i < swaps; ++i) {\n            int idx = rnd.next(0, n - 2);\n            swap(p[idx], p[idx + 1]);\n        }\n    } else if (type == \"almost_reversed\") {\n        reverse(p.begin(), p.end());\n        int swaps = min(k, n-1);\n        for (int i = 0; i < swaps; ++i) {\n            int idx = rnd.next(0, n - 2);\n            swap(p[idx], p[idx + 1]);\n        }\n    } else if (type == \"few_swaps\") {\n        int swaps = min(k, n*(n-1)/2);\n        for (int i = 0; i < swaps; ++i) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            while (idx2 == idx1) idx2 = rnd.next(0, n - 1);\n            swap(p[idx1], p[idx2]);\n        }\n    } else if (type == \"sawtooth\") {\n        vector<int> small, large;\n        for (int i = 1; i <= n/2; ++i)\n            small.push_back(i);\n        for (int i = n/2 + 1; i <= n; ++i)\n            large.push_back(i);\n        shuffle(small.begin(), small.end());\n        shuffle(large.begin(), large.end());\n        p.clear();\n        int i = 0, j = 0;\n        while (i < small.size() && j < large.size()) {\n            p.push_back(large[j++]);\n            p.push_back(small[i++]);\n        }\n        while (i < small.size())\n            p.push_back(small[i++]);\n        while (j < large.size())\n            p.push_back(large[j++]);\n    } else {\n        // Default to random\n        shuffle(p.begin(), p.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%d\", p[i]);\n        if (i + 1 != n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type sorted\n./gen -n 1 -type reversed\n./gen -n 2 -type sorted\n./gen -n 2 -type reversed\n./gen -n 2 -type random\n./gen -n 5 -type sorted\n./gen -n 5 -type reversed\n./gen -n 5 -type random\n./gen -n 5 -type almost_sorted -k 1\n./gen -n 5 -type almost_reversed -k 1\n./gen -n 10 -type sorted\n./gen -n 10 -type reversed\n./gen -n 10 -type random\n./gen -n 10 -type almost_sorted -k 2\n./gen -n 10 -type few_swaps -k 5\n./gen -n 10 -type sawtooth\n./gen -n 100 -type random\n./gen -n 100 -type almost_sorted -k 5\n./gen -n 100 -type almost_reversed -k 5\n./gen -n 100 -type few_swaps -k 10\n./gen -n 100 -type sawtooth\n./gen -n 1000 -type random\n./gen -n 1000 -type almost_sorted -k 10\n./gen -n 1000 -type almost_reversed -k 10\n./gen -n 1000 -type few_swaps -k 20\n./gen -n 1000 -type sawtooth\n./gen -n 3000 -type random\n./gen -n 3000 -type almost_sorted -k 10\n./gen -n 3000 -type almost_reversed -k 10\n./gen -n 3000 -type few_swaps -k 50\n./gen -n 3000 -type sawtooth\n./gen -n 3000 -type sorted\n./gen -n 3000 -type reversed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:35.125577",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "351/C",
      "title": "C. Джефф и скобки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n и m (1 ≤ n ≤ 20; 1 ≤ m ≤ 107; m — четное). Следующая строка содержит n целых чисел: a0, a1, ..., an - 1 (1 ≤ ai ≤ 10). Следующая строка содержит n целых чисел: b0, b1, ..., bn - 1 (1 ≤ bi ≤ 10). Числа разделяются пробелами.",
      "output_spec": "Выходные данныеВ единственную строку выведите ответ на задачу — минимальный требуемый объем чернил в литрах.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 61 22 1Выходные данныеСкопировать12Входные данныеСкопировать1 1000000023Выходные данныеСкопировать25000000",
      "description": "C. Джефф и скобки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа n и m (1 ≤ n ≤ 20; 1 ≤ m ≤ 107; m — четное). Следующая строка содержит n целых чисел: a0, a1, ..., an - 1 (1 ≤ ai ≤ 10). Следующая строка содержит n целых чисел: b0, b1, ..., bn - 1 (1 ≤ bi ≤ 10). Числа разделяются пробелами.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите ответ на задачу — минимальный требуемый объем чернил в литрах.\n\nВыходные данные\n\nВходные данныеСкопировать2 61 22 1Выходные данныеСкопировать12Входные данныеСкопировать1 1000000023Выходные данныеСкопировать25000000\n\nВходные данныеСкопировать2 61 22 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1000000023\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать25000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте оптимальная последовательность: ()()()()()(), требуемое количество литров чернил — 12.",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Всем привет!Совсем скоро, 4 октября в 19:30 MSK состоится Codeforces Round #204, автором которого являюсь я. Это мой восьмой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald), Евгену Василиву(yvasyliv), Максиму Бевзе(Cenadar) и Максиму Ахмедову(Zlobober) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе: 1000-1000-1500-2000-2000.Разбалловка во втором дивизионе: стандарт. Разбор. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 551
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces",
          "content": "Разбор задач Codeforces Round #204352A - Джефф и цифрыРассмотрим решение как разбор случаев:1. Если у нас нету нулей, то ответ -1.2. Если у нас меньше чем 9 пятерок, то ответ 0.3. Иначе ответ имеет вид:4. 1. максимальное количество пятерок, кратное 94. 2. все нули, что у нас есть 352B - Джефф и периодыБудем идти по массиву слева направо. На каждом шаге будем хранить массивы:1. nextx — последнее вхождение числа x2. periodx — период, с которым встречается x3. failx — был ли момент, когда число x перестало подходить Теперь когда мы получаем число рассматриваем случай, когда оно первое, второе или встречалось больше чем два раза.Все случаи описаны в любом прошедшем системное тестирование решении. 351A - Джефф и округленияИзначально запомним количество целых чисел — C. Далее округлим все числа вниз, и посчитаем сумму. Теперь мы можем изменить сумму, округлив некоторые числа вверх, при чем не важно какие именно, главное — сколько. Рассмотрим пары, которые могли получится (описанные в условии, первая компонента — число, округленное вниз, вторая — число, округленное вверх):1. (int, int) (c1)2. (int, double) (c2)3. (double, int) (c3)4. (double, double) (c4) Переберем количество пар первого типа c1. Тогда мы знаем суммарное количество вторых и третьих типов и количество четвертого типа:1. c2 + c3 = C - 2c12. c4 = N-(c1 + c2 + c3).Проверим, можно ли получить такие числа (хватит ли нам целых и действительных чисел соответственно). Получим, что мы можем округлить вверх от c4 до c4 + c2 + c3 чисел. Найдем среди них самое подходящее и обновим ответ. 351B - Джефф и ФурикЗаметим что после каждого шага количество инверсий в перестановке изменится на 1. Перейдем от перестановки к инверсиям — пусть их будет I штук. Понятно, что когда у нас одна инверсия, то ответ — 1. Теперь поймем, как это использовать дальше:1. понятно, что после хода Джеффа инверсий станет на 1 меньше2. понятно, что после хода Фурика инверсий станет на 1 меньше с вероятностью 0, 5, и на 1 больше с вероятностью 0, 5.3. имеем формулу для ответа ansI = 1 + 1 + ansI — 1 — 1 × 0.5 + ansI — 1 + 1 × 0.54. после преобразования получим ansI = 4 + ansI — 2.351C - Джефф и скобкиКак решить задачу для маленького NM? Просто использовать динамику dpi, j — минимальная стоимость построить i первых скобок с балансом j. Переходы просты:1. dpi, j + ai + 1 -> dpi + 1, j + 12. dpi, j + bi + 1 -> dpi + 1, j - 13. переходы делаем только, если результирующий баланс не отрицателен4. стартовые значения dp0, 0 = 0 В данной задаче можем считать, что баланс никогда не превысит 2N. Доказательство этого факта оставим как домашнее задание. А использую этот факт задачу можно решить возводя матрицу в степень:1. пусть Ti, j — цена перехода от баланса i к балансу j с помощью N скобок2. (TM)0, 0 — ответ на задачу 351D - Джефф и удаление периодовПосле первого запроса мы можем отсортировать числа и в за дальнейшие ходы сможем удалять все вхождения некоторого числа. Таким образом ответ это количество различных чисел + 1, если не найдется числа, вхождения которого образовывают арифметическую прогрессию. Количество различных чисел на под отрезке в оффлайне — стандартная задача, описанная на многих ресурсах, решается за O(N1.5). Задачу про поиск нужного элемента будем решать аналогичным способом:1. отсортируем запросы как пары (li / 300, ri), деление целочисленное2. научимся переходить от отрезка (l, r) к (l - 1, r), (l + 1, r), (l, r - 1), (l, r + 1) за O(1)3. с помощью таких операция будем переходить от одного отрезка к следующему, в сумме операция выйдет O(N1.5) Осталось научится делать изменение отрезка на 1 элемент. Такую задачу решать достаточно просто:1. заведем deque для всех значений чисел2. в зависимости от изменения отрезка будем добавлять/удалять элемент в начало/конец соответственного deque3. проверим, является ли полученный deque арифметической прогрессией. это останется домашним заданием 351E - Джефф и перестановкаСделаем нулевой шаг, заменим элементы на их модули. Первое, нужно понять каким способом мы будем строить наш ответ. После подбора нескольких способов поймем факт, что изначально нужно определять знак у больших чисел. Рассмотрим случай, когда на текущем шаге у нас только один максимальный элемент. Понятно, что если поставить знак -, то все элементы слева от текущего будут образовывать инверсии, а справа нет. Если же мы не будем ставить знак -, то все будет наоборот. Выберем лучший вариант и вычеркнем число из массива, больше оно не будет влиять на инверсии. Теперь поймем, как считать ответ, когда максимумов больше одного. Напишем динамику dp[i][j] — сколько можно получить инверсий, когда мы рассмотрели первых i максимумов и j из них оставили положительными. Из такой динамики не сложно сделать переходы и получить ответ. И так имеем простой и короткий алгоритм:1. делаем итерации пока массив не пуст2. найдем все максимальные элементы3. с помощью динамики определим знаки, которые нужно поставить элементам4. удалим элементы из массива Для уточнения деталей решений просмотрите любое прошедшее системное тестирование решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9070",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 351\\s*C"
          },
          "content_length": 5042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 1",
          "code": "Amount required to Ceil index j - Amount required to floor index i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 2",
          "code": "= (1-A[j]) - A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 3",
          "code": "(1-A[j]) - A[i] = 1 - A[j] - A[i] = (1-A[i]) - A[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 4",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 5",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 6",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 7",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 8",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 9",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 10",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 11",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 12",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — разбор - Codeforces - Code 13",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20); // Read n\n    inf.readSpace();\n    int m = inf.readInt(1, 10000000); // Read m\n    inf.readEoln();\n    ensuref(m % 2 == 0, \"m must be even, but m = %d\", m);\n\n    vector<int> a = inf.readInts(n, 1, 10); // Read sequence a\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10); // Read sequence b\n    inf.readEoln();\n\n    inf.readEof(); // Ensure no extra input\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20); // Read n\n    inf.readSpace();\n    int m = inf.readInt(1, 10000000); // Read m\n    inf.readEoln();\n    ensuref(m % 2 == 0, \"m must be even, but m = %d\", m);\n\n    vector<int> a = inf.readInts(n, 1, 10); // Read sequence a\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10); // Read sequence b\n    inf.readEoln();\n\n    inf.readEof(); // Ensure no extra input\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20); // Read n\n    inf.readSpace();\n    int m = inf.readInt(1, 10000000); // Read m\n    inf.readEoln();\n    ensuref(m % 2 == 0, \"m must be even, but m = %d\", m);\n\n    vector<int> a = inf.readInts(n, 1, 10); // Read sequence a\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10); // Read sequence b\n    inf.readEoln();\n\n    inf.readEof(); // Ensure no extra input\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within constraints\n    if (n < 1) n = 1;\n    if (n > 20) n = 20;\n\n    // Ensure m is within constraints and even\n    if (m < 2) m = 2;\n    if (m > 10000000) m = 10000000;\n    if (m % 2 != 0) m += 1;\n\n    vector<int> a(n), b(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1,10);\n            b[i] = rnd.next(1,10);\n        }\n    } else if (type == \"ai_max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10;\n            b[i] = 1;\n        }\n    } else if (type == \"bi_max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 10;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 10;\n            b[i] = (i % 2 == 0) ? 10 : 1;\n        }\n    } else if (type == \"ai_eq_bi\") {\n        int val = rnd.next(1,10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            b[i] = val;\n        }\n    } else if (type == \"ai_less_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1,5);\n            b[i] = rnd.next(6,10);\n        }\n    } else if (type == \"ai_greater_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(6,10);\n            b[i] = rnd.next(1,5);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1,10);\n            b[i] = rnd.next(1,10);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output a[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        if (i) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Output b[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        if (i) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within constraints\n    if (n < 1) n = 1;\n    if (n > 20) n = 20;\n\n    // Ensure m is within constraints and even\n    if (m < 2) m = 2;\n    if (m > 10000000) m = 10000000;\n    if (m % 2 != 0) m += 1;\n\n    vector<int> a(n), b(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1,10);\n            b[i] = rnd.next(1,10);\n        }\n    } else if (type == \"ai_max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10;\n            b[i] = 1;\n        }\n    } else if (type == \"bi_max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 10;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 10;\n            b[i] = (i % 2 == 0) ? 10 : 1;\n        }\n    } else if (type == \"ai_eq_bi\") {\n        int val = rnd.next(1,10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            b[i] = val;\n        }\n    } else if (type == \"ai_less_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1,5);\n            b[i] = rnd.next(6,10);\n        }\n    } else if (type == \"ai_greater_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(6,10);\n            b[i] = rnd.next(1,5);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1,10);\n            b[i] = rnd.next(1,10);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output a[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        if (i) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Output b[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        if (i) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type random\n./gen -n 1 -m 2 -type ai_max\n./gen -n 1 -m 2 -type bi_max\n./gen -n 1 -m 2 -type alternating\n./gen -n 1 -m 2 -type ai_eq_bi\n./gen -n 1 -m 2 -type ai_less_bi\n./gen -n 1 -m 2 -type ai_greater_bi\n\n./gen -n 20 -m 10000000 -type random\n./gen -n 20 -m 10000000 -type ai_max\n./gen -n 20 -m 10000000 -type bi_max\n./gen -n 20 -m 10000000 -type alternating\n./gen -n 20 -m 10000000 -type ai_eq_bi\n./gen -n 20 -m 10000000 -type ai_less_bi\n./gen -n 20 -m 10000000 -type ai_greater_bi\n\n./gen -n 10 -m 1000000 -type random\n./gen -n 5 -m 5000000 -type random\n./gen -n 7 -m 100 -type ai_max\n./gen -n 7 -m 100 -type bi_max\n\n./gen -n 1 -m 10000000 -type random\n\n./gen -n 2 -m 2 -type ai_eq_bi\n\n./gen -n 5 -m 2 -type random\n./gen -n 5 -m 2 -type ai_max\n\n./gen -n 3 -m 9999998 -type bi_max\n\n./gen -n 10 -m 10000000 -type alternating\n\n./gen -n 15 -m 10000000 -type ai_eq_bi\n\n./gen -n 15 -m 5000000 -type ai_less_bi\n\n./gen -n 20 -m 9999998 -type ai_greater_bi\n\n./gen -n 20 -m 6 -type random\n\n./gen -n 1 -m 10000000 -type ai_max\n\n./gen -n 2 -m 10000000 -type bi_max\n\n./gen -n 4 -m 10000000 -type alternating\n\n./gen -n 1 -m 10000000 -type ai_eq_bi\n\n./gen -n 20 -m 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:36.986861",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "351/D",
      "title": "D. Jeff and Removing Periods",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer m (1 ≤ m ≤ 105). The next line contains m integers b1, b2, ..., bm (1 ≤ bi ≤ 105). The third line contains integer q (1 ≤ q ≤ 105) — the number of questions. The next q lines contain pairs of integers, i-th of them contains a pair of integers li, ri (1 ≤ li ≤ ri ≤ m) — the description of i-th question.",
      "output_spec": "OutputIn q lines print the answers to Jeff's queries. Print the answers according to the order of questions in input.",
      "sample_tests": "ExamplesInputCopy52 2 1 1 251 51 12 21 32 3OutputCopy21122InputCopy102 1 3 3 3 3 1 3 1 1104 82 101 104 41 32 46 71 92 51 1OutputCopy2331322321",
      "description": "D. Jeff and Removing Periods\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer m (1 ≤ m ≤ 105). The next line contains m integers b1, b2, ..., bm (1 ≤ bi ≤ 105). The third line contains integer q (1 ≤ q ≤ 105) — the number of questions. The next q lines contain pairs of integers, i-th of them contains a pair of integers li, ri (1 ≤ li ≤ ri ≤ m) — the description of i-th question.\n\nOutputIn q lines print the answers to Jeff's queries. Print the answers according to the order of questions in input.\n\nInputCopy52 2 1 1 251 51 12 21 32 3OutputCopy21122InputCopy102 1 3 3 3 3 1 3 1 1104 82 101 104 41 32 46 71 92 51 1OutputCopy2331322321\n\nInputCopy52 2 1 1 251 51 12 21 32 3\n\nOutputCopy21122\n\nInputCopy102 1 3 3 3 3 1 3 1 1104 82 101 104 41 32 46 71 92 51 1\n\nOutputCopy2331322321",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Hello everyone!Codeforces Round #204 will take place on Friday, October 4th at 19:30 MSK. This is my eights Codeforces round and I hope not the last.I'd like to thank Gerald, yvasyliv, Cenadar and Zlobober for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values for the first division: 1000-1000-1500-2000-2000.Problem point values for the second division: standart. Tutorial. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 522
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces",
          "content": "Editorial for Codeforces Round #204352A - Jeff and DigitsSolution is looking for few cases:1. If we do not have zeros, then the answer is -1.2. If we have less than 9 fives, then the answer is 0.3. Otherwise, the answer is:4. 1. The maximum number of fives divisible by 94. 2. All zeros, we have 352B - Jeff and PeriodsWe will go through the array from left to right. At each step, we will store the arrays:1. nextx — the last occurrence of the number x2. periodx — period, which occurs x3. failx — whether a time when the number of x no longer fit Now, when we get a new number we considering the case when it is the first, second or occurred more than twice.All the cases described in any past system testing solution. 351A - Jeff and RoundingInitially, we should remember the number of integers — C. On next step we will round down all numbers and count the sum. Now we can change the sum, rounding up some numbers, with those not matter what kind of, the main thing — how many. Consider a couple what we could get:1. (int, int) (c1)2. (int, double) (c2)3. (double, int) (c3)4. (double, double) (c4) Iterate over the number of pairs of the first type. Then we know the total number of second and third type and number of the fourth type:1. c2 + c3 = C - 2c12. c4 = N - (c1  +  c2  +  c3)Check to see if you can get such numbers (enough for us count of integers and real numbers, respectively). We find that we can round up from c4 to c4 + c2 + c3 numbers. We will find the best choise. 351B - Jeff and Furikote that after each step, the number of inversions in the permutation is changed by 1. Let us turn to the inversions of the permutation — let them be I pcs. It is clear that when we have one inversion, then the answer — 1. Now we will see how to use it further:1. it is clear that after a Jeff's step inversions will become lower by 12. it is clear that after a Furik's step inversions will be on 1 lowerwith porbability of 0, 5, and on 1 greater with probability of 0, 5.3. we have the formula for an answer ansI = 1 + 1 + ansI - 1 - 1 × 0.5 + ansI - 1 + 1 × 0.54. after transformation we have ansI = 4 + ansI - 2. 351C - Jeff and BracketsHow to solve the problem for small NM? Just use the dynamic programming dpi, j — minimum cost to build i first brackets with the balance j. Transfers are simple:1. dpi, j + ai + 1 -> dpi + 1, j + 12. dpi, j + bi + 1 -> dpi + 1, j - 13. we make transfers only when balance will be non-negative4. starting state dp0, 0 = 0 In this problem, we can assume that the balance will never exceed 2N. The proof is left as homework. And by using this fact problem can be done by erecting a matrix to the power:1. lets Ti, j — cost of transfer from balance i to balance j, using N brackets2. (TM)0, 0 — answer to the problem 351D - Jeff and Removing PeriodsAfter the first request we can sort the numbers and for further moves will be able to remove all occurrences of a certain number. So the answer is the number of different numbers + 1 if there is no number, occurrence of which form an arithmetic progression. Number of different numbers on a segment — standart problem, can be done O(N1.5) with offline algorithm. The problem about finding the right number will be solved in a similar algorithm:1. lets sort queries like pairs (li / 300, ri), we use integer dividing2. learn how to move from the interval (l, r) to intervals (l - 1, r), (l + 1, r), (l, r - 1), (l, r + 1) with complexcity O(1)3. by means of such an operation will move from one segment to the next, in the amount of the operation algorithm will works O(N1.5) It remains to learn how to make the change on the interval by 1 element. Such a problem can be solved quite simply:1. we craete deque for all value of numbers in array2. depending on changes in the segment will add / remove items to the start / end of the respective deque3. check whether the resulting deque is arithmetic progression. it will be homework. 351E - Jeff and PermutationWe make the zero step, replace the elements on their modules. The first thing you need to understand the way in which we will build our response. After selecting a few ways to understand the fact that initially you need to determine the sign of the largest numbers. Consider the case where the current step we have only one maximal element. It is clear that if you put a sign - all the elements on the left of this will form an inversion, while on the right there will be no inversions. If we do not put a sign - it will all be the opposite. We select the best one and cross out the number of the array, it will not affect to some inversion. Now we should understand how to read the response when the highs more than one. We write the dynamics dp[i][j] — how much inversions can you get, when we looked at the first i higest values and j from them lefted as possitive. Of these dynamics is not difficult to make the transition and get the answer. And so we have a simple and short algorithm:1. Iterates until the array is not empty2. Find all the maximal elements3. Calculate dynamics and find right signs4. Remove elements from an array For more details view any passed system tests solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9070",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 351\\s*D"
          },
          "content_length": 5147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 1",
          "code": "Amount required to Ceil index j - Amount required to floor index i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 2",
          "code": "= (1-A[j]) - A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 3",
          "code": "(1-A[j]) - A[i] = 1 - A[j] - A[i] = (1-A[i]) - A[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 4",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 5",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 6",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 7",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 8",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 9",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 10",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 11",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 12",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 13",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 1, 100000, \"b_i\");\n    inf.readEoln();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, m, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, m, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 1, 100000, \"b_i\");\n    inf.readEoln();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, m, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, m, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 1, 100000, \"b_i\");\n    inf.readEoln();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, m, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, m, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\", 1000);\n    int q = opt<int>(\"q\", 1000);\n    int maxValue = opt<int>(\"maxValue\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> b(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, maxValue);\n        }\n    } else if (type == \"all_same\") {\n        int c = rnd.next(1, maxValue);\n        for (int i = 0; i < m; ++i) {\n            b[i] = c;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = m - i;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = (i % 2) + 1;\n        }\n    } else if (type == \"one_big_rest_small\") {\n        b[0] = maxValue;\n        for (int i = 1; i < m; ++i) {\n            b[i] = rnd.next(1, min(10, maxValue));\n        }\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, min(10, maxValue));\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(max(1, maxValue - 10), maxValue);\n        }\n    } else if (type == \"worst_case\") {\n        int k = rnd.next(2, 10);\n        for (int i = 0; i < m; ++i) {\n            b[i] = (i % k) + 1;\n        }\n    } else {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, maxValue);\n        }\n    }\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < m)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    vector<pair<int, int>> queries(q);\n    if (query_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int li = rnd.next(1, m);\n            int ri = rnd.next(li, m);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (query_type == \"edge\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = make_pair(1, m);\n        }\n    } else if (query_type == \"single_element\") {\n        for (int i = 0; i < q; ++i) {\n            int pos = rnd.next(1, m);\n            queries[i] = make_pair(pos, pos);\n        }\n    } else if (query_type == \"small_ranges\") {\n        for (int i = 0; i < q; ++i) {\n            int li = rnd.next(1, m);\n            int ri = min(m, li + rnd.next(0, 10));\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (query_type == \"large_ranges\") {\n        for (int i = 0; i < q; ++i) {\n            int len = rnd.next(max(1, m - 10), m);\n            int li = rnd.next(1, m - len + 1);\n            int ri = li + len - 1;\n            queries[i] = make_pair(li, ri);\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            int li = rnd.next(1, m);\n            int ri = rnd.next(li, m);\n            queries[i] = make_pair(li, ri);\n        }\n    }\n\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\", 1000);\n    int q = opt<int>(\"q\", 1000);\n    int maxValue = opt<int>(\"maxValue\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> b(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, maxValue);\n        }\n    } else if (type == \"all_same\") {\n        int c = rnd.next(1, maxValue);\n        for (int i = 0; i < m; ++i) {\n            b[i] = c;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = m - i;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = (i % 2) + 1;\n        }\n    } else if (type == \"one_big_rest_small\") {\n        b[0] = maxValue;\n        for (int i = 1; i < m; ++i) {\n            b[i] = rnd.next(1, min(10, maxValue));\n        }\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, min(10, maxValue));\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(max(1, maxValue - 10), maxValue);\n        }\n    } else if (type == \"worst_case\") {\n        int k = rnd.next(2, 10);\n        for (int i = 0; i < m; ++i) {\n            b[i] = (i % k) + 1;\n        }\n    } else {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, maxValue);\n        }\n    }\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < m)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    vector<pair<int, int>> queries(q);\n    if (query_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int li = rnd.next(1, m);\n            int ri = rnd.next(li, m);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (query_type == \"edge\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = make_pair(1, m);\n        }\n    } else if (query_type == \"single_element\") {\n        for (int i = 0; i < q; ++i) {\n            int pos = rnd.next(1, m);\n            queries[i] = make_pair(pos, pos);\n        }\n    } else if (query_type == \"small_ranges\") {\n        for (int i = 0; i < q; ++i) {\n            int li = rnd.next(1, m);\n            int ri = min(m, li + rnd.next(0, 10));\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (query_type == \"large_ranges\") {\n        for (int i = 0; i < q; ++i) {\n            int len = rnd.next(max(1, m - 10), m);\n            int li = rnd.next(1, m - len + 1);\n            int ri = li + len - 1;\n            queries[i] = make_pair(li, ri);\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            int li = rnd.next(1, m);\n            int ri = rnd.next(li, m);\n            queries[i] = make_pair(li, ri);\n        }\n    }\n\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 5 -q 5 -maxValue 2 -type all_same -query_type edge\n./gen -m 5 -q 5 -maxValue 2 -type all_same -query_type single_element\n./gen -m 5 -q 5 -maxValue 2 -type all_same -query_type random\n\n./gen -m 10 -q 10 -maxValue 100 -type alternating -query_type random\n./gen -m 100 -q 100 -maxValue 1000 -type increasing -query_type random\n./gen -m 100 -q 100 -maxValue 1000 -type decreasing -query_type random\n\n./gen -m 1000 -q 1000 -maxValue 1000 -type random -query_type random\n./gen -m 1000 -q 1000 -maxValue 10 -type small_numbers -query_type random\n./gen -m 1000 -q 1000 -maxValue 100000 -type large_numbers -query_type random\n\n./gen -m 50000 -q 50000 -maxValue 100000 -type random -query_type random\n./gen -m 100000 -q 100000 -maxValue 100000 -type random -query_type random\n\n./gen -m 100000 -q 100000 -maxValue 100000 -type random -query_type edge\n./gen -m 100000 -q 100000 -maxValue 100000 -type random -query_type large_ranges\n./gen -m 100000 -q 100000 -maxValue 100000 -type random -query_type small_ranges\n./gen -m 100000 -q 100000 -maxValue 100000 -type random -query_type single_element\n\n./gen -m 100000 -q 100000 -maxValue 10 -type small_numbers -query_type random\n./gen -m 100000 -q 100000 -maxValue 100000 -type one_big_rest_small -query_type random\n\n./gen -m 100000 -q 100000 -maxValue 100000 -type worst_case -query_type random\n./gen -m 100000 -q 100000 -maxValue 100000 -type worst_case -query_type large_ranges\n\n./gen -m 100000 -q 10000 -maxValue 100000 -type increasing -query_type random\n./gen -m 100000 -q 10000 -maxValue 100000 -type decreasing -query_type random\n\n./gen -m 100000 -q 10000 -maxValue 100000 -type alternating -query_type random\n\n./gen -m 100000 -q 10000 -maxValue 100000 -type random -query_type random\n\n./gen -m 100000 -q 1 -maxValue 100000 -type all_same -query_type edge\n\n./gen -m 1 -q 1 -maxValue 1 -type all_same -query_type edge\n\n./gen -m 1 -q 1 -maxValue 1 -type random -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:39.408158",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "351/E",
      "title": "E. Jeff and Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2000). The next line contains n integers — sequence p1, p2, ..., pn (|pi| ≤ 105). The numbers are separated by spaces.",
      "output_spec": "OutputIn a single line print the answer to the problem — the minimum number of inversions Jeff can get.",
      "sample_tests": "ExamplesInputCopy22 1OutputCopy0InputCopy9-2 0 -1 0 -1 2 1 0 -1OutputCopy6",
      "description": "E. Jeff and Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 2000). The next line contains n integers — sequence p1, p2, ..., pn (|pi| ≤ 105). The numbers are separated by spaces.\n\nOutputIn a single line print the answer to the problem — the minimum number of inversions Jeff can get.\n\nInputCopy22 1OutputCopy0InputCopy9-2 0 -1 0 -1 2 1 0 -1OutputCopy6\n\nInputCopy22 1\n\nOutputCopy0\n\nInputCopy9-2 0 -1 0 -1 2 1 0 -1\n\nOutputCopy6",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Hello everyone!Codeforces Round #204 will take place on Friday, October 4th at 19:30 MSK. This is my eights Codeforces round and I hope not the last.I'd like to thank Gerald, yvasyliv, Cenadar and Zlobober for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values for the first division: 1000-1000-1500-2000-2000.Problem point values for the second division: standart. Tutorial. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 522
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces",
          "content": "Editorial for Codeforces Round #204352A - Jeff and DigitsSolution is looking for few cases:1. If we do not have zeros, then the answer is -1.2. If we have less than 9 fives, then the answer is 0.3. Otherwise, the answer is:4. 1. The maximum number of fives divisible by 94. 2. All zeros, we have 352B - Jeff and PeriodsWe will go through the array from left to right. At each step, we will store the arrays:1. nextx — the last occurrence of the number x2. periodx — period, which occurs x3. failx — whether a time when the number of x no longer fit Now, when we get a new number we considering the case when it is the first, second or occurred more than twice.All the cases described in any past system testing solution. 351A - Jeff and RoundingInitially, we should remember the number of integers — C. On next step we will round down all numbers and count the sum. Now we can change the sum, rounding up some numbers, with those not matter what kind of, the main thing — how many. Consider a couple what we could get:1. (int, int) (c1)2. (int, double) (c2)3. (double, int) (c3)4. (double, double) (c4) Iterate over the number of pairs of the first type. Then we know the total number of second and third type and number of the fourth type:1. c2 + c3 = C - 2c12. c4 = N - (c1  +  c2  +  c3)Check to see if you can get such numbers (enough for us count of integers and real numbers, respectively). We find that we can round up from c4 to c4 + c2 + c3 numbers. We will find the best choise. 351B - Jeff and Furikote that after each step, the number of inversions in the permutation is changed by 1. Let us turn to the inversions of the permutation — let them be I pcs. It is clear that when we have one inversion, then the answer — 1. Now we will see how to use it further:1. it is clear that after a Jeff's step inversions will become lower by 12. it is clear that after a Furik's step inversions will be on 1 lowerwith porbability of 0, 5, and on 1 greater with probability of 0, 5.3. we have the formula for an answer ansI = 1 + 1 + ansI - 1 - 1 × 0.5 + ansI - 1 + 1 × 0.54. after transformation we have ansI = 4 + ansI - 2. 351C - Jeff and BracketsHow to solve the problem for small NM? Just use the dynamic programming dpi, j — minimum cost to build i first brackets with the balance j. Transfers are simple:1. dpi, j + ai + 1 -> dpi + 1, j + 12. dpi, j + bi + 1 -> dpi + 1, j - 13. we make transfers only when balance will be non-negative4. starting state dp0, 0 = 0 In this problem, we can assume that the balance will never exceed 2N. The proof is left as homework. And by using this fact problem can be done by erecting a matrix to the power:1. lets Ti, j — cost of transfer from balance i to balance j, using N brackets2. (TM)0, 0 — answer to the problem 351D - Jeff and Removing PeriodsAfter the first request we can sort the numbers and for further moves will be able to remove all occurrences of a certain number. So the answer is the number of different numbers + 1 if there is no number, occurrence of which form an arithmetic progression. Number of different numbers on a segment — standart problem, can be done O(N1.5) with offline algorithm. The problem about finding the right number will be solved in a similar algorithm:1. lets sort queries like pairs (li / 300, ri), we use integer dividing2. learn how to move from the interval (l, r) to intervals (l - 1, r), (l + 1, r), (l, r - 1), (l, r + 1) with complexcity O(1)3. by means of such an operation will move from one segment to the next, in the amount of the operation algorithm will works O(N1.5) It remains to learn how to make the change on the interval by 1 element. Such a problem can be solved quite simply:1. we craete deque for all value of numbers in array2. depending on changes in the segment will add / remove items to the start / end of the respective deque3. check whether the resulting deque is arithmetic progression. it will be homework. 351E - Jeff and PermutationWe make the zero step, replace the elements on their modules. The first thing you need to understand the way in which we will build our response. After selecting a few ways to understand the fact that initially you need to determine the sign of the largest numbers. Consider the case where the current step we have only one maximal element. It is clear that if you put a sign - all the elements on the left of this will form an inversion, while on the right there will be no inversions. If we do not put a sign - it will all be the opposite. We select the best one and cross out the number of the array, it will not affect to some inversion. Now we should understand how to read the response when the highs more than one. We write the dynamics dp[i][j] — how much inversions can you get, when we looked at the first i higest values and j from them lefted as possitive. Of these dynamics is not difficult to make the transition and get the answer. And so we have a simple and short algorithm:1. Iterates until the array is not empty2. Find all the maximal elements3. Calculate dynamics and find right signs4. Remove elements from an array For more details view any passed system tests solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9070",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 351\\s*E"
          },
          "content_length": 5147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 1",
          "code": "Amount required to Ceil index j - Amount required to floor index i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 2",
          "code": "= (1-A[j]) - A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 3",
          "code": "(1-A[j]) - A[i] = 1 - A[j] - A[i] = (1-A[i]) - A[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 4",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 5",
          "code": "1 - A[j_1] - A[i_1]\n+1 - A[j_2] - A[i_2]\n+1 - A[j_3] - A[i_3]\nand on till\n+1 -A[j_n] - A[i_n]\n-------------------\n= n - S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 6",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 7",
          "code": "M = n-S\nfor i 1 to Min( Count(Integers in A),n ):\nans = min(ans, abs(M-i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 8",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 9",
          "code": "DP(i,j) = Minimum of \n- The ith number is Ceiled  : DP(i-1,j-1) + Amount To Ceil A[i]\n- The ith number is Floored : DP(i-1,j)   - Amount to Floor A[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 10",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 11",
          "code": "for (int i=0;i<n;i++) {\n    A;\n    B;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 12",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 — tutorial - Codeforces - Code 13",
          "code": "for (int i=0;i<n;i++)\n    A;\nfor (int i=0;i<n;i++)\n    B;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9070",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, -100000, 100000, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, -100000, 100000, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, -100000, 100000, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"all_pos\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 100000); // positive numbers from 1 to 1e5\n    } else if (type == \"all_neg\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = -rnd.next(1, 100000); // negative numbers from -1 to -1e5\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000); // numbers from -1e5 to 1e5\n    } else if (type == \"with_zero\") {\n        for(int i = 0; i < n; ++i) {\n            int choice = rnd.next(0, 2);\n            if (choice == 0) p[i] = 0;\n            else p[i] = rnd.next(-100000, 100000);\n        }\n    } else if (type == \"duplicates\") {\n        // Generate some random numbers\n        int m = max(1, n / 10); // number of distinct numbers\n        vector<int> distinct(m);\n        for(int i = 0; i < m; ++i)\n            distinct[i] = rnd.next(-100000, 100000);\n        for(int i = 0; i < n; ++i)\n            p[i] = distinct[rnd.next(0, m-1)];\n    } else if (type == \"sorted\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000);\n        sort(p.begin(), p.end());\n    } else if (type == \"reverse_sorted\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000);\n        sort(p.begin(), p.end(), greater<int>());\n    } else if (type == \"almost_sorted\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000);\n        sort(p.begin(), p.end());\n        int num_swaps = max(1, n / 10);\n        for(int i = 0; i < num_swaps; ++i) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            swap(p[idx1], p[idx2]);\n        }\n    } else if (type == \"max_inversions\") {\n        // Create a sequence with maximum inversions\n        // Let's generate a decreasing sequence\n        p[0] = 100000;\n        for(int i = 1; i < n; ++i)\n            p[i] = p[i-1] - rnd.next(1, 10);\n        // Make sure we don't go below -100000\n        for(int i = 0; i < n; ++i)\n            if (p[i] < -100000)\n                p[i] = -100000;\n    } else if (type == \"min_inversions\") {\n        // Create a sequence with minimum inversions\n        // A sorted sequence\n        p[0] = -100000;\n        for(int i = 1; i < n; ++i)\n            p[i] = p[i-1] + rnd.next(1, 10);\n        // Make sure we don't exceed 100000\n        for(int i = 0; i < n; ++i)\n            if (p[i] > 100000)\n                p[i] = 100000;\n    } else if (type == \"big_values\") {\n        for(int i = 0; i < n; ++i) {\n            int sign = rnd.next(0, 1);\n            if (sign == 0)\n                p[i] = rnd.next(90000, 100000);\n            else\n                p[i] = rnd.next(-100000, -90000);\n        }\n    } else {\n        // default is random\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], i == n-1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"all_pos\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 100000); // positive numbers from 1 to 1e5\n    } else if (type == \"all_neg\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = -rnd.next(1, 100000); // negative numbers from -1 to -1e5\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000); // numbers from -1e5 to 1e5\n    } else if (type == \"with_zero\") {\n        for(int i = 0; i < n; ++i) {\n            int choice = rnd.next(0, 2);\n            if (choice == 0) p[i] = 0;\n            else p[i] = rnd.next(-100000, 100000);\n        }\n    } else if (type == \"duplicates\") {\n        // Generate some random numbers\n        int m = max(1, n / 10); // number of distinct numbers\n        vector<int> distinct(m);\n        for(int i = 0; i < m; ++i)\n            distinct[i] = rnd.next(-100000, 100000);\n        for(int i = 0; i < n; ++i)\n            p[i] = distinct[rnd.next(0, m-1)];\n    } else if (type == \"sorted\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000);\n        sort(p.begin(), p.end());\n    } else if (type == \"reverse_sorted\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000);\n        sort(p.begin(), p.end(), greater<int>());\n    } else if (type == \"almost_sorted\") {\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000);\n        sort(p.begin(), p.end());\n        int num_swaps = max(1, n / 10);\n        for(int i = 0; i < num_swaps; ++i) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            swap(p[idx1], p[idx2]);\n        }\n    } else if (type == \"max_inversions\") {\n        // Create a sequence with maximum inversions\n        // Let's generate a decreasing sequence\n        p[0] = 100000;\n        for(int i = 1; i < n; ++i)\n            p[i] = p[i-1] - rnd.next(1, 10);\n        // Make sure we don't go below -100000\n        for(int i = 0; i < n; ++i)\n            if (p[i] < -100000)\n                p[i] = -100000;\n    } else if (type == \"min_inversions\") {\n        // Create a sequence with minimum inversions\n        // A sorted sequence\n        p[0] = -100000;\n        for(int i = 1; i < n; ++i)\n            p[i] = p[i-1] + rnd.next(1, 10);\n        // Make sure we don't exceed 100000\n        for(int i = 0; i < n; ++i)\n            if (p[i] > 100000)\n                p[i] = 100000;\n    } else if (type == \"big_values\") {\n        for(int i = 0; i < n; ++i) {\n            int sign = rnd.next(0, 1);\n            if (sign == 0)\n                p[i] = rnd.next(90000, 100000);\n            else\n                p[i] = rnd.next(-100000, -90000);\n        }\n    } else {\n        // default is random\n        for(int i = 0; i < n; ++i)\n            p[i] = rnd.next(-100000, 100000);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], i == n-1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_pos\n./gen -n 1 -type all_neg\n./gen -n 1 -type random\n\n./gen -n 2 -type duplicates\n./gen -n 2 -type with_zero\n\n./gen -n 3 -type sorted\n./gen -n 3 -type reverse_sorted\n\n./gen -n 10 -type almost_sorted\n./gen -n 10 -type max_inversions\n./gen -n 10 -type min_inversions\n\n./gen -n 100 -type all_pos\n./gen -n 100 -type all_neg\n./gen -n 100 -type duplicates\n./gen -n 100 -type with_zero\n./gen -n 100 -type big_values\n\n./gen -n 500 -type random\n./gen -n 500 -type max_inversions\n./gen -n 500 -type min_inversions\n./gen -n 500 -type duplicates\n\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reverse_sorted\n./gen -n 1000 -type almost_sorted\n./gen -n 1000 -type with_zero\n\n./gen -n 2000 -type all_pos\n./gen -n 2000 -type all_neg\n./gen -n 2000 -type random\n./gen -n 2000 -type duplicates\n./gen -n 2000 -type big_values\n./gen -n 2000 -type max_inversions\n./gen -n 2000 -type min_inversions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:41.701826",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "352/A",
      "title": "A. Jeff and Digits",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 103). The next line contains n integers a1, a2, ..., an (ai = 0 or ai = 5). Number ai represents the digit that is written on the i-th card.",
      "output_spec": "OutputIn a single line print the answer to the problem — the maximum number, divisible by 90. If you can't make any divisible by 90 number from the cards, print -1.",
      "sample_tests": "ExamplesInputCopy45 0 5 0OutputCopy0InputCopy115 5 5 5 5 5 5 5 0 5 5OutputCopy5555555550",
      "description": "A. Jeff and Digits\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 103). The next line contains n integers a1, a2, ..., an (ai = 0 or ai = 5). Number ai represents the digit that is written on the i-th card.\n\nOutputIn a single line print the answer to the problem — the maximum number, divisible by 90. If you can't make any divisible by 90 number from the cards, print -1.\n\nInputCopy45 0 5 0OutputCopy0InputCopy115 5 5 5 5 5 5 5 0 5 5OutputCopy5555555550\n\nInputCopy45 0 5 0\n\nOutputCopy0\n\nInputCopy115 5 5 5 5 5 5 5 0 5 5\n\nOutputCopy5555555550\n\nNoteIn the first test you can make only one number that is a multiple of 90 — 0.In the second test you can make number 5555555550, it is a multiple of 90.",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Hello everyone!Codeforces Round #204 will take place on Friday, October 4th at 19:30 MSK. This is my eights Codeforces round and I hope not the last.I'd like to thank Gerald, yvasyliv, Cenadar and Zlobober for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values for the first division: 1000-1000-1500-2000-2000.Problem point values for the second division: standart. Tutorial. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 522
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 5, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        ensuref(a[i] == 0 || a[i] == 5, \"Invalid digit at position %d: %d\", i + 1, a[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 5, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        ensuref(a[i] == 0 || a[i] == 5, \"Invalid digit at position %d: %d\", i + 1, a[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 5, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        ensuref(a[i] == 0 || a[i] == 5, \"Invalid digit at position %d: %d\", i + 1, a[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> digits;\n\n    if (type == \"all_zeros\") {\n        // All zeros\n        digits.assign(n, 0);\n    } else if (type == \"all_fives\") {\n        // All fives\n        digits.assign(n, 5);\n    } else if (type == \"one_zero\") {\n        // One zero, rest fives\n        if (n < 1) {\n            printf(\"1\\n0\\n\"); // Edge case\n            return 0;\n        }\n        digits.assign(n, 5);\n        digits[0] = 0;\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"one_five\") {\n        // One five, rest zeros\n        if (n < 1) {\n            printf(\"1\\n5\\n\"); // Edge case\n            return 0;\n        }\n        digits.assign(n, 0);\n        digits[0] = 5;\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"sum_divisible_by_9\") {\n        // Number of fives is a multiple of 9\n        int num_fives = (n / 9) * 9;\n        int num_zeros = n - num_fives;\n        if(num_fives == 0) {\n            // Can't make sum divisible by 9 with less than 9 fives\n            num_fives = 9;\n            num_zeros = n - num_fives;\n            if (num_zeros < 0) num_zeros = 0;\n        }\n        digits.assign(num_fives, 5);\n        digits.insert(digits.end(), num_zeros, 0);\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"sum_not_divisible_by_9\") {\n        // Number of fives is not multiple of 9\n        int num_fives = n == 0 ? 0 : rnd.next(1, n) % 9;\n        int num_zeros = n - num_fives;\n        digits.assign(num_fives, 5);\n        digits.insert(digits.end(), num_zeros, 0);\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"no_zero\") {\n        // No zeros\n        digits.assign(n, 5);\n    } else if (type == \"no_five\") {\n        // No fives\n        digits.assign(n, 0);\n    } else if (type == \"random\") {\n        // Random digits\n        digits.resize(n);\n        for(int i = 0; i < n; ++i) {\n            digits[i] = rnd.next(2) * 5; // 0 or 5\n        }\n    } else {\n        // Default to random\n        digits.resize(n);\n        for(int i = 0; i < n; ++i) {\n            digits[i] = rnd.next(2) * 5; //0 or 5\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", digits[i], i + 1 < n ? ' ' : '\\n');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> digits;\n\n    if (type == \"all_zeros\") {\n        // All zeros\n        digits.assign(n, 0);\n    } else if (type == \"all_fives\") {\n        // All fives\n        digits.assign(n, 5);\n    } else if (type == \"one_zero\") {\n        // One zero, rest fives\n        if (n < 1) {\n            printf(\"1\\n0\\n\"); // Edge case\n            return 0;\n        }\n        digits.assign(n, 5);\n        digits[0] = 0;\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"one_five\") {\n        // One five, rest zeros\n        if (n < 1) {\n            printf(\"1\\n5\\n\"); // Edge case\n            return 0;\n        }\n        digits.assign(n, 0);\n        digits[0] = 5;\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"sum_divisible_by_9\") {\n        // Number of fives is a multiple of 9\n        int num_fives = (n / 9) * 9;\n        int num_zeros = n - num_fives;\n        if(num_fives == 0) {\n            // Can't make sum divisible by 9 with less than 9 fives\n            num_fives = 9;\n            num_zeros = n - num_fives;\n            if (num_zeros < 0) num_zeros = 0;\n        }\n        digits.assign(num_fives, 5);\n        digits.insert(digits.end(), num_zeros, 0);\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"sum_not_divisible_by_9\") {\n        // Number of fives is not multiple of 9\n        int num_fives = n == 0 ? 0 : rnd.next(1, n) % 9;\n        int num_zeros = n - num_fives;\n        digits.assign(num_fives, 5);\n        digits.insert(digits.end(), num_zeros, 0);\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"no_zero\") {\n        // No zeros\n        digits.assign(n, 5);\n    } else if (type == \"no_five\") {\n        // No fives\n        digits.assign(n, 0);\n    } else if (type == \"random\") {\n        // Random digits\n        digits.resize(n);\n        for(int i = 0; i < n; ++i) {\n            digits[i] = rnd.next(2) * 5; // 0 or 5\n        }\n    } else {\n        // Default to random\n        digits.resize(n);\n        for(int i = 0; i < n; ++i) {\n            digits[i] = rnd.next(2) * 5; //0 or 5\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", digits[i], i + 1 < n ? ' ' : '\\n');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type one_zero\n./gen -n 1 -type one_five\n\n./gen -n 2 -type all_zeros\n./gen -n 2 -type all_fives\n\n./gen -n 10 -type all_zeros\n./gen -n 10 -type all_fives\n./gen -n 10 -type one_zero\n./gen -n 10 -type one_five\n./gen -n 10 -type sum_divisible_by_9\n./gen -n 10 -type sum_not_divisible_by_9\n./gen -n 10 -type no_zero\n./gen -n 10 -type no_five\n./gen -n 10 -type random\n\n./gen -n 100 -type all_zeros\n./gen -n 100 -type all_fives\n./gen -n 100 -type one_zero\n./gen -n 100 -type one_five\n./gen -n 100 -type sum_divisible_by_9\n./gen -n 100 -type sum_not_divisible_by_9\n./gen -n 100 -type no_zero\n./gen -n 100 -type no_five\n./gen -n 100 -type random\n\n./gen -n 1000 -type all_zeros\n./gen -n 1000 -type all_fives\n./gen -n 1000 -type one_zero\n./gen -n 1000 -type one_five\n./gen -n 1000 -type sum_divisible_by_9\n./gen -n 1000 -type sum_not_divisible_by_9\n./gen -n 1000 -type no_zero\n./gen -n 1000 -type no_five\n./gen -n 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:43.559520",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "352/B",
      "title": "B. Jeff and Periods",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105). The next line contains integers a1, a2, ..., an (1 ≤ ai ≤ 105). The numbers are separated by spaces.",
      "output_spec": "OutputIn the first line print integer t — the number of valid x. On each of the next t lines print two integers x and px, where x is current suitable value, px is the common difference between numbers in the progression (if x occurs exactly once in the sequence, px must equal 0). Print the pairs in the order of increasing x.",
      "sample_tests": "ExamplesInputCopy12OutputCopy12 0InputCopy81 2 1 3 1 2 1 5OutputCopy41 22 43 05 0",
      "description": "B. Jeff and Periods\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105). The next line contains integers a1, a2, ..., an (1 ≤ ai ≤ 105). The numbers are separated by spaces.\n\nOutputIn the first line print integer t — the number of valid x. On each of the next t lines print two integers x and px, where x is current suitable value, px is the common difference between numbers in the progression (if x occurs exactly once in the sequence, px must equal 0). Print the pairs in the order of increasing x.\n\nInputCopy12OutputCopy12 0InputCopy81 2 1 3 1 2 1 5OutputCopy41 22 43 05 0\n\nInputCopy12\n\nOutputCopy12 0\n\nInputCopy81 2 1 3 1 2 1 5\n\nOutputCopy41 22 43 05 0\n\nNoteIn the first test 2 occurs exactly once in the sequence, ergo p2 = 0.",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Hello everyone!Codeforces Round #204 will take place on Friday, October 4th at 19:30 MSK. This is my eights Codeforces round and I hope not the last.I'd like to thank Gerald, yvasyliv, Cenadar and Zlobober for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values for the first division: 1000-1000-1500-2000-2000.Problem point values for the second division: standart. Tutorial. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 522
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_val = opt<int>(\"max_val\", 100000);\n    \n    vector<int> a(n);\n    \n    if (type == \"all_same\") {\n        int x = rnd.next(1, max_val);\n        fill(a.begin(), a.end(), x);\n    } else if (type == \"all_distinct\") {\n        if (n > max_val) {\n            cerr << \"Cannot generate all distinct values with n > max_val\\n\";\n            return 1;\n        }\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_values\") {\n        int min_val = max(1, max_val - n + 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_val, max_val);\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_val);\n    } else if (type == \"duplicates\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, min(n / 2 + 1, max_val));\n    } else {\n        cerr << \"Unknown type: \" << type << \"\\n\";\n        return 1;\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_val = opt<int>(\"max_val\", 100000);\n    \n    vector<int> a(n);\n    \n    if (type == \"all_same\") {\n        int x = rnd.next(1, max_val);\n        fill(a.begin(), a.end(), x);\n    } else if (type == \"all_distinct\") {\n        if (n > max_val) {\n            cerr << \"Cannot generate all distinct values with n > max_val\\n\";\n            return 1;\n        }\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_values\") {\n        int min_val = max(1, max_val - n + 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_val, max_val);\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_val);\n    } else if (type == \"duplicates\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, min(n / 2 + 1, max_val));\n    } else {\n        cerr << \"Unknown type: \" << type << \"\\n\";\n        return 1;\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type all_distinct\n./gen -n 2 -type all_same\n./gen -n 2 -type all_distinct\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 10 -type all_same\n./gen -n 10 -type all_distinct\n./gen -n 100 -type random\n./gen -n 100 -type all_same\n./gen -n 100 -type all_distinct\n./gen -n 10000 -type random\n./gen -n 10000 -type all_same\n./gen -n 10000 -type all_distinct\n./gen -n 100000 -type random\n./gen -n 100000 -type all_same\n./gen -n 100000 -type duplicates\n./gen -n 100000 -type max_values -max_val 100000\n./gen -n 100000 -type random -max_val 10\n./gen -n 100000 -type random -max_val 1\n./gen -n 99999 -type all_distinct\n./gen -n 99999 -type max_values\n./gen -n 50000 -type duplicates\n./gen -n 1 -type random\n./gen -n 1 -type all_same\n./gen -n 100000 -type random -max_val 100000\n./gen -n 50000 -type random\n./gen -n 50000 -type all_same\n./gen -n 50000 -type all_distinct\n./gen -n 100000 -type random\n./gen -n 100000 -type all_distinct\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:45.858178",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "352/C",
      "title": "C. Jeff and Rounding",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2000). The next line contains 2n real numbers a1, a2, ..., a2n (0 ≤ ai ≤ 10000), given with exactly three digits after the decimal point. The numbers are separated by spaces.",
      "output_spec": "OutputIn a single line print a single real number — the required difference with exactly three digits after the decimal point.",
      "sample_tests": "ExamplesInputCopy30.000 0.500 0.750 1.000 2.000 3.000OutputCopy0.250InputCopy34469.000 6526.000 4864.000 9356.383 7490.000 995.896OutputCopy0.279",
      "description": "C. Jeff and Rounding\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 2000). The next line contains 2n real numbers a1, a2, ..., a2n (0 ≤ ai ≤ 10000), given with exactly three digits after the decimal point. The numbers are separated by spaces.\n\nOutputIn a single line print a single real number — the required difference with exactly three digits after the decimal point.\n\nInputCopy30.000 0.500 0.750 1.000 2.000 3.000OutputCopy0.250InputCopy34469.000 6526.000 4864.000 9356.383 7490.000 995.896OutputCopy0.279\n\nInputCopy30.000 0.500 0.750 1.000 2.000 3.000\n\nOutputCopy0.250\n\nInputCopy34469.000 6526.000 4864.000 9356.383 7490.000 995.896\n\nOutputCopy0.279\n\nNoteIn the first test case you need to perform the operations as follows: (i = 1, j = 4), (i = 2, j = 3), (i = 5, j = 6). In this case, the difference will equal |(0 + 0.5 + 0.75 + 1 + 2 + 3) - (0 + 0 + 1 + 1 + 2 + 3)| = 0.25.",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Hello everyone!Codeforces Round #204 will take place on Friday, October 4th at 19:30 MSK. This is my eights Codeforces round and I hope not the last.I'd like to thank Gerald, yvasyliv, Cenadar and Zlobober for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values for the first division: 1000-1000-1500-2000-2000.Problem point values for the second division: standart. Tutorial. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 522
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n\n    istringstream iss(line);\n    vector<string> tokens;\n    string token;\n\n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n\n    ensuref(int(tokens.size()) == 2 * n, \"Expected %d tokens, but found %d\", 2 * n, int(tokens.size()));\n\n    for (int i = 0; i < 2 * n; ++i) {\n        string s = tokens[i];\n        int len = s.size();\n        ensuref(len >= 5, \"a[%d] ('%s') is too short\", i + 1, s.c_str());\n        ensuref(s[len - 4] == '.', \"a[%d] ('%s') does not have '.' at the correct position\", i + 1, s.c_str());\n        ensuref(isdigit(s[len - 3]) && isdigit(s[len - 2]) && isdigit(s[len - 1]), \"a[%d] ('%s') does not have exactly three digits after the decimal point\", i + 1, s.c_str());\n\n        string int_part = s.substr(0, len - 4);\n        string frac_part = s.substr(len - 3);\n\n        // Check integer part\n        bool int_part_valid = false;\n        if (int_part == \"0\") {\n            int_part_valid = true;\n        } else if (int_part == \"10000\") {\n            ensuref(s == \"10000.000\", \"a[%d] ('%s') must be '10000.000' if integer part is '10000'\", i + 1, s.c_str());\n            int_part_valid = true;\n        } else {\n            if (int_part.size() >= 1 && int_part.size() <= 4 && int_part[0] != '0') {\n                int_part_valid = all_of(int_part.begin(), int_part.end(), ::isdigit);\n            }\n        }\n        ensuref(int_part_valid, \"a[%d] ('%s') has invalid integer part\", i + 1, s.c_str());\n\n        // Convert to double and check the bounds\n        double ai = atof(s.c_str());\n        ensuref(0.0 <= ai && ai <= 10000.0, \"a[%d] (%f) is not in [0, 10000]\", i + 1, ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n\n    istringstream iss(line);\n    vector<string> tokens;\n    string token;\n\n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n\n    ensuref(int(tokens.size()) == 2 * n, \"Expected %d tokens, but found %d\", 2 * n, int(tokens.size()));\n\n    for (int i = 0; i < 2 * n; ++i) {\n        string s = tokens[i];\n        int len = s.size();\n        ensuref(len >= 5, \"a[%d] ('%s') is too short\", i + 1, s.c_str());\n        ensuref(s[len - 4] == '.', \"a[%d] ('%s') does not have '.' at the correct position\", i + 1, s.c_str());\n        ensuref(isdigit(s[len - 3]) && isdigit(s[len - 2]) && isdigit(s[len - 1]), \"a[%d] ('%s') does not have exactly three digits after the decimal point\", i + 1, s.c_str());\n\n        string int_part = s.substr(0, len - 4);\n        string frac_part = s.substr(len - 3);\n\n        // Check integer part\n        bool int_part_valid = false;\n        if (int_part == \"0\") {\n            int_part_valid = true;\n        } else if (int_part == \"10000\") {\n            ensuref(s == \"10000.000\", \"a[%d] ('%s') must be '10000.000' if integer part is '10000'\", i + 1, s.c_str());\n            int_part_valid = true;\n        } else {\n            if (int_part.size() >= 1 && int_part.size() <= 4 && int_part[0] != '0') {\n                int_part_valid = all_of(int_part.begin(), int_part.end(), ::isdigit);\n            }\n        }\n        ensuref(int_part_valid, \"a[%d] ('%s') has invalid integer part\", i + 1, s.c_str());\n\n        // Convert to double and check the bounds\n        double ai = atof(s.c_str());\n        ensuref(0.0 <= ai && ai <= 10000.0, \"a[%d] (%f) is not in [0, 10000]\", i + 1, ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n\n    istringstream iss(line);\n    vector<string> tokens;\n    string token;\n\n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n\n    ensuref(int(tokens.size()) == 2 * n, \"Expected %d tokens, but found %d\", 2 * n, int(tokens.size()));\n\n    for (int i = 0; i < 2 * n; ++i) {\n        string s = tokens[i];\n        int len = s.size();\n        ensuref(len >= 5, \"a[%d] ('%s') is too short\", i + 1, s.c_str());\n        ensuref(s[len - 4] == '.', \"a[%d] ('%s') does not have '.' at the correct position\", i + 1, s.c_str());\n        ensuref(isdigit(s[len - 3]) && isdigit(s[len - 2]) && isdigit(s[len - 1]), \"a[%d] ('%s') does not have exactly three digits after the decimal point\", i + 1, s.c_str());\n\n        string int_part = s.substr(0, len - 4);\n        string frac_part = s.substr(len - 3);\n\n        // Check integer part\n        bool int_part_valid = false;\n        if (int_part == \"0\") {\n            int_part_valid = true;\n        } else if (int_part == \"10000\") {\n            ensuref(s == \"10000.000\", \"a[%d] ('%s') must be '10000.000' if integer part is '10000'\", i + 1, s.c_str());\n            int_part_valid = true;\n        } else {\n            if (int_part.size() >= 1 && int_part.size() <= 4 && int_part[0] != '0') {\n                int_part_valid = all_of(int_part.begin(), int_part.end(), ::isdigit);\n            }\n        }\n        ensuref(int_part_valid, \"a[%d] ('%s') has invalid integer part\", i + 1, s.c_str());\n\n        // Convert to double and check the bounds\n        double ai = atof(s.c_str());\n        ensuref(0.0 <= ai && ai <= 10000.0, \"a[%d] (%f) is not in [0, 10000]\", i + 1, ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int total_n = n * 2;\n    vector<double> a(total_n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(0.0, 10000.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0; // Round to 3 decimal places\n        }\n    } else if (type == \"integers\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(0, 10000);\n        }\n    } else if (type == \"small\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(0.0, 1.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0;\n        }\n    } else if (type == \"large\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(9999.0, 10000.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0;\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = 0.0;\n        }\n    } else if (type == \"one_zero\") {\n        a[0] = 0.0;\n        for (int i = 1; i < total_n; ++i) {\n            a[i] = rnd.next(0.0, 10000.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0;\n        }\n    } else if (type == \"close_to_int_down\") {\n        for (int i = 0; i < total_n; ++i) {\n            int integer_part = rnd.next(1, 10000);\n            a[i] = integer_part - 0.001;\n            if (a[i] < 0.0) a[i] = 0.0;\n        }\n    } else if (type == \"close_to_int_up\") {\n        for (int i = 0; i < total_n; ++i) {\n            int integer_part = rnd.next(0, 9999);\n            a[i] = integer_part + 0.999;\n            if (a[i] > 10000.0) a[i] = 10000.0;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < total_n; ++i) {\n            int integer_part = rnd.next(0, 9999);\n            if (i % 2 == 0) {\n                a[i] = integer_part + 0.001;\n            } else {\n                a[i] = integer_part + 0.999;\n                if (a[i] > 10000.0) a[i] = 10000.0;\n            }\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(0.0, 10000.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0; // Round to 3 decimal places\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a[0..total_n - 1] with exactly three digits after the decimal point\n    for (int i = 0; i < total_n; ++i) {\n        printf(\"%.3f\", a[i]);\n        if (i + 1 < total_n) \n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int total_n = n * 2;\n    vector<double> a(total_n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(0.0, 10000.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0; // Round to 3 decimal places\n        }\n    } else if (type == \"integers\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(0, 10000);\n        }\n    } else if (type == \"small\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(0.0, 1.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0;\n        }\n    } else if (type == \"large\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(9999.0, 10000.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0;\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = 0.0;\n        }\n    } else if (type == \"one_zero\") {\n        a[0] = 0.0;\n        for (int i = 1; i < total_n; ++i) {\n            a[i] = rnd.next(0.0, 10000.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0;\n        }\n    } else if (type == \"close_to_int_down\") {\n        for (int i = 0; i < total_n; ++i) {\n            int integer_part = rnd.next(1, 10000);\n            a[i] = integer_part - 0.001;\n            if (a[i] < 0.0) a[i] = 0.0;\n        }\n    } else if (type == \"close_to_int_up\") {\n        for (int i = 0; i < total_n; ++i) {\n            int integer_part = rnd.next(0, 9999);\n            a[i] = integer_part + 0.999;\n            if (a[i] > 10000.0) a[i] = 10000.0;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < total_n; ++i) {\n            int integer_part = rnd.next(0, 9999);\n            if (i % 2 == 0) {\n                a[i] = integer_part + 0.001;\n            } else {\n                a[i] = integer_part + 0.999;\n                if (a[i] > 10000.0) a[i] = 10000.0;\n            }\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < total_n; ++i) {\n            a[i] = rnd.next(0.0, 10000.0);\n            a[i] = floor(a[i] * 1000 + 0.5) / 1000.0; // Round to 3 decimal places\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a[0..total_n - 1] with exactly three digits after the decimal point\n    for (int i = 0; i < total_n; ++i) {\n        printf(\"%.3f\", a[i]);\n        if (i + 1 < total_n) \n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type integers\n./gen -n 1 -type small\n./gen -n 1 -type large\n./gen -n 1 -type random\n./gen -n 1 -type close_to_int_down\n./gen -n 1 -type close_to_int_up\n./gen -n 1 -type alternating\n\n./gen -n 10 -type zeros\n./gen -n 10 -type integers\n./gen -n 10 -type small\n./gen -n 10 -type large\n./gen -n 10 -type random\n./gen -n 10 -type close_to_int_down\n./gen -n 10 -type close_to_int_up\n./gen -n 10 -type alternating\n\n./gen -n 100 -type zeros\n./gen -n 100 -type integers\n./gen -n 100 -type small\n./gen -n 100 -type large\n./gen -n 100 -type random\n./gen -n 100 -type close_to_int_down\n./gen -n 100 -type close_to_int_up\n./gen -n 100 -type alternating\n\n./gen -n 1000 -type zeros\n./gen -n 1000 -type integers\n./gen -n 1000 -type small\n./gen -n 1000 -type large\n./gen -n 1000 -type random\n./gen -n 1000 -type close_to_int_down\n./gen -n 1000 -type close_to_int_up\n./gen -n 1000 -type alternating\n\n./gen -n 2000 -type zeros\n./gen -n 2000 -type integers\n./gen -n 2000 -type small\n./gen -n 2000 -type large\n./gen -n 2000 -type random\n./gen -n 2000 -type close_to_int_down\n./gen -n 2000 -type close_to_int_up\n./gen -n 2000 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:47.809879",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "352/D",
      "title": "D. Джефф и Фурик",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 3000). Следующая строка содержит n различных целых чисел p1, p2, ..., pn (1 ≤ pi ≤ n) — перестановка p. Числа разделены пробелами.",
      "output_spec": "Выходные данныеВ единственную строку выведите вещественное число — ответ на задачу. Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать21 2Выходные данныеСкопировать0.000000Входные данныеСкопировать53 5 2 4 1Выходные данныеСкопировать13.000000",
      "description": "D. Джефф и Фурик\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 3000). Следующая строка содержит n различных целых чисел p1, p2, ..., pn (1 ≤ pi ≤ n) — перестановка p. Числа разделены пробелами.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите вещественное число — ответ на задачу. Ответ будет считаться правильным, если его абсолютная или относительная погрешность не превышает 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать21 2Выходные данныеСкопировать0.000000Входные данныеСкопировать53 5 2 4 1Выходные данныеСкопировать13.000000\n\nВходные данныеСкопировать21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать53 5 2 4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13.000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте последовательность уже отсортирована, следовательно — ответ 0.",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Всем привет!Совсем скоро, 4 октября в 19:30 MSK состоится Codeforces Round #204, автором которого являюсь я. Это мой восьмой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald), Евгену Василиву(yvasyliv), Максиму Бевзе(Cenadar) и Максиму Ахмедову(Zlobober) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе: 1000-1000-1500-2000-2000.Разбалловка во втором дивизионе: стандарт. Разбор. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 551
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n);\n    inf.readEoln();\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All p_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n);\n    inf.readEoln();\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All p_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n);\n    inf.readEoln();\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All p_i must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the correct answer from the jury's output\n    double juryAnswer = ans.readDouble();\n\n    // Read the participant's answer\n    double participantAnswer = ouf.readDouble();\n\n    // Calculate the absolute and relative errors\n    double absoluteError = fabs(juryAnswer - participantAnswer);\n    double relativeError = fabs(juryAnswer) > 1E-9 ? absoluteError / fabs(juryAnswer) : 0;\n\n    // Check if either the absolute or relative error is within the acceptable range\n    if (absoluteError <= EPS || relativeError <= EPS) {\n        quitf(_ok, \"Answer is correct.\");\n    } else {\n        quitf(_wa, \"The absolute error %.10f or relative error %.10f exceeds the acceptable limit %.10f.\", absoluteError, relativeError, EPS);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 1); // initialize with 1..n\n\n    if (type == \"sorted\") {\n        // perm is already sorted\n    } else if (type == \"reversed\") {\n        reverse(perm.begin(), perm.end());\n    } else if (type == \"almost_sorted\") {\n        // Swap two random elements\n        int i = rnd.next(n);\n        int j = rnd.next(n);\n        if (i != j) swap(perm[i], perm[j]);\n    } else if (type == \"few_swaps\") {\n        // Make a permutation that requires few swaps to sort\n        for(int i = 0; i < n/10; ++i) {\n            int index = rnd.next(1, n-1);\n            swap(perm[index], perm[index-1]);\n        }\n    } else if (type == \"alternating\") {\n        // Create an alternating high-low pattern\n        vector<int> low, high;\n        for(int i = 1; i <= n; ++i) {\n            if (i <= n/2)\n                low.push_back(i);\n            else\n                high.push_back(i);\n        }\n        perm.clear();\n        int idx_low = 0, idx_high = 0;\n        while (idx_low < low.size() && idx_high < high.size()) {\n            perm.push_back(high[idx_high++]);\n            perm.push_back(low[idx_low++]);\n        }\n        while (idx_high < high.size())\n            perm.push_back(high[idx_high++]);\n        while (idx_low < low.size())\n            perm.push_back(low[idx_low++]);\n    } else if (type == \"worst_case\") {\n        // Reverse sorted permutation may cause the worst expected number of moves\n        reverse(perm.begin(), perm.end());\n    } else {\n        // Generate a random permutation\n        shuffle(perm.begin(), perm.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the permutation\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", perm[i], (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 1); // initialize with 1..n\n\n    if (type == \"sorted\") {\n        // perm is already sorted\n    } else if (type == \"reversed\") {\n        reverse(perm.begin(), perm.end());\n    } else if (type == \"almost_sorted\") {\n        // Swap two random elements\n        int i = rnd.next(n);\n        int j = rnd.next(n);\n        if (i != j) swap(perm[i], perm[j]);\n    } else if (type == \"few_swaps\") {\n        // Make a permutation that requires few swaps to sort\n        for(int i = 0; i < n/10; ++i) {\n            int index = rnd.next(1, n-1);\n            swap(perm[index], perm[index-1]);\n        }\n    } else if (type == \"alternating\") {\n        // Create an alternating high-low pattern\n        vector<int> low, high;\n        for(int i = 1; i <= n; ++i) {\n            if (i <= n/2)\n                low.push_back(i);\n            else\n                high.push_back(i);\n        }\n        perm.clear();\n        int idx_low = 0, idx_high = 0;\n        while (idx_low < low.size() && idx_high < high.size()) {\n            perm.push_back(high[idx_high++]);\n            perm.push_back(low[idx_low++]);\n        }\n        while (idx_high < high.size())\n            perm.push_back(high[idx_high++]);\n        while (idx_low < low.size())\n            perm.push_back(low[idx_low++]);\n    } else if (type == \"worst_case\") {\n        // Reverse sorted permutation may cause the worst expected number of moves\n        reverse(perm.begin(), perm.end());\n    } else {\n        // Generate a random permutation\n        shuffle(perm.begin(), perm.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the permutation\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", perm[i], (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type sorted\n./gen -n 2 -type sorted\n./gen -n 2 -type reversed\n./gen -n 2 -type random\n./gen -n 5 -type sorted\n./gen -n 5 -type reversed\n./gen -n 5 -type random\n./gen -n 5 -type almost_sorted\n./gen -n 5 -type few_swaps\n./gen -n 5 -type alternating\n\n./gen -n 10 -type sorted\n./gen -n 10 -type reversed\n./gen -n 10 -type random\n./gen -n 10 -type almost_sorted\n./gen -n 10 -type few_swaps\n./gen -n 10 -type alternating\n\n./gen -n 100 -type sorted\n./gen -n 100 -type reversed\n./gen -n 100 -type random\n./gen -n 100 -type almost_sorted\n./gen -n 100 -type few_swaps\n./gen -n 100 -type alternating\n\n./gen -n 500 -type sorted\n./gen -n 500 -type reversed\n./gen -n 500 -type random\n./gen -n 500 -type almost_sorted\n./gen -n 500 -type few_swaps\n./gen -n 500 -type alternating\n\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reversed\n./gen -n 1000 -type random\n./gen -n 1000 -type almost_sorted\n./gen -n 1000 -type few_swaps\n./gen -n 1000 -type alternating\n\n./gen -n 3000 -type sorted\n./gen -n 3000 -type reversed\n./gen -n 3000 -type random\n./gen -n 3000 -type almost_sorted\n./gen -n 3000 -type few_swaps\n./gen -n 3000 -type alternating\n./gen -n 3000 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:49.790561",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "352/E",
      "title": "E. Jeff and Brackets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 20; 1 ≤ m ≤ 107; m is even). The next line contains n integers: a0, a1, ..., an - 1 (1 ≤ ai ≤ 10). The next line contains n integers: b0, b1, ..., bn - 1 (1 ≤ bi ≤ 10). The numbers are separated by spaces.",
      "output_spec": "OutputIn a single line print the answer to the problem — the minimum required amount of ink in liters.",
      "sample_tests": "ExamplesInputCopy2 61 22 1OutputCopy12InputCopy1 1000000023OutputCopy25000000",
      "description": "E. Jeff and Brackets\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 20; 1 ≤ m ≤ 107; m is even). The next line contains n integers: a0, a1, ..., an - 1 (1 ≤ ai ≤ 10). The next line contains n integers: b0, b1, ..., bn - 1 (1 ≤ bi ≤ 10). The numbers are separated by spaces.\n\nOutputIn a single line print the answer to the problem — the minimum required amount of ink in liters.\n\nInputCopy2 61 22 1OutputCopy12InputCopy1 1000000023OutputCopy25000000\n\nInputCopy2 61 22 1\n\nOutputCopy12\n\nInputCopy1 1000000023\n\nOutputCopy25000000\n\nNoteIn the first test the optimal sequence is: ()()()()()(), the required number of ink liters is 12.",
      "solutions": [
        {
          "title": "Codeforces Round #204 - Codeforces",
          "content": "Hello everyone!Codeforces Round #204 will take place on Friday, October 4th at 19:30 MSK. This is my eights Codeforces round and I hope not the last.I'd like to thank Gerald, yvasyliv, Cenadar and Zlobober for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values for the first division: 1000-1000-1500-2000-2000.Problem point values for the second division: standart. Tutorial. Gl & hf ! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9056",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 522
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #204 - Codeforces - Code 1",
          "code": "0.000 0.500 0.750 1.000 2.000 3.000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 2",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 3",
          "code": "String line=sc.next();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 4",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 5",
          "code": "for(int i=0;i<n;i++)\n        {\n            if(line.charAt(i)=='5') f++;\n            else z++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 6",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 7",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first<j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 8",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #204 - Codeforces - Code 9",
          "code": "bool f(pii i, pii j)\n{\n\treturn (i.first<j.first)||((i.first==j.first)&&(i.second<j.second));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9056",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000000, \"m\");\n    inf.readEoln();\n\n    ensuref(m % 2 == 0, \"m must be even, but m=%d\", m);\n\n    vector<int> a = inf.readInts(n, 1, 10, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000000, \"m\");\n    inf.readEoln();\n\n    ensuref(m % 2 == 0, \"m must be even, but m=%d\", m);\n\n    vector<int> a = inf.readInts(n, 1, 10, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000000, \"m\");\n    inf.readEoln();\n\n    ensuref(m % 2 == 0, \"m must be even, but m=%d\", m);\n\n    vector<int> a = inf.readInts(n, 1, 10, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 20);\n    ensure(1 <= m && m <= int(1e7));\n    ensure(m % 2 == 0);\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n            b[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10;\n            b[i] = 10;\n        }\n    } else if (type == \"equal\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = b[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"asc\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 10 + 1;\n            b[i] = a[i];\n        }\n    } else if (type == \"desc\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10 - (i % 10);\n            b[i] = a[i];\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 10;\n            b[i] = (i % 2 == 0) ? 10 : 1;\n        }\n    } else if (type == \"ai_less_than_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 5);\n            b[i] = rnd.next(6, 10);\n        }\n    } else if (type == \"ai_greater_than_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(6, 10);\n            b[i] = rnd.next(1, 5);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n            b[i] = rnd.next(1, 10);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 20);\n    ensure(1 <= m && m <= int(1e7));\n    ensure(m % 2 == 0);\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n            b[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10;\n            b[i] = 10;\n        }\n    } else if (type == \"equal\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = b[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"asc\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 10 + 1;\n            b[i] = a[i];\n        }\n    } else if (type == \"desc\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10 - (i % 10);\n            b[i] = a[i];\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 10;\n            b[i] = (i % 2 == 0) ? 10 : 1;\n        }\n    } else if (type == \"ai_less_than_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 5);\n            b[i] = rnd.next(6, 10);\n        }\n    } else if (type == \"ai_greater_than_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(6, 10);\n            b[i] = rnd.next(1, 5);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n            b[i] = rnd.next(1, 10);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type min\n./gen -n 1 -m 10000000 -type min\n./gen -n 1 -m 2 -type max\n./gen -n 1 -m 10000000 -type max\n./gen -n 1 -m 2 -type random\n./gen -n 1 -m 10000000 -type random\n./gen -n 1 -m 2 -type equal\n./gen -n 1 -m 10000000 -type equal\n\n./gen -n 20 -m 2 -type min\n./gen -n 20 -m 10000000 -type min\n./gen -n 20 -m 2 -type max\n./gen -n 20 -m 10000000 -type max\n./gen -n 20 -m 2 -type random\n./gen -n 20 -m 10000000 -type random\n./gen -n 20 -m 2 -type equal\n./gen -n 20 -m 10000000 -type equal\n\n./gen -n 10 -m 5000000 -type random\n./gen -n 5 -m 10000000 -type asc\n./gen -n 15 -m 10000000 -type desc\n./gen -n 20 -m 9999998 -type alternating\n./gen -n 20 -m 9999998 -type ai_less_than_bi\n./gen -n 20 -m 9999998 -type ai_greater_than_bi\n./gen -n 3 -m 10 -type random\n./gen -n 4 -m 10 -type random\n./gen -n 5 -m 10 -type random\n./gen -n 6 -m 10 -type random\n./gen -n 7 -m 10 -type random\n\n# Edge cases\n./gen -n 1 -m 2 -type random\n./gen -n 20 -m 2 -type random\n./gen -n 1 -m 10000000 -type random\n./gen -n 20 -m 10000000 -type random\n\n# m not a multiple of n\n./gen -n 3 -m 9999996 -type random\n./gen -n 4 -m 9999998 -type random\n./gen -n 5 -m 9999990 -type random\n\n# m is minimal\n./gen -n 5 -m 2 -type random\n./gen -n 20 -m 2 -type random\n\n# Maximize ai and minimize bi to challenge DP\n./gen -n 20 -m 10000000 -type ai_greater_than_bi\n\n# Minimize ai and maximize bi to challenge DP in the opposite way\n./gen -n 20 -m 10000000 -type ai_less_than_bi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:51.566538",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "353/A",
      "title": "A. Domino",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100), denoting the number of dominoes Valera has. Next n lines contain two space-separated integers xi, yi (1 ≤ xi, yi ≤ 6). Number xi is initially written on the upper half of the i-th domino, yi is initially written on the lower half.",
      "output_spec": "OutputPrint a single number — the minimum required number of seconds. If Valera can't do the task in any time, print  - 1.",
      "sample_tests": "ExamplesInputCopy24 26 4OutputCopy0InputCopy12 3OutputCopy-1InputCopy31 42 34 4OutputCopy1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 100), denoting the number of dominoes Valera has. Next n lines contain two space-separated integers xi, yi (1 ≤ xi, yi ≤ 6). Number xi is initially written on the upper half of the i-th domino, yi is initially written on the lower half.\n\nOutputPrint a single number — the minimum required number of seconds. If Valera can't do the task in any time, print  - 1.\n\nInputCopy24 26 4OutputCopy0InputCopy12 3OutputCopy-1InputCopy31 42 34 4OutputCopy1\n\nInputCopy24 26 4\n\nOutputCopy0\n\nInputCopy12 3\n\nOutputCopy-1\n\nInputCopy31 42 34 4\n\nOutputCopy1\n\nNoteIn the first test case the sum of the numbers on the upper halves equals 10 and the sum of the numbers on the lower halves equals 6. Both numbers are even, so Valera doesn't required to do anything.In the second sample Valera has only one piece of domino. It is written 3 on the one of its halves, therefore one of the sums will always be odd.In the third case Valera can rotate the first piece, and after that the sum on the upper halves will be equal to 10, and the sum on the lower halves will be equal to 8.",
      "solutions": [
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #205 for participants from 2 division will take place today. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: It is decided to use dynamic scoring system.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: hos_epic gzh1996n I_LOVE_ELE UPD 3: you can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 680
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #205 for participants from 2 division will take place today. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: It is decided to use dynamic scoring system.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: hos_epic gzh1996n I_LOVE_ELE UPD 3: you can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 680
        },
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces",
          "content": "353A - DominoLet's denote the sum of numbers on the upper halves of pieces as s1, and the sum on the lower halves — s2. If this sums are even, than the answer is obviously 0. Note, that if the numbers on both halves of piece have the same parity, than parity of s1 and s2 won't change after rotation this piece. If the numbers on halves have different parity, than parities of both s1 and s2 will change after rotation. Therefore, if s1 and s2 have different parities, than the answer is  - 1. If both s1 and s2 are odd, than we should check, if there is a piece with numbers of different parities. If so, the answer is 1, otherwise, the answer is  - 1.353B - Two HeapsLet's say for shortness, that we put numbers, that are painted on cubes, in piles, instead of cubes themselves.Note, that the answer is the product of c1... c2, where ci is the number of different numbers in the i-th pile. Let's consider that all numbers are different. In this case the answer is n2. Now, let's suppose that we have two equal numbers and all the other are different. Then, if we put them in different piles, the answer will be n2, but if we put them in one — n·(n - 1). Obviously, the first case give greater product.Thinking in similar manner, you can conclude, that we should do the following. Take numbers, that appear more than once, and put one of them in the first pile, one of them in the second pile and the other put aside. After that, divide the numbers, that appears once, in two equal part and put the first part in the first pile and second part in the second pile. Finally, take the numbers, that we put aside, and separate them in two pile in any kind.353C - Find MaximumLet's see on the highest bit of m. If it equals to zero, than for any there is a zero on the (n - 1)-th position, so an - 1 doesn't affect the answer and we can put it aside and find the answer for smaller number of elements.If the highest bit of m equals to 1, than an - 1 for some x will present in f(x), but for some will not. Let's consider such x, that a{n - 1} will present in f(x) with zero coefficient. It is obvious that . In this case f(x) will have maximum value when x = 2n - 1 - 1. Try to update the answer by this value.Now we should analyze the case, when , find the maximum value of f(x) for all such x and try to update the answer by this value. Let's note, that in all such x there is 1 in (n - 1)-th position. Therefore we can find the maximum value of f(y) for all and add an - 1 to it.353D - QueueNote that if there are some girls in the begining of the line, they will never move. So let's remove them and will consider that the first schoolchildren in the line is a boy. Also note, the relative order of the girls doesn't change. Let's calculate for each girl such moment of time ti, that after it she won't move forever. Note, that for i-th girl ti ≥ ti - 1. Let's calculate ti in order from left to right. Let's denote yi is the position in the line where i-th girl will stop, ans xi is her current position. Therefore it is needed xi - yi second for girl to reach her finish position. So if xi - yi > ti - 1, then ti = xi - yi. Let's manage the case when xi - yi ≤ ti. The girl with number (i - 1) will be on yi-th position by ti - 1-th second, so ti ≥ ti - 1 + 1. Let's consider such moment of time p, when i-th girl stand right after (i - 1)-th, but not on yi-th position. After that, in (p + 1)-th moment of time (i - 1)-th girl and the boy standing in front of her will swap their positions, but i-th girl will save her position. Then since p + 2-th second till ti - 1 both girls will change their positions. Finally, at (ti - 1 + 1) - th second i-th girl will occupy her position. Therefore, ti = ti - 1 + 1 in this case.353E - AntichainLet's divide our graph on chains. Denote chain as the maximal sequence of the edges, which have the same direction. If there are more than 2 edges in each chain, then the answer is the number of such chains.If there is a chain containing only one edge (u, v), then brute vertex, which we will take in maximal antichain (also consider the case, when we take none of them). Let's suppose we brute the vertex v. After that we put aside this vertex and all vertices, which is comparable with v. In received graph we can find the size of the maximal antichain by uning dynamic programming with O(n) time complexity. Let's show how to do this.Write all remaining vertices in line and renumerate them from left to right by the numbers from 1 to k. After that we are going to calculate di — the size of the maximal antichain among vertices with numbers j ≥ i. So if i > k, then di = 0. In other case we can skip i-th vertex and try to update di by the value of di + 1. Also we can try to take i-th vertex to the answer. In this case we should skip all vertices, that are reachable from i-th, or the vertices, from which we can reach i-th, take the answer from the next vertex, add 1 to it and try to update the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 353\\s*A"
          },
          "content_length": 4950
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "T(i) = max(T(i-1) + 1, dist(i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "T(lastGirl)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 6, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 6, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 6, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 6, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 6, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 6, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"even_sum\");\n\n    vector<int> xi(n), yi(n);\n    \n    if (type == \"even_sum\") {\n        // Generate xi and yi such that S_upper and S_lower are both even\n        int S_upper = 0, S_lower = 0;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1,6);\n            yi[i] = rnd.next(1,6);\n            S_upper += xi[i];\n            S_lower += yi[i];\n        }\n        // Adjust sums to be even\n        if (S_upper %2 != 0) {\n            xi[0] ^= 1; // Flip parity of xi[0] within 1..6\n            S_upper = S_upper - xi[0] + xi[0];\n        }\n        if (S_lower %2 !=0) {\n            yi[0] ^= 1; // Flip parity of yi[0] within 1..6\n            S_lower = S_lower - yi[0] + yi[0];\n        }\n    } else if (type == \"odd_sum_one_swap_possible\") {\n        // Generate xi and yi such that S_upper and S_lower are both odd\n        int S_upper = 0, S_lower = 0;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1,6);\n            yi[i] = rnd.next(1,6);\n            S_upper += xi[i];\n            S_lower += yi[i];\n        }\n        // Adjust sums to be odd\n        if (S_upper %2 == 0) {\n            xi[0] ^= 1;\n            S_upper = S_upper - xi[0] + xi[0];\n        }\n        if (S_lower %2 == 0) {\n            yi[0] ^= 1;\n            S_lower = S_lower - yi[0] + yi[0];\n        }\n        // Ensure there is at least one domino where xi and yi have different parity\n        bool found = false;\n        for (int i = 0; i < n; ++i) {\n            if ((xi[i] %2) != (yi[i]%2)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            xi[0] ^= 1;\n        }\n    } else if (type == \"odd_sum_no_swap_possible\") {\n        // Generate xi and yi such that S_upper and S_lower are both odd, xi[i] and yi[i] have same parity\n        int S_upper = 0, S_lower = 0;\n        for (int i = 0; i < n; ++i) {\n            int parity = rnd.next(0,1)*2; // 0 or 2\n            xi[i] = rnd.next(1,3)*2 - 1 + parity; // 1 or 3 or 5\n            yi[i] = rnd.next(1,3)*2 - 1 + parity;\n            S_upper += xi[i];\n            S_lower += yi[i];\n        }\n        // Adjust sums to be odd\n        if (S_upper %2 == 0) {\n            xi[0] ^= 1;\n            S_upper = S_upper - xi[0] + xi[0];\n        }\n        if (S_lower %2 == 0) {\n            yi[0] ^=1;\n            S_lower = S_lower - yi[0] + yi[0];\n        }\n    } else if (type == \"different_parity_sums\") {\n        // Generate xi and yi such that S_upper and S_lower have different parity\n        int S_upper = 0, S_lower = 0;\n        for (int i = 0; i < n; ++i){\n            xi[i] = rnd.next(1,6);\n            yi[i] = rnd.next(1,6);\n            S_upper += xi[i];\n            S_lower += yi[i];\n        }\n        // Adjust to make parities different\n        if ( (S_upper%2)==(S_lower%2) ) {\n            xi[0] ^= 1;\n            S_upper = S_upper - xi[0] + xi[0];\n        }\n    } else {\n        // Default random case\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1,6);\n            yi[i] = rnd.next(1,6);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xi[i], yi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"even_sum\");\n\n    vector<int> xi(n), yi(n);\n    \n    if (type == \"even_sum\") {\n        // Generate xi and yi such that S_upper and S_lower are both even\n        int S_upper = 0, S_lower = 0;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1,6);\n            yi[i] = rnd.next(1,6);\n            S_upper += xi[i];\n            S_lower += yi[i];\n        }\n        // Adjust sums to be even\n        if (S_upper %2 != 0) {\n            xi[0] ^= 1; // Flip parity of xi[0] within 1..6\n            S_upper = S_upper - xi[0] + xi[0];\n        }\n        if (S_lower %2 !=0) {\n            yi[0] ^= 1; // Flip parity of yi[0] within 1..6\n            S_lower = S_lower - yi[0] + yi[0];\n        }\n    } else if (type == \"odd_sum_one_swap_possible\") {\n        // Generate xi and yi such that S_upper and S_lower are both odd\n        int S_upper = 0, S_lower = 0;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1,6);\n            yi[i] = rnd.next(1,6);\n            S_upper += xi[i];\n            S_lower += yi[i];\n        }\n        // Adjust sums to be odd\n        if (S_upper %2 == 0) {\n            xi[0] ^= 1;\n            S_upper = S_upper - xi[0] + xi[0];\n        }\n        if (S_lower %2 == 0) {\n            yi[0] ^= 1;\n            S_lower = S_lower - yi[0] + yi[0];\n        }\n        // Ensure there is at least one domino where xi and yi have different parity\n        bool found = false;\n        for (int i = 0; i < n; ++i) {\n            if ((xi[i] %2) != (yi[i]%2)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            xi[0] ^= 1;\n        }\n    } else if (type == \"odd_sum_no_swap_possible\") {\n        // Generate xi and yi such that S_upper and S_lower are both odd, xi[i] and yi[i] have same parity\n        int S_upper = 0, S_lower = 0;\n        for (int i = 0; i < n; ++i) {\n            int parity = rnd.next(0,1)*2; // 0 or 2\n            xi[i] = rnd.next(1,3)*2 - 1 + parity; // 1 or 3 or 5\n            yi[i] = rnd.next(1,3)*2 - 1 + parity;\n            S_upper += xi[i];\n            S_lower += yi[i];\n        }\n        // Adjust sums to be odd\n        if (S_upper %2 == 0) {\n            xi[0] ^= 1;\n            S_upper = S_upper - xi[0] + xi[0];\n        }\n        if (S_lower %2 == 0) {\n            yi[0] ^=1;\n            S_lower = S_lower - yi[0] + yi[0];\n        }\n    } else if (type == \"different_parity_sums\") {\n        // Generate xi and yi such that S_upper and S_lower have different parity\n        int S_upper = 0, S_lower = 0;\n        for (int i = 0; i < n; ++i){\n            xi[i] = rnd.next(1,6);\n            yi[i] = rnd.next(1,6);\n            S_upper += xi[i];\n            S_lower += yi[i];\n        }\n        // Adjust to make parities different\n        if ( (S_upper%2)==(S_lower%2) ) {\n            xi[0] ^= 1;\n            S_upper = S_upper - xi[0] + xi[0];\n        }\n    } else {\n        // Default random case\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1,6);\n            yi[i] = rnd.next(1,6);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xi[i], yi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type even_sum\n./gen -n 1 -type odd_sum_one_swap_possible\n./gen -n 1 -type odd_sum_no_swap_possible\n./gen -n 1 -type different_parity_sums\n\n./gen -n 2 -type even_sum\n./gen -n 2 -type odd_sum_one_swap_possible\n./gen -n 2 -type odd_sum_no_swap_possible\n./gen -n 2 -type different_parity_sums\n\n./gen -n 5 -type even_sum\n./gen -n 5 -type odd_sum_one_swap_possible\n./gen -n 5 -type odd_sum_no_swap_possible\n./gen -n 5 -type different_parity_sums\n\n./gen -n 10 -type even_sum\n./gen -n 10 -type odd_sum_one_swap_possible\n./gen -n 10 -type odd_sum_no_swap_possible\n./gen -n 10 -type different_parity_sums\n\n./gen -n 50 -type even_sum\n./gen -n 50 -type odd_sum_one_swap_possible\n./gen -n 50 -type odd_sum_no_swap_possible\n./gen -n 50 -type different_parity_sums\n\n./gen -n 100 -type even_sum\n./gen -n 100 -type odd_sum_one_swap_possible\n./gen -n 100 -type odd_sum_no_swap_possible\n./gen -n 100 -type different_parity_sums\n\n./gen -n 100 -type even_sum\n./gen -n 100 -type even_sum\n./gen -n 100 -type even_sum\n./gen -n 100 -type odd_sum_one_swap_possible\n./gen -n 100 -type odd_sum_one_swap_possible\n./gen -n 100 -type odd_sum_one_swap_possible\n./gen -n 100 -type odd_sum_no_swap_possible\n./gen -n 100 -type odd_sum_no_swap_possible\n./gen -n 100 -type odd_sum_no_swap_possible\n./gen -n 100 -type different_parity_sums\n./gen -n 100 -type different_parity_sums\n./gen -n 100 -type different_parity_sums\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:54.006824",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "353/B",
      "title": "B. Две кучки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано целое число n (1 ≤ n ≤ 100). Во второй строке через пробел заданы 2·n целых чисел ai (10 ≤ ai ≤ 99), обозначающих числа, изображенные на кубиках.",
      "output_spec": "Выходные данныеВ первой строке выведите целое число — максимально возможное количество различных четырехзначных чисел, которое может получить Валера. Во второй строке выведите 2·n целых чисел bi (1 ≤ bi ≤ 2), число bi обозначает номер кучки в которую Валера должен отнести i-ый кубик.Если существует несколько вариантов разбиения кубиков на кучки, дающих максимально возможное количество различных четырехзначных чисел, которое может получить Валера, выведите любой из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать110 99Выходные данныеСкопировать12 1 Входные данныеСкопировать213 24 13 45Выходные данныеСкопировать41 2 2 1",
      "description": "B. Две кучки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано целое число n (1 ≤ n ≤ 100). Во второй строке через пробел заданы 2·n целых чисел ai (10 ≤ ai ≤ 99), обозначающих числа, изображенные на кубиках.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число — максимально возможное количество различных четырехзначных чисел, которое может получить Валера. Во второй строке выведите 2·n целых чисел bi (1 ≤ bi ≤ 2), число bi обозначает номер кучки в которую Валера должен отнести i-ый кубик.Если существует несколько вариантов разбиения кубиков на кучки, дающих максимально возможное количество различных четырехзначных чисел, которое может получить Валера, выведите любой из них.\n\nВыходные данные\n\nВходные данныеСкопировать110 99Выходные данныеСкопировать12 1 Входные данныеСкопировать213 24 13 45Выходные данныеСкопировать41 2 2 1\n\nВходные данныеСкопировать110 99\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать213 24 13 45\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать41 2 2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Валера может отложить первый кубик в первую кучку, а второй — во вторую. В этом случае он сможет получить число 1099. Если же он поместит в первую кучку второй кубик, а во вторую — первый, то он сможет получить число 9910. В обоих случаях максимальное количество различных чисел равно единице.Во втором тестовом примере Валера сможет получить числа 1313, 1345, 2413, 2445. Обратите внимание, что если бы Валера отложил в первую кучку первый и третий кубики, то он смог бы получить лишь два числа 1324 и 1345.",
      "solutions": [
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Всем привет!)Сегодня состоится очередной раунд Codeforces #205 для участников из 2 дивизиона. Традиционно, участники 1 дивизиона могут написать соревнование вне конкурса.Подготовкой задач занимались Игорь Кудряшов (Igor_Kudryashov) и Геральд Агапов (Gerald). Кроме того, выражаем благодарность Михаилу Мирзаянову (MikeMirzayanov) за прекрасный ресурс Codeforces и Марии Беловой (Delinur) за перевод условий задач на английский язык.Желаем всем участникам удачи, высокого рейтинга и удовольствия от решения задач)UPD: В раунде будет использована динамическая система оценки задач.UPD 2: Соревнование завершено, благодарим всех за участие.Поздравляем победителей: hos_epic gzh1996n I_LOVE_ELE UPD 3: Разбор задач можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 728
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Всем привет!)Сегодня состоится очередной раунд Codeforces #205 для участников из 2 дивизиона. Традиционно, участники 1 дивизиона могут написать соревнование вне конкурса.Подготовкой задач занимались Игорь Кудряшов (Igor_Kudryashov) и Геральд Агапов (Gerald). Кроме того, выражаем благодарность Михаилу Мирзаянову (MikeMirzayanov) за прекрасный ресурс Codeforces и Марии Беловой (Delinur) за перевод условий задач на английский язык.Желаем всем участникам удачи, высокого рейтинга и удовольствия от решения задач)UPD: В раунде будет использована динамическая система оценки задач.UPD 2: Соревнование завершено, благодарим всех за участие.Поздравляем победителей: hos_epic gzh1996n I_LOVE_ELE UPD 3: Разбор задач можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 728
        },
        {
          "title": "Разбор задач Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "353A - ДоминоОбозначим сумму чисел на верхних половинках костей за s1, а сумму на нижних — s2. Если изначально s1 и s2 четные, то ответ, очевидно, 0. Заметим, что если числа на обеих половинках кости одинаковой четности, то при повороте этой кости четность s1 и s2 не меняется. Если же четность чисел на половинках разная, то при повороте кости меняется четность как у s1 так и у s2. Из этого следует, что если s1 и s2 имеют разную четность, то ответ  - 1. Если же s1 и s2 нечетные, то нужно проверить, имеется ли в наборе кость с числами разной четности на половинках. Если имеется, то ответ 1, иначе ответ  - 1.353B - Две кучкиДля краткости будем говорить, что в кучки раскладываются числа, нарисованные на кубиках, а не сами кубики.Заметим, что ответ на задачу, это произведение количеств различных чисел в каждой из кучек. Предположим, что все заданные числа различны. В этом случае ответ равен n2. Предположим теперь, что есть два одинаковых числа, а все остальные различны. Тогда, если мы их положим в разные кучки, то ответ будет равен n2, а если в одну, то n·(n - 1). Очевидно, первый вариант даст большее произведение. Рассуждая аналогичным образом, можно прийти к выводу, что нужно действовать следующим образом. Возьмем числа, которые встречаются больше одного раза, и закидаем по одному из них в разные кучки, остальные пока отложим в сторону. После этого числа, которые встречаются по одному разу раскидаем поровну в разные кучки. Затем, все числа, которые мы отложили в сторону раскидаем по кучкам произвольным образом.353C - Найдите максимумРассмотрим старший бит числа m. Если он равен нулю, то во всех в n - 1-ой позиции будет стоять 0, а значит an - 1 никак не повлияет на ответ и мы можем выбросить его из набора и считать ответ для массива из n - 1 элемента.Если же старший бит числа m равен 1, то an - 1 для некоторых x будет входить в f(x), а для некоторых — нет. Рассмотрим все x, при которых an - 1 не будет входить в f(x). Это, очевидно, . Среди таких x максимальное f(x), очевидно, будет достигаться при x = 2n - 1 - 1. Попробуем улучшить ответ этим значением.Теперь нам осталось рассмотреть , среди них найти максимальное f(x) и попробовать улучшить ответ этим значением. Заметим, что во всех таких x на (n - 1)-ой позиции находится 1, поэтому мы можем найти максимальное значение f(y) среди всех и прибавить к нему an - 1.353D - ОчередьЗаметим, что если несколько девочек стоит в самом начале очереди, то они никогда не будут двигаться, поэтому удалим их, и будем считать, что очередь начинается с мальчика. Также заметим, что относительный порядок девочек при движении не меняется. Посчитаем для каждой девочки момент времени ti, начиная с которого она перестанет двигаться в очереди навсегда. Заметим, что для i-ой по порядку девочки ti ≥ ti - 1. Будем считать ti в порядке слева направо. Посмотрим на какой позиции yi в очереди будет находиться девочка, когда она закончит свое движение, и на какой позиции xi она находится сейчас. Тогда этой девочке потребуется не менее xi - yi времени, чтобы добраться до своего места. Тогда если xi - yi > ti - 1, то ti = xi - yi. Рассмотрим, что произойдет при xi - yi ≤ ti. В момент времени ti - 1 (i - 1)-ая девочка будет находиться на позиции yi, поэтому ti ≥ ti - 1 + 1. С другой стороны, рассмотрим последний момент времени p, когда i-ая девочка стоит непосредственно за (i - 1), но еще не на позиции yi. После этого, в момент времени p + 1 (i - 1)-ая девочка меняется местами со стоящим перед ней мальчиком, а i-ая девочка остается на своей позиции. Затем с момента времени p + 2 до ti - 1 обе девочки меняются местами с впереди стоящими мальчиками. А в момент времени ti - 1 + 1 i-ая девочка наконец встает на свое конечное место. Отсюда следует, что в этом случае ti = ti - 1 + 1.353E - АнтицепьРазобьем имеющийся граф на цепи. Цепью назовем максимальную по включению последовательность одинаково направленных ребер. Если в каждой такой цепи не менее 2 ребер, то ответ — это количество таких цепей.Если же есть цепь в которой одно ребро (u, v), то переберем, какую из вершин, инцидентных этому ребру, мы возьмем в максимальную антицепь (также переберем вариант, когда не берем ни одной вершины). Пусть это вершина v. После этого, выкинем из рассмотрения данную вершину и все вершины, которые достижимы из v и из которых достижима v. После этого граф превратится в цепочку, на которой можно за линейное время динамическим программированием найти размер максимальной антицепи. Покажем, как это сделать.Выпишем все вершины в цепочку и пронумеруем слева направо числами от 1 до k. После этого будем считать величину di — размер максимальной антицепи, среди вершин с номерами j ≥ i. Тогда, если i > k, то di = 0. Иначе мы можем пропустить i-ую вершину и улучшить величину di значением di + 1. Также мы можем попробовать взять i-ую вершину в ответ. В этом случае нужно пропустить все вершины, которые либо достижимы из i-ой, либо из которых достижима i-ая, взять ответ от следующей, прибавить к нему единицу и попробовать улучшить ответ.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 353\\s*B"
          },
          "content_length": 5008
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces - Code 1",
          "code": "3\n1 7\n4 6\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces - Code 2",
          "code": "3\n1 7\n4 6\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces - Code 3",
          "code": "ans = max(ans + 1, i - cnt);\ncnt++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces - Code 4",
          "code": "ans = max(ans + 1, i - cnt);\ncnt++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces - Code 1",
          "code": "3\n1 7\n4 6\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces - Code 2",
          "code": "3\n1 7\n4 6\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces - Code 3",
          "code": "ans = max(ans + 1, i - cnt);\ncnt++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces - Code 4",
          "code": "ans = max(ans + 1, i - cnt);\ncnt++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9139",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #205 (Div. 2) - Codeforces - Code 1",
          "code": "T(i) = max(T(i-1) + 1, dist(i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #205 (Div. 2) - Codeforces - Code 2",
          "code": "T(lastGirl)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(2 * n, 10, 99, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(2 * n, 10, 99, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(2 * n, 10, 99, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> ai;\n\nint readAns(InStream& stream) {\n    int claimed_max = stream.readInt(0, n * n, \"maximum number of distinct numbers\"); // Max possible is n^2\n    vector<int> bi = stream.readInts(2 * n, 1, 2, \"heap assignments bi\");\n\n    // Check that bi contains exactly n ones and n twos\n    int cnt1 = 0, cnt2 = 0;\n    for (int i = 0; i < 2 * n; ++i) {\n        if (bi[i] == 1) ++cnt1;\n        else if (bi[i] == 2) ++cnt2;\n        else {\n            stream.quitf(_wa, \"Invalid heap assignment bi[%d] = %d\", i + 1, bi[i]);\n        }\n    }\n    if (cnt1 != n) {\n        stream.quitf(_wa, \"The number of cubes in the first heap is %d, expected %d\", cnt1, n);\n    }\n    if (cnt2 != n) {\n        stream.quitf(_wa, \"The number of cubes in the second heap is %d, expected %d\", cnt2, n);\n    }\n\n    // Build heaps\n    vector<int> heap1, heap2;\n    for (int i = 0; i < 2 * n; ++i) {\n        if (bi[i] == 1) {\n            heap1.push_back(ai[i]);\n        } else {\n            heap2.push_back(ai[i]);\n        }\n    }\n\n    // For all combinations, form four-digit numbers\n    set<int> four_digit_numbers;\n    for (int x : heap1) {\n        for (int y : heap2) {\n            int num = x * 100 + y;\n            four_digit_numbers.insert(num);\n        }\n    }\n\n    int calculated_value = four_digit_numbers.size();\n\n    if (claimed_max != calculated_value) {\n        stream.quitf(_wa, \"Claimed number of distinct numbers %d does not match calculated value %d\", claimed_max, calculated_value);\n    }\n\n    return calculated_value;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 100, \"n\");\n    ai = inf.readInts(2 * n, 10, 99, \"ai\");\n\n    int jury_value = readAns(ans);\n    int participant_value = readAns(ouf);\n\n    if (participant_value < jury_value) {\n        quitf(_wa, \"Participant's answer is not optimal: Expected %d, Found %d\", jury_value, participant_value);\n    } else if (participant_value == jury_value) {\n        quitf(_ok, \"Correct answer: %d\", participant_value);\n    } else {\n        quitf(_fail, \"Participant's answer exceeds jury's expected maximum\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(2 * n);\n\n    if (type == \"random\") {\n        // Generate random numbers between 10 and 99\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = rnd.next(10, 99);\n        }\n    } else if (type == \"same\") {\n        // All ai are the same\n        int value = rnd.next(10, 99);\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = value;\n        }\n    } else if (type == \"max_distinct\") {\n        // Generate as many distinct ai as possible\n        vector<int> numbers;\n        for (int i = 10; i <= 99; ++i) {\n            numbers.push_back(i);\n        }\n        shuffle(numbers.begin(), numbers.end());\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = numbers[i % numbers.size()];\n        }\n    } else if (type == \"min_distinct\") {\n        // Use as few distinct ai as possible\n        int value = rnd.next(10, 99);\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = value;\n        }\n    } else if (type == \"half_same\") {\n        // First n numbers are the same, remaining n numbers are random\n        int value = rnd.next(10, 99);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = value;\n        }\n        for (int i = n; i < 2 * n; ++i) {\n            ai[i] = rnd.next(10, 99);\n        }\n    } else if (type == \"two_numbers\") {\n        // Use only two numbers for ai\n        int value1 = rnd.next(10, 99);\n        int value2 = rnd.next(10, 99);\n        while (value2 == value1) {\n            value2 = rnd.next(10, 99);\n        }\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = (i % 2 == 0) ? value1 : value2;\n        }\n    } else if (type == \"patterned\") {\n        // Generate ai numbers that create certain patterns, perhaps to test specific corner cases\n        // Let's generate numbers where tens digit is the same, units digit varies\n        int tens = rnd.next(1, 9);\n        for (int i = 0; i < 2 * n; ++i) {\n            int units = i % 10;\n            ai[i] = tens * 10 + units;\n        }\n    } else if (type == \"max_same_in_heaps\") {\n        // All numbers in each heap are the same\n        int value1 = rnd.next(10, 99);\n        int value2 = rnd.next(10, 99);\n        while (value2 == value1) {\n            value2 = rnd.next(10, 99);\n        }\n        for (int i = 0; i < n; ++i) {\n            ai[i] = value1;\n        }\n        for (int i = n; i < 2 * n; ++i) {\n            ai[i] = value2;\n        }\n    } else if (type == \"alternating_numbers\") {\n        // Alternate between two numbers\n        int value1 = rnd.next(10, 99);\n        int value2 = rnd.next(10, 99);\n        while (value2 == value1) {\n            value2 = rnd.next(10, 99);\n        }\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = (i % 2 == 0) ? value1 : value2;\n        }\n    } else if (type == \"ascending_numbers\") {\n        // Numbers are in ascending order\n        int start = 10;\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = start + (i % 90);\n        }\n    } else if (type == \"descending_numbers\") {\n        // Numbers are in descending order\n        int start = 99;\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = start - (i % 90);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = rnd.next(10, 99);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < 2 * n; ++i) {\n        printf(\"%d%c\", ai[i], (i + 1 == 2 * n) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(2 * n);\n\n    if (type == \"random\") {\n        // Generate random numbers between 10 and 99\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = rnd.next(10, 99);\n        }\n    } else if (type == \"same\") {\n        // All ai are the same\n        int value = rnd.next(10, 99);\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = value;\n        }\n    } else if (type == \"max_distinct\") {\n        // Generate as many distinct ai as possible\n        vector<int> numbers;\n        for (int i = 10; i <= 99; ++i) {\n            numbers.push_back(i);\n        }\n        shuffle(numbers.begin(), numbers.end());\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = numbers[i % numbers.size()];\n        }\n    } else if (type == \"min_distinct\") {\n        // Use as few distinct ai as possible\n        int value = rnd.next(10, 99);\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = value;\n        }\n    } else if (type == \"half_same\") {\n        // First n numbers are the same, remaining n numbers are random\n        int value = rnd.next(10, 99);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = value;\n        }\n        for (int i = n; i < 2 * n; ++i) {\n            ai[i] = rnd.next(10, 99);\n        }\n    } else if (type == \"two_numbers\") {\n        // Use only two numbers for ai\n        int value1 = rnd.next(10, 99);\n        int value2 = rnd.next(10, 99);\n        while (value2 == value1) {\n            value2 = rnd.next(10, 99);\n        }\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = (i % 2 == 0) ? value1 : value2;\n        }\n    } else if (type == \"patterned\") {\n        // Generate ai numbers that create certain patterns, perhaps to test specific corner cases\n        // Let's generate numbers where tens digit is the same, units digit varies\n        int tens = rnd.next(1, 9);\n        for (int i = 0; i < 2 * n; ++i) {\n            int units = i % 10;\n            ai[i] = tens * 10 + units;\n        }\n    } else if (type == \"max_same_in_heaps\") {\n        // All numbers in each heap are the same\n        int value1 = rnd.next(10, 99);\n        int value2 = rnd.next(10, 99);\n        while (value2 == value1) {\n            value2 = rnd.next(10, 99);\n        }\n        for (int i = 0; i < n; ++i) {\n            ai[i] = value1;\n        }\n        for (int i = n; i < 2 * n; ++i) {\n            ai[i] = value2;\n        }\n    } else if (type == \"alternating_numbers\") {\n        // Alternate between two numbers\n        int value1 = rnd.next(10, 99);\n        int value2 = rnd.next(10, 99);\n        while (value2 == value1) {\n            value2 = rnd.next(10, 99);\n        }\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = (i % 2 == 0) ? value1 : value2;\n        }\n    } else if (type == \"ascending_numbers\") {\n        // Numbers are in ascending order\n        int start = 10;\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = start + (i % 90);\n        }\n    } else if (type == \"descending_numbers\") {\n        // Numbers are in descending order\n        int start = 99;\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = start - (i % 90);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < 2 * n; ++i) {\n            ai[i] = rnd.next(10, 99);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < 2 * n; ++i) {\n        printf(\"%d%c\", ai[i], (i + 1 == 2 * n) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same\n./gen -n 1 -type max_distinct\n./gen -n 1 -type min_distinct\n./gen -n 2 -type random\n./gen -n 2 -type two_numbers\n./gen -n 5 -type half_same\n./gen -n 5 -type max_same_in_heaps\n./gen -n 10 -type random\n./gen -n 10 -type same\n./gen -n 10 -type max_distinct\n./gen -n 10 -type min_distinct\n./gen -n 10 -type half_same\n./gen -n 10 -type ascending_numbers\n./gen -n 10 -type descending_numbers\n./gen -n 50 -type random\n./gen -n 50 -type same\n./gen -n 50 -type two_numbers\n./gen -n 50 -type max_same_in_heaps\n./gen -n 50 -type alternating_numbers\n./gen -n 75 -type patterned\n./gen -n 99 -type random\n./gen -n 99 -type half_same\n./gen -n 99 -type max_same_in_heaps\n./gen -n 99 -type ascending_numbers\n./gen -n 99 -type descending_numbers\n./gen -n 100 -type random\n./gen -n 100 -type same\n./gen -n 100 -type max_distinct\n./gen -n 100 -type min_distinct\n./gen -n 100 -type half_same\n./gen -n 100 -type ascending_numbers\n./gen -n 100 -type descending_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:55.699212",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "353/C",
      "title": "C. Find Maximum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of array elements. The next line contains n space-separated integers a0, a1, ..., an - 1 (0 ≤ ai ≤ 104) — elements of array a.The third line contains a sequence of digits zero and one without spaces s0s1... sn - 1 — the binary representation of number m. Number m equals .",
      "output_spec": "OutputPrint a single integer — the maximum value of function f(x) for all .",
      "sample_tests": "ExamplesInputCopy23 810OutputCopy3InputCopy517 0 10 2 111010OutputCopy27",
      "description": "C. Find Maximum\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of array elements. The next line contains n space-separated integers a0, a1, ..., an - 1 (0 ≤ ai ≤ 104) — elements of array a.The third line contains a sequence of digits zero and one without spaces s0s1... sn - 1 — the binary representation of number m. Number m equals .\n\nOutputPrint a single integer — the maximum value of function f(x) for all .\n\nInputCopy23 810OutputCopy3InputCopy517 0 10 2 111010OutputCopy27\n\nInputCopy23 810\n\nOutputCopy3\n\nInputCopy517 0 10 2 111010\n\nOutputCopy27\n\nNoteIn the first test case m = 20 = 1, f(0) = 0, f(1) = a0 = 3.In the second sample m = 20 + 21 + 23 = 11, the maximum value of function equals f(5) = a0 + a2 = 17 + 10 = 27.",
      "solutions": [
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #205 for participants from 2 division will take place today. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: It is decided to use dynamic scoring system.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: hos_epic gzh1996n I_LOVE_ELE UPD 3: you can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 680
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #205 for participants from 2 division will take place today. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: It is decided to use dynamic scoring system.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: hos_epic gzh1996n I_LOVE_ELE UPD 3: you can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 680
        },
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces",
          "content": "353A - DominoLet's denote the sum of numbers on the upper halves of pieces as s1, and the sum on the lower halves — s2. If this sums are even, than the answer is obviously 0. Note, that if the numbers on both halves of piece have the same parity, than parity of s1 and s2 won't change after rotation this piece. If the numbers on halves have different parity, than parities of both s1 and s2 will change after rotation. Therefore, if s1 and s2 have different parities, than the answer is  - 1. If both s1 and s2 are odd, than we should check, if there is a piece with numbers of different parities. If so, the answer is 1, otherwise, the answer is  - 1.353B - Two HeapsLet's say for shortness, that we put numbers, that are painted on cubes, in piles, instead of cubes themselves.Note, that the answer is the product of c1... c2, where ci is the number of different numbers in the i-th pile. Let's consider that all numbers are different. In this case the answer is n2. Now, let's suppose that we have two equal numbers and all the other are different. Then, if we put them in different piles, the answer will be n2, but if we put them in one — n·(n - 1). Obviously, the first case give greater product.Thinking in similar manner, you can conclude, that we should do the following. Take numbers, that appear more than once, and put one of them in the first pile, one of them in the second pile and the other put aside. After that, divide the numbers, that appears once, in two equal part and put the first part in the first pile and second part in the second pile. Finally, take the numbers, that we put aside, and separate them in two pile in any kind.353C - Find MaximumLet's see on the highest bit of m. If it equals to zero, than for any there is a zero on the (n - 1)-th position, so an - 1 doesn't affect the answer and we can put it aside and find the answer for smaller number of elements.If the highest bit of m equals to 1, than an - 1 for some x will present in f(x), but for some will not. Let's consider such x, that a{n - 1} will present in f(x) with zero coefficient. It is obvious that . In this case f(x) will have maximum value when x = 2n - 1 - 1. Try to update the answer by this value.Now we should analyze the case, when , find the maximum value of f(x) for all such x and try to update the answer by this value. Let's note, that in all such x there is 1 in (n - 1)-th position. Therefore we can find the maximum value of f(y) for all and add an - 1 to it.353D - QueueNote that if there are some girls in the begining of the line, they will never move. So let's remove them and will consider that the first schoolchildren in the line is a boy. Also note, the relative order of the girls doesn't change. Let's calculate for each girl such moment of time ti, that after it she won't move forever. Note, that for i-th girl ti ≥ ti - 1. Let's calculate ti in order from left to right. Let's denote yi is the position in the line where i-th girl will stop, ans xi is her current position. Therefore it is needed xi - yi second for girl to reach her finish position. So if xi - yi > ti - 1, then ti = xi - yi. Let's manage the case when xi - yi ≤ ti. The girl with number (i - 1) will be on yi-th position by ti - 1-th second, so ti ≥ ti - 1 + 1. Let's consider such moment of time p, when i-th girl stand right after (i - 1)-th, but not on yi-th position. After that, in (p + 1)-th moment of time (i - 1)-th girl and the boy standing in front of her will swap their positions, but i-th girl will save her position. Then since p + 2-th second till ti - 1 both girls will change their positions. Finally, at (ti - 1 + 1) - th second i-th girl will occupy her position. Therefore, ti = ti - 1 + 1 in this case.353E - AntichainLet's divide our graph on chains. Denote chain as the maximal sequence of the edges, which have the same direction. If there are more than 2 edges in each chain, then the answer is the number of such chains.If there is a chain containing only one edge (u, v), then brute vertex, which we will take in maximal antichain (also consider the case, when we take none of them). Let's suppose we brute the vertex v. After that we put aside this vertex and all vertices, which is comparable with v. In received graph we can find the size of the maximal antichain by uning dynamic programming with O(n) time complexity. Let's show how to do this.Write all remaining vertices in line and renumerate them from left to right by the numbers from 1 to k. After that we are going to calculate di — the size of the maximal antichain among vertices with numbers j ≥ i. So if i > k, then di = 0. In other case we can skip i-th vertex and try to update di by the value of di + 1. Also we can try to take i-th vertex to the answer. In this case we should skip all vertices, that are reachable from i-th, or the vertices, from which we can reach i-th, take the answer from the next vertex, add 1 to it and try to update the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 353\\s*C"
          },
          "content_length": 4950
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "T(i) = max(T(i-1) + 1, dist(i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "T(lastGirl)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 10000);\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 10000);\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 10000);\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string m_type = opt<string>(\"m_type\", \"max\");\n\n    vector<int> a(n);\n\n    if (a_type == \"max_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 10000;\n    } else if (a_type == \"min_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (a_type == \"random_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 10000);\n    } else if (a_type == \"alternating_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 10000 : 0;\n    } else if (a_type == \"increasing_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i * 10000 / max(1, n - 1);\n    } else if (a_type == \"decreasing_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (n - i - 1) * 10000 / max(1, n - 1);\n    } else {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 10000);\n    }\n\n    string s(n, '0');\n    if (m_type == \"min_m\") {\n        // m = 0\n    } else if (m_type == \"max_m\") {\n        for (int i = 0; i < n; ++i)\n            s[i] = '1';\n    } else if (m_type == \"random_m\") {\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) ? '1' : '0';\n    } else if (m_type == \"partial_m\") {\n        int k = rnd.next(1, n - 1);\n        for (int i = 0; i < k; ++i)\n            s[i] = '1';\n    } else {\n        for (int i = 0; i < n; ++i)\n            s[i] = '1';\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string m_type = opt<string>(\"m_type\", \"max\");\n\n    vector<int> a(n);\n\n    if (a_type == \"max_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 10000;\n    } else if (a_type == \"min_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (a_type == \"random_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 10000);\n    } else if (a_type == \"alternating_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 10000 : 0;\n    } else if (a_type == \"increasing_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i * 10000 / max(1, n - 1);\n    } else if (a_type == \"decreasing_a\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (n - i - 1) * 10000 / max(1, n - 1);\n    } else {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 10000);\n    }\n\n    string s(n, '0');\n    if (m_type == \"min_m\") {\n        // m = 0\n    } else if (m_type == \"max_m\") {\n        for (int i = 0; i < n; ++i)\n            s[i] = '1';\n    } else if (m_type == \"random_m\") {\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) ? '1' : '0';\n    } else if (m_type == \"partial_m\") {\n        int k = rnd.next(1, n - 1);\n        for (int i = 0; i < k; ++i)\n            s[i] = '1';\n    } else {\n        for (int i = 0; i < n; ++i)\n            s[i] = '1';\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -a_type min_a -m_type min_m\n./gen -n 1 -a_type min_a -m_type max_m\n./gen -n 1 -a_type max_a -m_type min_m\n./gen -n 1 -a_type max_a -m_type max_m\n\n./gen -n 2 -a_type random_a -m_type random_m\n./gen -n 2 -a_type alternating_a -m_type partial_m\n\n./gen -n 10 -a_type random_a -m_type random_m\n./gen -n 10 -a_type alternating_a -m_type partial_m\n./gen -n 10 -a_type increasing_a -m_type max_m\n./gen -n 10 -a_type decreasing_a -m_type min_m\n\n./gen -n 100 -a_type max_a -m_type max_m\n./gen -n 100 -a_type min_a -m_type min_m\n./gen -n 100 -a_type random_a -m_type random_m\n\n./gen -n 1000 -a_type increasing_a -m_type partial_m\n./gen -n 1000 -a_type decreasing_a -m_type partial_m\n./gen -n 1000 -a_type random_a -m_type random_m\n\n./gen -n 10000 -a_type random_a -m_type max_m\n./gen -n 10000 -a_type random_a -m_type min_m\n./gen -n 10000 -a_type alternating_a -m_type random_m\n\n./gen -n 50000 -a_type max_a -m_type min_m\n./gen -n 50000 -a_type min_a -m_type max_m\n./gen -n 50000 -a_type random_a -m_type partial_m\n\n./gen -n 100000 -a_type random_a -m_type random_m\n./gen -n 100000 -a_type increasing_a -m_type max_m\n./gen -n 100000 -a_type decreasing_a -m_type min_m\n./gen -n 100000 -a_type alternating_a -m_type partial_m\n\n./gen -n 100000 -a_type max_a -m_type max_m\n./gen -n 100000 -a_type min_a -m_type min_m\n./gen -n 100000 -a_type random_a -m_type random_m\n\n./gen -n 99999 -a_type random_a -m_type partial_m\n./gen -n 50000 -a_type random_a -m_type random_m\n./gen -n 1 -a_type random_a -m_type random_m\n./gen -n 10 -a_type max_a -m_type min_m\n./gen -n 10 -a_type min_a -m_type max_m\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:12:57.885329",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "353/D",
      "title": "D. Queue",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a sequence of letters without spaces s1s2... sn (1 ≤ n ≤ 106), consisting of capital English letters M and F. If letter si equals M, that means that initially, the line had a boy on the i-th position. If letter si equals F, then initially the line had a girl on the i-th position.",
      "output_spec": "OutputPrint a single integer — the number of seconds needed to move all the girls in the line in front of the boys. If the line has only boys or only girls, print 0.",
      "sample_tests": "ExamplesInputCopyMFMOutputCopy1InputCopyMMFFOutputCopy3InputCopyFFMMMOutputCopy0",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a sequence of letters without spaces s1s2... sn (1 ≤ n ≤ 106), consisting of capital English letters M and F. If letter si equals M, that means that initially, the line had a boy on the i-th position. If letter si equals F, then initially the line had a girl on the i-th position.\n\nOutputPrint a single integer — the number of seconds needed to move all the girls in the line in front of the boys. If the line has only boys or only girls, print 0.\n\nInputCopyMFMOutputCopy1InputCopyMMFFOutputCopy3InputCopyFFMMMOutputCopy0\n\nInputCopyMFM\n\nOutputCopy1\n\nInputCopyMMFF\n\nOutputCopy3\n\nInputCopyFFMMM\n\nOutputCopy0\n\nNoteIn the first test case the sequence of changes looks as follows: MFM  →  FMM.The second test sample corresponds to the sample from the statement. The sequence of changes is: MMFF  →  MFMF  →  FMFM  →  FFMM.",
      "solutions": [
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #205 for participants from 2 division will take place today. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: It is decided to use dynamic scoring system.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: hos_epic gzh1996n I_LOVE_ELE UPD 3: you can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 680
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #205 for participants from 2 division will take place today. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: It is decided to use dynamic scoring system.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: hos_epic gzh1996n I_LOVE_ELE UPD 3: you can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 680
        },
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces",
          "content": "353A - DominoLet's denote the sum of numbers on the upper halves of pieces as s1, and the sum on the lower halves — s2. If this sums are even, than the answer is obviously 0. Note, that if the numbers on both halves of piece have the same parity, than parity of s1 and s2 won't change after rotation this piece. If the numbers on halves have different parity, than parities of both s1 and s2 will change after rotation. Therefore, if s1 and s2 have different parities, than the answer is  - 1. If both s1 and s2 are odd, than we should check, if there is a piece with numbers of different parities. If so, the answer is 1, otherwise, the answer is  - 1.353B - Two HeapsLet's say for shortness, that we put numbers, that are painted on cubes, in piles, instead of cubes themselves.Note, that the answer is the product of c1... c2, where ci is the number of different numbers in the i-th pile. Let's consider that all numbers are different. In this case the answer is n2. Now, let's suppose that we have two equal numbers and all the other are different. Then, if we put them in different piles, the answer will be n2, but if we put them in one — n·(n - 1). Obviously, the first case give greater product.Thinking in similar manner, you can conclude, that we should do the following. Take numbers, that appear more than once, and put one of them in the first pile, one of them in the second pile and the other put aside. After that, divide the numbers, that appears once, in two equal part and put the first part in the first pile and second part in the second pile. Finally, take the numbers, that we put aside, and separate them in two pile in any kind.353C - Find MaximumLet's see on the highest bit of m. If it equals to zero, than for any there is a zero on the (n - 1)-th position, so an - 1 doesn't affect the answer and we can put it aside and find the answer for smaller number of elements.If the highest bit of m equals to 1, than an - 1 for some x will present in f(x), but for some will not. Let's consider such x, that a{n - 1} will present in f(x) with zero coefficient. It is obvious that . In this case f(x) will have maximum value when x = 2n - 1 - 1. Try to update the answer by this value.Now we should analyze the case, when , find the maximum value of f(x) for all such x and try to update the answer by this value. Let's note, that in all such x there is 1 in (n - 1)-th position. Therefore we can find the maximum value of f(y) for all and add an - 1 to it.353D - QueueNote that if there are some girls in the begining of the line, they will never move. So let's remove them and will consider that the first schoolchildren in the line is a boy. Also note, the relative order of the girls doesn't change. Let's calculate for each girl such moment of time ti, that after it she won't move forever. Note, that for i-th girl ti ≥ ti - 1. Let's calculate ti in order from left to right. Let's denote yi is the position in the line where i-th girl will stop, ans xi is her current position. Therefore it is needed xi - yi second for girl to reach her finish position. So if xi - yi > ti - 1, then ti = xi - yi. Let's manage the case when xi - yi ≤ ti. The girl with number (i - 1) will be on yi-th position by ti - 1-th second, so ti ≥ ti - 1 + 1. Let's consider such moment of time p, when i-th girl stand right after (i - 1)-th, but not on yi-th position. After that, in (p + 1)-th moment of time (i - 1)-th girl and the boy standing in front of her will swap their positions, but i-th girl will save her position. Then since p + 2-th second till ti - 1 both girls will change their positions. Finally, at (ti - 1 + 1) - th second i-th girl will occupy her position. Therefore, ti = ti - 1 + 1 in this case.353E - AntichainLet's divide our graph on chains. Denote chain as the maximal sequence of the edges, which have the same direction. If there are more than 2 edges in each chain, then the answer is the number of such chains.If there is a chain containing only one edge (u, v), then brute vertex, which we will take in maximal antichain (also consider the case, when we take none of them). Let's suppose we brute the vertex v. After that we put aside this vertex and all vertices, which is comparable with v. In received graph we can find the size of the maximal antichain by uning dynamic programming with O(n) time complexity. Let's show how to do this.Write all remaining vertices in line and renumerate them from left to right by the numbers from 1 to k. After that we are going to calculate di — the size of the maximal antichain among vertices with numbers j ≥ i. So if i > k, then di = 0. In other case we can skip i-th vertex and try to update di by the value of di + 1. Also we can try to take i-th vertex to the answer. In this case we should skip all vertices, that are reachable from i-th, or the vertices, from which we can reach i-th, take the answer from the next vertex, add 1 to it and try to update the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 353\\s*D"
          },
          "content_length": 4950
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "T(i) = max(T(i-1) + 1, dist(i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "T(lastGirl)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    int n = s.length();\n    ensuref(1 <= n && n <= 1000000, \"Length of s (%d) is out of bounds [1, 1e6]\", n);\n    for (int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c == 'M' || c == 'F', \"Invalid character at position %d: %c\", i + 1, c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    int n = s.length();\n    ensuref(1 <= n && n <= 1000000, \"Length of s (%d) is out of bounds [1, 1e6]\", n);\n    for (int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c == 'M' || c == 'F', \"Invalid character at position %d: %c\", i + 1, c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    int n = s.length();\n    ensuref(1 <= n && n <= 1000000, \"Length of s (%d) is out of bounds [1, 1e6]\", n);\n    for (int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c == 'M' || c == 'F', \"Invalid character at position %d: %c\", i + 1, c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'M');\n\n    if (type == \"AllM\") {\n        // s is already initialized to all 'M'\n    } else if (type == \"AllF\") {\n        s = string(n, 'F');\n    } else if (type == \"AlternatingMF\") {\n        for (int i = 0; i < n; ++i) s[i] = (i % 2 == 0) ? 'M' : 'F';\n    } else if (type == \"AlternatingFM\") {\n        for (int i = 0; i < n; ++i) s[i] = (i % 2 == 0) ? 'F' : 'M';\n    } else if (type == \"AllMThenAllF\") {\n        int k = opt<int>(\"k\", n / 2);\n        s = string(k, 'M') + string(n - k, 'F');\n    } else if (type == \"AllFThenAllM\") {\n        int k = opt<int>(\"k\", n / 2);\n        s = string(k, 'F') + string(n - k, 'M');\n    } else if (type == \"SingleFAtEnd\") {\n        s = string(n - 1, 'M') + 'F';\n    } else if (type == \"SingleFAtStart\") {\n        s = 'F' + string(n - 1, 'M');\n    } else if (type == \"Random\") {\n        for (int i = 0; i < n; ++i) s[i] = (rnd.next(2) == 0) ? 'M' : 'F';\n    } else if (type == \"MaximumSwap\") {\n        int numF = opt<int>(\"numF\", n / 2);\n        s = string(numF, 'F') + string(n - numF, 'M');\n        reverse(s.begin(), s.end());\n    } else {\n        for (int i = 0; i < n; ++i) s[i] = (rnd.next(2) == 0) ? 'M' : 'F';\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'M');\n\n    if (type == \"AllM\") {\n        // s is already initialized to all 'M'\n    } else if (type == \"AllF\") {\n        s = string(n, 'F');\n    } else if (type == \"AlternatingMF\") {\n        for (int i = 0; i < n; ++i) s[i] = (i % 2 == 0) ? 'M' : 'F';\n    } else if (type == \"AlternatingFM\") {\n        for (int i = 0; i < n; ++i) s[i] = (i % 2 == 0) ? 'F' : 'M';\n    } else if (type == \"AllMThenAllF\") {\n        int k = opt<int>(\"k\", n / 2);\n        s = string(k, 'M') + string(n - k, 'F');\n    } else if (type == \"AllFThenAllM\") {\n        int k = opt<int>(\"k\", n / 2);\n        s = string(k, 'F') + string(n - k, 'M');\n    } else if (type == \"SingleFAtEnd\") {\n        s = string(n - 1, 'M') + 'F';\n    } else if (type == \"SingleFAtStart\") {\n        s = 'F' + string(n - 1, 'M');\n    } else if (type == \"Random\") {\n        for (int i = 0; i < n; ++i) s[i] = (rnd.next(2) == 0) ? 'M' : 'F';\n    } else if (type == \"MaximumSwap\") {\n        int numF = opt<int>(\"numF\", n / 2);\n        s = string(numF, 'F') + string(n - numF, 'M');\n        reverse(s.begin(), s.end());\n    } else {\n        for (int i = 0; i < n; ++i) s[i] = (rnd.next(2) == 0) ? 'M' : 'F';\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Size n = 1\n./gen -n 1 -type AllM\n./gen -n 1 -type AllF\n\n# Size n = 2\n./gen -n 2 -type AlternatingMF\n./gen -n 2 -type AlternatingFM\n\n# Size n = 10\n./gen -n 10 -type AllMThenAllF -k 5\n./gen -n 10 -type AllFThenAllM -k 5\n./gen -n 10 -type SingleFAtEnd\n./gen -n 10 -type SingleFAtStart\n./gen -n 10 -type Random\n\n# Size n = 100\n./gen -n 100 -type AlternatingMF\n./gen -n 100 -type AlternatingFM\n./gen -n 100 -type AllMThenAllF -k 50\n./gen -n 100 -type AllFThenAllM -k 50\n./gen -n 100 -type MaximumSwap -numF 10\n\n# Size n = 1000\n./gen -n 1000 -type Random\n./gen -n 1000 -type MaximumSwap -numF 500\n\n# Size n = 10000\n./gen -n 10000 -type AllM\n./gen -n 10000 -type AllF\n./gen -n 10000 -type SingleFAtStart\n./gen -n 10000 -type SingleFAtEnd\n./gen -n 10000 -type Random\n\n# Size n = 100000\n./gen -n 100000 -type AlternatingMF\n./gen -n 100000 -type AlternatingFM\n./gen -n 100000 -type MaximumSwap -numF 50000\n\n# Size n = 1000000 (maximum size)\n./gen -n 1000000 -type AllMThenAllF -k 999999\n./gen -n 1000000 -type AllFThenAllM -k 1\n./gen -n 1000000 -type SingleFAtEnd\n./gen -n 1000000 -type SingleFAtStart\n./gen -n 1000000 -type Random\n\n# Additional cases\n./gen -n 500000 -type Random\n./gen -n 999999 -type Random\n./gen -n 1000000 -type MaximumSwap -numF 500000\n./gen -n 1000000 -type MaximumSwap -numF 1\n./gen -n 1000000 -type MaximumSwap -numF 999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:00.129997",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "353/E",
      "title": "E. Antichain",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the sequence of characters s0s1... sn - 1 (2 ≤ n ≤ 106), consisting of numbers zero and one. The length of the line (number n) corresponds to the number of vertexes and edges in graph G. If character si (i ≥ 0) equals 0, then the edge between vertexes i and (i + 1) mod n is directed from the i-th vertex to the (i + 1) mod n-th one, otherwise — to the opposite point.It is guaranteed that the given graph is acyclic.",
      "output_spec": "OutputPrint a single integer — the size of the maximum antichain of graph G.",
      "sample_tests": "ExamplesInputCopy001OutputCopy1InputCopy110010OutputCopy3",
      "description": "E. Antichain\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the sequence of characters s0s1... sn - 1 (2 ≤ n ≤ 106), consisting of numbers zero and one. The length of the line (number n) corresponds to the number of vertexes and edges in graph G. If character si (i ≥ 0) equals 0, then the edge between vertexes i and (i + 1) mod n is directed from the i-th vertex to the (i + 1) mod n-th one, otherwise — to the opposite point.It is guaranteed that the given graph is acyclic.\n\nOutputPrint a single integer — the size of the maximum antichain of graph G.\n\nInputCopy001OutputCopy1InputCopy110010OutputCopy3\n\nInputCopy001\n\nOutputCopy1\n\nInputCopy110010\n\nOutputCopy3\n\nNoteConsider the first test sample. The graph's G edges are: 0 → 1, 1 → 2, 0 → 2. We can choose the set of vertexes [0] as the maximum antichain. We cannot choose an antichain of larger size.",
      "solutions": [
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #205 for participants from 2 division will take place today. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: It is decided to use dynamic scoring system.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: hos_epic gzh1996n I_LOVE_ELE UPD 3: you can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 680
        },
        {
          "title": "Codeforces Round #205 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #205 for participants from 2 division will take place today. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: It is decided to use dynamic scoring system.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: hos_epic gzh1996n I_LOVE_ELE UPD 3: you can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 680
        },
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces",
          "content": "353A - DominoLet's denote the sum of numbers on the upper halves of pieces as s1, and the sum on the lower halves — s2. If this sums are even, than the answer is obviously 0. Note, that if the numbers on both halves of piece have the same parity, than parity of s1 and s2 won't change after rotation this piece. If the numbers on halves have different parity, than parities of both s1 and s2 will change after rotation. Therefore, if s1 and s2 have different parities, than the answer is  - 1. If both s1 and s2 are odd, than we should check, if there is a piece with numbers of different parities. If so, the answer is 1, otherwise, the answer is  - 1.353B - Two HeapsLet's say for shortness, that we put numbers, that are painted on cubes, in piles, instead of cubes themselves.Note, that the answer is the product of c1... c2, where ci is the number of different numbers in the i-th pile. Let's consider that all numbers are different. In this case the answer is n2. Now, let's suppose that we have two equal numbers and all the other are different. Then, if we put them in different piles, the answer will be n2, but if we put them in one — n·(n - 1). Obviously, the first case give greater product.Thinking in similar manner, you can conclude, that we should do the following. Take numbers, that appear more than once, and put one of them in the first pile, one of them in the second pile and the other put aside. After that, divide the numbers, that appears once, in two equal part and put the first part in the first pile and second part in the second pile. Finally, take the numbers, that we put aside, and separate them in two pile in any kind.353C - Find MaximumLet's see on the highest bit of m. If it equals to zero, than for any there is a zero on the (n - 1)-th position, so an - 1 doesn't affect the answer and we can put it aside and find the answer for smaller number of elements.If the highest bit of m equals to 1, than an - 1 for some x will present in f(x), but for some will not. Let's consider such x, that a{n - 1} will present in f(x) with zero coefficient. It is obvious that . In this case f(x) will have maximum value when x = 2n - 1 - 1. Try to update the answer by this value.Now we should analyze the case, when , find the maximum value of f(x) for all such x and try to update the answer by this value. Let's note, that in all such x there is 1 in (n - 1)-th position. Therefore we can find the maximum value of f(y) for all and add an - 1 to it.353D - QueueNote that if there are some girls in the begining of the line, they will never move. So let's remove them and will consider that the first schoolchildren in the line is a boy. Also note, the relative order of the girls doesn't change. Let's calculate for each girl such moment of time ti, that after it she won't move forever. Note, that for i-th girl ti ≥ ti - 1. Let's calculate ti in order from left to right. Let's denote yi is the position in the line where i-th girl will stop, ans xi is her current position. Therefore it is needed xi - yi second for girl to reach her finish position. So if xi - yi > ti - 1, then ti = xi - yi. Let's manage the case when xi - yi ≤ ti. The girl with number (i - 1) will be on yi-th position by ti - 1-th second, so ti ≥ ti - 1 + 1. Let's consider such moment of time p, when i-th girl stand right after (i - 1)-th, but not on yi-th position. After that, in (p + 1)-th moment of time (i - 1)-th girl and the boy standing in front of her will swap their positions, but i-th girl will save her position. Then since p + 2-th second till ti - 1 both girls will change their positions. Finally, at (ti - 1 + 1) - th second i-th girl will occupy her position. Therefore, ti = ti - 1 + 1 in this case.353E - AntichainLet's divide our graph on chains. Denote chain as the maximal sequence of the edges, which have the same direction. If there are more than 2 edges in each chain, then the answer is the number of such chains.If there is a chain containing only one edge (u, v), then brute vertex, which we will take in maximal antichain (also consider the case, when we take none of them). Let's suppose we brute the vertex v. After that we put aside this vertex and all vertices, which is comparable with v. In received graph we can find the size of the maximal antichain by uning dynamic programming with O(n) time complexity. Let's show how to do this.Write all remaining vertices in line and renumerate them from left to right by the numbers from 1 to k. After that we are going to calculate di — the size of the maximal antichain among vertices with numbers j ≥ i. So if i > k, then di = 0. In other case we can skip i-th vertex and try to update di by the value of di + 1. Also we can try to take i-th vertex to the answer. In this case we should skip all vertices, that are reachable from i-th, or the vertices, from which we can reach i-th, take the answer from the next vertex, add 1 to it and try to update the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 353\\s*E"
          },
          "content_length": 4950
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "T(i) = max(T(i-1) + 1, dist(i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #205 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "T(lastGirl)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9145",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> adj[1000000 + 5];\nvector<int> color(1000000 + 5);\nint n;\n\nbool dfs(int u) {\n    color[u] = 1; // gray/in progress\n    for (int v : adj[u]) {\n        if (color[v] == 0) {\n            if (dfs(v)) return true;\n        } else if (color[v] == 1) {\n            return true; // cycle detected\n        }\n    }\n    color[u] = 2; // black/finished\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the sequence s0s1...sn-1 consisting of '0's and '1's\n    string s = inf.readToken(\"[01]{2,1000000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    \n    n = s.size();\n    ensuref(n >= 2 && n <= 1000000, \"n = %d is out of bounds\", n);\n    \n    // Build the graph according to the problem statement\n    for (int i = 0; i < n; ++i) {\n        int u = i;\n        int v = (i + 1) % n;\n        if (s[i] == '0') {\n            adj[u].push_back(v);\n        } else {\n            adj[v].push_back(u);\n        }\n    }\n    \n    // Check that the graph is acyclic using DFS\n    color.assign(n, 0); // 0 = unvisited, 1 = visiting, 2 = visited\n    bool hasCycle = false;\n    for (int i = 0; i < n; ++i) {\n        if (color[i] == 0) {\n            if (dfs(i)) {\n                hasCycle = true;\n                break;\n            }\n        }\n    }\n    \n    ensuref(!hasCycle, \"The graph contains a cycle\");\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> adj[1000000 + 5];\nvector<int> color(1000000 + 5);\nint n;\n\nbool dfs(int u) {\n    color[u] = 1; // gray/in progress\n    for (int v : adj[u]) {\n        if (color[v] == 0) {\n            if (dfs(v)) return true;\n        } else if (color[v] == 1) {\n            return true; // cycle detected\n        }\n    }\n    color[u] = 2; // black/finished\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the sequence s0s1...sn-1 consisting of '0's and '1's\n    string s = inf.readToken(\"[01]{2,1000000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    \n    n = s.size();\n    ensuref(n >= 2 && n <= 1000000, \"n = %d is out of bounds\", n);\n    \n    // Build the graph according to the problem statement\n    for (int i = 0; i < n; ++i) {\n        int u = i;\n        int v = (i + 1) % n;\n        if (s[i] == '0') {\n            adj[u].push_back(v);\n        } else {\n            adj[v].push_back(u);\n        }\n    }\n    \n    // Check that the graph is acyclic using DFS\n    color.assign(n, 0); // 0 = unvisited, 1 = visiting, 2 = visited\n    bool hasCycle = false;\n    for (int i = 0; i < n; ++i) {\n        if (color[i] == 0) {\n            if (dfs(i)) {\n                hasCycle = true;\n                break;\n            }\n        }\n    }\n    \n    ensuref(!hasCycle, \"The graph contains a cycle\");\n    \n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> adj[1000000 + 5];\nvector<int> color(1000000 + 5);\nint n;\n\nbool dfs(int u) {\n    color[u] = 1; // gray/in progress\n    for (int v : adj[u]) {\n        if (color[v] == 0) {\n            if (dfs(v)) return true;\n        } else if (color[v] == 1) {\n            return true; // cycle detected\n        }\n    }\n    color[u] = 2; // black/finished\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the sequence s0s1...sn-1 consisting of '0's and '1's\n    string s = inf.readToken(\"[01]{2,1000000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    \n    n = s.size();\n    ensuref(n >= 2 && n <= 1000000, \"n = %d is out of bounds\", n);\n    \n    // Build the graph according to the problem statement\n    for (int i = 0; i < n; ++i) {\n        int u = i;\n        int v = (i + 1) % n;\n        if (s[i] == '0') {\n            adj[u].push_back(v);\n        } else {\n            adj[v].push_back(u);\n        }\n    }\n    \n    // Check that the graph is acyclic using DFS\n    color.assign(n, 0); // 0 = unvisited, 1 = visiting, 2 = visited\n    bool hasCycle = false;\n    for (int i = 0; i < n; ++i) {\n        if (color[i] == 0) {\n            if (dfs(i)) {\n                hasCycle = true;\n                break;\n            }\n        }\n    }\n    \n    ensuref(!hasCycle, \"The graph contains a cycle\");\n    \n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '0');\n\n    if (type == \"random\") {\n\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) ? '1' : '0';\n\n        // Ensure the graph is acyclic\n        int sum = 0;\n        for(char c : s) sum += (c - '0');\n        if (sum == 0 || sum == n) { // All '0's or all '1's\n            int idx = rnd.next(n);\n            s[idx] = (s[idx] == '0') ? '1' : '0';\n        }\n\n    } else if (type == \"single_break\") {\n\n        // All '0's except s[n - 1] == '1'\n        fill(s.begin(), s.end(), '0');\n        s[n - 1] = '1';\n\n    } else if (type == \"double_break\") {\n\n        // All '0's except s[n / 2] == '1' and s[n - 1] == '1'\n        fill(s.begin(), s.end(), '0');\n        s[n / 2] = '1';\n        s[n - 1] = '1';\n\n    } else if (type == \"alternate\") {\n\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '0' : '1';\n        }\n\n    } else if (type == \"all_zero_but_one\") {\n\n        fill(s.begin(), s.end(), '0');\n        s[0] = '1';\n\n    } else if (type == \"all_one_but_one\") {\n\n        fill(s.begin(), s.end(), '1');\n        s[0] = '0';\n\n    } else if (type == \"all_zero\") {\n\n        // All '0's except s[0] == '1' to prevent cycle\n        fill(s.begin(), s.end(), '0');\n        s[0] = '1';\n\n    } else if (type == \"all_one\") {\n\n        // All '1's except s[0] == '0' to prevent cycle\n        fill(s.begin(), s.end(), '1');\n        s[0] = '0';\n\n    } else if (type == \"max_antichain\") {\n\n        // Try to maximize the size of the maximum antichain\n        fill(s.begin(), s.end(), '1');\n        s[0] = '0';\n\n    } else {\n\n        // Default to 'random' if type is unknown\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) ? '1' : '0';\n\n        // Ensure the graph is acyclic\n        int sum = 0;\n        for(char c : s) sum += (c - '0');\n        if (sum == 0 || sum == n) { // Avoid all '0's or all '1's\n            int idx = rnd.next(n);\n            s[idx] = (s[idx] == '0') ? '1' : '0';\n        }\n\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '0');\n\n    if (type == \"random\") {\n\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) ? '1' : '0';\n\n        // Ensure the graph is acyclic\n        int sum = 0;\n        for(char c : s) sum += (c - '0');\n        if (sum == 0 || sum == n) { // All '0's or all '1's\n            int idx = rnd.next(n);\n            s[idx] = (s[idx] == '0') ? '1' : '0';\n        }\n\n    } else if (type == \"single_break\") {\n\n        // All '0's except s[n - 1] == '1'\n        fill(s.begin(), s.end(), '0');\n        s[n - 1] = '1';\n\n    } else if (type == \"double_break\") {\n\n        // All '0's except s[n / 2] == '1' and s[n - 1] == '1'\n        fill(s.begin(), s.end(), '0');\n        s[n / 2] = '1';\n        s[n - 1] = '1';\n\n    } else if (type == \"alternate\") {\n\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '0' : '1';\n        }\n\n    } else if (type == \"all_zero_but_one\") {\n\n        fill(s.begin(), s.end(), '0');\n        s[0] = '1';\n\n    } else if (type == \"all_one_but_one\") {\n\n        fill(s.begin(), s.end(), '1');\n        s[0] = '0';\n\n    } else if (type == \"all_zero\") {\n\n        // All '0's except s[0] == '1' to prevent cycle\n        fill(s.begin(), s.end(), '0');\n        s[0] = '1';\n\n    } else if (type == \"all_one\") {\n\n        // All '1's except s[0] == '0' to prevent cycle\n        fill(s.begin(), s.end(), '1');\n        s[0] = '0';\n\n    } else if (type == \"max_antichain\") {\n\n        // Try to maximize the size of the maximum antichain\n        fill(s.begin(), s.end(), '1');\n        s[0] = '0';\n\n    } else {\n\n        // Default to 'random' if type is unknown\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) ? '1' : '0';\n\n        // Ensure the graph is acyclic\n        int sum = 0;\n        for(char c : s) sum += (c - '0');\n        if (sum == 0 || sum == n) { // Avoid all '0's or all '1's\n            int idx = rnd.next(n);\n            s[idx] = (s[idx] == '0') ? '1' : '0';\n        }\n\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type all_zero_but_one\n./gen -n 2 -type all_one_but_one\n./gen -n 2 -type max_antichain\n./gen -n 5 -type all_zero_but_one\n./gen -n 5 -type all_one_but_one\n./gen -n 5 -type max_antichain\n./gen -n 10 -type random\n./gen -n 10 -type alternate\n./gen -n 10 -type max_antichain\n./gen -n 100 -type random\n./gen -n 100 -type alternate\n./gen -n 100 -type max_antichain\n./gen -n 1000 -type random\n./gen -n 1000 -type single_break\n./gen -n 1000 -type double_break\n./gen -n 1000 -type alternate\n./gen -n 1000 -type max_antichain\n./gen -n 1000000 -type random\n./gen -n 1000000 -type random\n./gen -n 1000000 -type single_break\n./gen -n 1000000 -type double_break\n./gen -n 1000000 -type alternate\n./gen -n 1000000 -type all_zero_but_one\n./gen -n 1000000 -type all_one_but_one\n./gen -n 1000000 -type all_zero\n./gen -n 1000000 -type all_one\n./gen -n 1000000 -type max_antichain\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:01.722202",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "354/A",
      "title": "A. Вася и робот",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится пять целых чисел n, l, r, Ql, Qr (1 ≤ n ≤ 105; 1 ≤ l, r ≤ 100; 1 ≤ Ql, Qr ≤ 104).Во второй строке содержится n целых чисел w1, w2, ..., wn (1 ≤ wi ≤ 100).",
      "output_spec": "Выходные данныеВ единственной строке выведите целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 4 4 19 142 3 99Выходные данныеСкопировать576Входные данныеСкопировать4 7 2 3 91 2 3 4Выходные данныеСкопировать34",
      "description": "A. Вася и робот\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится пять целых чисел n, l, r, Ql, Qr (1 ≤ n ≤ 105; 1 ≤ l, r ≤ 100; 1 ≤ Ql, Qr ≤ 104).Во второй строке содержится n целых чисел w1, w2, ..., wn (1 ≤ wi ≤ 100).\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать3 4 4 19 142 3 99Выходные данныеСкопировать576Входные данныеСкопировать4 7 2 3 91 2 3 4Выходные данныеСкопировать34\n\nВходные данныеСкопировать3 4 4 19 142 3 99\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать576\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 7 2 3 91 2 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать34\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример. Так как l = r, мы можем просто по очереди брать по одному предмету с левой, с правой и потом опять с левой стороны. В итоге будет затрачено 4·42 + 4·99 + 4·3 = 576 единиц энергии.Второй пример. Оптимальное решение — взять один предмет справа, затем один предмет слева и затем два предмета справа. В итоге будет затрачено (2·4) + (7·1) + (2·3) + (2·2 + 9) = 34 единицы энергии.",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Всем привет!Уже скоро, 13 октября в 19:30 MSK состоится Codeforces Round #206. Автором задач являюсь я и это мой первый раунд!За помощь в подготовке хочется поблагодарить координатора задач Геральда Агапова (Gerald), Евгения Вихрова (gen) за тестирование задач и Марию Белову (Delinur) за перевод условий на английский язык. Отдельное спасибо Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Разбалловка стандартная в обоих дивизионах: 500-1000-1500-2000-2500.Желаю всем удачи и очень надеюсь, что Вам понравятся задачи!Поздравляем победителей! Особые поздравления rng_58, единственному участнику, решившему все 5 задач!Первый дивизион: rng_58 sankear VArtem sillycross Endagorion Второй дивизион: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 804
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces",
          "content": "355A - Вася и цифровой кореньЕсли d = 0, то существует всего одно число, что , поэтому, если k = 1, то ответ — 0, иначе — No solution.Если d > 0, то подоходящим числом, к примеру, являтся d × 10k - 1.Асимптотика решения: O(1) + O(k) на вывод решения.355B - Вася и общественный транспортЕсли мы купим билет четвертого типа, то больше ничего покупать не надо, по-этому ответ — min(c4, ответ из билетов первых трех типов).Теперь, когда у нас нету билета четвертого типа, можно решать задачу независимо для автобусов и потом аналогично для троллейбусов.Решая задачу только для автобусов, если мы купим билет третьего типа, то больше покупать ничего не надо, по-этому ответ равен min(c3, ответ из билетов первых двух типов).Без билетов третьего типа можно решать задачу независимо для каждого автобуса. Таким образом, если мы купим билет второго типа, то потратим c2 бурлей, если же купим ai билетов первого типа, то потратим (ai × c1) бурлей. Таким образом, ответ для автобуса i — min(c2, ai × c1).Собрав все вместе несложно получить следующее решение: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Асимптотика решения: O(n + m).354A - Вася и роботПереберем, сколько раз мы будем использовать операцию слева. Путь мы используем ее k раз, тогда понятно, что операциями слева мы заберем k первых предметов, а оставшиеся (n - k) предметов заберем справа. Тогда робот затратит sumLeft[k]·l + sumRight[n - k]·r энергии плюс некоторый штраф за одинаковые операции. Чтобы минимизировать этот штраф операции необходимо выполнять в порядке LRLRL ... RLRLLLLL ..., начиная с тех операций, которых больше. К примеру, если k = 7, n - k = 4, то выполнять операции надо в последовательности LRLRLRLRL LL. Таким образом нам надо будет заплатить штраф два раза (7 - 4 - 1).sumLeft[i] — сумма первых i весов, sumRight[i] — сумма последних i весов.Псевдокод решения: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Асимптотика решения: O(n).354B - Игра со строкамиБудем говорить, что клетка (r, c) соответствует строке s, если существует корректный путь, заканчивающийся в клетке (r, c), которому соответствует строка s.Найдем для строки s множество соответствующий ей клеток, назовем это множество состоянием. Одно состояние может соответствовать множеству разных строк. Перебрать все возможные строки мы не можем, так как их количество — слишком большое, однако перебрать все состояния мы можем. Несложно понять, что все клетки соответствующие одной строке находятся на одной диагонали, таким образом количество различных состояний равно 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). В реализации состояние можно охарактеризовать номером диагонали (от 1 до 2n - 1) и битовой маской клеток, которые в него входят (2n).Из каждого состояния мы можем перейти в 26 различных состояний (на самом деле меньше), причем все возможные переходы зависят именно от состояния, а не от самой строки. На изображении — пример перехода: из состояния, которое выделено синем цветом по букве a мы перейдем в состояние, выделенное желтым цветом.Теперь, подсчитаем для каждого состояния величину (кол-во букв A  -  кол-во букв B) в строке, начиная с этого состояния. Если в данный момент ходит первый игрок (на четной диагонали), то это значение надо максимизировать, если второй (на нечетной диагонали) — минимизировать. Реализовать это несложно в виде рекурсии с мемоизацией.Победителя можно определить по значению состояния, соответствующему клетке (1, 1).Асимптотика: O(2n × (n + alpha)), где alpha — размер алфавита.354C - Вася и красивые массивыВ задаче было необходимо найти максимальное d, такое, что ai ≥ d,  ai mod d ≤ k.Пусть m = min(ai), из условия следует, что d ≤ m. Рассмотрим два случая:. В данном случае переберем ответ от k + 1 до m, проверить, подходит ли число d в качестве ответа можно следующим образом:Нам необходимо проверить, что ai mod d ≤ k при фиксированном d, что равносильно , где . Так как все упомянутые интервалы [x·d..x·d + k] не пересекаются, то достаточно проверить, что , где cnt[l..r] — количество чисел ai в интервале [l..r].Итоговая асимптотика решения: O(maxA log maxA), доказательство основывается на сумме гармонического ряда.354D - Передача пирамидыДанная задача решается динамическим программированием. Рассмотрим для начала решение за O(n3).Пусть dp[i][j] — ответ для выделенной синим цветом на изображении части (минимальная стоимость передачи всех ячеек, которые находятся в синей области). Тогда в dp[n][0] будет содержатся ответ на задачу.Как пересчитывать такую динамику? Понятно, что в самом левом столбце (внутри синей части) мы выберем в качестве вершины подпирамиды максимум одну ячейку. Если мы выберем две, то одна из данных подпирамид будет полностью содержать другую внутри (как синяя подпирамида содержит оранжевую). Теперь, переберем за O(n) ту клеточку, которая будет вершиной подпирамиды и получим следующий переход:Для упрощения формул будем считать, что . 0 ≤ k ≤ i, где k — высота, на которой мы выберем вершину или 0, если в данном столбце не будет выбрана подпирамида, а sumUp[i][p] — количество помеченных клеточек в i-том столбце, на высоте начиная с p, их нам придется передавать по одной операциями первого типа.Можно сократить одну степень, пересчитывая динамику так: 0 ≤ k ≤ i; для всех j > 0.Доказательство того, что это корректно довольно просто и оставляется читателю. :)Также можно заметить, что нам не выгодно брать подпирамиду с высотой больше, чем , так как за нее мы заплатим  > 3k, однако, если передавать все клеточки по одной мы заплатим всего 3k. Таким образом второе измерение (j) в динамике можно сократить до .Также, чтобы получить АС необходимо хранить только два последних слоя динамики, иначе не хватит памяти.Асимптотика решения: .354E - Счастливое представление числаАвторское решение, намного сложнее предложенного участниками во время контеста:Для начала напишем ДП за O(N * lucky_count(N)), где lucky_count(N) — количество счастливых чисел до N, lucky_count(10n) = 3n. Видно, что для всех достаточно больших N решение существует. На самом деле для всех N > 523.Теперь, скажем для чисел  ≤ 10000 у нас есть решение, найденное ДПой. Решим задачу для больших чисел:Следующая и ключевая идея — разделить задачу на две части. N = N1 + N2. Выберем N1 и N2 так, чтобы для них можно было легко найти ответ, а также, найдя 2 решения, было возможно их объеденить в одно. Пусть N1 = N mod 4000, N2 = N - N1. Однако, тут может появиться проблемма с тем, что для N1 нет решения, тогда сделаем N1 = N1 + 4000, N2 = N2 - 4000.Теперь решение гарантированно существует и для N1 и для N2, причем в решении для числа N1 мы будем использовать только числа из не более, чем 3 цифр ( < 1000). Доказательство довольно просто: если N1 < 4000 — то очевидно; иначе — если в решении используется число вида (4000 + some_lucky_number), то заменим его на просто some_lucky_number и получим решение для (N1 - 4000), однако его не существует!Решение для N1 мы нашли при помощи ДП, теперь нам нужно найти решение для N2. Если оно будет использовать только числа вида (some_lucky_number × 1000), то мы сможем легко объеденить его с решением для N1, по-этому будем искать именно такое решение. Тут мы будем использовать тот факт, что N2 делится на 4. Для простоты поделим N2 на 1000, а в конце просто умножим все Ans2(i) на ту же 1000. Пусть P = N2 / 4. Теперь будем конструктивно строить решение. Рассмотрим, к пример, P = 95: идем по цифрам этого числа, последняя цифра — 5, означает, что мы хотим в пяти числах ответа на последнюю позицию (в десятичной записи) поставить цифру 4, хорошо — ставим и в последнем, шестом, числе оставляем на последней позиции 0. Идем дальше, цифра 9 — у нас нету девяти чисел, но мы можем семь четверок заменить на четыре семерки, тогда нам на вторые позиции надо поставить (9 - 7) четверок и 4 семерки, в сумме в 6 чисел, как раз то, что надо.Таким образом, если очередная цифра d ≤ 6, то просто в первые d чисел ответа ставим цифру 4 на очередную позицию, если же d > 6, то в 4 числа ставим цифру 7 и в d - 7 чисел ставим цифру 4. Во всех остальных числах оставляем на данной позиции 0.Если Ans1(i) — ответ для числа N1, Ans2(i) — для числа N2, то ответом для числа N будет просто Ans(i) = Ans1(i) + Ans2(i).Асимптотика решения на одно число: O(logN).Во время контеста многие участники сдали следующее решение:dp[i][j] — можем ли мы расставив цифры на последние i позиций чисел ответа так, чтобы получить верные последние i цифр в сумме и перенос на следующий разряд был равен j. Тогда решение существует, если dp[19][0] = true, чтобы восстановить ответ просто для каждого состояния запоминаем, из какого состояния мы в него пришли. База — dp[0][0] = true. Переход — перебераем, сколько мы поставим четверок и сколько семерок в i-тый разряд.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 354\\s*A"
          },
          "content_length": 8959
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 5",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 6",
          "code": "3\ncca\nccc\ncbc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 7",
          "code": "3\ncca\nccc\ncbc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 8",
          "code": "\\sum\\limits_{k=1}^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 9",
          "code": "for i = 1 to n:\n  for j = i to n step i:\n    append i to divisors[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 10",
          "code": "for i = 1 to n:\n  for j = i to n step i:\n    append i to divisors[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 11",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 12",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 13",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int Ql = inf.readInt(1, 10000, \"Ql\");\n    inf.readSpace();\n    int Qr = inf.readInt(1, 10000, \"Qr\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int Ql = inf.readInt(1, 10000, \"Ql\");\n    inf.readSpace();\n    int Qr = inf.readInt(1, 10000, \"Qr\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int Ql = inf.readInt(1, 10000, \"Ql\");\n    inf.readSpace();\n    int Qr = inf.readInt(1, 10000, \"Qr\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    int Ql = opt<int>(\"Ql\");\n    int Qr = opt<int>(\"Qr\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n\n    vector<int> w(n);\n\n    if (wtype == \"constant\") {\n        int val = opt<int>(\"w\", 1);\n        ensure(1 <= val && val <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = val;\n        }\n    } else if (wtype == \"increasing\") {\n        int min_w = opt<int>(\"min_w\", 1);\n        int max_w = opt<int>(\"max_w\", 100);\n        ensure(1 <= min_w && min_w <= max_w && max_w <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = min_w + i % (max_w - min_w + 1);\n        }\n    } else if (wtype == \"decreasing\") {\n        int min_w = opt<int>(\"min_w\", 1);\n        int max_w = opt<int>(\"max_w\", 100);\n        ensure(1 <= min_w && min_w <= max_w && max_w <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = max_w - i % (max_w - min_w + 1);\n        }\n    } else if (wtype == \"random\") {\n        int min_w = opt<int>(\"min_w\", 1);\n        int max_w = opt<int>(\"max_w\", 100);\n        ensure(1 <= min_w && min_w <= max_w && max_w <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(min_w, max_w);\n        }\n    } else if (wtype == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 100;\n        }\n    } else if (wtype == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 1;\n        }\n    } else if (wtype == \"alternating\") {\n        int val1 = opt<int>(\"w1\", 1);\n        int val2 = opt<int>(\"w2\", 100);\n        ensure(1 <= val1 && val1 <= 100);\n        ensure(1 <= val2 && val2 <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else {\n        // Default case: random weights\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d %d %d\\n\", n, l, r, Ql, Qr);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", w[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    int Ql = opt<int>(\"Ql\");\n    int Qr = opt<int>(\"Qr\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n\n    vector<int> w(n);\n\n    if (wtype == \"constant\") {\n        int val = opt<int>(\"w\", 1);\n        ensure(1 <= val && val <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = val;\n        }\n    } else if (wtype == \"increasing\") {\n        int min_w = opt<int>(\"min_w\", 1);\n        int max_w = opt<int>(\"max_w\", 100);\n        ensure(1 <= min_w && min_w <= max_w && max_w <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = min_w + i % (max_w - min_w + 1);\n        }\n    } else if (wtype == \"decreasing\") {\n        int min_w = opt<int>(\"min_w\", 1);\n        int max_w = opt<int>(\"max_w\", 100);\n        ensure(1 <= min_w && min_w <= max_w && max_w <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = max_w - i % (max_w - min_w + 1);\n        }\n    } else if (wtype == \"random\") {\n        int min_w = opt<int>(\"min_w\", 1);\n        int max_w = opt<int>(\"max_w\", 100);\n        ensure(1 <= min_w && min_w <= max_w && max_w <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(min_w, max_w);\n        }\n    } else if (wtype == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 100;\n        }\n    } else if (wtype == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 1;\n        }\n    } else if (wtype == \"alternating\") {\n        int val1 = opt<int>(\"w1\", 1);\n        int val2 = opt<int>(\"w2\", 100);\n        ensure(1 <= val1 && val1 <= 100);\n        ensure(1 <= val2 && val2 <= 100);\n        for (int i = 0; i < n; ++i) {\n            w[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else {\n        // Default case: random weights\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d %d %d\\n\", n, l, r, Ql, Qr);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", w[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test Case 1: Minimal n\n./gen -n 1 -l 1 -r 1 -Ql 1 -Qr 1 -wtype constant -w 1\n\n# Test Case 2: Maximal n, minimal l, r, Ql, Qr, minimal weights\n./gen -n 100000 -l 1 -r 1 -Ql 1 -Qr 1 -wtype constant -w 1\n\n# Test Case 3: Maximal n, maximal l, r, Ql, Qr, maximal weights\n./gen -n 100000 -l 100 -r 100 -Ql 10000 -Qr 10000 -wtype constant -w 100\n\n# Test Case 4: n = 100000, l < r, Ql < Qr, weights increasing\n./gen -n 100000 -l 1 -r 100 -Ql 1 -Qr 10000 -wtype increasing -min_w 1 -max_w 100\n\n# Test Case 5: n = 100000, l > r, Ql > Qr, weights decreasing\n./gen -n 100000 -l 100 -r 1 -Ql 10000 -Qr 1 -wtype decreasing -min_w 1 -max_w 100\n\n# Test Case 6: n = 100000, l = r = 50, Ql = Qr = 5000, random weights\n./gen -n 100000 -l 50 -r 50 -Ql 5000 -Qr 5000 -wtype random -min_w 1 -max_w 100\n\n# Test Case 7: n = 99999, odd n, alternating weights\n./gen -n 99999 -l 10 -r 10 -Ql 1000 -Qr 1000 -wtype alternating -w1 100 -w2 1\n\n# Test Case 8: n = 100000, l=1, r=100, Ql=10000, Qr=1, random weights\n./gen -n 100000 -l 1 -r 100 -Ql 10000 -Qr 1 -wtype random -min_w 50 -max_w 100\n\n# Test Case 9: n = 2, minimal n where both left and right are possible\n./gen -n 2 -l 10 -r 20 -Ql 100 -Qr 100 -wtype constant -w 50\n\n# Test Case 10: n = 100000, weights are max\n./gen -n 100000 -l 50 -r 50 -Ql 10000 -Qr 10000 -wtype max\n\n# Test Case 11: n = 100000, weights are min\n./gen -n 100000 -l 50 -r 50 -Ql 10000 -Qr 10000 -wtype min\n\n# Test Case 12: n = 50000, l = r, Ql much larger than Qr\n./gen -n 50000 -l 50 -r 50 -Ql 10000 -Qr 1 -wtype random\n\n# Test Case 13: n = 50000, l = r, Ql much smaller than Qr\n./gen -n 50000 -l 50 -r 50 -Ql 1 -Qr 10000 -wtype random\n\n# Test Case 14: n = 100000, l = 100, r = 1, weights are random\n./gen -n 100000 -l 100 -r 1 -Ql 5000 -Qr 5000 -wtype random\n\n# Test Case 15: n = 100000, l = r = 1, Ql = Qr = 10000, weights are random\n./gen -n 100000 -l 1 -r 1 -Ql 10000 -Qr 10000 -wtype random\n\n# Test Case 16: n = 100000, l = r = 100, Ql = Qr = 1, weights are random\n./gen -n 100000 -l 100 -r 100 -Ql 1 -Qr 1 -wtype random\n\n# Test Case 17: n = 100000, weights alternate between max and min\n./gen -n 100000 -l 50 -r 50 -Ql 1000 -Qr 1000 -wtype alternating -w1 1 -w2 100\n\n# Test Case 18: n = 1, l = r = 100, Ql = Qr = 10000, weights = 100\n./gen -n 1 -l 100 -r 100 -Ql 10000 -Qr 10000 -wtype constant -w 100\n\n# Test Case 19: n = 10, l = 10, r = 90, Ql = 100, Qr = 1000, weights increasing\n./gen -n 10 -l 10 -r 90 -Ql 100 -Qr 1000 -wtype increasing\n\n# Test Case 20: n = 10, l = 90, r = 10, Ql = 1000, Qr = 100, weights decreasing\n./gen -n 10 -l 90 -r 10 -Ql 1000 -Qr 100 -wtype decreasing\n\n# Test Case 21: n = 100000, l = 100, r = 100, Ql = 10000, Qr = 10000, weights min\n./gen -n 100000 -l 100 -r 100 -Ql 10000 -Qr 10000 -wtype min\n\n# Test Case 22: n = 100000, l = 1, r = 1, Ql = 1, Qr = 1, weights max\n./gen -n 100000 -l 1 -r 1 -Ql 1 -Qr 1 -wtype max\n\n# Test Case 23: n = 100000, l = 50, r = 50, Ql = 5000, Qr = 5000, weights random mid-range\n./gen -n 100000 -l 50 -r 50 -Ql 5000 -Qr 5000 -wtype random -min_w 45 -max_w 55\n\n# Test Case 24: n = 100, small n, l = r, Ql = Qr, random weights\n./gen -n 100 -l 50 -r 50 -Ql 5000 -Qr 5000 -wtype random\n\n# Test Case 25: n = 100000, l and r non-symmetric, weights random\n./gen -n 100000 -l 25 -r 75 -Ql 2500 -Qr 7500 -wtype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:03.594928",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "354/B",
      "title": "B. Игра со строками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится одно целое число n (1 ≤ n ≤ 20).Следующие n строк содержат по n строчных латинских букв — таблицу T.",
      "output_spec": "Выходные данныеВ единственной строке выведите строку «FIRST», если выиграет первый игрок, «SECOND», если выиграет второй игрок и «DRAW», если игра закончится в ничью.",
      "sample_tests": "ПримерыВходные данныеСкопировать2abcdВыходные данныеСкопироватьDRAWВходные данныеСкопировать2xaayВыходные данныеСкопироватьFIRSTВходные данныеСкопировать3aabbcbbacВыходные данныеСкопироватьDRAW",
      "description": "B. Игра со строками\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится одно целое число n (1 ≤ n ≤ 20).Следующие n строк содержат по n строчных латинских букв — таблицу T.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите строку «FIRST», если выиграет первый игрок, «SECOND», если выиграет второй игрок и «DRAW», если игра закончится в ничью.\n\nВыходные данные\n\nВходные данныеСкопировать2abcdВыходные данныеСкопироватьDRAWВходные данныеСкопировать2xaayВыходные данныеСкопироватьFIRSTВходные данныеСкопировать3aabbcbbacВыходные данныеСкопироватьDRAW\n\nВходные данныеСкопировать2abcd\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьDRAW\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2xaay\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьFIRST\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3aabbcbbac\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьDRAW\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример:Хорошими строками являются: a, ab, ac, abd, acd.Первый игрок в первый ход допишет к строке букву a, так как существует всего одна хорошая строка длины 1. Затем, второй игрок может приписать одну из букв b или c и тогда игра закончится соответственно со строками abd или acd. В первом случае будет ничья (в строке по одной букве a и b), во втором же случае выиграет первый игрок. Понятно, что в таком случае второму игроку выгодно выбрать букву b и получить ничью.Рассмотрим второй пример:Хорошие строки: x, xa, xay.Понятно, что игра закончится со строкой xay и победит первый игрок.",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Всем привет!Уже скоро, 13 октября в 19:30 MSK состоится Codeforces Round #206. Автором задач являюсь я и это мой первый раунд!За помощь в подготовке хочется поблагодарить координатора задач Геральда Агапова (Gerald), Евгения Вихрова (gen) за тестирование задач и Марию Белову (Delinur) за перевод условий на английский язык. Отдельное спасибо Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Разбалловка стандартная в обоих дивизионах: 500-1000-1500-2000-2500.Желаю всем удачи и очень надеюсь, что Вам понравятся задачи!Поздравляем победителей! Особые поздравления rng_58, единственному участнику, решившему все 5 задач!Первый дивизион: rng_58 sankear VArtem sillycross Endagorion Второй дивизион: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 804
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces",
          "content": "355A - Вася и цифровой кореньЕсли d = 0, то существует всего одно число, что , поэтому, если k = 1, то ответ — 0, иначе — No solution.Если d > 0, то подоходящим числом, к примеру, являтся d × 10k - 1.Асимптотика решения: O(1) + O(k) на вывод решения.355B - Вася и общественный транспортЕсли мы купим билет четвертого типа, то больше ничего покупать не надо, по-этому ответ — min(c4, ответ из билетов первых трех типов).Теперь, когда у нас нету билета четвертого типа, можно решать задачу независимо для автобусов и потом аналогично для троллейбусов.Решая задачу только для автобусов, если мы купим билет третьего типа, то больше покупать ничего не надо, по-этому ответ равен min(c3, ответ из билетов первых двух типов).Без билетов третьего типа можно решать задачу независимо для каждого автобуса. Таким образом, если мы купим билет второго типа, то потратим c2 бурлей, если же купим ai билетов первого типа, то потратим (ai × c1) бурлей. Таким образом, ответ для автобуса i — min(c2, ai × c1).Собрав все вместе несложно получить следующее решение: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Асимптотика решения: O(n + m).354A - Вася и роботПереберем, сколько раз мы будем использовать операцию слева. Путь мы используем ее k раз, тогда понятно, что операциями слева мы заберем k первых предметов, а оставшиеся (n - k) предметов заберем справа. Тогда робот затратит sumLeft[k]·l + sumRight[n - k]·r энергии плюс некоторый штраф за одинаковые операции. Чтобы минимизировать этот штраф операции необходимо выполнять в порядке LRLRL ... RLRLLLLL ..., начиная с тех операций, которых больше. К примеру, если k = 7, n - k = 4, то выполнять операции надо в последовательности LRLRLRLRL LL. Таким образом нам надо будет заплатить штраф два раза (7 - 4 - 1).sumLeft[i] — сумма первых i весов, sumRight[i] — сумма последних i весов.Псевдокод решения: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Асимптотика решения: O(n).354B - Игра со строкамиБудем говорить, что клетка (r, c) соответствует строке s, если существует корректный путь, заканчивающийся в клетке (r, c), которому соответствует строка s.Найдем для строки s множество соответствующий ей клеток, назовем это множество состоянием. Одно состояние может соответствовать множеству разных строк. Перебрать все возможные строки мы не можем, так как их количество — слишком большое, однако перебрать все состояния мы можем. Несложно понять, что все клетки соответствующие одной строке находятся на одной диагонали, таким образом количество различных состояний равно 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). В реализации состояние можно охарактеризовать номером диагонали (от 1 до 2n - 1) и битовой маской клеток, которые в него входят (2n).Из каждого состояния мы можем перейти в 26 различных состояний (на самом деле меньше), причем все возможные переходы зависят именно от состояния, а не от самой строки. На изображении — пример перехода: из состояния, которое выделено синем цветом по букве a мы перейдем в состояние, выделенное желтым цветом.Теперь, подсчитаем для каждого состояния величину (кол-во букв A  -  кол-во букв B) в строке, начиная с этого состояния. Если в данный момент ходит первый игрок (на четной диагонали), то это значение надо максимизировать, если второй (на нечетной диагонали) — минимизировать. Реализовать это несложно в виде рекурсии с мемоизацией.Победителя можно определить по значению состояния, соответствующему клетке (1, 1).Асимптотика: O(2n × (n + alpha)), где alpha — размер алфавита.354C - Вася и красивые массивыВ задаче было необходимо найти максимальное d, такое, что ai ≥ d,  ai mod d ≤ k.Пусть m = min(ai), из условия следует, что d ≤ m. Рассмотрим два случая:. В данном случае переберем ответ от k + 1 до m, проверить, подходит ли число d в качестве ответа можно следующим образом:Нам необходимо проверить, что ai mod d ≤ k при фиксированном d, что равносильно , где . Так как все упомянутые интервалы [x·d..x·d + k] не пересекаются, то достаточно проверить, что , где cnt[l..r] — количество чисел ai в интервале [l..r].Итоговая асимптотика решения: O(maxA log maxA), доказательство основывается на сумме гармонического ряда.354D - Передача пирамидыДанная задача решается динамическим программированием. Рассмотрим для начала решение за O(n3).Пусть dp[i][j] — ответ для выделенной синим цветом на изображении части (минимальная стоимость передачи всех ячеек, которые находятся в синей области). Тогда в dp[n][0] будет содержатся ответ на задачу.Как пересчитывать такую динамику? Понятно, что в самом левом столбце (внутри синей части) мы выберем в качестве вершины подпирамиды максимум одну ячейку. Если мы выберем две, то одна из данных подпирамид будет полностью содержать другую внутри (как синяя подпирамида содержит оранжевую). Теперь, переберем за O(n) ту клеточку, которая будет вершиной подпирамиды и получим следующий переход:Для упрощения формул будем считать, что . 0 ≤ k ≤ i, где k — высота, на которой мы выберем вершину или 0, если в данном столбце не будет выбрана подпирамида, а sumUp[i][p] — количество помеченных клеточек в i-том столбце, на высоте начиная с p, их нам придется передавать по одной операциями первого типа.Можно сократить одну степень, пересчитывая динамику так: 0 ≤ k ≤ i; для всех j > 0.Доказательство того, что это корректно довольно просто и оставляется читателю. :)Также можно заметить, что нам не выгодно брать подпирамиду с высотой больше, чем , так как за нее мы заплатим  > 3k, однако, если передавать все клеточки по одной мы заплатим всего 3k. Таким образом второе измерение (j) в динамике можно сократить до .Также, чтобы получить АС необходимо хранить только два последних слоя динамики, иначе не хватит памяти.Асимптотика решения: .354E - Счастливое представление числаАвторское решение, намного сложнее предложенного участниками во время контеста:Для начала напишем ДП за O(N * lucky_count(N)), где lucky_count(N) — количество счастливых чисел до N, lucky_count(10n) = 3n. Видно, что для всех достаточно больших N решение существует. На самом деле для всех N > 523.Теперь, скажем для чисел  ≤ 10000 у нас есть решение, найденное ДПой. Решим задачу для больших чисел:Следующая и ключевая идея — разделить задачу на две части. N = N1 + N2. Выберем N1 и N2 так, чтобы для них можно было легко найти ответ, а также, найдя 2 решения, было возможно их объеденить в одно. Пусть N1 = N mod 4000, N2 = N - N1. Однако, тут может появиться проблемма с тем, что для N1 нет решения, тогда сделаем N1 = N1 + 4000, N2 = N2 - 4000.Теперь решение гарантированно существует и для N1 и для N2, причем в решении для числа N1 мы будем использовать только числа из не более, чем 3 цифр ( < 1000). Доказательство довольно просто: если N1 < 4000 — то очевидно; иначе — если в решении используется число вида (4000 + some_lucky_number), то заменим его на просто some_lucky_number и получим решение для (N1 - 4000), однако его не существует!Решение для N1 мы нашли при помощи ДП, теперь нам нужно найти решение для N2. Если оно будет использовать только числа вида (some_lucky_number × 1000), то мы сможем легко объеденить его с решением для N1, по-этому будем искать именно такое решение. Тут мы будем использовать тот факт, что N2 делится на 4. Для простоты поделим N2 на 1000, а в конце просто умножим все Ans2(i) на ту же 1000. Пусть P = N2 / 4. Теперь будем конструктивно строить решение. Рассмотрим, к пример, P = 95: идем по цифрам этого числа, последняя цифра — 5, означает, что мы хотим в пяти числах ответа на последнюю позицию (в десятичной записи) поставить цифру 4, хорошо — ставим и в последнем, шестом, числе оставляем на последней позиции 0. Идем дальше, цифра 9 — у нас нету девяти чисел, но мы можем семь четверок заменить на четыре семерки, тогда нам на вторые позиции надо поставить (9 - 7) четверок и 4 семерки, в сумме в 6 чисел, как раз то, что надо.Таким образом, если очередная цифра d ≤ 6, то просто в первые d чисел ответа ставим цифру 4 на очередную позицию, если же d > 6, то в 4 числа ставим цифру 7 и в d - 7 чисел ставим цифру 4. Во всех остальных числах оставляем на данной позиции 0.Если Ans1(i) — ответ для числа N1, Ans2(i) — для числа N2, то ответом для числа N будет просто Ans(i) = Ans1(i) + Ans2(i).Асимптотика решения на одно число: O(logN).Во время контеста многие участники сдали следующее решение:dp[i][j] — можем ли мы расставив цифры на последние i позиций чисел ответа так, чтобы получить верные последние i цифр в сумме и перенос на следующий разряд был равен j. Тогда решение существует, если dp[19][0] = true, чтобы восстановить ответ просто для каждого состояния запоминаем, из какого состояния мы в него пришли. База — dp[0][0] = true. Переход — перебераем, сколько мы поставим четверок и сколько семерок в i-тый разряд.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 354\\s*B"
          },
          "content_length": 8959
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 5",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 6",
          "code": "3\ncca\nccc\ncbc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 7",
          "code": "3\ncca\nccc\ncbc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 8",
          "code": "\\sum\\limits_{k=1}^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 9",
          "code": "for i = 1 to n:\n  for j = i to n step i:\n    append i to divisors[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 10",
          "code": "for i = 1 to n:\n  for j = i to n step i:\n    append i to divisors[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 11",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 12",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 13",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == n, \"Line %d must contain exactly %d characters\", i+2, n);\n        for (char c : s) {\n            ensuref(c >= 'a' && c <= 'z', \"All characters must be lowercase English letters\");\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == n, \"Line %d must contain exactly %d characters\", i+2, n);\n        for (char c : s) {\n            ensuref(c >= 'a' && c <= 'z', \"All characters must be lowercase English letters\");\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == n, \"Line %d must contain exactly %d characters\", i+2, n);\n        for (char c : s) {\n            ensuref(c >= 'a' && c <= 'z', \"All characters must be lowercase English letters\");\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(n, 'a'));\n\n    if (type == \"random\") {\n        /* Fill the grid with random lowercase letters */\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z'); // Random lowercase letter\n    } else if (type == \"all_a\") {\n        /* Fill the grid with 'a's */\n        // grid already initialized with 'a's\n    } else if (type == \"all_b\") {\n        /* Fill the grid with 'b's */\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, 'b');\n    } else if (type == \"diag_a\") {\n        /* Fill the diagonal with 'a's, others random */\n        for (int i = 0; i < n; ++i)\n            grid[i][i] = 'a';\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    grid[i][j] = rnd.next('a', 'z');\n    } else if (type == \"diag_b\") {\n        /* Fill the diagonal with 'b's, others random */\n        for (int i = 0; i < n; ++i)\n            grid[i][i] = 'b';\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    grid[i][j] = rnd.next('a', 'z');\n    } else if (type == \"border_a\") {\n        /* Fill the top row and left column with 'a's, others random */\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = 'a';\n            grid[i][0] = 'a';\n        }\n        for (int i = 1; i < n; ++i)\n            for (int j = 1; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z');\n    } else if (type == \"border_b\") {\n        /* Fill the top row and left column with 'b's, others random */\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = 'b';\n            grid[i][0] = 'b';\n        }\n        for (int i = 1; i < n; ++i)\n            for (int j = 1; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z');\n    } else {\n        /* Default: fill the grid with random lowercase letters */\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z'); // Random lowercase letter\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output the grid */\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(n, 'a'));\n\n    if (type == \"random\") {\n        /* Fill the grid with random lowercase letters */\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z'); // Random lowercase letter\n    } else if (type == \"all_a\") {\n        /* Fill the grid with 'a's */\n        // grid already initialized with 'a's\n    } else if (type == \"all_b\") {\n        /* Fill the grid with 'b's */\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, 'b');\n    } else if (type == \"diag_a\") {\n        /* Fill the diagonal with 'a's, others random */\n        for (int i = 0; i < n; ++i)\n            grid[i][i] = 'a';\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    grid[i][j] = rnd.next('a', 'z');\n    } else if (type == \"diag_b\") {\n        /* Fill the diagonal with 'b's, others random */\n        for (int i = 0; i < n; ++i)\n            grid[i][i] = 'b';\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    grid[i][j] = rnd.next('a', 'z');\n    } else if (type == \"border_a\") {\n        /* Fill the top row and left column with 'a's, others random */\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = 'a';\n            grid[i][0] = 'a';\n        }\n        for (int i = 1; i < n; ++i)\n            for (int j = 1; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z');\n    } else if (type == \"border_b\") {\n        /* Fill the top row and left column with 'b's, others random */\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = 'b';\n            grid[i][0] = 'b';\n        }\n        for (int i = 1; i < n; ++i)\n            for (int j = 1; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z');\n    } else {\n        /* Default: fill the grid with random lowercase letters */\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z'); // Random lowercase letter\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output the grid */\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_a\n./gen -n 1 -type all_b\n./gen -n 1 -type random\n\n./gen -n 2 -type all_a\n./gen -n 2 -type all_b\n./gen -n 2 -type random\n./gen -n 2 -type diag_a\n./gen -n 2 -type diag_b\n./gen -n 2 -type border_a\n./gen -n 2 -type border_b\n\n./gen -n 3 -type random\n./gen -n 3 -type diag_a\n./gen -n 3 -type diag_b\n./gen -n 3 -type border_a\n./gen -n 3 -type border_b\n\n./gen -n 5 -type random\n./gen -n 5 -type all_a\n./gen -n 5 -type all_b\n./gen -n 5 -type diag_a\n./gen -n 5 -type diag_b\n./gen -n 5 -type border_a\n./gen -n 5 -type border_b\n\n./gen -n 10 -type random\n./gen -n 10 -type all_a\n./gen -n 10 -type all_b\n./gen -n 10 -type diag_a\n./gen -n 10 -type diag_b\n./gen -n 10 -type border_a\n./gen -n 10 -type border_b\n\n./gen -n 15 -type random\n./gen -n 15 -type diag_a\n./gen -n 15 -type diag_b\n\n./gen -n 20 -type random\n./gen -n 20 -type all_a\n./gen -n 20 -type all_b\n./gen -n 20 -type diag_a\n./gen -n 20 -type diag_b\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:05.282553",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "354/C",
      "title": "C. Vasya and Beautiful Arrays",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 3·105; 1 ≤ k ≤ 106). The second line contains n integers ai (1 ≤ ai ≤ 106) — array a.",
      "output_spec": "OutputIn the single line print a single number — the maximum possible beauty of the resulting array.",
      "sample_tests": "ExamplesInputCopy6 13 6 10 12 13 16OutputCopy3InputCopy5 38 21 52 15 77OutputCopy7",
      "description": "C. Vasya and Beautiful Arrays\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 3·105; 1 ≤ k ≤ 106). The second line contains n integers ai (1 ≤ ai ≤ 106) — array a.\n\nOutputIn the single line print a single number — the maximum possible beauty of the resulting array.\n\nInputCopy6 13 6 10 12 13 16OutputCopy3InputCopy5 38 21 52 15 77OutputCopy7\n\nInputCopy6 13 6 10 12 13 16\n\nOutputCopy3\n\nInputCopy5 38 21 52 15 77\n\nOutputCopy7\n\nNoteIn the first sample we can obtain the array:3 6 9 12 12 15In the second sample we can obtain the next array:7 21 49 14 77",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Hello everyone!Very soon on 13 october at 19:30 MSK will take place Codeforces Round #206. I am author of the problems and it's my first round!I would like to thank problem coordinator Gerald Agapov (Gerald), Evgeny Vihrov (gen) for problem testing and Mary Belova (Delinur) for translation of statements to English. Special thanks to Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Score distribution will be standard in both divisions: 500-1000-1500-2000-2500.I wish good luck for everyone and hope that you will enjoy the problems!Congratulations to the winners! Special congratulations to rng_58, the only participant, who have solved all 5 problems!First division: rng_58 sankear VArtem sillycross Endagorion Second division: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD The editorial has been published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 845
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces",
          "content": "355A - Vasya and Digital RootIf d = 0, the there is the only number with , so, if k = 1, the answer is 0, otherwise — No solution.If d > 0, then one of correct numbers is d × 10k - 1.Time complexity: O(1) + O(k) for the output.355B - Vasya and Public TransportIf we buy a ticket of the fourth type, we don't have to buy anything else, so, the answer is min(c4, answer using tickets of first three types).Now, when we don't have ticket of the fourth type, we can solve the task separately for buses and trolleys.Solving the problem only for buses: if we buy a ticket of the third type, we don't have to buy anything else, so, the answer is min(c3, answer using tickets of first two types).Without tickets of type three, we can solve the problem separately for each bus. If we buy a ticket of the second type, we will spend c2 burles and if we buy ai tickets of the first type, we will spend (ai × c1) burles. So, the answer for bus i is min(c2, ai × c1).Now it is not difficult to obtain the following solution: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Time complexity: O(n + m).354A - Vasya and RobotBrute force how many times we will use operation from the left. So, if we use it k times, then it's clear, that we will take first k items by the left operations and last (n - k) items by the right operations. So, robot will spend sumLeft[k]·l + sumRight[n - k]·r energy plus some penalty for the same operations. To minimize this penalty we should perform the operations in the following order LRLRL ... RLRLLLLL ..., starting from the bigger set. For example, if k = 7, n - k = 4, we should perform operations in this order: LRLRLRLRL LL. So, we will have to pay the penalty two times (7 - 4 - 1).sumLeft[i] — sum of first i weights, sumRight[i] — sum of last i weights.Solution in pseudocode: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Time complexity: O(n).354B - Game with StringsWe will say that cell (r, c) corresponds to a string s, if there exist correct path, which ends in the cell (r, c) and this path corresponds to a string s.Let call a set of cells which corresponds to some string s a state. One state can correspond to different strings. We can't brute force all possible strings, because their count — is too big, but we can brute force all possible states. It's not hard to observe that all cells that corresponds to some string s lies on same diagonal, so the total count of states is 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). In implementation we can denote state with diagonal number (from 1 to 2n - 1) and bitmask of cells corresponding to this state (2n).From each state we can move to 26 different states (actually less) and all possible moves depends on the state, not on the string. On the image you can see an example of move: from state, which is highlighted in blue by letter a we will move to the state, which is highlighted in yellow.Now, for each state we can calculate a value of (count of letters A  -  count of letters B) in the string, starting from this state. If at the moment is first players turn (an even diagonal), we have to maximize this value, otherwise — minimize. It can be implemented as recursion with memoization.The winner can be determined by the value of state, which corresponds to the single cell (1, 1).Complexity: O(2n × (n + alpha)), where alpha is the size of alphabet.354C - Vasya and Beautiful ArraysThe problem was to find greatest d, such that ai ≥ d,  ai mod d ≤ k holds for each i.Let m = min(ai), then d ≤ m. Let consider two cases:. In this case we will brute force answer from k + 1 to m. We can check, if number d is a correct answer in the following way:We have to check that ai mod d ≤ k for some fixed d, which is equals to , where . Since all these intervals [x·d..x·d + k] doesn't intersects each with other, we can just check that , where cnt[l..r] — count of numbers ai in the interval [l..r].Time complexity: O(maxA log maxA), proof is based on the sum of harmonic series.354D - Transferring PyramidThis tasks is solvable with dynamic programming. First of all let consider solution with complexity O(n3).Let dp[i][j] be the answer for the highlighted in blue part (minimal cost of transferring all special cells that lies inside this area). Then dp[n][0] will be the answer for our original problem.How to recalculate such DP? It's clear that in the leftmost column (inside the blue area) we will choose at most one cell as the top of some subpyramid. If we choose two, then the smallest one will lie fully inside the biggest one (as the orange subpyramid lies inside the blue one). Now, let brute force the cell, which will be the top of subpyramid in this column in time O(n) and we will obtain the following transition:To simplify the formulas, let assume that . 0 ≤ k ≤ i, where k is the height on which we will choose our top cell, or 0, if we don't choose any subpyramid in this column. sumUp[i][p] — count of special cells in the i-th column at height starting from p, this cells we will have to transfer one by one, using the first type operations.We can reduce the complexity by one n, if we will recalculate out DP in the following way: 0 ≤ k ≤ i; for all j > 0.The proof that this is correct is quite simple and is left to the reader. :)Also, we can observe that it is not profitably to take some subpyramid with height greater than , because for such subpyramid we will pay  > 3k, but if we transfer all cells using the first type operations we will pay only 3k. So, the second dimension (j) in out DP can be reduced to .Also, to receive AC, you should store only last 2 layers of the DP, otherwise there will be not enough memory.Time complexity: .354E - Lucky Number RepresentationAuthor's solution, much more complicated than suggested by many participants during the competition, easy solution will be described below.First of all, let write a DP with complexity O(N * lucky_count(N)), where lucky_count(N) is the count of lucky numbers  ≤ N, lucky_count(10n) = 3n. As we can see, for all sufficiently large N solution exists. Really — for every N > 523.Now, we can say that for N ≤ 10000 we have a solution, which is found using DP. Let's solve the task for larger values of N.Next and key idea is to separate the task into two parts: N = N1 + N2. Let's choose N1 and N2 in such way that for them it was easy to find a solution and then merge these two solutions into one. Let N1 = N mod 4000, N2 = N - N1. Here we can have a problem that there is no solution for number N1, in this case we can do N1 = N1 + 4000, N2 = N2 - 4000.Now it is guaranteed that solutions exists for both N1 and N2, moreover, the solution for number N1 will contain only numbers of not more than 3 digits ( < 1000). The proof is quite easy: if N1 < 4000 — it is obvious; else — if the solution uses some number of the form (4000 + some_lucky_number), we can replace it with just some_lucky_number and receive a correct solution for number (N1 - 4000), but is doesn't exist!So, the solution for number N1 we have found using DP, now let's find the solution for N2. If it will contains only of numbers of the form (some_lucky_number × 1000), then we will be able to easily merge this solution with solution for N1, so, let's find such a solution. Here we will use the fact that N2 is divisible by 4. For simplicity, let's divide N2 by 1000 and in the end multiply all Ans2(i) by the same 1000. Let P = N2 / 4. Now, let's construct the solution. Consider, for example, P = 95: we will walk through digits of this number, last digit — 5, means that we want to put digit 4 at the last decimal position of five answer numbers — ok, put it and in the last, sixth, number leave there digit 0. Go forward, digit 9 — we don't have nine numbers, but we can replace seven fours with four sevens, then to the second position we have to put (9 - 7) fours and 4 sevens, in total — 6 numbers, exactly as much as we have.Thus, if next digit d ≤ 6, we just put to the first d answer numbers digit 4 to the next position; if d > 6, then we put 4 sevens and (d - 7) fours. In all other numbers we just leave digit 0 at this position.If Ans1(i) — answer for N1, Ans2(i) — for N2, the the answer for N will be just Ans(i) = Ans1(i) + Ans2(i).Time complexity for one number: O(logN).During the competition many participants have wrote the following solution:dp[i][j] — can we put the digit to the last i decimal positions of the answer number in such way that we will get correct last i digits in the sum and with carry to the next position equals to j. Then the solution exist iff dp[19][0] = true. To restore the answer we just have to remember for each state the previous state. Base — dp[0][0] = true. Transition — brute force how many fours and sevens we will put to the i-th position.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 354\\s*C"
          },
          "content_length": 9015
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 5",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 6",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 7",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random ai in [1, 1e6]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"max_ai\") {\n        // All ai are maximum (1e6)\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000;\n        }\n    }\n    else if (type == \"min_ai\") {\n        // All ai are minimum (1)\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    }\n    else if (type == \"same_gcd\") {\n        // All ai are multiples of g\n        int g = opt<int>(\"g\", rnd.next(1, 1000000));\n        for (int i = 0; i < n; ++i) {\n            int mult = rnd.next(1, 1000000 / g);\n            a[i] = g * mult;\n        }\n    }\n    else if (type == \"all_equal\") {\n        // All ai are equal to a random value in [1, 1e6]\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    }\n    else if (type == \"decreasing\") {\n        // ai is a decreasing sequence starting from 1e6\n        a[0] = 1000000;\n        for (int i = 1; i < n; ++i) {\n            int decrement = rnd.next(0, min(a[i - 1] - 1, 100000));\n            a[i] = a[i - 1] - decrement;\n            if (a[i] < 1) a[i] = 1;\n        }\n    }\n    else if (type == \"increasing\") {\n        // ai is an increasing sequence starting from a small number\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            int increment = rnd.next(0, 100000);\n            a[i] = a[i - 1] + increment;\n            if (a[i] > 1000000) a[i] = 1000000;\n        }\n    }\n    else if (type == \"near_k\") {\n        // ai values are around k + 1, testing the lower bounds after decreasing by k\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(k + 1, k + 10);\n        }\n    }\n    else if (type == \"large_values\") {\n        // ai values are large, near 1e6\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000 - min(k, 1000000), 1000000);\n        }\n    }\n    else if (type == \"small_values\") {\n        // ai values are small, up to k\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, min(1000000, k));\n        }\n    }\n    else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random ai in [1, 1e6]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n    else if (type == \"max_ai\") {\n        // All ai are maximum (1e6)\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000;\n        }\n    }\n    else if (type == \"min_ai\") {\n        // All ai are minimum (1)\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    }\n    else if (type == \"same_gcd\") {\n        // All ai are multiples of g\n        int g = opt<int>(\"g\", rnd.next(1, 1000000));\n        for (int i = 0; i < n; ++i) {\n            int mult = rnd.next(1, 1000000 / g);\n            a[i] = g * mult;\n        }\n    }\n    else if (type == \"all_equal\") {\n        // All ai are equal to a random value in [1, 1e6]\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    }\n    else if (type == \"decreasing\") {\n        // ai is a decreasing sequence starting from 1e6\n        a[0] = 1000000;\n        for (int i = 1; i < n; ++i) {\n            int decrement = rnd.next(0, min(a[i - 1] - 1, 100000));\n            a[i] = a[i - 1] - decrement;\n            if (a[i] < 1) a[i] = 1;\n        }\n    }\n    else if (type == \"increasing\") {\n        // ai is an increasing sequence starting from a small number\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            int increment = rnd.next(0, 100000);\n            a[i] = a[i - 1] + increment;\n            if (a[i] > 1000000) a[i] = 1000000;\n        }\n    }\n    else if (type == \"near_k\") {\n        // ai values are around k + 1, testing the lower bounds after decreasing by k\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(k + 1, k + 10);\n        }\n    }\n    else if (type == \"large_values\") {\n        // ai values are large, near 1e6\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000 - min(k, 1000000), 1000000);\n        }\n    }\n    else if (type == \"small_values\") {\n        // ai values are small, up to k\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, min(1000000, k));\n        }\n    }\n    else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type min_ai\n./gen -n 1 -k 1 -type max_ai\n./gen -n 2 -k 1 -type random\n\n./gen -n 3 -k 1000000 -type same_gcd -g 1\n./gen -n 3 -k 1000000 -type all_equal\n\n./gen -n 10 -k 100000 -type increasing\n./gen -n 10 -k 100000 -type decreasing\n\n./gen -n 100 -k 1000000 -type random\n./gen -n 100 -k 500000 -type large_values\n./gen -n 100 -k 1 -type small_values\n\n./gen -n 1000 -k 1000000 -type same_gcd -g 10000\n./gen -n 1000 -k 1000000 -type all_equal\n\n./gen -n 10000 -k 1000000 -type random\n./gen -n 10000 -k 1 -type near_k\n\n./gen -n 100000 -k 1000000 -type random\n./gen -n 100000 -k 1 -type random\n\n./gen -n 300000 -k 1000000 -type random\n./gen -n 300000 -k 1 -type random\n./gen -n 300000 -k 1000000 -type same_gcd -g 1\n./gen -n 300000 -k 1 -type same_gcd -g 2\n\n./gen -n 300000 -k 1000000 -type increasing\n./gen -n 300000 -k 1 -type decreasing\n./gen -n 300000 -k 500000 -type near_k\n\n./gen -n 1 -k 1000000 -type max_ai\n./gen -n 3 -k 1000000 -type min_ai\n\n./gen -n 300000 -k 1000000 -type large_values\n./gen -n 300000 -k 1 -type small_values\n\n./gen -n 300000 -k 500000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:06.968358",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "354/D",
      "title": "Problem 354/D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < k; i++) {\n        int r = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int c = inf.readInt(1, r, \"ci\");\n        inf.readEoln();\n\n        ensuref(cells.insert({r, c}).second, \"Cell (%d, %d) appears multiple times\", r, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < k; i++) {\n        int r = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int c = inf.readInt(1, r, \"ci\");\n        inf.readEoln();\n\n        ensuref(cells.insert({r, c}).second, \"Cell (%d, %d) appears multiple times\", r, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < k; i++) {\n        int r = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int c = inf.readInt(1, r, \"ci\");\n        inf.readEoln();\n\n        ensuref(cells.insert({r, c}).second, \"Cell (%d, %d) appears multiple times\", r, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure k does not exceed the total number of cells\n    long long total_cells = 1LL * n * (n + 1) / 2;\n    k = min(k, (int)total_cells);\n\n    set<pair<int, int>> cells; // To ensure all cells are distinct\n\n    if (type == \"random\") {\n        // Generate k random distinct cells\n        while ((int)cells.size() < k) {\n            int ri = rnd.next(1, n);\n            int ci = rnd.next(1, ri);\n            cells.emplace(ri, ci);\n        }\n    } else if (type == \"first_row\") {\n        // All modifications in the first row\n        n = max(n, 1);\n        k = min(k, 1); // First row has only one cell\n        cells.emplace(1, 1);\n    } else if (type == \"last_row\") {\n        // All modifications in the last row\n        n = max(n, 1);\n        k = min(k, n); // Last row has n cells\n        for (int ci = 1; ci <= k; ci++) {\n            cells.emplace(n, ci);\n        }\n    } else if (type == \"diagonal\") {\n        // Modify cells where ri == ci (the main diagonal)\n        int max_k = min(n, k);\n        for (int i = 1; i <= max_k; i++) {\n            cells.emplace(i, i);\n        }\n    } else if (type == \"left_edge\") {\n        // All cells along the left edge (ci = 1)\n        int max_k = min(n, k);\n        for (int ri = 1; ri <= max_k; ri++) {\n            cells.emplace(ri, 1);\n        }\n    } else if (type == \"right_edge\") {\n        // All cells along the right edge (ci = ri)\n        int max_k = min(n, k);\n        for (int ri = 1; ri <= max_k; ri++) {\n            cells.emplace(ri, ri);\n        }\n    } else if (type == \"full_pyramid\") {\n        // Modify all cells up to the limit of k\n        for (int ri = 1; ri <= n && (int)cells.size() < k; ri++) {\n            for (int ci = 1; ci <= ri && (int)cells.size() < k; ci++) {\n                cells.emplace(ri, ci);\n            }\n        }\n    } else if (type == \"small_n\") {\n        // Small n and k\n        n = min(n, 10);\n        k = min(k, (int)(1LL * n * (n + 1) / 2));\n        while ((int)cells.size() < k) {\n            int ri = rnd.next(1, n);\n            int ci = rnd.next(1, ri);\n            cells.emplace(ri, ci);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        while ((int)cells.size() < k) {\n            int ri = rnd.next(1, n);\n            int ci = rnd.next(1, ri);\n            cells.emplace(ri, ci);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, (int)cells.size());\n    for (const auto& p : cells) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure k does not exceed the total number of cells\n    long long total_cells = 1LL * n * (n + 1) / 2;\n    k = min(k, (int)total_cells);\n\n    set<pair<int, int>> cells; // To ensure all cells are distinct\n\n    if (type == \"random\") {\n        // Generate k random distinct cells\n        while ((int)cells.size() < k) {\n            int ri = rnd.next(1, n);\n            int ci = rnd.next(1, ri);\n            cells.emplace(ri, ci);\n        }\n    } else if (type == \"first_row\") {\n        // All modifications in the first row\n        n = max(n, 1);\n        k = min(k, 1); // First row has only one cell\n        cells.emplace(1, 1);\n    } else if (type == \"last_row\") {\n        // All modifications in the last row\n        n = max(n, 1);\n        k = min(k, n); // Last row has n cells\n        for (int ci = 1; ci <= k; ci++) {\n            cells.emplace(n, ci);\n        }\n    } else if (type == \"diagonal\") {\n        // Modify cells where ri == ci (the main diagonal)\n        int max_k = min(n, k);\n        for (int i = 1; i <= max_k; i++) {\n            cells.emplace(i, i);\n        }\n    } else if (type == \"left_edge\") {\n        // All cells along the left edge (ci = 1)\n        int max_k = min(n, k);\n        for (int ri = 1; ri <= max_k; ri++) {\n            cells.emplace(ri, 1);\n        }\n    } else if (type == \"right_edge\") {\n        // All cells along the right edge (ci = ri)\n        int max_k = min(n, k);\n        for (int ri = 1; ri <= max_k; ri++) {\n            cells.emplace(ri, ri);\n        }\n    } else if (type == \"full_pyramid\") {\n        // Modify all cells up to the limit of k\n        for (int ri = 1; ri <= n && (int)cells.size() < k; ri++) {\n            for (int ci = 1; ci <= ri && (int)cells.size() < k; ci++) {\n                cells.emplace(ri, ci);\n            }\n        }\n    } else if (type == \"small_n\") {\n        // Small n and k\n        n = min(n, 10);\n        k = min(k, (int)(1LL * n * (n + 1) / 2));\n        while ((int)cells.size() < k) {\n            int ri = rnd.next(1, n);\n            int ci = rnd.next(1, ri);\n            cells.emplace(ri, ci);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        while ((int)cells.size() < k) {\n            int ri = rnd.next(1, n);\n            int ci = rnd.next(1, ri);\n            cells.emplace(ri, ci);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, (int)cells.size());\n    for (const auto& p : cells) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and k, random modifications\n./gen -n 1 -k 1 -type random\n./gen -n 2 -k 1 -type random\n./gen -n 3 -k 3 -type random\n./gen -n 5 -k 10 -type random\n./gen -n 10 -k 15 -type random\n\n# Small n and k, full pyramid modifications\n./gen -n 5 -type full_pyramid\n./gen -n 10 -type full_pyramid\n\n# Medium n and k, random modifications\n./gen -n 100 -k 50 -type random\n./gen -n 1000 -k 500 -type random\n./gen -n 1000 -k 1000 -type random\n\n# Maximum n and k, random modifications\n./gen -n 100000 -k 100000 -type random\n./gen -n 100000 -k 100000 -type max_n\n\n# Modifications only in the first row\n./gen -n 1 -k 1 -type first_row\n./gen -n 1000 -k 1 -type first_row\n./gen -n 100000 -k 1 -type first_row\n\n# Modifications only in the last row\n./gen -n 1 -k 1 -type last_row\n./gen -n 1000 -k 1000 -type last_row\n./gen -n 100000 -k 100000 -type last_row\n\n# Modifications along the main diagonal\n./gen -n 1 -k 1 -type diagonal\n./gen -n 1000 -type diagonal\n./gen -n 100000 -k 100000 -type diagonal\n\n# Modifications along the left edge\n./gen -n 1000 -type left_edge\n./gen -n 100000 -k 100000 -type left_edge\n\n# Modifications along the right edge\n./gen -n 1000 -type right_edge\n./gen -n 100000 -k 100000 -type right_edge\n\n# Full pyramid modifications up to k\n./gen -n 447 -type full_pyramid  # Since 447*448/2 ≈ 100000\n./gen -n 1000 -k 100000 -type full_pyramid\n\n# Small n, large k (testing limit of total cells)\n./gen -n 10 -k 55 -type full_pyramid  # 10*11/2 = 55 total cells\n\n# Edge cases with random modifications\n./gen -n 1000 -k 100000 -type random   # k exceeds total cells; should adjust k\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 99999 -type random\n\n# Random modifications with specific n and k\n./gen -n 93567 -k 100000 -type random\n./gen -n 12345 -k 54321 -type random\n./gen -n 78901 -k 9876 -type random\n\n# Small n tests\n./gen -n 5 -k 15 -type full_pyramid\n./gen -n 10 -k 20 -type small_n\n\n# Maximum size tests\n./gen -n 100000 -k 100000 -type full_pyramid\n./gen -n 100000 -k 100000 -type left_edge\n./gen -n 100000 -k 100000 -type right_edge\n\n# Random modifications with varying k\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 99999 -type random\n./gen -n 100000 -k 12345 -type random\n\n# Testing adjustments in k when it exceeds total cells\n./gen -n 500 -k 500000 -type full_pyramid  # Total cells are less than k\n./gen -n 1000 -k 1000000 -type random     # Total cells are less than k\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:08.655742",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "354/E",
      "title": "E. Счастливое представление числа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано целое число t (1 ≤ t ≤ 5000).Следующие t строк содержат по одному целому положительному числу ni (1 ≤ ni ≤ 1018) — список важных чисел.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64 битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите t строк; i-тая строка должна содержать ответ для i-того важного числа: если решение существует — строка должна содержать ровно шесть счастливых чисел, сумма которых равна ni, если решения не существует — строка должна содержать одно число -1.Если решений несколько разрешается вывести любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать54217444751Выходные данныеСкопировать7 7 7 7 7 7-1400 0 40 0 4 07 0 0 0 0 047 4 0 0 0 0",
      "description": "E. Счастливое представление числа\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано целое число t (1 ≤ t ≤ 5000).Следующие t строк содержат по одному целому положительному числу ni (1 ≤ ni ≤ 1018) — список важных чисел.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64 битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите t строк; i-тая строка должна содержать ответ для i-того важного числа: если решение существует — строка должна содержать ровно шесть счастливых чисел, сумма которых равна ni, если решения не существует — строка должна содержать одно число -1.Если решений несколько разрешается вывести любое.\n\nВыходные данные\n\nВходные данныеСкопировать54217444751Выходные данныеСкопировать7 7 7 7 7 7-1400 0 40 0 4 07 0 0 0 0 047 4 0 0 0 0\n\nВходные данныеСкопировать54217444751\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7 7 7 7 7 7-1400 0 40 0 4 07 0 0 0 0 047 4 0 0 0 0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Всем привет!Уже скоро, 13 октября в 19:30 MSK состоится Codeforces Round #206. Автором задач являюсь я и это мой первый раунд!За помощь в подготовке хочется поблагодарить координатора задач Геральда Агапова (Gerald), Евгения Вихрова (gen) за тестирование задач и Марию Белову (Delinur) за перевод условий на английский язык. Отдельное спасибо Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Разбалловка стандартная в обоих дивизионах: 500-1000-1500-2000-2500.Желаю всем удачи и очень надеюсь, что Вам понравятся задачи!Поздравляем победителей! Особые поздравления rng_58, единственному участнику, решившему все 5 задач!Первый дивизион: rng_58 sankear VArtem sillycross Endagorion Второй дивизион: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 804
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces",
          "content": "355A - Вася и цифровой кореньЕсли d = 0, то существует всего одно число, что , поэтому, если k = 1, то ответ — 0, иначе — No solution.Если d > 0, то подоходящим числом, к примеру, являтся d × 10k - 1.Асимптотика решения: O(1) + O(k) на вывод решения.355B - Вася и общественный транспортЕсли мы купим билет четвертого типа, то больше ничего покупать не надо, по-этому ответ — min(c4, ответ из билетов первых трех типов).Теперь, когда у нас нету билета четвертого типа, можно решать задачу независимо для автобусов и потом аналогично для троллейбусов.Решая задачу только для автобусов, если мы купим билет третьего типа, то больше покупать ничего не надо, по-этому ответ равен min(c3, ответ из билетов первых двух типов).Без билетов третьего типа можно решать задачу независимо для каждого автобуса. Таким образом, если мы купим билет второго типа, то потратим c2 бурлей, если же купим ai билетов первого типа, то потратим (ai × c1) бурлей. Таким образом, ответ для автобуса i — min(c2, ai × c1).Собрав все вместе несложно получить следующее решение: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Асимптотика решения: O(n + m).354A - Вася и роботПереберем, сколько раз мы будем использовать операцию слева. Путь мы используем ее k раз, тогда понятно, что операциями слева мы заберем k первых предметов, а оставшиеся (n - k) предметов заберем справа. Тогда робот затратит sumLeft[k]·l + sumRight[n - k]·r энергии плюс некоторый штраф за одинаковые операции. Чтобы минимизировать этот штраф операции необходимо выполнять в порядке LRLRL ... RLRLLLLL ..., начиная с тех операций, которых больше. К примеру, если k = 7, n - k = 4, то выполнять операции надо в последовательности LRLRLRLRL LL. Таким образом нам надо будет заплатить штраф два раза (7 - 4 - 1).sumLeft[i] — сумма первых i весов, sumRight[i] — сумма последних i весов.Псевдокод решения: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Асимптотика решения: O(n).354B - Игра со строкамиБудем говорить, что клетка (r, c) соответствует строке s, если существует корректный путь, заканчивающийся в клетке (r, c), которому соответствует строка s.Найдем для строки s множество соответствующий ей клеток, назовем это множество состоянием. Одно состояние может соответствовать множеству разных строк. Перебрать все возможные строки мы не можем, так как их количество — слишком большое, однако перебрать все состояния мы можем. Несложно понять, что все клетки соответствующие одной строке находятся на одной диагонали, таким образом количество различных состояний равно 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). В реализации состояние можно охарактеризовать номером диагонали (от 1 до 2n - 1) и битовой маской клеток, которые в него входят (2n).Из каждого состояния мы можем перейти в 26 различных состояний (на самом деле меньше), причем все возможные переходы зависят именно от состояния, а не от самой строки. На изображении — пример перехода: из состояния, которое выделено синем цветом по букве a мы перейдем в состояние, выделенное желтым цветом.Теперь, подсчитаем для каждого состояния величину (кол-во букв A  -  кол-во букв B) в строке, начиная с этого состояния. Если в данный момент ходит первый игрок (на четной диагонали), то это значение надо максимизировать, если второй (на нечетной диагонали) — минимизировать. Реализовать это несложно в виде рекурсии с мемоизацией.Победителя можно определить по значению состояния, соответствующему клетке (1, 1).Асимптотика: O(2n × (n + alpha)), где alpha — размер алфавита.354C - Вася и красивые массивыВ задаче было необходимо найти максимальное d, такое, что ai ≥ d,  ai mod d ≤ k.Пусть m = min(ai), из условия следует, что d ≤ m. Рассмотрим два случая:. В данном случае переберем ответ от k + 1 до m, проверить, подходит ли число d в качестве ответа можно следующим образом:Нам необходимо проверить, что ai mod d ≤ k при фиксированном d, что равносильно , где . Так как все упомянутые интервалы [x·d..x·d + k] не пересекаются, то достаточно проверить, что , где cnt[l..r] — количество чисел ai в интервале [l..r].Итоговая асимптотика решения: O(maxA log maxA), доказательство основывается на сумме гармонического ряда.354D - Передача пирамидыДанная задача решается динамическим программированием. Рассмотрим для начала решение за O(n3).Пусть dp[i][j] — ответ для выделенной синим цветом на изображении части (минимальная стоимость передачи всех ячеек, которые находятся в синей области). Тогда в dp[n][0] будет содержатся ответ на задачу.Как пересчитывать такую динамику? Понятно, что в самом левом столбце (внутри синей части) мы выберем в качестве вершины подпирамиды максимум одну ячейку. Если мы выберем две, то одна из данных подпирамид будет полностью содержать другую внутри (как синяя подпирамида содержит оранжевую). Теперь, переберем за O(n) ту клеточку, которая будет вершиной подпирамиды и получим следующий переход:Для упрощения формул будем считать, что . 0 ≤ k ≤ i, где k — высота, на которой мы выберем вершину или 0, если в данном столбце не будет выбрана подпирамида, а sumUp[i][p] — количество помеченных клеточек в i-том столбце, на высоте начиная с p, их нам придется передавать по одной операциями первого типа.Можно сократить одну степень, пересчитывая динамику так: 0 ≤ k ≤ i; для всех j > 0.Доказательство того, что это корректно довольно просто и оставляется читателю. :)Также можно заметить, что нам не выгодно брать подпирамиду с высотой больше, чем , так как за нее мы заплатим  > 3k, однако, если передавать все клеточки по одной мы заплатим всего 3k. Таким образом второе измерение (j) в динамике можно сократить до .Также, чтобы получить АС необходимо хранить только два последних слоя динамики, иначе не хватит памяти.Асимптотика решения: .354E - Счастливое представление числаАвторское решение, намного сложнее предложенного участниками во время контеста:Для начала напишем ДП за O(N * lucky_count(N)), где lucky_count(N) — количество счастливых чисел до N, lucky_count(10n) = 3n. Видно, что для всех достаточно больших N решение существует. На самом деле для всех N > 523.Теперь, скажем для чисел  ≤ 10000 у нас есть решение, найденное ДПой. Решим задачу для больших чисел:Следующая и ключевая идея — разделить задачу на две части. N = N1 + N2. Выберем N1 и N2 так, чтобы для них можно было легко найти ответ, а также, найдя 2 решения, было возможно их объеденить в одно. Пусть N1 = N mod 4000, N2 = N - N1. Однако, тут может появиться проблемма с тем, что для N1 нет решения, тогда сделаем N1 = N1 + 4000, N2 = N2 - 4000.Теперь решение гарантированно существует и для N1 и для N2, причем в решении для числа N1 мы будем использовать только числа из не более, чем 3 цифр ( < 1000). Доказательство довольно просто: если N1 < 4000 — то очевидно; иначе — если в решении используется число вида (4000 + some_lucky_number), то заменим его на просто some_lucky_number и получим решение для (N1 - 4000), однако его не существует!Решение для N1 мы нашли при помощи ДП, теперь нам нужно найти решение для N2. Если оно будет использовать только числа вида (some_lucky_number × 1000), то мы сможем легко объеденить его с решением для N1, по-этому будем искать именно такое решение. Тут мы будем использовать тот факт, что N2 делится на 4. Для простоты поделим N2 на 1000, а в конце просто умножим все Ans2(i) на ту же 1000. Пусть P = N2 / 4. Теперь будем конструктивно строить решение. Рассмотрим, к пример, P = 95: идем по цифрам этого числа, последняя цифра — 5, означает, что мы хотим в пяти числах ответа на последнюю позицию (в десятичной записи) поставить цифру 4, хорошо — ставим и в последнем, шестом, числе оставляем на последней позиции 0. Идем дальше, цифра 9 — у нас нету девяти чисел, но мы можем семь четверок заменить на четыре семерки, тогда нам на вторые позиции надо поставить (9 - 7) четверок и 4 семерки, в сумме в 6 чисел, как раз то, что надо.Таким образом, если очередная цифра d ≤ 6, то просто в первые d чисел ответа ставим цифру 4 на очередную позицию, если же d > 6, то в 4 числа ставим цифру 7 и в d - 7 чисел ставим цифру 4. Во всех остальных числах оставляем на данной позиции 0.Если Ans1(i) — ответ для числа N1, Ans2(i) — для числа N2, то ответом для числа N будет просто Ans(i) = Ans1(i) + Ans2(i).Асимптотика решения на одно число: O(logN).Во время контеста многие участники сдали следующее решение:dp[i][j] — можем ли мы расставив цифры на последние i позиций чисел ответа так, чтобы получить верные последние i цифр в сумме и перенос на следующий разряд был равен j. Тогда решение существует, если dp[19][0] = true, чтобы восстановить ответ просто для каждого состояния запоминаем, из какого состояния мы в него пришли. База — dp[0][0] = true. Переход — перебераем, сколько мы поставим четверок и сколько семерок в i-тый разряд.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 354\\s*E"
          },
          "content_length": 8959
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 5",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 6",
          "code": "3\ncca\nccc\ncbc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 7",
          "code": "3\ncca\nccc\ncbc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 8",
          "code": "\\sum\\limits_{k=1}^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 9",
          "code": "for i = 1 to n:\n  for j = i to n step i:\n    append i to divisors[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 10",
          "code": "for i = 1 to n:\n  for j = i to n step i:\n    append i to divisors[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 11",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 12",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #206 - Codeforces - Code 13",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        long long ni = inf.readLong(1LL, 1000000000000000000LL, \"ni\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        long long ni = inf.readLong(1LL, 1000000000000000000LL, \"ni\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        long long ni = inf.readLong(1LL, 1000000000000000000LL, \"ni\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_NI = 1000000000000000000LL;\n\nvector<long long> n;\n\nbool isLucky(long long x) {\n    if (x == 0) return true; // 0 is considered a lucky number\n    while (x > 0) {\n        int d = x % 10;\n        if (d != 0 && d != 4 && d != 7) return false;\n        x /= 10;\n    }\n    return true;\n}\n\nint readAnswer(InStream& stream, long long n_i, int test_case_index) {\n    string line = stream.readLine();\n\n    if (line == \"-1\") {\n        return -1;\n    }\n\n    vector<long long> numbers;\n    istringstream iss(line);\n    string token;\n    while (iss >> token) {\n        if (numbers.size() >= 6) {\n            stream.quitf(_wa, \"For test case %d, more than 6 numbers provided\", test_case_index + 1);\n        }\n\n        long long x;\n        try {\n            x = stoll(token);\n        } catch (...) {\n            stream.quitf(_wa, \"For test case %d, token '%s' is not a valid integer\", test_case_index + 1, token.c_str());\n        }\n        if (x < 0) {\n            stream.quitf(_wa, \"For test case %d, number '%s' is negative\", test_case_index + 1, token.c_str());\n        }\n        if (x > MAX_NI) {\n            stream.quitf(_wa, \"For test case %d, number '%s' is too large\", test_case_index + 1, token.c_str());\n        }\n        if (!isLucky(x)) {\n            stream.quitf(_wa, \"For test case %d, number '%lld' is not a lucky number\", test_case_index + 1, x);\n        }\n        numbers.push_back(x);\n    }\n\n    if (numbers.size() != 6) {\n        stream.quitf(_wa, \"For test case %d, expected 6 numbers or -1, but got %d numbers\", test_case_index + 1, (int)numbers.size());\n    }\n\n    long long sum_numbers = 0;\n    for (int i = 0; i < 6; ++i) {\n        sum_numbers += numbers[i];\n    }\n    if (sum_numbers != n_i) {\n        stream.quitf(_wa, \"For test case %d, sum of numbers %lld does not equal required sum %lld\", test_case_index + 1, sum_numbers, n_i);\n    }\n\n    return 0; // Indicate that everything is fine\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int t = inf.readInt(1, 5000, \"t\");\n    n.resize(t);\n    for (int i = 0; i < t; ++i) {\n        n[i] = inf.readLong(1LL, MAX_NI, format(\"n[%d]\", i + 1).c_str());\n    }\n\n    for (int i = 0; i < t; ++i) {\n        long long n_i = n[i];\n        int jury_ret = readAnswer(ans, n_i, i);\n        int cont_ret = readAnswer(ouf, n_i, i);\n\n        if (jury_ret == -1 && cont_ret == -1) {\n            // Both agree that no solution exists\n            continue;\n        } else if (jury_ret != -1 && cont_ret == -1) {\n            // Contestant failed to find a solution when one exists\n            quitf(_wa, \"For test case %d, contestant outputs -1 while a solution exists\", i + 1);\n        } else if (jury_ret == -1 && cont_ret != -1) {\n            // Contestant found a solution when jury said none exists\n            quitf(_fail, \"For test case %d, contestant found a solution but jury says none exists\", i + 1);\n        } else {\n            // Both provided solutions; contestant's solution has been checked in readAnswer\n            continue;\n        }\n    }\n\n    // If we reach here, all answers are correct\n    quitf(_ok, \"All answers are correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nset<long long> lucky_numbers_set;\nvector<long long> lucky_numbers;\n\nconst int max_digits = 12;\n\nvoid generate_lucky_numbers(long long num, int digits) {\n    if (digits > max_digits || num > 1000000000000000000LL) return;\n    lucky_numbers_set.insert(num);\n    generate_lucky_numbers(num * 10 + 0, digits + 1);\n    generate_lucky_numbers(num * 10 + 4, digits + 1);\n    generate_lucky_numbers(num * 10 + 7, digits + 1);\n}\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n_max = 1000000000000000000LL; // 1e18\n\n    if (type == \"min\") {\n        t = 1;\n        printf(\"%d\\n\", t);\n        long long n = 1;\n        printf(\"%lld\\n\", n);\n    }\n    else if (type == \"max\") {\n        t = 5000;\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long n = n_max;\n            printf(\"%lld\\n\", n);\n        }\n    }\n    else if (type == \"random\") {\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, n_max);\n            printf(\"%lld\\n\", n);\n        }\n    }\n    else if (type == \"possible\") {\n        // Generate n_i as sum of six lucky numbers\n        generate_lucky_numbers(0LL, 0);\n        lucky_numbers.assign(lucky_numbers_set.begin(), lucky_numbers_set.end());\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long sum = 0;\n            for (int j = 0; j < 6; ++j) {\n                long long ln = lucky_numbers[rnd.next(0, (int)lucky_numbers.size() - 1)];\n                sum += ln;\n            }\n            printf(\"%lld\\n\", sum);\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate numbers unlikely to be representable\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 100000LL);\n            n = n * 7 + 3; // Adding 3 makes it less likely to be representable\n            printf(\"%lld\\n\", n);\n        }\n    }\n    else {\n        // Default or unknown type\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, n_max);\n            printf(\"%lld\\n\", n);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nset<long long> lucky_numbers_set;\nvector<long long> lucky_numbers;\n\nconst int max_digits = 12;\n\nvoid generate_lucky_numbers(long long num, int digits) {\n    if (digits > max_digits || num > 1000000000000000000LL) return;\n    lucky_numbers_set.insert(num);\n    generate_lucky_numbers(num * 10 + 0, digits + 1);\n    generate_lucky_numbers(num * 10 + 4, digits + 1);\n    generate_lucky_numbers(num * 10 + 7, digits + 1);\n}\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n_max = 1000000000000000000LL; // 1e18\n\n    if (type == \"min\") {\n        t = 1;\n        printf(\"%d\\n\", t);\n        long long n = 1;\n        printf(\"%lld\\n\", n);\n    }\n    else if (type == \"max\") {\n        t = 5000;\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long n = n_max;\n            printf(\"%lld\\n\", n);\n        }\n    }\n    else if (type == \"random\") {\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, n_max);\n            printf(\"%lld\\n\", n);\n        }\n    }\n    else if (type == \"possible\") {\n        // Generate n_i as sum of six lucky numbers\n        generate_lucky_numbers(0LL, 0);\n        lucky_numbers.assign(lucky_numbers_set.begin(), lucky_numbers_set.end());\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long sum = 0;\n            for (int j = 0; j < 6; ++j) {\n                long long ln = lucky_numbers[rnd.next(0, (int)lucky_numbers.size() - 1)];\n                sum += ln;\n            }\n            printf(\"%lld\\n\", sum);\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate numbers unlikely to be representable\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 100000LL);\n            n = n * 7 + 3; // Adding 3 makes it less likely to be representable\n            printf(\"%lld\\n\", n);\n        }\n    }\n    else {\n        // Default or unknown type\n        printf(\"%d\\n\", t);\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, n_max);\n            printf(\"%lld\\n\", n);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type min\n./gen -t 1 -type max\n./gen -t 5 -type random\n./gen -t 10 -type random\n./gen -t 100 -type random\n./gen -t 5000 -type random\n\n./gen -t 5 -type possible\n./gen -t 10 -type possible\n./gen -t 100 -type possible\n./gen -t 5000 -type possible\n\n./gen -t 5 -type impossible\n./gen -t 10 -type impossible\n./gen -t 100 -type impossible\n./gen -t 5000 -type impossible\n\n./gen -t 10 -type min\n./gen -t 10 -type max\n\n./gen -t 50 -type random\n./gen -t 50 -type possible\n./gen -t 50 -type impossible\n\n./gen -t 5000 -type random\n./gen -t 5000 -type possible\n./gen -t 5000 -type impossible\n\n./gen -t 1 -type default\n./gen -t 1000\n./gen -t 5000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:10.684731",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "355/A",
      "title": "A. Vasya and Digital Root",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers k and d (1 ≤ k ≤ 1000; 0 ≤ d ≤ 9).",
      "output_spec": "OutputIn a single line print either any number that meets the requirements (without the leading zeroes) or \"No solution\" (without the quotes), if the corresponding number does not exist.The chosen number must consist of exactly k digits. We assume that number 0 doesn't contain any leading zeroes.",
      "sample_tests": "ExamplesInputCopy4 4OutputCopy5881InputCopy5 1OutputCopy36172InputCopy1 0OutputCopy0",
      "description": "A. Vasya and Digital Root\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers k and d (1 ≤ k ≤ 1000; 0 ≤ d ≤ 9).\n\nOutputIn a single line print either any number that meets the requirements (without the leading zeroes) or \"No solution\" (without the quotes), if the corresponding number does not exist.The chosen number must consist of exactly k digits. We assume that number 0 doesn't contain any leading zeroes.\n\nInputCopy4 4OutputCopy5881InputCopy5 1OutputCopy36172InputCopy1 0OutputCopy0\n\nInputCopy4 4\n\nOutputCopy5881\n\nInputCopy5 1\n\nOutputCopy36172\n\nInputCopy1 0\n\nOutputCopy0\n\nNoteFor the first test sample dr(5881)  =  dr(22)  =  4.For the second test sample dr(36172)  =  dr(19)  =  dr(10)  =  1.",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Hello everyone!Very soon on 13 october at 19:30 MSK will take place Codeforces Round #206. I am author of the problems and it's my first round!I would like to thank problem coordinator Gerald Agapov (Gerald), Evgeny Vihrov (gen) for problem testing and Mary Belova (Delinur) for translation of statements to English. Special thanks to Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Score distribution will be standard in both divisions: 500-1000-1500-2000-2500.I wish good luck for everyone and hope that you will enjoy the problems!Congratulations to the winners! Special congratulations to rng_58, the only participant, who have solved all 5 problems!First division: rng_58 sankear VArtem sillycross Endagorion Second division: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD The editorial has been published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 845
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces",
          "content": "355A - Vasya and Digital RootIf d = 0, the there is the only number with , so, if k = 1, the answer is 0, otherwise — No solution.If d > 0, then one of correct numbers is d × 10k - 1.Time complexity: O(1) + O(k) for the output.355B - Vasya and Public TransportIf we buy a ticket of the fourth type, we don't have to buy anything else, so, the answer is min(c4, answer using tickets of first three types).Now, when we don't have ticket of the fourth type, we can solve the task separately for buses and trolleys.Solving the problem only for buses: if we buy a ticket of the third type, we don't have to buy anything else, so, the answer is min(c3, answer using tickets of first two types).Without tickets of type three, we can solve the problem separately for each bus. If we buy a ticket of the second type, we will spend c2 burles and if we buy ai tickets of the first type, we will spend (ai × c1) burles. So, the answer for bus i is min(c2, ai × c1).Now it is not difficult to obtain the following solution: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Time complexity: O(n + m).354A - Vasya and RobotBrute force how many times we will use operation from the left. So, if we use it k times, then it's clear, that we will take first k items by the left operations and last (n - k) items by the right operations. So, robot will spend sumLeft[k]·l + sumRight[n - k]·r energy plus some penalty for the same operations. To minimize this penalty we should perform the operations in the following order LRLRL ... RLRLLLLL ..., starting from the bigger set. For example, if k = 7, n - k = 4, we should perform operations in this order: LRLRLRLRL LL. So, we will have to pay the penalty two times (7 - 4 - 1).sumLeft[i] — sum of first i weights, sumRight[i] — sum of last i weights.Solution in pseudocode: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Time complexity: O(n).354B - Game with StringsWe will say that cell (r, c) corresponds to a string s, if there exist correct path, which ends in the cell (r, c) and this path corresponds to a string s.Let call a set of cells which corresponds to some string s a state. One state can correspond to different strings. We can't brute force all possible strings, because their count — is too big, but we can brute force all possible states. It's not hard to observe that all cells that corresponds to some string s lies on same diagonal, so the total count of states is 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). In implementation we can denote state with diagonal number (from 1 to 2n - 1) and bitmask of cells corresponding to this state (2n).From each state we can move to 26 different states (actually less) and all possible moves depends on the state, not on the string. On the image you can see an example of move: from state, which is highlighted in blue by letter a we will move to the state, which is highlighted in yellow.Now, for each state we can calculate a value of (count of letters A  -  count of letters B) in the string, starting from this state. If at the moment is first players turn (an even diagonal), we have to maximize this value, otherwise — minimize. It can be implemented as recursion with memoization.The winner can be determined by the value of state, which corresponds to the single cell (1, 1).Complexity: O(2n × (n + alpha)), where alpha is the size of alphabet.354C - Vasya and Beautiful ArraysThe problem was to find greatest d, such that ai ≥ d,  ai mod d ≤ k holds for each i.Let m = min(ai), then d ≤ m. Let consider two cases:. In this case we will brute force answer from k + 1 to m. We can check, if number d is a correct answer in the following way:We have to check that ai mod d ≤ k for some fixed d, which is equals to , where . Since all these intervals [x·d..x·d + k] doesn't intersects each with other, we can just check that , where cnt[l..r] — count of numbers ai in the interval [l..r].Time complexity: O(maxA log maxA), proof is based on the sum of harmonic series.354D - Transferring PyramidThis tasks is solvable with dynamic programming. First of all let consider solution with complexity O(n3).Let dp[i][j] be the answer for the highlighted in blue part (minimal cost of transferring all special cells that lies inside this area). Then dp[n][0] will be the answer for our original problem.How to recalculate such DP? It's clear that in the leftmost column (inside the blue area) we will choose at most one cell as the top of some subpyramid. If we choose two, then the smallest one will lie fully inside the biggest one (as the orange subpyramid lies inside the blue one). Now, let brute force the cell, which will be the top of subpyramid in this column in time O(n) and we will obtain the following transition:To simplify the formulas, let assume that . 0 ≤ k ≤ i, where k is the height on which we will choose our top cell, or 0, if we don't choose any subpyramid in this column. sumUp[i][p] — count of special cells in the i-th column at height starting from p, this cells we will have to transfer one by one, using the first type operations.We can reduce the complexity by one n, if we will recalculate out DP in the following way: 0 ≤ k ≤ i; for all j > 0.The proof that this is correct is quite simple and is left to the reader. :)Also, we can observe that it is not profitably to take some subpyramid with height greater than , because for such subpyramid we will pay  > 3k, but if we transfer all cells using the first type operations we will pay only 3k. So, the second dimension (j) in out DP can be reduced to .Also, to receive AC, you should store only last 2 layers of the DP, otherwise there will be not enough memory.Time complexity: .354E - Lucky Number RepresentationAuthor's solution, much more complicated than suggested by many participants during the competition, easy solution will be described below.First of all, let write a DP with complexity O(N * lucky_count(N)), where lucky_count(N) is the count of lucky numbers  ≤ N, lucky_count(10n) = 3n. As we can see, for all sufficiently large N solution exists. Really — for every N > 523.Now, we can say that for N ≤ 10000 we have a solution, which is found using DP. Let's solve the task for larger values of N.Next and key idea is to separate the task into two parts: N = N1 + N2. Let's choose N1 and N2 in such way that for them it was easy to find a solution and then merge these two solutions into one. Let N1 = N mod 4000, N2 = N - N1. Here we can have a problem that there is no solution for number N1, in this case we can do N1 = N1 + 4000, N2 = N2 - 4000.Now it is guaranteed that solutions exists for both N1 and N2, moreover, the solution for number N1 will contain only numbers of not more than 3 digits ( < 1000). The proof is quite easy: if N1 < 4000 — it is obvious; else — if the solution uses some number of the form (4000 + some_lucky_number), we can replace it with just some_lucky_number and receive a correct solution for number (N1 - 4000), but is doesn't exist!So, the solution for number N1 we have found using DP, now let's find the solution for N2. If it will contains only of numbers of the form (some_lucky_number × 1000), then we will be able to easily merge this solution with solution for N1, so, let's find such a solution. Here we will use the fact that N2 is divisible by 4. For simplicity, let's divide N2 by 1000 and in the end multiply all Ans2(i) by the same 1000. Let P = N2 / 4. Now, let's construct the solution. Consider, for example, P = 95: we will walk through digits of this number, last digit — 5, means that we want to put digit 4 at the last decimal position of five answer numbers — ok, put it and in the last, sixth, number leave there digit 0. Go forward, digit 9 — we don't have nine numbers, but we can replace seven fours with four sevens, then to the second position we have to put (9 - 7) fours and 4 sevens, in total — 6 numbers, exactly as much as we have.Thus, if next digit d ≤ 6, we just put to the first d answer numbers digit 4 to the next position; if d > 6, then we put 4 sevens and (d - 7) fours. In all other numbers we just leave digit 0 at this position.If Ans1(i) — answer for N1, Ans2(i) — for N2, the the answer for N will be just Ans(i) = Ans1(i) + Ans2(i).Time complexity for one number: O(logN).During the competition many participants have wrote the following solution:dp[i][j] — can we put the digit to the last i decimal positions of the answer number in such way that we will get correct last i digits in the sum and with carry to the next position equals to j. Then the solution exist iff dp[19][0] = true. To restore the answer we just have to remember for each state the previous state. Base — dp[0][0] = true. Transition — brute force how many fours and sevens we will put to the i-th position.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 355\\s*A"
          },
          "content_length": 9015
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 5",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 6",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 7",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(0, 9, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(0, 9, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(0, 9, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int k = inf.readInt(1, 1000);\n    int d = inf.readInt(0, 9);\n\n    string ans_str = ouf.readToken();\n\n    if (ans_str == \"No\" || ans_str == \"No solution\") {\n        if (ans_str == \"No\") {\n            string sol = ouf.readToken();\n            if (sol != \"solution\")\n                quitf(_wa, \"Expected 'No solution', but got '%s %s'\", ans_str.c_str(), sol.c_str());\n        }\n        if (d == 0 && k > 1) {\n            quitf(_ok, \"Correctly output No solution.\");\n        } else {\n            quitf(_wa, \"Output 'No solution' but a solution exists.\");\n        }\n    } else {\n        // Check if ans_str is a valid number\n        if (!all_of(ans_str.begin(), ans_str.end(), ::isdigit)) {\n            quitf(_wa, \"Output is not a valid number.\");\n        }\n        // Check leading zeros\n        if (ans_str[0] == '0') {\n            if (!(k == 1 && ans_str == \"0\")) {\n                quitf(_wa, \"Leading zeros are not allowed except for '0' when k=1.\");\n            }\n        }\n        // Check length\n        if ((int)ans_str.length() != k) {\n            quitf(_wa, \"Number length is not equal to k.\");\n        }\n        // Compute digital root\n        string s = ans_str;\n        int dr = 0;\n        for (int iter = 0; iter < 4; ++iter) {\n            int sum = 0;\n            for (char c : s) {\n                sum += c - '0';\n            }\n            s = to_string(sum);\n            if (sum < 10) {\n                dr = sum;\n                break;\n            }\n        }\n        if (dr != d) {\n            quitf(_wa, \"Digital root is incorrect.\");\n        }\n        quitf(_ok, \"Answer is correct.\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int K_MIN = 1;\nconst int K_MAX = 1000;\nconst int D_MIN = 0;\nconst int D_MAX = 9;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1);\n    int d = opt<int>(\"d\", -1);\n    string type = opt<string>(\"type\", \"possible\");\n\n    if (type == \"fixed\") {\n        if (k == -1 || d == -1) {\n            fprintf(stderr, \"Error: type 'fixed' requires parameters k and d\\n\");\n            return 1;\n        }\n    } else if (type == \"impossible\") {\n        // Generate impossible test case: k > 1 and d = 0\n        k = rnd.next(2, K_MAX);\n        d = 0;\n    } else if (type == \"possible\") {\n        // Generate possible test cases, avoiding k > 1 and d = 0\n        k = rnd.next(K_MIN, K_MAX);\n        d = rnd.next(D_MIN, D_MAX);\n        if (k > 1 && d == 0) {\n            d = rnd.next(1, D_MAX);\n        }\n    } else if (type == \"max_k\") {\n        k = K_MAX;\n        d = rnd.next(D_MIN, D_MAX);\n        if (k > 1 && d == 0) {\n            d = rnd.next(1, D_MAX);\n        }\n    } else if (type == \"min_k\") {\n        k = K_MIN;\n        d = rnd.next(D_MIN, D_MAX);\n    } else {\n        fprintf(stderr, \"Error: unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", k, d);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int K_MIN = 1;\nconst int K_MAX = 1000;\nconst int D_MIN = 0;\nconst int D_MAX = 9;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1);\n    int d = opt<int>(\"d\", -1);\n    string type = opt<string>(\"type\", \"possible\");\n\n    if (type == \"fixed\") {\n        if (k == -1 || d == -1) {\n            fprintf(stderr, \"Error: type 'fixed' requires parameters k and d\\n\");\n            return 1;\n        }\n    } else if (type == \"impossible\") {\n        // Generate impossible test case: k > 1 and d = 0\n        k = rnd.next(2, K_MAX);\n        d = 0;\n    } else if (type == \"possible\") {\n        // Generate possible test cases, avoiding k > 1 and d = 0\n        k = rnd.next(K_MIN, K_MAX);\n        d = rnd.next(D_MIN, D_MAX);\n        if (k > 1 && d == 0) {\n            d = rnd.next(1, D_MAX);\n        }\n    } else if (type == \"max_k\") {\n        k = K_MAX;\n        d = rnd.next(D_MIN, D_MAX);\n        if (k > 1 && d == 0) {\n            d = rnd.next(1, D_MAX);\n        }\n    } else if (type == \"min_k\") {\n        k = K_MIN;\n        d = rnd.next(D_MIN, D_MAX);\n    } else {\n        fprintf(stderr, \"Error: unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", k, d);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_k\n./gen -type max_k\n./gen -type possible\n./gen -type possible\n./gen -type possible\n./gen -type impossible\n./gen -type impossible\n./gen -type impossible\n./gen -type fixed -k 1 -d 0\n./gen -type fixed -k 1 -d 5\n./gen -type fixed -k 1 -d 9\n./gen -type fixed -k 2 -d 0\n./gen -type fixed -k 10 -d 0\n./gen -type fixed -k 999 -d 0\n./gen -type fixed -k 1000 -d 5\n./gen -type fixed -k 1000 -d 0\n./gen -type fixed -k 500 -d 0\n./gen -type fixed -k 500 -d 9\n./gen -type fixed -k 999 -d 1\n./gen -type fixed -k 1000 -d 9\n./gen -type fixed -k 2 -d 1\n./gen -type fixed -k 2 -d 9\n./gen -type fixed -k 3 -d 5\n./gen -type fixed -k 50 -d 2\n./gen -type fixed -k 100 -d 3\n./gen -type fixed -k 200 -d 4\n./gen -type fixed -k 300 -d 5\n./gen -type fixed -k 400 -d 6\n./gen -type fixed -k 500 -d 7\n./gen -type fixed -k 600 -d 8\n./gen -type fixed -k 700 -d 9\n./gen -type fixed -k 800 -d 1\n./gen -type fixed -k 900 -d 2\n./gen -type fixed -k 1000 -d 3\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:13.010548",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "355/B",
      "title": "B. Vasya and Public Transport",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers c1, c2, c3, c4 (1 ≤ c1, c2, c3, c4 ≤ 1000) — the costs of the tickets.The second line contains two integers n and m (1 ≤ n, m ≤ 1000) — the number of buses and trolleys Vasya is going to use.The third line contains n integers ai (0 ≤ ai ≤ 1000) — the number of times Vasya is going to use the bus number i.The fourth line contains m integers bi (0 ≤ bi ≤ 1000) — the number of times Vasya is going to use the trolley number i.",
      "output_spec": "OutputPrint a single number — the minimum sum of burles Vasya will have to spend on the tickets.",
      "sample_tests": "ExamplesInputCopy1 3 7 192 32 54 4 4OutputCopy12InputCopy4 3 2 11 37981 2 3OutputCopy1InputCopy100 100 8 1003 57 94 12100 1 47 0 42OutputCopy16",
      "description": "B. Vasya and Public Transport\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four integers c1, c2, c3, c4 (1 ≤ c1, c2, c3, c4 ≤ 1000) — the costs of the tickets.The second line contains two integers n and m (1 ≤ n, m ≤ 1000) — the number of buses and trolleys Vasya is going to use.The third line contains n integers ai (0 ≤ ai ≤ 1000) — the number of times Vasya is going to use the bus number i.The fourth line contains m integers bi (0 ≤ bi ≤ 1000) — the number of times Vasya is going to use the trolley number i.\n\nOutputPrint a single number — the minimum sum of burles Vasya will have to spend on the tickets.\n\nInputCopy1 3 7 192 32 54 4 4OutputCopy12InputCopy4 3 2 11 37981 2 3OutputCopy1InputCopy100 100 8 1003 57 94 12100 1 47 0 42OutputCopy16\n\nInputCopy1 3 7 192 32 54 4 4\n\nOutputCopy12\n\nInputCopy4 3 2 11 37981 2 3\n\nOutputCopy1\n\nInputCopy100 100 8 1003 57 94 12100 1 47 0 42\n\nOutputCopy16\n\nNoteIn the first sample the profitable strategy is to buy two tickets of the first type (for the first bus), one ticket of the second type (for the second bus) and one ticket of the third type (for all trolleys). It totals to (2·1) + 3 + 7 = 12 burles.In the second sample the profitable strategy is to buy one ticket of the fourth type.In the third sample the profitable strategy is to buy two tickets of the third type: for all buses and for all trolleys.",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Hello everyone!Very soon on 13 october at 19:30 MSK will take place Codeforces Round #206. I am author of the problems and it's my first round!I would like to thank problem coordinator Gerald Agapov (Gerald), Evgeny Vihrov (gen) for problem testing and Mary Belova (Delinur) for translation of statements to English. Special thanks to Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Score distribution will be standard in both divisions: 500-1000-1500-2000-2500.I wish good luck for everyone and hope that you will enjoy the problems!Congratulations to the winners! Special congratulations to rng_58, the only participant, who have solved all 5 problems!First division: rng_58 sankear VArtem sillycross Endagorion Second division: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD The editorial has been published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 845
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces",
          "content": "355A - Vasya and Digital RootIf d = 0, the there is the only number with , so, if k = 1, the answer is 0, otherwise — No solution.If d > 0, then one of correct numbers is d × 10k - 1.Time complexity: O(1) + O(k) for the output.355B - Vasya and Public TransportIf we buy a ticket of the fourth type, we don't have to buy anything else, so, the answer is min(c4, answer using tickets of first three types).Now, when we don't have ticket of the fourth type, we can solve the task separately for buses and trolleys.Solving the problem only for buses: if we buy a ticket of the third type, we don't have to buy anything else, so, the answer is min(c3, answer using tickets of first two types).Without tickets of type three, we can solve the problem separately for each bus. If we buy a ticket of the second type, we will spend c2 burles and if we buy ai tickets of the first type, we will spend (ai × c1) burles. So, the answer for bus i is min(c2, ai × c1).Now it is not difficult to obtain the following solution: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Time complexity: O(n + m).354A - Vasya and RobotBrute force how many times we will use operation from the left. So, if we use it k times, then it's clear, that we will take first k items by the left operations and last (n - k) items by the right operations. So, robot will spend sumLeft[k]·l + sumRight[n - k]·r energy plus some penalty for the same operations. To minimize this penalty we should perform the operations in the following order LRLRL ... RLRLLLLL ..., starting from the bigger set. For example, if k = 7, n - k = 4, we should perform operations in this order: LRLRLRLRL LL. So, we will have to pay the penalty two times (7 - 4 - 1).sumLeft[i] — sum of first i weights, sumRight[i] — sum of last i weights.Solution in pseudocode: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Time complexity: O(n).354B - Game with StringsWe will say that cell (r, c) corresponds to a string s, if there exist correct path, which ends in the cell (r, c) and this path corresponds to a string s.Let call a set of cells which corresponds to some string s a state. One state can correspond to different strings. We can't brute force all possible strings, because their count — is too big, but we can brute force all possible states. It's not hard to observe that all cells that corresponds to some string s lies on same diagonal, so the total count of states is 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). In implementation we can denote state with diagonal number (from 1 to 2n - 1) and bitmask of cells corresponding to this state (2n).From each state we can move to 26 different states (actually less) and all possible moves depends on the state, not on the string. On the image you can see an example of move: from state, which is highlighted in blue by letter a we will move to the state, which is highlighted in yellow.Now, for each state we can calculate a value of (count of letters A  -  count of letters B) in the string, starting from this state. If at the moment is first players turn (an even diagonal), we have to maximize this value, otherwise — minimize. It can be implemented as recursion with memoization.The winner can be determined by the value of state, which corresponds to the single cell (1, 1).Complexity: O(2n × (n + alpha)), where alpha is the size of alphabet.354C - Vasya and Beautiful ArraysThe problem was to find greatest d, such that ai ≥ d,  ai mod d ≤ k holds for each i.Let m = min(ai), then d ≤ m. Let consider two cases:. In this case we will brute force answer from k + 1 to m. We can check, if number d is a correct answer in the following way:We have to check that ai mod d ≤ k for some fixed d, which is equals to , where . Since all these intervals [x·d..x·d + k] doesn't intersects each with other, we can just check that , where cnt[l..r] — count of numbers ai in the interval [l..r].Time complexity: O(maxA log maxA), proof is based on the sum of harmonic series.354D - Transferring PyramidThis tasks is solvable with dynamic programming. First of all let consider solution with complexity O(n3).Let dp[i][j] be the answer for the highlighted in blue part (minimal cost of transferring all special cells that lies inside this area). Then dp[n][0] will be the answer for our original problem.How to recalculate such DP? It's clear that in the leftmost column (inside the blue area) we will choose at most one cell as the top of some subpyramid. If we choose two, then the smallest one will lie fully inside the biggest one (as the orange subpyramid lies inside the blue one). Now, let brute force the cell, which will be the top of subpyramid in this column in time O(n) and we will obtain the following transition:To simplify the formulas, let assume that . 0 ≤ k ≤ i, where k is the height on which we will choose our top cell, or 0, if we don't choose any subpyramid in this column. sumUp[i][p] — count of special cells in the i-th column at height starting from p, this cells we will have to transfer one by one, using the first type operations.We can reduce the complexity by one n, if we will recalculate out DP in the following way: 0 ≤ k ≤ i; for all j > 0.The proof that this is correct is quite simple and is left to the reader. :)Also, we can observe that it is not profitably to take some subpyramid with height greater than , because for such subpyramid we will pay  > 3k, but if we transfer all cells using the first type operations we will pay only 3k. So, the second dimension (j) in out DP can be reduced to .Also, to receive AC, you should store only last 2 layers of the DP, otherwise there will be not enough memory.Time complexity: .354E - Lucky Number RepresentationAuthor's solution, much more complicated than suggested by many participants during the competition, easy solution will be described below.First of all, let write a DP with complexity O(N * lucky_count(N)), where lucky_count(N) is the count of lucky numbers  ≤ N, lucky_count(10n) = 3n. As we can see, for all sufficiently large N solution exists. Really — for every N > 523.Now, we can say that for N ≤ 10000 we have a solution, which is found using DP. Let's solve the task for larger values of N.Next and key idea is to separate the task into two parts: N = N1 + N2. Let's choose N1 and N2 in such way that for them it was easy to find a solution and then merge these two solutions into one. Let N1 = N mod 4000, N2 = N - N1. Here we can have a problem that there is no solution for number N1, in this case we can do N1 = N1 + 4000, N2 = N2 - 4000.Now it is guaranteed that solutions exists for both N1 and N2, moreover, the solution for number N1 will contain only numbers of not more than 3 digits ( < 1000). The proof is quite easy: if N1 < 4000 — it is obvious; else — if the solution uses some number of the form (4000 + some_lucky_number), we can replace it with just some_lucky_number and receive a correct solution for number (N1 - 4000), but is doesn't exist!So, the solution for number N1 we have found using DP, now let's find the solution for N2. If it will contains only of numbers of the form (some_lucky_number × 1000), then we will be able to easily merge this solution with solution for N1, so, let's find such a solution. Here we will use the fact that N2 is divisible by 4. For simplicity, let's divide N2 by 1000 and in the end multiply all Ans2(i) by the same 1000. Let P = N2 / 4. Now, let's construct the solution. Consider, for example, P = 95: we will walk through digits of this number, last digit — 5, means that we want to put digit 4 at the last decimal position of five answer numbers — ok, put it and in the last, sixth, number leave there digit 0. Go forward, digit 9 — we don't have nine numbers, but we can replace seven fours with four sevens, then to the second position we have to put (9 - 7) fours and 4 sevens, in total — 6 numbers, exactly as much as we have.Thus, if next digit d ≤ 6, we just put to the first d answer numbers digit 4 to the next position; if d > 6, then we put 4 sevens and (d - 7) fours. In all other numbers we just leave digit 0 at this position.If Ans1(i) — answer for N1, Ans2(i) — for N2, the the answer for N will be just Ans(i) = Ans1(i) + Ans2(i).Time complexity for one number: O(logN).During the competition many participants have wrote the following solution:dp[i][j] — can we put the digit to the last i decimal positions of the answer number in such way that we will get correct last i digits in the sum and with carry to the next position equals to j. Then the solution exist iff dp[19][0] = true. To restore the answer we just have to remember for each state the previous state. Base — dp[0][0] = true. Transition — brute force how many fours and sevens we will put to the i-th position.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 355\\s*B"
          },
          "content_length": 9015
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 5",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 6",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 7",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read c1, c2, c3, c4\n    int c1 = inf.readInt(1, 1000, \"c1\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, 1000, \"c2\");\n    inf.readSpace();\n    int c3 = inf.readInt(1, 1000, \"c3\");\n    inf.readSpace();\n    int c4 = inf.readInt(1, 1000, \"c4\");\n    inf.readEoln();\n\n    // Read n and m\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    // Read n integers ai\n    vector<int> ai = inf.readInts(n, 0, 1000, \"ai\");\n    inf.readEoln();\n\n    // Read m integers bi\n    vector<int> bi = inf.readInts(m, 0, 1000, \"bi\");\n    inf.readEoln();\n\n    // Ensure there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read c1, c2, c3, c4\n    int c1 = inf.readInt(1, 1000, \"c1\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, 1000, \"c2\");\n    inf.readSpace();\n    int c3 = inf.readInt(1, 1000, \"c3\");\n    inf.readSpace();\n    int c4 = inf.readInt(1, 1000, \"c4\");\n    inf.readEoln();\n\n    // Read n and m\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    // Read n integers ai\n    vector<int> ai = inf.readInts(n, 0, 1000, \"ai\");\n    inf.readEoln();\n\n    // Read m integers bi\n    vector<int> bi = inf.readInts(m, 0, 1000, \"bi\");\n    inf.readEoln();\n\n    // Ensure there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read c1, c2, c3, c4\n    int c1 = inf.readInt(1, 1000, \"c1\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, 1000, \"c2\");\n    inf.readSpace();\n    int c3 = inf.readInt(1, 1000, \"c3\");\n    inf.readSpace();\n    int c4 = inf.readInt(1, 1000, \"c4\");\n    inf.readEoln();\n\n    // Read n and m\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    // Read n integers ai\n    vector<int> ai = inf.readInts(n, 0, 1000, \"ai\");\n    inf.readEoln();\n\n    // Read m integers bi\n    vector<int> bi = inf.readInts(m, 0, 1000, \"bi\");\n    inf.readEoln();\n\n    // Ensure there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int c1, c2, c3, c4;\n    vector<int> ai(n), bi(m);\n\n    if (type == \"random\") {\n        // Random costs and usages\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, 1000);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(0, 1000);\n    } else if (type == \"all_zero_usage\") {\n        // All usages are zero\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, 0);\n        bi.assign(m, 0);\n    } else if (type == \"all_max_usage\") {\n        // All usages are maximum\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, 1000);\n        bi.assign(m, 1000);\n    } else if (type == \"single_ride_per_bus\") {\n        // Each bus/trolley is used once\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, 1);\n        bi.assign(m, 1);\n    } else if (type == \"max_ai_min_bi\") {\n        // Max bus usage, min trolley usage\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, 1000);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(0, 1);\n    } else if (type == \"min_ai_max_bi\") {\n        // Min bus usage, max trolley usage\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, 1);\n        bi.assign(m, 1000);\n    } else if (type == \"equal_costs\") {\n        // All costs are equal\n        c1 = c2 = c3 = c4 = rnd.next(1, 1000);\n        ai.assign(n, rnd.next(0, 1000));\n        bi.assign(m, rnd.next(0, 1000));\n    } else if (type == \"skewed_costs\") {\n        // Costs are in increasing order\n        c1 = rnd.next(1, 250);\n        c2 = rnd.next(c1 + 1, 500);\n        c3 = rnd.next(c2 + 1, 750);\n        c4 = rnd.next(c3 + 1, 1000);\n        ai.assign(n, rnd.next(0, 1000));\n        bi.assign(m, rnd.next(0, 1000));\n    } else if (type == \"confusing_c1_c2\") {\n        // c2 is cheaper than c1\n        c1 = rnd.next(500, 1000);\n        c2 = rnd.next(1, c1 - 1);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, rnd.next(1, 1000));\n        bi.assign(m, rnd.next(1, 1000));\n    } else if (type == \"confusing_c2_c3\") {\n        // c3 is cheaper than c2\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(500, 1000);\n        c3 = rnd.next(1, c2 - 1);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, rnd.next(1, 1000));\n        bi.assign(m, rnd.next(1, 1000));\n    } else if (type == \"confusing_c3_c4\") {\n        // c4 is cheaper than c3\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(500, 1000);\n        c4 = rnd.next(1, c3 - 1);\n        ai.assign(n, rnd.next(1, 1000));\n        bi.assign(m, rnd.next(1, 1000));\n    } else if (type == \"edge_costs\") {\n        // All costs are minimal\n        c1 = c2 = c3 = c4 = 1;\n        ai.assign(n, rnd.next(0, 1000));\n        bi.assign(m, rnd.next(0, 1000));\n    } else {\n        // Default to random if unknown type\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, 1000);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(0, 1000);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", c1, c2, c3, c4);\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d\", bi[i]);\n        if (i != m - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int c1, c2, c3, c4;\n    vector<int> ai(n), bi(m);\n\n    if (type == \"random\") {\n        // Random costs and usages\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, 1000);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(0, 1000);\n    } else if (type == \"all_zero_usage\") {\n        // All usages are zero\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, 0);\n        bi.assign(m, 0);\n    } else if (type == \"all_max_usage\") {\n        // All usages are maximum\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, 1000);\n        bi.assign(m, 1000);\n    } else if (type == \"single_ride_per_bus\") {\n        // Each bus/trolley is used once\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, 1);\n        bi.assign(m, 1);\n    } else if (type == \"max_ai_min_bi\") {\n        // Max bus usage, min trolley usage\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, 1000);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(0, 1);\n    } else if (type == \"min_ai_max_bi\") {\n        // Min bus usage, max trolley usage\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, 1);\n        bi.assign(m, 1000);\n    } else if (type == \"equal_costs\") {\n        // All costs are equal\n        c1 = c2 = c3 = c4 = rnd.next(1, 1000);\n        ai.assign(n, rnd.next(0, 1000));\n        bi.assign(m, rnd.next(0, 1000));\n    } else if (type == \"skewed_costs\") {\n        // Costs are in increasing order\n        c1 = rnd.next(1, 250);\n        c2 = rnd.next(c1 + 1, 500);\n        c3 = rnd.next(c2 + 1, 750);\n        c4 = rnd.next(c3 + 1, 1000);\n        ai.assign(n, rnd.next(0, 1000));\n        bi.assign(m, rnd.next(0, 1000));\n    } else if (type == \"confusing_c1_c2\") {\n        // c2 is cheaper than c1\n        c1 = rnd.next(500, 1000);\n        c2 = rnd.next(1, c1 - 1);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, rnd.next(1, 1000));\n        bi.assign(m, rnd.next(1, 1000));\n    } else if (type == \"confusing_c2_c3\") {\n        // c3 is cheaper than c2\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(500, 1000);\n        c3 = rnd.next(1, c2 - 1);\n        c4 = rnd.next(1, 1000);\n        ai.assign(n, rnd.next(1, 1000));\n        bi.assign(m, rnd.next(1, 1000));\n    } else if (type == \"confusing_c3_c4\") {\n        // c4 is cheaper than c3\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(500, 1000);\n        c4 = rnd.next(1, c3 - 1);\n        ai.assign(n, rnd.next(1, 1000));\n        bi.assign(m, rnd.next(1, 1000));\n    } else if (type == \"edge_costs\") {\n        // All costs are minimal\n        c1 = c2 = c3 = c4 = 1;\n        ai.assign(n, rnd.next(0, 1000));\n        bi.assign(m, rnd.next(0, 1000));\n    } else {\n        // Default to random if unknown type\n        c1 = rnd.next(1, 1000);\n        c2 = rnd.next(1, 1000);\n        c3 = rnd.next(1, 1000);\n        c4 = rnd.next(1, 1000);\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, 1000);\n        for(int i = 0; i < m; ++i)\n            bi[i] = rnd.next(0, 1000);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", c1, c2, c3, c4);\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d\", bi[i]);\n        if (i != m - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type all_zero_usage\n./gen -n 10 -m 10 -type all_max_usage\n./gen -n 10 -m 10 -type single_ride_per_bus\n./gen -n 10 -m 10 -type max_ai_min_bi\n./gen -n 10 -m 10 -type min_ai_max_bi\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type all_zero_usage\n./gen -n 100 -m 100 -type all_max_usage\n./gen -n 100 -m 100 -type single_ride_per_bus\n./gen -n 100 -m 100 -type max_ai_min_bi\n./gen -n 100 -m 100 -type min_ai_max_bi\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type all_zero_usage\n./gen -n 1000 -m 1000 -type all_max_usage\n./gen -n 1000 -m 1000 -type single_ride_per_bus\n./gen -n 1000 -m 1000 -type max_ai_min_bi\n./gen -n 1000 -m 1000 -type min_ai_max_bi\n./gen -n 500 -m 500 -type confusing_c1_c2\n./gen -n 500 -m 500 -type confusing_c2_c3\n./gen -n 500 -m 500 -type confusing_c3_c4\n./gen -n 1000 -m 1000 -type equal_costs\n./gen -n 1000 -m 1000 -type skewed_costs\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type all_zero_usage\n./gen -n 1 -m 1 -type all_max_usage\n./gen -n 1 -m 1 -type single_ride_per_bus\n./gen -n 1 -m 1 -type edge_costs\n./gen -n 1000 -m 1 -type random\n./gen -n 1 -m 1000 -type random\n./gen -n 1000 -m 1000 -type edge_costs\n./gen -n 500 -m 1000 -type random\n./gen -n 1000 -m 500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:15.195245",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "355/C",
      "title": "C. Vasya and Robot",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains five integers n, l, r, Ql, Qr (1 ≤ n ≤ 105; 1 ≤ l, r ≤ 100; 1 ≤ Ql, Qr ≤ 104).The second line contains n integers w1, w2, ..., wn (1 ≤ wi ≤ 100).",
      "output_spec": "OutputIn the single line print a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3 4 4 19 142 3 99OutputCopy576InputCopy4 7 2 3 91 2 3 4OutputCopy34",
      "description": "C. Vasya and Robot\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains five integers n, l, r, Ql, Qr (1 ≤ n ≤ 105; 1 ≤ l, r ≤ 100; 1 ≤ Ql, Qr ≤ 104).The second line contains n integers w1, w2, ..., wn (1 ≤ wi ≤ 100).\n\nOutputIn the single line print a single number — the answer to the problem.\n\nInputCopy3 4 4 19 142 3 99OutputCopy576InputCopy4 7 2 3 91 2 3 4OutputCopy34\n\nInputCopy3 4 4 19 142 3 99\n\nOutputCopy576\n\nInputCopy4 7 2 3 91 2 3 4\n\nOutputCopy34\n\nNoteConsider the first sample. As l = r, we can take an item in turns: first from the left side, then from the right one and last item from the left. In total the robot spends 4·42 + 4·99 + 4·3 = 576 energy units.The second sample. The optimal solution is to take one item from the right, then one item from the left and two items from the right. In total the robot spends (2·4) + (7·1) + (2·3) + (2·2 + 9) = 34 energy units.",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Hello everyone!Very soon on 13 october at 19:30 MSK will take place Codeforces Round #206. I am author of the problems and it's my first round!I would like to thank problem coordinator Gerald Agapov (Gerald), Evgeny Vihrov (gen) for problem testing and Mary Belova (Delinur) for translation of statements to English. Special thanks to Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Score distribution will be standard in both divisions: 500-1000-1500-2000-2500.I wish good luck for everyone and hope that you will enjoy the problems!Congratulations to the winners! Special congratulations to rng_58, the only participant, who have solved all 5 problems!First division: rng_58 sankear VArtem sillycross Endagorion Second division: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD The editorial has been published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 845
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces",
          "content": "355A - Vasya and Digital RootIf d = 0, the there is the only number with , so, if k = 1, the answer is 0, otherwise — No solution.If d > 0, then one of correct numbers is d × 10k - 1.Time complexity: O(1) + O(k) for the output.355B - Vasya and Public TransportIf we buy a ticket of the fourth type, we don't have to buy anything else, so, the answer is min(c4, answer using tickets of first three types).Now, when we don't have ticket of the fourth type, we can solve the task separately for buses and trolleys.Solving the problem only for buses: if we buy a ticket of the third type, we don't have to buy anything else, so, the answer is min(c3, answer using tickets of first two types).Without tickets of type three, we can solve the problem separately for each bus. If we buy a ticket of the second type, we will spend c2 burles and if we buy ai tickets of the first type, we will spend (ai × c1) burles. So, the answer for bus i is min(c2, ai × c1).Now it is not difficult to obtain the following solution: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Time complexity: O(n + m).354A - Vasya and RobotBrute force how many times we will use operation from the left. So, if we use it k times, then it's clear, that we will take first k items by the left operations and last (n - k) items by the right operations. So, robot will spend sumLeft[k]·l + sumRight[n - k]·r energy plus some penalty for the same operations. To minimize this penalty we should perform the operations in the following order LRLRL ... RLRLLLLL ..., starting from the bigger set. For example, if k = 7, n - k = 4, we should perform operations in this order: LRLRLRLRL LL. So, we will have to pay the penalty two times (7 - 4 - 1).sumLeft[i] — sum of first i weights, sumRight[i] — sum of last i weights.Solution in pseudocode: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Time complexity: O(n).354B - Game with StringsWe will say that cell (r, c) corresponds to a string s, if there exist correct path, which ends in the cell (r, c) and this path corresponds to a string s.Let call a set of cells which corresponds to some string s a state. One state can correspond to different strings. We can't brute force all possible strings, because their count — is too big, but we can brute force all possible states. It's not hard to observe that all cells that corresponds to some string s lies on same diagonal, so the total count of states is 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). In implementation we can denote state with diagonal number (from 1 to 2n - 1) and bitmask of cells corresponding to this state (2n).From each state we can move to 26 different states (actually less) and all possible moves depends on the state, not on the string. On the image you can see an example of move: from state, which is highlighted in blue by letter a we will move to the state, which is highlighted in yellow.Now, for each state we can calculate a value of (count of letters A  -  count of letters B) in the string, starting from this state. If at the moment is first players turn (an even diagonal), we have to maximize this value, otherwise — minimize. It can be implemented as recursion with memoization.The winner can be determined by the value of state, which corresponds to the single cell (1, 1).Complexity: O(2n × (n + alpha)), where alpha is the size of alphabet.354C - Vasya and Beautiful ArraysThe problem was to find greatest d, such that ai ≥ d,  ai mod d ≤ k holds for each i.Let m = min(ai), then d ≤ m. Let consider two cases:. In this case we will brute force answer from k + 1 to m. We can check, if number d is a correct answer in the following way:We have to check that ai mod d ≤ k for some fixed d, which is equals to , where . Since all these intervals [x·d..x·d + k] doesn't intersects each with other, we can just check that , where cnt[l..r] — count of numbers ai in the interval [l..r].Time complexity: O(maxA log maxA), proof is based on the sum of harmonic series.354D - Transferring PyramidThis tasks is solvable with dynamic programming. First of all let consider solution with complexity O(n3).Let dp[i][j] be the answer for the highlighted in blue part (minimal cost of transferring all special cells that lies inside this area). Then dp[n][0] will be the answer for our original problem.How to recalculate such DP? It's clear that in the leftmost column (inside the blue area) we will choose at most one cell as the top of some subpyramid. If we choose two, then the smallest one will lie fully inside the biggest one (as the orange subpyramid lies inside the blue one). Now, let brute force the cell, which will be the top of subpyramid in this column in time O(n) and we will obtain the following transition:To simplify the formulas, let assume that . 0 ≤ k ≤ i, where k is the height on which we will choose our top cell, or 0, if we don't choose any subpyramid in this column. sumUp[i][p] — count of special cells in the i-th column at height starting from p, this cells we will have to transfer one by one, using the first type operations.We can reduce the complexity by one n, if we will recalculate out DP in the following way: 0 ≤ k ≤ i; for all j > 0.The proof that this is correct is quite simple and is left to the reader. :)Also, we can observe that it is not profitably to take some subpyramid with height greater than , because for such subpyramid we will pay  > 3k, but if we transfer all cells using the first type operations we will pay only 3k. So, the second dimension (j) in out DP can be reduced to .Also, to receive AC, you should store only last 2 layers of the DP, otherwise there will be not enough memory.Time complexity: .354E - Lucky Number RepresentationAuthor's solution, much more complicated than suggested by many participants during the competition, easy solution will be described below.First of all, let write a DP with complexity O(N * lucky_count(N)), where lucky_count(N) is the count of lucky numbers  ≤ N, lucky_count(10n) = 3n. As we can see, for all sufficiently large N solution exists. Really — for every N > 523.Now, we can say that for N ≤ 10000 we have a solution, which is found using DP. Let's solve the task for larger values of N.Next and key idea is to separate the task into two parts: N = N1 + N2. Let's choose N1 and N2 in such way that for them it was easy to find a solution and then merge these two solutions into one. Let N1 = N mod 4000, N2 = N - N1. Here we can have a problem that there is no solution for number N1, in this case we can do N1 = N1 + 4000, N2 = N2 - 4000.Now it is guaranteed that solutions exists for both N1 and N2, moreover, the solution for number N1 will contain only numbers of not more than 3 digits ( < 1000). The proof is quite easy: if N1 < 4000 — it is obvious; else — if the solution uses some number of the form (4000 + some_lucky_number), we can replace it with just some_lucky_number and receive a correct solution for number (N1 - 4000), but is doesn't exist!So, the solution for number N1 we have found using DP, now let's find the solution for N2. If it will contains only of numbers of the form (some_lucky_number × 1000), then we will be able to easily merge this solution with solution for N1, so, let's find such a solution. Here we will use the fact that N2 is divisible by 4. For simplicity, let's divide N2 by 1000 and in the end multiply all Ans2(i) by the same 1000. Let P = N2 / 4. Now, let's construct the solution. Consider, for example, P = 95: we will walk through digits of this number, last digit — 5, means that we want to put digit 4 at the last decimal position of five answer numbers — ok, put it and in the last, sixth, number leave there digit 0. Go forward, digit 9 — we don't have nine numbers, but we can replace seven fours with four sevens, then to the second position we have to put (9 - 7) fours and 4 sevens, in total — 6 numbers, exactly as much as we have.Thus, if next digit d ≤ 6, we just put to the first d answer numbers digit 4 to the next position; if d > 6, then we put 4 sevens and (d - 7) fours. In all other numbers we just leave digit 0 at this position.If Ans1(i) — answer for N1, Ans2(i) — for N2, the the answer for N will be just Ans(i) = Ans1(i) + Ans2(i).Time complexity for one number: O(logN).During the competition many participants have wrote the following solution:dp[i][j] — can we put the digit to the last i decimal positions of the answer number in such way that we will get correct last i digits in the sum and with carry to the next position equals to j. Then the solution exist iff dp[19][0] = true. To restore the answer we just have to remember for each state the previous state. Base — dp[0][0] = true. Transition — brute force how many fours and sevens we will put to the i-th position.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 355 和字母"
          },
          "content_length": 9015
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 5",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 6",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 7",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int Ql = inf.readInt(1, 10000, \"Ql\");\n    inf.readSpace();\n    int Qr = inf.readInt(1, 10000, \"Qr\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int Ql = inf.readInt(1, 10000, \"Ql\");\n    inf.readSpace();\n    int Qr = inf.readInt(1, 10000, \"Qr\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int Ql = inf.readInt(1, 10000, \"Ql\");\n    inf.readSpace();\n    int Qr = inf.readInt(1, 10000, \"Qr\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    int Ql = opt<int>(\"Ql\");\n    int Qr = opt<int>(\"Qr\");\n    string w_type = opt<string>(\"w_type\", \"random\");\n\n    // Check that parameters are within constraints\n    assert(1 <= n && n <= 100000);\n    assert(1 <= l && l <= 100);\n    assert(1 <= r && r <= 100);\n    assert(1 <= Ql && Ql <= 10000);\n    assert(1 <= Qr && Qr <= 10000);\n\n    // Generate weights w_i\n    vector<int> w(n);\n    if (w_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 100);\n        }\n    } else if (w_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 100;\n        }\n    } else if (w_type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 1;\n        }\n    } else if (w_type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = (i % 2 == 0) ? 1 : 100;\n        }\n    } else if (w_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = (i % 100) + 1;\n        }\n    } else if (w_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 100 - (i % 100);\n        }\n    } else if (w_type == \"one_side_heavier\") {\n        // Left half weights are max, right half weights are min\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2) {\n                w[i] = 100;\n            } else {\n                w[i] = 1;\n            }\n        }\n    } else if (w_type == \"sawtooth\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = (i % 100) + 1;\n        }\n        shuffle(w.begin(), w.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d\\n\", n, l, r, Ql, Qr);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", w[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    int Ql = opt<int>(\"Ql\");\n    int Qr = opt<int>(\"Qr\");\n    string w_type = opt<string>(\"w_type\", \"random\");\n\n    // Check that parameters are within constraints\n    assert(1 <= n && n <= 100000);\n    assert(1 <= l && l <= 100);\n    assert(1 <= r && r <= 100);\n    assert(1 <= Ql && Ql <= 10000);\n    assert(1 <= Qr && Qr <= 10000);\n\n    // Generate weights w_i\n    vector<int> w(n);\n    if (w_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 100);\n        }\n    } else if (w_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 100;\n        }\n    } else if (w_type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 1;\n        }\n    } else if (w_type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = (i % 2 == 0) ? 1 : 100;\n        }\n    } else if (w_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = (i % 100) + 1;\n        }\n    } else if (w_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 100 - (i % 100);\n        }\n    } else if (w_type == \"one_side_heavier\") {\n        // Left half weights are max, right half weights are min\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2) {\n                w[i] = 100;\n            } else {\n                w[i] = 1;\n            }\n        }\n    } else if (w_type == \"sawtooth\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = (i % 100) + 1;\n        }\n        shuffle(w.begin(), w.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d\\n\", n, l, r, Ql, Qr);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", w[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -l 1 -r 1 -Ql 1 -Qr 1 -w_type min\n./gen -n 1 -l 1 -r 1 -Ql 10000 -Qr 10000 -w_type max\n./gen -n 2 -l 50 -r 50 -Ql 5000 -Qr 5000 -w_type random\n./gen -n 3 -l 1 -r 100 -Ql 10000 -Qr 1 -w_type alternating\n./gen -n 5 -l 100 -r 1 -Ql 1 -Qr 10000 -w_type increasing\n./gen -n 10 -l 100 -r 100 -Ql 10000 -Qr 10000 -w_type decreasing\n./gen -n 20 -l 1 -r 1 -Ql 1 -Qr 1 -w_type one_side_heavier\n./gen -n 100 -l 50 -r 50 -Ql 1 -Qr 1 -w_type random\n./gen -n 1000 -l 1 -r 100 -Ql 1 -Qr 10000 -w_type random\n./gen -n 5000 -l 100 -r 1 -Ql 10000 -Qr 1 -w_type random\n./gen -n 10000 -l 100 -r 100 -Ql 5000 -Qr 5000 -w_type max\n./gen -n 20000 -l 1 -r 1 -Ql 10000 -Qr 10000 -w_type min\n./gen -n 30000 -l 100 -r 1 -Ql 1 -Qr 10000 -w_type one_side_heavier\n./gen -n 40000 -l 1 -r 100 -Ql 10000 -Qr 1 -w_type one_side_heavier\n./gen -n 50000 -l 100 -r 100 -Ql 1 -Qr 1 -w_type random\n./gen -n 60000 -l 50 -r 50 -Ql 10000 -Qr 1 -w_type random\n./gen -n 70000 -l 50 -r 50 -Ql 1 -Qr 10000 -w_type random\n./gen -n 80000 -l 1 -r 1 -Ql 1 -Qr 1 -w_type max\n./gen -n 90000 -l 100 -r 100 -Ql 1 -Qr 1 -w_type min\n./gen -n 100000 -l 100 -r 100 -Ql 10000 -Qr 10000 -w_type random\n./gen -n 99999 -l 50 -r 50 -Ql 5000 -Qr 5000 -w_type alternating\n./gen -n 99998 -l 100 -r 1 -Ql 1 -Qr 10000 -w_type increasing\n./gen -n 99997 -l 1 -r 100 -Ql 10000 -Qr 1 -w_type decreasing\n./gen -n 99996 -l 100 -r 100 -Ql 10000 -Qr 10000 -w_type one_side_heavier\n./gen -n 99995 -l 1 -r 1 -Ql 1 -Qr 1 -w_type random\n./gen -n 99994 -l 100 -r 1 -Ql 10000 -Qr 1 -w_type one_side_heavier\n./gen -n 99993 -l 1 -r 100 -Ql 1 -Qr 10000 -w_type one_side_heavier\n./gen -n 99992 -l 100 -r 100 -Ql 10000 -Qr 10000 -w_type max\n./gen -n 99991 -l 1 -r 1 -Ql 1 -Qr 1 -w_type min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:17.154413",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "355/D",
      "title": "D. Game with Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains a single number n (1 ≤ n ≤ 20).Next n lines contain n lowercase English letters each — table T.",
      "output_spec": "OutputIn a single line print string \"FIRST\", if the first player wins, \"SECOND\", if the second player wins and \"DRAW\", if the game ends with a draw.",
      "sample_tests": "ExamplesInputCopy2abcdOutputCopyDRAWInputCopy2xaayOutputCopyFIRSTInputCopy3aabbcbbacOutputCopyDRAW",
      "description": "D. Game with Strings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single number n (1 ≤ n ≤ 20).Next n lines contain n lowercase English letters each — table T.\n\nOutputIn a single line print string \"FIRST\", if the first player wins, \"SECOND\", if the second player wins and \"DRAW\", if the game ends with a draw.\n\nInputCopy2abcdOutputCopyDRAWInputCopy2xaayOutputCopyFIRSTInputCopy3aabbcbbacOutputCopyDRAW\n\nInputCopy2abcd\n\nOutputCopyDRAW\n\nInputCopy2xaay\n\nOutputCopyFIRST\n\nInputCopy3aabbcbbac\n\nOutputCopyDRAW\n\nNoteConsider the first sample:Good strings are strings: a, ab, ac, abd, acd.The first player moves first and adds letter a to the string, as there is only one good string of length 1. Then the second player can add b or c and the game will end with strings abd or acd, correspondingly. In the first case it will be a draw (the string has one a and one b), in the second case the first player wins. Naturally, in this case the second player prefers to choose letter b and end the game with a draw.Consider the second sample:Good strings are: x, xa, xay.We can see that the game will end with string xay and the first player wins.",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Hello everyone!Very soon on 13 october at 19:30 MSK will take place Codeforces Round #206. I am author of the problems and it's my first round!I would like to thank problem coordinator Gerald Agapov (Gerald), Evgeny Vihrov (gen) for problem testing and Mary Belova (Delinur) for translation of statements to English. Special thanks to Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Score distribution will be standard in both divisions: 500-1000-1500-2000-2500.I wish good luck for everyone and hope that you will enjoy the problems!Congratulations to the winners! Special congratulations to rng_58, the only participant, who have solved all 5 problems!First division: rng_58 sankear VArtem sillycross Endagorion Second division: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD The editorial has been published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 845
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces",
          "content": "355A - Vasya and Digital RootIf d = 0, the there is the only number with , so, if k = 1, the answer is 0, otherwise — No solution.If d > 0, then one of correct numbers is d × 10k - 1.Time complexity: O(1) + O(k) for the output.355B - Vasya and Public TransportIf we buy a ticket of the fourth type, we don't have to buy anything else, so, the answer is min(c4, answer using tickets of first three types).Now, when we don't have ticket of the fourth type, we can solve the task separately for buses and trolleys.Solving the problem only for buses: if we buy a ticket of the third type, we don't have to buy anything else, so, the answer is min(c3, answer using tickets of first two types).Without tickets of type three, we can solve the problem separately for each bus. If we buy a ticket of the second type, we will spend c2 burles and if we buy ai tickets of the first type, we will spend (ai × c1) burles. So, the answer for bus i is min(c2, ai × c1).Now it is not difficult to obtain the following solution: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Time complexity: O(n + m).354A - Vasya and RobotBrute force how many times we will use operation from the left. So, if we use it k times, then it's clear, that we will take first k items by the left operations and last (n - k) items by the right operations. So, robot will spend sumLeft[k]·l + sumRight[n - k]·r energy plus some penalty for the same operations. To minimize this penalty we should perform the operations in the following order LRLRL ... RLRLLLLL ..., starting from the bigger set. For example, if k = 7, n - k = 4, we should perform operations in this order: LRLRLRLRL LL. So, we will have to pay the penalty two times (7 - 4 - 1).sumLeft[i] — sum of first i weights, sumRight[i] — sum of last i weights.Solution in pseudocode: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Time complexity: O(n).354B - Game with StringsWe will say that cell (r, c) corresponds to a string s, if there exist correct path, which ends in the cell (r, c) and this path corresponds to a string s.Let call a set of cells which corresponds to some string s a state. One state can correspond to different strings. We can't brute force all possible strings, because their count — is too big, but we can brute force all possible states. It's not hard to observe that all cells that corresponds to some string s lies on same diagonal, so the total count of states is 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). In implementation we can denote state with diagonal number (from 1 to 2n - 1) and bitmask of cells corresponding to this state (2n).From each state we can move to 26 different states (actually less) and all possible moves depends on the state, not on the string. On the image you can see an example of move: from state, which is highlighted in blue by letter a we will move to the state, which is highlighted in yellow.Now, for each state we can calculate a value of (count of letters A  -  count of letters B) in the string, starting from this state. If at the moment is first players turn (an even diagonal), we have to maximize this value, otherwise — minimize. It can be implemented as recursion with memoization.The winner can be determined by the value of state, which corresponds to the single cell (1, 1).Complexity: O(2n × (n + alpha)), where alpha is the size of alphabet.354C - Vasya and Beautiful ArraysThe problem was to find greatest d, such that ai ≥ d,  ai mod d ≤ k holds for each i.Let m = min(ai), then d ≤ m. Let consider two cases:. In this case we will brute force answer from k + 1 to m. We can check, if number d is a correct answer in the following way:We have to check that ai mod d ≤ k for some fixed d, which is equals to , where . Since all these intervals [x·d..x·d + k] doesn't intersects each with other, we can just check that , where cnt[l..r] — count of numbers ai in the interval [l..r].Time complexity: O(maxA log maxA), proof is based on the sum of harmonic series.354D - Transferring PyramidThis tasks is solvable with dynamic programming. First of all let consider solution with complexity O(n3).Let dp[i][j] be the answer for the highlighted in blue part (minimal cost of transferring all special cells that lies inside this area). Then dp[n][0] will be the answer for our original problem.How to recalculate such DP? It's clear that in the leftmost column (inside the blue area) we will choose at most one cell as the top of some subpyramid. If we choose two, then the smallest one will lie fully inside the biggest one (as the orange subpyramid lies inside the blue one). Now, let brute force the cell, which will be the top of subpyramid in this column in time O(n) and we will obtain the following transition:To simplify the formulas, let assume that . 0 ≤ k ≤ i, where k is the height on which we will choose our top cell, or 0, if we don't choose any subpyramid in this column. sumUp[i][p] — count of special cells in the i-th column at height starting from p, this cells we will have to transfer one by one, using the first type operations.We can reduce the complexity by one n, if we will recalculate out DP in the following way: 0 ≤ k ≤ i; for all j > 0.The proof that this is correct is quite simple and is left to the reader. :)Also, we can observe that it is not profitably to take some subpyramid with height greater than , because for such subpyramid we will pay  > 3k, but if we transfer all cells using the first type operations we will pay only 3k. So, the second dimension (j) in out DP can be reduced to .Also, to receive AC, you should store only last 2 layers of the DP, otherwise there will be not enough memory.Time complexity: .354E - Lucky Number RepresentationAuthor's solution, much more complicated than suggested by many participants during the competition, easy solution will be described below.First of all, let write a DP with complexity O(N * lucky_count(N)), where lucky_count(N) is the count of lucky numbers  ≤ N, lucky_count(10n) = 3n. As we can see, for all sufficiently large N solution exists. Really — for every N > 523.Now, we can say that for N ≤ 10000 we have a solution, which is found using DP. Let's solve the task for larger values of N.Next and key idea is to separate the task into two parts: N = N1 + N2. Let's choose N1 and N2 in such way that for them it was easy to find a solution and then merge these two solutions into one. Let N1 = N mod 4000, N2 = N - N1. Here we can have a problem that there is no solution for number N1, in this case we can do N1 = N1 + 4000, N2 = N2 - 4000.Now it is guaranteed that solutions exists for both N1 and N2, moreover, the solution for number N1 will contain only numbers of not more than 3 digits ( < 1000). The proof is quite easy: if N1 < 4000 — it is obvious; else — if the solution uses some number of the form (4000 + some_lucky_number), we can replace it with just some_lucky_number and receive a correct solution for number (N1 - 4000), but is doesn't exist!So, the solution for number N1 we have found using DP, now let's find the solution for N2. If it will contains only of numbers of the form (some_lucky_number × 1000), then we will be able to easily merge this solution with solution for N1, so, let's find such a solution. Here we will use the fact that N2 is divisible by 4. For simplicity, let's divide N2 by 1000 and in the end multiply all Ans2(i) by the same 1000. Let P = N2 / 4. Now, let's construct the solution. Consider, for example, P = 95: we will walk through digits of this number, last digit — 5, means that we want to put digit 4 at the last decimal position of five answer numbers — ok, put it and in the last, sixth, number leave there digit 0. Go forward, digit 9 — we don't have nine numbers, but we can replace seven fours with four sevens, then to the second position we have to put (9 - 7) fours and 4 sevens, in total — 6 numbers, exactly as much as we have.Thus, if next digit d ≤ 6, we just put to the first d answer numbers digit 4 to the next position; if d > 6, then we put 4 sevens and (d - 7) fours. In all other numbers we just leave digit 0 at this position.If Ans1(i) — answer for N1, Ans2(i) — for N2, the the answer for N will be just Ans(i) = Ans1(i) + Ans2(i).Time complexity for one number: O(logN).During the competition many participants have wrote the following solution:dp[i][j] — can we put the digit to the last i decimal positions of the answer number in such way that we will get correct last i digits in the sum and with carry to the next position equals to j. Then the solution exist iff dp[19][0] = true. To restore the answer we just have to remember for each state the previous state. Base — dp[0][0] = true. Transition — brute force how many fours and sevens we will put to the i-th position.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 355 和字母"
          },
          "content_length": 9015
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 5",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 6",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 7",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; i++) {\n        string variableName = \"line \" + to_string(i + 1);\n        string s = inf.readLine(pattern, variableName);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; i++) {\n        string variableName = \"line \" + to_string(i + 1);\n        string s = inf.readLine(pattern, variableName);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; i++) {\n        string variableName = \"line \" + to_string(i + 1);\n        string s = inf.readLine(pattern, variableName);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(n, 'a'));\n\n    if (type == \"all_a\") {\n        // grid filled with 'a's\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(n, 'a');\n        }\n    } else if (type == \"all_b\") {\n        // grid filled with 'b's\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(n, 'b');\n        }\n    } else if (type == \"all_c\") {\n        // grid filled with 'c's\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(n, 'c');\n        }\n    } else if (type == \"random\") {\n        // grid filled with random letters 'a' to 'z'\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = rnd.next(26) + 'a';\n                grid[i] += c;\n            }\n        }\n    } else if (type == \"random_ab\") {\n        // grid filled with random 'a's and 'b's\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = (rnd.next(2) ? 'a' : 'b');\n                grid[i] += c;\n            }\n        }\n    } else if (type == \"favor_a\") {\n        // grid filled with 'a's and 'b's, more 'a's\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = (rnd.next(10) < 7 ? 'a' : 'b');\n                grid[i] += c;\n            }\n        }\n    } else if (type == \"favor_b\") {\n        // grid filled with 'a's and 'b's, more 'b's\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = (rnd.next(10) < 7 ? 'b' : 'a');\n                grid[i] += c;\n            }\n        }\n    } else if (type == \"draw\") {\n        // grid designed to cause a draw\n        // For simplicity, fill the grid with letters other than 'a' and 'b', e.g., 'c's\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(n, 'c');\n        }\n    } else {\n        // Default: random letters\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = rnd.next(26) + 'a';\n                grid[i] += c;\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(n, 'a'));\n\n    if (type == \"all_a\") {\n        // grid filled with 'a's\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(n, 'a');\n        }\n    } else if (type == \"all_b\") {\n        // grid filled with 'b's\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(n, 'b');\n        }\n    } else if (type == \"all_c\") {\n        // grid filled with 'c's\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(n, 'c');\n        }\n    } else if (type == \"random\") {\n        // grid filled with random letters 'a' to 'z'\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = rnd.next(26) + 'a';\n                grid[i] += c;\n            }\n        }\n    } else if (type == \"random_ab\") {\n        // grid filled with random 'a's and 'b's\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = (rnd.next(2) ? 'a' : 'b');\n                grid[i] += c;\n            }\n        }\n    } else if (type == \"favor_a\") {\n        // grid filled with 'a's and 'b's, more 'a's\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = (rnd.next(10) < 7 ? 'a' : 'b');\n                grid[i] += c;\n            }\n        }\n    } else if (type == \"favor_b\") {\n        // grid filled with 'a's and 'b's, more 'b's\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = (rnd.next(10) < 7 ? 'b' : 'a');\n                grid[i] += c;\n            }\n        }\n    } else if (type == \"draw\") {\n        // grid designed to cause a draw\n        // For simplicity, fill the grid with letters other than 'a' and 'b', e.g., 'c's\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(n, 'c');\n        }\n    } else {\n        // Default: random letters\n        for (int i = 0; i < n; i++) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; j++) {\n                char c = rnd.next(26) + 'a';\n                grid[i] += c;\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_a\n./gen -n 1 -type all_b\n./gen -n 1 -type all_c\n./gen -n 1 -type random_ab\n\n./gen -n 2 -type all_a\n./gen -n 2 -type all_b\n./gen -n 2 -type all_c\n./gen -n 2 -type draw\n./gen -n 2 -type random_ab\n\n./gen -n 5 -type favor_a\n./gen -n 5 -type favor_b\n./gen -n 5 -type draw\n./gen -n 5 -type random_ab\n\n./gen -n 10 -type random\n./gen -n 10 -type draw\n./gen -n 10 -type random_ab\n\n./gen -n 15 -type favor_a\n./gen -n 15 -type favor_b\n./gen -n 15 -type random\n\n./gen -n 18 -type all_a\n./gen -n 18 -type all_b\n./gen -n 18 -type all_c\n./gen -n 18 -type random_ab\n\n./gen -n 20 -type random\n./gen -n 20 -type draw\n./gen -n 20 -type random_ab\n\n./gen -n 20 -type favor_a\n./gen -n 20 -type favor_b\n./gen -n 20 -type all_a\n./gen -n 20 -type all_b\n./gen -n 20 -type all_c\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:19.144293",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "355/E",
      "title": "E. Vasya and Beautiful Arrays",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 3·105; 1 ≤ k ≤ 106). The second line contains n integers ai (1 ≤ ai ≤ 106) — array a.",
      "output_spec": "OutputIn the single line print a single number — the maximum possible beauty of the resulting array.",
      "sample_tests": "ExamplesInputCopy6 13 6 10 12 13 16OutputCopy3InputCopy5 38 21 52 15 77OutputCopy7",
      "description": "E. Vasya and Beautiful Arrays\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 3·105; 1 ≤ k ≤ 106). The second line contains n integers ai (1 ≤ ai ≤ 106) — array a.\n\nOutputIn the single line print a single number — the maximum possible beauty of the resulting array.\n\nInputCopy6 13 6 10 12 13 16OutputCopy3InputCopy5 38 21 52 15 77OutputCopy7\n\nInputCopy6 13 6 10 12 13 16\n\nOutputCopy3\n\nInputCopy5 38 21 52 15 77\n\nOutputCopy7\n\nNoteIn the first sample we can obtain the array:3 6 9 12 12 15In the second sample we can obtain the next array:7 21 49 14 77",
      "solutions": [
        {
          "title": "Codeforces Round #206 - Codeforces",
          "content": "Hello everyone!Very soon on 13 october at 19:30 MSK will take place Codeforces Round #206. I am author of the problems and it's my first round!I would like to thank problem coordinator Gerald Agapov (Gerald), Evgeny Vihrov (gen) for problem testing and Mary Belova (Delinur) for translation of statements to English. Special thanks to Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Score distribution will be standard in both divisions: 500-1000-1500-2000-2500.I wish good luck for everyone and hope that you will enjoy the problems!Congratulations to the winners! Special congratulations to rng_58, the only participant, who have solved all 5 problems!First division: rng_58 sankear VArtem sillycross Endagorion Second division: sola_93 Bega squirtle Dixtosa anupam.kanyal UPD The editorial has been published.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9178",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 845
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces",
          "content": "355A - Vasya and Digital RootIf d = 0, the there is the only number with , so, if k = 1, the answer is 0, otherwise — No solution.If d > 0, then one of correct numbers is d × 10k - 1.Time complexity: O(1) + O(k) for the output.355B - Vasya and Public TransportIf we buy a ticket of the fourth type, we don't have to buy anything else, so, the answer is min(c4, answer using tickets of first three types).Now, when we don't have ticket of the fourth type, we can solve the task separately for buses and trolleys.Solving the problem only for buses: if we buy a ticket of the third type, we don't have to buy anything else, so, the answer is min(c3, answer using tickets of first two types).Without tickets of type three, we can solve the problem separately for each bus. If we buy a ticket of the second type, we will spend c2 burles and if we buy ai tickets of the first type, we will spend (ai × c1) burles. So, the answer for bus i is min(c2, ai × c1).Now it is not difficult to obtain the following solution: function f(x, k) {\n res = 0;\n for i = 1 .. k\n res = res + min(c2, x[i] * c1);\n\n return min(c3, res);\n }\n\n ans = min(c4, f(a, n) + f(b, m));Time complexity: O(n + m).354A - Vasya and RobotBrute force how many times we will use operation from the left. So, if we use it k times, then it's clear, that we will take first k items by the left operations and last (n - k) items by the right operations. So, robot will spend sumLeft[k]·l + sumRight[n - k]·r energy plus some penalty for the same operations. To minimize this penalty we should perform the operations in the following order LRLRL ... RLRLLLLL ..., starting from the bigger set. For example, if k = 7, n - k = 4, we should perform operations in this order: LRLRLRLRL LL. So, we will have to pay the penalty two times (7 - 4 - 1).sumLeft[i] — sum of first i weights, sumRight[i] — sum of last i weights.Solution in pseudocode: ans = inf;\n for i = 0 .. n {\n curr = firstSum[i] * l + lastSum[n-i] * r;\n if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n ans = min(ans, curr);\n }Time complexity: O(n).354B - Game with StringsWe will say that cell (r, c) corresponds to a string s, if there exist correct path, which ends in the cell (r, c) and this path corresponds to a string s.Let call a set of cells which corresponds to some string s a state. One state can correspond to different strings. We can't brute force all possible strings, because their count — is too big, but we can brute force all possible states. It's not hard to observe that all cells that corresponds to some string s lies on same diagonal, so the total count of states is 21 + 22 + ... + 2n - 1 + 2n + 2n - 1 + ... + 22 + 21 = O(2n). In implementation we can denote state with diagonal number (from 1 to 2n - 1) and bitmask of cells corresponding to this state (2n).From each state we can move to 26 different states (actually less) and all possible moves depends on the state, not on the string. On the image you can see an example of move: from state, which is highlighted in blue by letter a we will move to the state, which is highlighted in yellow.Now, for each state we can calculate a value of (count of letters A  -  count of letters B) in the string, starting from this state. If at the moment is first players turn (an even diagonal), we have to maximize this value, otherwise — minimize. It can be implemented as recursion with memoization.The winner can be determined by the value of state, which corresponds to the single cell (1, 1).Complexity: O(2n × (n + alpha)), where alpha is the size of alphabet.354C - Vasya and Beautiful ArraysThe problem was to find greatest d, such that ai ≥ d,  ai mod d ≤ k holds for each i.Let m = min(ai), then d ≤ m. Let consider two cases:. In this case we will brute force answer from k + 1 to m. We can check, if number d is a correct answer in the following way:We have to check that ai mod d ≤ k for some fixed d, which is equals to , where . Since all these intervals [x·d..x·d + k] doesn't intersects each with other, we can just check that , where cnt[l..r] — count of numbers ai in the interval [l..r].Time complexity: O(maxA log maxA), proof is based on the sum of harmonic series.354D - Transferring PyramidThis tasks is solvable with dynamic programming. First of all let consider solution with complexity O(n3).Let dp[i][j] be the answer for the highlighted in blue part (minimal cost of transferring all special cells that lies inside this area). Then dp[n][0] will be the answer for our original problem.How to recalculate such DP? It's clear that in the leftmost column (inside the blue area) we will choose at most one cell as the top of some subpyramid. If we choose two, then the smallest one will lie fully inside the biggest one (as the orange subpyramid lies inside the blue one). Now, let brute force the cell, which will be the top of subpyramid in this column in time O(n) and we will obtain the following transition:To simplify the formulas, let assume that . 0 ≤ k ≤ i, where k is the height on which we will choose our top cell, or 0, if we don't choose any subpyramid in this column. sumUp[i][p] — count of special cells in the i-th column at height starting from p, this cells we will have to transfer one by one, using the first type operations.We can reduce the complexity by one n, if we will recalculate out DP in the following way: 0 ≤ k ≤ i; for all j > 0.The proof that this is correct is quite simple and is left to the reader. :)Also, we can observe that it is not profitably to take some subpyramid with height greater than , because for such subpyramid we will pay  > 3k, but if we transfer all cells using the first type operations we will pay only 3k. So, the second dimension (j) in out DP can be reduced to .Also, to receive AC, you should store only last 2 layers of the DP, otherwise there will be not enough memory.Time complexity: .354E - Lucky Number RepresentationAuthor's solution, much more complicated than suggested by many participants during the competition, easy solution will be described below.First of all, let write a DP with complexity O(N * lucky_count(N)), where lucky_count(N) is the count of lucky numbers  ≤ N, lucky_count(10n) = 3n. As we can see, for all sufficiently large N solution exists. Really — for every N > 523.Now, we can say that for N ≤ 10000 we have a solution, which is found using DP. Let's solve the task for larger values of N.Next and key idea is to separate the task into two parts: N = N1 + N2. Let's choose N1 and N2 in such way that for them it was easy to find a solution and then merge these two solutions into one. Let N1 = N mod 4000, N2 = N - N1. Here we can have a problem that there is no solution for number N1, in this case we can do N1 = N1 + 4000, N2 = N2 - 4000.Now it is guaranteed that solutions exists for both N1 and N2, moreover, the solution for number N1 will contain only numbers of not more than 3 digits ( < 1000). The proof is quite easy: if N1 < 4000 — it is obvious; else — if the solution uses some number of the form (4000 + some_lucky_number), we can replace it with just some_lucky_number and receive a correct solution for number (N1 - 4000), but is doesn't exist!So, the solution for number N1 we have found using DP, now let's find the solution for N2. If it will contains only of numbers of the form (some_lucky_number × 1000), then we will be able to easily merge this solution with solution for N1, so, let's find such a solution. Here we will use the fact that N2 is divisible by 4. For simplicity, let's divide N2 by 1000 and in the end multiply all Ans2(i) by the same 1000. Let P = N2 / 4. Now, let's construct the solution. Consider, for example, P = 95: we will walk through digits of this number, last digit — 5, means that we want to put digit 4 at the last decimal position of five answer numbers — ok, put it and in the last, sixth, number leave there digit 0. Go forward, digit 9 — we don't have nine numbers, but we can replace seven fours with four sevens, then to the second position we have to put (9 - 7) fours and 4 sevens, in total — 6 numbers, exactly as much as we have.Thus, if next digit d ≤ 6, we just put to the first d answer numbers digit 4 to the next position; if d > 6, then we put 4 sevens and (d - 7) fours. In all other numbers we just leave digit 0 at this position.If Ans1(i) — answer for N1, Ans2(i) — for N2, the the answer for N will be just Ans(i) = Ans1(i) + Ans2(i).Time complexity for one number: O(logN).During the competition many participants have wrote the following solution:dp[i][j] — can we put the digit to the last i decimal positions of the answer number in such way that we will get correct last i digits in the sum and with carry to the next position equals to j. Then the solution exist iff dp[19][0] = true. To restore the answer we just have to remember for each state the previous state. Base — dp[0][0] = true. Transition — brute force how many fours and sevens we will put to the i-th position.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8672",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 355 和字母"
          },
          "content_length": 9015
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #206 - Codeforces - Code 1",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #206 - Codeforces - Code 2",
          "code": "3\naba\nbcc\nccc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9178",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 1",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 2",
          "code": "function f(x, k) {\n    res = 0;\n    for i = 1 .. k\n      res = res + min(c2, x[i] * c1);\n\n    return min(c3, res);\n  }\n\n  ans = min(c4, f(a, n) + f(b, m));",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 3",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 4",
          "code": "ans = inf;\n  for i = 0 .. n {\n    curr = firstSum[i] * l + lastSum[n-i] * r;\n    if ( i > n - i ) curr = curr + (2i - n - 1) * Ql;\n    if ( i < n - i ) curr = curr + (n - 2i - 1) * Qr;\n\n    ans = min(ans, curr);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 5",
          "code": "cnt[i] = count of numbers ≤ i we have in array a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 6",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #206 — Editorial - Codeforces - Code 7",
          "code": "int sum = 0;\nfor (int i = 1; i * d <= maxA; i++) {\n    sum += cnt[i * d + k] - cnt[i * d - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8672",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000);\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000);\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000);\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000);\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000);\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000);\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random ai in [1, 1e6]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"all_equal\") {\n        // All ai equal to a random value\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_ai\") {\n        // All ai in [1, 10]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    } else if (type == \"large_ai\") {\n        // All ai in [1e6 - 10, 1e6]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1000000 - 10, 1000000);\n    } else if (type == \"one_large_rest_small\") {\n        // One ai large, rest small\n        a[0] = rnd.next(1000000 - 10, 1000000);\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next(1, 5);\n    } else if (type == \"all_ones\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max_k\") {\n        // k = maximum allowed\n        k = 1000000;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n    } else if (type == \"min_k\") {\n        // k = 0\n        k = 0;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n    } else if (type == \"gcd_is_one\") {\n        // Ensure that GCD is 1\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(2, 1000000);\n        // Modify first ai to be co-prime with others\n        a[0] = a[1] + 1;\n    } else if (type == \"gcd_is_k\") {\n        // Adjust ai so that GCD can be k\n        int g = k == 0 ? 1 : k;\n        for (int i = 0; i < n; ++i)\n            a[i] = g * rnd.next(1, 1000);\n    } else if (type == \"max_ai_min_k\") {\n        k = 0;\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000;\n    } else if (type == \"large_n_small_k\") {\n        k = rnd.next(1, 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n    } else if (type == \"repeated_elements\") {\n        int cnt = rnd.next(2, 10);\n        vector<int> vals(cnt);\n        for (int i = 0; i < cnt; ++i)\n            vals[i] = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = vals[rnd.next(0, cnt-1)];\n    } else if (type == \"ai_equals_k\") {\n        // All ai equal to k + 1\n        int ai_value = min(k + 1, 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_value;\n    } else if (type == \"ai_less_than_k\") {\n        // All ai less than or equal to k\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, min(k, 1000000));\n        }\n    } else if (type == \"ai_multiples_of_m\") {\n        int m = rnd.next(2, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = m * rnd.next(1, 1000);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random ai in [1, 1e6]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"all_equal\") {\n        // All ai equal to a random value\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_ai\") {\n        // All ai in [1, 10]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    } else if (type == \"large_ai\") {\n        // All ai in [1e6 - 10, 1e6]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1000000 - 10, 1000000);\n    } else if (type == \"one_large_rest_small\") {\n        // One ai large, rest small\n        a[0] = rnd.next(1000000 - 10, 1000000);\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next(1, 5);\n    } else if (type == \"all_ones\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max_k\") {\n        // k = maximum allowed\n        k = 1000000;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n    } else if (type == \"min_k\") {\n        // k = 0\n        k = 0;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n    } else if (type == \"gcd_is_one\") {\n        // Ensure that GCD is 1\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(2, 1000000);\n        // Modify first ai to be co-prime with others\n        a[0] = a[1] + 1;\n    } else if (type == \"gcd_is_k\") {\n        // Adjust ai so that GCD can be k\n        int g = k == 0 ? 1 : k;\n        for (int i = 0; i < n; ++i)\n            a[i] = g * rnd.next(1, 1000);\n    } else if (type == \"max_ai_min_k\") {\n        k = 0;\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000;\n    } else if (type == \"large_n_small_k\") {\n        k = rnd.next(1, 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n    } else if (type == \"repeated_elements\") {\n        int cnt = rnd.next(2, 10);\n        vector<int> vals(cnt);\n        for (int i = 0; i < cnt; ++i)\n            vals[i] = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = vals[rnd.next(0, cnt-1)];\n    } else if (type == \"ai_equals_k\") {\n        // All ai equal to k + 1\n        int ai_value = min(k + 1, 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_value;\n    } else if (type == \"ai_less_than_k\") {\n        // All ai less than or equal to k\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, min(k, 1000000));\n        }\n    } else if (type == \"ai_multiples_of_m\") {\n        int m = rnd.next(2, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = m * rnd.next(1, 1000);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 2 -k 0 -type min_k\n./gen -n 10 -k 1000000 -type max_k\n./gen -n 1000 -k 500000 -type random\n./gen -n 100000 -k 0 -type min_k\n./gen -n 300000 -k 1000000 -type max_k\n\n./gen -n 100000 -k 1000000 -type all_equal\n./gen -n 100000 -k 1 -type all_ones\n./gen -n 100000 -k 1000000 -type small_ai\n./gen -n 100000 -k 1 -type large_ai\n./gen -n 100000 -k 1 -type one_large_rest_small\n./gen -n 100000 -k 1 -type gcd_is_one\n\n./gen -n 300000 -k 1 -type repeated_elements\n./gen -n 300000 -k 1 -type ai_equals_k\n./gen -n 300000 -k 500000 -type ai_less_than_k\n./gen -n 300000 -k 1000000 -type ai_multiples_of_m\n\n./gen -n 300000 -k 100 -type large_n_small_k\n./gen -n 300000 -k 0 -type max_ai_min_k\n./gen -n 300000 -k 1 -type gcd_is_k\n./gen -n 300000 -k 1 -type ai_multiples_of_m\n\n./gen -n 299999 -k 299999 -type random\n./gen -n 300000 -k 1 -type ai_equals_k\n./gen -n 1 -k 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:21.049927",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "356/A",
      "title": "A. Knight Tournament",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (2 ≤ n ≤ 3·105; 1 ≤ m ≤ 3·105) — the number of knights and the number of fights. Each of the following m lines contains three integers li, ri, xi (1 ≤ li < ri ≤ n; li ≤ xi ≤ ri) — the description of the i-th fight.It is guaranteed that the input is correct and matches the problem statement. It is guaranteed that at least two knights took part in each battle.",
      "output_spec": "OutputPrint n integers. If the i-th knight lost, then the i-th number should equal the number of the knight that beat the knight number i. If the i-th knight is the winner, then the i-th number must equal 0.",
      "sample_tests": "ExamplesInputCopy4 31 2 11 3 31 4 4OutputCopy3 1 4 0 InputCopy8 43 5 43 7 62 8 81 8 1OutputCopy0 8 4 6 4 8 6 1",
      "description": "A. Knight Tournament\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, m (2 ≤ n ≤ 3·105; 1 ≤ m ≤ 3·105) — the number of knights and the number of fights. Each of the following m lines contains three integers li, ri, xi (1 ≤ li < ri ≤ n; li ≤ xi ≤ ri) — the description of the i-th fight.It is guaranteed that the input is correct and matches the problem statement. It is guaranteed that at least two knights took part in each battle.\n\nOutputPrint n integers. If the i-th knight lost, then the i-th number should equal the number of the knight that beat the knight number i. If the i-th knight is the winner, then the i-th number must equal 0.\n\nInputCopy4 31 2 11 3 31 4 4OutputCopy3 1 4 0 InputCopy8 43 5 43 7 62 8 81 8 1OutputCopy0 8 4 6 4 8 6 1\n\nInputCopy4 31 2 11 3 31 4 4\n\nOutputCopy3 1 4 0\n\nInputCopy8 43 5 43 7 62 8 81 8 1\n\nOutputCopy0 8 4 6 4 8 6 1\n\nNoteConsider the first test case. Knights 1 and 2 fought the first fight and knight 1 won. Knights 1 and 3 fought the second fight and knight 3 won. The last fight was between knights 3 and 4, knight 4 won.",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Hi all.Today there is a school regional team competition in programming in Saratov. We've decided to make a round using tasks from this competition. The problems were prepared by Gerald (Gerald Agapov), Fefer_Ivan (Ivan Fefer), HolkinPV (Pavel Kholkin), Igor_Kudryashov (Igor Kudryashov), IlyaLos (Ilya Los) and Nerevar (Dmitry Matov). The problems' statements were translated into english by Mary Belova (Delinur).The round starts today, on 15th of October, at 16:00 MSK. Parcipants from both divisions are welcome to take part in it.The scoring is standard: 500-1000-1500-2000-2500.Congratulations to the winners!Division I: tourist mmaxio Dmitry_Egorov iwiwi bmerry Division II: Apsara ZJUDBLab noxe intsashka Kanari UPD: The tutorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 751
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 356\\s*A"
          },
          "content_length": 8532
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 356\\s*A"
          },
          "content_length": 8532
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    vector<bool> alive(n + 1, true); // Knights are numbered from 1 to n\n    for (int fight = 0; fight < m; ++fight) {\n        int l_i = inf.readInt(1, n - 1, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i + 1, n, \"r_i\");\n        inf.readSpace();\n        int x_i = inf.readInt(l_i, r_i, \"x_i\");\n        inf.readEoln();\n\n        // Collect alive participants in [l_i, r_i]\n        int participants = 0;\n        for (int k = l_i; k <= r_i; ++k) {\n            if (alive[k]) {\n                ++participants;\n            }\n        }\n        // Ensure at least two knights took part in each battle\n        ensuref(participants >= 2, \"In fight %d, less than two participants (participants=%d)\", fight + 1, participants);\n        ensuref(alive[x_i], \"In fight %d, x_i (%d) is not alive\", fight + 1, x_i);\n\n        // Remove all participants except x_i from alive[]\n        for (int k = l_i; k <= r_i; ++k) {\n            if (alive[k] && k != x_i) {\n                alive[k] = false;\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    vector<bool> alive(n + 1, true); // Knights are numbered from 1 to n\n    for (int fight = 0; fight < m; ++fight) {\n        int l_i = inf.readInt(1, n - 1, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i + 1, n, \"r_i\");\n        inf.readSpace();\n        int x_i = inf.readInt(l_i, r_i, \"x_i\");\n        inf.readEoln();\n\n        // Collect alive participants in [l_i, r_i]\n        int participants = 0;\n        for (int k = l_i; k <= r_i; ++k) {\n            if (alive[k]) {\n                ++participants;\n            }\n        }\n        // Ensure at least two knights took part in each battle\n        ensuref(participants >= 2, \"In fight %d, less than two participants (participants=%d)\", fight + 1, participants);\n        ensuref(alive[x_i], \"In fight %d, x_i (%d) is not alive\", fight + 1, x_i);\n\n        // Remove all participants except x_i from alive[]\n        for (int k = l_i; k <= r_i; ++k) {\n            if (alive[k] && k != x_i) {\n                alive[k] = false;\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    vector<bool> alive(n + 1, true); // Knights are numbered from 1 to n\n    for (int fight = 0; fight < m; ++fight) {\n        int l_i = inf.readInt(1, n - 1, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i + 1, n, \"r_i\");\n        inf.readSpace();\n        int x_i = inf.readInt(l_i, r_i, \"x_i\");\n        inf.readEoln();\n\n        // Collect alive participants in [l_i, r_i]\n        int participants = 0;\n        for (int k = l_i; k <= r_i; ++k) {\n            if (alive[k]) {\n                ++participants;\n            }\n        }\n        // Ensure at least two knights took part in each battle\n        ensuref(participants >= 2, \"In fight %d, less than two participants (participants=%d)\", fight + 1, participants);\n        ensuref(alive[x_i], \"In fight %d, x_i (%d) is not alive\", fight + 1, x_i);\n\n        // Remove all participants except x_i from alive[]\n        for (int k = l_i; k <= r_i; ++k) {\n            if (alive[k] && k != x_i) {\n                alive[k] = false;\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"pairwise\");\n\n    vector<int> alive_knights;\n    for(int i = 1; i <= n; ++i)\n        alive_knights.push_back(i);\n\n    vector< tuple<int, int, int> > fights; \n\n    if (type == \"pairwise\") {\n        map<int, int> defeated_by;\n        while (alive_knights.size() > 1) {\n            vector<int> new_alive;\n            for(size_t i = 0; i < alive_knights.size(); i += 2) {\n                if (i + 1 < alive_knights.size()) {\n                    int a = alive_knights[i];\n                    int b = alive_knights[i+1];\n                    int winner = rnd.next(0,1) ? a : b;\n                    int loser = (winner == a) ? b : a;\n\n                    int Li = min(a, b);\n                    int Ri = max(a, b);\n                    int Xi = winner;\n\n                    fights.push_back(make_tuple(Li, Ri, Xi));\n\n                    defeated_by[loser] = winner;\n                    new_alive.push_back(winner);\n                } else {\n                    new_alive.push_back(alive_knights[i]);\n                }\n            }\n            alive_knights = new_alive;\n        }\n\n        int m = fights.size();\n        printf(\"%d %d\\n\", n, m);\n        for(auto &fight : fights) {\n            int Li, Ri, Xi;\n            tie(Li, Ri, Xi) = fight;\n            printf(\"%d %d %d\\n\", Li, Ri, Xi);\n        }\n\n    } else if (type == \"chain\") {\n        int m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 1; i < n; ++i) {\n            int Li = i;\n            int Ri = i + 1;\n            int Xi = Ri;\n            printf(\"%d %d %d\\n\", Li, Ri, Xi);\n        }\n\n    } else if (type == \"reverse_chain\") {\n        int m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 1; i < n; ++i) {\n            int Li = i;\n            int Ri = i + 1;\n            int Xi = Li;\n            printf(\"%d %d %d\\n\", Li, Ri, Xi);\n        }\n    } else if (type == \"random\") {\n        map<int, int> defeated_by;\n        while (alive_knights.size() > 1) {\n            shuffle(alive_knights.begin(), alive_knights.end());\n            vector<int> new_alive;\n            for(size_t i = 0; i < alive_knights.size(); i += 2) {\n                if (i + 1 < alive_knights.size()) {\n                    int a = alive_knights[i];\n                    int b = alive_knights[i+1];\n                    int winner = rnd.next(0,1) ? a : b;\n                    int loser = (winner == a) ? b : a;\n\n                    int Li = min(a, b);\n                    int Ri = max(a, b);\n                    int Xi = winner;\n\n                    fights.push_back(make_tuple(Li, Ri, Xi));\n\n                    defeated_by[loser] = winner;\n                    new_alive.push_back(winner);\n                } else {\n                    new_alive.push_back(alive_knights[i]);\n                }\n            }\n            alive_knights = new_alive;\n        }\n\n        int m = fights.size();\n        printf(\"%d %d\\n\", n, m);\n        for(auto &fight : fights) {\n            int Li, Ri, Xi;\n            tie(Li, Ri, Xi) = fight;\n            printf(\"%d %d %d\\n\", Li, Ri, Xi);\n        }\n\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"pairwise\");\n\n    vector<int> alive_knights;\n    for(int i = 1; i <= n; ++i)\n        alive_knights.push_back(i);\n\n    vector< tuple<int, int, int> > fights; \n\n    if (type == \"pairwise\") {\n        map<int, int> defeated_by;\n        while (alive_knights.size() > 1) {\n            vector<int> new_alive;\n            for(size_t i = 0; i < alive_knights.size(); i += 2) {\n                if (i + 1 < alive_knights.size()) {\n                    int a = alive_knights[i];\n                    int b = alive_knights[i+1];\n                    int winner = rnd.next(0,1) ? a : b;\n                    int loser = (winner == a) ? b : a;\n\n                    int Li = min(a, b);\n                    int Ri = max(a, b);\n                    int Xi = winner;\n\n                    fights.push_back(make_tuple(Li, Ri, Xi));\n\n                    defeated_by[loser] = winner;\n                    new_alive.push_back(winner);\n                } else {\n                    new_alive.push_back(alive_knights[i]);\n                }\n            }\n            alive_knights = new_alive;\n        }\n\n        int m = fights.size();\n        printf(\"%d %d\\n\", n, m);\n        for(auto &fight : fights) {\n            int Li, Ri, Xi;\n            tie(Li, Ri, Xi) = fight;\n            printf(\"%d %d %d\\n\", Li, Ri, Xi);\n        }\n\n    } else if (type == \"chain\") {\n        int m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 1; i < n; ++i) {\n            int Li = i;\n            int Ri = i + 1;\n            int Xi = Ri;\n            printf(\"%d %d %d\\n\", Li, Ri, Xi);\n        }\n\n    } else if (type == \"reverse_chain\") {\n        int m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 1; i < n; ++i) {\n            int Li = i;\n            int Ri = i + 1;\n            int Xi = Li;\n            printf(\"%d %d %d\\n\", Li, Ri, Xi);\n        }\n    } else if (type == \"random\") {\n        map<int, int> defeated_by;\n        while (alive_knights.size() > 1) {\n            shuffle(alive_knights.begin(), alive_knights.end());\n            vector<int> new_alive;\n            for(size_t i = 0; i < alive_knights.size(); i += 2) {\n                if (i + 1 < alive_knights.size()) {\n                    int a = alive_knights[i];\n                    int b = alive_knights[i+1];\n                    int winner = rnd.next(0,1) ? a : b;\n                    int loser = (winner == a) ? b : a;\n\n                    int Li = min(a, b);\n                    int Ri = max(a, b);\n                    int Xi = winner;\n\n                    fights.push_back(make_tuple(Li, Ri, Xi));\n\n                    defeated_by[loser] = winner;\n                    new_alive.push_back(winner);\n                } else {\n                    new_alive.push_back(alive_knights[i]);\n                }\n            }\n            alive_knights = new_alive;\n        }\n\n        int m = fights.size();\n        printf(\"%d %d\\n\", n, m);\n        for(auto &fight : fights) {\n            int Li, Ri, Xi;\n            tie(Li, Ri, Xi) = fight;\n            printf(\"%d %d %d\\n\", Li, Ri, Xi);\n        }\n\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type reverse_chain\n./gen -n 2 -type pairwise\n./gen -n 2 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type reverse_chain\n./gen -n 10 -type pairwise\n./gen -n 10 -type random\n\n./gen -n 100 -type chain\n./gen -n 100 -type reverse_chain\n./gen -n 100 -type pairwise\n./gen -n 100 -type random\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type reverse_chain\n./gen -n 1000 -type pairwise\n./gen -n 1000 -type random\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type reverse_chain\n./gen -n 10000 -type pairwise\n./gen -n 10000 -type random\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type reverse_chain\n./gen -n 100000 -type pairwise\n./gen -n 100000 -type random\n\n./gen -n 200000 -type chain\n./gen -n 200000 -type reverse_chain\n./gen -n 200000 -type pairwise\n./gen -n 200000 -type random\n\n./gen -n 300000 -type chain\n./gen -n 300000 -type reverse_chain\n./gen -n 300000 -type pairwise\n./gen -n 300000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:23.025589",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "356/B",
      "title": "Problem 356/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\");\n    inf.readEoln();\n\n    string x = inf.readToken(\"[a-z]{1,1000000}\", \"x\");\n    inf.readEoln();\n\n    string y = inf.readToken(\"[a-z]{1,1000000}\", \"y\");\n    inf.readEoln();\n\n    long long len_a = n * (long long)x.size();\n    long long len_b = m * (long long)y.size();\n\n    ensuref(len_a == len_b, \"Strings 'a' and 'b' must have equal length, but len_a=%lld, len_b=%lld\", len_a, len_b);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\");\n    inf.readEoln();\n\n    string x = inf.readToken(\"[a-z]{1,1000000}\", \"x\");\n    inf.readEoln();\n\n    string y = inf.readToken(\"[a-z]{1,1000000}\", \"y\");\n    inf.readEoln();\n\n    long long len_a = n * (long long)x.size();\n    long long len_b = m * (long long)y.size();\n\n    ensuref(len_a == len_b, \"Strings 'a' and 'b' must have equal length, but len_a=%lld, len_b=%lld\", len_a, len_b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\");\n    inf.readEoln();\n\n    string x = inf.readToken(\"[a-z]{1,1000000}\", \"x\");\n    inf.readEoln();\n\n    string y = inf.readToken(\"[a-z]{1,1000000}\", \"y\");\n    inf.readEoln();\n\n    long long len_a = n * (long long)x.size();\n    long long len_b = m * (long long)y.size();\n\n    ensuref(len_a == len_b, \"Strings 'a' and 'b' must have equal length, but len_a=%lld, len_b=%lld\", len_a, len_b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int len_x = opt<int>(\"len_x\");\n    int len_y = opt<int>(\"len_y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure len_x and len_y are within [1, 1e6]\n    len_x = max(1, min(len_x, (int)1e6));\n    len_y = max(1, min(len_y, (int)1e6));\n\n    // Generate x and y\n    string x(len_x, ' ');\n    string y(len_y, ' ');\n\n    if (type == \"same\") {\n        // x and y are the same random string\n        for(int i = 0; i < len_x; ++i)\n            x[i] = 'a' + rnd.next(26);\n        y = x;\n    } else if (type == \"complement\") {\n        // x and y are different\n        for(int i = 0; i < len_x; ++i)\n            x[i] = 'a' + rnd.next(26);\n        for(int i = 0; i < len_y; ++i)\n            do {\n                y[i] = 'a' + rnd.next(26);\n            } while(len_x == len_y && y[i] == x[i % len_x]);\n    } else if (type == \"partial\") {\n        // x and y share some characters\n        int common_len = min(len_x, len_y) / 2;\n        for(int i = 0; i < common_len; ++i) {\n            char c = 'a' + rnd.next(26);\n            x[i] = y[i] = c;\n        }\n        for(int i = common_len; i < len_x; ++i) {\n            x[i] = 'a' + rnd.next(26);\n        }\n        for(int i = common_len; i < len_y; ++i) {\n            y[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"onestring\") {\n        // x and y are strings of the same character\n        char c = 'a' + rnd.next(26);\n        x = string(len_x, c);\n        y = x;\n    } else {\n        // Random x and y\n        for(int i = 0; i < len_x; ++i)\n            x[i] = 'a' + rnd.next(26);\n        for(int i = 0; i < len_y; ++i)\n            y[i] = 'a' + rnd.next(26);\n    }\n\n    // Compute gcd and lcm of len_x and len_y\n    ll gcd_len = __gcd(len_x, len_y);\n    ll lcm_len = (ll)len_x / gcd_len * len_y;\n\n    // Compute unit n and m\n    ll n_unit = len_y / gcd_len;\n    ll m_unit = len_x / gcd_len;\n\n    // Compute maximum factors for n and m\n    ll n_max = (ll)1e12;\n    ll m_max = (ll)1e12;\n    ll f_max_n = n_max / n_unit;\n    ll f_max_m = m_max / m_unit;\n    ll f_max = min(f_max_n, f_max_m);\n\n    // Limit total length to 1e18\n    ll total_length_limit = (ll)1e18;\n    ll f_max_length = total_length_limit / lcm_len;\n    f_max = min(f_max, f_max_length);\n\n    // Ensure f_max >= 1\n    f_max = max(f_max, 1LL);\n\n    // Determine the multiplication factor f\n    ll f = f_max;\n    if (type == \"min_n_m\") {\n        f = 1;\n    } else if (type == \"max_n_m\") {\n        f = f_max;\n    } else if (type == \"random\") {\n        f = rnd.next(1LL, f_max);\n    }\n\n    // Compute n and m\n    ll n = n_unit * f;\n    ll m = m_unit * f;\n\n    // Output n and m\n    printf(\"%lld %lld\\n\", n, m);\n\n    // Output x and y\n    printf(\"%s\\n\", x.c_str());\n    printf(\"%s\\n\", y.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int len_x = opt<int>(\"len_x\");\n    int len_y = opt<int>(\"len_y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure len_x and len_y are within [1, 1e6]\n    len_x = max(1, min(len_x, (int)1e6));\n    len_y = max(1, min(len_y, (int)1e6));\n\n    // Generate x and y\n    string x(len_x, ' ');\n    string y(len_y, ' ');\n\n    if (type == \"same\") {\n        // x and y are the same random string\n        for(int i = 0; i < len_x; ++i)\n            x[i] = 'a' + rnd.next(26);\n        y = x;\n    } else if (type == \"complement\") {\n        // x and y are different\n        for(int i = 0; i < len_x; ++i)\n            x[i] = 'a' + rnd.next(26);\n        for(int i = 0; i < len_y; ++i)\n            do {\n                y[i] = 'a' + rnd.next(26);\n            } while(len_x == len_y && y[i] == x[i % len_x]);\n    } else if (type == \"partial\") {\n        // x and y share some characters\n        int common_len = min(len_x, len_y) / 2;\n        for(int i = 0; i < common_len; ++i) {\n            char c = 'a' + rnd.next(26);\n            x[i] = y[i] = c;\n        }\n        for(int i = common_len; i < len_x; ++i) {\n            x[i] = 'a' + rnd.next(26);\n        }\n        for(int i = common_len; i < len_y; ++i) {\n            y[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"onestring\") {\n        // x and y are strings of the same character\n        char c = 'a' + rnd.next(26);\n        x = string(len_x, c);\n        y = x;\n    } else {\n        // Random x and y\n        for(int i = 0; i < len_x; ++i)\n            x[i] = 'a' + rnd.next(26);\n        for(int i = 0; i < len_y; ++i)\n            y[i] = 'a' + rnd.next(26);\n    }\n\n    // Compute gcd and lcm of len_x and len_y\n    ll gcd_len = __gcd(len_x, len_y);\n    ll lcm_len = (ll)len_x / gcd_len * len_y;\n\n    // Compute unit n and m\n    ll n_unit = len_y / gcd_len;\n    ll m_unit = len_x / gcd_len;\n\n    // Compute maximum factors for n and m\n    ll n_max = (ll)1e12;\n    ll m_max = (ll)1e12;\n    ll f_max_n = n_max / n_unit;\n    ll f_max_m = m_max / m_unit;\n    ll f_max = min(f_max_n, f_max_m);\n\n    // Limit total length to 1e18\n    ll total_length_limit = (ll)1e18;\n    ll f_max_length = total_length_limit / lcm_len;\n    f_max = min(f_max, f_max_length);\n\n    // Ensure f_max >= 1\n    f_max = max(f_max, 1LL);\n\n    // Determine the multiplication factor f\n    ll f = f_max;\n    if (type == \"min_n_m\") {\n        f = 1;\n    } else if (type == \"max_n_m\") {\n        f = f_max;\n    } else if (type == \"random\") {\n        f = rnd.next(1LL, f_max);\n    }\n\n    // Compute n and m\n    ll n = n_unit * f;\n    ll m = m_unit * f;\n\n    // Output n and m\n    printf(\"%lld %lld\\n\", n, m);\n\n    // Output x and y\n    printf(\"%s\\n\", x.c_str());\n    printf(\"%s\\n\", y.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len_x 1 -len_y 1 -type same\n./gen -len_x 1 -len_y 1 -type complement\n./gen -len_x 1 -len_y 1 -type random\n\n./gen -len_x 1 -len_y 2 -type random\n./gen -len_x 2 -len_y 3 -type random\n./gen -len_x 10 -len_y 15 -type random\n./gen -len_x 100 -len_y 150 -type partial\n\n./gen -len_x 1000 -len_y 1000 -type same\n./gen -len_x 1000 -len_y 1000 -type complement\n./gen -len_x 1000 -len_y 1001 -type random\n\n./gen -len_x 500000 -len_y 500000 -type same\n./gen -len_x 500000 -len_y 500001 -type random\n\n./gen -len_x 1000000 -len_y 1000000 -type same\n./gen -len_x 1000000 -len_y 1000000 -type complement\n./gen -len_x 1000000 -len_y 999983 -type random\n\n./gen -len_x 123456 -len_y 789012 -type partial\n./gen -len_x 1000000 -len_y 1 -type random\n./gen -len_x 1 -len_y 1000000 -type random\n\n./gen -len_x 999999 -len_y 999991 -type random\n\n./gen -len_x 1000000 -len_y 1000000 -type onestring\n\n./gen -len_x 1 -len_y 1 -type random\n\n./gen -len_x 2 -len_y 2 -type min_n_m\n./gen -len_x 1000000 -len_y 1000000 -type max_n_m\n\n./gen -len_x 1000000 -len_y 999999 -type random\n./gen -len_x 1000000 -len_y 999983 -type random\n\n./gen -len_x 500000 -len_y 2 -type complement\n\n./gen -len_x 3 -len_y 5 -type complement\n\n./gen -len_x 999999 -len_y 999999 -type random\n./gen -len_x 999999 -len_y 1 -type random\n\n./gen -len_x 999983 -len_y 500029 -type random\n\n# Edge cases with maximal n or m\n./gen -len_x 1 -len_y 1 -type max_n_m\n./gen -len_x 1 -len_y 1 -type min_n_m\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:25.157380",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "356/C",
      "title": "C. Compartments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106) — the number of compartments in the carriage. The second line contains n integers a1, a2, ..., an showing how many students ride in each compartment (0 ≤ ai ≤ 4). It is guaranteed that at least one student is riding in the train.",
      "output_spec": "OutputIf no sequence of swapping seats with other people leads to the desired result, print number \"-1\" (without the quotes). In another case, print the smallest number of people you need to persuade to swap places.",
      "sample_tests": "ExamplesInputCopy51 2 2 4 3OutputCopy2InputCopy34 1 1OutputCopy2InputCopy40 3 0 4OutputCopy0",
      "description": "C. Compartments\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 106) — the number of compartments in the carriage. The second line contains n integers a1, a2, ..., an showing how many students ride in each compartment (0 ≤ ai ≤ 4). It is guaranteed that at least one student is riding in the train.\n\nOutputIf no sequence of swapping seats with other people leads to the desired result, print number \"-1\" (without the quotes). In another case, print the smallest number of people you need to persuade to swap places.\n\nInputCopy51 2 2 4 3OutputCopy2InputCopy34 1 1OutputCopy2InputCopy40 3 0 4OutputCopy0\n\nInputCopy51 2 2 4 3\n\nOutputCopy2\n\nInputCopy34 1 1\n\nOutputCopy2\n\nInputCopy40 3 0 4\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Hi all.Today there is a school regional team competition in programming in Saratov. We've decided to make a round using tasks from this competition. The problems were prepared by Gerald (Gerald Agapov), Fefer_Ivan (Ivan Fefer), HolkinPV (Pavel Kholkin), Igor_Kudryashov (Igor Kudryashov), IlyaLos (Ilya Los) and Nerevar (Dmitry Matov). The problems' statements were translated into english by Mary Belova (Delinur).The round starts today, on 15th of October, at 16:00 MSK. Parcipants from both divisions are welcome to take part in it.The scoring is standard: 500-1000-1500-2000-2500.Congratulations to the winners!Division I: tourist mmaxio Dmitry_Egorov iwiwi bmerry Division II: Apsara ZJUDBLab noxe intsashka Kanari UPD: The tutorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 751
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 356\\s*C"
          },
          "content_length": 8532
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 356\\s*C"
          },
          "content_length": 8532
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4, \"a\");\n    inf.readEoln();\n\n    long long total_students = accumulate(a.begin(), a.end(), 0LL);\n    ensuref(total_students >= 1, \"At least one student should be riding in the train\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4, \"a\");\n    inf.readEoln();\n\n    long long total_students = accumulate(a.begin(), a.end(), 0LL);\n    ensuref(total_students >= 1, \"At least one student should be riding in the train\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4, \"a\");\n    inf.readEoln();\n\n    long long total_students = accumulate(a.begin(), a.end(), 0LL);\n    ensuref(total_students >= 1, \"At least one student should be riding in the train\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        // All compartments have exactly 1 student\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } \n    else if (type == \"all_twos\") {\n        // All compartments have exactly 2 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 2;\n    } \n    else if (type == \"alternating_ones_twos\") {\n        // Compartments alternate between 1 and 2 students\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1;\n    } \n    else if (type == \"few_students\") {\n        // Total students are either 1 or 2\n        int total_students = rnd.next(1, 2);\n        int idx = rnd.next(0, n - 1);\n        a[idx] = total_students;\n    } \n    else if (type == \"max_students\") {\n        // All compartments have exactly 4 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 4;\n    } \n    else if (type == \"single_compartment\") {\n        // Only one compartment has students\n        int idx = rnd.next(0, n - 1);\n        a[idx] = rnd.next(1, 4);\n    } \n    else if (type == \"edge_impossible\") {\n        // Total students cannot be divided into sums of 3 and 4\n        vector<int> bad_numbers = {1, 2, 5, 7, 11, 13, 14, 17, 19, 22};\n        int idx = rnd.next(0, int(bad_numbers.size()) - 1);\n        int total_students = bad_numbers[idx];\n        total_students = min(total_students, n * 4); // Adjust if necessary\n        int remaining_students = total_students;\n        for(int i = 0; i < n && remaining_students > 0; ++i) {\n            a[i] = min(4, remaining_students);\n            remaining_students -= a[i];\n        }\n    } \n    else if (type == \"random_with_many_small_groups\") {\n        // Random ai, but ensure many compartments have 1 or 2 students\n        for(int i = 0; i < n; ++i) {\n            int r = rnd.next(100);\n            if (r < 45)\n                a[i] = 1;\n            else if (r < 90)\n                a[i] = 2;\n            else\n                a[i] = rnd.next(3, 4);\n        }\n        // Ensure at least one student is on the train\n        if (accumulate(a.begin(), a.end(), 0) == 0) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, 4);\n        }\n    }\n    else if (type == \"random_large\") {\n        // Random ai between 0 and 4 for large n\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 4);\n        }\n        // Ensure at least one student is on the train\n        if (accumulate(a.begin(), a.end(), 0) == 0) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, 4);\n        }\n    } \n    else { // type == \"random\" or default\n        // Random ai between 0 and 4\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 4);\n        }\n        // Ensure at least one student is on the train\n        if (accumulate(a.begin(), a.end(), 0) == 0) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, 4);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        // All compartments have exactly 1 student\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } \n    else if (type == \"all_twos\") {\n        // All compartments have exactly 2 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 2;\n    } \n    else if (type == \"alternating_ones_twos\") {\n        // Compartments alternate between 1 and 2 students\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1;\n    } \n    else if (type == \"few_students\") {\n        // Total students are either 1 or 2\n        int total_students = rnd.next(1, 2);\n        int idx = rnd.next(0, n - 1);\n        a[idx] = total_students;\n    } \n    else if (type == \"max_students\") {\n        // All compartments have exactly 4 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 4;\n    } \n    else if (type == \"single_compartment\") {\n        // Only one compartment has students\n        int idx = rnd.next(0, n - 1);\n        a[idx] = rnd.next(1, 4);\n    } \n    else if (type == \"edge_impossible\") {\n        // Total students cannot be divided into sums of 3 and 4\n        vector<int> bad_numbers = {1, 2, 5, 7, 11, 13, 14, 17, 19, 22};\n        int idx = rnd.next(0, int(bad_numbers.size()) - 1);\n        int total_students = bad_numbers[idx];\n        total_students = min(total_students, n * 4); // Adjust if necessary\n        int remaining_students = total_students;\n        for(int i = 0; i < n && remaining_students > 0; ++i) {\n            a[i] = min(4, remaining_students);\n            remaining_students -= a[i];\n        }\n    } \n    else if (type == \"random_with_many_small_groups\") {\n        // Random ai, but ensure many compartments have 1 or 2 students\n        for(int i = 0; i < n; ++i) {\n            int r = rnd.next(100);\n            if (r < 45)\n                a[i] = 1;\n            else if (r < 90)\n                a[i] = 2;\n            else\n                a[i] = rnd.next(3, 4);\n        }\n        // Ensure at least one student is on the train\n        if (accumulate(a.begin(), a.end(), 0) == 0) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, 4);\n        }\n    }\n    else if (type == \"random_large\") {\n        // Random ai between 0 and 4 for large n\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 4);\n        }\n        // Ensure at least one student is on the train\n        if (accumulate(a.begin(), a.end(), 0) == 0) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, 4);\n        }\n    } \n    else { // type == \"random\" or default\n        // Random ai between 0 and 4\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 4);\n        }\n        // Ensure at least one student is on the train\n        if (accumulate(a.begin(), a.end(), 0) == 0) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, 4);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_compartment\n./gen -n 2 -type few_students\n./gen -n 5 -type random\n./gen -n 5 -type edge_impossible\n./gen -n 10 -type all_ones\n./gen -n 10 -type all_twos\n./gen -n 10 -type alternating_ones_twos\n./gen -n 10 -type max_students\n./gen -n 10 -type random\n\n./gen -n 50 -type random_with_many_small_groups\n./gen -n 50 -type edge_impossible\n\n./gen -n 100 -type all_ones\n./gen -n 100 -type all_twos\n./gen -n 100 -type alternating_ones_twos\n./gen -n 100 -type max_students\n./gen -n 100 -type random\n\n./gen -n 500 -type edge_impossible\n./gen -n 500 -type single_compartment\n\n./gen -n 1000 -type all_ones\n./gen -n 1000 -type all_twos\n./gen -n 1000 -type random_with_many_small_groups\n./gen -n 1000 -type max_students\n./gen -n 1000 -type random\n\n./gen -n 5000 -type random_large\n\n./gen -n 10000 -type random_large\n./gen -n 10000 -type alternating_ones_twos\n\n./gen -n 50000 -type random_with_many_small_groups\n./gen -n 50000 -type edge_impossible\n\n./gen -n 100000 -type all_ones\n./gen -n 100000 -type max_students\n./gen -n 100000 -type random\n\n./gen -n 1000000 -type random_large\n./gen -n 1000000 -type single_compartment\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:27.190114",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "356/D",
      "title": "D. Монеты и мешочки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и s (1 ≤ n, s ≤ 70000) — количество мешочков и общее количество монеток. В следующей строке записаны n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 70000), где ai обозначает, сколько монеток лежит в i-ом мешочке.",
      "output_spec": "Выходные данныеЕсли ответа не существует, выведите -1. Иначе, выведите n строк. В i-ой строке выведите, что лежит в i-ом мешочке. Первое число в строке — ci (0 ≤ ci ≤ ai) — должно означать, сколько монеток лежит непосредственно в i-ом мешочке (монеты в мешочках, которые лежат в i-ом мешочке, не считаются). Второе число в строке — ki (0 ≤ ki < n) — должно означать, сколько мешочков лежит непосредственно в i-ом мешочке (мешочки, которые лежат внутри мешочков, которые лежат в i-ом мешочке, не считаются). Далее в строке должны следовать ki целых чисел — номера мешочков, которые лежат непосредственно в i-ом мешочке.В выведенном ответе общее количество монет должно быть равно s. Если для i-го мешочка в ответе посчитать общее количество монет, которое находится внутри него, то должно получаться ai. Никакой мешочек не должен лежать в более чем одном мешочке непосредственно. Допускается более одного уровня вложенности мешочков (смотрите второй тестовый пример). Если существует несколько правильных ответов, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 31 3 1Выходные данныеСкопировать1 01 2 3 11 0Входные данныеСкопировать3 31 3 1Выходные данныеСкопировать1 02 1 30 1 1Входные данныеСкопировать1 21Выходные данныеСкопировать-1Входные данныеСкопировать8 102 7 3 4 1 3 1 2Выходные данныеСкопировать2 01 2 1 40 2 7 80 2 5 61 03 01 02 0",
      "description": "D. Монеты и мешочки\n\nограничение по времени на тест2.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и s (1 ≤ n, s ≤ 70000) — количество мешочков и общее количество монеток. В следующей строке записаны n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 70000), где ai обозначает, сколько монеток лежит в i-ом мешочке.\n\nВходные данные\n\nВыходные данныеЕсли ответа не существует, выведите -1. Иначе, выведите n строк. В i-ой строке выведите, что лежит в i-ом мешочке. Первое число в строке — ci (0 ≤ ci ≤ ai) — должно означать, сколько монеток лежит непосредственно в i-ом мешочке (монеты в мешочках, которые лежат в i-ом мешочке, не считаются). Второе число в строке — ki (0 ≤ ki < n) — должно означать, сколько мешочков лежит непосредственно в i-ом мешочке (мешочки, которые лежат внутри мешочков, которые лежат в i-ом мешочке, не считаются). Далее в строке должны следовать ki целых чисел — номера мешочков, которые лежат непосредственно в i-ом мешочке.В выведенном ответе общее количество монет должно быть равно s. Если для i-го мешочка в ответе посчитать общее количество монет, которое находится внутри него, то должно получаться ai. Никакой мешочек не должен лежать в более чем одном мешочке непосредственно. Допускается более одного уровня вложенности мешочков (смотрите второй тестовый пример). Если существует несколько правильных ответов, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать3 31 3 1Выходные данныеСкопировать1 01 2 3 11 0Входные данныеСкопировать3 31 3 1Выходные данныеСкопировать1 02 1 30 1 1Входные данныеСкопировать1 21Выходные данныеСкопировать-1Входные данныеСкопировать8 102 7 3 4 1 3 1 2Выходные данныеСкопировать2 01 2 1 40 2 7 80 2 5 61 03 01 02 0\n\nВходные данныеСкопировать3 31 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 01 2 3 11 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 31 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 02 1 30 1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 21\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8 102 7 3 4 1 3 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 01 2 1 40 2 7 80 2 5 61 03 01 02 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеНа рисунках снизу показаны два возможных решения одного и того же тестового примера из условия. Левый рисунок соответствует первому тестовому примеру, правый — второму тестовому примеру.",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Привет всем.Сегодня в Саратове проходит региональная командная олимпиада школьников по программированию. Мы решили сделать раунд с использованием задач этого соревнования. Задачи к раунду готовили: Gerald (Геральд Агапов), Fefer_Ivan (Иван Фефер), HolkinPV (Павел Холкин), Igor_Kudryashov (Игорь Кудряшов), IlyaLos (Илья Лось) и Nerevar (Дмитрий Матов). Условия на английский переводила Мария Белова (Delinur).Раунд начнется сегодня, 15 октября, в 16:00 MSK. К участию приглашаются участники обоих дивизионов.Разбалловка стандартная: 500-1000-1500-2000-2500.Поздравляем победителей!Первый дивизион: tourist mmaxio Dmitry_Egorov iwiwi bmerry Второй дивизион: Apsara ZJUDBLab noxe intsashka Kanari UPD: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 726
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces",
          "content": "357A - Кружок школьниковВ задаче нужно было перебрать все варианты проходного балла от 1 до 100 и для каждого варианта посчитать, какие получаются размеры групп. Если нашли подходящие разбиения, выводим соответствующий одном из них проходной балл, иначе выводим 0.357B - День ФлагаБудем обрабатывать танцы в порядке их исполнения, и определять цвета формы участвующим в них танцорам. Если в текущем танце нет ни одного ранее танцевавшего участника, то назначим всем троим танцорам различные цвета формы произвольным образом. В случае же, если есть один такой танцор, тогда для него цвет формы уже известен. Два других цвета формы произвольным образом распределим между остальными двумя танцорами.356A - Рыцарский турнирПусть в очередной битве (l, r, x) сражается K рыцарей. Тогда в этой задаче было достаточно научиться находить всех этих рыцарей за время O(K) или O(KlogN). Рассмотрим несколько способов сделать это.Способ первый: хранить множество рыцарей в std::set (C++) или в TreeSet(Java). Тогда в C++ мы можем использовать метод lower_bound для нахождения самого первого живого рыцаря в отрезке, а потом итерироваться по множеству, переходя каждый раз к следующему по номеру живому рыцарю. В Java мы бы для этих целей использовали метод subSet. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }Способ второй: определим массив next, значения в котором будут иметь следующий смысл: если рыцарь v живой, то next[v] = v; если рыцарь v выбыл, то next[v] указывает на некоторого рыцаря u > v (next[v] = u), такого, что между v и u нет живых рыцарей. Тогда для того, чтобы для рыцаря v найти следующего по номеру живого рыцаря, нужно пройти по ссылкам next до первого живого рыцаря. Чтобы не ходить многократно по одним и тем же ссылкам, применяем эвристику сжатия путей из DSU. Надо учитывать случай, когда текущий рыцарь последний и уже выбыл из турнира. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Ксюша и ХеммингОбозначим первую строку за x, |x| = lenX, вторую строку за y, |y| = lenY. Пусть L=НОК(lenX, lenY). Очевидно, что для тех больших строк a и b, которые описаны в условии, L является периодом, поэтому достаточно решить задачу для длины L, а затем умножить ответ на . Зафиксируем позицию i в строке x и посмотрим, с символами в каких позициях в строке y будет сравниваться символ xi. Из несложных соображений теории чисел это будут такие позиции 0 ≤ j < lenY, что i ≡ j (mod g), где g=НОД(lenX, lenY). Для каждого возможного остатка r от деления на g и каждого символа c можно посчитать count(r, c) — количество символов c, которые встречаются в y на позициях j таких, что j mod g = r. Тогда при вычислении расстояния Хэмминга напротив символа xi будет ровно count(i mod g, xi) таких же символов, а все остальные сравнения прибавят единицу к расстоянию Хэмминга. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - КупеВ данной задаче требовалось придумать какой-нибудь правильный жадный алгоритм. Один из правильных подходов делает следующее: Сначала соединяет все <<двойки>> с <<единичками>> (образуются <<тройки>>), путем пересаживания <<единичек>>. Рассматривает два случая в зависимости от того, <<единичек>> больше изначально или <<двоек>>. Если больше единичек, то пробует соединять оставшиеся после первого пункта одинокие <<единички>> в тройки, если <<двоек>>, то пробует из каждых трех <<двоек>> образовать две <<тройки>>. После применения пункта два, могут остаться еще какие-то <<единички>> или <<двойки>>. Нужно разобрать случаи того, что осталось, руками (случаев будет мало). В задаче нужно руководствоваться скорее здравым смыслом, нежели какими-то известными жадными соображениями. Неплохо помогает написать стресс-тестирование с наивным решением (обходом в ширину), чтобы убедиться в корректности вашей жадности.356D - Монеты и мешочкиОчевидно, что мешки и отношения \"лежит непосредственно в\" образуют лес. К каждой вершиной должно быть связано некоторое число ci — количество монет в соответствующем мешке. Тогда, если мы для каждой вершины посчитаем величину fi — сумма значений cj в поддереве этой вершины, то должны выполняться следующие условия: fi = ai сумма fi по вершинам, которые являются корнями деревьев, равна s. Очевидно, что мешок с наибольшим ai будет корнем какого-то из деревьев. Также достаточно легко понять, что решение задачи существует тогда и только тогда, когда можно выбрать такой набор ai1, ai2, ..., aik, что сумма ai1 + ai2 + ... + aik равна s, причем один из мешков с наибольшим ai входит в такой набор. В одну сторону это очевидно, в другую покажем конструктивно: пусть у нас есть такой набор. Тогда все мешки, вошедшие в набор, кроме самого большого, будут \"отдельными\", то для них ci = ai, а все не вошедшие мешки мы последовательно положим друг в друга и в первый, получив матрешку (т.е. дерево с корнем в самом большом мешке будет ориентированной цепью).Задача свелась к задаче о наборе суммы s из предметов a1, ... an. Это задача является NP-полной, и обычно в подобных ограничениях решается так: пусть T(i, j) = 1, если можно набрать сумму j, используя какие-то из первых i предметов, и T(i, j) = 0 в противном случае. Тогда . Заметим, что i-ая строка этой таблицы зависит только от (i - 1)-ой, поэтому можно хранить в памяти не всю таблицу, а только две строки. Дальше мы будем использовать то, что значения в таблицы — это нули и единицы, поэтому мы можем хранить строчки таблицы побитово, в массиве из 4-битных целых чисел. Тогда, чтобы получить очередную строчку, мы должны сделать побитовое ИЛИ предыдущей строки и предыдущей строки, сдвинутой на ai бит. Все это можно сделать за действий, поэтому выяснить, можно ли набрать сумму s, можно примерно за операций. Однако, тут нужно применить один трюк для того, чтобы восстановить, какие именно предметы нужно взять. Давайте для каждого значения суммы j будем запоминать величину first(j) — номер такого предмета, после рассмотрения которого стало возможно набрать сумму j. Это позволит нам восстановить ответ.356E - Ксюша и строковая задачаВо время контеста большинство участников писали решение задачи очень похожее на авторское. Одно из авторских решений (более простое) использует полиномиальные хеши (хотя есть решения и без них). Кратко опишем решение. Для каждой позиции i посчитаем с помощью хешей максимальное такое Li, что подстрока s[(i - Li + 1)..(i + Li - 1)] является строкой Грея. Так же посчитаем максимальное такое Pi, что подстрока s[(i - Pi + 1)..(i + Pi - 1)] отличается от строки грея не более чем на один символ. Очевидно, что Pi ≥ Li. Причем если Pi > Li, то также сохраним позицию символа и символ, который различает подстроку и некоторую строку Грея. Понятно, что если бы не нужно было менять символы, тогда ответ был бы равен , где f(L) = 12 + 32 + 72 + ... + L2. Посчитаем ответ, без замены символов. Теперь переберем позицию и новый символ, на который будем менять символ в данной позиции. Как понять, на сколько поменяется ответ на задачу? Посмотрим на все строки грея, вхождения которых перекрывают зафиксированную позицию. После изменения символа на другой, они все перестанут быть строками грея (вычтем их длину в квадрате из ответа). Посмотрим на все строки Грея, которые отличаются ровно в одной зафиксированном символе от некоторой подстроки строки. После изменения на этот символ они все добавятся в ответ (их длину в квадрате нужно добавить в ответ). Суммируя вышесказанное, с помощью Pi Li нужно, используя update на отрезке в offline, посчитать для каждой позиции и символа, на сколько поменяется ответ на задачу, если в данной позиции поставить этот символ. Далее нужно обновит ответ всеми возможными значениями.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 356\\s*D"
          },
          "content_length": 8610
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces",
          "content": "357A - Кружок школьниковВ задаче нужно было перебрать все варианты проходного балла от 1 до 100 и для каждого варианта посчитать, какие получаются размеры групп. Если нашли подходящие разбиения, выводим соответствующий одном из них проходной балл, иначе выводим 0.357B - День ФлагаБудем обрабатывать танцы в порядке их исполнения, и определять цвета формы участвующим в них танцорам. Если в текущем танце нет ни одного ранее танцевавшего участника, то назначим всем троим танцорам различные цвета формы произвольным образом. В случае же, если есть один такой танцор, тогда для него цвет формы уже известен. Два других цвета формы произвольным образом распределим между остальными двумя танцорами.356A - Рыцарский турнирПусть в очередной битве (l, r, x) сражается K рыцарей. Тогда в этой задаче было достаточно научиться находить всех этих рыцарей за время O(K) или O(KlogN). Рассмотрим несколько способов сделать это.Способ первый: хранить множество рыцарей в std::set (C++) или в TreeSet(Java). Тогда в C++ мы можем использовать метод lower_bound для нахождения самого первого живого рыцаря в отрезке, а потом итерироваться по множеству, переходя каждый раз к следующему по номеру живому рыцарю. В Java мы бы для этих целей использовали метод subSet. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }Способ второй: определим массив next, значения в котором будут иметь следующий смысл: если рыцарь v живой, то next[v] = v; если рыцарь v выбыл, то next[v] указывает на некоторого рыцаря u > v (next[v] = u), такого, что между v и u нет живых рыцарей. Тогда для того, чтобы для рыцаря v найти следующего по номеру живого рыцаря, нужно пройти по ссылкам next до первого живого рыцаря. Чтобы не ходить многократно по одним и тем же ссылкам, применяем эвристику сжатия путей из DSU. Надо учитывать случай, когда текущий рыцарь последний и уже выбыл из турнира. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Ксюша и ХеммингОбозначим первую строку за x, |x| = lenX, вторую строку за y, |y| = lenY. Пусть L=НОК(lenX, lenY). Очевидно, что для тех больших строк a и b, которые описаны в условии, L является периодом, поэтому достаточно решить задачу для длины L, а затем умножить ответ на . Зафиксируем позицию i в строке x и посмотрим, с символами в каких позициях в строке y будет сравниваться символ xi. Из несложных соображений теории чисел это будут такие позиции 0 ≤ j < lenY, что i ≡ j (mod g), где g=НОД(lenX, lenY). Для каждого возможного остатка r от деления на g и каждого символа c можно посчитать count(r, c) — количество символов c, которые встречаются в y на позициях j таких, что j mod g = r. Тогда при вычислении расстояния Хэмминга напротив символа xi будет ровно count(i mod g, xi) таких же символов, а все остальные сравнения прибавят единицу к расстоянию Хэмминга. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - КупеВ данной задаче требовалось придумать какой-нибудь правильный жадный алгоритм. Один из правильных подходов делает следующее: Сначала соединяет все <<двойки>> с <<единичками>> (образуются <<тройки>>), путем пересаживания <<единичек>>. Рассматривает два случая в зависимости от того, <<единичек>> больше изначально или <<двоек>>. Если больше единичек, то пробует соединять оставшиеся после первого пункта одинокие <<единички>> в тройки, если <<двоек>>, то пробует из каждых трех <<двоек>> образовать две <<тройки>>. После применения пункта два, могут остаться еще какие-то <<единички>> или <<двойки>>. Нужно разобрать случаи того, что осталось, руками (случаев будет мало). В задаче нужно руководствоваться скорее здравым смыслом, нежели какими-то известными жадными соображениями. Неплохо помогает написать стресс-тестирование с наивным решением (обходом в ширину), чтобы убедиться в корректности вашей жадности.356D - Монеты и мешочкиОчевидно, что мешки и отношения \"лежит непосредственно в\" образуют лес. К каждой вершиной должно быть связано некоторое число ci — количество монет в соответствующем мешке. Тогда, если мы для каждой вершины посчитаем величину fi — сумма значений cj в поддереве этой вершины, то должны выполняться следующие условия: fi = ai сумма fi по вершинам, которые являются корнями деревьев, равна s. Очевидно, что мешок с наибольшим ai будет корнем какого-то из деревьев. Также достаточно легко понять, что решение задачи существует тогда и только тогда, когда можно выбрать такой набор ai1, ai2, ..., aik, что сумма ai1 + ai2 + ... + aik равна s, причем один из мешков с наибольшим ai входит в такой набор. В одну сторону это очевидно, в другую покажем конструктивно: пусть у нас есть такой набор. Тогда все мешки, вошедшие в набор, кроме самого большого, будут \"отдельными\", то для них ci = ai, а все не вошедшие мешки мы последовательно положим друг в друга и в первый, получив матрешку (т.е. дерево с корнем в самом большом мешке будет ориентированной цепью).Задача свелась к задаче о наборе суммы s из предметов a1, ... an. Это задача является NP-полной, и обычно в подобных ограничениях решается так: пусть T(i, j) = 1, если можно набрать сумму j, используя какие-то из первых i предметов, и T(i, j) = 0 в противном случае. Тогда . Заметим, что i-ая строка этой таблицы зависит только от (i - 1)-ой, поэтому можно хранить в памяти не всю таблицу, а только две строки. Дальше мы будем использовать то, что значения в таблицы — это нули и единицы, поэтому мы можем хранить строчки таблицы побитово, в массиве из 4-битных целых чисел. Тогда, чтобы получить очередную строчку, мы должны сделать побитовое ИЛИ предыдущей строки и предыдущей строки, сдвинутой на ai бит. Все это можно сделать за действий, поэтому выяснить, можно ли набрать сумму s, можно примерно за операций. Однако, тут нужно применить один трюк для того, чтобы восстановить, какие именно предметы нужно взять. Давайте для каждого значения суммы j будем запоминать величину first(j) — номер такого предмета, после рассмотрения которого стало возможно набрать сумму j. Это позволит нам восстановить ответ.356E - Ксюша и строковая задачаВо время контеста большинство участников писали решение задачи очень похожее на авторское. Одно из авторских решений (более простое) использует полиномиальные хеши (хотя есть решения и без них). Кратко опишем решение. Для каждой позиции i посчитаем с помощью хешей максимальное такое Li, что подстрока s[(i - Li + 1)..(i + Li - 1)] является строкой Грея. Так же посчитаем максимальное такое Pi, что подстрока s[(i - Pi + 1)..(i + Pi - 1)] отличается от строки грея не более чем на один символ. Очевидно, что Pi ≥ Li. Причем если Pi > Li, то также сохраним позицию символа и символ, который различает подстроку и некоторую строку Грея. Понятно, что если бы не нужно было менять символы, тогда ответ был бы равен , где f(L) = 12 + 32 + 72 + ... + L2. Посчитаем ответ, без замены символов. Теперь переберем позицию и новый символ, на который будем менять символ в данной позиции. Как понять, на сколько поменяется ответ на задачу? Посмотрим на все строки грея, вхождения которых перекрывают зафиксированную позицию. После изменения символа на другой, они все перестанут быть строками грея (вычтем их длину в квадрате из ответа). Посмотрим на все строки Грея, которые отличаются ровно в одной зафиксированном символе от некоторой подстроки строки. После изменения на этот символ они все добавятся в ответ (их длину в квадрате нужно добавить в ответ). Суммируя вышесказанное, с помощью Pi Li нужно, используя update на отрезке в offline, посчитать для каждой позиции и символа, на сколько поменяется ответ на задачу, если в данной позиции поставить этот символ. Далее нужно обновит ответ всеми возможными значениями.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 356\\s*D"
          },
          "content_length": 8610
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "70000 70000\n1 1 2 2 ... 35000 35000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "70000 70000\n1 1 2 2 ... 35000 35000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 4",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 5",
          "code": "012345678012345678\n012345012345012345",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 6",
          "code": "012345678012345678\n012345012345012345",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 7",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 70000, \"s\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 70000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 70000, \"s\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 70000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 70000, \"s\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 70000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 70000;\n\nint n, s;\nvector<int> ai; // Coins in each bag according to the input\nvector<int> ci; // Coins directly in each bag according to the participant's output\nvector<vector<int>> subbags; // Bags contained directly in each bag\nvector<int> parent; // Parent bag index for each bag\nvector<int> total_coins; // Total coins in each bag computed recursively\nvector<bool> visited; // Visited flag for cycle detection\nvector<bool> in_stack; // In-stack flag for cycle detection\n\nvoid dfs(int u, InStream& stream) {\n    visited[u] = true;\n    in_stack[u] = true;\n    for (int v : subbags[u]) {\n        if (in_stack[v]) {\n            stream.quitf(_wa, \"Cycle detected: bag %d is part of a cycle\", v + 1);\n        }\n        if (!visited[v]) {\n            dfs(v, stream);\n        }\n    }\n    in_stack[u] = false;\n}\n\nint compute_total_coins(int u) {\n    if (total_coins[u] != -1) {\n        return total_coins[u];\n    }\n    int sum = ci[u];\n    for (int v : subbags[u]) {\n        sum += compute_total_coins(v);\n    }\n    total_coins[u] = sum;\n    return sum;\n}\n\nbool readAns(InStream& stream, bool &has_solution, InStream& infStream) {\n    string firstToken = stream.readToken();\n    if (firstToken == \"-1\") {\n        has_solution = false;\n        return true; // No need to check further\n    } else {\n        has_solution = true;\n        stream.seekEoln();\n        // Initialize variables\n        ci.assign(n, 0);\n        subbags.assign(n, vector<int>());\n        parent.assign(n, -1);\n\n        ci[0] = atoi(firstToken.c_str());\n        if (ci[0] < 0 || ci[0] > ai[0]) {\n            stream.quitf(_wa, \"Invalid number of coins in bag 1: %d\", ci[0]);\n        }\n        int ki = stream.readInt(0, n - 1, \"ki\");\n        subbags[0].resize(ki);\n        for (int j = 0; j < ki; j++) {\n            int b = stream.readInt(1, n, \"subbag index\") - 1;\n            if (b == 0) {\n                stream.quitf(_wa, \"Bag cannot contain itself: bag 1\");\n            }\n            if (parent[b] != -1) {\n                stream.quitf(_wa, \"Bag %d is contained in more than one bag\", b + 1);\n            }\n            parent[b] = 0;\n            subbags[0][j] = b;\n        }\n        for (int i = 1; i < n; i++) {\n            ci[i] = stream.readInt(0, ai[i], \"ci\");\n            int ki = stream.readInt(0, n - 1, \"ki\");\n            subbags[i].resize(ki);\n            for (int j = 0; j < ki; j++) {\n                int b = stream.readInt(1, n, \"subbag index\") - 1;\n                if (b == i) {\n                    stream.quitf(_wa, \"Bag cannot contain itself: bag %d\", i + 1);\n                }\n                if (parent[b] != -1) {\n                    stream.quitf(_wa, \"Bag %d is contained in more than one bag\", b + 1);\n                }\n                parent[b] = i;\n                subbags[i][j] = b;\n            }\n        }\n        // Check for cycles\n        visited.assign(n, false);\n        in_stack.assign(n, false);\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, stream);\n            }\n        }\n        // Compute total coins in each bag\n        total_coins.assign(n, -1);\n        for (int i = 0; i < n; i++) {\n            int total = compute_total_coins(i);\n            if (total != ai[i]) {\n                stream.quitf(_wa, \"Total coins in bag %d do not match: expected %d, found %d\", i + 1, ai[i], total);\n            }\n        }\n        // Verify total coins equal s\n        int sum_ci = accumulate(ci.begin(), ci.end(), 0);\n        if (sum_ci != s) {\n            stream.quitf(_wa, \"Total coins in solution do not equal s: expected %d, found %d\", s, sum_ci);\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read input from inf\n    n = inf.readInt(1, MAXN, \"n\");\n    s = inf.readInt(1, MAXN, \"s\");\n    ai.resize(n);\n    for (int i = 0; i < n; i++) {\n        ai[i] = inf.readInt(1, MAXN, \"ai\");\n    }\n    // Read jury's answer\n    bool jury_has_solution;\n    bool participant_has_solution;\n    if (!readAns(ans, jury_has_solution, inf)) {\n        quitf(_fail, \"Jury's answer is incorrect\");\n    }\n    // Read participant's answer\n    if (!readAns(ouf, participant_has_solution, inf)) {\n        // The readAns function for ouf will have already quitf with _wa\n    }\n    // Compare answers\n    if (jury_has_solution) {\n        if (participant_has_solution) {\n            quitf(_ok, \"Participant's solution is correct\");\n        } else {\n            quitf(_wa, \"Participant claims no solution exists, but jury has one\");\n        }\n    } else {\n        if (participant_has_solution) {\n            quitf(_wa, \"Participant found a solution, but jury says none exists\");\n        } else {\n            quitf(_ok, \"Correct: no solution exists\");\n        }\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> tree;\nvector<int> ci;\nvector<int> ai;\n\nint compute_ai(int u) {\n    int total = ci[u];\n    for (int v : tree[u]) {\n        total += compute_ai(v);\n    }\n    ai[u] = total;\n    return total;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    tree.resize(n);\n    ci.resize(n);\n    ai.resize(n);\n\n    if (type == \"random\") {\n        // Generate a random tree\n        vector<int> parent(n, -1);\n        for (int i = 1; i < n; ++i) {\n            int p = rnd.next(0, i - 1);\n            parent[i] = p;\n            tree[p].push_back(i);\n        }\n        // Assign ci\n        int max_ci = opt<int>(\"max_ci\", 100);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n        }\n        // Compute ai's\n        compute_ai(0);\n        // Compute s\n        int s = accumulate(ci.begin(), ci.end(), 0);\n        // Output n s\n        printf(\"%d %d\\n\", n, s);\n        // Output ai's\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"chain\") {\n        // Build a chain\n        for (int i = 1; i < n; ++i) {\n            tree[i - 1].push_back(i);\n        }\n        // Assign ci\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n        }\n        compute_ai(0);\n        int s = accumulate(ci.begin(), ci.end(), 0);\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"star\") {\n        // Build a star, where bag 0 contains all other bags\n        for (int i = 1; i < n; ++i) {\n            tree[0].push_back(i);\n        }\n        // Assign ci\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n        }\n        compute_ai(0);\n        int s = accumulate(ci.begin(), ci.end(), 0);\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"impossible\") {\n        // Generate impossible test case\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 10);\n        }\n        int s = 0;\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> tree;\nvector<int> ci;\nvector<int> ai;\n\nint compute_ai(int u) {\n    int total = ci[u];\n    for (int v : tree[u]) {\n        total += compute_ai(v);\n    }\n    ai[u] = total;\n    return total;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    tree.resize(n);\n    ci.resize(n);\n    ai.resize(n);\n\n    if (type == \"random\") {\n        // Generate a random tree\n        vector<int> parent(n, -1);\n        for (int i = 1; i < n; ++i) {\n            int p = rnd.next(0, i - 1);\n            parent[i] = p;\n            tree[p].push_back(i);\n        }\n        // Assign ci\n        int max_ci = opt<int>(\"max_ci\", 100);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n        }\n        // Compute ai's\n        compute_ai(0);\n        // Compute s\n        int s = accumulate(ci.begin(), ci.end(), 0);\n        // Output n s\n        printf(\"%d %d\\n\", n, s);\n        // Output ai's\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"chain\") {\n        // Build a chain\n        for (int i = 1; i < n; ++i) {\n            tree[i - 1].push_back(i);\n        }\n        // Assign ci\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n        }\n        compute_ai(0);\n        int s = accumulate(ci.begin(), ci.end(), 0);\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"star\") {\n        // Build a star, where bag 0 contains all other bags\n        for (int i = 1; i < n; ++i) {\n            tree[0].push_back(i);\n        }\n        // Assign ci\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n        }\n        compute_ai(0);\n        int s = accumulate(ci.begin(), ci.end(), 0);\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"impossible\") {\n        // Generate impossible test case\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 10);\n        }\n        int s = 0;\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type impossible\n./gen -n 1 -type random\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type impossible\n./gen -n 5 -type random\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type impossible\n./gen -n 10 -type random\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type impossible\n./gen -n 100 -type random -max_ci 1000\n./gen -n 1000 -type random -max_ci 70000\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 10000 -type random -max_ci 70000\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 50000 -type random -max_ci 1\n./gen -n 70000 -type random -max_ci 1\n./gen -n 70000 -type chain\n./gen -n 70000 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:29.265638",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "356/E",
      "title": "E. Xenia and String Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty string t (1 ≤ |t| ≤ 105). String t only consists of lowercase English letters.",
      "output_spec": "OutputPrint the sought maximum beauty value Xenia can get.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopyzzzOutputCopy12InputCopyabaOutputCopy12InputCopyabacabaOutputCopy83InputCopyaaaaaaOutputCopy15",
      "description": "E. Xenia and String Problem\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty string t (1 ≤ |t| ≤ 105). String t only consists of lowercase English letters.\n\nOutputPrint the sought maximum beauty value Xenia can get.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopyzzzOutputCopy12InputCopyabaOutputCopy12InputCopyabacabaOutputCopy83InputCopyaaaaaaOutputCopy15\n\nInputCopyzzz\n\nOutputCopy12\n\nInputCopyaba\n\nOutputCopy12\n\nInputCopyabacaba\n\nOutputCopy83\n\nInputCopyaaaaaa\n\nOutputCopy15\n\nNoteIn the first test sample the given string can be transformed into string p = \"zbz\". Such string contains Gray strings as substrings p[1... 1], p[2... 2], p[3... 3] и p[1... 3]. In total, the beauty of string p gets equal to 12 + 12 + 12 + 32 = 12. You can't obtain a more beautiful string.In the second test case it is not necessary to perform any operation. The initial string has the maximum possible beauty.",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Hi all.Today there is a school regional team competition in programming in Saratov. We've decided to make a round using tasks from this competition. The problems were prepared by Gerald (Gerald Agapov), Fefer_Ivan (Ivan Fefer), HolkinPV (Pavel Kholkin), Igor_Kudryashov (Igor Kudryashov), IlyaLos (Ilya Los) and Nerevar (Dmitry Matov). The problems' statements were translated into english by Mary Belova (Delinur).The round starts today, on 15th of October, at 16:00 MSK. Parcipants from both divisions are welcome to take part in it.The scoring is standard: 500-1000-1500-2000-2500.Congratulations to the winners!Division I: tourist mmaxio Dmitry_Egorov iwiwi bmerry Division II: Apsara ZJUDBLab noxe intsashka Kanari UPD: The tutorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 751
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 356\\s*E"
          },
          "content_length": 8532
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 356\\s*E"
          },
          "content_length": 8532
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string t = inf.readToken(\"[a-z]+\", \"t\");\n    inf.readEoln();\n    ensuref(1 <= int(t.size()) && int(t.size()) <= 100000, \"Length of t (%d) is not between 1 and 100000\", int(t.size()));\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string t = inf.readToken(\"[a-z]+\", \"t\");\n    inf.readEoln();\n    ensuref(1 <= int(t.size()) && int(t.size()) <= 100000, \"Length of t (%d) is not between 1 and 100000\", int(t.size()));\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string t = inf.readToken(\"[a-z]+\", \"t\");\n    inf.readEoln();\n    ensuref(1 <= int(t.size()) && int(t.size()) <= 100000, \"Length of t (%d) is not between 1 and 100000\", int(t.size()));\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s;\n    if (type == \"random\") {\n        /* Generate a random string of length n */\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"same_char\") {\n        /* Generate a string consisting of the same character */\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        /* Generate a palindrome of length n */\n        string first_half;\n        int half = n / 2;\n        for (int i = 0; i < half; ++i) {\n            first_half += (char)('a' + rnd.next(26));\n        }\n        string second_half = first_half;\n        reverse(second_half.begin(), second_half.end());\n        if (n % 2 == 1) {\n            /* Add a middle character */\n            char middle = 'a' + rnd.next(26);\n            s = first_half + middle + second_half;\n        } else {\n            s = first_half + second_half;\n        }\n    } else if (type == \"max_beauty\") {\n        /* Generate a string that maximizes beauty by nesting palindrome-automatons */\n        function<string(int)> make_good_string = [&](int len) {\n            if (len == 0) return string(\"\");\n            if (len == 1) {\n                char c = 'a' + rnd.next(26);\n                return string(1, c);\n            }\n            if (len % 2 == 0) {\n                len--;\n            }\n            int half_len = (len - 1) / 2;\n            string half_s = make_good_string(half_len);\n            char middle = 'a' + rnd.next(26);\n            return half_s + middle + half_s;\n        };\n        s = make_good_string(n);\n        /* Adjust length if necessary */\n        while ((int)s.length() < n) {\n            s += (char)('a' + rnd.next(26));\n        }\n        if ((int)s.length() > n) {\n            s = s.substr(0, n);\n        }\n    } else if (type == \"single_mistake\") {\n        /* Generate a palindrome-automaton and introduce a single error */\n        function<string(int)> make_good_string = [&](int len) {\n            if (len == 0) return string(\"\");\n            if (len == 1) {\n                char c = 'a' + rnd.next(26);\n                return string(1, c);\n            }\n            if (len % 2 == 0) {\n                len--;\n            }\n            int half_len = (len - 1) / 2;\n            string half_s = make_good_string(half_len);\n            char middle = 'a' + rnd.next(26);\n            return half_s + middle + half_s;\n        };\n        s = make_good_string(n);\n        /* Introduce a single mistake */\n        if (s.length() > 2) {\n            int pos = rnd.next(1, n - 2);\n            char original = s[pos];\n            char c;\n            do {\n                c = 'a' + rnd.next(26);\n            } while (c == original);\n            s[pos] = c;\n        }\n    }\n\n    /* Output the string */\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s;\n    if (type == \"random\") {\n        /* Generate a random string of length n */\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"same_char\") {\n        /* Generate a string consisting of the same character */\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        /* Generate a palindrome of length n */\n        string first_half;\n        int half = n / 2;\n        for (int i = 0; i < half; ++i) {\n            first_half += (char)('a' + rnd.next(26));\n        }\n        string second_half = first_half;\n        reverse(second_half.begin(), second_half.end());\n        if (n % 2 == 1) {\n            /* Add a middle character */\n            char middle = 'a' + rnd.next(26);\n            s = first_half + middle + second_half;\n        } else {\n            s = first_half + second_half;\n        }\n    } else if (type == \"max_beauty\") {\n        /* Generate a string that maximizes beauty by nesting palindrome-automatons */\n        function<string(int)> make_good_string = [&](int len) {\n            if (len == 0) return string(\"\");\n            if (len == 1) {\n                char c = 'a' + rnd.next(26);\n                return string(1, c);\n            }\n            if (len % 2 == 0) {\n                len--;\n            }\n            int half_len = (len - 1) / 2;\n            string half_s = make_good_string(half_len);\n            char middle = 'a' + rnd.next(26);\n            return half_s + middle + half_s;\n        };\n        s = make_good_string(n);\n        /* Adjust length if necessary */\n        while ((int)s.length() < n) {\n            s += (char)('a' + rnd.next(26));\n        }\n        if ((int)s.length() > n) {\n            s = s.substr(0, n);\n        }\n    } else if (type == \"single_mistake\") {\n        /* Generate a palindrome-automaton and introduce a single error */\n        function<string(int)> make_good_string = [&](int len) {\n            if (len == 0) return string(\"\");\n            if (len == 1) {\n                char c = 'a' + rnd.next(26);\n                return string(1, c);\n            }\n            if (len % 2 == 0) {\n                len--;\n            }\n            int half_len = (len - 1) / 2;\n            string half_s = make_good_string(half_len);\n            char middle = 'a' + rnd.next(26);\n            return half_s + middle + half_s;\n        };\n        s = make_good_string(n);\n        /* Introduce a single mistake */\n        if (s.length() > 2) {\n            int pos = rnd.next(1, n - 2);\n            char original = s[pos];\n            char c;\n            do {\n                c = 'a' + rnd.next(26);\n            } while (c == original);\n            s[pos] = c;\n        }\n    }\n\n    /* Output the string */\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same_char\n./gen -n 1 -type palindrome\n./gen -n 1 -type max_beauty\n\n./gen -n 2 -type random\n./gen -n 2 -type same_char\n./gen -n 2 -type palindrome\n./gen -n 2 -type max_beauty\n\n./gen -n 3 -type random\n./gen -n 3 -type same_char\n./gen -n 3 -type palindrome\n./gen -n 3 -type max_beauty\n\n./gen -n 5 -type random\n./gen -n 5 -type same_char\n./gen -n 5 -type palindrome\n./gen -n 5 -type single_mistake\n./gen -n 5 -type max_beauty\n\n./gen -n 10 -type random\n./gen -n 10 -type same_char\n./gen -n 10 -type palindrome\n./gen -n 10 -type single_mistake\n./gen -n 10 -type max_beauty\n\n./gen -n 50 -type random\n./gen -n 50 -type same_char\n./gen -n 50 -type palindrome\n./gen -n 50 -type single_mistake\n./gen -n 50 -type max_beauty\n\n./gen -n 100 -type random\n./gen -n 100 -type same_char\n./gen -n 100 -type palindrome\n./gen -n 100 -type single_mistake\n./gen -n 100 -type max_beauty\n\n./gen -n 5000 -type random\n./gen -n 5000 -type same_char\n./gen -n 5000 -type palindrome\n./gen -n 5000 -type single_mistake\n./gen -n 5000 -type max_beauty\n\n./gen -n 10000 -type random\n./gen -n 10000 -type same_char\n./gen -n 10000 -type palindrome\n./gen -n 10000 -type single_mistake\n./gen -n 10000 -type max_beauty\n\n./gen -n 50000 -type random\n./gen -n 50000 -type same_char\n./gen -n 50000 -type palindrome\n./gen -n 50000 -type single_mistake\n./gen -n 50000 -type max_beauty\n\n./gen -n 99999 -type random\n./gen -n 100000 -type random\n./gen -n 100000 -type same_char\n./gen -n 100000 -type palindrome\n./gen -n 100000 -type single_mistake\n./gen -n 100000 -type max_beauty\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:31.358020",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "357/A",
      "title": "A. Group of Students",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer m (2 ≤ m ≤ 100). The second line contains m integers c1, c2, ..., cm, separated by single spaces (0 ≤ ci ≤ 100). The third line contains two space-separated integers x and y (1 ≤ x ≤ y ≤ 10000). At least one ci is greater than 0.",
      "output_spec": "OutputIf it is impossible to pick a passing rate in a way that makes the size of each resulting groups at least x and at most y, print 0. Otherwise, print an integer from 1 to m — the passing rate you'd like to suggest. If there are multiple possible answers, print any of them.",
      "sample_tests": "ExamplesInputCopy53 4 3 2 16 8OutputCopy3InputCopy50 3 3 4 23 10OutputCopy4InputCopy22 53 6OutputCopy0",
      "description": "A. Group of Students\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer m (2 ≤ m ≤ 100). The second line contains m integers c1, c2, ..., cm, separated by single spaces (0 ≤ ci ≤ 100). The third line contains two space-separated integers x and y (1 ≤ x ≤ y ≤ 10000). At least one ci is greater than 0.\n\nOutputIf it is impossible to pick a passing rate in a way that makes the size of each resulting groups at least x and at most y, print 0. Otherwise, print an integer from 1 to m — the passing rate you'd like to suggest. If there are multiple possible answers, print any of them.\n\nInputCopy53 4 3 2 16 8OutputCopy3InputCopy50 3 3 4 23 10OutputCopy4InputCopy22 53 6OutputCopy0\n\nInputCopy53 4 3 2 16 8\n\nOutputCopy3\n\nInputCopy50 3 3 4 23 10\n\nOutputCopy4\n\nInputCopy22 53 6\n\nOutputCopy0\n\nNoteIn the first sample the beginner group has 7 students, the intermediate group has 6 of them. In the second sample another correct answer is 3.",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Hi all.Today there is a school regional team competition in programming in Saratov. We've decided to make a round using tasks from this competition. The problems were prepared by Gerald (Gerald Agapov), Fefer_Ivan (Ivan Fefer), HolkinPV (Pavel Kholkin), Igor_Kudryashov (Igor Kudryashov), IlyaLos (Ilya Los) and Nerevar (Dmitry Matov). The problems' statements were translated into english by Mary Belova (Delinur).The round starts today, on 15th of October, at 16:00 MSK. Parcipants from both divisions are welcome to take part in it.The scoring is standard: 500-1000-1500-2000-2500.Congratulations to the winners!Division I: tourist mmaxio Dmitry_Egorov iwiwi bmerry Division II: Apsara ZJUDBLab noxe intsashka Kanari UPD: The tutorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 751
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 357\\s*A"
          },
          "content_length": 8532
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> c(m);\n\n    for(int i = 0; i < m; i++) {\n        c[i] = inf.readInt(0, 100, \"c[\" + to_string(i+1) + \"]\");\n        if (i < m - 1) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    int x = inf.readInt(1, 10000, \"x\");\n    inf.readChar(' ');\n    int y = inf.readInt(x, 10000, \"y\");\n    inf.readEoln();\n\n    bool has_positive_ci = false;\n    for(int i = 0; i < m; i++) {\n        if (c[i] > 0) {\n            has_positive_ci = true;\n            break;\n        }\n    }\n    ensuref(has_positive_ci, \"At least one ci must be greater than zero\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> c(m);\n\n    for(int i = 0; i < m; i++) {\n        c[i] = inf.readInt(0, 100, \"c[\" + to_string(i+1) + \"]\");\n        if (i < m - 1) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    int x = inf.readInt(1, 10000, \"x\");\n    inf.readChar(' ');\n    int y = inf.readInt(x, 10000, \"y\");\n    inf.readEoln();\n\n    bool has_positive_ci = false;\n    for(int i = 0; i < m; i++) {\n        if (c[i] > 0) {\n            has_positive_ci = true;\n            break;\n        }\n    }\n    ensuref(has_positive_ci, \"At least one ci must be greater than zero\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> c(m);\n\n    for(int i = 0; i < m; i++) {\n        c[i] = inf.readInt(0, 100, \"c[\" + to_string(i+1) + \"]\");\n        if (i < m - 1) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    int x = inf.readInt(1, 10000, \"x\");\n    inf.readChar(' ');\n    int y = inf.readInt(x, 10000, \"y\");\n    inf.readEoln();\n\n    bool has_positive_ci = false;\n    for(int i = 0; i < m; i++) {\n        if (c[i] > 0) {\n            has_positive_ci = true;\n            break;\n        }\n    }\n    ensuref(has_positive_ci, \"At least one ci must be greater than zero\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    int m = inf.readInt(2, 100, \"m\");\n    vector<int> c(m + 1,0); // 1-based indexing of scores from 1 to m\n    for(int i = 1; i <= m; ++i) {\n        c[i] = inf.readInt(0, 100, format(\"c[%d]\", i).c_str());\n    }\n    int x = inf.readInt(1, 10000, \"x\");\n    int y = inf.readInt(x, 10000, \"y\");\n\n    // Read participant's output\n    int pans = ouf.readInt(0, m, \"k\");\n\n    // Function to check if a given k satisfies the condition\n    auto isValid = [&](int k) {\n        int beginner = 0, intermediate = 0;\n        for(int i = 1; i <= m; ++i) {\n            if(i < k)\n                beginner += c[i];\n            else\n                intermediate += c[i];\n        }\n        return (beginner >= x && beginner <= y && intermediate >= x && intermediate <= y);\n    };\n\n    // Check participant's answer\n    if(pans == 0) {\n        // Participant claims no valid k exists\n        bool possible = false;\n        for(int k = 1; k <= m; ++k) {\n            if(isValid(k)) {\n                possible = true;\n                break;\n            }\n        }\n        if(possible) {\n            quitf(_wa, \"Participant output 0 but a valid k exists.\");\n        } else {\n            quitf(_ok, \"Correctly determined that no valid k exists.\");\n        }\n    } else {\n        // Participant provides a k, need to check if it's valid\n        if(isValid(pans)) {\n            quitf(_ok, \"Participant provided a valid k: %d.\", pans);\n        } else {\n            quitf(_wa, \"Participant provided an invalid k: %d.\", pans);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_ci(int total_students, int m, vector<int>& ci) {\n    ci.assign(m+1, 0);  // ci[1..m]\n\n    int remaining_students = total_students;\n\n    int max_total_students = m * 100;\n    if (total_students > max_total_students) {\n        fprintf(stderr, \"Error: total_students (%d) exceeds maximum possible students (%d)\\n\", total_students, max_total_students);\n        exit(1);\n    }\n    if (total_students <= 0) {\n        fprintf(stderr, \"Error: total_students must be at least 1\\n\");\n        exit(1);\n    }\n\n    // Initialize indices\n    vector<int> indices(m);\n    for(int i=1; i<=m; i++) {\n        indices[i-1] = i;\n    }\n\n    while (remaining_students > 0) {\n        // Build list of indices where ci[i] < 100\n        vector<int> available_indices;\n        for (int i = 1; i <= m; i++) {\n            if (ci[i] < 100)\n                available_indices.push_back(i);\n        }\n        if (available_indices.empty()) {\n            fprintf(stderr, \"Error: No available ci to increment, but remaining_students = %d\\n\", remaining_students);\n            exit(1);\n        }\n        // Randomly pick index j from available_indices\n        int idx = rnd.next(available_indices.size());\n        int j = available_indices[idx];\n        ci[j]++;\n        remaining_students--;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\"); // Number of possible scores (between 2 and 100)\n    int total_students = opt<int>(\"total_students\"); // Total students (between 1 and m*100)\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (m < 2 || m > 100) {\n        fprintf(stderr, \"Error: m must be between 2 and 100\\n\");\n        exit(1);\n    }\n\n    if (x < 1 || y < x || y > 10000) {\n        fprintf(stderr, \"Error: x and y must satisfy 1 <= x <= y <= 10000\\n\");\n        exit(1);\n    }\n\n    vector<int> ci(m+1, 0); // ci[1..m]\n\n    int max_total_students = m * 100;\n    if (total_students < 1 || total_students > max_total_students) {\n        fprintf(stderr, \"Error: total_students must be between 1 and %d\\n\", max_total_students);\n        exit(1);\n    }\n\n    if (type == \"random\") {\n        generate_random_ci(total_students, m, ci);\n    } else if (type == \"max_ci\") {\n        // Set ci[1] to min(total_students, 100)\n        int remaining_students = total_students;\n        ci[1] = min(remaining_students, 100);\n        remaining_students -= ci[1];\n        // Distribute remaining students to ci[2..m]\n        for (int i = 2; i <= m && remaining_students > 0; i++) {\n            ci[i] = min(100, remaining_students);\n            remaining_students -= ci[i];\n        }\n    } else if (type == \"single_ci\") {\n        if (total_students > 100) {\n            fprintf(stderr, \"Error: For 'single_ci' type, total_students must be <= 100\\n\");\n            exit(1);\n        }\n        int index = rnd.next(1, m);\n        ci[index] = total_students;\n    } else if (type == \"impossible\") {\n        // Set all ci to 100\n        for (int i = 1; i <= m; i++) {\n            ci[i] = 100;\n        }\n        total_students = m * 100;\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure at least one ci > 0\n    int sum_ci = 0;\n    int positive_ci_count = 0;\n    for (int i = 1; i <= m; i++) {\n        sum_ci += ci[i];\n        if (ci[i] > 0) positive_ci_count++;\n    }\n    if (positive_ci_count == 0) {\n        fprintf(stderr, \"Error: At least one ci must be greater than 0\\n\");\n        exit(1);\n    }\n    if (sum_ci != total_students) {\n        fprintf(stderr, \"Error: Sum of ci (%d) does not equal total_students (%d)\\n\", sum_ci, total_students);\n        exit(1);\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output c1 to cm\n    for (int i = 1; i <= m; i++) {\n        printf(\"%d%c\", ci[i], (i == m) ? '\\n' : ' ');\n    }\n\n    // Output x y\n    printf(\"%d %d\\n\", x, y);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_ci(int total_students, int m, vector<int>& ci) {\n    ci.assign(m+1, 0);  // ci[1..m]\n\n    int remaining_students = total_students;\n\n    int max_total_students = m * 100;\n    if (total_students > max_total_students) {\n        fprintf(stderr, \"Error: total_students (%d) exceeds maximum possible students (%d)\\n\", total_students, max_total_students);\n        exit(1);\n    }\n    if (total_students <= 0) {\n        fprintf(stderr, \"Error: total_students must be at least 1\\n\");\n        exit(1);\n    }\n\n    // Initialize indices\n    vector<int> indices(m);\n    for(int i=1; i<=m; i++) {\n        indices[i-1] = i;\n    }\n\n    while (remaining_students > 0) {\n        // Build list of indices where ci[i] < 100\n        vector<int> available_indices;\n        for (int i = 1; i <= m; i++) {\n            if (ci[i] < 100)\n                available_indices.push_back(i);\n        }\n        if (available_indices.empty()) {\n            fprintf(stderr, \"Error: No available ci to increment, but remaining_students = %d\\n\", remaining_students);\n            exit(1);\n        }\n        // Randomly pick index j from available_indices\n        int idx = rnd.next(available_indices.size());\n        int j = available_indices[idx];\n        ci[j]++;\n        remaining_students--;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\"); // Number of possible scores (between 2 and 100)\n    int total_students = opt<int>(\"total_students\"); // Total students (between 1 and m*100)\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (m < 2 || m > 100) {\n        fprintf(stderr, \"Error: m must be between 2 and 100\\n\");\n        exit(1);\n    }\n\n    if (x < 1 || y < x || y > 10000) {\n        fprintf(stderr, \"Error: x and y must satisfy 1 <= x <= y <= 10000\\n\");\n        exit(1);\n    }\n\n    vector<int> ci(m+1, 0); // ci[1..m]\n\n    int max_total_students = m * 100;\n    if (total_students < 1 || total_students > max_total_students) {\n        fprintf(stderr, \"Error: total_students must be between 1 and %d\\n\", max_total_students);\n        exit(1);\n    }\n\n    if (type == \"random\") {\n        generate_random_ci(total_students, m, ci);\n    } else if (type == \"max_ci\") {\n        // Set ci[1] to min(total_students, 100)\n        int remaining_students = total_students;\n        ci[1] = min(remaining_students, 100);\n        remaining_students -= ci[1];\n        // Distribute remaining students to ci[2..m]\n        for (int i = 2; i <= m && remaining_students > 0; i++) {\n            ci[i] = min(100, remaining_students);\n            remaining_students -= ci[i];\n        }\n    } else if (type == \"single_ci\") {\n        if (total_students > 100) {\n            fprintf(stderr, \"Error: For 'single_ci' type, total_students must be <= 100\\n\");\n            exit(1);\n        }\n        int index = rnd.next(1, m);\n        ci[index] = total_students;\n    } else if (type == \"impossible\") {\n        // Set all ci to 100\n        for (int i = 1; i <= m; i++) {\n            ci[i] = 100;\n        }\n        total_students = m * 100;\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure at least one ci > 0\n    int sum_ci = 0;\n    int positive_ci_count = 0;\n    for (int i = 1; i <= m; i++) {\n        sum_ci += ci[i];\n        if (ci[i] > 0) positive_ci_count++;\n    }\n    if (positive_ci_count == 0) {\n        fprintf(stderr, \"Error: At least one ci must be greater than 0\\n\");\n        exit(1);\n    }\n    if (sum_ci != total_students) {\n        fprintf(stderr, \"Error: Sum of ci (%d) does not equal total_students (%d)\\n\", sum_ci, total_students);\n        exit(1);\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output c1 to cm\n    for (int i = 1; i <= m; i++) {\n        printf(\"%d%c\", ci[i], (i == m) ? '\\n' : ' ');\n    }\n\n    // Output x y\n    printf(\"%d %d\\n\", x, y);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 2 -total_students 2 -x 1 -y 1 -type random\n./gen -m 100 -total_students 10000 -x 1 -y 10000 -type random\n./gen -m 50 -total_students 5000 -x 100 -y 2000 -type max_ci\n./gen -m 10 -total_students 100 -x 50 -y 50 -type single_ci\n./gen -m 100 -total_students 10000 -x 5000 -y 5000 -type impossible\n./gen -m 2 -total_students 200 -x 100 -y 150 -type random\n./gen -m 3 -total_students 300 -x 100 -y 200 -type random\n./gen -m 5 -total_students 500 -x 200 -y 400 -type random\n./gen -m 50 -total_students 5000 -x 2500 -y 2500 -type random\n./gen -m 100 -total_students 10000 -x 9999 -y 10000 -type random\n./gen -m 100 -total_students 10000 -x 10000 -y 10000 -type random\n./gen -m 3 -total_students 50 -x 20 -y 30 -type random\n./gen -m 3 -total_students 50 -x 10 -y 20 -type random\n./gen -m 3 -total_students 50 -x 5 -y 15 -type random\n./gen -m 10 -total_students 1000 -x 100 -y 1000 -type max_ci\n./gen -m 10 -total_students 1000 -x 1 -y 10 -type impossible\n./gen -m 99 -total_students 9900 -x 1000 -y 1000 -type random\n./gen -m 2 -total_students 2 -x 2 -y 2 -type single_ci\n./gen -m 2 -total_students 2 -x 1 -y 1 -type single_ci\n./gen -m 2 -total_students 2 -x 1 -y 2 -type single_ci\n./gen -m 4 -total_students 100 -x 50 -y 51 -type random\n./gen -m 100 -total_students 10000 -x 1 -y 10000 -type impossible\n./gen -m 100 -total_students 10000 -x 5000 -y 10000 -type random\n./gen -m 100 -total_students 10000 -x 1 -y 5000 -type random\n./gen -m 100 -total_students 10000 -x 1 -y 1000 -type random\n./gen -m 2 -total_students 200 -x 100 -y 100 -type impossible\n./gen -m 3 -total_students 300 -x 150 -y 151 -type random\n./gen -m 3 -total_students 75 -x 25 -y 25 -type random\n./gen -m 3 -total_students 100 -x 50 -y 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:32.955464",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "357/B",
      "title": "B. День Флага",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел заданы два целых числа n (3 ≤ n ≤ 105) и m (1 ≤ m ≤ 105) — количество танцоров и количество танцев соответственно. Далее идёт m строк, описывающих танцы в порядке их исполнения. В i-ой строке находятся три различных целых числа — номера танцоров, участвующих в i-ом танце. Танцоры пронумерованы от 1 до n. Каждый танцор принимает участие хотя бы в одном танце.",
      "output_spec": "Выходные данныеВыведите через пробел n чисел: i-ое из этих чисел должно обозначать цвет формы i-го танцора (1 — белый, 2 — красный, 3 — синий). Если подходящих решений несколько, выведите любое из них. Гарантируется, что хотя бы одно решение существует.",
      "sample_tests": "ПримерыВходные данныеСкопировать7 31 2 31 4 54 6 7Выходные данныеСкопировать1 2 3 3 2 2 1 Входные данныеСкопировать9 33 6 92 5 81 4 7Выходные данныеСкопировать1 1 1 2 2 2 3 3 3 Входные данныеСкопировать5 24 1 53 1 2Выходные данныеСкопировать2 3 1 1 3",
      "description": "B. День Флага\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел заданы два целых числа n (3 ≤ n ≤ 105) и m (1 ≤ m ≤ 105) — количество танцоров и количество танцев соответственно. Далее идёт m строк, описывающих танцы в порядке их исполнения. В i-ой строке находятся три различных целых числа — номера танцоров, участвующих в i-ом танце. Танцоры пронумерованы от 1 до n. Каждый танцор принимает участие хотя бы в одном танце.\n\nВходные данные\n\nВыходные данныеВыведите через пробел n чисел: i-ое из этих чисел должно обозначать цвет формы i-го танцора (1 — белый, 2 — красный, 3 — синий). Если подходящих решений несколько, выведите любое из них. Гарантируется, что хотя бы одно решение существует.\n\nВыходные данные\n\nВходные данныеСкопировать7 31 2 31 4 54 6 7Выходные данныеСкопировать1 2 3 3 2 2 1 Входные данныеСкопировать9 33 6 92 5 81 4 7Выходные данныеСкопировать1 1 1 2 2 2 3 3 3 Входные данныеСкопировать5 24 1 53 1 2Выходные данныеСкопировать2 3 1 1 3\n\nВходные данныеСкопировать7 31 2 31 4 54 6 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 3 3 2 2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9 33 6 92 5 81 4 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1 1 2 2 2 3 3 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 24 1 53 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 3 1 1 3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Привет всем.Сегодня в Саратове проходит региональная командная олимпиада школьников по программированию. Мы решили сделать раунд с использованием задач этого соревнования. Задачи к раунду готовили: Gerald (Геральд Агапов), Fefer_Ivan (Иван Фефер), HolkinPV (Павел Холкин), Igor_Kudryashov (Игорь Кудряшов), IlyaLos (Илья Лось) и Nerevar (Дмитрий Матов). Условия на английский переводила Мария Белова (Delinur).Раунд начнется сегодня, 15 октября, в 16:00 MSK. К участию приглашаются участники обоих дивизионов.Разбалловка стандартная: 500-1000-1500-2000-2500.Поздравляем победителей!Первый дивизион: tourist mmaxio Dmitry_Egorov iwiwi bmerry Второй дивизион: Apsara ZJUDBLab noxe intsashka Kanari UPD: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 726
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces",
          "content": "357A - Кружок школьниковВ задаче нужно было перебрать все варианты проходного балла от 1 до 100 и для каждого варианта посчитать, какие получаются размеры групп. Если нашли подходящие разбиения, выводим соответствующий одном из них проходной балл, иначе выводим 0.357B - День ФлагаБудем обрабатывать танцы в порядке их исполнения, и определять цвета формы участвующим в них танцорам. Если в текущем танце нет ни одного ранее танцевавшего участника, то назначим всем троим танцорам различные цвета формы произвольным образом. В случае же, если есть один такой танцор, тогда для него цвет формы уже известен. Два других цвета формы произвольным образом распределим между остальными двумя танцорами.356A - Рыцарский турнирПусть в очередной битве (l, r, x) сражается K рыцарей. Тогда в этой задаче было достаточно научиться находить всех этих рыцарей за время O(K) или O(KlogN). Рассмотрим несколько способов сделать это.Способ первый: хранить множество рыцарей в std::set (C++) или в TreeSet(Java). Тогда в C++ мы можем использовать метод lower_bound для нахождения самого первого живого рыцаря в отрезке, а потом итерироваться по множеству, переходя каждый раз к следующему по номеру живому рыцарю. В Java мы бы для этих целей использовали метод subSet. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }Способ второй: определим массив next, значения в котором будут иметь следующий смысл: если рыцарь v живой, то next[v] = v; если рыцарь v выбыл, то next[v] указывает на некоторого рыцаря u > v (next[v] = u), такого, что между v и u нет живых рыцарей. Тогда для того, чтобы для рыцаря v найти следующего по номеру живого рыцаря, нужно пройти по ссылкам next до первого живого рыцаря. Чтобы не ходить многократно по одним и тем же ссылкам, применяем эвристику сжатия путей из DSU. Надо учитывать случай, когда текущий рыцарь последний и уже выбыл из турнира. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Ксюша и ХеммингОбозначим первую строку за x, |x| = lenX, вторую строку за y, |y| = lenY. Пусть L=НОК(lenX, lenY). Очевидно, что для тех больших строк a и b, которые описаны в условии, L является периодом, поэтому достаточно решить задачу для длины L, а затем умножить ответ на . Зафиксируем позицию i в строке x и посмотрим, с символами в каких позициях в строке y будет сравниваться символ xi. Из несложных соображений теории чисел это будут такие позиции 0 ≤ j < lenY, что i ≡ j (mod g), где g=НОД(lenX, lenY). Для каждого возможного остатка r от деления на g и каждого символа c можно посчитать count(r, c) — количество символов c, которые встречаются в y на позициях j таких, что j mod g = r. Тогда при вычислении расстояния Хэмминга напротив символа xi будет ровно count(i mod g, xi) таких же символов, а все остальные сравнения прибавят единицу к расстоянию Хэмминга. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - КупеВ данной задаче требовалось придумать какой-нибудь правильный жадный алгоритм. Один из правильных подходов делает следующее: Сначала соединяет все <<двойки>> с <<единичками>> (образуются <<тройки>>), путем пересаживания <<единичек>>. Рассматривает два случая в зависимости от того, <<единичек>> больше изначально или <<двоек>>. Если больше единичек, то пробует соединять оставшиеся после первого пункта одинокие <<единички>> в тройки, если <<двоек>>, то пробует из каждых трех <<двоек>> образовать две <<тройки>>. После применения пункта два, могут остаться еще какие-то <<единички>> или <<двойки>>. Нужно разобрать случаи того, что осталось, руками (случаев будет мало). В задаче нужно руководствоваться скорее здравым смыслом, нежели какими-то известными жадными соображениями. Неплохо помогает написать стресс-тестирование с наивным решением (обходом в ширину), чтобы убедиться в корректности вашей жадности.356D - Монеты и мешочкиОчевидно, что мешки и отношения \"лежит непосредственно в\" образуют лес. К каждой вершиной должно быть связано некоторое число ci — количество монет в соответствующем мешке. Тогда, если мы для каждой вершины посчитаем величину fi — сумма значений cj в поддереве этой вершины, то должны выполняться следующие условия: fi = ai сумма fi по вершинам, которые являются корнями деревьев, равна s. Очевидно, что мешок с наибольшим ai будет корнем какого-то из деревьев. Также достаточно легко понять, что решение задачи существует тогда и только тогда, когда можно выбрать такой набор ai1, ai2, ..., aik, что сумма ai1 + ai2 + ... + aik равна s, причем один из мешков с наибольшим ai входит в такой набор. В одну сторону это очевидно, в другую покажем конструктивно: пусть у нас есть такой набор. Тогда все мешки, вошедшие в набор, кроме самого большого, будут \"отдельными\", то для них ci = ai, а все не вошедшие мешки мы последовательно положим друг в друга и в первый, получив матрешку (т.е. дерево с корнем в самом большом мешке будет ориентированной цепью).Задача свелась к задаче о наборе суммы s из предметов a1, ... an. Это задача является NP-полной, и обычно в подобных ограничениях решается так: пусть T(i, j) = 1, если можно набрать сумму j, используя какие-то из первых i предметов, и T(i, j) = 0 в противном случае. Тогда . Заметим, что i-ая строка этой таблицы зависит только от (i - 1)-ой, поэтому можно хранить в памяти не всю таблицу, а только две строки. Дальше мы будем использовать то, что значения в таблицы — это нули и единицы, поэтому мы можем хранить строчки таблицы побитово, в массиве из 4-битных целых чисел. Тогда, чтобы получить очередную строчку, мы должны сделать побитовое ИЛИ предыдущей строки и предыдущей строки, сдвинутой на ai бит. Все это можно сделать за действий, поэтому выяснить, можно ли набрать сумму s, можно примерно за операций. Однако, тут нужно применить один трюк для того, чтобы восстановить, какие именно предметы нужно взять. Давайте для каждого значения суммы j будем запоминать величину first(j) — номер такого предмета, после рассмотрения которого стало возможно набрать сумму j. Это позволит нам восстановить ответ.356E - Ксюша и строковая задачаВо время контеста большинство участников писали решение задачи очень похожее на авторское. Одно из авторских решений (более простое) использует полиномиальные хеши (хотя есть решения и без них). Кратко опишем решение. Для каждой позиции i посчитаем с помощью хешей максимальное такое Li, что подстрока s[(i - Li + 1)..(i + Li - 1)] является строкой Грея. Так же посчитаем максимальное такое Pi, что подстрока s[(i - Pi + 1)..(i + Pi - 1)] отличается от строки грея не более чем на один символ. Очевидно, что Pi ≥ Li. Причем если Pi > Li, то также сохраним позицию символа и символ, который различает подстроку и некоторую строку Грея. Понятно, что если бы не нужно было менять символы, тогда ответ был бы равен , где f(L) = 12 + 32 + 72 + ... + L2. Посчитаем ответ, без замены символов. Теперь переберем позицию и новый символ, на который будем менять символ в данной позиции. Как понять, на сколько поменяется ответ на задачу? Посмотрим на все строки грея, вхождения которых перекрывают зафиксированную позицию. После изменения символа на другой, они все перестанут быть строками грея (вычтем их длину в квадрате из ответа). Посмотрим на все строки Грея, которые отличаются ровно в одной зафиксированном символе от некоторой подстроки строки. После изменения на этот символ они все добавятся в ответ (их длину в квадрате нужно добавить в ответ). Суммируя вышесказанное, с помощью Pi Li нужно, используя update на отрезке в offline, посчитать для каждой позиции и символа, на сколько поменяется ответ на задачу, если в данной позиции поставить этот символ. Далее нужно обновит ответ всеми возможными значениями.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 357\\s*B"
          },
          "content_length": 8610
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "70000 70000\n1 1 2 2 ... 35000 35000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "70000 70000\n1 1 2 2 ... 35000 35000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 4",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 5",
          "code": "012345678012345678\n012345012345012345",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 6",
          "code": "012345678012345678\n012345012345012345",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 7",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> dancerParticipation(n + 1, 0);\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c_i\");\n        inf.readEoln();\n\n        ensuref(a != b && a != c && b != c, \"In dance %d, dancers are not distinct: %d, %d, %d\", i + 1, a, b, c);\n\n        dancerParticipation[a] += 1;\n        dancerParticipation[b] += 1;\n        dancerParticipation[c] += 1;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(dancerParticipation[i] >= 1, \"Dancer %d does not participate in any dance\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> dancerParticipation(n + 1, 0);\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c_i\");\n        inf.readEoln();\n\n        ensuref(a != b && a != c && b != c, \"In dance %d, dancers are not distinct: %d, %d, %d\", i + 1, a, b, c);\n\n        dancerParticipation[a] += 1;\n        dancerParticipation[b] += 1;\n        dancerParticipation[c] += 1;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(dancerParticipation[i] >= 1, \"Dancer %d does not participate in any dance\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> dancerParticipation(n + 1, 0);\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c_i\");\n        inf.readEoln();\n\n        ensuref(a != b && a != c && b != c, \"In dance %d, dancers are not distinct: %d, %d, %d\", i + 1, a, b, c);\n\n        dancerParticipation[a] += 1;\n        dancerParticipation[b] += 1;\n        dancerParticipation[c] += 1;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(dancerParticipation[i] >= 1, \"Dancer %d does not participate in any dance\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    int m = inf.readInt(1, 100000, \"m\");\n\n    vector<array<int, 3>> dances(m);\n    for (int i = 0; i < m; ++i) {\n        set<int> dance_dancers;\n        for (int j = 0; j < 3; ++j) {\n            int dancer = inf.readInt(1, n, \"dancer\");\n            dances[i][j] = dancer;\n            dance_dancers.insert(dancer);\n        }\n        if (dance_dancers.size() != 3)\n            quitf(_fail, \"Dancer repeated in dance %d.\", i + 1);\n    }\n\n    vector<int> colors(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i) {\n        colors[i] = ouf.readInt(1, 3, format(\"color[%d]\", i).c_str());\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int c1 = colors[dances[i][0]];\n        int c2 = colors[dances[i][1]];\n        int c3 = colors[dances[i][2]];\n        set<int> dance_colors = {c1, c2, c3};\n        if (dance_colors != set<int>({1, 2, 3})) {\n            quitf(_wa, \"In dance %d, colors are not 1, 2, 3.\", i + 1);\n        }\n    }\n\n    quitf(_ok, \"Correct solution.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"chain\");\n\n    // Calculate the maximum number of dances m given n\n    int max_m = (n - 1) / 2;\n    int m = max_m;\n\n    printf(\"%d %d\\n\", n, m);\n\n    vector<int> dancers(n);\n    for (int i = 0; i < n; ++i) dancers[i] = i + 1;\n\n    vector<int> danced(n + 1, 0); // Keep track of dancers who have danced\n\n    if (type == \"chain\") {\n        int next_new_dancer = 0;\n        // First dance\n        int d1 = dancers[next_new_dancer++];\n        int d2 = dancers[next_new_dancer++];\n        int d3 = dancers[next_new_dancer++];\n        printf(\"%d %d %d\\n\", d1, d2, d3);\n        danced[d1] = danced[d2] = danced[d3] = 1;\n\n        int prev_dancer = d1;\n\n        while (next_new_dancer + 1 < n) {\n            // Next dance\n            int d4 = dancers[next_new_dancer++];\n            int d5 = dancers[next_new_dancer++];\n            printf(\"%d %d %d\\n\", prev_dancer, d4, d5);\n            danced[d4] = danced[d5] = 1;\n            prev_dancer = d4;\n        }\n    } else if (type == \"random\") {\n        // Randomly generate dances\n        vector<int> undanced;\n        for (int i = 1; i <= n; ++i) {\n            undanced.push_back(i);\n        }\n\n        shuffle(undanced.begin(), undanced.end());\n\n        int next_new_dancer = 0;\n        int dance_count = 0;\n\n        // First dance\n        if (undanced.size() >= 3) {\n            int d1 = undanced[next_new_dancer++];\n            int d2 = undanced[next_new_dancer++];\n            int d3 = undanced[next_new_dancer++];\n            printf(\"%d %d %d\\n\", d1, d2, d3);\n            danced[d1] = danced[d2] = danced[d3] = 1;\n            dance_count++;\n        }\n\n        while (dance_count < m) {\n            if (next_new_dancer + 1 >= undanced.size()) {\n                // No more new dancers available\n                break;\n            }\n            // Choose a previously danced dancer\n            int pre_dancer = rnd.next(1, n);\n            while (!danced[pre_dancer]) {\n                pre_dancer = rnd.next(1, n);\n            }\n            // Choose two new dancers\n            int d1 = undanced[next_new_dancer++];\n            int d2 = undanced[next_new_dancer++];\n            printf(\"%d %d %d\\n\", pre_dancer, d1, d2);\n            danced[d1] = danced[d2] = 1;\n            dance_count++;\n        }\n    } else if (type == \"maxreuse\") {\n        // Reuse the same dancer in every dance\n        int pre_dancer = 1;\n        danced[pre_dancer] = 1;\n        int next_new_dancer = 0;\n        // First dance\n        int d1 = pre_dancer;\n        int d2 = dancers[++next_new_dancer];\n        int d3 = dancers[++next_new_dancer];\n        printf(\"%d %d %d\\n\", d1, d2, d3);\n        danced[d2] = danced[d3] = 1;\n\n        int dance_count = 1;\n\n        while (dance_count < m && next_new_dancer + 1 < n) {\n            d2 = dancers[++next_new_dancer];\n            d3 = dancers[++next_new_dancer];\n            printf(\"%d %d %d\\n\", pre_dancer, d2, d3);\n            danced[d2] = danced[d3] = 1;\n            dance_count++;\n        }\n    } else {\n        // Default, similar to random\n        // You can add more types as needed\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"chain\");\n\n    // Calculate the maximum number of dances m given n\n    int max_m = (n - 1) / 2;\n    int m = max_m;\n\n    printf(\"%d %d\\n\", n, m);\n\n    vector<int> dancers(n);\n    for (int i = 0; i < n; ++i) dancers[i] = i + 1;\n\n    vector<int> danced(n + 1, 0); // Keep track of dancers who have danced\n\n    if (type == \"chain\") {\n        int next_new_dancer = 0;\n        // First dance\n        int d1 = dancers[next_new_dancer++];\n        int d2 = dancers[next_new_dancer++];\n        int d3 = dancers[next_new_dancer++];\n        printf(\"%d %d %d\\n\", d1, d2, d3);\n        danced[d1] = danced[d2] = danced[d3] = 1;\n\n        int prev_dancer = d1;\n\n        while (next_new_dancer + 1 < n) {\n            // Next dance\n            int d4 = dancers[next_new_dancer++];\n            int d5 = dancers[next_new_dancer++];\n            printf(\"%d %d %d\\n\", prev_dancer, d4, d5);\n            danced[d4] = danced[d5] = 1;\n            prev_dancer = d4;\n        }\n    } else if (type == \"random\") {\n        // Randomly generate dances\n        vector<int> undanced;\n        for (int i = 1; i <= n; ++i) {\n            undanced.push_back(i);\n        }\n\n        shuffle(undanced.begin(), undanced.end());\n\n        int next_new_dancer = 0;\n        int dance_count = 0;\n\n        // First dance\n        if (undanced.size() >= 3) {\n            int d1 = undanced[next_new_dancer++];\n            int d2 = undanced[next_new_dancer++];\n            int d3 = undanced[next_new_dancer++];\n            printf(\"%d %d %d\\n\", d1, d2, d3);\n            danced[d1] = danced[d2] = danced[d3] = 1;\n            dance_count++;\n        }\n\n        while (dance_count < m) {\n            if (next_new_dancer + 1 >= undanced.size()) {\n                // No more new dancers available\n                break;\n            }\n            // Choose a previously danced dancer\n            int pre_dancer = rnd.next(1, n);\n            while (!danced[pre_dancer]) {\n                pre_dancer = rnd.next(1, n);\n            }\n            // Choose two new dancers\n            int d1 = undanced[next_new_dancer++];\n            int d2 = undanced[next_new_dancer++];\n            printf(\"%d %d %d\\n\", pre_dancer, d1, d2);\n            danced[d1] = danced[d2] = 1;\n            dance_count++;\n        }\n    } else if (type == \"maxreuse\") {\n        // Reuse the same dancer in every dance\n        int pre_dancer = 1;\n        danced[pre_dancer] = 1;\n        int next_new_dancer = 0;\n        // First dance\n        int d1 = pre_dancer;\n        int d2 = dancers[++next_new_dancer];\n        int d3 = dancers[++next_new_dancer];\n        printf(\"%d %d %d\\n\", d1, d2, d3);\n        danced[d2] = danced[d3] = 1;\n\n        int dance_count = 1;\n\n        while (dance_count < m && next_new_dancer + 1 < n) {\n            d2 = dancers[++next_new_dancer];\n            d3 = dancers[++next_new_dancer];\n            printf(\"%d %d %d\\n\", pre_dancer, d2, d3);\n            danced[d2] = danced[d3] = 1;\n            dance_count++;\n        }\n    } else {\n        // Default, similar to random\n        // You can add more types as needed\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 7 -type chain\n./gen -n 7 -type random\n./gen -n 7 -type maxreuse\n\n./gen -n 10 -type chain\n./gen -n 10 -type random\n./gen -n 10 -type maxreuse\n\n./gen -n 15 -type chain\n./gen -n 15 -type random\n./gen -n 15 -type maxreuse\n\n./gen -n 100 -type chain\n./gen -n 100 -type random\n./gen -n 100 -type maxreuse\n\n./gen -n 99999 -type chain\n./gen -n 99999 -type random\n./gen -n 99999 -type maxreuse\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type random\n./gen -n 100000 -type maxreuse\n\n# Edge cases\n./gen -n 3 -type chain\n./gen -n 3 -type random\n./gen -n 3 -type maxreuse\n\n# Test with minimal dancers and maximal dances\n./gen -n 5 -type chain\n./gen -n 5 -type random\n./gen -n 5 -type maxreuse\n\n# Test with varying sizes\n./gen -n 5000 -type chain\n./gen -n 5000 -type random\n./gen -n 5000 -type maxreuse\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type random\n./gen -n 10000 -type maxreuse\n\n# Test with the maximum possible m for given n\n./gen -n 99999 -type chain\n./gen -n 99999 -type random\n./gen -n 99999 -type maxreuse\n\n# Additional types can be added as needed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:35.156620",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "357/C",
      "title": "C. Knight Tournament",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (2 ≤ n ≤ 3·105; 1 ≤ m ≤ 3·105) — the number of knights and the number of fights. Each of the following m lines contains three integers li, ri, xi (1 ≤ li < ri ≤ n; li ≤ xi ≤ ri) — the description of the i-th fight.It is guaranteed that the input is correct and matches the problem statement. It is guaranteed that at least two knights took part in each battle.",
      "output_spec": "OutputPrint n integers. If the i-th knight lost, then the i-th number should equal the number of the knight that beat the knight number i. If the i-th knight is the winner, then the i-th number must equal 0.",
      "sample_tests": "ExamplesInputCopy4 31 2 11 3 31 4 4OutputCopy3 1 4 0 InputCopy8 43 5 43 7 62 8 81 8 1OutputCopy0 8 4 6 4 8 6 1",
      "description": "C. Knight Tournament\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, m (2 ≤ n ≤ 3·105; 1 ≤ m ≤ 3·105) — the number of knights and the number of fights. Each of the following m lines contains three integers li, ri, xi (1 ≤ li < ri ≤ n; li ≤ xi ≤ ri) — the description of the i-th fight.It is guaranteed that the input is correct and matches the problem statement. It is guaranteed that at least two knights took part in each battle.\n\nOutputPrint n integers. If the i-th knight lost, then the i-th number should equal the number of the knight that beat the knight number i. If the i-th knight is the winner, then the i-th number must equal 0.\n\nInputCopy4 31 2 11 3 31 4 4OutputCopy3 1 4 0 InputCopy8 43 5 43 7 62 8 81 8 1OutputCopy0 8 4 6 4 8 6 1\n\nInputCopy4 31 2 11 3 31 4 4\n\nOutputCopy3 1 4 0\n\nInputCopy8 43 5 43 7 62 8 81 8 1\n\nOutputCopy0 8 4 6 4 8 6 1\n\nNoteConsider the first test case. Knights 1 and 2 fought the first fight and knight 1 won. Knights 1 and 3 fought the second fight and knight 3 won. The last fight was between knights 3 and 4, knight 4 won.",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Hi all.Today there is a school regional team competition in programming in Saratov. We've decided to make a round using tasks from this competition. The problems were prepared by Gerald (Gerald Agapov), Fefer_Ivan (Ivan Fefer), HolkinPV (Pavel Kholkin), Igor_Kudryashov (Igor Kudryashov), IlyaLos (Ilya Los) and Nerevar (Dmitry Matov). The problems' statements were translated into english by Mary Belova (Delinur).The round starts today, on 15th of October, at 16:00 MSK. Parcipants from both divisions are welcome to take part in it.The scoring is standard: 500-1000-1500-2000-2500.Congratulations to the winners!Division I: tourist mmaxio Dmitry_Egorov iwiwi bmerry Division II: Apsara ZJUDBLab noxe intsashka Kanari UPD: The tutorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 751
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 357 和字母"
          },
          "content_length": 8532
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SegmentTree {\n    int start, end;\n    int sum;\n    int assign;\n    SegmentTree *left, *right;\n    SegmentTree(int s, int e): start(s), end(e), sum(e - s + 1), assign(-1), left(NULL), right(NULL) {\n        if (s != e) {\n            int m = (s + e) / 2;\n            left = new SegmentTree(s, m);\n            right = new SegmentTree(m+1, e);\n        }\n    }\n    void pushDown() {\n        if (assign != -1 && start != end) {\n            left->assign = assign;\n            left->sum = (left->end - left->start + 1) * assign;\n            right->assign = assign;\n            right->sum = (right->end - right->start + 1) * assign;\n            assign = -1;\n        }\n    }\n    int query(int l, int r) {\n        if (r < start || end < l) return 0;\n        if (l <= start && end <= r) return sum;\n        pushDown();\n        return left->query(l, r) + right->query(l, r);\n    }\n    void rangeAssign(int l, int r, int val) {\n        if (r < start || end < l) return;\n        if (l <= start && end <= r) {\n            assign = val;\n            sum = (end - start + 1) * val;\n        } else {\n            pushDown();\n            left->rangeAssign(l, r, val);\n            right->rangeAssign(l, r, val);\n            sum = left->sum + right->sum;\n        }\n    }\n    void pointAssign(int pos, int val) {\n        if (start == end) {\n            sum = val;\n            assign = -1;\n        } else {\n            pushDown();\n            if (pos <= left->end) {\n                left->pointAssign(pos, val);\n            } else {\n                right->pointAssign(pos, val);\n            }\n            sum = left->sum + right->sum;\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    SegmentTree* root = new SegmentTree(1, n);\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n - 1, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, n, \"ri\"); // li < ri ≤ n\n        inf.readSpace();\n        int xi = inf.readInt(li, ri, \"xi\");\n        inf.readEoln();\n        int aliveCount = root->query(li, ri);\n        ensuref(aliveCount >= 2, \"At least two knights must participate in each fight at fight %d\", i + 1);\n        root->rangeAssign(li, ri, 0);\n        root->pointAssign(xi, 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SegmentTree {\n    int start, end;\n    int sum;\n    int assign;\n    SegmentTree *left, *right;\n    SegmentTree(int s, int e): start(s), end(e), sum(e - s + 1), assign(-1), left(NULL), right(NULL) {\n        if (s != e) {\n            int m = (s + e) / 2;\n            left = new SegmentTree(s, m);\n            right = new SegmentTree(m+1, e);\n        }\n    }\n    void pushDown() {\n        if (assign != -1 && start != end) {\n            left->assign = assign;\n            left->sum = (left->end - left->start + 1) * assign;\n            right->assign = assign;\n            right->sum = (right->end - right->start + 1) * assign;\n            assign = -1;\n        }\n    }\n    int query(int l, int r) {\n        if (r < start || end < l) return 0;\n        if (l <= start && end <= r) return sum;\n        pushDown();\n        return left->query(l, r) + right->query(l, r);\n    }\n    void rangeAssign(int l, int r, int val) {\n        if (r < start || end < l) return;\n        if (l <= start && end <= r) {\n            assign = val;\n            sum = (end - start + 1) * val;\n        } else {\n            pushDown();\n            left->rangeAssign(l, r, val);\n            right->rangeAssign(l, r, val);\n            sum = left->sum + right->sum;\n        }\n    }\n    void pointAssign(int pos, int val) {\n        if (start == end) {\n            sum = val;\n            assign = -1;\n        } else {\n            pushDown();\n            if (pos <= left->end) {\n                left->pointAssign(pos, val);\n            } else {\n                right->pointAssign(pos, val);\n            }\n            sum = left->sum + right->sum;\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    SegmentTree* root = new SegmentTree(1, n);\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n - 1, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, n, \"ri\"); // li < ri ≤ n\n        inf.readSpace();\n        int xi = inf.readInt(li, ri, \"xi\");\n        inf.readEoln();\n        int aliveCount = root->query(li, ri);\n        ensuref(aliveCount >= 2, \"At least two knights must participate in each fight at fight %d\", i + 1);\n        root->rangeAssign(li, ri, 0);\n        root->pointAssign(xi, 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SegmentTree {\n    int start, end;\n    int sum;\n    int assign;\n    SegmentTree *left, *right;\n    SegmentTree(int s, int e): start(s), end(e), sum(e - s + 1), assign(-1), left(NULL), right(NULL) {\n        if (s != e) {\n            int m = (s + e) / 2;\n            left = new SegmentTree(s, m);\n            right = new SegmentTree(m+1, e);\n        }\n    }\n    void pushDown() {\n        if (assign != -1 && start != end) {\n            left->assign = assign;\n            left->sum = (left->end - left->start + 1) * assign;\n            right->assign = assign;\n            right->sum = (right->end - right->start + 1) * assign;\n            assign = -1;\n        }\n    }\n    int query(int l, int r) {\n        if (r < start || end < l) return 0;\n        if (l <= start && end <= r) return sum;\n        pushDown();\n        return left->query(l, r) + right->query(l, r);\n    }\n    void rangeAssign(int l, int r, int val) {\n        if (r < start || end < l) return;\n        if (l <= start && end <= r) {\n            assign = val;\n            sum = (end - start + 1) * val;\n        } else {\n            pushDown();\n            left->rangeAssign(l, r, val);\n            right->rangeAssign(l, r, val);\n            sum = left->sum + right->sum;\n        }\n    }\n    void pointAssign(int pos, int val) {\n        if (start == end) {\n            sum = val;\n            assign = -1;\n        } else {\n            pushDown();\n            if (pos <= left->end) {\n                left->pointAssign(pos, val);\n            } else {\n                right->pointAssign(pos, val);\n            }\n            sum = left->sum + right->sum;\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    SegmentTree* root = new SegmentTree(1, n);\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n - 1, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, n, \"ri\"); // li < ri ≤ n\n        inf.readSpace();\n        int xi = inf.readInt(li, ri, \"xi\");\n        inf.readEoln();\n        int aliveCount = root->query(li, ri);\n        ensuref(aliveCount >= 2, \"At least two knights must participate in each fight at fight %d\", i + 1);\n        root->rangeAssign(li, ri, 0);\n        root->pointAssign(xi, 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    m = min(m, n - 1); // Ensure m ≤ n - 1\n\n    set<int> alive_knights;\n    for (int i = 1; i <= n; ++i) {\n        alive_knights.insert(i);\n    }\n\n    vector<tuple<int, int, int>> fights; // Stores the fights as (li, ri, xi)\n\n    for (int i = 0; i < m; ++i) {\n        if (alive_knights.size() < 2) {\n            break;\n        }\n        int li = 1;\n        int ri = n;\n        if (type == \"full\") {\n            li = 1;\n            ri = n;\n        } else if (type == \"small\") {\n            int attempts = 0;\n            while (attempts < 10) {\n                int li_candidate = rnd.next(1, n - 1);\n                int ri_candidate = rnd.next(li_candidate + 1, min(li_candidate + 10, n));\n                auto it_start = alive_knights.lower_bound(li_candidate);\n                auto it_end = alive_knights.upper_bound(ri_candidate);\n                vector<int> participants(it_start, it_end);\n                if (participants.size() >= 2) {\n                    li = li_candidate;\n                    ri = ri_candidate;\n                    break;\n                }\n                attempts++;\n            }\n        } else if (type == \"random\") {\n            int attempts = 0;\n            while (attempts < 10) {\n                int li_candidate = rnd.next(1, n - 1);\n                int ri_candidate = rnd.next(li_candidate + 1, n);\n                auto it_start = alive_knights.lower_bound(li_candidate);\n                auto it_end = alive_knights.upper_bound(ri_candidate);\n                vector<int> participants(it_start, it_end);\n                if (participants.size() >= 2) {\n                    li = li_candidate;\n                    ri = ri_candidate;\n                    break;\n                }\n                attempts++;\n            }\n        }\n        // Get participants in the fight\n        auto it_start = alive_knights.lower_bound(li);\n        auto it_end = alive_knights.upper_bound(ri);\n        vector<int> participants(it_start, it_end);\n        if (participants.size() < 2) {\n            // If less than two participants, expand the range to all alive knights\n            li = *alive_knights.begin();\n            ri = *prev(alive_knights.end());\n            participants.assign(alive_knights.begin(), alive_knights.end());\n        }\n        if (participants.size() < 2) {\n            break;\n        }\n        // Select the winner xi\n        int xi = participants[rnd.next(0, (int)participants.size() - 1)];\n        fights.push_back(make_tuple(li, ri, xi));\n        // Remove other participants from alive_knights\n        for (int knight : participants) {\n            if (knight != xi) {\n                alive_knights.erase(knight);\n            }\n        }\n    }\n\n    // Output n and the number of fights\n    printf(\"%d %d\\n\", n, (int)fights.size());\n    for (auto fight : fights) {\n        int li, ri, xi;\n        tie(li, ri, xi) = fight;\n        printf(\"%d %d %d\\n\", li, ri, xi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    m = min(m, n - 1); // Ensure m ≤ n - 1\n\n    set<int> alive_knights;\n    for (int i = 1; i <= n; ++i) {\n        alive_knights.insert(i);\n    }\n\n    vector<tuple<int, int, int>> fights; // Stores the fights as (li, ri, xi)\n\n    for (int i = 0; i < m; ++i) {\n        if (alive_knights.size() < 2) {\n            break;\n        }\n        int li = 1;\n        int ri = n;\n        if (type == \"full\") {\n            li = 1;\n            ri = n;\n        } else if (type == \"small\") {\n            int attempts = 0;\n            while (attempts < 10) {\n                int li_candidate = rnd.next(1, n - 1);\n                int ri_candidate = rnd.next(li_candidate + 1, min(li_candidate + 10, n));\n                auto it_start = alive_knights.lower_bound(li_candidate);\n                auto it_end = alive_knights.upper_bound(ri_candidate);\n                vector<int> participants(it_start, it_end);\n                if (participants.size() >= 2) {\n                    li = li_candidate;\n                    ri = ri_candidate;\n                    break;\n                }\n                attempts++;\n            }\n        } else if (type == \"random\") {\n            int attempts = 0;\n            while (attempts < 10) {\n                int li_candidate = rnd.next(1, n - 1);\n                int ri_candidate = rnd.next(li_candidate + 1, n);\n                auto it_start = alive_knights.lower_bound(li_candidate);\n                auto it_end = alive_knights.upper_bound(ri_candidate);\n                vector<int> participants(it_start, it_end);\n                if (participants.size() >= 2) {\n                    li = li_candidate;\n                    ri = ri_candidate;\n                    break;\n                }\n                attempts++;\n            }\n        }\n        // Get participants in the fight\n        auto it_start = alive_knights.lower_bound(li);\n        auto it_end = alive_knights.upper_bound(ri);\n        vector<int> participants(it_start, it_end);\n        if (participants.size() < 2) {\n            // If less than two participants, expand the range to all alive knights\n            li = *alive_knights.begin();\n            ri = *prev(alive_knights.end());\n            participants.assign(alive_knights.begin(), alive_knights.end());\n        }\n        if (participants.size() < 2) {\n            break;\n        }\n        // Select the winner xi\n        int xi = participants[rnd.next(0, (int)participants.size() - 1)];\n        fights.push_back(make_tuple(li, ri, xi));\n        // Remove other participants from alive_knights\n        for (int knight : participants) {\n            if (knight != xi) {\n                alive_knights.erase(knight);\n            }\n        }\n    }\n\n    // Output n and the number of fights\n    printf(\"%d %d\\n\", n, (int)fights.size());\n    for (auto fight : fights) {\n        int li, ri, xi;\n        tie(li, ri, xi) = fight;\n        printf(\"%d %d %d\\n\", li, ri, xi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -type full\n\n./gen -n 5 -m 4 -type full\n./gen -n 5 -m 4 -type small\n./gen -n 5 -m 4 -type random\n\n./gen -n 10 -m 9 -type full\n./gen -n 10 -m 9 -type small\n./gen -n 10 -m 9 -type random\n\n./gen -n 100 -m 99 -type full\n./gen -n 100 -m 99 -type small\n./gen -n 100 -m 99 -type random\n\n./gen -n 1000 -m 999 -type full\n./gen -n 1000 -m 999 -type small\n./gen -n 1000 -m 999 -type random\n\n./gen -n 10000 -m 9999 -type full\n./gen -n 10000 -m 9999 -type small\n./gen -n 10000 -m 9999 -type random\n\n./gen -n 50000 -m 49999 -type full\n./gen -n 50000 -m 49999 -type small\n./gen -n 50000 -m 49999 -type random\n\n./gen -n 100000 -m 99999 -type full\n./gen -n 100000 -m 99999 -type small\n./gen -n 100000 -m 99999 -type random\n\n./gen -n 200000 -m 199999 -type full\n./gen -n 200000 -m 199999 -type small\n./gen -n 200000 -m 199999 -type random\n\n./gen -n 300000 -m 299999 -type full\n./gen -n 300000 -m 299999 -type small\n./gen -n 300000 -m 299999 -type random\n\n# Edge cases with minimum n and m\n./gen -n 2 -m 1 -type small\n./gen -n 2 -m 1 -type random\n\n# Edge cases with maximum n and m\n./gen -n 300000 -m 299999 -type full\n\n# Test cases with m less than n - 1\n./gen -n 1000 -m 500 -type random\n./gen -n 1000 -m 100 -type small\n./gen -n 1000 -m 1 -type full\n\n# Test cases with n small, m small\n./gen -n 10 -m 5 -type small\n./gen -n 10 -m 5 -type random\n\n# Test cases with n large, m small\n./gen -n 300000 -m 10 -type random\n./gen -n 300000 -m 1 -type small\n\n# Test cases with varied types\n./gen -n 10000 -m 9999 -type small\n./gen -n 10000 -m 9999 -type random\n./gen -n 10000 -m 9999 -type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:37.473550",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "357/D",
      "title": "D. Ксюша и Хемминг",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 1012). Во второй строке записана непустая строка x. В третьей строке записана непустая строка y. Обе строки состоят из не более чем 106 строчных букв латинского алфавита.Гарантируется, что строки a и b, полученные по входным данным, имеют одинаковую длину.",
      "output_spec": "Выходные данныеВыведите единственное целое число — искомое расстояние Хемминга.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать100 10aaaaaaaaaaaВыходные данныеСкопировать0Входные данныеСкопировать1 1abacabaabzczzzВыходные данныеСкопировать4Входные данныеСкопировать2 3rzrazВыходные данныеСкопировать5",
      "description": "D. Ксюша и Хемминг\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 1012). Во второй строке записана непустая строка x. В третьей строке записана непустая строка y. Обе строки состоят из не более чем 106 строчных букв латинского алфавита.Гарантируется, что строки a и b, полученные по входным данным, имеют одинаковую длину.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — искомое расстояние Хемминга.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать100 10aaaaaaaaaaaВыходные данныеСкопировать0Входные данныеСкопировать1 1abacabaabzczzzВыходные данныеСкопировать4Входные данныеСкопировать2 3rzrazВыходные данныеСкопировать5\n\nВходные данныеСкопировать100 10aaaaaaaaaaa\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1abacabaabzczzz\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3rzraz\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере строка a равна строке b и равна 100 буквам a. Так как строки равны, расстояние Хемминга между ними равно нулю.Во втором тестовом примере у строк a и b различаются 3-ый, 5-ый, 6-ой, и 7-ой символы. Таким образом расстояние Хемминга равно 4.В третьем тестовом примере строка a равна rzrrzr, а строка b — azazaz. Строки отличаются во всех символах кроме 2-го, расстояние Хемминга между ними равно 5.",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Привет всем.Сегодня в Саратове проходит региональная командная олимпиада школьников по программированию. Мы решили сделать раунд с использованием задач этого соревнования. Задачи к раунду готовили: Gerald (Геральд Агапов), Fefer_Ivan (Иван Фефер), HolkinPV (Павел Холкин), Igor_Kudryashov (Игорь Кудряшов), IlyaLos (Илья Лось) и Nerevar (Дмитрий Матов). Условия на английский переводила Мария Белова (Delinur).Раунд начнется сегодня, 15 октября, в 16:00 MSK. К участию приглашаются участники обоих дивизионов.Разбалловка стандартная: 500-1000-1500-2000-2500.Поздравляем победителей!Первый дивизион: tourist mmaxio Dmitry_Egorov iwiwi bmerry Второй дивизион: Apsara ZJUDBLab noxe intsashka Kanari UPD: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 726
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces",
          "content": "357A - Кружок школьниковВ задаче нужно было перебрать все варианты проходного балла от 1 до 100 и для каждого варианта посчитать, какие получаются размеры групп. Если нашли подходящие разбиения, выводим соответствующий одном из них проходной балл, иначе выводим 0.357B - День ФлагаБудем обрабатывать танцы в порядке их исполнения, и определять цвета формы участвующим в них танцорам. Если в текущем танце нет ни одного ранее танцевавшего участника, то назначим всем троим танцорам различные цвета формы произвольным образом. В случае же, если есть один такой танцор, тогда для него цвет формы уже известен. Два других цвета формы произвольным образом распределим между остальными двумя танцорами.356A - Рыцарский турнирПусть в очередной битве (l, r, x) сражается K рыцарей. Тогда в этой задаче было достаточно научиться находить всех этих рыцарей за время O(K) или O(KlogN). Рассмотрим несколько способов сделать это.Способ первый: хранить множество рыцарей в std::set (C++) или в TreeSet(Java). Тогда в C++ мы можем использовать метод lower_bound для нахождения самого первого живого рыцаря в отрезке, а потом итерироваться по множеству, переходя каждый раз к следующему по номеру живому рыцарю. В Java мы бы для этих целей использовали метод subSet. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }Способ второй: определим массив next, значения в котором будут иметь следующий смысл: если рыцарь v живой, то next[v] = v; если рыцарь v выбыл, то next[v] указывает на некоторого рыцаря u > v (next[v] = u), такого, что между v и u нет живых рыцарей. Тогда для того, чтобы для рыцаря v найти следующего по номеру живого рыцаря, нужно пройти по ссылкам next до первого живого рыцаря. Чтобы не ходить многократно по одним и тем же ссылкам, применяем эвристику сжатия путей из DSU. Надо учитывать случай, когда текущий рыцарь последний и уже выбыл из турнира. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Ксюша и ХеммингОбозначим первую строку за x, |x| = lenX, вторую строку за y, |y| = lenY. Пусть L=НОК(lenX, lenY). Очевидно, что для тех больших строк a и b, которые описаны в условии, L является периодом, поэтому достаточно решить задачу для длины L, а затем умножить ответ на . Зафиксируем позицию i в строке x и посмотрим, с символами в каких позициях в строке y будет сравниваться символ xi. Из несложных соображений теории чисел это будут такие позиции 0 ≤ j < lenY, что i ≡ j (mod g), где g=НОД(lenX, lenY). Для каждого возможного остатка r от деления на g и каждого символа c можно посчитать count(r, c) — количество символов c, которые встречаются в y на позициях j таких, что j mod g = r. Тогда при вычислении расстояния Хэмминга напротив символа xi будет ровно count(i mod g, xi) таких же символов, а все остальные сравнения прибавят единицу к расстоянию Хэмминга. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - КупеВ данной задаче требовалось придумать какой-нибудь правильный жадный алгоритм. Один из правильных подходов делает следующее: Сначала соединяет все <<двойки>> с <<единичками>> (образуются <<тройки>>), путем пересаживания <<единичек>>. Рассматривает два случая в зависимости от того, <<единичек>> больше изначально или <<двоек>>. Если больше единичек, то пробует соединять оставшиеся после первого пункта одинокие <<единички>> в тройки, если <<двоек>>, то пробует из каждых трех <<двоек>> образовать две <<тройки>>. После применения пункта два, могут остаться еще какие-то <<единички>> или <<двойки>>. Нужно разобрать случаи того, что осталось, руками (случаев будет мало). В задаче нужно руководствоваться скорее здравым смыслом, нежели какими-то известными жадными соображениями. Неплохо помогает написать стресс-тестирование с наивным решением (обходом в ширину), чтобы убедиться в корректности вашей жадности.356D - Монеты и мешочкиОчевидно, что мешки и отношения \"лежит непосредственно в\" образуют лес. К каждой вершиной должно быть связано некоторое число ci — количество монет в соответствующем мешке. Тогда, если мы для каждой вершины посчитаем величину fi — сумма значений cj в поддереве этой вершины, то должны выполняться следующие условия: fi = ai сумма fi по вершинам, которые являются корнями деревьев, равна s. Очевидно, что мешок с наибольшим ai будет корнем какого-то из деревьев. Также достаточно легко понять, что решение задачи существует тогда и только тогда, когда можно выбрать такой набор ai1, ai2, ..., aik, что сумма ai1 + ai2 + ... + aik равна s, причем один из мешков с наибольшим ai входит в такой набор. В одну сторону это очевидно, в другую покажем конструктивно: пусть у нас есть такой набор. Тогда все мешки, вошедшие в набор, кроме самого большого, будут \"отдельными\", то для них ci = ai, а все не вошедшие мешки мы последовательно положим друг в друга и в первый, получив матрешку (т.е. дерево с корнем в самом большом мешке будет ориентированной цепью).Задача свелась к задаче о наборе суммы s из предметов a1, ... an. Это задача является NP-полной, и обычно в подобных ограничениях решается так: пусть T(i, j) = 1, если можно набрать сумму j, используя какие-то из первых i предметов, и T(i, j) = 0 в противном случае. Тогда . Заметим, что i-ая строка этой таблицы зависит только от (i - 1)-ой, поэтому можно хранить в памяти не всю таблицу, а только две строки. Дальше мы будем использовать то, что значения в таблицы — это нули и единицы, поэтому мы можем хранить строчки таблицы побитово, в массиве из 4-битных целых чисел. Тогда, чтобы получить очередную строчку, мы должны сделать побитовое ИЛИ предыдущей строки и предыдущей строки, сдвинутой на ai бит. Все это можно сделать за действий, поэтому выяснить, можно ли набрать сумму s, можно примерно за операций. Однако, тут нужно применить один трюк для того, чтобы восстановить, какие именно предметы нужно взять. Давайте для каждого значения суммы j будем запоминать величину first(j) — номер такого предмета, после рассмотрения которого стало возможно набрать сумму j. Это позволит нам восстановить ответ.356E - Ксюша и строковая задачаВо время контеста большинство участников писали решение задачи очень похожее на авторское. Одно из авторских решений (более простое) использует полиномиальные хеши (хотя есть решения и без них). Кратко опишем решение. Для каждой позиции i посчитаем с помощью хешей максимальное такое Li, что подстрока s[(i - Li + 1)..(i + Li - 1)] является строкой Грея. Так же посчитаем максимальное такое Pi, что подстрока s[(i - Pi + 1)..(i + Pi - 1)] отличается от строки грея не более чем на один символ. Очевидно, что Pi ≥ Li. Причем если Pi > Li, то также сохраним позицию символа и символ, который различает подстроку и некоторую строку Грея. Понятно, что если бы не нужно было менять символы, тогда ответ был бы равен , где f(L) = 12 + 32 + 72 + ... + L2. Посчитаем ответ, без замены символов. Теперь переберем позицию и новый символ, на который будем менять символ в данной позиции. Как понять, на сколько поменяется ответ на задачу? Посмотрим на все строки грея, вхождения которых перекрывают зафиксированную позицию. После изменения символа на другой, они все перестанут быть строками грея (вычтем их длину в квадрате из ответа). Посмотрим на все строки Грея, которые отличаются ровно в одной зафиксированном символе от некоторой подстроки строки. После изменения на этот символ они все добавятся в ответ (их длину в квадрате нужно добавить в ответ). Суммируя вышесказанное, с помощью Pi Li нужно, используя update на отрезке в offline, посчитать для каждой позиции и символа, на сколько поменяется ответ на задачу, если в данной позиции поставить этот символ. Далее нужно обновит ответ всеми возможными значениями.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 357 和字母"
          },
          "content_length": 8610
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "70000 70000\n1 1 2 2 ... 35000 35000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "70000 70000\n1 1 2 2 ... 35000 35000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 4",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 5",
          "code": "012345678012345678\n012345012345012345",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 6",
          "code": "012345678012345678\n012345012345012345",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 7",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: разбор задач - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\");\n    inf.readEoln();\n\n    string x = inf.readToken(\"[a-z]+\", \"x\");\n    inf.readEoln();\n\n    string y = inf.readToken(\"[a-z]+\", \"y\");\n    inf.readEoln();\n\n    ensuref(1 <= x.size() && x.size() <= 1000000, \"Length of x must be between 1 and 1e6, but is %zu\", x.size());\n    ensuref(1 <= y.size() && y.size() <= 1000000, \"Length of y must be between 1 and 1e6, but is %zu\", y.size());\n\n    long long lenA = n * (long long)x.size();\n    long long lenB = m * (long long)y.size();\n\n    ensuref(lenA == lenB, \"Lengths of strings a and b must be equal: len(a)=%lld, len(b)=%lld\", lenA, lenB);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\");\n    inf.readEoln();\n\n    string x = inf.readToken(\"[a-z]+\", \"x\");\n    inf.readEoln();\n\n    string y = inf.readToken(\"[a-z]+\", \"y\");\n    inf.readEoln();\n\n    ensuref(1 <= x.size() && x.size() <= 1000000, \"Length of x must be between 1 and 1e6, but is %zu\", x.size());\n    ensuref(1 <= y.size() && y.size() <= 1000000, \"Length of y must be between 1 and 1e6, but is %zu\", y.size());\n\n    long long lenA = n * (long long)x.size();\n    long long lenB = m * (long long)y.size();\n\n    ensuref(lenA == lenB, \"Lengths of strings a and b must be equal: len(a)=%lld, len(b)=%lld\", lenA, lenB);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\");\n    inf.readEoln();\n\n    string x = inf.readToken(\"[a-z]+\", \"x\");\n    inf.readEoln();\n\n    string y = inf.readToken(\"[a-z]+\", \"y\");\n    inf.readEoln();\n\n    ensuref(1 <= x.size() && x.size() <= 1000000, \"Length of x must be between 1 and 1e6, but is %zu\", x.size());\n    ensuref(1 <= y.size() && y.size() <= 1000000, \"Length of y must be between 1 and 1e6, but is %zu\", y.size());\n\n    long long lenA = n * (long long)x.size();\n    long long lenB = m * (long long)y.size();\n\n    ensuref(lenA == lenB, \"Lengths of strings a and b must be equal: len(a)=%lld, len(b)=%lld\", lenA, lenB);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test for the problem:\n    n, m (1 <= n, m <= 1e12)\n    x (non-empty, length at most 1e6)\n    y (non-empty, length at most 1e6)\n  such that length(x)*n = length(y)*m.\n\n  Usage (examples):\n    ./gen -n 5 -m 3 -xLen 6 -yLen 10 -xType random -yType random\n    ./gen -n 1 -m 1 -xLen 7 -yLen 7 -xType all_a -yType random\n\n  The generator will:\n    1) Parse n, m, xLen, yLen, xType, yType.\n    2) Possibly fix xLen or yLen if xLen*n != yLen*m, whenever possible.\n    3) Generate strings x, y of lengths xLen, yLen in [1..1e6], with the \n       characters in [a..z].\n    4) Print:\n         n m\n         x\n         y\n*/\n\nstatic const int ALPH_SZ = 26; // 'a'..'z'\n\nstring genString(int len, const string &type) {\n    // Generate a string of length 'len' using only [a..z].\n    // 'type' can be \"all_a\", \"all_b\", or \"random\".\n    // Feel free to add more patterns if needed.\n    string s(len, 'a');\n\n    if (type == \"all_a\") {\n        // already filled with 'a'\n    }\n    else if (type == \"all_b\") {\n        for (int i = 0; i < len; i++) {\n            s[i] = 'b';\n        }\n    }\n    else {\n        // random\n        for (int i = 0; i < len; i++) {\n            s[i] = char('a' + rnd.next(ALPH_SZ));\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    long long n = opt<long long>(\"n\");\n    long long m = opt<long long>(\"m\");\n    long long xLen = opt<long long>(\"xLen\", 1LL);\n    long long yLen = opt<long long>(\"yLen\", 1LL);\n    string xType = opt<string>(\"xType\", \"random\");\n    string yType = opt<string>(\"yType\", \"random\");\n\n    // Basic checks\n    // We'll attempt to fix xLen or yLen if needed:\n    // condition: xLen*n == yLen*m\n    // if not, try adjusting one of them in an integer way.\n    long long lhs = xLen * n; // length(x)*n\n    long long rhs = yLen * m; // length(y)*m\n\n    if (lhs != rhs) {\n        // try to fix yLen if possible\n        // meaning we want (xLen * n) / m to be an integer\n        // and <= 1e6\n        if ((xLen * n) % m == 0) {\n            long long newYLen = (xLen * n) / m;\n            if (newYLen >= 1 && newYLen <= 1000000) {\n                yLen = newYLen;\n            }\n            else {\n                // If that doesn't work, try to fix xLen\n                if ((yLen * m) % n == 0) {\n                    long long newXLen = (yLen * m) / n;\n                    if (newXLen >= 1 && newXLen <= 1000000) {\n                        xLen = newXLen;\n                    }\n                    else {\n                        // in worst case, fail\n                        cerr << \"Cannot fix xLen or yLen to satisfy constraints\\n\";\n                        return 0;\n                    }\n                }\n                else {\n                    cerr << \"Cannot fix xLen or yLen to satisfy constraints\\n\";\n                    return 0;\n                }\n            }\n        }\n        else if ((yLen * m) % n == 0) {\n            long long newXLen = (yLen * m) / n;\n            if (newXLen >= 1 && newXLen <= 1000000) {\n                xLen = newXLen;\n            }\n            else {\n                cerr << \"Cannot fix xLen or yLen to satisfy constraints\\n\";\n                return 0;\n            }\n        }\n        else {\n            cerr << \"Cannot fix xLen or yLen to satisfy constraints\\n\";\n            return 0;\n        }\n    }\n\n    // final check\n    lhs = xLen * n; \n    rhs = yLen * m;\n    if (lhs != rhs) {\n        // still not matching => cannot produce correct data\n        cerr << \"Still cannot satisfy len(x)*n == len(y)*m.\\n\";\n        return 0;\n    }\n\n    // Also ensure 1 <= xLen,yLen <=1e6\n    if (xLen < 1 || xLen > 1000000 || yLen < 1 || yLen > 1000000) {\n        cerr << \"xLen or yLen out of range.\\n\";\n        return 0;\n    }\n    // n,m are presumably valid up to 1e12 from the problem statement.\n\n    // Generate x, y\n    string x = genString((int)xLen, xType);\n    string y = genString((int)yLen, yType);\n\n    // Output\n    cout << n << \" \" << m << \"\\n\";\n    cout << x << \"\\n\";\n    cout << y << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test for the problem:\n    n, m (1 <= n, m <= 1e12)\n    x (non-empty, length at most 1e6)\n    y (non-empty, length at most 1e6)\n  such that length(x)*n = length(y)*m.\n\n  Usage (examples):\n    ./gen -n 5 -m 3 -xLen 6 -yLen 10 -xType random -yType random\n    ./gen -n 1 -m 1 -xLen 7 -yLen 7 -xType all_a -yType random\n\n  The generator will:\n    1) Parse n, m, xLen, yLen, xType, yType.\n    2) Possibly fix xLen or yLen if xLen*n != yLen*m, whenever possible.\n    3) Generate strings x, y of lengths xLen, yLen in [1..1e6], with the \n       characters in [a..z].\n    4) Print:\n         n m\n         x\n         y\n*/\n\nstatic const int ALPH_SZ = 26; // 'a'..'z'\n\nstring genString(int len, const string &type) {\n    // Generate a string of length 'len' using only [a..z].\n    // 'type' can be \"all_a\", \"all_b\", or \"random\".\n    // Feel free to add more patterns if needed.\n    string s(len, 'a');\n\n    if (type == \"all_a\") {\n        // already filled with 'a'\n    }\n    else if (type == \"all_b\") {\n        for (int i = 0; i < len; i++) {\n            s[i] = 'b';\n        }\n    }\n    else {\n        // random\n        for (int i = 0; i < len; i++) {\n            s[i] = char('a' + rnd.next(ALPH_SZ));\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    long long n = opt<long long>(\"n\");\n    long long m = opt<long long>(\"m\");\n    long long xLen = opt<long long>(\"xLen\", 1LL);\n    long long yLen = opt<long long>(\"yLen\", 1LL);\n    string xType = opt<string>(\"xType\", \"random\");\n    string yType = opt<string>(\"yType\", \"random\");\n\n    // Basic checks\n    // We'll attempt to fix xLen or yLen if needed:\n    // condition: xLen*n == yLen*m\n    // if not, try adjusting one of them in an integer way.\n    long long lhs = xLen * n; // length(x)*n\n    long long rhs = yLen * m; // length(y)*m\n\n    if (lhs != rhs) {\n        // try to fix yLen if possible\n        // meaning we want (xLen * n) / m to be an integer\n        // and <= 1e6\n        if ((xLen * n) % m == 0) {\n            long long newYLen = (xLen * n) / m;\n            if (newYLen >= 1 && newYLen <= 1000000) {\n                yLen = newYLen;\n            }\n            else {\n                // If that doesn't work, try to fix xLen\n                if ((yLen * m) % n == 0) {\n                    long long newXLen = (yLen * m) / n;\n                    if (newXLen >= 1 && newXLen <= 1000000) {\n                        xLen = newXLen;\n                    }\n                    else {\n                        // in worst case, fail\n                        cerr << \"Cannot fix xLen or yLen to satisfy constraints\\n\";\n                        return 0;\n                    }\n                }\n                else {\n                    cerr << \"Cannot fix xLen or yLen to satisfy constraints\\n\";\n                    return 0;\n                }\n            }\n        }\n        else if ((yLen * m) % n == 0) {\n            long long newXLen = (yLen * m) / n;\n            if (newXLen >= 1 && newXLen <= 1000000) {\n                xLen = newXLen;\n            }\n            else {\n                cerr << \"Cannot fix xLen or yLen to satisfy constraints\\n\";\n                return 0;\n            }\n        }\n        else {\n            cerr << \"Cannot fix xLen or yLen to satisfy constraints\\n\";\n            return 0;\n        }\n    }\n\n    // final check\n    lhs = xLen * n; \n    rhs = yLen * m;\n    if (lhs != rhs) {\n        // still not matching => cannot produce correct data\n        cerr << \"Still cannot satisfy len(x)*n == len(y)*m.\\n\";\n        return 0;\n    }\n\n    // Also ensure 1 <= xLen,yLen <=1e6\n    if (xLen < 1 || xLen > 1000000 || yLen < 1 || yLen > 1000000) {\n        cerr << \"xLen or yLen out of range.\\n\";\n        return 0;\n    }\n    // n,m are presumably valid up to 1e12 from the problem statement.\n\n    // Generate x, y\n    string x = genString((int)xLen, xType);\n    string y = genString((int)yLen, yType);\n\n    // Output\n    cout << n << \" \" << m << \"\\n\";\n    cout << x << \"\\n\";\n    cout << y << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are sample commands for generating 20+ different tests.\n# Each command prints ONE test to stdout. Use them all to create a diverse set of tests.\n\n./gen -n 1 -m 1 -xLen 1 -yLen 1 -xType all_a -yType all_a\n./gen -n 1 -m 1 -xLen 7 -yLen 7 -xType random -yType random\n./gen -n 1 -m 1 -xLen 7 -yLen 7 -xType all_a -yType random\n./gen -n 2 -m 2 -xLen 2 -yLen 2 -xType random -yType random\n./gen -n 5 -m 3 -xLen 6 -yLen 10 -xType random -yType random\n./gen -n 2 -m 1 -xLen 2 -yLen 4 -xType random -yType random\n./gen -n 10 -m 10 -xLen 5 -yLen 5 -xType all_b -yType all_a\n./gen -n 10 -m 2 -xLen 3 -yLen 15 -xType random -yType random\n./gen -n 100 -m 1 -xLen 5 -yLen 500 -xType random -yType random\n./gen -n 1 -m 100 -xLen 500 -yLen 5 -xType random -yType random\n./gen -n 10 -m 1 -xLen 10 -yLen 100 -xType all_a -yType all_b\n./gen -n 1 -m 10 -xLen 100 -yLen 10 -xType random -yType all_a\n./gen -n 999999 -m 1 -xLen 1 -yLen 999999 -xType random -yType all_a\n./gen -n 1 -m 999999 -xLen 999999 -yLen 1 -xType all_b -yType random\n./gen -n 999999 -m 999999 -xLen 1 -yLen 1 -xType random -yType random\n./gen -n 100000 -m 1 -xLen 1000 -yLen 100000000 -xType random -yType random\n# The above might fix to a correct ratio if possible, else might fail if it can't fix yLen. \n# (The generator tries to adjust xLen/yLen if they don't match up.)\n# Some more big ratio tests:\n./gen -n 1000000 -m 1 -xLen 1 -yLen 1000000 -xType random -yType random\n./gen -n 1 -m 1000000 -xLen 1000000 -yLen 1 -xType random -yType random\n./gen -n 1000000000000 -m 1000000000000 -xLen 1 -yLen 1 -xType random -yType random\n./gen -n 1000000000000 -m 500000000000 -xLen 2 -yLen 4 -xType all_a -yType all_b\n./gen -n 6 -m 4 -xLen 2 -yLen 3 -xType random -yType random\n./gen -n 10 -m 1 -xLen 9 -yLen 90 -xType random -yType all_b\n./gen -n 3 -m 3 -xLen 10 -yLen 10 -xType random -yType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:39.132836",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "357/E",
      "title": "E. Compartments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106) — the number of compartments in the carriage. The second line contains n integers a1, a2, ..., an showing how many students ride in each compartment (0 ≤ ai ≤ 4). It is guaranteed that at least one student is riding in the train.",
      "output_spec": "OutputIf no sequence of swapping seats with other people leads to the desired result, print number \"-1\" (without the quotes). In another case, print the smallest number of people you need to persuade to swap places.",
      "sample_tests": "ExamplesInputCopy51 2 2 4 3OutputCopy2InputCopy34 1 1OutputCopy2InputCopy40 3 0 4OutputCopy0",
      "description": "E. Compartments\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 106) — the number of compartments in the carriage. The second line contains n integers a1, a2, ..., an showing how many students ride in each compartment (0 ≤ ai ≤ 4). It is guaranteed that at least one student is riding in the train.\n\nOutputIf no sequence of swapping seats with other people leads to the desired result, print number \"-1\" (without the quotes). In another case, print the smallest number of people you need to persuade to swap places.\n\nInputCopy51 2 2 4 3OutputCopy2InputCopy34 1 1OutputCopy2InputCopy40 3 0 4OutputCopy0\n\nInputCopy51 2 2 4 3\n\nOutputCopy2\n\nInputCopy34 1 1\n\nOutputCopy2\n\nInputCopy40 3 0 4\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #207 - Codeforces",
          "content": "Hi all.Today there is a school regional team competition in programming in Saratov. We've decided to make a round using tasks from this competition. The problems were prepared by Gerald (Gerald Agapov), Fefer_Ivan (Ivan Fefer), HolkinPV (Pavel Kholkin), Igor_Kudryashov (Igor Kudryashov), IlyaLos (Ilya Los) and Nerevar (Dmitry Matov). The problems' statements were translated into english by Mary Belova (Delinur).The round starts today, on 15th of October, at 16:00 MSK. Parcipants from both divisions are welcome to take part in it.The scoring is standard: 500-1000-1500-2000-2500.Congratulations to the winners!Division I: tourist mmaxio Dmitry_Egorov iwiwi bmerry Division II: Apsara ZJUDBLab noxe intsashka Kanari UPD: The tutorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 751
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces",
          "content": "357A - Group of StudentsIn this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups. 357B - Flag DayLet's process the dances in the given order and determine the colors of dancers' clothes. If there are no dancer from some previous dance, we can give the dances different colors arbitrarily. And if there is such dancer, we already know the color of his clothes. So, we arbitrarily distribute the other two colors between the remaning two dancers.356A - Knight TournamentLet's the current fight (l, r, x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.The first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method. set<int> alive;\n for (int i = 0; i < n; i++)\n alive.insert(i);\n\n for (int i = 0; i < m; i++) {\n int l, r, x;\n scanf(\"%d%d%d\", &l, &r, &x);\n l--, r--, x--; \n set<int>::iterator it = alive.lower_bound(l);\n vector<int> toErase; \n while(it != alive.end()){\n int cur = *it; \n if(cur > r)\n break; \n if(cur != x){ \n toErase.pb(cur); answer[cur] = x;\n }\n it++;\n }\n\n for (size_t j = 0; j < toErase.size(); j++)\n alive.erase(toErase[j]);\n }The second way is to define array next with the following meaning: if knight v is alive, then next[v] = v; if knight v is out of tournament, next[v] points to some knight u (next[v] = u), such that there are no alive knights between v and u; To find the first alive knight starting from the knight v we need to follow this links until we find the first knight w with next[w] = w. In order not to pass the same links too many times, we will use the trick known as path compression (it is used in Disjoint Set Union). Note that you should handle the case when the current knight is the last knight and is out of tournament. int getNext(int v){\n if(next[v] == v)\n return v;\n return next[v] = getNext(next[v]);\n }\n\n ...\n\n int cur = getNext(l);\n while(cur <= r){\n if(cur == x){\n cur = cur + 1;\n }else{\n answer[cur] = x;\n next[cur] = cur + 1;\n }\n\n cur = getNext(cur);\n }356B - Xenia and HammingLet's denote the length of the first string as lenX, the length of the second string as lenY. Let L = LCM(lenX, lenY). It's obvious that L is a period of the long strings a and b, so we can find the distance of its' prefixes of length L and multiply the answer by . Let's fix the position i in the string x and think about all characters from the second string it will be compared with. It it easy to conclude that it will be compared with such yj that i ≡ j (mod g), where g = GCD(lenX, lenY). For each possible remainder of division by g and for each character c we can calculate count(r, c) — the number of characters c that appear in y in such positions j that j mod g = r. When calculating the Hamming distance, the character xi will be compared with exactly count(i mod g, xi) characters from y that are equal to it, all other comparisons will add one to the distance. private void solve() {\n Scanner in = new Scanner(System.in);\n long n = in.nextLong(), m = in.nextLong();\n String x = in.next(), y = in.next();\n int lenX = x.length(), lenY = y.length();\n int g = gcd(lenX, lenY);\n long L = lenX * (long)lenY / g;\n long answer = L;\n int[][] count = new int[g][26];\n for (int j = 0; j < lenY; j++) {\n count[j % g][y.charAt(j) - 'a']++;\n }\n for (int i = 0; i < lenX; i++) {\n answer -= count[i % g][x.charAt(i) - 'a'];\n }\n System.out.println(answer * (n * lenX / L));\n }356C - CompartmentsIn the problem you should come up with some right greedy algorithm. One of correct approaches acts as follows: Firstly, it joins all \"twos\" and \"ones\" (to get \"threes\"). Several \"ones\" should be moved. Then you should consider two cases depend on amounts of \"ones\" and \"twos\". If initially you have more \"ones\", you should try to join remaining after the first point \"ones\" into groups of three. If initially you have more \"twos\", you should try to join remaining after the first point \"twos\" into groups of three. You can get two \"threes\" from three \"twos\". After the first point and the second point some \"ones\" or \"twos\" can remain. You shouldn't come up with common solution. Else you should just to consider all possible cases. To solve the problem you should follow your common sense (is it greedy?). Writing naive solution (bfs search) for stress purposes is not so bad for proving correctness of your solution.356D - Bags and CoinsIt's easy to see that bags and their relations \"lies directly in\" should form directed forest. Each vertex should be given value ci — the number of coins in the corresponding bag. Let's denote the sum of values cj in the subtree of vertex i as fi. The following conditions should be met: fi = ai then sum of fi of roots equals s. It's clear that one of the bags with largest ai must be the root of some tree. It's quite easy to see that the solution exists if and only if there exists a subset ai1, ai2, ..., aik such that ai1 + ai2 + ... + aik = s and this subset contains at least one bag with the largest ai. It's obvious that it is necessary condition, the sufficiency is also easy to see: let's suppose we have such subset. Then all bags from the subset, except one of the largest, will be roots of the signle-vertex trees (i.e. ci = ai for them). All bags that are not in the subset we will consequentially put into the largest bag, forming the \"russian doll\" (this tree will be directed chain).So, we reduced the task to the well-known subset-sum problem: from the items a1, a2, ... an find the subset with the given sum s. This problem is NP-Complete, and with these constraints is solved in a following way: let T(i, j) = 1 if it is possible to obtain sum j using some of the first i items, and T(i, j) = 0 otherwise. Then . The i-th row of this table depends only on the previous row, so we don't have to store the whole table in memory. Also we should use the fact that the values of the table are zeroes and ones, and we can use bit compression and store each row in an array of int's of size . To get the i-th row, we should calculate the bitwise OR of the previous row and the previous row shifted to the left by ai positions. That is, we can find out whether it possible to obtain the sum s in approximately operations. To find the actual way to obtain s, we need to use the following trick: for every possible sum j we will remember the value first(j) — the number of such item that after considering this item it became possible to obtain j. This allows us to restore the solution.356E - Xenia and String ProblemDuring the contest most of participants write the solutions that are very similar to the author's one. One of the author's solution uses hashes (but there exist solution without it), you can see short description of the solution below: For each position i calculate with hashes the maximal value of Li, such that substring s[(i - Li + 1)..(i + Li - 1)] is Gray string. Also, calculate the maximal value Pi, that substring s[(i - Pi + 1)..(i + Pi - 1)] differs from some Gray string in at most one position. You can see that Pi ≥ Li. If Pi > Li, also remember position and letter in the position, that differs Gray string and the substring. You can see, that if we don't need to change letters, then the answer for the problem is , where f(L) = 12 + 32 + 72 + ... + L2. So, calculate an answer without changes. Next, iterate through all positions and letters in it. What is the new answer for the problem? Look at all Gray strings that occurs in our string and touches our fixed position. After we change this position the string will not be Gray string anymore (so we should subtract the squired length of the string from our answer). Look at all Gray strings that differs in exactly fixed position from some substring of the string. If we change the letter in the position to the fixed letter, all such strings will be added to the answer (and we should add their squired lengths). Summary, with Pi and Li we need to calculate for each position and letter, how the answer differs if we change the letter in the position to the fixed one. For that reason we should use offline update (+=) on the segment. After the values will be calculated we can update our answer with all possible values.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9210",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 357 和字母"
          },
          "content_length": 8532
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #207 - Codeforces - Code 1",
          "code": "lower_bound(s.begin(), s.end(), l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 2",
          "code": "s.lower_bound(l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207 - Codeforces - Code 3",
          "code": "MlogN + M + N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 1",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 2",
          "code": "set<int> alive;\n    for (int i = 0; i < n; i++)\n        alive.insert(i);\n        \n    for (int i = 0; i < m; i++) {\n        int l, r, x;\n        scanf(\"%d%d%d\", &l, &r, &x);\n        l--, r--, x--;        \n        set<int>::iterator it = alive.lower_bound(l);\n        vector<int> toErase;        \n        while(it != alive.end()){\n            int cur = *it;            \n            if(cur > r)\n                break;                \n            if(cur != x){    \n                toErase.pb(cur); answer[cur] = x;\n            }\n            it++;\n        }\n\n        for (size_t j = 0; j < toErase.size(); j++)\n            alive.erase(toErase[j]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 3",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 4",
          "code": "int getNext(int v){\n        if(next[v] == v)\n            return v;\n        return next[v] = getNext(next[v]);\n    }\n\n    ...\n\n     int cur = getNext(l);\n     while(cur <= r){\n        if(cur == x){\n            cur = cur + 1;\n        }else{\n            answer[cur] = x;\n            next[cur] = cur + 1;\n        }\n\n        cur = getNext(cur);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 5",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 6",
          "code": "private void solve() {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong(), m = in.nextLong();\n        String x = in.next(), y = in.next();\n        int lenX = x.length(), lenY = y.length();\n        int g = gcd(lenX, lenY);\n        long L = lenX * (long)lenY / g;\n        long answer = L;\n        int[][] count = new int[g][26];\n        for (int j = 0; j < lenY; j++) {\n            count[j % g][y.charAt(j) - 'a']++;\n        }\n        for (int i = 0; i < lenX; i++) {\n            answer -= count[i % g][x.charAt(i) - 'a'];\n        }\n        System.out.println(answer * (n * lenX / L));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 7",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 8",
          "code": "set<int>::iterator lt = S.lower_bound(l[i]);\nset<int>::iterator rt = S.upper_bound(r[i]);\nfor(set<int>::iterator it = lt; it != rt; it++) {\n    int val = *it;\n    if(val != x[i]) {\n        ans[val] = x[i];\n    }\n}\nS.erase(lt, rt);\nS.insert(x[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #207: tutorial - Codeforces - Code 9",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9210",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4);\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    for (int ai : a) {\n        sum_ai += ai;\n    }\n    ensuref(sum_ai >= 1, \"At least one student must be riding in the train, but sum of ai is %lld\", sum_ai);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4);\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    for (int ai : a) {\n        sum_ai += ai;\n    }\n    ensuref(sum_ai >= 1, \"At least one student must be riding in the train, but sum of ai is %lld\", sum_ai);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4);\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    for (int ai : a) {\n        sum_ai += ai;\n    }\n    ensuref(sum_ai >= 1, \"At least one student must be riding in the train, but sum of ai is %lld\", sum_ai);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random values between 0 and 4\n        int total_students = 0;\n        for(int i=0;i<n;i++) {\n            a[i] = rnd.next(0,4);\n            total_students += a[i];\n        }\n        // Ensure at least one student\n        if(total_students == 0) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, 4);\n            total_students += a[idx];\n        }\n    } else if (type == \"all1\") {\n        // All compartments have 1 student\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"all2\") {\n        // All compartments have 2 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 2;\n    } else if (type == \"all3\") {\n        // All compartments have 3 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 3;\n    } else if (type == \"all4\") {\n        // All compartments have 4 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 4;\n    } else if (type == \"alternating12\") {\n        // Compartments alternate between 1 and 2 students\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1;\n    } else if (type == \"maxstudents\") {\n        // Maximum number of students in compartments with 3 or 4 students\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(3, 4);\n    } else if (type == \"minstudents\") {\n        // Only one student in a random compartment\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        int idx = rnd.next(0, n - 1);\n        a[idx] = 1;\n    } else if (type == \"edge_s5\") {\n        // Total number of students is 5, which cannot be partitioned into 3s and 4s\n        if (n < 3) {\n            fprintf(stderr, \"n must be at least 3 for edge_s5 type\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[0] = 2;\n        a[1] = 2;\n        a[2] = 1;\n    } else if (type == \"unrepresentable\") {\n        // Total students cannot be partitioned into groups of 3 or 4\n        int s_unrep_values[] = {1, 2, 5};\n        int s_unrep = s_unrep_values[rnd.next(3)];\n\n        // Make sure sum of students does not exceed 4*n\n        while (s_unrep <= n * 4) {\n            int total_students = s_unrep;\n            int remaining_students = total_students;\n            for(int i = 0; i < n && remaining_students > 0; ++i) {\n                int max_ai = min(4, remaining_students);\n                a[i] = rnd.next(1, max_ai);\n                remaining_students -= a[i];\n            }\n            if (remaining_students == 0)\n                break;\n            s_unrep += 7;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random values between 0 and 4\n        int total_students = 0;\n        for(int i=0;i<n;i++) {\n            a[i] = rnd.next(0,4);\n            total_students += a[i];\n        }\n        // Ensure at least one student\n        if(total_students == 0) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, 4);\n            total_students += a[idx];\n        }\n    } else if (type == \"all1\") {\n        // All compartments have 1 student\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"all2\") {\n        // All compartments have 2 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 2;\n    } else if (type == \"all3\") {\n        // All compartments have 3 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 3;\n    } else if (type == \"all4\") {\n        // All compartments have 4 students\n        for(int i = 0; i < n; ++i)\n            a[i] = 4;\n    } else if (type == \"alternating12\") {\n        // Compartments alternate between 1 and 2 students\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1;\n    } else if (type == \"maxstudents\") {\n        // Maximum number of students in compartments with 3 or 4 students\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(3, 4);\n    } else if (type == \"minstudents\") {\n        // Only one student in a random compartment\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        int idx = rnd.next(0, n - 1);\n        a[idx] = 1;\n    } else if (type == \"edge_s5\") {\n        // Total number of students is 5, which cannot be partitioned into 3s and 4s\n        if (n < 3) {\n            fprintf(stderr, \"n must be at least 3 for edge_s5 type\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[0] = 2;\n        a[1] = 2;\n        a[2] = 1;\n    } else if (type == \"unrepresentable\") {\n        // Total students cannot be partitioned into groups of 3 or 4\n        int s_unrep_values[] = {1, 2, 5};\n        int s_unrep = s_unrep_values[rnd.next(3)];\n\n        // Make sure sum of students does not exceed 4*n\n        while (s_unrep <= n * 4) {\n            int total_students = s_unrep;\n            int remaining_students = total_students;\n            for(int i = 0; i < n && remaining_students > 0; ++i) {\n                int max_ai = min(4, remaining_students);\n                a[i] = rnd.next(1, max_ai);\n                remaining_students -= a[i];\n            }\n            if (remaining_students == 0)\n                break;\n            s_unrep += 7;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random types\n./gen -n 1 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n# All compartments have 1 student\n./gen -n 5 -type all1\n./gen -n 10 -type all1\n\n# All compartments have 2 students\n./gen -n 5 -type all2\n./gen -n 10 -type all2\n\n# All compartments have 3 students\n./gen -n 5 -type all3\n./gen -n 10 -type all3\n\n# All compartments have 4 students\n./gen -n 5 -type all4\n./gen -n 10 -type all4\n\n# Alternating compartments with 1 and 2 students\n./gen -n 6 -type alternating12\n./gen -n 9 -type alternating12\n\n# Edge case with minimal number of students\n./gen -n 1 -type minstudents\n./gen -n 5 -type minstudents\n\n# Edge case where total number of students is 5 (unrepresentable)\n./gen -n 3 -type edge_s5\n\n# Large n, random types\n./gen -n 100000 -type random\n./gen -n 1000000 -type random\n\n# Large n, all compartments have 1 student\n./gen -n 100000 -type all1\n\n# Large n, all compartments have 2 students\n./gen -n 100000 -type all2\n\n# Large n, all compartments have 3 students\n./gen -n 100000 -type all3\n\n# Large n, all compartments have 4 students\n./gen -n 100000 -type all4\n\n# Large n, alternating compartments with 1 and 2 students\n./gen -n 100000 -type alternating12\n\n# Edge case with maximum capacity of students (3 or 4 students in each compartment)\n./gen -n 250000 -type maxstudents\n\n# Edge case with minimal number of students on maximum n\n./gen -n 1000000 -type minstudents\n\n# Edge cases with unrepresentable total numbers of students\n./gen -n 100000 -type unrepresentable\n./gen -n 1000000 -type unrepresentable\n./gen -n 100 -type unrepresentable\n./gen -n 10 -type unrepresentable\n\n# Edge cases with n = 1\n./gen -n 1 -type all1\n./gen -n 1 -type all2\n./gen -n 1 -type all3\n./gen -n 1 -type all4\n./gen -n 1 -type minstudents\n\n# Random test cases with various sizes\n./gen -n 500 -type random\n./gen -n 5000 -type random\n./gen -n 50000 -type random\n\n# Edge case, n = 1000000, all compartments have 1 student\n./gen -n 1000000 -type all1\n\n# Edge case, n = 1000000, alternating compartments\n./gen -n 1000000 -type alternating12\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:40.921563",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "358/A",
      "title": "A. Dima and Continuous Line",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 103). The second line contains n distinct integers x1, x2, ..., xn ( - 106 ≤ xi ≤ 106) — the i-th point has coordinates (xi, 0). The points are not necessarily sorted by their x coordinate.",
      "output_spec": "OutputIn the single line print \"yes\" (without the quotes), if the line has self-intersections. Otherwise, print \"no\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy40 10 5 15OutputCopyyesInputCopy40 15 5 10OutputCopyno",
      "description": "A. Dima and Continuous Line\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 103). The second line contains n distinct integers x1, x2, ..., xn ( - 106 ≤ xi ≤ 106) — the i-th point has coordinates (xi, 0). The points are not necessarily sorted by their x coordinate.\n\nOutputIn the single line print \"yes\" (without the quotes), if the line has self-intersections. Otherwise, print \"no\" (without the quotes).\n\nInputCopy40 10 5 15OutputCopyyesInputCopy40 15 5 10OutputCopyno\n\nInputCopy40 10 5 15\n\nOutputCopyyes\n\nInputCopy40 15 5 10\n\nOutputCopyno\n\nNoteThe first test from the statement is on the picture to the left, the second test is on the picture to the right.",
      "solutions": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces",
          "content": "Hi everybody!When you've seen my nickname you probably thought: \"Finally! At least this round is not made by Sereja! And you are right! I, Dmytro Berezin(Berezin) give this round... and my neighbour Sergii Nagin(Sereja)The action will take place in Friday, 25th october, 19:30.Thanks to Gerald Agapov(Gerald) and Maria Belova(Delinur) for help in preperation and translation of problems respectively.Thanks to Yaroslav Tverdokhlib(KADR) for help in testing.You have to help Dima equip his personal life :)The point values for this cause is 500 1000 1500 2000 3000.Sergii strongly recommends you to read all the tasks.I highly recommend you also to try to solve them.Thank you for your attention, and have a successful round!Tutorial: http://codeforces.com/blog/entry/9334",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9326",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*A"
          },
          "content_length": 3336
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*A"
          },
          "content_length": 3336
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 1",
          "code": "edges.length()%2 == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 2",
          "code": "pos=sts.find_first_of(s[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 3",
          "code": "pos=sts.find_first_of(s[i],pos);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 4",
          "code": "StringBuilder.append()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, -1000000, 1000000, \"xi\");\n    inf.readEoln();\n\n    set<int> xs(x.begin(), x.end());\n    ensuref(xs.size() == n, \"All xi must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, -1000000, 1000000, \"xi\");\n    inf.readEoln();\n\n    set<int> xs(x.begin(), x.end());\n    ensuref(xs.size() == n, \"All xi must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, -1000000, 1000000, \"xi\");\n    inf.readEoln();\n\n    set<int> xs(x.begin(), x.end());\n    ensuref(xs.size() == n, \"All xi must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random integers in [-1e6, 1e6]\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        // Shuffle the coordinates\n        shuffle(x.begin(), x.end());\n    } else if (type == \"sorted_increasing\") {\n        // Generate n distinct integers sorted in increasing order\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        sort(x.begin(), x.end());\n    } else if (type == \"sorted_decreasing\") {\n        // Generate n distinct integers sorted in decreasing order\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        sort(x.rbegin(), x.rend());\n    } else if (type == \"alternating\") {\n        // Generate an alternating sequence of increasing and decreasing x-coordinates\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        sort(x.begin(), x.end());\n        vector<int> x_new;\n        int l = 0, r = n - 1;\n        while (l <= r) {\n            if (l == r)\n                x_new.push_back(x[l]);\n            else {\n                x_new.push_back(x[l]);\n                x_new.push_back(x[r]);\n            }\n            l++;\n            r--;\n        }\n        x = x_new;\n    } else if (type == \"overlapping_intervals\") {\n        // Construct intervals that will cause overlapping arcs\n        // Designed to create self-intersections\n        x.clear();\n        for (int i = 0; i < n; i += 2) {\n            int a = rnd.next(-1000000, 1000000);\n            int b = rnd.next(-1000000, 1000000);\n            while (a == b) b = rnd.next(-1000000, 1000000);\n            x.push_back(a);\n            x.push_back(b);\n        }\n        if (n % 2 != 0) {\n            int c = rnd.next(-1000000, 1000000);\n            x.push_back(c);\n        }\n        // Shuffle to create overlapping when connected consecutively\n        shuffle(x.begin(), x.end());\n    } else if (type == \"nested_intervals\") {\n        // Construct nested intervals without crossings\n        x.clear();\n        int start = -1000000;\n        int step = 2000000 / n;\n        for (int i = 0; i < n; ++i) {\n            x.push_back(start + i * step);\n        }\n        // Points are sorted; intervals are nested\n        // Shuffle to ensure contestants don't assume sorted order\n        shuffle(x.begin(), x.end());\n    } else if (type == \"large_coordinates\") {\n        // Generate points with very large positive and negative coordinates\n        x.clear();\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 1) ? 1000000 - rnd.next(0, 1000) : -1000000 + rnd.next(0, 1000);\n            x.push_back(xi);\n        }\n        // Ensure all x are distinct\n        sort(x.begin(), x.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n        // Adjust size if duplicates were removed\n        while (x.size() < (size_t)n) {\n            int xi = rnd.next(-1000000, 1000000);\n            if (find(x.begin(), x.end(), xi) == x.end())\n                x.push_back(xi);\n        }\n        shuffle(x.begin(), x.end());\n    } else {\n        // Default to random if unknown type\n        // Generate n distinct random integers in [-1e6, 1e6]\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        shuffle(x.begin(), x.end());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", x[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random integers in [-1e6, 1e6]\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        // Shuffle the coordinates\n        shuffle(x.begin(), x.end());\n    } else if (type == \"sorted_increasing\") {\n        // Generate n distinct integers sorted in increasing order\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        sort(x.begin(), x.end());\n    } else if (type == \"sorted_decreasing\") {\n        // Generate n distinct integers sorted in decreasing order\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        sort(x.rbegin(), x.rend());\n    } else if (type == \"alternating\") {\n        // Generate an alternating sequence of increasing and decreasing x-coordinates\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        sort(x.begin(), x.end());\n        vector<int> x_new;\n        int l = 0, r = n - 1;\n        while (l <= r) {\n            if (l == r)\n                x_new.push_back(x[l]);\n            else {\n                x_new.push_back(x[l]);\n                x_new.push_back(x[r]);\n            }\n            l++;\n            r--;\n        }\n        x = x_new;\n    } else if (type == \"overlapping_intervals\") {\n        // Construct intervals that will cause overlapping arcs\n        // Designed to create self-intersections\n        x.clear();\n        for (int i = 0; i < n; i += 2) {\n            int a = rnd.next(-1000000, 1000000);\n            int b = rnd.next(-1000000, 1000000);\n            while (a == b) b = rnd.next(-1000000, 1000000);\n            x.push_back(a);\n            x.push_back(b);\n        }\n        if (n % 2 != 0) {\n            int c = rnd.next(-1000000, 1000000);\n            x.push_back(c);\n        }\n        // Shuffle to create overlapping when connected consecutively\n        shuffle(x.begin(), x.end());\n    } else if (type == \"nested_intervals\") {\n        // Construct nested intervals without crossings\n        x.clear();\n        int start = -1000000;\n        int step = 2000000 / n;\n        for (int i = 0; i < n; ++i) {\n            x.push_back(start + i * step);\n        }\n        // Points are sorted; intervals are nested\n        // Shuffle to ensure contestants don't assume sorted order\n        shuffle(x.begin(), x.end());\n    } else if (type == \"large_coordinates\") {\n        // Generate points with very large positive and negative coordinates\n        x.clear();\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 1) ? 1000000 - rnd.next(0, 1000) : -1000000 + rnd.next(0, 1000);\n            x.push_back(xi);\n        }\n        // Ensure all x are distinct\n        sort(x.begin(), x.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n        // Adjust size if duplicates were removed\n        while (x.size() < (size_t)n) {\n            int xi = rnd.next(-1000000, 1000000);\n            if (find(x.begin(), x.end(), xi) == x.end())\n                x.push_back(xi);\n        }\n        shuffle(x.begin(), x.end());\n    } else {\n        // Default to random if unknown type\n        // Generate n distinct random integers in [-1e6, 1e6]\n        set<int> S;\n        while (S.size() < n) {\n            int xi = rnd.next(-1000000, 1000000);\n            S.insert(xi);\n        }\n        x.assign(S.begin(), S.end());\n        shuffle(x.begin(), x.end());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", x[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n# Medium random test cases\n./gen -n 100 -type random\n./gen -n 500 -type random\n\n# Large random test cases\n./gen -n 1000 -type random\n\n# Test cases with sorted increasing coordinates\n./gen -n 5 -type sorted_increasing\n./gen -n 10 -type sorted_increasing\n./gen -n 500 -type sorted_increasing\n./gen -n 1000 -type sorted_increasing\n\n# Test cases with sorted decreasing coordinates\n./gen -n 5 -type sorted_decreasing\n./gen -n 10 -type sorted_decreasing\n./gen -n 500 -type sorted_decreasing\n./gen -n 1000 -type sorted_decreasing\n\n# Test cases with alternating coordinates\n./gen -n 5 -type alternating\n./gen -n 10 -type alternating\n./gen -n 500 -type alternating\n./gen -n 1000 -type alternating\n\n# Test cases designed to have overlapping intervals (should output \"yes\")\n./gen -n 4 -type overlapping_intervals\n./gen -n 10 -type overlapping_intervals\n./gen -n 100 -type overlapping_intervals\n./gen -n 1000 -type overlapping_intervals\n\n# Test cases with nested intervals without crossings (should output \"no\")\n./gen -n 4 -type nested_intervals\n./gen -n 10 -type nested_intervals\n./gen -n 100 -type nested_intervals\n./gen -n 1000 -type nested_intervals\n\n# Test cases with large coordinates to test potential overflows\n./gen -n 5 -type large_coordinates\n./gen -n 10 -type large_coordinates\n./gen -n 500 -type large_coordinates\n./gen -n 1000 -type large_coordinates\n\n# Edge cases with minimal number of points\n./gen -n 1 -type random\n./gen -n 2 -type random\n\n# Edge cases with maximal number of points\n./gen -n 1000 -type random\n./gen -n 1000 -type overlapping_intervals\n./gen -n 1000 -type nested_intervals\n\n# Additional random test cases for thoroughness\n./gen -n 250 -type random\n./gen -n 750 -type random\n\n# Special case: all points at zero (should be rejected due to distinctness)\n# Since all points must be distinct, adjust to make them distinct\n./gen -n 5 -type zero_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:43.223829",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "358/B",
      "title": "B. Dima and Text Messages",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of words in Dima's message. Next n lines contain non-empty words, one word per line. The words only consist of small English letters. The total length of all words doesn't exceed 105. The last line contains non-empty text message that Inna has got. The number of characters in the text message doesn't exceed 105. A text message can contain only small English letters, digits and signs more and less.",
      "output_spec": "OutputIn a single line, print \"yes\" (without the quotes), if Dima decoded the text message correctly, and \"no\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy3iloveyou<3i<3love<23you<3OutputCopyyesInputCopy7iamnotmaininthefamily<3i<>3am<3the<3<main<3in<3the<3><3family<3OutputCopyno",
      "description": "B. Dima and Text Messages\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of words in Dima's message. Next n lines contain non-empty words, one word per line. The words only consist of small English letters. The total length of all words doesn't exceed 105. The last line contains non-empty text message that Inna has got. The number of characters in the text message doesn't exceed 105. A text message can contain only small English letters, digits and signs more and less.\n\nOutputIn a single line, print \"yes\" (without the quotes), if Dima decoded the text message correctly, and \"no\" (without the quotes) otherwise.\n\nInputCopy3iloveyou<3i<3love<23you<3OutputCopyyesInputCopy7iamnotmaininthefamily<3i<>3am<3the<3<main<3in<3the<3><3family<3OutputCopyno\n\nInputCopy3iloveyou<3i<3love<23you<3\n\nOutputCopyyes\n\nInputCopy7iamnotmaininthefamily<3i<>3am<3the<3<main<3in<3the<3><3family<3\n\nOutputCopyno\n\nNotePlease note that Dima got a good old kick in the pants for the second sample from the statement.",
      "solutions": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces",
          "content": "Hi everybody!When you've seen my nickname you probably thought: \"Finally! At least this round is not made by Sereja! And you are right! I, Dmytro Berezin(Berezin) give this round... and my neighbour Sergii Nagin(Sereja)The action will take place in Friday, 25th october, 19:30.Thanks to Gerald Agapov(Gerald) and Maria Belova(Delinur) for help in preperation and translation of problems respectively.Thanks to Yaroslav Tverdokhlib(KADR) for help in testing.You have to help Dima equip his personal life :)The point values for this cause is 500 1000 1500 2000 3000.Sergii strongly recommends you to read all the tasks.I highly recommend you also to try to solve them.Thank you for your attention, and have a successful round!Tutorial: http://codeforces.com/blog/entry/9334",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9326",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*B"
          },
          "content_length": 3336
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*B"
          },
          "content_length": 3336
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 1",
          "code": "edges.length()%2 == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 2",
          "code": "pos=sts.find_first_of(s[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 3",
          "code": "pos=sts.find_first_of(s[i],pos);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 4",
          "code": "StringBuilder.append()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int totalWordLength = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string word = inf.readToken(\"[a-z]+\", \"word\");\n        totalWordLength += word.length();\n        inf.readEoln();\n    }\n\n    ensuref(totalWordLength <= 100000, \"Total length of all words must be at most 100000, but was %d\", totalWordLength);\n\n    string message = inf.readLine();\n    ensuref(!message.empty(), \"Message must be non-empty\");\n    ensuref(int(message.length()) <= 100000, \"Message length must be at most 100000, but was %d\", int(message.length()));\n\n    for (char c : message) {\n        ensuref(('a' <= c && c <= 'z') || ('0' <= c && c <= '9') || c == '<' || c == '>', \"Invalid character '%c' in message\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int totalWordLength = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string word = inf.readToken(\"[a-z]+\", \"word\");\n        totalWordLength += word.length();\n        inf.readEoln();\n    }\n\n    ensuref(totalWordLength <= 100000, \"Total length of all words must be at most 100000, but was %d\", totalWordLength);\n\n    string message = inf.readLine();\n    ensuref(!message.empty(), \"Message must be non-empty\");\n    ensuref(int(message.length()) <= 100000, \"Message length must be at most 100000, but was %d\", int(message.length()));\n\n    for (char c : message) {\n        ensuref(('a' <= c && c <= 'z') || ('0' <= c && c <= '9') || c == '<' || c == '>', \"Invalid character '%c' in message\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int totalWordLength = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string word = inf.readToken(\"[a-z]+\", \"word\");\n        totalWordLength += word.length();\n        inf.readEoln();\n    }\n\n    ensuref(totalWordLength <= 100000, \"Total length of all words must be at most 100000, but was %d\", totalWordLength);\n\n    string message = inf.readLine();\n    ensuref(!message.empty(), \"Message must be non-empty\");\n    ensuref(int(message.length()) <= 100000, \"Message length must be at most 100000, but was %d\", int(message.length()));\n\n    for (char c : message) {\n        ensuref(('a' <= c && c <= 'z') || ('0' <= c && c <= '9') || c == '<' || c == '>', \"Invalid character '%c' in message\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxlen = opt<int>(\"maxlen\", 10);\n    string type = opt<string>(\"type\", \"correct\");\n\n    int total_word_length = 0;\n\n    vector<string> words;\n    for(int i = 0; i < n; i++)\n    {\n        int len = rnd.next(1, maxlen);\n        if(total_word_length + len > 100000)\n            len = max(1, 100000 - total_word_length);\n        string word = \"\";\n        for(int j = 0; j < len; j++)\n            word += (char)('a' + rnd.next(26));\n        words.push_back(word);\n        total_word_length += len;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output words\n    for(int i = 0; i < n; i++)\n        printf(\"%s\\n\", words[i].c_str());\n\n    string message = \"\";\n    // Build the encoded message\n    string encoded_message = \"\";\n    for(int i = 0; i < n; i++)\n    {\n        encoded_message += \"<3\" + words[i];\n    }\n    encoded_message += \"<3\";\n\n    if(type == \"correct\")\n    {\n        // Insert random characters into random positions\n        for(int i = 0; i < encoded_message.size(); i++)\n        {\n            message += encoded_message[i];\n            int insertions = rnd.wnext(3, -2); // May or may not insert extra chars\n            for(int j = 0; j < insertions; j++)\n            {\n                char c;\n                int t = rnd.next(4);\n                if(t == 0)\n                    c = (char)('a' + rnd.next(26));\n                else if(t == 1)\n                    c = (char)('0' + rnd.next(10));\n                else if(t == 2)\n                    c = '<';\n                else\n                    c = '>';\n                message += c;\n            }\n        }\n    }\n    else if(type == \"missing_heart\")\n    {\n        // Same as correct but remove a heart\n        int remove_pos = rnd.next(n+1);\n        encoded_message = \"\";\n        for(int i = 0; i < n; i++)\n        {\n            if(i == remove_pos)\n                continue; // Skip one heart\n            encoded_message += \"<3\" + words[i];\n        }\n        if(remove_pos == n)\n            ; // Remove the last <3\n        else\n            encoded_message += \"<3\";\n\n        // Build message with random insertions\n        for(int i = 0; i < encoded_message.size(); i++)\n        {\n            message += encoded_message[i];\n            int insertions = rnd.wnext(3, -2); // May or may not insert extra chars\n            for(int j = 0; j < insertions; j++)\n            {\n                char c;\n                int t = rnd.next(4);\n                if(t == 0)\n                    c = (char)('a' + rnd.next(26));\n                else if(t == 1)\n                    c = (char)('0' + rnd.next(10));\n                else if(t == 2)\n                    c = '<';\n                else\n                    c = '>';\n                message += c;\n            }\n        }\n    }\n    else if(type == \"wrong_order\")\n    {\n        // Shuffle the words\n        vector<string> shuffled_words = words;\n        shuffle(shuffled_words.begin(), shuffled_words.end());\n        encoded_message = \"\";\n        for(int i = 0; i < n; i++)\n        {\n            encoded_message += \"<3\" + shuffled_words[i];\n        }\n        encoded_message += \"<3\";\n        // Build message with random insertions\n        for(int i = 0; i < encoded_message.size(); i++)\n        {\n            message += encoded_message[i];\n            int insertions = rnd.wnext(3, -2); // May or may not insert extra chars\n            for(int j = 0; j < insertions; j++)\n            {\n                char c;\n                int t = rnd.next(4);\n                if(t == 0)\n                    c = (char)('a' + rnd.next(26));\n                else if(t == 1)\n                    c = (char)('0' + rnd.next(10));\n                else if(t == 2)\n                    c = '<';\n                else\n                    c = '>';\n                message += c;\n            }\n        }\n    }\n    else if(type == \"random\")\n    {\n        // Generate a random message\n        int msglen = rnd.next(1, 100000);\n        for(int i = 0; i < msglen; i++)\n        {\n            int t = rnd.next(4);\n            char c;\n            if(t == 0)\n                c = (char)('a' + rnd.next(26));\n            else if(t == 1)\n                c = (char)('0' + rnd.next(10));\n            else if(t == 2)\n                c = '<';\n            else\n                c = '>';\n            message += c;\n        }\n    }\n    // Additional types can be added here\n\n    // Ensure the message length does not exceed 1e5\n    if(message.size() > 100000)\n        message = message.substr(0, 100000);\n\n    // Output message\n    printf(\"%s\\n\", message.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxlen = opt<int>(\"maxlen\", 10);\n    string type = opt<string>(\"type\", \"correct\");\n\n    int total_word_length = 0;\n\n    vector<string> words;\n    for(int i = 0; i < n; i++)\n    {\n        int len = rnd.next(1, maxlen);\n        if(total_word_length + len > 100000)\n            len = max(1, 100000 - total_word_length);\n        string word = \"\";\n        for(int j = 0; j < len; j++)\n            word += (char)('a' + rnd.next(26));\n        words.push_back(word);\n        total_word_length += len;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output words\n    for(int i = 0; i < n; i++)\n        printf(\"%s\\n\", words[i].c_str());\n\n    string message = \"\";\n    // Build the encoded message\n    string encoded_message = \"\";\n    for(int i = 0; i < n; i++)\n    {\n        encoded_message += \"<3\" + words[i];\n    }\n    encoded_message += \"<3\";\n\n    if(type == \"correct\")\n    {\n        // Insert random characters into random positions\n        for(int i = 0; i < encoded_message.size(); i++)\n        {\n            message += encoded_message[i];\n            int insertions = rnd.wnext(3, -2); // May or may not insert extra chars\n            for(int j = 0; j < insertions; j++)\n            {\n                char c;\n                int t = rnd.next(4);\n                if(t == 0)\n                    c = (char)('a' + rnd.next(26));\n                else if(t == 1)\n                    c = (char)('0' + rnd.next(10));\n                else if(t == 2)\n                    c = '<';\n                else\n                    c = '>';\n                message += c;\n            }\n        }\n    }\n    else if(type == \"missing_heart\")\n    {\n        // Same as correct but remove a heart\n        int remove_pos = rnd.next(n+1);\n        encoded_message = \"\";\n        for(int i = 0; i < n; i++)\n        {\n            if(i == remove_pos)\n                continue; // Skip one heart\n            encoded_message += \"<3\" + words[i];\n        }\n        if(remove_pos == n)\n            ; // Remove the last <3\n        else\n            encoded_message += \"<3\";\n\n        // Build message with random insertions\n        for(int i = 0; i < encoded_message.size(); i++)\n        {\n            message += encoded_message[i];\n            int insertions = rnd.wnext(3, -2); // May or may not insert extra chars\n            for(int j = 0; j < insertions; j++)\n            {\n                char c;\n                int t = rnd.next(4);\n                if(t == 0)\n                    c = (char)('a' + rnd.next(26));\n                else if(t == 1)\n                    c = (char)('0' + rnd.next(10));\n                else if(t == 2)\n                    c = '<';\n                else\n                    c = '>';\n                message += c;\n            }\n        }\n    }\n    else if(type == \"wrong_order\")\n    {\n        // Shuffle the words\n        vector<string> shuffled_words = words;\n        shuffle(shuffled_words.begin(), shuffled_words.end());\n        encoded_message = \"\";\n        for(int i = 0; i < n; i++)\n        {\n            encoded_message += \"<3\" + shuffled_words[i];\n        }\n        encoded_message += \"<3\";\n        // Build message with random insertions\n        for(int i = 0; i < encoded_message.size(); i++)\n        {\n            message += encoded_message[i];\n            int insertions = rnd.wnext(3, -2); // May or may not insert extra chars\n            for(int j = 0; j < insertions; j++)\n            {\n                char c;\n                int t = rnd.next(4);\n                if(t == 0)\n                    c = (char)('a' + rnd.next(26));\n                else if(t == 1)\n                    c = (char)('0' + rnd.next(10));\n                else if(t == 2)\n                    c = '<';\n                else\n                    c = '>';\n                message += c;\n            }\n        }\n    }\n    else if(type == \"random\")\n    {\n        // Generate a random message\n        int msglen = rnd.next(1, 100000);\n        for(int i = 0; i < msglen; i++)\n        {\n            int t = rnd.next(4);\n            char c;\n            if(t == 0)\n                c = (char)('a' + rnd.next(26));\n            else if(t == 1)\n                c = (char)('0' + rnd.next(10));\n            else if(t == 2)\n                c = '<';\n            else\n                c = '>';\n            message += c;\n        }\n    }\n    // Additional types can be added here\n\n    // Ensure the message length does not exceed 1e5\n    if(message.size() > 100000)\n        message = message.substr(0, 100000);\n\n    // Output message\n    printf(\"%s\\n\", message.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, correct messages\n./gen -n 1 -type correct\n./gen -n 5 -type correct\n./gen -n 10 -type correct\n\n# Small n, incorrect messages\n./gen -n 10 -type missing_heart\n./gen -n 10 -type wrong_order\n./gen -n 10 -type random\n\n# Medium n, correct messages\n./gen -n 100 -type correct\n./gen -n 100 -type correct -maxlen 1\n\n# Medium n, incorrect messages\n./gen -n 100 -type missing_heart\n./gen -n 100 -type wrong_order\n\n# Large n, correct messages\n./gen -n 1000 -type correct\n./gen -n 10000 -type correct\n\n# Large n, incorrect messages\n./gen -n 10000 -type missing_heart\n./gen -n 10000 -type wrong_order\n\n# n at maximum value, varying types\n./gen -n 100000 -type correct\n\n# Maximum n, words of minimum length\n./gen -n 100000 -type correct -maxlen 1\n\n# Maximum n, words of varying lengths\n./gen -n 100000 -type correct -maxlen 1000\n\n# n at maximum value, incorrect messages\n./gen -n 100000 -type missing_heart\n./gen -n 100000 -type wrong_order\n\n# Random messages\n./gen -n 0 -type random\n\n# Edge cases\n./gen -n 1 -type missing_heart\n./gen -n 1 -type wrong_order\n./gen -n 1 -type random\n\n# Total word length near limit\n./gen -n 50000 -type correct -maxlen 2\n\n# Generate a message with maximum allowed length\n./gen -n 100000 -type correct -maxlen 1\n\n# Generate correct messages with long words\n./gen -n 10 -type correct -maxlen 10000\n\n# Generate an incorrect message where only one character is off\n./gen -n 1000 -type missing_heart\n\n# Generate random incorrect messages\n./gen -n 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:45.147907",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "358/C",
      "title": "C. Dima and Containers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of Inna's commands. Then n lines follow, describing Inna's commands. Each line consists an integer:  Integer a (1 ≤ a ≤ 105) means that Inna gives Dima a command to add number a into one of containers.  Integer 0 shows that Inna asks Dima to make at most three extractions from different containers.",
      "output_spec": "OutputEach command of the input must correspond to one line of the output — Dima's action.For the command of the first type (adding) print one word that corresponds to Dima's choice:  pushStack — add to the end of the stack;  pushQueue — add to the end of the queue;  pushFront — add to the beginning of the deck;  pushBack — add to the end of the deck. For a command of the second type first print an integer k (0 ≤ k ≤ 3), that shows the number of extract operations, then print k words separated by space. The words can be:  popStack — extract from the end of the stack;  popQueue — extract from the beginning of the line;  popFront — extract from the beginning from the deck;  popBack — extract from the end of the deck. The printed operations mustn't extract numbers from empty containers. Also, they must extract numbers from distinct containers.The printed sequence of actions must lead to the maximum number of kisses. If there are multiple sequences of actions leading to the maximum number of kisses, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy100101201230OutputCopy0pushStack1 popStackpushStackpushQueue2 popStack popQueuepushStackpushQueuepushFront3 popStack popQueue popFrontInputCopy41230OutputCopypushStackpushQueuepushFront3 popStack popQueue popFront",
      "description": "C. Dima and Containers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of Inna's commands. Then n lines follow, describing Inna's commands. Each line consists an integer:  Integer a (1 ≤ a ≤ 105) means that Inna gives Dima a command to add number a into one of containers.  Integer 0 shows that Inna asks Dima to make at most three extractions from different containers.\n\nOutputEach command of the input must correspond to one line of the output — Dima's action.For the command of the first type (adding) print one word that corresponds to Dima's choice:  pushStack — add to the end of the stack;  pushQueue — add to the end of the queue;  pushFront — add to the beginning of the deck;  pushBack — add to the end of the deck. For a command of the second type first print an integer k (0 ≤ k ≤ 3), that shows the number of extract operations, then print k words separated by space. The words can be:  popStack — extract from the end of the stack;  popQueue — extract from the beginning of the line;  popFront — extract from the beginning from the deck;  popBack — extract from the end of the deck. The printed operations mustn't extract numbers from empty containers. Also, they must extract numbers from distinct containers.The printed sequence of actions must lead to the maximum number of kisses. If there are multiple sequences of actions leading to the maximum number of kisses, you are allowed to print any of them.\n\nInputCopy100101201230OutputCopy0pushStack1 popStackpushStackpushQueue2 popStack popQueuepushStackpushQueuepushFront3 popStack popQueue popFrontInputCopy41230OutputCopypushStackpushQueuepushFront3 popStack popQueue popFront\n\nInputCopy100101201230\n\nOutputCopy0pushStack1 popStackpushStackpushQueue2 popStack popQueuepushStackpushQueuepushFront3 popStack popQueue popFront\n\nInputCopy41230\n\nOutputCopypushStackpushQueuepushFront3 popStack popQueue popFront",
      "solutions": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces",
          "content": "Hi everybody!When you've seen my nickname you probably thought: \"Finally! At least this round is not made by Sereja! And you are right! I, Dmytro Berezin(Berezin) give this round... and my neighbour Sergii Nagin(Sereja)The action will take place in Friday, 25th october, 19:30.Thanks to Gerald Agapov(Gerald) and Maria Belova(Delinur) for help in preperation and translation of problems respectively.Thanks to Yaroslav Tverdokhlib(KADR) for help in testing.You have to help Dima equip his personal life :)The point values for this cause is 500 1000 1500 2000 3000.Sergii strongly recommends you to read all the tasks.I highly recommend you also to try to solve them.Thank you for your attention, and have a successful round!Tutorial: http://codeforces.com/blog/entry/9334",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9326",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*C"
          },
          "content_length": 3336
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*C"
          },
          "content_length": 3336
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 1",
          "code": "edges.length()%2 == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 2",
          "code": "pos=sts.find_first_of(s[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 3",
          "code": "pos=sts.find_first_of(s[i],pos);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 4",
          "code": "StringBuilder.append()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int cmd = inf.readInt(0, 100000, \"command\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int cmd = inf.readInt(0, 100000, \"command\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int cmd = inf.readInt(0, 100000, \"command\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(); // Number of commands\n\n    vector<int> cmds(n);\n    for (int i = 0; i < n; i++) {\n        cmds[i] = inf.readInt();\n    }\n\n    // We simulate the three containers:\n    // stackContainer: last-in first-out (popStack -> pop from the back)\n    // queueContainer: first-in first-out (popQueue -> pop from the front)\n    // deckContainer: can push/pop from both ends (popFront -> pop front, popBack -> pop back)\n\n    // blockVals will hold the values in the current block of additions until we see a \"0\" command\n    // so that we can check the maximum possible sum for that block.\n    vector<int> blockVals;\n\n    // For simulation:\n    vector<int> stackContainer;      // use back() for popStack\n    deque<int> queueContainer;       // use front() for popQueue\n    deque<int> deckContainer;        // popFront -> front(), popBack -> back()\n\n    auto computeMaxBlockSum = [&](const vector<int> &vals) {\n        // Sum of up to 3 largest values\n        if (vals.empty()) return 0LL;\n        vector<long long> sortedVals(vals.begin(), vals.end());\n        sort(sortedVals.begin(), sortedVals.end(), greater<long long>());\n        long long sum = 0;\n        for (int i = 0; i < (int)min((size_t)3, sortedVals.size()); i++) {\n            sum += sortedVals[i];\n        }\n        return sum;\n    };\n\n    long long expectedSum, gotSum;\n\n    // Process each command and each corresponding line of output\n    for (int i = 0; i < n; i++) {\n        int cmd = cmds[i];\n        if (cmd != 0) {\n            // We expect exactly one token from {pushStack, pushQueue, pushFront, pushBack}.\n            string op = ouf.readToken();\n            if (op != \"pushStack\" && op != \"pushQueue\" && \n                op != \"pushFront\" && op != \"pushBack\")\n            {\n                quitf(_wa, \"Invalid operation for an add command: %s\", op.c_str());\n            }\n\n            // Simulate the push\n            if (op == \"pushStack\") {\n                stackContainer.push_back(cmd);\n            } else if (op == \"pushQueue\") {\n                queueContainer.push_back(cmd);\n            } else if (op == \"pushFront\") {\n                deckContainer.push_front(cmd);\n            } else { // pushBack\n                deckContainer.push_back(cmd);\n            }\n\n            // Keep track of all values in this block\n            blockVals.push_back(cmd);\n        } \n        else {\n            // A zero command: read k (0 ≤ k ≤ 3), then read k distinct pop operations\n            int k = ouf.readInt(0, 3);\n            vector<string> pops(k);\n            set<string> used;\n            for (int j = 0; j < k; j++) {\n                pops[j] = ouf.readToken();\n                if (pops[j] != \"popStack\" && pops[j] != \"popQueue\" &&\n                    pops[j] != \"popFront\" && pops[j] != \"popBack\")\n                {\n                    quitf(_wa, \"Invalid pop operation: %s\", pops[j].c_str());\n                }\n                // Must pop from distinct containers\n                if (!used.insert(pops[j]).second) {\n                    quitf(_wa, \"Pop operations must be from distinct containers\");\n                }\n            }\n\n            // Simulate the pop operations:\n            long long sumBlock = 0;\n            for (auto &p : pops) {\n                if (p == \"popStack\") {\n                    if (stackContainer.empty()) {\n                        quitf(_wa, \"popStack from an empty stack\");\n                    }\n                    sumBlock += stackContainer.back();\n                    stackContainer.pop_back();\n                } else if (p == \"popQueue\") {\n                    if (queueContainer.empty()) {\n                        quitf(_wa, \"popQueue from an empty queue\");\n                    }\n                    sumBlock += queueContainer.front();\n                    queueContainer.pop_front();\n                } else if (p == \"popFront\") {\n                    if (deckContainer.empty()) {\n                        quitf(_wa, \"popFront from an empty deque\");\n                    }\n                    sumBlock += deckContainer.front();\n                    deckContainer.pop_front();\n                } else {\n                    // popBack\n                    if (deckContainer.empty()) {\n                        quitf(_wa, \"popBack from an empty deque\");\n                    }\n                    sumBlock += deckContainer.back();\n                    deckContainer.pop_back();\n                }\n            }\n\n            // Compute the best possible sum for this block\n            long long bestSum = computeMaxBlockSum(blockVals);\n            if (sumBlock != bestSum) {\n                quitf(_wa,\n                      \"Wrong sum in extraction: got %lld, but the max possible is %lld\",\n                      sumBlock, bestSum);\n            }\n\n            // Now empty all containers\n            stackContainer.clear();\n            queueContainer.clear();\n            deckContainer.clear();\n\n            // Reset blockVals for the next block\n            blockVals.clear();\n        }\n    }\n\n    // If we reach here with no issues, the output is correct\n    // (Participant's strategy yields the maximum sum of extracted values.)\n    quitf(_ok, \"answer is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_num = opt<int>(\"max_num\", 100000);\n\n    vector<int> commands;\n\n    if (type == \"random\") {\n        // Generate random sequence of add and extract commands\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                // Add command\n                int a = rnd.next(1, max_num);\n                commands.push_back(a);\n            } else {\n                // Extract command\n                commands.push_back(0);\n            }\n        }\n    } else if (type == \"all_add\") {\n        // Generate only add commands\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, max_num);\n            commands.push_back(a);\n        }\n    } else if (type == \"all_extract\") {\n        // Generate only extract commands\n        for (int i = 0; i < n; ++i) {\n            commands.push_back(0);\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between add and extract commands\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                int a = rnd.next(1, max_num);\n                commands.push_back(a);\n            } else {\n                commands.push_back(0);\n            }\n        }\n    } else if (type == \"max_extraction\") {\n        // Generate commands to test maximum extraction\n        int num_adds = n / 2;\n        for (int i = 0; i < num_adds; ++i) {\n            int a = rnd.next(1, 10); // Small numbers\n            commands.push_back(a);\n        }\n        // Add a large number before extraction\n        commands.push_back(max_num);\n        // Extraction command\n        commands.push_back(0);\n        // Remaining commands\n        for (int i = num_adds + 2; i < n; ++i) {\n            int a = rnd.next(1, 10);\n            commands.push_back(a);\n        }\n    } else if (type == \"long_no_extract\") {\n        // Long sequence without extraction, then an extraction\n        for (int i = 0; i < n - 1; ++i) {\n            int a = rnd.next(1, max_num);\n            commands.push_back(a);\n        }\n        // Last command is extraction\n        commands.push_back(0);\n    } else if (type == \"empty_extract\") {\n        // Extract commands when containers are empty\n        for (int i = 0; i < n; ++i) {\n            commands.push_back(0);\n        }\n    } else if (type == \"increasing\") {\n        // Add commands with increasing numbers\n        for (int i = 1; i <= n; ++i) {\n            commands.push_back(min(max_num, i));\n        }\n    } else if (type == \"decreasing\") {\n        // Add commands with decreasing numbers\n        for (int i = n; i >= 1; --i) {\n            commands.push_back(min(max_num, i));\n        }\n    } else {\n        // Invalid type\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and the commands\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", commands[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_num = opt<int>(\"max_num\", 100000);\n\n    vector<int> commands;\n\n    if (type == \"random\") {\n        // Generate random sequence of add and extract commands\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                // Add command\n                int a = rnd.next(1, max_num);\n                commands.push_back(a);\n            } else {\n                // Extract command\n                commands.push_back(0);\n            }\n        }\n    } else if (type == \"all_add\") {\n        // Generate only add commands\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, max_num);\n            commands.push_back(a);\n        }\n    } else if (type == \"all_extract\") {\n        // Generate only extract commands\n        for (int i = 0; i < n; ++i) {\n            commands.push_back(0);\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between add and extract commands\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                int a = rnd.next(1, max_num);\n                commands.push_back(a);\n            } else {\n                commands.push_back(0);\n            }\n        }\n    } else if (type == \"max_extraction\") {\n        // Generate commands to test maximum extraction\n        int num_adds = n / 2;\n        for (int i = 0; i < num_adds; ++i) {\n            int a = rnd.next(1, 10); // Small numbers\n            commands.push_back(a);\n        }\n        // Add a large number before extraction\n        commands.push_back(max_num);\n        // Extraction command\n        commands.push_back(0);\n        // Remaining commands\n        for (int i = num_adds + 2; i < n; ++i) {\n            int a = rnd.next(1, 10);\n            commands.push_back(a);\n        }\n    } else if (type == \"long_no_extract\") {\n        // Long sequence without extraction, then an extraction\n        for (int i = 0; i < n - 1; ++i) {\n            int a = rnd.next(1, max_num);\n            commands.push_back(a);\n        }\n        // Last command is extraction\n        commands.push_back(0);\n    } else if (type == \"empty_extract\") {\n        // Extract commands when containers are empty\n        for (int i = 0; i < n; ++i) {\n            commands.push_back(0);\n        }\n    } else if (type == \"increasing\") {\n        // Add commands with increasing numbers\n        for (int i = 1; i <= n; ++i) {\n            commands.push_back(min(max_num, i));\n        }\n    } else if (type == \"decreasing\") {\n        // Add commands with decreasing numbers\n        for (int i = n; i >= 1; --i) {\n            commands.push_back(min(max_num, i));\n        }\n    } else {\n        // Invalid type\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and the commands\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", commands[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 10 -type random\n./gen -n 10 -type all_add\n./gen -n 10 -type all_extract\n./gen -n 10 -type alternate\n./gen -n 10 -type max_extraction\n./gen -n 10 -type long_no_extract\n./gen -n 10 -type empty_extract\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n\n# Medium test cases\n./gen -n 1000 -type random\n./gen -n 1000 -type all_add\n./gen -n 1000 -type all_extract\n./gen -n 1000 -type alternate\n./gen -n 1000 -type max_extraction\n./gen -n 1000 -type long_no_extract\n./gen -n 1000 -type empty_extract\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n\n# Large test cases\n./gen -n 100000 -type random\n./gen -n 100000 -type all_add\n./gen -n 100000 -type all_extract\n./gen -n 100000 -type alternate\n./gen -n 100000 -type max_extraction\n./gen -n 100000 -type long_no_extract\n./gen -n 100000 -type empty_extract\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n\n# Test cases with maximum numbers\n./gen -n 100000 -type random -max_num 100000\n./gen -n 100000 -type increasing -max_num 100000\n./gen -n 100000 -type decreasing -max_num 100000\n\n# Edge cases\n./gen -n 1 -type random\n./gen -n 1 -type all_extract\n./gen -n 1 -type empty_extract\n./gen -n 1 -type max_extraction\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:47.245256",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "358/D",
      "title": "D. Dima and Hares",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 3000) — the number of hares. Then three lines follow, each line has n integers. The first line contains integers a1 a2 ... an. The second line contains b1, b2, ..., bn. The third line contains c1, c2, ..., cn. The following limits are fulfilled: 0 ≤ ai, bi, ci ≤ 105.Number ai in the first line shows the joy that hare number i gets if his adjacent hares are both hungry. Number bi in the second line shows the joy that hare number i radiates if he has exactly one full adjacent hare. Number сi in the third line shows the joy that hare number i radiates if both his adjacent hares are full.",
      "output_spec": "OutputIn a single line, print the maximum possible total joy of the hares Inna can get by feeding them.",
      "sample_tests": "ExamplesInputCopy41 2 3 44 3 2 10 1 1 0OutputCopy13InputCopy78 5 7 6 1 8 92 7 9 5 4 3 12 3 3 4 1 1 3OutputCopy44InputCopy31 1 11 2 11 1 1OutputCopy4",
      "description": "D. Dima and Hares\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 3000) — the number of hares. Then three lines follow, each line has n integers. The first line contains integers a1 a2 ... an. The second line contains b1, b2, ..., bn. The third line contains c1, c2, ..., cn. The following limits are fulfilled: 0 ≤ ai, bi, ci ≤ 105.Number ai in the first line shows the joy that hare number i gets if his adjacent hares are both hungry. Number bi in the second line shows the joy that hare number i radiates if he has exactly one full adjacent hare. Number сi in the third line shows the joy that hare number i radiates if both his adjacent hares are full.\n\nOutputIn a single line, print the maximum possible total joy of the hares Inna can get by feeding them.\n\nInputCopy41 2 3 44 3 2 10 1 1 0OutputCopy13InputCopy78 5 7 6 1 8 92 7 9 5 4 3 12 3 3 4 1 1 3OutputCopy44InputCopy31 1 11 2 11 1 1OutputCopy4\n\nInputCopy41 2 3 44 3 2 10 1 1 0\n\nOutputCopy13\n\nInputCopy78 5 7 6 1 8 92 7 9 5 4 3 12 3 3 4 1 1 3\n\nOutputCopy44\n\nInputCopy31 1 11 2 11 1 1\n\nOutputCopy4",
      "solutions": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces",
          "content": "Hi everybody!When you've seen my nickname you probably thought: \"Finally! At least this round is not made by Sereja! And you are right! I, Dmytro Berezin(Berezin) give this round... and my neighbour Sergii Nagin(Sereja)The action will take place in Friday, 25th october, 19:30.Thanks to Gerald Agapov(Gerald) and Maria Belova(Delinur) for help in preperation and translation of problems respectively.Thanks to Yaroslav Tverdokhlib(KADR) for help in testing.You have to help Dima equip his personal life :)The point values for this cause is 500 1000 1500 2000 3000.Sergii strongly recommends you to read all the tasks.I highly recommend you also to try to solve them.Thank you for your attention, and have a successful round!Tutorial: http://codeforces.com/blog/entry/9334",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9326",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*D"
          },
          "content_length": 3336
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*D"
          },
          "content_length": 3336
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 1",
          "code": "edges.length()%2 == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 2",
          "code": "pos=sts.find_first_of(s[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 3",
          "code": "pos=sts.find_first_of(s[i],pos);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 4",
          "code": "StringBuilder.append()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 100000, \"b_i\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 100000, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 100000, \"b_i\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 100000, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 100000, \"b_i\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 100000, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n), c(n);\n\n    if (type == \"min\") {\n        // All zeros\n        fill(a.begin(), a.end(), 0);\n        fill(b.begin(), b.end(), 0);\n        fill(c.begin(), c.end(), 0);\n    } else if (type == \"max\") {\n        // All maximum values\n        fill(a.begin(), a.end(), 100000);\n        fill(b.begin(), b.end(), 100000);\n        fill(c.begin(), c.end(), 100000);\n    } else if (type == \"ai_max\") {\n        // ai maximum, bi and ci zeros\n        fill(a.begin(), a.end(), 100000);\n        fill(b.begin(), b.end(), 0);\n        fill(c.begin(), c.end(), 0);\n    } else if (type == \"bi_max\") {\n        // bi maximum, ai and ci zeros\n        fill(a.begin(), a.end(), 0);\n        fill(b.begin(), b.end(), 100000);\n        fill(c.begin(), c.end(), 0);\n    } else if (type == \"ci_max\") {\n        // ci maximum, ai and bi zeros\n        fill(a.begin(), a.end(), 0);\n        fill(b.begin(), b.end(), 0);\n        fill(c.begin(), c.end(), 100000);\n    } else if (type == \"ai_bi_large\") {\n        // ai and bi large values, ci zero\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(50000, 100000);\n            b[i] = rnd.next(50000, 100000);\n            c[i] = 0;\n        }\n    } else if (type == \"alternating\"){\n        // Alternate between large and small values\n        for(int i = 0; i < n; ++i){\n            if(i % 2 == 0){\n                a[i] = 0;\n                b[i] = 0;\n                c[i] = 0;\n            } else{\n                a[i] = 100000;\n                b[i] = 100000;\n                c[i] = 100000;\n            }\n        }\n    } else if (type == \"random\"){\n        // Random values between 0 and 1e5\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, 100000);\n            b[i] = rnd.next(0, 100000);\n            c[i] = rnd.next(0, 100000);\n        }\n    } else {\n        // Default to random if type not recognized\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, 100000);\n            b[i] = rnd.next(0, 100000);\n            c[i] = rnd.next(0, 100000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < n; ++i){\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < n; ++i){\n        printf(\"%d%c\", c[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n), c(n);\n\n    if (type == \"min\") {\n        // All zeros\n        fill(a.begin(), a.end(), 0);\n        fill(b.begin(), b.end(), 0);\n        fill(c.begin(), c.end(), 0);\n    } else if (type == \"max\") {\n        // All maximum values\n        fill(a.begin(), a.end(), 100000);\n        fill(b.begin(), b.end(), 100000);\n        fill(c.begin(), c.end(), 100000);\n    } else if (type == \"ai_max\") {\n        // ai maximum, bi and ci zeros\n        fill(a.begin(), a.end(), 100000);\n        fill(b.begin(), b.end(), 0);\n        fill(c.begin(), c.end(), 0);\n    } else if (type == \"bi_max\") {\n        // bi maximum, ai and ci zeros\n        fill(a.begin(), a.end(), 0);\n        fill(b.begin(), b.end(), 100000);\n        fill(c.begin(), c.end(), 0);\n    } else if (type == \"ci_max\") {\n        // ci maximum, ai and bi zeros\n        fill(a.begin(), a.end(), 0);\n        fill(b.begin(), b.end(), 0);\n        fill(c.begin(), c.end(), 100000);\n    } else if (type == \"ai_bi_large\") {\n        // ai and bi large values, ci zero\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(50000, 100000);\n            b[i] = rnd.next(50000, 100000);\n            c[i] = 0;\n        }\n    } else if (type == \"alternating\"){\n        // Alternate between large and small values\n        for(int i = 0; i < n; ++i){\n            if(i % 2 == 0){\n                a[i] = 0;\n                b[i] = 0;\n                c[i] = 0;\n            } else{\n                a[i] = 100000;\n                b[i] = 100000;\n                c[i] = 100000;\n            }\n        }\n    } else if (type == \"random\"){\n        // Random values between 0 and 1e5\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, 100000);\n            b[i] = rnd.next(0, 100000);\n            c[i] = rnd.next(0, 100000);\n        }\n    } else {\n        // Default to random if type not recognized\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, 100000);\n            b[i] = rnd.next(0, 100000);\n            c[i] = rnd.next(0, 100000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < n; ++i){\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < n; ++i){\n        printf(\"%d%c\", c[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n./gen -n 1 -type max\n./gen -n 1 -type random\n\n./gen -n 2 -type min\n./gen -n 2 -type max\n./gen -n 2 -type random\n./gen -n 2 -type ai_bi_large\n./gen -n 2 -type ci_max\n\n./gen -n 3 -type random\n\n./gen -n 10 -type min\n./gen -n 10 -type max\n./gen -n 10 -type random\n./gen -n 10 -type ai_max\n./gen -n 10 -type bi_max\n./gen -n 10 -type ci_max\n./gen -n 10 -type ai_bi_large\n./gen -n 10 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type ai_max\n\n./gen -n 1000 -type random\n./gen -n 1000 -type bi_max\n\n./gen -n 3000 -type random\n./gen -n 3000 -type ai_max\n./gen -n 3000 -type bi_max\n./gen -n 3000 -type ci_max\n./gen -n 3000 -type ai_bi_large\n./gen -n 3000 -type alternating\n./gen -n 3000 -type min\n./gen -n 3000 -type max\n\n./gen -n 1500 -type random\n./gen -n 2000 -type random\n./gen -n 2500 -type random\n./gen -n 2500 -type ai_max\n./gen -n 2500 -type bi_max\n./gen -n 2500 -type ci_max\n./gen -n 2500 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:49.196634",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "358/E",
      "title": "E. Dima and Kicks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains n and m (1 ≤ n, m ≤ 103) — size of the room.Next n lines goes, each contains m numbers aij — Dima's notes: aij = 1, if Dima was staying in the square (i, j) or was flying above it. Otherwise aij = 0.At least one aij equals 1.",
      "output_spec": "OutputIn a single line in accending order print all k (k > 1), which matches the Dima's notes. If there are no such k and Dima invented this story with kicks, print -1.",
      "sample_tests": "ExamplesInputCopy5 51 1 1 1 11 0 0 0 11 0 0 0 11 0 0 0 11 1 1 1 1OutputCopy2 4InputCopy7 70 0 1 1 1 0 00 0 1 0 1 0 01 1 1 1 1 1 11 0 1 0 1 0 11 1 1 1 1 1 10 0 1 0 1 0 00 0 1 1 1 0 0OutputCopy2InputCopy3 31 1 11 1 11 1 1OutputCopy-1InputCopy4 41 1 1 10 0 0 00 0 0 00 0 0 0OutputCopy3InputCopy5 50 0 1 0 00 0 1 0 01 1 1 1 10 0 1 0 00 0 1 0 0OutputCopy-1",
      "description": "E. Dima and Kicks\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains n and m (1 ≤ n, m ≤ 103) — size of the room.Next n lines goes, each contains m numbers aij — Dima's notes: aij = 1, if Dima was staying in the square (i, j) or was flying above it. Otherwise aij = 0.At least one aij equals 1.\n\nOutputIn a single line in accending order print all k (k > 1), which matches the Dima's notes. If there are no such k and Dima invented this story with kicks, print -1.\n\nInputCopy5 51 1 1 1 11 0 0 0 11 0 0 0 11 0 0 0 11 1 1 1 1OutputCopy2 4InputCopy7 70 0 1 1 1 0 00 0 1 0 1 0 01 1 1 1 1 1 11 0 1 0 1 0 11 1 1 1 1 1 10 0 1 0 1 0 00 0 1 1 1 0 0OutputCopy2InputCopy3 31 1 11 1 11 1 1OutputCopy-1InputCopy4 41 1 1 10 0 0 00 0 0 00 0 0 0OutputCopy3InputCopy5 50 0 1 0 00 0 1 0 01 1 1 1 10 0 1 0 00 0 1 0 0OutputCopy-1\n\nInputCopy5 51 1 1 1 11 0 0 0 11 0 0 0 11 0 0 0 11 1 1 1 1\n\nOutputCopy2 4\n\nInputCopy7 70 0 1 1 1 0 00 0 1 0 1 0 01 1 1 1 1 1 11 0 1 0 1 0 11 1 1 1 1 1 10 0 1 0 1 0 00 0 1 1 1 0 0\n\nOutputCopy2\n\nInputCopy3 31 1 11 1 11 1 1\n\nOutputCopy-1\n\nInputCopy4 41 1 1 10 0 0 00 0 0 00 0 0 0\n\nOutputCopy3\n\nInputCopy5 50 0 1 0 00 0 1 0 01 1 1 1 10 0 1 0 00 0 1 0 0\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces",
          "content": "Hi everybody!When you've seen my nickname you probably thought: \"Finally! At least this round is not made by Sereja! And you are right! I, Dmytro Berezin(Berezin) give this round... and my neighbour Sergii Nagin(Sereja)The action will take place in Friday, 25th october, 19:30.Thanks to Gerald Agapov(Gerald) and Maria Belova(Delinur) for help in preperation and translation of problems respectively.Thanks to Yaroslav Tverdokhlib(KADR) for help in testing.You have to help Dima equip his personal life :)The point values for this cause is 500 1000 1500 2000 3000.Sergii strongly recommends you to read all the tasks.I highly recommend you also to try to solve them.Thank you for your attention, and have a successful round!Tutorial: http://codeforces.com/blog/entry/9334",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9326",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 771
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*E"
          },
          "content_length": 3336
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces",
          "content": "358A - Dima and Continuous LineAuthor — Berezin If our line has self-intersections, that some pair of semi-circles exists, which intersect each other.Let points x1 < x2 are connected with a semi-circle and points x3 < x4 are connected with another semi-circle. Then this semis-circles intersect if one of the conditions is true: 1). x1 < x3 < x2 < x42). x3 < x1 < x4 < x2 Let’s iterate trough all pairs of semi-circles, and check if the semi-circles intersect each other. So, the solution will have complexity O(N2) what satisfied the constrains. 358B - Dima and Text MessagesAuthor — Berezin It’s clear, that adding new random symbols means, that we can simply omit them, they don’t change the structure of the phrase:  < 3word1 < 3word2 < 3... wordN < 3. Let’s determine the phrase before inserting random elements: s = \" < 3\" + word1 + \" < 3\" + ... + \" < 3\" + wordN + \" < 3\". Lets i —is an index in s, we are waiting for. At the beginning i = 0; we will iterate though the sms and when we will meet the symbol which equals to si we will simply increment i. if at some moment |s| ≤ I we found all needed symbols and answer is yes, otherwise – no.358C - Dima and ContainersAuthor — Berezin We know all the numbers at the beginning, so, it’s clear, that we want pop three maximums. We can “precalculate “ maximums with finding next zero and iterating through all numbers between two zeroes.We should do pops from different containers, so let’s save maximums in the top of the stack, in the beginning of the queue and on the beginning of the dek. (you can do this in some other way) We should determine, where will be stored the 1st, 2nd and 3rd maximum. For example, the first(the biggest one) – in the stack, second – in queue, and the third – in dek. “trash” – other numbers we can save into the end of the dek.Also you need to catch cases, when two or less numbers are between zeroes. 358D - Dima and HaresAuthor — Sereja Let’s look at the first hare: we chose them befoe second, or after. If it is chosen after the second, than the solution from the 2nd hare to the last doesn’t depend on the first one, otherwise, we will receive the same but before the second hair will be obviously the feed hair. So, we have two dinamics:1). d0i — answer for suffix as a separate task.2). d1i — answer for suffix if the previous hair for this suffix is feed already.Movements:d0n  =  and1n  =  bnd0i  =  max(ai  +  d1i  +  1,  bi  +  d0i  +  1)d1i  =  max(bi  +  d1i  +  1,  ci  +  d0i  +  1)answer is d01; 358E - Dima and KicksAuthor — Sereja The first thing to understand is that the answer is the divisor of maximal-length sequence of standing one by one ones. (1111…11)Let’s iterate trough this number. Now we should check the table knowing the value of K. Let’s find the most left of ones, and choose from them the most top. Let it be (X, Y). then after each step Dima can appear inly in cells which look like: (X + K * a, Y + K * b). Let such cells are the vertexes of the graph. And sequences of ones – the ribs. We will build the graph. We should check that there are no additional ones in table. We should also check if the graph is connected and has en Euler’s path. The value of K is the next answer under the all conditions. The correct implementation will have the complexity O(N * N * log(N)). In reality it will be never achieved.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 358\\s*E"
          },
          "content_length": 3336
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 1",
          "code": "edges.length()%2 == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 2",
          "code": "pos=sts.find_first_of(s[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 3",
          "code": "pos=sts.find_first_of(s[i],pos);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) - Codeforces - Code 4",
          "code": "StringBuilder.append()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9326",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "( int position, bool previous )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "if previous is true (previous hare is already fed) :\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ b[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ c[position]\n \n\nElse if previous is false (previous hare is not fed)\n\n 1. I can feed the current hare now so result1= solve( position+1, 1)+ a[position]\n 2. I will feed after the next one so  result2 =  solve( position+1, 0)+ b[position]\n\n  return max(result1,result2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "int n,a[3001],b[3001],c[3001],dpTable[3001][2];\nint feed(int depth,bool feeded)\n{\n\nif(depth == n)\n{\n    if(feeded)\n        return b[n];\n    else\n        return a[n];\n}\nif(dpTable[depth][feeded]!=(-1))\n    return dpTable[depth][feeded];\nint x;\nif(feeded)\n    x = max(b[depth]+feed(depth+1,0),c[depth]+feed(depth+1,1));\nelse\n    x = max(b[depth]+feed(depth+1,0),a[depth]+feed(depth+1,1));\nreturn dpTable[depth][feeded] = x;\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #208 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "s = s + str + \"<3\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9334",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    bool has_one = false;\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        for (int val : row) {\n            if (val == 1) has_one = true;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(has_one, \"At least one a_{i,j} must be 1.\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    bool has_one = false;\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        for (int val : row) {\n            if (val == 1) has_one = true;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(has_one, \"At least one a_{i,j} must be 1.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    bool has_one = false;\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        for (int val : row) {\n            if (val == 1) has_one = true;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(has_one, \"At least one a_{i,j} must be 1.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // optional k value\n\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    if (type == \"random\") {\n        if (k <= 1) {\n            // Random k between 2 and min(n, m)\n            k = rnd.next(2, min(n, m));\n        }\n\n        int i_cur = rnd.next(0, n - 1);\n        int j_cur = rnd.next(0, m - 1);\n        grid[i_cur][j_cur] = 1;\n\n        set<pair<pair<int,int>, pair<int,int>>> edges_crossed;\n\n        vector<pair<int,int>> directions = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n\n        int moves = 0;\n        while (true) {\n            // Shuffle directions\n            shuffle(directions.begin(), directions.end());\n\n            bool moved = false;\n            for (auto dir : directions) {\n                int dx = dir.first;\n                int dy = dir.second;\n\n                // Check if movement is possible\n                int i_new = i_cur + dx * (k);\n                int j_new = j_cur + dy * (k);\n\n                if (i_new < 0 || i_new >= n || j_new < 0 || j_new >= m) {\n                    continue; // Movement goes out of grid\n                }\n\n                // Prepare to collect edges and positions to be marked\n                vector<pair<int,int>> positions_to_mark;\n                vector<pair<pair<int,int>, pair<int,int>>> edges_to_add;\n\n                int i_prev = i_cur;\n                int j_prev = j_cur;\n\n                bool can_move = true;\n                for (int t = 1; t <= k; ++t) {\n                    int i = i_cur + dx * t;\n                    int j = j_cur + dy * t;\n\n                    positions_to_mark.push_back({ i, j });\n\n                    // Edge between i_prev, j_prev and i, j\n                    pair<pair<int,int>, pair<int,int>> edge = make_pair(\n                        min(make_pair(i_prev, j_prev), make_pair(i, j)),\n                        max(make_pair(i_prev, j_prev), make_pair(i, j))\n                    );\n                    if (edges_crossed.count(edge)) {\n                        can_move = false;\n                        break;\n                    } else {\n                        edges_to_add.push_back(edge);\n                    }\n\n                    i_prev = i;\n                    j_prev = j;\n                }\n\n                if (!can_move) {\n                    continue; // Try next direction\n                } else {\n                    // Move is successful\n                    for (auto pos : positions_to_mark) {\n                        grid[pos.first][pos.second] = 1;\n                    }\n                    for (auto edge : edges_to_add) {\n                        edges_crossed.insert(edge);\n                    }\n                    // Update current position\n                    i_cur = i_new;\n                    j_cur = j_new;\n                    moved = true;\n                    ++moves;\n                    break;\n                }\n            }\n            if (!moved) {\n                break; // No moves possible\n            }\n        }\n\n    } else if (type == \"full\") {\n        // All ones\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n\n    } else if (type == \"nosolution\") {\n        // Generate a grid that cannot be explained by any k\n        // For example, ones at opposite corners\n        grid[0][0] = 1;\n        grid[n - 1][m - 1] = 1;\n\n    } else if (type == \"singlek\") {\n        if (k <= 1) {\n            k = rnd.next(2, min(n, m) / 2); // Random k\n        }\n\n        vector<pair<int,int>> directions = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n\n        // Start from position (0, 0)\n        int i_cur = 0;\n        int j_cur = 0;\n        grid[i_cur][j_cur] = 1;\n\n        // Try to move in one direction\n        // Ensure that moving k units is within grid\n        int dir_idx = rnd.next(0, 3);\n        pair<int,int> dir = directions[dir_idx];\n        int dx = dir.first;\n        int dy = dir.second;\n\n        int i_new = i_cur + dx * k;\n        int j_new = j_cur + dy * k;\n\n        if (i_new >= 0 && i_new < n && j_new >= 0 && j_new < m) {\n            // Move is possible\n            vector<pair<int,int>> positions_to_mark;\n            for (int t = 1; t <= k; ++t) {\n                int i = i_cur + dx * t;\n                int j = j_cur + dy * t;\n                positions_to_mark.push_back({ i, j });\n            }\n\n            // Mark positions\n            for (auto pos : positions_to_mark) {\n                grid[pos.first][pos.second] = 1;\n            }\n        } else {\n            // Adjust k to fit within grid\n            // For simplicity, move down from (0, 0)\n            dx = 1;\n            dy = 0;\n            k = min(k, n - 1);\n            i_new = i_cur + dx * k;\n            j_new = j_cur + dy * k;\n\n            vector<pair<int,int>> positions_to_mark;\n            for (int t = 1; t <= k; ++t) {\n                int i = i_cur + dx * t;\n                int j = j_cur + dy * t;\n                positions_to_mark.push_back({ i, j });\n            }\n\n            // Mark positions\n            for (auto pos : positions_to_mark) {\n                grid[pos.first][pos.second] = 1;\n            }\n        }\n\n    } else if (type == \"edgecase\") {\n        // For example, a minimal grid with only one cell marked\n        grid[0][0] = 1;\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // optional k value\n\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    if (type == \"random\") {\n        if (k <= 1) {\n            // Random k between 2 and min(n, m)\n            k = rnd.next(2, min(n, m));\n        }\n\n        int i_cur = rnd.next(0, n - 1);\n        int j_cur = rnd.next(0, m - 1);\n        grid[i_cur][j_cur] = 1;\n\n        set<pair<pair<int,int>, pair<int,int>>> edges_crossed;\n\n        vector<pair<int,int>> directions = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n\n        int moves = 0;\n        while (true) {\n            // Shuffle directions\n            shuffle(directions.begin(), directions.end());\n\n            bool moved = false;\n            for (auto dir : directions) {\n                int dx = dir.first;\n                int dy = dir.second;\n\n                // Check if movement is possible\n                int i_new = i_cur + dx * (k);\n                int j_new = j_cur + dy * (k);\n\n                if (i_new < 0 || i_new >= n || j_new < 0 || j_new >= m) {\n                    continue; // Movement goes out of grid\n                }\n\n                // Prepare to collect edges and positions to be marked\n                vector<pair<int,int>> positions_to_mark;\n                vector<pair<pair<int,int>, pair<int,int>>> edges_to_add;\n\n                int i_prev = i_cur;\n                int j_prev = j_cur;\n\n                bool can_move = true;\n                for (int t = 1; t <= k; ++t) {\n                    int i = i_cur + dx * t;\n                    int j = j_cur + dy * t;\n\n                    positions_to_mark.push_back({ i, j });\n\n                    // Edge between i_prev, j_prev and i, j\n                    pair<pair<int,int>, pair<int,int>> edge = make_pair(\n                        min(make_pair(i_prev, j_prev), make_pair(i, j)),\n                        max(make_pair(i_prev, j_prev), make_pair(i, j))\n                    );\n                    if (edges_crossed.count(edge)) {\n                        can_move = false;\n                        break;\n                    } else {\n                        edges_to_add.push_back(edge);\n                    }\n\n                    i_prev = i;\n                    j_prev = j;\n                }\n\n                if (!can_move) {\n                    continue; // Try next direction\n                } else {\n                    // Move is successful\n                    for (auto pos : positions_to_mark) {\n                        grid[pos.first][pos.second] = 1;\n                    }\n                    for (auto edge : edges_to_add) {\n                        edges_crossed.insert(edge);\n                    }\n                    // Update current position\n                    i_cur = i_new;\n                    j_cur = j_new;\n                    moved = true;\n                    ++moves;\n                    break;\n                }\n            }\n            if (!moved) {\n                break; // No moves possible\n            }\n        }\n\n    } else if (type == \"full\") {\n        // All ones\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n\n    } else if (type == \"nosolution\") {\n        // Generate a grid that cannot be explained by any k\n        // For example, ones at opposite corners\n        grid[0][0] = 1;\n        grid[n - 1][m - 1] = 1;\n\n    } else if (type == \"singlek\") {\n        if (k <= 1) {\n            k = rnd.next(2, min(n, m) / 2); // Random k\n        }\n\n        vector<pair<int,int>> directions = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n\n        // Start from position (0, 0)\n        int i_cur = 0;\n        int j_cur = 0;\n        grid[i_cur][j_cur] = 1;\n\n        // Try to move in one direction\n        // Ensure that moving k units is within grid\n        int dir_idx = rnd.next(0, 3);\n        pair<int,int> dir = directions[dir_idx];\n        int dx = dir.first;\n        int dy = dir.second;\n\n        int i_new = i_cur + dx * k;\n        int j_new = j_cur + dy * k;\n\n        if (i_new >= 0 && i_new < n && j_new >= 0 && j_new < m) {\n            // Move is possible\n            vector<pair<int,int>> positions_to_mark;\n            for (int t = 1; t <= k; ++t) {\n                int i = i_cur + dx * t;\n                int j = j_cur + dy * t;\n                positions_to_mark.push_back({ i, j });\n            }\n\n            // Mark positions\n            for (auto pos : positions_to_mark) {\n                grid[pos.first][pos.second] = 1;\n            }\n        } else {\n            // Adjust k to fit within grid\n            // For simplicity, move down from (0, 0)\n            dx = 1;\n            dy = 0;\n            k = min(k, n - 1);\n            i_new = i_cur + dx * k;\n            j_new = j_cur + dy * k;\n\n            vector<pair<int,int>> positions_to_mark;\n            for (int t = 1; t <= k; ++t) {\n                int i = i_cur + dx * t;\n                int j = j_cur + dy * t;\n                positions_to_mark.push_back({ i, j });\n            }\n\n            // Mark positions\n            for (auto pos : positions_to_mark) {\n                grid[pos.first][pos.second] = 1;\n            }\n        }\n\n    } else if (type == \"edgecase\") {\n        // For example, a minimal grid with only one cell marked\n        grid[0][0] = 1;\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varying sizes\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 500 -m 500 -type random\n./gen -n 1000 -m 1000 -type random\n\n# Random test cases with specified k\n./gen -n 100 -m 100 -type random -k 2\n./gen -n 100 -m 100 -type random -k 10\n./gen -n 500 -m 500 -type random -k 5\n\n# Full grid of ones\n./gen -n 3 -m 3 -type full\n./gen -n 10 -m 10 -type full\n./gen -n 100 -m 100 -type full\n\n# Test cases with no possible solution\n./gen -n 5 -m 5 -type nosolution\n./gen -n 100 -m 100 -type nosolution\n\n# Test cases with only a single k value possible\n./gen -n 10 -m 10 -type singlek -k 2\n./gen -n 20 -m 20 -type singlek -k 5\n./gen -n 50 -m 50 -type singlek -k 10\n\n# Edge case test cases\n./gen -n 1 -m 1 -type edgecase\n./gen -n 2 -m 2 -type edgecase\n./gen -n 3 -m 3 -type edgecase\n\n# Random test cases with maximum size\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type random -k 2\n./gen -n 1000 -m 1000 -type random -k 999\n\n# Mixed test cases\n./gen -n 100 -m 200 -type random\n./gen -n 200 -m 100 -type random\n./gen -n 500 -m 300 -type random\n./gen -n 300 -m 500 -type random\n\n# Another nosolution test case\n./gen -n 2 -m 2 -type nosolution\n\n# Single cell marked\n./gen -n 100 -m 100 -type edgecase\n\n# Random test cases with small sizes\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type random -k 3\n\n# Test cases with k set to maximum possible\n./gen -n 1000 -m 1000 -type singlek -k 999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:51.439893",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "359/A",
      "title": "A. Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains exactly two integers n, m (3 ≤ n, m ≤ 50).Next n lines contain the description of the table cells. Specifically, the i-th line contains m space-separated integers ai1, ai2, ..., aim. If aij equals zero, then cell (i, j) isn't good. Otherwise aij equals one. It is guaranteed that at least one cell is good. It is guaranteed that no good cell is a corner.",
      "output_spec": "OutputPrint a single number — the minimum number of operations Simon needs to carry out his idea.",
      "sample_tests": "ExamplesInputCopy3 30 0 00 1 00 0 0OutputCopy4InputCopy4 30 0 00 0 11 0 00 0 0OutputCopy2",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains exactly two integers n, m (3 ≤ n, m ≤ 50).Next n lines contain the description of the table cells. Specifically, the i-th line contains m space-separated integers ai1, ai2, ..., aim. If aij equals zero, then cell (i, j) isn't good. Otherwise aij equals one. It is guaranteed that at least one cell is good. It is guaranteed that no good cell is a corner.\n\nOutputPrint a single number — the minimum number of operations Simon needs to carry out his idea.\n\nInputCopy3 30 0 00 1 00 0 0OutputCopy4InputCopy4 30 0 00 0 11 0 00 0 0OutputCopy2\n\nInputCopy3 30 0 00 1 00 0 0\n\nOutputCopy4\n\nInputCopy4 30 0 00 0 11 0 00 0 0\n\nOutputCopy2\n\nNoteIn the first sample, the sequence of operations can be like this:    For the first time you need to choose cell (2, 2) and corner (1, 1).  For the second time you need to choose cell (2, 2) and corner (3, 3).  For the third time you need to choose cell (2, 2) and corner (3, 1).  For the fourth time you need to choose cell (2, 2) and corner (1, 3). In the second sample the sequence of operations can be like this:    For the first time you need to choose cell (3, 1) and corner (4, 3).  For the second time you need to choose cell (2, 3) and corner (1, 1).",
      "solutions": [
        {
          "title": "Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on November 2 at 12:00 MSK) you are lucky to participate in Codeforces Round #209 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition. Pay attention to the round begining time!Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) and Ilya Los (IlyaLos) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2500, 2500.UPD2: Congratulations to winners! cptbtptp FancyCoder Oyk E.B. orzkbc UPD: EditorialGood Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 653
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "I'm not good in English. So, if you find an mistake in editorial, please, send me a private message.359A - TableIf there are some good cell, which is located in the first row or in the first column, the answer is two. Similarly, if If there are some good cell, which is located in the last row or in the last column, the answer is two. Otherwise, the answer is four.Авторское решение: 4968279359B - PermutationThe answer is a slightly modified permutation 1, 2, ..., 2n. Let's reverse numbers 2i - 1 and 2i for each 1 ≤ i ≤ k. It's not hard to understand, that this permutation is good.Авторское решение: 4968385359C - Prime NumberObviously, the answer is xv. Let sum = a1 + a2 + ... + an. Also let si = sum - ai (the array of degrees). After that let's find value v by the following algorithm: Let's consider a sequence of degrees as decreasing sequence. Now we will perform the following operation until it's possible to perfom it. Take the minimum degree v from the array of degrees and calculate the number of elements cnt, which have the same degree. If cnt multiples of x, then replace all cnt elements by cnt / x elements of the form v + 1. Since the sequence of degrees is a decreasing sequence, we can simply assign them to the end. If cnt is not a multiple of x, then we found the required value v. Also you need to check, that v is not greater then sum. Otherwise, v will be equals to sum.Авторское решение: 4968346359D - Pair of NumbersQuite simple note: if the pair (l, r) satisfies the condition 1 from the statements, then min(l, r) = GCD(l, r), where min(l, r) is smallest number ai from the segment (l, r) and GCD(l, r) is a GCD of all numbers from the segment (l, r). Calculate some data structure that will allow us to respond quickly to requests GCD(l, r) and min(l, r). For example, you can use Sparce Table. Solutuions, that uses segment tree, is too slow. So I think, you should use Sparce Table. So, now our task quite simple. Let's use binary search to find greatest value of r - l: lf = 0; //left boundary of binary search\nrg = n; //right boundary of binary search\nwhile (rg - lf > 1) {\n int mid = (lf + rg) / 2;\n if (ok(mid)) //ok(mid)\n lf = mid;\n else\n rg = mid;\n}ok(mid) is the function, that determines, is there some segment where min(l, r) = GCD(l, r) and mid = r - l (mid — is fixed value by binary search). If there is some good segment, you should update boundaries of binary search correctly. After that, it's very simple to restore answer. Some information about Sparce TableАвторское решение: 4968587359E - NeatnessYou should write recursive function, that will turn on the light in all rooms, where it's possible. Also this function will visit all rooms, which it may visit. Let this function is called paint(x, y), where x, y is the current room. Paint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current direction (rule 3 from the statement), and the room (nx, ny) (current neighbor) has not yet visited, we will call our recursive function from (nx, ny). Also, we will turn on the light in all rooms, were we were. If some room is not visited by paint(x, y) and lights is on in this room, the answer is \"NO\". Otherwise, the answer is \"YES\". After that let's calculate value dist(x, y) by using bfs. dist(x, y) — is a minimal possible distance from the start to the current position (x, y). It's possible to use in our bfs only rooms, where lights is on. After that we will write the same function repaint(x, y). Repaint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current neighbor (nx, ny) and dist(nx, ny) > dist(x, y) ((x, y) — current room), let's call our recursive function from (nx, ny).After that we will come back to room (x, y). If there is no such neigbor (nx, ny), turn off the light in the room (x, y). Also you should look at my solution for more details.Авторское решение: 4968657",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 359\\s*A"
          },
          "content_length": 3922
        }
      ],
      "code_examples": [
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 1",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 2",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 50, \"m\");\n    inf.readEoln();\n\n    bool has_good_cell = false;\n    for (int i = 1; i <= n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n        for (int j = 1; j <= m; j++) {\n            int aij = row[j - 1];\n            if (aij == 1) {\n                has_good_cell = true;\n                bool is_corner = ((i == 1 && j == 1) || (i == 1 && j == m) ||\n                                  (i == n && j == 1) || (i == n && j == m));\n                ensuref(!is_corner, \"Good cell (%d, %d) cannot be at corner\", i, j);\n            }\n        }\n    }\n    ensuref(has_good_cell, \"At least one cell must be good\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 50, \"m\");\n    inf.readEoln();\n\n    bool has_good_cell = false;\n    for (int i = 1; i <= n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n        for (int j = 1; j <= m; j++) {\n            int aij = row[j - 1];\n            if (aij == 1) {\n                has_good_cell = true;\n                bool is_corner = ((i == 1 && j == 1) || (i == 1 && j == m) ||\n                                  (i == n && j == 1) || (i == n && j == m));\n                ensuref(!is_corner, \"Good cell (%d, %d) cannot be at corner\", i, j);\n            }\n        }\n    }\n    ensuref(has_good_cell, \"At least one cell must be good\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 50, \"m\");\n    inf.readEoln();\n\n    bool has_good_cell = false;\n    for (int i = 1; i <= n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n        for (int j = 1; j <= m; j++) {\n            int aij = row[j - 1];\n            if (aij == 1) {\n                has_good_cell = true;\n                bool is_corner = ((i == 1 && j == 1) || (i == 1 && j == m) ||\n                                  (i == n && j == 1) || (i == n && j == m));\n                ensuref(!is_corner, \"Good cell (%d, %d) cannot be at corner\", i, j);\n            }\n        }\n    }\n    ensuref(has_good_cell, \"At least one cell must be good\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    // First, ensure that n and m satisfy constraints\n    ensure(n >= 3 && n <= 50);\n    ensure(m >= 3 && m <= 50);\n\n    if (type == \"single\") {\n        // Place a single good cell\n        // Ensure it's not in a corner\n        int x = n / 2;\n        int y = m / 2;\n        if ((x == 0 && (y == 0 || y == m -1)) || (x == n - 1 && (y == 0 || y == m -1))) {\n            // It is a corner, adjust\n            x = 1;\n            y = 1;\n        }\n        grid[x][y] = 1;\n    } else if (type == \"all\") {\n        // All cells are good, except corners\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = 1;\n        // Set corners to 0\n        grid[0][0] = 0;\n        grid[0][m-1] = 0;\n        grid[n-1][0] = 0;\n        grid[n-1][m-1] = 0;\n    } else if (type == \"line\") {\n        // Good cells form a line\n        // Choose a row (excluding first and last rows)\n        int row = rnd.next(1, n - 2); // Exclude first and last row\n        for (int j = 0; j < m; ++j) {\n            grid[row][j] = 1;\n        }\n        // Ensure no corners are good\n        grid[row][0] = 0;\n        grid[row][m-1] = 0;\n    } else if (type == \"column\") {\n        // Good cells form a column\n        int col = rnd.next(1, m - 2); // Exclude first and last column\n        for (int i = 0; i < n; ++i) {\n            grid[i][col] = 1;\n        }\n        grid[0][col] = 0;\n        grid[n-1][col] = 0;\n    } else if (type == \"diagonal\") {\n        // Good cells along the main diagonal\n        int len = min(n, m);\n        for (int i = 0; i < len; ++i) {\n            if ((i == 0 && i == 0) || (i == n - 1 && i == m -1)) {\n                // skip corners\n                continue;\n            }\n            grid[i][i] = 1;\n        }\n    } else if (type == \"antidiagonal\") {\n        // Good cells along the anti-diagonal\n        int len = min(n, m);\n        for (int i = 0; i < len; ++i) {\n            int x = i;\n            int y = m - 1 - i;\n            if ((x == 0 && y == m -1) || (x == n - 1 && y == 0)) {\n                // skip corners\n                continue;\n            }\n            grid[x][y] = 1;\n        }\n    } else if (type == \"edges\") {\n        // Good cells along edges, excluding corners\n        for (int j = 1; j < m - 1; ++j) {\n            grid[0][j] = 1; // Top edge\n            grid[n -1][j] = 1; // Bottom edge\n        }\n        for (int i = 1; i < n - 1; ++i) {\n            grid[i][0] = 1; // Left edge\n            grid[i][m -1] = 1; // Right edge\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0) {\n                    if (!((i==0 && j==0) || (i==0 && j==m-1) || (i==n-1 && j==0) || (i==n-1 && j==m-1))) {\n                        grid[i][j] = 1;\n                    }\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly place good cells\n        int total_cells = n * m;\n        int num_good = rnd.next(1, total_cells - 4); // At least 1, excluding corners\n        vector<pair<int,int>> positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (!((i==0 && j==0) || (i==0 && j==m-1) || (i==n-1 && j==0) || (i==n-1 && j==m-1))) {\n                    positions.push_back({i, j});\n                }\n        shuffle(positions.begin(), positions.end());\n        for (int k = 0; k < num_good; ++k) {\n            grid[positions[k].first][positions[k].second] = 1;\n        }\n    } else {\n        // Default: error or random\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure at least one good cell\n    int num_good_cells = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            num_good_cells += grid[i][j];\n    ensure(num_good_cells >= 1);\n\n    // Ensure no good cell is in the corners\n    ensure(grid[0][0] == 0);\n    ensure(grid[0][m-1] == 0);\n    ensure(grid[n-1][0] == 0);\n    ensure(grid[n-1][m-1] == 0);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j+1 != m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    // First, ensure that n and m satisfy constraints\n    ensure(n >= 3 && n <= 50);\n    ensure(m >= 3 && m <= 50);\n\n    if (type == \"single\") {\n        // Place a single good cell\n        // Ensure it's not in a corner\n        int x = n / 2;\n        int y = m / 2;\n        if ((x == 0 && (y == 0 || y == m -1)) || (x == n - 1 && (y == 0 || y == m -1))) {\n            // It is a corner, adjust\n            x = 1;\n            y = 1;\n        }\n        grid[x][y] = 1;\n    } else if (type == \"all\") {\n        // All cells are good, except corners\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = 1;\n        // Set corners to 0\n        grid[0][0] = 0;\n        grid[0][m-1] = 0;\n        grid[n-1][0] = 0;\n        grid[n-1][m-1] = 0;\n    } else if (type == \"line\") {\n        // Good cells form a line\n        // Choose a row (excluding first and last rows)\n        int row = rnd.next(1, n - 2); // Exclude first and last row\n        for (int j = 0; j < m; ++j) {\n            grid[row][j] = 1;\n        }\n        // Ensure no corners are good\n        grid[row][0] = 0;\n        grid[row][m-1] = 0;\n    } else if (type == \"column\") {\n        // Good cells form a column\n        int col = rnd.next(1, m - 2); // Exclude first and last column\n        for (int i = 0; i < n; ++i) {\n            grid[i][col] = 1;\n        }\n        grid[0][col] = 0;\n        grid[n-1][col] = 0;\n    } else if (type == \"diagonal\") {\n        // Good cells along the main diagonal\n        int len = min(n, m);\n        for (int i = 0; i < len; ++i) {\n            if ((i == 0 && i == 0) || (i == n - 1 && i == m -1)) {\n                // skip corners\n                continue;\n            }\n            grid[i][i] = 1;\n        }\n    } else if (type == \"antidiagonal\") {\n        // Good cells along the anti-diagonal\n        int len = min(n, m);\n        for (int i = 0; i < len; ++i) {\n            int x = i;\n            int y = m - 1 - i;\n            if ((x == 0 && y == m -1) || (x == n - 1 && y == 0)) {\n                // skip corners\n                continue;\n            }\n            grid[x][y] = 1;\n        }\n    } else if (type == \"edges\") {\n        // Good cells along edges, excluding corners\n        for (int j = 1; j < m - 1; ++j) {\n            grid[0][j] = 1; // Top edge\n            grid[n -1][j] = 1; // Bottom edge\n        }\n        for (int i = 1; i < n - 1; ++i) {\n            grid[i][0] = 1; // Left edge\n            grid[i][m -1] = 1; // Right edge\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0) {\n                    if (!((i==0 && j==0) || (i==0 && j==m-1) || (i==n-1 && j==0) || (i==n-1 && j==m-1))) {\n                        grid[i][j] = 1;\n                    }\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly place good cells\n        int total_cells = n * m;\n        int num_good = rnd.next(1, total_cells - 4); // At least 1, excluding corners\n        vector<pair<int,int>> positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (!((i==0 && j==0) || (i==0 && j==m-1) || (i==n-1 && j==0) || (i==n-1 && j==m-1))) {\n                    positions.push_back({i, j});\n                }\n        shuffle(positions.begin(), positions.end());\n        for (int k = 0; k < num_good; ++k) {\n            grid[positions[k].first][positions[k].second] = 1;\n        }\n    } else {\n        // Default: error or random\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure at least one good cell\n    int num_good_cells = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            num_good_cells += grid[i][j];\n    ensure(num_good_cells >= 1);\n\n    // Ensure no good cell is in the corners\n    ensure(grid[0][0] == 0);\n    ensure(grid[0][m-1] == 0);\n    ensure(grid[n-1][0] == 0);\n    ensure(grid[n-1][m-1] == 0);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j+1 != m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -type single\n./gen -n 3 -m 3 -type all\n./gen -n 3 -m 3 -type line\n./gen -n 3 -m 3 -type column\n./gen -n 3 -m 3 -type diagonal\n./gen -n 3 -m 3 -type antidiagonal\n./gen -n 3 -m 3 -type edges\n./gen -n 3 -m 3 -type checkerboard\n./gen -n 3 -m 3 -type random\n\n./gen -n 10 -m 10 -type single\n./gen -n 10 -m 10 -type all\n./gen -n 10 -m 10 -type line\n./gen -n 10 -m 10 -type column\n./gen -n 10 -m 10 -type diagonal\n./gen -n 10 -m 10 -type antidiagonal\n./gen -n 10 -m 10 -type edges\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type random\n\n./gen -n 50 -m 50 -type single\n./gen -n 50 -m 50 -type all\n./gen -n 50 -m 50 -type line\n./gen -n 50 -m 50 -type column\n./gen -n 50 -m 50 -type diagonal\n./gen -n 50 -m 50 -type antidiagonal\n./gen -n 50 -m 50 -type edges\n./gen -n 50 -m 50 -type checkerboard\n./gen -n 50 -m 50 -type random\n\n./gen -n 3 -m 50 -type single\n./gen -n 50 -m 3 -type line\n./gen -n 25 -m 25 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:53.410186",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "359/B",
      "title": "B. Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 50000, 0 ≤ 2k ≤ n).",
      "output_spec": "OutputPrint 2n integers a1, a2, ..., a2n — the required permutation a. It is guaranteed that the solution exists. If there are multiple solutions, you can print any of them.",
      "sample_tests": "ExamplesInputCopy1 0OutputCopy1 2InputCopy2 1OutputCopy3 2 1 4InputCopy4 0OutputCopy2 7 4 6 1 3 5 8",
      "description": "B. Permutation\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 50000, 0 ≤ 2k ≤ n).\n\nOutputPrint 2n integers a1, a2, ..., a2n — the required permutation a. It is guaranteed that the solution exists. If there are multiple solutions, you can print any of them.\n\nInputCopy1 0OutputCopy1 2InputCopy2 1OutputCopy3 2 1 4InputCopy4 0OutputCopy2 7 4 6 1 3 5 8\n\nInputCopy1 0\n\nOutputCopy1 2\n\nInputCopy2 1\n\nOutputCopy3 2 1 4\n\nInputCopy4 0\n\nOutputCopy2 7 4 6 1 3 5 8\n\nNoteRecord |x| represents the absolute value of number x. In the first sample |1 - 2| - |1 - 2| = 0.In the second sample |3 - 2| + |1 - 4| - |3 - 2 + 1 - 4| = 1 + 3 - 2 = 2.In the third sample |2 - 7| + |4 - 6| + |1 - 3| + |5 - 8| - |2 - 7 + 4 - 6 + 1 - 3 + 5 - 8| = 12 - 12 = 0.",
      "solutions": [
        {
          "title": "Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on November 2 at 12:00 MSK) you are lucky to participate in Codeforces Round #209 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition. Pay attention to the round begining time!Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) and Ilya Los (IlyaLos) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2500, 2500.UPD2: Congratulations to winners! cptbtptp FancyCoder Oyk E.B. orzkbc UPD: EditorialGood Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 653
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "I'm not good in English. So, if you find an mistake in editorial, please, send me a private message.359A - TableIf there are some good cell, which is located in the first row or in the first column, the answer is two. Similarly, if If there are some good cell, which is located in the last row or in the last column, the answer is two. Otherwise, the answer is four.Авторское решение: 4968279359B - PermutationThe answer is a slightly modified permutation 1, 2, ..., 2n. Let's reverse numbers 2i - 1 and 2i for each 1 ≤ i ≤ k. It's not hard to understand, that this permutation is good.Авторское решение: 4968385359C - Prime NumberObviously, the answer is xv. Let sum = a1 + a2 + ... + an. Also let si = sum - ai (the array of degrees). After that let's find value v by the following algorithm: Let's consider a sequence of degrees as decreasing sequence. Now we will perform the following operation until it's possible to perfom it. Take the minimum degree v from the array of degrees and calculate the number of elements cnt, which have the same degree. If cnt multiples of x, then replace all cnt elements by cnt / x elements of the form v + 1. Since the sequence of degrees is a decreasing sequence, we can simply assign them to the end. If cnt is not a multiple of x, then we found the required value v. Also you need to check, that v is not greater then sum. Otherwise, v will be equals to sum.Авторское решение: 4968346359D - Pair of NumbersQuite simple note: if the pair (l, r) satisfies the condition 1 from the statements, then min(l, r) = GCD(l, r), where min(l, r) is smallest number ai from the segment (l, r) and GCD(l, r) is a GCD of all numbers from the segment (l, r). Calculate some data structure that will allow us to respond quickly to requests GCD(l, r) and min(l, r). For example, you can use Sparce Table. Solutuions, that uses segment tree, is too slow. So I think, you should use Sparce Table. So, now our task quite simple. Let's use binary search to find greatest value of r - l: lf = 0; //left boundary of binary search\nrg = n; //right boundary of binary search\nwhile (rg - lf > 1) {\n int mid = (lf + rg) / 2;\n if (ok(mid)) //ok(mid)\n lf = mid;\n else\n rg = mid;\n}ok(mid) is the function, that determines, is there some segment where min(l, r) = GCD(l, r) and mid = r - l (mid — is fixed value by binary search). If there is some good segment, you should update boundaries of binary search correctly. After that, it's very simple to restore answer. Some information about Sparce TableАвторское решение: 4968587359E - NeatnessYou should write recursive function, that will turn on the light in all rooms, where it's possible. Also this function will visit all rooms, which it may visit. Let this function is called paint(x, y), where x, y is the current room. Paint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current direction (rule 3 from the statement), and the room (nx, ny) (current neighbor) has not yet visited, we will call our recursive function from (nx, ny). Also, we will turn on the light in all rooms, were we were. If some room is not visited by paint(x, y) and lights is on in this room, the answer is \"NO\". Otherwise, the answer is \"YES\". After that let's calculate value dist(x, y) by using bfs. dist(x, y) — is a minimal possible distance from the start to the current position (x, y). It's possible to use in our bfs only rooms, where lights is on. After that we will write the same function repaint(x, y). Repaint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current neighbor (nx, ny) and dist(nx, ny) > dist(x, y) ((x, y) — current room), let's call our recursive function from (nx, ny).After that we will come back to room (x, y). If there is no such neigbor (nx, ny), turn off the light in the room (x, y). Also you should look at my solution for more details.Авторское решение: 4968657",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 359\\s*B"
          },
          "content_length": 3922
        }
      ],
      "code_examples": [
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 1",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 2",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n\n    ensuref(2 * k <= n, \"Value of k (%d) is too large: 2k (%d) > n (%d)\", k, 2 * k, n);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n\n    ensuref(2 * k <= n, \"Value of k (%d) is too large: 2k (%d) > n (%d)\", k, 2 * k, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n\n    ensuref(2 * k <= n, \"Value of k (%d) is too large: 2k (%d) > n (%d)\", k, 2 * k, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and k from input file.\n    int n = inf.readInt(1, 50000, \"n\");\n    int k = inf.readInt(0, n / 2, \"k\");\n\n    // Read 2n integers from contestant's output\n    int totalNumbers = 2 * n;\n    vector<int> a = ouf.readInts(totalNumbers, 1, totalNumbers, \"a\");\n\n    // Check that a is a permutation of numbers from 1 to 2n\n    vector<bool> used(totalNumbers + 1, false); // Indexing from 1 to 2n\n    for (int i = 0; i < totalNumbers; i++) {\n        int num = a[i];\n        if (used[num]) {\n            quitf(_wa, \"number %d occurs multiple times\", num);\n        }\n        used[num] = true;\n    }\n\n    // Compute S\n    long long sum_abs_diffs = 0;\n    long long sum_diffs = 0;\n    for (int i = 0; i < n; i++) {\n        int idx1 = 2 * i;\n        int idx2 = 2 * i + 1;\n        int diff = a[idx1] - a[idx2];\n        sum_abs_diffs += abs(diff);\n        sum_diffs += diff;\n    }\n    long long S = sum_abs_diffs - abs(sum_diffs);\n\n    // Check whether S == 2k\n    if (S != 2LL * k) {\n        quitf(_wa, \"S expected %lld, found %lld\", 2LL * k, S);\n    }\n\n    quitf(_ok, \"answer is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for producing input to the given problem.\n\n  Usage:\n    ./gen -n <int> -k <int>\n\n  -n: The value of n (1 <= n <= 50000). If not provided, defaults to 10.\n  -k: The value of k (0 <= 2k <= n). If not provided, it is chosen randomly in [0, n/2].\n  \n  This program outputs exactly one test case:\n    The first (and only) line: \"n k\"\n  \n  Constraints are guaranteed by adjusting k if 2k > n after a random pick.\n  No random seed is set inside this generator.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int k = opt<int>(\"k\", -1);\n\n    // If k was not given, pick a random k in [0, floor(n/2)].\n    if (k == -1) {\n        k = rnd.next(n / 2 + 1); \n    }\n    // Ensure 2k <= n\n    if (2 * k > n) {\n        k = n / 2; // integer division truncates\n    }\n\n    // Output the test input\n    cout << n << \" \" << k << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for producing input to the given problem.\n\n  Usage:\n    ./gen -n <int> -k <int>\n\n  -n: The value of n (1 <= n <= 50000). If not provided, defaults to 10.\n  -k: The value of k (0 <= 2k <= n). If not provided, it is chosen randomly in [0, n/2].\n  \n  This program outputs exactly one test case:\n    The first (and only) line: \"n k\"\n  \n  Constraints are guaranteed by adjusting k if 2k > n after a random pick.\n  No random seed is set inside this generator.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int k = opt<int>(\"k\", -1);\n\n    // If k was not given, pick a random k in [0, floor(n/2)].\n    if (k == -1) {\n        k = rnd.next(n / 2 + 1); \n    }\n    // Ensure 2k <= n\n    if (2 * k > n) {\n        k = n / 2; // integer division truncates\n    }\n\n    // Output the test input\n    cout << n << \" \" << k << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0\n./gen -n 2 -k 0\n./gen -n 2 -k 1\n./gen -n 3 -k 0\n./gen -n 3 -k 1\n./gen -n 5\n./gen -n 6 -k 3\n./gen -n 10 -k 0\n./gen -n 10 -k 5\n./gen -n 10\n./gen -n 12 -k 6\n./gen -n 99\n./gen -n 100 -k 50\n./gen -n 1000 -k 0\n./gen -n 1000\n./gen -n 1234\n./gen -n 10000 -k 0\n./gen -n 10000\n./gen -n 50000 -k 0\n./gen -n 50000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:55.332237",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "359/C",
      "title": "C. Prime Number",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two positive integers n and x (1 ≤ n ≤ 105, 2 ≤ x ≤ 109) — the size of the array and the prime number.The second line contains n space-separated integers a1, a2, ..., an (0 ≤ a1 ≤ a2 ≤ ... ≤ an ≤ 109).",
      "output_spec": "OutputPrint a single number — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy2 22 2OutputCopy8InputCopy3 31 2 3OutputCopy27InputCopy2 229 29OutputCopy73741817InputCopy4 50 0 0 0OutputCopy1",
      "description": "C. Prime Number\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two positive integers n and x (1 ≤ n ≤ 105, 2 ≤ x ≤ 109) — the size of the array and the prime number.The second line contains n space-separated integers a1, a2, ..., an (0 ≤ a1 ≤ a2 ≤ ... ≤ an ≤ 109).\n\nOutputPrint a single number — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy2 22 2OutputCopy8InputCopy3 31 2 3OutputCopy27InputCopy2 229 29OutputCopy73741817InputCopy4 50 0 0 0OutputCopy1\n\nInputCopy2 22 2\n\nOutputCopy8\n\nInputCopy3 31 2 3\n\nOutputCopy27\n\nInputCopy2 229 29\n\nOutputCopy73741817\n\nInputCopy4 50 0 0 0\n\nOutputCopy1\n\nNoteIn the first sample . Thus, the answer to the problem is 8.In the second sample, . The answer to the problem is 27, as 351 = 13·27, 729 = 27·27.In the third sample the answer to the problem is 1073741824 mod 1000000007 = 73741817.In the fourth sample . Thus, the answer to the problem is 1.",
      "solutions": [
        {
          "title": "Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on November 2 at 12:00 MSK) you are lucky to participate in Codeforces Round #209 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition. Pay attention to the round begining time!Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) and Ilya Los (IlyaLos) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2500, 2500.UPD2: Congratulations to winners! cptbtptp FancyCoder Oyk E.B. orzkbc UPD: EditorialGood Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 653
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "I'm not good in English. So, if you find an mistake in editorial, please, send me a private message.359A - TableIf there are some good cell, which is located in the first row or in the first column, the answer is two. Similarly, if If there are some good cell, which is located in the last row or in the last column, the answer is two. Otherwise, the answer is four.Авторское решение: 4968279359B - PermutationThe answer is a slightly modified permutation 1, 2, ..., 2n. Let's reverse numbers 2i - 1 and 2i for each 1 ≤ i ≤ k. It's not hard to understand, that this permutation is good.Авторское решение: 4968385359C - Prime NumberObviously, the answer is xv. Let sum = a1 + a2 + ... + an. Also let si = sum - ai (the array of degrees). After that let's find value v by the following algorithm: Let's consider a sequence of degrees as decreasing sequence. Now we will perform the following operation until it's possible to perfom it. Take the minimum degree v from the array of degrees and calculate the number of elements cnt, which have the same degree. If cnt multiples of x, then replace all cnt elements by cnt / x elements of the form v + 1. Since the sequence of degrees is a decreasing sequence, we can simply assign them to the end. If cnt is not a multiple of x, then we found the required value v. Also you need to check, that v is not greater then sum. Otherwise, v will be equals to sum.Авторское решение: 4968346359D - Pair of NumbersQuite simple note: if the pair (l, r) satisfies the condition 1 from the statements, then min(l, r) = GCD(l, r), where min(l, r) is smallest number ai from the segment (l, r) and GCD(l, r) is a GCD of all numbers from the segment (l, r). Calculate some data structure that will allow us to respond quickly to requests GCD(l, r) and min(l, r). For example, you can use Sparce Table. Solutuions, that uses segment tree, is too slow. So I think, you should use Sparce Table. So, now our task quite simple. Let's use binary search to find greatest value of r - l: lf = 0; //left boundary of binary search\nrg = n; //right boundary of binary search\nwhile (rg - lf > 1) {\n int mid = (lf + rg) / 2;\n if (ok(mid)) //ok(mid)\n lf = mid;\n else\n rg = mid;\n}ok(mid) is the function, that determines, is there some segment where min(l, r) = GCD(l, r) and mid = r - l (mid — is fixed value by binary search). If there is some good segment, you should update boundaries of binary search correctly. After that, it's very simple to restore answer. Some information about Sparce TableАвторское решение: 4968587359E - NeatnessYou should write recursive function, that will turn on the light in all rooms, where it's possible. Also this function will visit all rooms, which it may visit. Let this function is called paint(x, y), where x, y is the current room. Paint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current direction (rule 3 from the statement), and the room (nx, ny) (current neighbor) has not yet visited, we will call our recursive function from (nx, ny). Also, we will turn on the light in all rooms, were we were. If some room is not visited by paint(x, y) and lights is on in this room, the answer is \"NO\". Otherwise, the answer is \"YES\". After that let's calculate value dist(x, y) by using bfs. dist(x, y) — is a minimal possible distance from the start to the current position (x, y). It's possible to use in our bfs only rooms, where lights is on. After that we will write the same function repaint(x, y). Repaint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current neighbor (nx, ny) and dist(nx, ny) > dist(x, y) ((x, y) — current room), let's call our recursive function from (nx, ny).After that we will come back to room (x, y). If there is no such neigbor (nx, ny), turn off the light in the room (x, y). Also you should look at my solution for more details.Авторское решение: 4968657",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 359\\s*C"
          },
          "content_length": 3922
        }
      ],
      "code_examples": [
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 1",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 2",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool isPrime(int x) {\n    if (x <= 1) return false;\n    if (x == 2 || x == 3) return true;\n    if (x%2 == 0 || x%3 == 0) return false;\n    for (int i = 5; (long long)i * i <= x; i += 6) {\n        if (x % i == 0 || x % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(2, 1000000000, \"x\");\n    inf.readEoln();\n\n    ensuref(isPrime(x), \"x=%d is not a prime number\", x);\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    ensuref(is_sorted(a.begin(), a.end()), \"Array 'a' must be sorted in non-decreasing order\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool isPrime(int x) {\n    if (x <= 1) return false;\n    if (x == 2 || x == 3) return true;\n    if (x%2 == 0 || x%3 == 0) return false;\n    for (int i = 5; (long long)i * i <= x; i += 6) {\n        if (x % i == 0 || x % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(2, 1000000000, \"x\");\n    inf.readEoln();\n\n    ensuref(isPrime(x), \"x=%d is not a prime number\", x);\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    ensuref(is_sorted(a.begin(), a.end()), \"Array 'a' must be sorted in non-decreasing order\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool isPrime(int x) {\n    if (x <= 1) return false;\n    if (x == 2 || x == 3) return true;\n    if (x%2 == 0 || x%3 == 0) return false;\n    for (int i = 5; (long long)i * i <= x; i += 6) {\n        if (x % i == 0 || x % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(2, 1000000000, \"x\");\n    inf.readEoln();\n\n    ensuref(isPrime(x), \"x=%d is not a prime number\", x);\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    ensuref(is_sorted(a.begin(), a.end()), \"Array 'a' must be sorted in non-decreasing order\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_A = 1000000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"all_zero\") {\n        a.assign(n, 0);\n    } else if (type == \"all_max\") {\n        a.assign(n, MAX_A);\n    } else if (type == \"increasing\") {\n        if (n == 1) {\n            a.assign(1, rnd.next(0, MAX_A));\n        } else {\n            int step = MAX_A / (n - 1);\n            a.resize(n);\n            for (int i = 0; i < n; ++i)\n                a[i] = i * step;\n        }\n    } else if (type == \"almost_equal\") {\n        int base = rnd.next(0, MAX_A);\n        a.assign(n, base);\n        if (n > 1) {\n            int idx = rnd.next(0, n - 1);\n            int delta = rnd.next(0, MAX_A);\n            a[idx] = delta;\n            sort(a.begin(), a.end());\n        }\n    } else if (type == \"single\") {\n        n = 1;\n        a.assign(1, rnd.next(0, MAX_A));\n    } else if (type == \"max_nmax_xmax_a\") {\n        n = 100000;\n        x = 999999937; // largest prime less than 1e9\n        a.assign(n, MAX_A);\n    } else if (type == \"random\") {\n        a.resize(n);\n        a[0] = rnd.next(0, MAX_A);\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(a[i - 1], MAX_A);\n        }\n    } else {\n        // default is random\n        a.resize(n);\n        a[0] = rnd.next(0, MAX_A);\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next(a[i - 1], MAX_A);\n    }\n\n    printf(\"%d %d\\n\", n, x);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_A = 1000000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"all_zero\") {\n        a.assign(n, 0);\n    } else if (type == \"all_max\") {\n        a.assign(n, MAX_A);\n    } else if (type == \"increasing\") {\n        if (n == 1) {\n            a.assign(1, rnd.next(0, MAX_A));\n        } else {\n            int step = MAX_A / (n - 1);\n            a.resize(n);\n            for (int i = 0; i < n; ++i)\n                a[i] = i * step;\n        }\n    } else if (type == \"almost_equal\") {\n        int base = rnd.next(0, MAX_A);\n        a.assign(n, base);\n        if (n > 1) {\n            int idx = rnd.next(0, n - 1);\n            int delta = rnd.next(0, MAX_A);\n            a[idx] = delta;\n            sort(a.begin(), a.end());\n        }\n    } else if (type == \"single\") {\n        n = 1;\n        a.assign(1, rnd.next(0, MAX_A));\n    } else if (type == \"max_nmax_xmax_a\") {\n        n = 100000;\n        x = 999999937; // largest prime less than 1e9\n        a.assign(n, MAX_A);\n    } else if (type == \"random\") {\n        a.resize(n);\n        a[0] = rnd.next(0, MAX_A);\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(a[i - 1], MAX_A);\n        }\n    } else {\n        // default is random\n        a.resize(n);\n        a[0] = rnd.next(0, MAX_A);\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next(a[i - 1], MAX_A);\n    }\n\n    printf(\"%d %d\\n\", n, x);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -x 2 -type single\n./gen -n 1 -x 999999937 -type all_max\n./gen -n 5 -x 3 -type all_zero\n./gen -n 100000 -x 3 -type all_zero\n./gen -n 100000 -x 999999937 -type all_max\n./gen -n 1000 -x 99991 -type increasing\n./gen -n 5000 -x 7 -type almost_equal\n./gen -n 100000 -x 999999937 -type random\n./gen -n 100000 -x 2 -type random\n./gen -n 50000 -x 99991 -type random\n./gen -n 100000 -x 999999937 -type all_zero\n./gen -n 100000 -x 2 -type all_max\n./gen -n 100000 -x 999999937 -type increasing\n./gen -n 100 -x 5 -type single\n./gen -n 100 -x 999999937 -type single\n./gen -n 100000 -x 3 -type almost_equal\n./gen -n 1 -x 2 -type random\n./gen -n 5 -x 5 -type random\n./gen -n 10 -x 10007 -type almost_equal\n./gen -n 100000 -x 999999937 -type max_nmax_xmax_a\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:56.932113",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "359/D",
      "title": "D. Pair of Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 3·105).The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 106).",
      "output_spec": "OutputPrint two integers in the first line — the number of required pairs and the maximum value of r - l. On the following line print all l values from optimal pairs in increasing order.",
      "sample_tests": "ExamplesInputCopy54 6 9 3 6OutputCopy1 32 InputCopy51 3 5 7 9OutputCopy1 41 InputCopy52 3 5 7 11OutputCopy5 01 2 3 4 5",
      "description": "D. Pair of Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 3·105).The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 106).\n\nOutputPrint two integers in the first line — the number of required pairs and the maximum value of r - l. On the following line print all l values from optimal pairs in increasing order.\n\nInputCopy54 6 9 3 6OutputCopy1 32 InputCopy51 3 5 7 9OutputCopy1 41 InputCopy52 3 5 7 11OutputCopy5 01 2 3 4 5\n\nInputCopy54 6 9 3 6\n\nOutputCopy1 32\n\nInputCopy51 3 5 7 9\n\nOutputCopy1 41\n\nInputCopy52 3 5 7 11\n\nOutputCopy5 01 2 3 4 5\n\nNoteIn the first sample the pair of numbers is right, as numbers 6, 9, 3 are divisible by 3.In the second sample all numbers are divisible by number 1.In the third sample all numbers are prime, so conditions 1 and 2 are true only for pairs of numbers (1, 1), (2, 2), (3, 3), (4, 4), (5, 5).",
      "solutions": [
        {
          "title": "Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on November 2 at 12:00 MSK) you are lucky to participate in Codeforces Round #209 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition. Pay attention to the round begining time!Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) and Ilya Los (IlyaLos) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2500, 2500.UPD2: Congratulations to winners! cptbtptp FancyCoder Oyk E.B. orzkbc UPD: EditorialGood Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 653
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "I'm not good in English. So, if you find an mistake in editorial, please, send me a private message.359A - TableIf there are some good cell, which is located in the first row or in the first column, the answer is two. Similarly, if If there are some good cell, which is located in the last row or in the last column, the answer is two. Otherwise, the answer is four.Авторское решение: 4968279359B - PermutationThe answer is a slightly modified permutation 1, 2, ..., 2n. Let's reverse numbers 2i - 1 and 2i for each 1 ≤ i ≤ k. It's not hard to understand, that this permutation is good.Авторское решение: 4968385359C - Prime NumberObviously, the answer is xv. Let sum = a1 + a2 + ... + an. Also let si = sum - ai (the array of degrees). After that let's find value v by the following algorithm: Let's consider a sequence of degrees as decreasing sequence. Now we will perform the following operation until it's possible to perfom it. Take the minimum degree v from the array of degrees and calculate the number of elements cnt, which have the same degree. If cnt multiples of x, then replace all cnt elements by cnt / x elements of the form v + 1. Since the sequence of degrees is a decreasing sequence, we can simply assign them to the end. If cnt is not a multiple of x, then we found the required value v. Also you need to check, that v is not greater then sum. Otherwise, v will be equals to sum.Авторское решение: 4968346359D - Pair of NumbersQuite simple note: if the pair (l, r) satisfies the condition 1 from the statements, then min(l, r) = GCD(l, r), where min(l, r) is smallest number ai from the segment (l, r) and GCD(l, r) is a GCD of all numbers from the segment (l, r). Calculate some data structure that will allow us to respond quickly to requests GCD(l, r) and min(l, r). For example, you can use Sparce Table. Solutuions, that uses segment tree, is too slow. So I think, you should use Sparce Table. So, now our task quite simple. Let's use binary search to find greatest value of r - l: lf = 0; //left boundary of binary search\nrg = n; //right boundary of binary search\nwhile (rg - lf > 1) {\n int mid = (lf + rg) / 2;\n if (ok(mid)) //ok(mid)\n lf = mid;\n else\n rg = mid;\n}ok(mid) is the function, that determines, is there some segment where min(l, r) = GCD(l, r) and mid = r - l (mid — is fixed value by binary search). If there is some good segment, you should update boundaries of binary search correctly. After that, it's very simple to restore answer. Some information about Sparce TableАвторское решение: 4968587359E - NeatnessYou should write recursive function, that will turn on the light in all rooms, where it's possible. Also this function will visit all rooms, which it may visit. Let this function is called paint(x, y), where x, y is the current room. Paint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current direction (rule 3 from the statement), and the room (nx, ny) (current neighbor) has not yet visited, we will call our recursive function from (nx, ny). Also, we will turn on the light in all rooms, were we were. If some room is not visited by paint(x, y) and lights is on in this room, the answer is \"NO\". Otherwise, the answer is \"YES\". After that let's calculate value dist(x, y) by using bfs. dist(x, y) — is a minimal possible distance from the start to the current position (x, y). It's possible to use in our bfs only rooms, where lights is on. After that we will write the same function repaint(x, y). Repaint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current neighbor (nx, ny) and dist(nx, ny) > dist(x, y) ((x, y) — current room), let's call our recursive function from (nx, ny).After that we will come back to room (x, y). If there is no such neigbor (nx, ny), turn off the light in the room (x, y). Also you should look at my solution for more details.Авторское решение: 4968657",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 359\\s*D"
          },
          "content_length": 3922
        }
      ],
      "code_examples": [
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 1",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 2",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000);\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000);\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000);\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_A = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        /* Generate random values between 1 and MAX_A */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_A);\n        }\n    } else if (type == \"same\") {\n        /* All elements have the same value */\n        int value = rnd.next(1, MAX_A);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"ones\") {\n        /* All elements are 1 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"primes\") {\n        /* All elements are prime numbers */\n        vector<int> primes;\n        vector<bool> is_prime(MAX_A + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= MAX_A; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (1LL * i * i <= MAX_A) {\n                    for (int j = i * i; j <= MAX_A; j += i)\n                        is_prime[j] = false;\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() - 1)];\n        }\n    } else if (type == \"alternating\") {\n        /* Elements alternate between two random values */\n        int v1 = rnd.next(1, MAX_A);\n        int v2 = rnd.next(1, MAX_A);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? v1 : v2;\n        }\n    } else if (type == \"increasing\") {\n        /* Elements form an increasing sequence */\n        int start = rnd.next(1, MAX_A - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        /* Elements form a decreasing sequence */\n        int start = rnd.next(n, MAX_A);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } else if (type == \"powers\") {\n        /* Elements are powers of a random base */\n        int b = rnd.next(2, 1000); // Base\n        for (int i = 0; i < n; ++i) {\n            int k = rnd.next(1, min(6, (int)(log(MAX_A) / log(b)))); // Exponent\n            a[i] = (int)pow(b, k);\n        }\n    } else if (type == \"maximal\") {\n        /* All elements are MAX_A */\n        for (int i = 0; i < n; ++i) {\n            a[i] = MAX_A;\n        }\n    } else if (type == \"smallnumbers\") {\n        /* All elements are small numbers between 1 and 10 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"bigvalues\") {\n        /* All elements are large numbers near MAX_A */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(MAX_A - 10, MAX_A);\n        }\n    } else {\n        /* Default to random if unknown type */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_A);\n        }\n    }\n\n    /* Output the array */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_A = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        /* Generate random values between 1 and MAX_A */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_A);\n        }\n    } else if (type == \"same\") {\n        /* All elements have the same value */\n        int value = rnd.next(1, MAX_A);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"ones\") {\n        /* All elements are 1 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"primes\") {\n        /* All elements are prime numbers */\n        vector<int> primes;\n        vector<bool> is_prime(MAX_A + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= MAX_A; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (1LL * i * i <= MAX_A) {\n                    for (int j = i * i; j <= MAX_A; j += i)\n                        is_prime[j] = false;\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() - 1)];\n        }\n    } else if (type == \"alternating\") {\n        /* Elements alternate between two random values */\n        int v1 = rnd.next(1, MAX_A);\n        int v2 = rnd.next(1, MAX_A);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? v1 : v2;\n        }\n    } else if (type == \"increasing\") {\n        /* Elements form an increasing sequence */\n        int start = rnd.next(1, MAX_A - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        /* Elements form a decreasing sequence */\n        int start = rnd.next(n, MAX_A);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } else if (type == \"powers\") {\n        /* Elements are powers of a random base */\n        int b = rnd.next(2, 1000); // Base\n        for (int i = 0; i < n; ++i) {\n            int k = rnd.next(1, min(6, (int)(log(MAX_A) / log(b)))); // Exponent\n            a[i] = (int)pow(b, k);\n        }\n    } else if (type == \"maximal\") {\n        /* All elements are MAX_A */\n        for (int i = 0; i < n; ++i) {\n            a[i] = MAX_A;\n        }\n    } else if (type == \"smallnumbers\") {\n        /* All elements are small numbers between 1 and 10 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"bigvalues\") {\n        /* All elements are large numbers near MAX_A */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(MAX_A - 10, MAX_A);\n        }\n    } else {\n        /* Default to random if unknown type */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_A);\n        }\n    }\n\n    /* Output the array */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type ones\n./gen -n 2 -type same\n./gen -n 10 -type random\n./gen -n 10 -type primes\n./gen -n 10 -type alternating\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type maximal\n./gen -n 10 -type smallnumbers\n./gen -n 10 -type bigvalues\n\n./gen -n 100 -type random\n./gen -n 100 -type primes\n./gen -n 100 -type powers\n./gen -n 100 -type same\n\n./gen -n 1000 -type random\n./gen -n 1000 -type primes\n./gen -n 1000 -type alternating\n./gen -n 1000 -type smallnumbers\n./gen -n 1000 -type bigvalues\n\n./gen -n 10000 -type random\n./gen -n 10000 -type increasing\n./gen -n 10000 -type decreasing\n\n./gen -n 100000 -type random\n./gen -n 100000 -type primes\n\n./gen -n 200000 -type same\n./gen -n 200000 -type ones\n\n./gen -n 300000 -type random\n./gen -n 300000 -type maximal\n./gen -n 300000 -type alternating\n./gen -n 300000 -type powers\n./gen -n 300000 -type smallnumbers\n./gen -n 300000 -type bigvalues\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:13:58.933565",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "359/E",
      "title": "E. Neatness",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three positive integers n, x0, y0 (2 ≤ n ≤ 500, 1 ≤ x0, y0 ≤ n).Next n lines contain the description of rooms in the house. The i-th line contains n space-separated integers ai1, ai2, ..., ain. If number aij equals zero, then room (i, j) has light off, and if number aij equals one, then room (i, j) has light on. It is guaranteed that at least one room has light on.",
      "output_spec": "OutputIf there is no desired sequence of actions, print \"NO\" (without the quotes). Otherwise, print \"YES\" (without the quotes) and the description of the required sequence of actions as a string. Note that you do not have to minimize the length of the sequence of actions but you shouldn't use more than 3·106 actions.",
      "sample_tests": "ExamplesInputCopy3 1 11 0 00 1 01 0 0OutputCopyYESD1R2L2D2UU2InputCopy3 1 11 0 00 1 00 0 1OutputCopyNO",
      "description": "E. Neatness\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three positive integers n, x0, y0 (2 ≤ n ≤ 500, 1 ≤ x0, y0 ≤ n).Next n lines contain the description of rooms in the house. The i-th line contains n space-separated integers ai1, ai2, ..., ain. If number aij equals zero, then room (i, j) has light off, and if number aij equals one, then room (i, j) has light on. It is guaranteed that at least one room has light on.\n\nOutputIf there is no desired sequence of actions, print \"NO\" (without the quotes). Otherwise, print \"YES\" (without the quotes) and the description of the required sequence of actions as a string. Note that you do not have to minimize the length of the sequence of actions but you shouldn't use more than 3·106 actions.\n\nInputCopy3 1 11 0 00 1 01 0 0OutputCopyYESD1R2L2D2UU2InputCopy3 1 11 0 00 1 00 0 1OutputCopyNO\n\nInputCopy3 1 11 0 00 1 01 0 0\n\nOutputCopyYESD1R2L2D2UU2\n\nInputCopy3 1 11 0 00 1 00 0 1\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on November 2 at 12:00 MSK) you are lucky to participate in Codeforces Round #209 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition. Pay attention to the round begining time!Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) and Ilya Los (IlyaLos) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2500, 2500.UPD2: Congratulations to winners! cptbtptp FancyCoder Oyk E.B. orzkbc UPD: EditorialGood Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 653
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces",
          "content": "I'm not good in English. So, if you find an mistake in editorial, please, send me a private message.359A - TableIf there are some good cell, which is located in the first row or in the first column, the answer is two. Similarly, if If there are some good cell, which is located in the last row or in the last column, the answer is two. Otherwise, the answer is four.Авторское решение: 4968279359B - PermutationThe answer is a slightly modified permutation 1, 2, ..., 2n. Let's reverse numbers 2i - 1 and 2i for each 1 ≤ i ≤ k. It's not hard to understand, that this permutation is good.Авторское решение: 4968385359C - Prime NumberObviously, the answer is xv. Let sum = a1 + a2 + ... + an. Also let si = sum - ai (the array of degrees). After that let's find value v by the following algorithm: Let's consider a sequence of degrees as decreasing sequence. Now we will perform the following operation until it's possible to perfom it. Take the minimum degree v from the array of degrees and calculate the number of elements cnt, which have the same degree. If cnt multiples of x, then replace all cnt elements by cnt / x elements of the form v + 1. Since the sequence of degrees is a decreasing sequence, we can simply assign them to the end. If cnt is not a multiple of x, then we found the required value v. Also you need to check, that v is not greater then sum. Otherwise, v will be equals to sum.Авторское решение: 4968346359D - Pair of NumbersQuite simple note: if the pair (l, r) satisfies the condition 1 from the statements, then min(l, r) = GCD(l, r), where min(l, r) is smallest number ai from the segment (l, r) and GCD(l, r) is a GCD of all numbers from the segment (l, r). Calculate some data structure that will allow us to respond quickly to requests GCD(l, r) and min(l, r). For example, you can use Sparce Table. Solutuions, that uses segment tree, is too slow. So I think, you should use Sparce Table. So, now our task quite simple. Let's use binary search to find greatest value of r - l: lf = 0; //left boundary of binary search\nrg = n; //right boundary of binary search\nwhile (rg - lf > 1) {\n int mid = (lf + rg) / 2;\n if (ok(mid)) //ok(mid)\n lf = mid;\n else\n rg = mid;\n}ok(mid) is the function, that determines, is there some segment where min(l, r) = GCD(l, r) and mid = r - l (mid — is fixed value by binary search). If there is some good segment, you should update boundaries of binary search correctly. After that, it's very simple to restore answer. Some information about Sparce TableАвторское решение: 4968587359E - NeatnessYou should write recursive function, that will turn on the light in all rooms, where it's possible. Also this function will visit all rooms, which it may visit. Let this function is called paint(x, y), where x, y is the current room. Paint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current direction (rule 3 from the statement), and the room (nx, ny) (current neighbor) has not yet visited, we will call our recursive function from (nx, ny). Also, we will turn on the light in all rooms, were we were. If some room is not visited by paint(x, y) and lights is on in this room, the answer is \"NO\". Otherwise, the answer is \"YES\". After that let's calculate value dist(x, y) by using bfs. dist(x, y) — is a minimal possible distance from the start to the current position (x, y). It's possible to use in our bfs only rooms, where lights is on. After that we will write the same function repaint(x, y). Repaint(x, y) will use following idea: Let's look at all neighbors. If there is a light in the current neighbor (nx, ny) and dist(nx, ny) > dist(x, y) ((x, y) — current room), let's call our recursive function from (nx, ny).After that we will come back to room (x, y). If there is no such neigbor (nx, ny), turn off the light in the room (x, y). Also you should look at my solution for more details.Авторское решение: 4968657",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 359\\s*E"
          },
          "content_length": 3922
        }
      ],
      "code_examples": [
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 1",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #209 (Div. 2) - Codeforces - Code 2",
          "code": "lf = 0;  //left boundary of binary search\nrg = n;  //right boundary of binary search\nwhile (rg - lf > 1) {\n  int mid = (lf + rg) / 2;\n  if (ok(mid))   //ok(mid)\n    lf = mid;\n  else\n    rg = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9425",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int x0 = inf.readInt(1, n, \"x0\");\n    inf.readSpace();\n    int y0 = inf.readInt(1, n, \"y0\");\n    inf.readEoln();\n\n    int sumLights = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (j > 1) inf.readSpace();\n            int aij = inf.readInt(0, 1, \"a_\" + to_string(i) + \"_\" + to_string(j));\n            sumLights += aij;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(sumLights >= 1, \"At least one room must have light on\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int x0 = inf.readInt(1, n, \"x0\");\n    inf.readSpace();\n    int y0 = inf.readInt(1, n, \"y0\");\n    inf.readEoln();\n\n    int sumLights = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (j > 1) inf.readSpace();\n            int aij = inf.readInt(0, 1, \"a_\" + to_string(i) + \"_\" + to_string(j));\n            sumLights += aij;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(sumLights >= 1, \"At least one room must have light on\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int x0 = inf.readInt(1, n, \"x0\");\n    inf.readSpace();\n    int y0 = inf.readInt(1, n, \"y0\");\n    inf.readEoln();\n\n    int sumLights = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (j > 1) inf.readSpace();\n            int aij = inf.readInt(0, 1, \"a_\" + to_string(i) + \"_\" + to_string(j));\n            sumLights += aij;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(sumLights >= 1, \"At least one room must have light on\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_ACTIONS = 3000000;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(2, 500, \"n\");\n    int x0 = inf.readInt(1, n, \"x0\");\n    int y0 = inf.readInt(1, n, \"y0\");\n    vector<vector<int>> grid(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            grid[i][j] = inf.readInt(0, 1, format(\"a[%d][%d]\", i + 1, j + 1).c_str());\n        }\n    }\n\n    string ansStatus = ans.readWord();\n    if (ansStatus != \"YES\" && ansStatus != \"NO\") {\n        quitf(_fail, \"Judge's answer is neither YES nor NO: %s\", ansStatus.c_str());\n    }\n\n    string oufStatus = ouf.readWord();\n    if (oufStatus != \"YES\" && oufStatus != \"NO\") {\n        quitf(_pe, \"Contestant's answer is neither YES nor NO: %s\", oufStatus.c_str());\n    }\n\n    if (oufStatus == \"NO\") {\n        if (ansStatus == \"YES\") {\n            quitf(_wa, \"Contestant failed to find a solution when one exists\");\n        } else {\n            quitf(_ok, \"Correctly reported NO when no solution exists\");\n        }\n    } else { // oufStatus == \"YES\"\n        ouf.readEoln();\n        string actions = ouf.readString();\n        if (int(actions.length()) > MAX_ACTIONS) {\n            quitf(_wa, \"Action sequence too long: length = %d\", int(actions.length()));\n        }\n        // Simulate the actions\n        int x = x0 - 1;\n        int y = y0 - 1;\n        map<char, pair<int, int>> moves = {\n            {'L', {0, -1}},\n            {'R', {0, 1}},\n            {'U', {-1, 0}},\n            {'D', {1, 0}}\n        };\n        for (size_t idx = 0; idx < actions.size(); idx++) {\n            char c = actions[idx];\n            if (c == '1') {\n                if (grid[x][y] == 0) {\n                    grid[x][y] = 1;\n                } else {\n                    quitf(_wa, \"Cannot turn on an already lit room at position (%d, %d)\", x + 1, y + 1);\n                }\n            } else if (c == '2') {\n                if (grid[x][y] == 1) {\n                    grid[x][y] = 0;\n                } else {\n                    quitf(_wa, \"Cannot turn off an already unlit room at position (%d, %d)\", x + 1, y + 1);\n                }\n            } else if (moves.count(c)) {\n                int dx = moves[c].first;\n                int dy = moves[c].second;\n                bool canMove = false;\n                for (int k = 1; k < n; k++) {\n                    int nx = x + dx * k;\n                    int ny = y + dy * k;\n                    if (nx < 0 || nx >= n || ny < 0 || ny >= n) break;\n                    if (grid[nx][ny] == 1) {\n                        canMove = true;\n                        break;\n                    }\n                }\n                if (!canMove) {\n                    quitf(_wa, \"Cannot move %c from position (%d, %d)\", c, x + 1, y + 1);\n                }\n                int nx = x + dx;\n                int ny = y + dy;\n                if (nx < 0 || nx >= n || ny < 0 || ny >= n) {\n                    quitf(_wa, \"Moved out of bounds to position (%d, %d)\", nx + 1, ny + 1);\n                }\n                x = nx;\n                y = ny;\n            } else {\n                quitf(_wa, \"Invalid action character '%c'\", c);\n            }\n        }\n        // Check final state\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    quitf(_wa, \"Light at position (%d, %d) is still on\", i + 1, j + 1);\n                }\n            }\n        }\n        if (x != x0 - 1 || y != y0 - 1) {\n            quitf(_wa, \"Did not return to starting position (%d, %d), ended at (%d, %d)\", x0, y0, x + 1, y + 1);\n        }\n        quitf(_ok, \"Correct solution\");\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int x0 = opt<int>(\"x0\");\n    int y0 = opt<int>(\"y0\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure x0 and y0 are within range\n    if (x0 < 1 || x0 > n || y0 < 1 || y0 > n) {\n        x0 = rnd.next(1, n);\n        y0 = rnd.next(1, n);\n    }\n\n    vector<vector<int>> grid(n, vector<int>(n, 0));\n\n    if (type == \"full-lit\") {\n        // All rooms are lit\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = 1;\n    } else if (type == \"one-lit\") {\n        // Only one room is lit\n        int x = rnd.next(n);\n        int y = rnd.next(n);\n        grid[x][y] = 1;\n    } else if (type == \"blocked-start\") {\n        // Simon cannot move from starting position\n        // Ensure starting room is lit\n        grid[x0 -1 ][y0 -1 ] = 1;\n        // Remove lit rooms in all directions from starting position\n        for (int i = 0; i < n; ++i) {\n            if (i != x0 - 1)\n                grid[i][y0 - 1] = 0; // Same column\n            if (i != y0 - 1)\n                grid[x0 - 1][i] = 0; // Same row\n        }\n        // Ensure at least one lit room somewhere else\n        if (x0 > 1) {\n            grid[0][0] = 1; // Top-left corner\n        } else {\n            grid[n-1][n-1] = 1; // Bottom-right corner\n        }\n    } else if (type == \"unreachable\") {\n        // Generate a grid where some lit rooms are unreachable\n        int wall_col = n / 2;\n        for (int i = 0; i < n; ++i) {\n            grid[i][wall_col] = 0; // Wall of unlit rooms\n        }\n        // Set lit rooms on both sides of the wall\n        grid[x0 - 1][y0 - 1] = 1; // Starting position\n        grid[n - 1][n - 1] = 1; // Other side of the wall\n    } else if (type == \"perimeter-lit\") {\n        // Only the perimeter rooms are lit\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = 1; // Top row\n            grid[n - 1][i] = 1; // Bottom row\n            grid[i][0] = 1; // Left column\n            grid[i][n - 1] = 1; // Right column\n        }\n    } else if (type == \"random\") {\n        // Random grid with at least one room lit\n        int lit_count = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                grid[i][j] = rnd.next(2);\n                lit_count += grid[i][j];\n            }\n        // Ensure at least one room is lit\n        if (lit_count == 0) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            grid[x][y] = 1;\n        }\n    } else {\n        // Default to random\n        int lit_count = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                grid[i][j] = rnd.next(2);\n                lit_count += grid[i][j];\n            }\n        if (lit_count == 0) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            grid[x][y] = 1;\n        }\n    }\n\n    // Print n x0 y0\n    printf(\"%d %d %d\\n\", n, x0, y0);\n\n    // Print the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 != n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int x0 = opt<int>(\"x0\");\n    int y0 = opt<int>(\"y0\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure x0 and y0 are within range\n    if (x0 < 1 || x0 > n || y0 < 1 || y0 > n) {\n        x0 = rnd.next(1, n);\n        y0 = rnd.next(1, n);\n    }\n\n    vector<vector<int>> grid(n, vector<int>(n, 0));\n\n    if (type == \"full-lit\") {\n        // All rooms are lit\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = 1;\n    } else if (type == \"one-lit\") {\n        // Only one room is lit\n        int x = rnd.next(n);\n        int y = rnd.next(n);\n        grid[x][y] = 1;\n    } else if (type == \"blocked-start\") {\n        // Simon cannot move from starting position\n        // Ensure starting room is lit\n        grid[x0 -1 ][y0 -1 ] = 1;\n        // Remove lit rooms in all directions from starting position\n        for (int i = 0; i < n; ++i) {\n            if (i != x0 - 1)\n                grid[i][y0 - 1] = 0; // Same column\n            if (i != y0 - 1)\n                grid[x0 - 1][i] = 0; // Same row\n        }\n        // Ensure at least one lit room somewhere else\n        if (x0 > 1) {\n            grid[0][0] = 1; // Top-left corner\n        } else {\n            grid[n-1][n-1] = 1; // Bottom-right corner\n        }\n    } else if (type == \"unreachable\") {\n        // Generate a grid where some lit rooms are unreachable\n        int wall_col = n / 2;\n        for (int i = 0; i < n; ++i) {\n            grid[i][wall_col] = 0; // Wall of unlit rooms\n        }\n        // Set lit rooms on both sides of the wall\n        grid[x0 - 1][y0 - 1] = 1; // Starting position\n        grid[n - 1][n - 1] = 1; // Other side of the wall\n    } else if (type == \"perimeter-lit\") {\n        // Only the perimeter rooms are lit\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = 1; // Top row\n            grid[n - 1][i] = 1; // Bottom row\n            grid[i][0] = 1; // Left column\n            grid[i][n - 1] = 1; // Right column\n        }\n    } else if (type == \"random\") {\n        // Random grid with at least one room lit\n        int lit_count = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                grid[i][j] = rnd.next(2);\n                lit_count += grid[i][j];\n            }\n        // Ensure at least one room is lit\n        if (lit_count == 0) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            grid[x][y] = 1;\n        }\n    } else {\n        // Default to random\n        int lit_count = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                grid[i][j] = rnd.next(2);\n                lit_count += grid[i][j];\n            }\n        if (lit_count == 0) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            grid[x][y] = 1;\n        }\n    }\n\n    // Print n x0 y0\n    printf(\"%d %d %d\\n\", n, x0, y0);\n\n    // Print the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 != n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -x0 1 -y0 1 -type random\n./gen -n 3 -x0 1 -y0 1 -type one-lit\n./gen -n 3 -x0 1 -y0 1 -type full-lit\n./gen -n 3 -x0 1 -y0 1 -type blocked-start\n./gen -n 3 -x0 1 -y0 1 -type unreachable\n\n./gen -n 10 -x0 5 -y0 5 -type random\n./gen -n 10 -x0 5 -y0 5 -type one-lit\n./gen -n 10 -x0 1 -y0 10 -type full-lit\n./gen -n 10 -x0 10 -y0 1 -type blocked-start\n./gen -n 10 -x0 3 -y0 7 -type unreachable\n./gen -n 10 -x0 5 -y0 5 -type perimeter-lit\n\n./gen -n 50 -x0 25 -y0 25 -type random\n./gen -n 50 -x0 25 -y0 25 -type one-lit\n./gen -n 50 -x0 1 -y0 50 -type full-lit\n./gen -n 50 -x0 50 -y0 1 -type blocked-start\n./gen -n 50 -x0 20 -y0 30 -type unreachable\n./gen -n 50 -x0 25 -y0 25 -type perimeter-lit\n\n./gen -n 100 -x0 50 -y0 50 -type random\n./gen -n 100 -x0 50 -y0 50 -type one-lit\n./gen -n 100 -x0 1 -y0 100 -type full-lit\n./gen -n 100 -x0 100 -y0 1 -type blocked-start\n./gen -n 100 -x0 40 -y0 60 -type unreachable\n./gen -n 100 -x0 50 -y0 50 -type perimeter-lit\n\n./gen -n 500 -x0 250 -y0 250 -type random\n./gen -n 500 -x0 250 -y0 250 -type one-lit\n./gen -n 500 -x0 1 -y0 500 -type full-lit\n./gen -n 500 -x0 500 -y0 1 -type blocked-start\n./gen -n 500 -x0 200 -y0 300 -type unreachable\n./gen -n 500 -x0 250 -y0 250 -type perimeter-lit\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:00.963009",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "36/A",
      "title": "A. Внеземной разум",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке записано целое число n (3 ≤ n ≤ 100) — количество дней наблюдения за приемником. Во второй строке записано n символов 1 или 0 — показания приемника в каждый из n дней. Гарантируется, что в заданной последовательности показаний не менее трех единиц.",
      "output_spec": "Выходные данныеЕсли Вася обнаружил внеземной разум, выведите YES, иначе выведите NO.",
      "sample_tests": "ПримерыВходные данныеСкопировать800111000Выходные данныеСкопироватьYESВходные данныеСкопировать71001011Выходные данныеСкопироватьNOВходные данныеСкопировать71010100Выходные данныеСкопироватьYES",
      "description": "A. Внеземной разум\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвводinput.txt\n\nвыводoutput.txt\n\nВходные данныеВ первой строке записано целое число n (3 ≤ n ≤ 100) — количество дней наблюдения за приемником. Во второй строке записано n символов 1 или 0 — показания приемника в каждый из n дней. Гарантируется, что в заданной последовательности показаний не менее трех единиц.\n\nВходные данные\n\nВыходные данныеЕсли Вася обнаружил внеземной разум, выведите YES, иначе выведите NO.\n\nВыходные данные\n\nВходные данныеСкопировать800111000Выходные данныеСкопироватьYESВходные данныеСкопировать71001011Выходные данныеСкопироватьNOВходные данныеСкопировать71010100Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать800111000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать71001011\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать71010100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #35 (Div. 2) и Codeforces Beta Round #36 - Codeforces",
          "content": "Всем доброго времени суток. Сегодня на Codeforces необычный день: сразу два раунда, днем, да еще со столь небольшим перерывом. А объясняется это тем, что сегодня в Саратове проходит IX Региональная командная олимпиада школьников по программированию, и задачи с нее (а они весьма неплохие) решено было дать на раунды Codeforces. По этой причине авторов у сегодняшних задач много. Не поленюсь перечислить весь состав жюри олимпиады, все члены которого хорошо знакомы вам как авторы задач на Codeforces. Это Артем Рахов, Николай Кузнецов, Наталья Бондаренко, Геральд Агапов,Полина Бондаренко, Иван Фефер, Эдвард Давтян, Игорь Кудряшов, Павел Холкин и я. Все мы отлично потрудились и надеемся, что вы оцените наши задачи. Отдельное спасибо стоит сказать Марии Беловой и Юлии Сатушиной за перевод задач на английский язык. Обращаю ваше внимание на то, что сегодня во всех задачах будет файловый ввод-вывод. Однако генератор для взлома, как обычно, должен выводить в stdout. Желаю всем удачи на контестах! UPD: Результаты 35-го раунда. Поздравляем победителя, участника с ником Naginchik, с впечатляющим дебютом!UPD: Результаты 36-го раунда.Ссылки на разборы задач: A, B, C, D, E.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 36 和字母"
          },
          "content_length": 1174
        },
        {
          "title": "Codeforces Beta Round #36 (Разбор задачи E) - Codeforces",
          "content": "В задаче требуется разбить ребра графа на две группы, каждая из которых образует путь в графе. Ясно, что каждый путь содержится в одной компоненте связности. Поэтому если в данном графе больше двух компонент связности, то задача не имеет решения. То же самое можно сказать про граф, в котором более четырех вершин нечетной степени. Действительно, каждая вершина в пути имеет четную степень, за исключением первой и последней вершины. Поэтому объединение двух путей не может содержать больше четырех нечетных вершин.Теперь рассмотрим случаи:1. Одна компонента связности, нет вершин нечетной степени. Тогда имеем эйлеров цикл, который можно разбить на два пути.2. Одна компонента связности, две нечетные вершины. То же самое, только с эйлеровым путем вместо эйлерова цикла. Есть один хитрый случай: граф с одним ребром, который не может быть разбит на два непустых пути.3. Одна компонента связности, четыре нечетные вершины. Самый интересный случай. Соединим две вершины нечетной степени фиктивным ребром. Получим граф, содержащий эйлеров путь. Найдем эйлеров путь и удалим фиктивное ребро - получим два пути.4. Две компоненты связности, каждая имеет ноль или две нечетные вершины. Два эйлеровых пути/цикла.5. Две компоненты связности, четыре нечетные вершины в одной и ни одной нечетной вершины в другой. Нет решения.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1316
        },
        {
          "title": "Codeforces Beta Round #36 (Problem C Tutorial) - Codeforces",
          "content": "Imagine that we have successfully processed first i - 1 bowls, i.e. we know height of the bottom yj for every bowl j (1 ≤ j < i). Now we are going to place i-th bowl. For each j-th already placed bowl, we will calculate the relative height of the bottom of i-th bowl above the bottom of j-th bowl, assuming that there are no other bowls. Lets denote this value by Δi, j. It is obvious that height of the new bowl is equal to the maximal of the following values: yi = max(yj + Δi, j).Now I will describe how to calculate Δi, j. Firstly, consider two trivial cases:I. ri ≥ Rj: bottom of i-th bowl rests on the top of j-th. Then Δi, j = hj.II. Ri ≤ rj: bottom of i-th bowl reaches the bottom of j-th. Then Δi, j = 0.Then there are three slightly more complicated cases. 1. ri > rj: bottom of i-th bowl gets stuck somewhere between the top and the bottom of j-th,touching it's sides. From the similarity of some triangles we get that .2. Ri ≤ Rj: top of i-th bowl gets stuck somewhere between the top and the bottom of j-th,touching it's sides. From the similarity of some triangles we get that .3. Ri > Rj: sides of i-th bowl touch the top of j-th in it's upper points. Then .Note that, for example, cases 1 and 2 do not exclude each other, so the final value of Δi, j is equal to the maximum of the values, computed in all three cases.Note that if the calculated value of Δi, j is negative, the result should be 0. Thanks to adamax for pointing it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/774",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1446
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #35 (Div. 2) и Codeforces Beta Round #36 - Codeforces - Code 1",
          "code": "Pascal / Delphi:\n\nvar\n    a, b: longint;\nbegin\n    assign(input, 'input.txt');\n    assign(output, 'output.txt');\n    reset(input);\n    rewrite(output);\n    read(a, b);\n    writeln(a * b);\n    close(input);\n    close(output);\nend.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #35 (Div. 2) и Codeforces Beta Round #36 - Codeforces - Code 2",
          "code": "C/C++:\n#include <stdio.h>int main()\n{\n    int a, b;\n\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"wt\", stdout);\n\n    scanf(\"%d %d\", &a, &b);\n    printf(\"%d\\n\", a * b);\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #35 (Div. 2) и Codeforces Beta Round #36 - Codeforces - Code 3",
          "code": "Java:\nimport java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner s = new Scanner(new File(\"input.txt\"));\n        int a = s.nextInt();\n        int b = s.nextInt();\n        s.close();\n\n        PrintWriter writer = new PrintWriter(\"output.txt\");\n        writer.println(a * b);\n        writer.close();\n    }\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    int count_ones = count(s.begin(), s.end(), '1');\n    ensuref(count_ones >= 3, \"the sequence must contain at least three '1's, but it contains %d\", count_ones);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    int count_ones = count(s.begin(), s.end(), '1');\n    ensuref(count_ones >= 3, \"the sequence must contain at least three '1's, but it contains %d\", count_ones);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    int count_ones = count(s.begin(), s.end(), '1');\n    ensuref(count_ones >= 3, \"the sequence must contain at least three '1's, but it contains %d\", count_ones);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string pattern = opt<string>(\"pattern\", \"random\");\n\n    vector<int> positions;\n\n    if (type == \"YES\") {\n        if (pattern == \"all_ones\") {\n            // Generate all ones\n            positions.clear();\n            for (int i = 1; i <= n; i++) {\n                positions.push_back(i);\n            }\n        } else {\n            // Generate positions with equal intervals\n            int min_k = 3;\n            int max_k = n;\n            int k;\n            int delta;\n            int s;\n            bool success = false;\n            for (int attempt = 0; attempt < 1000 && !success; attempt++) {\n                k = rnd.next(min_k, max_k);\n                if (k < 3) continue;\n                int delta_max = (n - 1) / (k -1);\n                if (delta_max < 1) continue;\n                delta = rnd.next(1, delta_max);\n                int s_max = n - (k -1)*delta;\n                if (s_max < 1) continue;\n                s = rnd.next(1, s_max);\n                success = true;\n            }\n            if (!success) {\n                // As a last resort, set k = 3, delta =1, s =1\n                k = 3;\n                delta = 1;\n                s = 1;\n            }\n            positions.clear();\n            for (int i = 0; i < k; i++) {\n                positions.push_back(s + delta * i);\n            }\n        }\n    } else if (type == \"NO\") {\n        if (pattern == \"consecutive_ones\") {\n            // Generate sequence with consecutive ones, but make intervals unequal\n            positions.clear();\n            int k = rnd.next(3, n);\n            int start = rnd.next(1, n - k +1);\n            for (int i = 0; i < k; i++) {\n                positions.push_back(start + i);\n            }\n            // Now modify one position to break equal intervals\n            int idx = rnd.next(1, k -1);\n            positions[idx] += 1;\n            if (positions[idx] > n) positions[idx] = positions[idx -1] +1;\n            sort(positions.begin(), positions.end());\n        } else {\n            // Generate positions with unequal intervals\n            int min_k = 3;\n            int max_k = n;\n            int k = rnd.next(min_k, max_k);\n            set<int> pos_set;\n            while ((int)pos_set.size() < k) {\n                int pos = rnd.next(1, n);\n                pos_set.insert(pos);\n            }\n            positions.assign(pos_set.begin(), pos_set.end());\n            sort(positions.begin(), positions.end());\n            // Check intervals\n            vector<int> intervals;\n            for (size_t i = 1; i < positions.size(); i++) {\n                intervals.push_back(positions[i] - positions[i-1]);\n            }\n            // If intervals are all equal, modify one position\n            bool equal_intervals = true;\n            for (size_t i =1; i < intervals.size(); i++) {\n                if (intervals[i] != intervals[i-1]) {\n                    equal_intervals = false;\n                    break;\n                }\n            }\n            if (equal_intervals) {\n                int idx = rnd.next(1, k -1);\n                positions[idx] += 1;\n                if (positions[idx] > n) positions[idx] = positions[idx -1 ] + 1;\n                sort(positions.begin(), positions.end());\n            }\n        }\n    }\n\n    // Generate the sequence\n    string s(n, '0');\n    for (int pos : positions) {\n        s[pos -1] = '1';\n    }\n\n    // Output n and sequence\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string pattern = opt<string>(\"pattern\", \"random\");\n\n    vector<int> positions;\n\n    if (type == \"YES\") {\n        if (pattern == \"all_ones\") {\n            // Generate all ones\n            positions.clear();\n            for (int i = 1; i <= n; i++) {\n                positions.push_back(i);\n            }\n        } else {\n            // Generate positions with equal intervals\n            int min_k = 3;\n            int max_k = n;\n            int k;\n            int delta;\n            int s;\n            bool success = false;\n            for (int attempt = 0; attempt < 1000 && !success; attempt++) {\n                k = rnd.next(min_k, max_k);\n                if (k < 3) continue;\n                int delta_max = (n - 1) / (k -1);\n                if (delta_max < 1) continue;\n                delta = rnd.next(1, delta_max);\n                int s_max = n - (k -1)*delta;\n                if (s_max < 1) continue;\n                s = rnd.next(1, s_max);\n                success = true;\n            }\n            if (!success) {\n                // As a last resort, set k = 3, delta =1, s =1\n                k = 3;\n                delta = 1;\n                s = 1;\n            }\n            positions.clear();\n            for (int i = 0; i < k; i++) {\n                positions.push_back(s + delta * i);\n            }\n        }\n    } else if (type == \"NO\") {\n        if (pattern == \"consecutive_ones\") {\n            // Generate sequence with consecutive ones, but make intervals unequal\n            positions.clear();\n            int k = rnd.next(3, n);\n            int start = rnd.next(1, n - k +1);\n            for (int i = 0; i < k; i++) {\n                positions.push_back(start + i);\n            }\n            // Now modify one position to break equal intervals\n            int idx = rnd.next(1, k -1);\n            positions[idx] += 1;\n            if (positions[idx] > n) positions[idx] = positions[idx -1] +1;\n            sort(positions.begin(), positions.end());\n        } else {\n            // Generate positions with unequal intervals\n            int min_k = 3;\n            int max_k = n;\n            int k = rnd.next(min_k, max_k);\n            set<int> pos_set;\n            while ((int)pos_set.size() < k) {\n                int pos = rnd.next(1, n);\n                pos_set.insert(pos);\n            }\n            positions.assign(pos_set.begin(), pos_set.end());\n            sort(positions.begin(), positions.end());\n            // Check intervals\n            vector<int> intervals;\n            for (size_t i = 1; i < positions.size(); i++) {\n                intervals.push_back(positions[i] - positions[i-1]);\n            }\n            // If intervals are all equal, modify one position\n            bool equal_intervals = true;\n            for (size_t i =1; i < intervals.size(); i++) {\n                if (intervals[i] != intervals[i-1]) {\n                    equal_intervals = false;\n                    break;\n                }\n            }\n            if (equal_intervals) {\n                int idx = rnd.next(1, k -1);\n                positions[idx] += 1;\n                if (positions[idx] > n) positions[idx] = positions[idx -1 ] + 1;\n                sort(positions.begin(), positions.end());\n            }\n        }\n    }\n\n    // Generate the sequence\n    string s(n, '0');\n    for (int pos : positions) {\n        s[pos -1] = '1';\n    }\n\n    // Output n and sequence\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n cases\n./gen -n 3 -type YES\n./gen -n 3 -type NO\n\n# Small n cases\n./gen -n 4 -type YES\n./gen -n 5 -type NO\n./gen -n 6 -type YES\n./gen -n 7 -type NO\n./gen -n 8 -type YES\n./gen -n 9 -type NO\n\n# Medium n cases\n./gen -n 10 -type YES\n./gen -n 12 -type NO\n./gen -n 15 -type YES\n./gen -n 20 -type NO\n./gen -n 25 -type YES\n./gen -n 30 -type NO\n\n# Maximal n cases\n./gen -n 50 -type YES\n./gen -n 60 -type NO\n./gen -n 70 -type YES\n./gen -n 80 -type NO\n./gen -n 90 -type YES\n./gen -n 100 -type NO\n\n# Edge cases\n# All ones sequence\n./gen -n 100 -type YES -pattern all_ones\n\n# Sequence with consecutive ones but should output NO\n./gen -n 100 -type NO -pattern consecutive_ones\n\n# Random tests with varying n\nfor n in 3 10 20 30 40 50 60 70 80 90 100; do\n    ./gen -n $n -type YES\n    ./gen -n $n -type NO\ndone\n\n# Special NO cases with consecutive ones\n./gen -n 3 -type NO -pattern consecutive_ones\n./gen -n 20 -type NO -pattern consecutive_ones\n./gen -n 100 -type NO -pattern consecutive_ones\n\n# Special YES cases with all ones\n./gen -n 5 -type YES -pattern all_ones\n./gen -n 50 -type YES -pattern all_ones\n\n# Generate YES cases with minimal interval\n./gen -n 100 -type YES\n\n# Generate NO cases with random patterns\n./gen -n 50 -type NO\n./gen -n 75 -type NO\n\n# Generate YES cases with random patterns\n./gen -n 50 -type YES\n./gen -n 75 -type YES\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:02.910542",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "36/B",
      "title": "B. Fractal",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains integers n and k (2 ≤ n ≤ 3, 1 ≤ k ≤ 5), where k is the amount of steps of the algorithm. Each of the following n lines contains n symbols that determine the model. Symbol «.» stands for a white square, whereas «*» stands for a black one. It is guaranteed that the model has at least one white square.",
      "output_spec": "OutputOutput a matrix nk × nk which is what a picture should look like after k steps of the algorithm.",
      "sample_tests": "ExamplesInputCopy2 3.*..OutputCopy.*******..******.*.*****....****.***.***..**..**.*.*.*.*........InputCopy3 2.*.***.*.OutputCopy.*.***.*.*********.*.***.*.***************************.*.***.*.*********.*.***.*.",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\ninputinput.txt\n\noutputoutput.txt\n\nInputThe first line contains integers n and k (2 ≤ n ≤ 3, 1 ≤ k ≤ 5), where k is the amount of steps of the algorithm. Each of the following n lines contains n symbols that determine the model. Symbol «.» stands for a white square, whereas «*» stands for a black one. It is guaranteed that the model has at least one white square.\n\nOutputOutput a matrix nk × nk which is what a picture should look like after k steps of the algorithm.\n\nInputCopy2 3.*..OutputCopy.*******..******.*.*****....****.***.***..**..**.*.*.*.*........InputCopy3 2.*.***.*.OutputCopy.*.***.*.*********.*.***.*.***************************.*.***.*.*********.*.***.*.\n\nInputCopy2 3.*..\n\nOutputCopy.*******..******.*.*****....****.***.***..**..**.*.*.*.*........\n\nInputCopy3 2.*.***.*.\n\nOutputCopy.*.***.*.*********.*.***.*.***************************.*.***.*.*********.*.***.*.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #35 (Div. 2) and Codeforces Beta Round #36 - Codeforces",
          "content": "Greetings to everybody. Today is an unusual day on Codeforces: two contests a day with quite small gap between them. The reason is that today the IX Regional team school programming contest is held in Saratov, and it was decided to use the tasks from it for Codeforces rounds. That's why there are many authors of today's tasks. I would like to thank the whole jury of the school contest for their excellent job. The following people are on the jury: Artem Rakhov, Nickolay Kuznetsov, Natalia Bondarenko, Gerald Agapov, Polina Bondarenko, Ivan Fefer, Edvard Davtyan, Igor Kudryashov, Pavel Kholkin and me. I believe that you know all these people as Codeforces problemsetters. Let me draw your attention to the fact that today all problems have file IO. But generators for the hacks should output to stdout as usual. Special thanks to Maria Belova and Julia Satushina for translating problem statements into English. Good luck at the contests! UPD: Results of the 35th round. We congratulate the winner, Naginchik, on his impressive debut!UPD: Results of the 36th round.Links to problem tutorials: A, B, C, D, E.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 36 和字母"
          },
          "content_length": 1112
        },
        {
          "title": "Codeforces Beta Round #36 (Problem E solution) - Codeforces",
          "content": "The problem is to divide edges of a graph into two groups forming two paths in the graph. Clearly, each path is contained in one connected component. So if the given graph has more than two connected components, the problem has no solution. The same we can say if the graph has more than four vertices of an odd degree. Indeed, each vertex in a path (even if the path contains some vertices more than once) have an even degree, exept the first vertex and the last vertex. So the union of two paths can contain no more than four odd vertices.Now consider the cases:1. One connected component, no vertices of an odd degree. So we have an euler cycle, which can be divided into two paths.2. One connected component, two odd vertices. The same with an euler path instead of euler cycle. There is a tricky case of a graph with only one edge, which cannot be divided into two nonempty paths.3. One connected component, four odd vertices. The most interesting case. Connect two vertices of an odd degree by a dummy edge. You will get a graph with an euler path. Find the euler path and delete the dummy edge - you will get two paths.4. Two connetced components, each having zero or two odd vertices. Two euler paths/cycles.5. Two connected components, four odd vertices in one and no odd vertices in another. No solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1314
        },
        {
          "title": "Codeforces Beta Round #36 (Problem C Tutorial) - Codeforces",
          "content": "Imagine that we have successfully processed first i - 1 bowls, i.e. we know height of the bottom yj for every bowl j (1 ≤ j < i). Now we are going to place i-th bowl. For each j-th already placed bowl, we will calculate the relative height of the bottom of i-th bowl above the bottom of j-th bowl, assuming that there are no other bowls. Lets denote this value by Δi, j. It is obvious that height of the new bowl is equal to the maximal of the following values: yi = max(yj + Δi, j).Now I will describe how to calculate Δi, j. Firstly, consider two trivial cases:I. ri ≥ Rj: bottom of i-th bowl rests on the top of j-th. Then Δi, j = hj.II. Ri ≤ rj: bottom of i-th bowl reaches the bottom of j-th. Then Δi, j = 0.Then there are three slightly more complicated cases. 1. ri > rj: bottom of i-th bowl gets stuck somewhere between the top and the bottom of j-th,touching it's sides. From the similarity of some triangles we get that .2. Ri ≤ Rj: top of i-th bowl gets stuck somewhere between the top and the bottom of j-th,touching it's sides. From the similarity of some triangles we get that .3. Ri > Rj: sides of i-th bowl touch the top of j-th in it's upper points. Then .Note that, for example, cases 1 and 2 do not exclude each other, so the final value of Δi, j is equal to the maximum of the values, computed in all three cases.Note that if the calculated value of Δi, j is negative, the result should be 0. Thanks to adamax for pointing it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/774",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1446
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #35 (Div. 2) and Codeforces Beta Round #36 - Codeforces - Code 1",
          "code": "Pascal / Delphi:\n\nvar\n    a, b: longint;\nbegin\n    assign(input, 'input.txt');\n    assign(output, 'output.txt');\n    reset(input);\n    rewrite(output);\n    read(a, b);\n    writeln(a * b);\n    close(input);\n    close(output);\nend.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #35 (Div. 2) and Codeforces Beta Round #36 - Codeforces - Code 2",
          "code": "C/C++:\n#include <stdio.h>int main()\n{\n    int a, b;\n\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"wt\", stdout);\n\n    scanf(\"%d %d\", &a, &b);\n    printf(\"%d\\n\", a * b);\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #35 (Div. 2) and Codeforces Beta Round #36 - Codeforces - Code 3",
          "code": "Java:\nimport java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner s = new Scanner(new File(\"input.txt\"));\n        int a = s.nextInt();\n        int b = s.nextInt();\n        s.close();\n\n        PrintWriter writer = new PrintWriter(\"output.txt\");\n        writer.println(a * b);\n        writer.close();\n    }\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 3, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    bool has_white = false;\n    string pattern = \"[.*]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(pattern, \"line\");\n        if (line.find('.') != string::npos) {\n            has_white = true;\n        }\n    }\n    ensuref(has_white, \"The model must have at least one white square ('.')\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 3, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    bool has_white = false;\n    string pattern = \"[.*]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(pattern, \"line\");\n        if (line.find('.') != string::npos) {\n            has_white = true;\n        }\n    }\n    ensuref(has_white, \"The model must have at least one white square ('.')\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 3, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    bool has_white = false;\n    string pattern = \"[.*]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(pattern, \"line\");\n        if (line.find('.') != string::npos) {\n            has_white = true;\n        }\n    }\n    ensuref(has_white, \"The model must have at least one white square ('.')\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> model(n, string(n, '.'));\n\n    if (type == \"only_one_white\") {\n        // Only one white square; rest are black\n        for (int i = 0; i < n; ++i)\n            model[i] = string(n, '*');\n        // Set one random position to '.'\n        int x = rnd.next(0, n-1);\n        int y = rnd.next(0, n-1);\n        model[x][y] = '.';\n    } else if (type == \"only_one_black\") {\n        // Only one black square; rest are white\n        for (int i = 0; i < n; ++i)\n            model[i] = string(n, '.');\n        // Set one random position to '*'\n        int x = rnd.next(0, n-1);\n        int y = rnd.next(0, n-1);\n        model[x][y] = '*';\n    } else if (type == \"checkerboard\") {\n        // Create a checkerboard pattern of '.' and '*'\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                model[i][j] = ((i + j) % 2 == 0) ? '.' : '*';\n    } else if (type == \"full_white\") {\n        // All squares are white\n        for (int i = 0; i < n; ++i)\n            model[i] = string(n, '.');\n    } else {\n        // Default is \"random\"\n        // Generate random model ensuring at least one white square\n        int num_white_squares = 0;\n        for (int i = 0; i < n; ++i) {\n            model[i].resize(n);\n            for (int j = 0; j < n; ++j) {\n                int r = rnd.next(0, 1);\n                if (r == 0) {\n                    model[i][j] = '.';\n                    ++num_white_squares;\n                } else {\n                    model[i][j] = '*';\n                }\n            }\n        }\n        // Ensure there's at least one white square\n        if (num_white_squares == 0) {\n            int x = rnd.next(0, n-1);\n            int y = rnd.next(0, n-1);\n            model[x][y] = '.';\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the model\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", model[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> model(n, string(n, '.'));\n\n    if (type == \"only_one_white\") {\n        // Only one white square; rest are black\n        for (int i = 0; i < n; ++i)\n            model[i] = string(n, '*');\n        // Set one random position to '.'\n        int x = rnd.next(0, n-1);\n        int y = rnd.next(0, n-1);\n        model[x][y] = '.';\n    } else if (type == \"only_one_black\") {\n        // Only one black square; rest are white\n        for (int i = 0; i < n; ++i)\n            model[i] = string(n, '.');\n        // Set one random position to '*'\n        int x = rnd.next(0, n-1);\n        int y = rnd.next(0, n-1);\n        model[x][y] = '*';\n    } else if (type == \"checkerboard\") {\n        // Create a checkerboard pattern of '.' and '*'\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                model[i][j] = ((i + j) % 2 == 0) ? '.' : '*';\n    } else if (type == \"full_white\") {\n        // All squares are white\n        for (int i = 0; i < n; ++i)\n            model[i] = string(n, '.');\n    } else {\n        // Default is \"random\"\n        // Generate random model ensuring at least one white square\n        int num_white_squares = 0;\n        for (int i = 0; i < n; ++i) {\n            model[i].resize(n);\n            for (int j = 0; j < n; ++j) {\n                int r = rnd.next(0, 1);\n                if (r == 0) {\n                    model[i][j] = '.';\n                    ++num_white_squares;\n                } else {\n                    model[i][j] = '*';\n                }\n            }\n        }\n        // Ensure there's at least one white square\n        if (num_white_squares == 0) {\n            int x = rnd.next(0, n-1);\n            int y = rnd.next(0, n-1);\n            model[x][y] = '.';\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the model\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", model[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# For n=2, k=1\n./gen -n 2 -k 1 -type only_one_white\n./gen -n 2 -k 1 -type only_one_black\n./gen -n 2 -k 1 -type checkerboard\n./gen -n 2 -k 1 -type full_white\n./gen -n 2 -k 1 -type random\n\n# For n=2, k=3\n./gen -n 2 -k 3 -type only_one_white\n./gen -n 2 -k 3 -type only_one_black\n./gen -n 2 -k 3 -type checkerboard\n./gen -n 2 -k 3 -type full_white\n./gen -n 2 -k 3 -type random\n\n# For n=2, k=5\n./gen -n 2 -k 5 -type only_one_white\n./gen -n 2 -k 5 -type only_one_black\n./gen -n 2 -k 5 -type checkerboard\n./gen -n 2 -k 5 -type full_white\n./gen -n 2 -k 5 -type random\n\n# For n=3, k=1\n./gen -n 3 -k 1 -type only_one_white\n./gen -n 3 -k 1 -type only_one_black\n./gen -n 3 -k 1 -type checkerboard\n./gen -n 3 -k 1 -type full_white\n./gen -n 3 -k 1 -type random\n\n# For n=3, k=3\n./gen -n 3 -k 3 -type only_one_white\n./gen -n 3 -k 3 -type only_one_black\n./gen -n 3 -k 3 -type checkerboard\n./gen -n 3 -k 3 -type full_white\n./gen -n 3 -k 3 -type random\n\n# For n=3, k=5\n./gen -n 3 -k 5 -type only_one_white\n./gen -n 3 -k 5 -type only_one_black\n./gen -n 3 -k 5 -type checkerboard\n./gen -n 3 -k 5 -type full_white\n./gen -n 3 -k 5 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:04.679442",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "36/D",
      "title": "D. New Game with a Chess Piece",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first input line contains two integers t and k (1 ≤ t ≤ 20, 1 ≤ k ≤ 109). Each of the following t lines contains two numbers n, m — the board’s length and width (1 ≤ n, m ≤ 109).",
      "output_spec": "OutputOutput t lines that can determine the outcomes of the game on every board. Write «+» if the first player is a winner, and «-» otherwise.",
      "sample_tests": "ExamplesInputCopy10 21 11 22 12 21 32 33 13 23 34 3OutputCopy-++--+-+++",
      "description": "D. New Game with a Chess Piece\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\ninputinput.txt\n\noutputoutput.txt\n\nInputThe first input line contains two integers t and k (1 ≤ t ≤ 20, 1 ≤ k ≤ 109). Each of the following t lines contains two numbers n, m — the board’s length and width (1 ≤ n, m ≤ 109).\n\nOutputOutput t lines that can determine the outcomes of the game on every board. Write «+» if the first player is a winner, and «-» otherwise.\n\nInputCopy10 21 11 22 12 21 32 33 13 23 34 3OutputCopy-++--+-+++\n\nInputCopy10 21 11 22 12 21 32 33 13 23 34 3\n\nOutputCopy-++--+-+++",
      "solutions": [
        {
          "title": "Codeforces Beta Round #35 (Div. 2) and Codeforces Beta Round #36 - Codeforces",
          "content": "Greetings to everybody. Today is an unusual day on Codeforces: two contests a day with quite small gap between them. The reason is that today the IX Regional team school programming contest is held in Saratov, and it was decided to use the tasks from it for Codeforces rounds. That's why there are many authors of today's tasks. I would like to thank the whole jury of the school contest for their excellent job. The following people are on the jury: Artem Rakhov, Nickolay Kuznetsov, Natalia Bondarenko, Gerald Agapov, Polina Bondarenko, Ivan Fefer, Edvard Davtyan, Igor Kudryashov, Pavel Kholkin and me. I believe that you know all these people as Codeforces problemsetters. Let me draw your attention to the fact that today all problems have file IO. But generators for the hacks should output to stdout as usual. Special thanks to Maria Belova and Julia Satushina for translating problem statements into English. Good luck at the contests! UPD: Results of the 35th round. We congratulate the winner, Naginchik, on his impressive debut!UPD: Results of the 36th round.Links to problem tutorials: A, B, C, D, E.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 36 和字母"
          },
          "content_length": 1112
        },
        {
          "title": "Codeforces Beta Round #36 (Problem E solution) - Codeforces",
          "content": "The problem is to divide edges of a graph into two groups forming two paths in the graph. Clearly, each path is contained in one connected component. So if the given graph has more than two connected components, the problem has no solution. The same we can say if the graph has more than four vertices of an odd degree. Indeed, each vertex in a path (even if the path contains some vertices more than once) have an even degree, exept the first vertex and the last vertex. So the union of two paths can contain no more than four odd vertices.Now consider the cases:1. One connected component, no vertices of an odd degree. So we have an euler cycle, which can be divided into two paths.2. One connected component, two odd vertices. The same with an euler path instead of euler cycle. There is a tricky case of a graph with only one edge, which cannot be divided into two nonempty paths.3. One connected component, four odd vertices. The most interesting case. Connect two vertices of an odd degree by a dummy edge. You will get a graph with an euler path. Find the euler path and delete the dummy edge - you will get two paths.4. Two connetced components, each having zero or two odd vertices. Two euler paths/cycles.5. Two connected components, four odd vertices in one and no odd vertices in another. No solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1314
        },
        {
          "title": "Codeforces Beta Round #36 (Problem C Tutorial) - Codeforces",
          "content": "Imagine that we have successfully processed first i - 1 bowls, i.e. we know height of the bottom yj for every bowl j (1 ≤ j < i). Now we are going to place i-th bowl. For each j-th already placed bowl, we will calculate the relative height of the bottom of i-th bowl above the bottom of j-th bowl, assuming that there are no other bowls. Lets denote this value by Δi, j. It is obvious that height of the new bowl is equal to the maximal of the following values: yi = max(yj + Δi, j).Now I will describe how to calculate Δi, j. Firstly, consider two trivial cases:I. ri ≥ Rj: bottom of i-th bowl rests on the top of j-th. Then Δi, j = hj.II. Ri ≤ rj: bottom of i-th bowl reaches the bottom of j-th. Then Δi, j = 0.Then there are three slightly more complicated cases. 1. ri > rj: bottom of i-th bowl gets stuck somewhere between the top and the bottom of j-th,touching it's sides. From the similarity of some triangles we get that .2. Ri ≤ Rj: top of i-th bowl gets stuck somewhere between the top and the bottom of j-th,touching it's sides. From the similarity of some triangles we get that .3. Ri > Rj: sides of i-th bowl touch the top of j-th in it's upper points. Then .Note that, for example, cases 1 and 2 do not exclude each other, so the final value of Δi, j is equal to the maximum of the values, computed in all three cases.Note that if the calculated value of Δi, j is negative, the result should be 0. Thanks to adamax for pointing it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/774",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1446
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #35 (Div. 2) and Codeforces Beta Round #36 - Codeforces - Code 1",
          "code": "Pascal / Delphi:\n\nvar\n    a, b: longint;\nbegin\n    assign(input, 'input.txt');\n    assign(output, 'output.txt');\n    reset(input);\n    rewrite(output);\n    read(a, b);\n    writeln(a * b);\n    close(input);\n    close(output);\nend.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #35 (Div. 2) and Codeforces Beta Round #36 - Codeforces - Code 2",
          "code": "C/C++:\n#include <stdio.h>int main()\n{\n    int a, b;\n\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"wt\", stdout);\n\n    scanf(\"%d %d\", &a, &b);\n    printf(\"%d\\n\", a * b);\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #35 (Div. 2) and Codeforces Beta Round #36 - Codeforces - Code 3",
          "code": "Java:\nimport java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner s = new Scanner(new File(\"input.txt\"));\n        int a = s.nextInt();\n        int b = s.nextInt();\n        s.close();\n\n        PrintWriter writer = new PrintWriter(\"output.txt\");\n        writer.println(a * b);\n        writer.close();\n    }\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/764",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 20, \"t\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 20, \"t\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 20, \"t\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    long long k = opt<long long>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %lld\\n\", t, k);\n\n    if (type == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 1000000000LL);\n            long long m = rnd.next(1LL, 1000000000LL);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < t; ++i) {\n            printf(\"1 1\\n\");\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < t; ++i) {\n            printf(\"1000000000 1000000000\\n\");\n        }\n    } else if (type == \"one_line\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = 1;\n            long long m = rnd.next(1LL, 1000000000LL);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"one_column\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 1000000000LL);\n            long long m = 1;\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"n_equals_m\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 1000000000LL);\n            long long m = n;\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"multiple_of_k\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = k * rnd.next(1LL, 1000000000LL / k);\n            long long m = k * rnd.next(1LL, 1000000000LL / k);\n            n = max(1LL, min(n, 1000000000LL));\n            m = max(1LL, min(m, 1000000000LL));\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"less_than_k\") {\n        for (int i = 0; i < t; ++i) {\n            long long max_val = max(1LL, k - 1);\n            long long n = rnd.next(1LL, max_val);\n            long long m = rnd.next(1LL, max_val);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"equal_k\") {\n        for (int i = 0; i < t; ++i) {\n            printf(\"%lld %lld\\n\", k, k);\n        }\n    } else if (type == \"k_plus_minus\") {\n        for (int i = 0; i < t; ++i) {\n            long long from = max(1LL, k - 5);\n            long long to = min(1000000000LL, k + 5);\n            long long n = rnd.next(from, to);\n            long long m = rnd.next(from, to);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 1000000000LL);\n            long long m = rnd.next(1LL, 1000000000LL);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    long long k = opt<long long>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %lld\\n\", t, k);\n\n    if (type == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 1000000000LL);\n            long long m = rnd.next(1LL, 1000000000LL);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < t; ++i) {\n            printf(\"1 1\\n\");\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < t; ++i) {\n            printf(\"1000000000 1000000000\\n\");\n        }\n    } else if (type == \"one_line\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = 1;\n            long long m = rnd.next(1LL, 1000000000LL);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"one_column\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 1000000000LL);\n            long long m = 1;\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"n_equals_m\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 1000000000LL);\n            long long m = n;\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"multiple_of_k\") {\n        for (int i = 0; i < t; ++i) {\n            long long n = k * rnd.next(1LL, 1000000000LL / k);\n            long long m = k * rnd.next(1LL, 1000000000LL / k);\n            n = max(1LL, min(n, 1000000000LL));\n            m = max(1LL, min(m, 1000000000LL));\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"less_than_k\") {\n        for (int i = 0; i < t; ++i) {\n            long long max_val = max(1LL, k - 1);\n            long long n = rnd.next(1LL, max_val);\n            long long m = rnd.next(1LL, max_val);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else if (type == \"equal_k\") {\n        for (int i = 0; i < t; ++i) {\n            printf(\"%lld %lld\\n\", k, k);\n        }\n    } else if (type == \"k_plus_minus\") {\n        for (int i = 0; i < t; ++i) {\n            long long from = max(1LL, k - 5);\n            long long to = min(1000000000LL, k + 5);\n            long long n = rnd.next(from, to);\n            long long m = rnd.next(from, to);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < t; ++i) {\n            long long n = rnd.next(1LL, 1000000000LL);\n            long long m = rnd.next(1LL, 1000000000LL);\n            printf(\"%lld %lld\\n\", n, m);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Minimal values\n./gen -t 1 -k 1 -type min\n\n# Test case 2: Maximal values\n./gen -t 1 -k 1000000000 -type max\n\n# Test case 3: Random test cases with minimal k\n./gen -t 20 -k 1 -type random\n\n# Test case 4: Random test cases with maximal k\n./gen -t 20 -k 1000000000 -type random\n\n# Test case 5: Random test cases with medium k\n./gen -t 10 -k 500 -type random\n\n# Test case 6: Random test cases with large k\n./gen -t 15 -k 123456789 -type random\n\n# Test case 7: Minimal boards with medium k\n./gen -t 5 -k 100 -type min\n\n# Test case 8: Maximal boards with medium k\n./gen -t 5 -k 100 -type max\n\n# Test case 9: Boards with one line (n = 1)\n./gen -t 10 -k 2 -type one_line\n\n# Test case 10: Boards with one column (m = 1)\n./gen -t 10 -k 2 -type one_column\n\n# Test case 11: Boards where n equals m\n./gen -t 10 -k 1000 -type n_equals_m\n\n# Test case 12: Boards where n and m are multiples of k\n./gen -t 20 -k 1000000000 -type multiple_of_k\n\n# Test case 13: Boards where n and m are multiples of k (medium k)\n./gen -t 20 -k 1000000 -type multiple_of_k\n\n# Test case 14: Boards where n and m are less than k\n./gen -t 20 -k 10 -type less_than_k\n\n# Test case 15: Boards where n and m equal k (small k)\n./gen -t 15 -k 10 -type equal_k\n\n# Test case 16: Boards where n and m equal k (max k)\n./gen -t 15 -k 1000000000 -type equal_k\n\n# Test case 17: Boards where n and m are around k (max k)\n./gen -t 20 -k 1000000000 -type k_plus_minus\n\n# Test case 18: Boards where n and m are around k (large k)\n./gen -t 20 -k 500000000 -type k_plus_minus\n\n# Test case 19: Boards where n and m are around k (k near max)\n./gen -t 20 -k 999999999 -type k_plus_minus\n\n# Test case 20: Boards where n and m are around k (k = 1)\n./gen -t 20 -k 1 -type k_plus_minus\n\n# Test case 21: Boards where n and m are less than k (k = 2)\n./gen -t 20 -k 2 -type less_than_k\n\n# Test case 22: Single test case with k = 2 and n, m less than k\n./gen -t 1 -k 2 -type less_than_k\n\n# Test case 23: Single test case with max k and n, m less than k\n./gen -t 1 -k 1000000000 -type less_than_k\n\n# Test case 24: Boards where n and m are multiples of k (k = 1)\n./gen -t 20 -k 1 -type multiple_of_k\n\n# Test case 25: Single test case where n and m equal k (max k)\n./gen -t 1 -k 1000000000 -type equal_k\n\n# Test case 26: Random test cases with large k\n./gen -t 10 -k 500000000 -type random\n\n# Test case 27: Maximal boards with minimal k\n./gen -t 20 -k 1 -type max\n\n# Test case 28: Minimal boards with maximal k\n./gen -t 20 -k 1000000000 -type min\n\n# Test case 29: Boards where n equals m and k is maximal\n./gen -t 20 -k 1000000000 -type n_equals_m\n\n# Test case 30: Boards where n equals m and k is minimal\n./gen -t 20 -k 1 -type n_equals_m\n\n# Test case 31: Random test cases with large k\n./gen -t 10 -k 123456789 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:06.289709",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "360/A",
      "title": "A. Левко и восстановление массива",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 5000) — размер массива и количество операций в записях Левко соответственно.Следующие m строк описывают операции, i-ая строка описывает i-ую операцию. Первое число в i-ой строке — целое число ti (1 ≤ ti ≤ 2), которое обозначает тип операции. Если ti = 1, то далее следуют три целых числа li, ri и di (1 ≤ li ≤ ri ≤ n,  - 104 ≤ di ≤ 104) — описание операции первого типа. Если ti = 2, то далее следуют три целых числа li, ri и mi (1 ≤ li ≤ ri ≤ n,  - 5·107 ≤ mi ≤ 5·107) — описание операции второго типа. Операции заданы в том порядке, в котором Левко выполнял их со своим массивом.",
      "output_spec": "Выходные данныеВ первой строке выведите «YES» (без кавычек), если решение существует, и «NO» (без кавычек) в противном случае.Если решение все-таки существует, то во второй строке выведите n целых чисел a1, a2, ... , an (|ai| ≤ 109) — найденный массив.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 8Выходные данныеСкопироватьYES4 7 4 7Входные данныеСкопировать4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 13Выходные данныеСкопироватьNO",
      "description": "A. Левко и восстановление массива\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 5000) — размер массива и количество операций в записях Левко соответственно.Следующие m строк описывают операции, i-ая строка описывает i-ую операцию. Первое число в i-ой строке — целое число ti (1 ≤ ti ≤ 2), которое обозначает тип операции. Если ti = 1, то далее следуют три целых числа li, ri и di (1 ≤ li ≤ ri ≤ n,  - 104 ≤ di ≤ 104) — описание операции первого типа. Если ti = 2, то далее следуют три целых числа li, ri и mi (1 ≤ li ≤ ri ≤ n,  - 5·107 ≤ mi ≤ 5·107) — описание операции второго типа. Операции заданы в том порядке, в котором Левко выполнял их со своим массивом.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите «YES» (без кавычек), если решение существует, и «NO» (без кавычек) в противном случае.Если решение все-таки существует, то во второй строке выведите n целых чисел a1, a2, ... , an (|ai| ≤ 109) — найденный массив.\n\nВыходные данные\n\nВходные данныеСкопировать4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 8Выходные данныеСкопироватьYES4 7 4 7Входные данныеСкопировать4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 13Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES4 7 4 7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 13\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Всем привет!Скоро, 10 ноября в 21.00 MSK состоится Codeforces Round #210 и его автором буду я. Это мой первый раунд на Codeforces и я очень надеюсь, что все пройдет хорошо. Спасибо Геральду Агапову (Gerald) и Виталию Аксенову(Aksenov239) за помощь в подготовке раунда.Удачи!UPD. Разбалловка в первом дивизионе: 500-1000-1500-1500-2000.Разбалловка во втором дивизионе: 500-1000-1500-2000-2500.UPD.Поздравляем победителей!Первый дивизион: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Второй дивизион: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD. Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 574
        },
        {
          "title": "Разбор Codeforces Round #210 - Codeforces",
          "content": "361A - Левко и таблицаМатрица, у которой все диагональные элементы равны k, а другие 0 удовлетворяет условие. Например для n = 4, k = 7 она будет такой:7 0 0 00 7 0 00 0 7 00 0 0 7361B - Левко и перестановкаТак, как gcd(1, m) = 1, то при n = k ответа не существует.Воспользуемся фактом, что gcd(m, m - 1) = 1 и построим такую перестановку:n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Левко и восстановление массиваНайдем для каждой позиции i такое значение b[i], что a[i] ≤ b[i]. Что бы найти эти значения, будем симулировать операции, поддерживая массив diff[i] — разница между теперешним значением i-ого элемента и его начальным значением. Если операция первого типа, то меняем нужные значения delta[i], иначе мы знаем, что a[i] + diff[i] ≤ m[i], из этого следует, что a[i] ≤ m[i] - diff[i]. Объединим все эти неравенства и мы получим массив b.Докажем, что либо b удовлетворяет условие, либо такого массива не существует. Возможны два варианта не выполнения операции второго типа: — но это невозможно из построения массива b. — но мы взяли на каждой позиции максимум, то есть мы не можем получить значение больше и чтобы при этом выполнялись все другие условия. 360B - Левко и массивСделаем бинпоиск по ответу. Чтобы проверить можно ли достичь ответа x, сделаем дп.dp[i] — это минимальное количество элементов, которые нужно изменить до i-ого, и при том i-ый элемент мы не меняем. Перебираем следующий элемент j, который мы не меняем. Тогда мы знаем, что элементы i и j мы не меняем, а все остальные между ними можем менять. Чтобы проверить можем ли мы так сделать, нужно всего лишь, чтобы выполнялось условие |aj - ai| ≤ (j - i)·xЭто так, потому что между соседними разница может быть максимум x, а между элементами i и j ровно j - i раз разница может увеличиваться на x.360C - Левко и строкиПосчитаем количество таких подстрок t, которые больше соответствующих подстрок s и начинаются в позиции i. Если t[i] < s[i], то 0. Если t[i] > s[i], то n - i. Если t[i] = s[i], то найдем ближайшую позицию j,  j > i , такую, что t[j] ≠ s[j]. Если t[j] > s[j], то нужное количество подстрок будет n - j. Если t[j] < s[j], то 0.Это мы можем переформулировать так: Если t[i] > s[i], то будет (1 + pref)·(n - i) новых подстрок, где pref означает сколько последних перед i элементов из s и t равны.Сделаем дп. dp[i][sum] — значит, что мы просмотрели i позиций и набрали sum нужных подстрок, при этом значение t и s в i-ой позиции отличаются. Будем делать ее назад. Переберем общий префикс pref этих строк и то больше или меньше t[i].Если t[i] < s[i], то dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — это посчитаем частичными сумами.Если t[i] > s[i], то dp[i][smum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Будем перебирать pref. Заметим, что sum - pref·(n - i) ≥ 0, то есть pref ≤ sum / (n - i) и pref ≤ k / (n - i). Это значит, что при нахождении значения dp[i][sum] третий цикл выполнит не больше k / (n - i) итераций. Посчитаем общее количество итераций:  =   <  k·(n + k·log  k).360D - Левко и множестваТак, как число p — простое, то должен существовать первообразный корень g по модулю p(Явно мы его не находим, пусть просто он есть). Тогда запишем каждое ai = gri. Заметим, что в i-ом множестве будут находиться все числа вида , где cj ≥ 0. Это можно записать как .Малая теорема Ферма — ap - 1 = 1 mod p. Это также значит, что ak mod p = ak mod (p - 1) mod p. Из этого следует, что может принимать все значения k·t по модулю p - 1, где t = gcd(b1, b2, ... , bm, p - 1). Заметим, что t никак не зависит от ri, поэтому мы можем сделать g = gt. Тогда все элементы с i-ого множества будут выглядить, как gri·k, где k ≥ 0. Заметим, что мы получили приктически такой же запис как и с bi в начале, сделаем то же. Заменим ri на qi, где qi = gcd(ri, p - 1). Тогда все элементы с i-ого множества будут выглядить, как gqi·k, где k ≥ 0. Это значит, что если мы запишем значения g0, g1, ..., gp - 2 в строку, то в i-ом множестве будет каждый qi-ый.Теперь чтобы найти объединение этих множеств, нам нужно применить принцип включения-исключения. Так как все числа, которые мы маем — делители p - 1, то мы можем добавлять qi по одному, поддержывая dpi — коефициэнт возле i в принцыпе включения-исключения.Нам осталось найти qi. Рассмотрим количество элементов в i-ом множестве. С одной стороны оно равно . С другой стороны это количество равно минимальному такому значению di, что aidi = 1 mod p (di — цыкл). Из того что aip - 1 = 1 mod p маем, что p - 1 делится на di. Найдем di среди делителей p - 1. Теперь .360E - Левко и играАлгоритм:Сначала будем решать задачу, может ли первый победить.Сделаем все дороги, которые можно менять, равными r[i] и запустим две Дейкстры из вершын s1 и s2. Пусть массив d1[i] — расстояное от s1 до i, d2[i] — расстояние от s2 до i. Рассмотрим дорогу из a в b, которую можно менять. Если d1[a] < d2[a], то поставим длину этой дороги равной l[i] и опять запустим две Дейкстры. Так делаем пока мы можем изменить значение хотя бы одной дороги.Если в конце у нас получилось d1[f] < d2[f], то первый может победить.Дальше повторим тоже самое, только условие d1[a] < d2[a] меняем на d1[a] ≤ d2[a]. Это нам даст, может ли первый игрок достичь ничьи.Доказательство:Будем называть ребрами только те дороги, которые Левко может менять. Причем, если мы запускаем Дейкстру из какой-то вершины, то мы учитываем все дороги. Докажем, что если существует расклад значений ребер, при котором первый игрок выигрывает, то существует такой, при котором он выигрывает и все ребра равны либо l[i], либо r[i]. Возьмем кратчайшие пути первого и второго игрока из данного расклада.Тогда если по ребру из a в b проходит только первый, то мы можем установить его значение l[i]. Доказательство: для этого ребра должно выполняться d1[a] < d2[a], потому что первому выгодно по нему проходить и он выигрывает. Это условие выполняться и после изменения значения ребра. Тогда второй либо идет по нему и проигрывает потому, что d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f] , либо не идет и тоже проигрывает потому, что расстояние первого уменьшилось, а его нет(d(x, y) — кратчайшее расстояние между x и y).Если по ребру проходит только второй, то можем поставить r[i]. Доказательство: Первый по нему проходить и так не будет, а путь второго от этого меньше не станет.Если по ребру не проходит ни один игрок поставим его равным r[i]. Доказательство: Пути игроков никак не изменяться.Если по ребру проходят оба игрока, то поставим l[i]. Доказательство: Пути обоих игроков уменьшаться на (предыдущее значение — l[i]).После каждой из этих операций если первый выигрывал, то он и продолжает выигрывать, но в конце у нас получаться все ребра равными либо l[i], либо r[i]. Рассмотрим результат выполнения алгоритма: некоторые ребра будут равны l[i], а некоторые r[i]. Назовем ребра хорошими если на них теперь стоит l[i] и плохими — если r[i].(a) Докажем, что в конце для всех хороших ребер выполняется условие d1[a] < d2[a]. Докажем от супротивного. Пусть у нас для ребра (a1, b1) выполнялось d1[a1] < d2[a1], а после нескольких итераций перестало выполняться. Пусть оно перестало выполняться, после изменения ребра (a2, b2). Тогда мы маем такие неравенства d1[a1] >  = d2[a1], d1[a2] < d2[a2]. Так как мы изменили только одно ребро и расстояние второго игрока до а1 уменьшилось, то на кратчайшем от него до а1 он идет по ребру (a2, b2).d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Получили противоречие.(b) Докажем, что в конце для всех плохих ребер выполняется условие d1[a] ≥ d2[a]. Если бы оно не выполнялось, то мы продолжили бы наш процесс.(c) Докажем, что если для какого-то ребра стало выполняться условие d1[a] < d2[a], но на этом шаге мы его не изменили(изменили другое), то это условие не может перестать выполняться. Оно доказывается аналогично (a).(d) Докажем, что если у нас какое-то подмножество хороших ребер равны l[i] и для ребра (a, b) выполняется условие, то оно не может перестать выполняться после того, как мы поставим все хорошие ребра поставить равными l[i]. Для этого просто симулируем весь процесс, применяя (c). Докажем, что при любом раскладе ребер(даже не обязательно только l[i] или r[i]) мы не можем получить ситуации, в которой для плохого ребра (a, b) выполняется условие d1[a] < d2[a].Докажем от супротивного. Пусть у нас существует такое ребро. Рассмотрит путь первого до его начала. Если на этом пути есть плохие ребра (a1, b1), то для них тоже должно выполняться условие d1[a1] < d2[a1] (Если не выполняется , то d2[a] ≤ d2[a1] + d(a1, b1) + d(b1, a) ≤ d1[a1] + d(a1, b1) + d(b1, a) = d1[a]. Противоречие.) . Возьмем первое из них. Тогда путь первого до его начала может содержать только хорошие ребра. Рассмотрим задачу, аналогичную нашей, но с финишем в вершине a1 вместо f. Плохие и хорошие ребра будут такими же, потому что они не зависят от финиша. У нас должен победить первый игрок. Изменим все ребра на l[i] и r[i] так, как мы это делали в первом пункте. Заметим, что все плохие ребра будут равными r[i], потому что первый в кратчайшем пути по них не проходит. То есть у нас получилось, что у нас только подмножество хороших ребер равны l[i] и для ребра (a1, b1) выполняется условие d1[a1] < d2[a1]. С (d) получается, что условие для этого ребра должно выполняться и после того, как мы все хорошие ребра поставим равными l[i]. А это противоречит тому, что это ребро плохое. Это значит, что при любом раскладе первому не выгодно идти через плохие ребра. Поэтому мы можем всем им поставить r[i]. Теперь l[i] мы можем поставить только подмножеству хороших ребер. Пусть для него у нас выполняется d1[F] < d2[F]. Но за свойством (d) у нас это будет выполняться и если мы все хорошие ребра поставим равными l[i]. Заметим, что у нас доказательство практически не измениться, если Левко хочет завершить игру ничьей.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 360\\s*A"
          },
          "content_length": 9841
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #210 - Codeforces - Code 1",
          "code": "Несложно доказать, что либо массив b будет удовлетворять условие, либо такого массива не существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9529",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r_i\");\n            inf.readSpace();\n            int d = inf.readInt(-10000, 10000, \"d_i\");\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r_i\");\n            inf.readSpace();\n            int m_i = inf.readInt(-50000000, 50000000, \"m_i\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r_i\");\n            inf.readSpace();\n            int d = inf.readInt(-10000, 10000, \"d_i\");\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r_i\");\n            inf.readSpace();\n            int m_i = inf.readInt(-50000000, 50000000, \"m_i\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r_i\");\n            inf.readSpace();\n            int d = inf.readInt(-10000, 10000, \"d_i\");\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r_i\");\n            inf.readSpace();\n            int m_i = inf.readInt(-50000000, 50000000, \"m_i\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Operation {\n    int type;\n    int l, r;\n    int d; // For type 1\n    int m; // For type 2\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    int n = inf.readInt();\n    int m = inf.readInt();\n    vector<Operation> ops(m);\n\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt();\n        int l = inf.readInt();\n        int r = inf.readInt();\n        if (t == 1) {\n            int d = inf.readInt();\n            ops[i] = {t, l - 1, r - 1, d, 0}; // Convert to 0-based index\n        } else if (t == 2) {\n            int mx = inf.readInt();\n            ops[i] = {t, l - 1, r - 1, 0, mx}; // Convert to 0-based index\n        } else {\n            // Invalid operation type in input\n            quitf(_fail, \"Invalid operation type in input\");\n        }\n    }\n\n    // Read judge's answer\n    string jury_ans = ans.readToken();\n    // Read participant's answer\n    string part_ans = ouf.readToken();\n\n    if (jury_ans != \"YES\" && jury_ans != \"NO\") {\n        quitf(_fail, \"Judge's output is neither YES nor NO\");\n    }\n    if (part_ans != \"YES\" && part_ans != \"NO\") {\n        quitf(_wa, \"Participant's output is neither YES nor NO\");\n    }\n\n    if (jury_ans == \"NO\") {\n        if (part_ans == \"NO\") {\n            // Both say NO, accept\n            quitf(_ok, \"Both outputs are NO\");\n        } else {\n            // Participant found a solution when judge didn't\n            quitf(_fail, \"Participant found a solution when judge says none exists\");\n        }\n    } else {\n        // Judge's answer is YES\n        if (part_ans == \"NO\") {\n            // Participant failed to find a solution\n            quitf(_wa, \"Participant failed to find a solution when one exists\");\n        }\n        // Participant's answer is YES\n        // Read participant's array\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            a[i] = ouf.readInt(-1000000000, 1000000000, format(\"a[%d]\", i + 1).c_str());\n        }\n\n        // Create a copy of participant's array to perform operations\n        vector<int> arr = a;\n\n        // Initialize max values for ranges, for type 2 operations\n        for (const auto& op : ops) {\n            if (op.type == 1) {\n                // Increase elements in range [l, r] by d\n                for (int i = op.l; i <= op.r; i++) {\n                    arr[i] += op.d;\n                }\n            } else if (op.type == 2) {\n                // Find max in range [l, r] and compare with op.m\n                int max_val = arr[op.l];\n                for (int i = op.l; i <= op.r; i++) {\n                    if (arr[i] > max_val) {\n                        max_val = arr[i];\n                    }\n                }\n                if (max_val != op.m) {\n                    quitf(_wa, \"At operation %d, expected max %d, found %d\", &op - &ops[0] + 1, op.m, max_val);\n                }\n            }\n        }\n        // All operations matched\n        quitf(_ok, \"Participant's array is valid\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        printf(\"%d %d\\n\", n, m);\n\n        vector<int> a(n+1, 0); // 1-based indexing\n        vector<string> operations;\n\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n\n            if (op_type == 1) {\n                int d = rnd.next(-2000, 2000);\n                for (int j = l; j <= r; ++j) {\n                    a[j] += d;\n                    if (a[j] > 1e9) a[j] = 1e9;\n                    if (a[j] < -1e9) a[j] = -1e9;\n                }\n                operations.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(d));\n            } else {\n                int m_i = a[l];\n                for (int j = l+1; j <= r; ++j) {\n                    if (a[j] > m_i) m_i = a[j];\n                }\n                operations.push_back(\"2 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(m_i));\n            }\n        }\n\n        for (auto op : operations) {\n            printf(\"%s\\n\", op.c_str());\n        }\n    } else if (type == \"only_type1\") {\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int d = rnd.next(-10000, 10000);\n            printf(\"1 %d %d %d\\n\", l, r, d);\n        }\n    } else if (type == \"only_type2\") {\n        vector<int> a(n+1);\n        for (int i = 1; i <= n; ++i) {\n            a[i] = rnd.next(-50000000, 50000000);\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int m_i = a[l];\n            for (int j = l+1; j <= r; ++j) {\n                if (a[j] > m_i) m_i = a[j];\n            }\n            printf(\"2 %d %d %d\\n\", l, r, m_i);\n        }\n    } else if (type == \"conflict\") {\n        printf(\"%d %d\\n\", n, m);\n\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n); // l <= r <= n\n        int m_i1 = rnd.next(-50000000, 50000000);\n        int m_i2 = m_i1 + rnd.next(1, 10); // Ensure m_i2 > m_i1\n\n        printf(\"2 %d %d %d\\n\", l, r, m_i1);\n        printf(\"2 %d %d %d\\n\", l, r, m_i2);\n\n        for (int i = 2; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(1, n);\n            if (l_i > r_i) swap(l_i, r_i);\n\n            if (op_type == 1) {\n                int d = rnd.next(-2000, 2000);\n                printf(\"1 %d %d %d\\n\", l_i, r_i, d);\n            } else {\n                int m_i = rnd.next(-50000000, 50000000);\n                printf(\"2 %d %d %d\\n\", l_i, r_i, m_i);\n            }\n        }\n    } else if (type == \"maximal\") {\n        printf(\"%d %d\\n\", n, m);\n        vector<int> a(n+1, 0);\n        vector<string> operations;\n\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n\n            int l = 1;\n            int r = n;\n\n            if (op_type == 1) {\n                int d = rnd.next(-10000, 10000);\n                for (int j = l; j <= r; ++j) {\n                    a[j] += d;\n                    if (a[j] > 1e9) a[j] = 1e9;\n                    if (a[j] < -1e9) a[j] = -1e9;\n                }\n                operations.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(d));\n            } else {\n                int m_i = *max_element(a.begin()+1, a.end());\n                operations.push_back(\"2 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(m_i));\n            }\n        }\n\n        for (auto op : operations) {\n            printf(\"%s\\n\", op.c_str());\n        }\n    } else if (type == \"edge_cases\") {\n        printf(\"%d %d\\n\", n, m);\n\n        // Generate operations with minimal ranges\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = l; // Minimal range\n\n            if (op_type == 1) {\n                int d = rnd.next(-10000, 10000);\n                printf(\"1 %d %d %d\\n\", l, r, d);\n            } else {\n                int m_i = rnd.next(-50000000, 50000000);\n                printf(\"2 %d %d %d\\n\", l, r, m_i);\n            }\n        }\n    } else {\n        printf(\"Unsupported type: %s\\n\", type.c_str());\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        printf(\"%d %d\\n\", n, m);\n\n        vector<int> a(n+1, 0); // 1-based indexing\n        vector<string> operations;\n\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n\n            if (op_type == 1) {\n                int d = rnd.next(-2000, 2000);\n                for (int j = l; j <= r; ++j) {\n                    a[j] += d;\n                    if (a[j] > 1e9) a[j] = 1e9;\n                    if (a[j] < -1e9) a[j] = -1e9;\n                }\n                operations.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(d));\n            } else {\n                int m_i = a[l];\n                for (int j = l+1; j <= r; ++j) {\n                    if (a[j] > m_i) m_i = a[j];\n                }\n                operations.push_back(\"2 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(m_i));\n            }\n        }\n\n        for (auto op : operations) {\n            printf(\"%s\\n\", op.c_str());\n        }\n    } else if (type == \"only_type1\") {\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int d = rnd.next(-10000, 10000);\n            printf(\"1 %d %d %d\\n\", l, r, d);\n        }\n    } else if (type == \"only_type2\") {\n        vector<int> a(n+1);\n        for (int i = 1; i <= n; ++i) {\n            a[i] = rnd.next(-50000000, 50000000);\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int m_i = a[l];\n            for (int j = l+1; j <= r; ++j) {\n                if (a[j] > m_i) m_i = a[j];\n            }\n            printf(\"2 %d %d %d\\n\", l, r, m_i);\n        }\n    } else if (type == \"conflict\") {\n        printf(\"%d %d\\n\", n, m);\n\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n); // l <= r <= n\n        int m_i1 = rnd.next(-50000000, 50000000);\n        int m_i2 = m_i1 + rnd.next(1, 10); // Ensure m_i2 > m_i1\n\n        printf(\"2 %d %d %d\\n\", l, r, m_i1);\n        printf(\"2 %d %d %d\\n\", l, r, m_i2);\n\n        for (int i = 2; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(1, n);\n            if (l_i > r_i) swap(l_i, r_i);\n\n            if (op_type == 1) {\n                int d = rnd.next(-2000, 2000);\n                printf(\"1 %d %d %d\\n\", l_i, r_i, d);\n            } else {\n                int m_i = rnd.next(-50000000, 50000000);\n                printf(\"2 %d %d %d\\n\", l_i, r_i, m_i);\n            }\n        }\n    } else if (type == \"maximal\") {\n        printf(\"%d %d\\n\", n, m);\n        vector<int> a(n+1, 0);\n        vector<string> operations;\n\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n\n            int l = 1;\n            int r = n;\n\n            if (op_type == 1) {\n                int d = rnd.next(-10000, 10000);\n                for (int j = l; j <= r; ++j) {\n                    a[j] += d;\n                    if (a[j] > 1e9) a[j] = 1e9;\n                    if (a[j] < -1e9) a[j] = -1e9;\n                }\n                operations.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(d));\n            } else {\n                int m_i = *max_element(a.begin()+1, a.end());\n                operations.push_back(\"2 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(m_i));\n            }\n        }\n\n        for (auto op : operations) {\n            printf(\"%s\\n\", op.c_str());\n        }\n    } else if (type == \"edge_cases\") {\n        printf(\"%d %d\\n\", n, m);\n\n        // Generate operations with minimal ranges\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = l; // Minimal range\n\n            if (op_type == 1) {\n                int d = rnd.next(-10000, 10000);\n                printf(\"1 %d %d %d\\n\", l, r, d);\n            } else {\n                int m_i = rnd.next(-50000000, 50000000);\n                printf(\"2 %d %d %d\\n\", l, r, m_i);\n            }\n        }\n    } else {\n        printf(\"Unsupported type: %s\\n\", type.c_str());\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type only_type2\n./gen -n 2 -m 2 -type conflict\n\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type only_type1\n./gen -n 5 -m 5 -type only_type2\n./gen -n 5 -m 5 -type conflict\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type conflict\n\n./gen -n 5000 -m 5000 -type random\n./gen -n 5000 -m 5000 -type only_type1\n./gen -n 5000 -m 5000 -type only_type2\n./gen -n 5000 -m 5000 -type conflict\n\n./gen -n 5000 -m 5000 -type edge_cases\n\n./gen -n 5000 -m 5000 -type maximal\n\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 1 -type only_type1\n./gen -n 2 -m 1 -type only_type2\n\n./gen -n 10 -m 1 -type random\n./gen -n 10 -m 1 -type only_type1\n./gen -n 10 -m 1 -type only_type2\n\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 100 -m 10 -type conflict\n\n./gen -n 5000 -m 5000 -type only_type2\n./gen -n 5000 -m 5000 -type only_type1\n\n./gen -n 5000 -m 5000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:07.874719",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "360/B",
      "title": "B. Левко и массив",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и k (1 ≤ k ≤ n ≤ 2000). Во второй строке через пробел записаны целые числа a1, a2, ... , an ( - 109 ≤ ai ≤ 109).",
      "output_spec": "Выходные данныеЕдинственное число — минимальное значение c(a), которое может получить Левко.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 24 7 4 7 4Выходные данныеСкопировать0Входные данныеСкопировать3 1-100 0 100Выходные данныеСкопировать100Входные данныеСкопировать6 31 2 3 7 8 9Выходные данныеСкопировать1",
      "description": "B. Левко и массив\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и k (1 ≤ k ≤ n ≤ 2000). Во второй строке через пробел записаны целые числа a1, a2, ... , an ( - 109 ≤ ai ≤ 109).\n\nВходные данные\n\nВыходные данныеЕдинственное число — минимальное значение c(a), которое может получить Левко.\n\nВыходные данные\n\nВходные данныеСкопировать5 24 7 4 7 4Выходные данныеСкопировать0Входные данныеСкопировать3 1-100 0 100Выходные данныеСкопировать100Входные данныеСкопировать6 31 2 3 7 8 9Выходные данныеСкопировать1\n\nВходные данныеСкопировать5 24 7 4 7 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 1-100 0 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать100\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 31 2 3 7 8 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Левко может изменить второй и четвертый элементы и получить массив: 4, 4, 4, 4, 4.В третьем примере он может получить массив: 1, 2, 3, 4, 5, 6.",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Всем привет!Скоро, 10 ноября в 21.00 MSK состоится Codeforces Round #210 и его автором буду я. Это мой первый раунд на Codeforces и я очень надеюсь, что все пройдет хорошо. Спасибо Геральду Агапову (Gerald) и Виталию Аксенову(Aksenov239) за помощь в подготовке раунда.Удачи!UPD. Разбалловка в первом дивизионе: 500-1000-1500-1500-2000.Разбалловка во втором дивизионе: 500-1000-1500-2000-2500.UPD.Поздравляем победителей!Первый дивизион: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Второй дивизион: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD. Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 574
        },
        {
          "title": "Разбор Codeforces Round #210 - Codeforces",
          "content": "361A - Левко и таблицаМатрица, у которой все диагональные элементы равны k, а другие 0 удовлетворяет условие. Например для n = 4, k = 7 она будет такой:7 0 0 00 7 0 00 0 7 00 0 0 7361B - Левко и перестановкаТак, как gcd(1, m) = 1, то при n = k ответа не существует.Воспользуемся фактом, что gcd(m, m - 1) = 1 и построим такую перестановку:n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Левко и восстановление массиваНайдем для каждой позиции i такое значение b[i], что a[i] ≤ b[i]. Что бы найти эти значения, будем симулировать операции, поддерживая массив diff[i] — разница между теперешним значением i-ого элемента и его начальным значением. Если операция первого типа, то меняем нужные значения delta[i], иначе мы знаем, что a[i] + diff[i] ≤ m[i], из этого следует, что a[i] ≤ m[i] - diff[i]. Объединим все эти неравенства и мы получим массив b.Докажем, что либо b удовлетворяет условие, либо такого массива не существует. Возможны два варианта не выполнения операции второго типа: — но это невозможно из построения массива b. — но мы взяли на каждой позиции максимум, то есть мы не можем получить значение больше и чтобы при этом выполнялись все другие условия. 360B - Левко и массивСделаем бинпоиск по ответу. Чтобы проверить можно ли достичь ответа x, сделаем дп.dp[i] — это минимальное количество элементов, которые нужно изменить до i-ого, и при том i-ый элемент мы не меняем. Перебираем следующий элемент j, который мы не меняем. Тогда мы знаем, что элементы i и j мы не меняем, а все остальные между ними можем менять. Чтобы проверить можем ли мы так сделать, нужно всего лишь, чтобы выполнялось условие |aj - ai| ≤ (j - i)·xЭто так, потому что между соседними разница может быть максимум x, а между элементами i и j ровно j - i раз разница может увеличиваться на x.360C - Левко и строкиПосчитаем количество таких подстрок t, которые больше соответствующих подстрок s и начинаются в позиции i. Если t[i] < s[i], то 0. Если t[i] > s[i], то n - i. Если t[i] = s[i], то найдем ближайшую позицию j,  j > i , такую, что t[j] ≠ s[j]. Если t[j] > s[j], то нужное количество подстрок будет n - j. Если t[j] < s[j], то 0.Это мы можем переформулировать так: Если t[i] > s[i], то будет (1 + pref)·(n - i) новых подстрок, где pref означает сколько последних перед i элементов из s и t равны.Сделаем дп. dp[i][sum] — значит, что мы просмотрели i позиций и набрали sum нужных подстрок, при этом значение t и s в i-ой позиции отличаются. Будем делать ее назад. Переберем общий префикс pref этих строк и то больше или меньше t[i].Если t[i] < s[i], то dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — это посчитаем частичными сумами.Если t[i] > s[i], то dp[i][smum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Будем перебирать pref. Заметим, что sum - pref·(n - i) ≥ 0, то есть pref ≤ sum / (n - i) и pref ≤ k / (n - i). Это значит, что при нахождении значения dp[i][sum] третий цикл выполнит не больше k / (n - i) итераций. Посчитаем общее количество итераций:  =   <  k·(n + k·log  k).360D - Левко и множестваТак, как число p — простое, то должен существовать первообразный корень g по модулю p(Явно мы его не находим, пусть просто он есть). Тогда запишем каждое ai = gri. Заметим, что в i-ом множестве будут находиться все числа вида , где cj ≥ 0. Это можно записать как .Малая теорема Ферма — ap - 1 = 1 mod p. Это также значит, что ak mod p = ak mod (p - 1) mod p. Из этого следует, что может принимать все значения k·t по модулю p - 1, где t = gcd(b1, b2, ... , bm, p - 1). Заметим, что t никак не зависит от ri, поэтому мы можем сделать g = gt. Тогда все элементы с i-ого множества будут выглядить, как gri·k, где k ≥ 0. Заметим, что мы получили приктически такой же запис как и с bi в начале, сделаем то же. Заменим ri на qi, где qi = gcd(ri, p - 1). Тогда все элементы с i-ого множества будут выглядить, как gqi·k, где k ≥ 0. Это значит, что если мы запишем значения g0, g1, ..., gp - 2 в строку, то в i-ом множестве будет каждый qi-ый.Теперь чтобы найти объединение этих множеств, нам нужно применить принцип включения-исключения. Так как все числа, которые мы маем — делители p - 1, то мы можем добавлять qi по одному, поддержывая dpi — коефициэнт возле i в принцыпе включения-исключения.Нам осталось найти qi. Рассмотрим количество элементов в i-ом множестве. С одной стороны оно равно . С другой стороны это количество равно минимальному такому значению di, что aidi = 1 mod p (di — цыкл). Из того что aip - 1 = 1 mod p маем, что p - 1 делится на di. Найдем di среди делителей p - 1. Теперь .360E - Левко и играАлгоритм:Сначала будем решать задачу, может ли первый победить.Сделаем все дороги, которые можно менять, равными r[i] и запустим две Дейкстры из вершын s1 и s2. Пусть массив d1[i] — расстояное от s1 до i, d2[i] — расстояние от s2 до i. Рассмотрим дорогу из a в b, которую можно менять. Если d1[a] < d2[a], то поставим длину этой дороги равной l[i] и опять запустим две Дейкстры. Так делаем пока мы можем изменить значение хотя бы одной дороги.Если в конце у нас получилось d1[f] < d2[f], то первый может победить.Дальше повторим тоже самое, только условие d1[a] < d2[a] меняем на d1[a] ≤ d2[a]. Это нам даст, может ли первый игрок достичь ничьи.Доказательство:Будем называть ребрами только те дороги, которые Левко может менять. Причем, если мы запускаем Дейкстру из какой-то вершины, то мы учитываем все дороги. Докажем, что если существует расклад значений ребер, при котором первый игрок выигрывает, то существует такой, при котором он выигрывает и все ребра равны либо l[i], либо r[i]. Возьмем кратчайшие пути первого и второго игрока из данного расклада.Тогда если по ребру из a в b проходит только первый, то мы можем установить его значение l[i]. Доказательство: для этого ребра должно выполняться d1[a] < d2[a], потому что первому выгодно по нему проходить и он выигрывает. Это условие выполняться и после изменения значения ребра. Тогда второй либо идет по нему и проигрывает потому, что d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f] , либо не идет и тоже проигрывает потому, что расстояние первого уменьшилось, а его нет(d(x, y) — кратчайшее расстояние между x и y).Если по ребру проходит только второй, то можем поставить r[i]. Доказательство: Первый по нему проходить и так не будет, а путь второго от этого меньше не станет.Если по ребру не проходит ни один игрок поставим его равным r[i]. Доказательство: Пути игроков никак не изменяться.Если по ребру проходят оба игрока, то поставим l[i]. Доказательство: Пути обоих игроков уменьшаться на (предыдущее значение — l[i]).После каждой из этих операций если первый выигрывал, то он и продолжает выигрывать, но в конце у нас получаться все ребра равными либо l[i], либо r[i]. Рассмотрим результат выполнения алгоритма: некоторые ребра будут равны l[i], а некоторые r[i]. Назовем ребра хорошими если на них теперь стоит l[i] и плохими — если r[i].(a) Докажем, что в конце для всех хороших ребер выполняется условие d1[a] < d2[a]. Докажем от супротивного. Пусть у нас для ребра (a1, b1) выполнялось d1[a1] < d2[a1], а после нескольких итераций перестало выполняться. Пусть оно перестало выполняться, после изменения ребра (a2, b2). Тогда мы маем такие неравенства d1[a1] >  = d2[a1], d1[a2] < d2[a2]. Так как мы изменили только одно ребро и расстояние второго игрока до а1 уменьшилось, то на кратчайшем от него до а1 он идет по ребру (a2, b2).d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Получили противоречие.(b) Докажем, что в конце для всех плохих ребер выполняется условие d1[a] ≥ d2[a]. Если бы оно не выполнялось, то мы продолжили бы наш процесс.(c) Докажем, что если для какого-то ребра стало выполняться условие d1[a] < d2[a], но на этом шаге мы его не изменили(изменили другое), то это условие не может перестать выполняться. Оно доказывается аналогично (a).(d) Докажем, что если у нас какое-то подмножество хороших ребер равны l[i] и для ребра (a, b) выполняется условие, то оно не может перестать выполняться после того, как мы поставим все хорошие ребра поставить равными l[i]. Для этого просто симулируем весь процесс, применяя (c). Докажем, что при любом раскладе ребер(даже не обязательно только l[i] или r[i]) мы не можем получить ситуации, в которой для плохого ребра (a, b) выполняется условие d1[a] < d2[a].Докажем от супротивного. Пусть у нас существует такое ребро. Рассмотрит путь первого до его начала. Если на этом пути есть плохие ребра (a1, b1), то для них тоже должно выполняться условие d1[a1] < d2[a1] (Если не выполняется , то d2[a] ≤ d2[a1] + d(a1, b1) + d(b1, a) ≤ d1[a1] + d(a1, b1) + d(b1, a) = d1[a]. Противоречие.) . Возьмем первое из них. Тогда путь первого до его начала может содержать только хорошие ребра. Рассмотрим задачу, аналогичную нашей, но с финишем в вершине a1 вместо f. Плохие и хорошие ребра будут такими же, потому что они не зависят от финиша. У нас должен победить первый игрок. Изменим все ребра на l[i] и r[i] так, как мы это делали в первом пункте. Заметим, что все плохие ребра будут равными r[i], потому что первый в кратчайшем пути по них не проходит. То есть у нас получилось, что у нас только подмножество хороших ребер равны l[i] и для ребра (a1, b1) выполняется условие d1[a1] < d2[a1]. С (d) получается, что условие для этого ребра должно выполняться и после того, как мы все хорошие ребра поставим равными l[i]. А это противоречит тому, что это ребро плохое. Это значит, что при любом раскладе первому не выгодно идти через плохие ребра. Поэтому мы можем всем им поставить r[i]. Теперь l[i] мы можем поставить только подмножеству хороших ребер. Пусть для него у нас выполняется d1[F] < d2[F]. Но за свойством (d) у нас это будет выполняться и если мы все хорошие ребра поставим равными l[i]. Заметим, что у нас доказательство практически не измениться, если Левко хочет завершить игру ничьей.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 360\\s*B"
          },
          "content_length": 9841
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #210 - Codeforces - Code 1",
          "code": "Несложно доказать, что либо массив b будет удовлетворять условие, либо такого массива не существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9529",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int val = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"max_min\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1) ? -1000000000 : 1000000000;\n    } else if (type == \"alternating\") {\n        int vals[2] = { -1000000000, 1000000000 };\n        for(int i = 0; i < n; ++i)\n            a[i] = vals[i % 2];\n    } else if (type == \"increasing\") {\n        int start = rnd.next(-1000000000, 1000000000 - n);\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(-1000000000 + n, 1000000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"random_positive\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"random_negative\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, -1);\n    } else if (type == \"almost_same\") {\n        int val = rnd.next(-1000000000 + 1000, 1000000000 - 1000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val + rnd.next(-1000, 1000);\n    } else {\n        // default random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int val = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"max_min\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1) ? -1000000000 : 1000000000;\n    } else if (type == \"alternating\") {\n        int vals[2] = { -1000000000, 1000000000 };\n        for(int i = 0; i < n; ++i)\n            a[i] = vals[i % 2];\n    } else if (type == \"increasing\") {\n        int start = rnd.next(-1000000000, 1000000000 - n);\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(-1000000000 + n, 1000000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"random_positive\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"random_negative\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, -1);\n    } else if (type == \"almost_same\") {\n        int val = rnd.next(-1000000000 + 1000, 1000000000 - 1000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val + rnd.next(-1000, 1000);\n    } else {\n        // default random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, k = 0\n./gen -n 1 -k 0 -type all_same\n./gen -n 1 -k 0 -type random\n./gen -n 1 -k 0 -type random_positive\n./gen -n 1 -k 0 -type random_negative\n\n# Small n, k = n\n./gen -n 1 -k 1 -type all_same\n./gen -n 1 -k 1 -type random\n\n# Edge cases n = 2, k = 0\n./gen -n 2 -k 0 -type max_min\n./gen -n 2 -k 0 -type random\n./gen -n 2 -k 0 -type almost_same\n\n# Mid n, k = 0\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 0 -type almost_same\n\n# Mid n, k = n\n./gen -n 1000 -k 1000 -type random\n./gen -n 1000 -k 1000 -type decreasing\n./gen -n 1000 -k 1000 -type increasing\n\n# Max n, k = 0\n./gen -n 2000 -k 0 -type random\n./gen -n 2000 -k 0 -type all_same\n\n# Max n, k = n/2\n./gen -n 2000 -k 1000 -type random\n./gen -n 2000 -k 1000 -type max_min\n\n# Max n, k = n\n./gen -n 2000 -k 2000 -type random\n./gen -n 2000 -k 2000 -type increasing\n./gen -n 2000 -k 2000 -type decreasing\n\n# Random k\n./gen -n 2000 -k 1234 -type random_negative\n./gen -n 2000 -k 1500 -type random_positive\n\n# Special cases\n./gen -n 2000 -k 1 -type max_min\n./gen -n 2000 -k 0 -type alternating\n\n# Varying n\n./gen -n 100 -k 20 -type random\n./gen -n 500 -k 100 -type almost_same\n./gen -n 999 -k 0 -type alternating\n./gen -n 1500 -k 500 -type random_positive\n./gen -n 1800 -k 300 -type random_negative\n\n# Edge n\n./gen -n 2 -k 1 -type max_min\n./gen -n 2 -k 2 -type random_negative\n\n# Large k\n./gen -n 2000 -k 1999 -type random\n./gen -n 2000 -k 2000 -type all_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:09.855091",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "360/C",
      "title": "C. Левко и строки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 2000).Во второй строке записана непустая строка s длины n. Строка s состоит только из строчных латинских букв.",
      "output_spec": "Выходные данныеВыведите единственное число — ответ на задачу по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2yzВыходные данныеСкопировать26Входные данныеСкопировать2 3yxВыходные данныеСкопировать2Входные данныеСкопировать4 7abcdВыходные данныеСкопировать21962",
      "description": "C. Левко и строки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 2000).Во второй строке записана непустая строка s длины n. Строка s состоит только из строчных латинских букв.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — ответ на задачу по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать2 2yzВыходные данныеСкопировать26Входные данныеСкопировать2 3yxВыходные данныеСкопировать2Входные данныеСкопировать4 7abcdВыходные данныеСкопировать21962\n\nВходные данныеСкопировать2 2yz\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать26\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3yx\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 7abcd\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21962\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Всем привет!Скоро, 10 ноября в 21.00 MSK состоится Codeforces Round #210 и его автором буду я. Это мой первый раунд на Codeforces и я очень надеюсь, что все пройдет хорошо. Спасибо Геральду Агапову (Gerald) и Виталию Аксенову(Aksenov239) за помощь в подготовке раунда.Удачи!UPD. Разбалловка в первом дивизионе: 500-1000-1500-1500-2000.Разбалловка во втором дивизионе: 500-1000-1500-2000-2500.UPD.Поздравляем победителей!Первый дивизион: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Второй дивизион: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD. Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 574
        },
        {
          "title": "Разбор Codeforces Round #210 - Codeforces",
          "content": "361A - Левко и таблицаМатрица, у которой все диагональные элементы равны k, а другие 0 удовлетворяет условие. Например для n = 4, k = 7 она будет такой:7 0 0 00 7 0 00 0 7 00 0 0 7361B - Левко и перестановкаТак, как gcd(1, m) = 1, то при n = k ответа не существует.Воспользуемся фактом, что gcd(m, m - 1) = 1 и построим такую перестановку:n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Левко и восстановление массиваНайдем для каждой позиции i такое значение b[i], что a[i] ≤ b[i]. Что бы найти эти значения, будем симулировать операции, поддерживая массив diff[i] — разница между теперешним значением i-ого элемента и его начальным значением. Если операция первого типа, то меняем нужные значения delta[i], иначе мы знаем, что a[i] + diff[i] ≤ m[i], из этого следует, что a[i] ≤ m[i] - diff[i]. Объединим все эти неравенства и мы получим массив b.Докажем, что либо b удовлетворяет условие, либо такого массива не существует. Возможны два варианта не выполнения операции второго типа: — но это невозможно из построения массива b. — но мы взяли на каждой позиции максимум, то есть мы не можем получить значение больше и чтобы при этом выполнялись все другие условия. 360B - Левко и массивСделаем бинпоиск по ответу. Чтобы проверить можно ли достичь ответа x, сделаем дп.dp[i] — это минимальное количество элементов, которые нужно изменить до i-ого, и при том i-ый элемент мы не меняем. Перебираем следующий элемент j, который мы не меняем. Тогда мы знаем, что элементы i и j мы не меняем, а все остальные между ними можем менять. Чтобы проверить можем ли мы так сделать, нужно всего лишь, чтобы выполнялось условие |aj - ai| ≤ (j - i)·xЭто так, потому что между соседними разница может быть максимум x, а между элементами i и j ровно j - i раз разница может увеличиваться на x.360C - Левко и строкиПосчитаем количество таких подстрок t, которые больше соответствующих подстрок s и начинаются в позиции i. Если t[i] < s[i], то 0. Если t[i] > s[i], то n - i. Если t[i] = s[i], то найдем ближайшую позицию j,  j > i , такую, что t[j] ≠ s[j]. Если t[j] > s[j], то нужное количество подстрок будет n - j. Если t[j] < s[j], то 0.Это мы можем переформулировать так: Если t[i] > s[i], то будет (1 + pref)·(n - i) новых подстрок, где pref означает сколько последних перед i элементов из s и t равны.Сделаем дп. dp[i][sum] — значит, что мы просмотрели i позиций и набрали sum нужных подстрок, при этом значение t и s в i-ой позиции отличаются. Будем делать ее назад. Переберем общий префикс pref этих строк и то больше или меньше t[i].Если t[i] < s[i], то dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — это посчитаем частичными сумами.Если t[i] > s[i], то dp[i][smum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Будем перебирать pref. Заметим, что sum - pref·(n - i) ≥ 0, то есть pref ≤ sum / (n - i) и pref ≤ k / (n - i). Это значит, что при нахождении значения dp[i][sum] третий цикл выполнит не больше k / (n - i) итераций. Посчитаем общее количество итераций:  =   <  k·(n + k·log  k).360D - Левко и множестваТак, как число p — простое, то должен существовать первообразный корень g по модулю p(Явно мы его не находим, пусть просто он есть). Тогда запишем каждое ai = gri. Заметим, что в i-ом множестве будут находиться все числа вида , где cj ≥ 0. Это можно записать как .Малая теорема Ферма — ap - 1 = 1 mod p. Это также значит, что ak mod p = ak mod (p - 1) mod p. Из этого следует, что может принимать все значения k·t по модулю p - 1, где t = gcd(b1, b2, ... , bm, p - 1). Заметим, что t никак не зависит от ri, поэтому мы можем сделать g = gt. Тогда все элементы с i-ого множества будут выглядить, как gri·k, где k ≥ 0. Заметим, что мы получили приктически такой же запис как и с bi в начале, сделаем то же. Заменим ri на qi, где qi = gcd(ri, p - 1). Тогда все элементы с i-ого множества будут выглядить, как gqi·k, где k ≥ 0. Это значит, что если мы запишем значения g0, g1, ..., gp - 2 в строку, то в i-ом множестве будет каждый qi-ый.Теперь чтобы найти объединение этих множеств, нам нужно применить принцип включения-исключения. Так как все числа, которые мы маем — делители p - 1, то мы можем добавлять qi по одному, поддержывая dpi — коефициэнт возле i в принцыпе включения-исключения.Нам осталось найти qi. Рассмотрим количество элементов в i-ом множестве. С одной стороны оно равно . С другой стороны это количество равно минимальному такому значению di, что aidi = 1 mod p (di — цыкл). Из того что aip - 1 = 1 mod p маем, что p - 1 делится на di. Найдем di среди делителей p - 1. Теперь .360E - Левко и играАлгоритм:Сначала будем решать задачу, может ли первый победить.Сделаем все дороги, которые можно менять, равными r[i] и запустим две Дейкстры из вершын s1 и s2. Пусть массив d1[i] — расстояное от s1 до i, d2[i] — расстояние от s2 до i. Рассмотрим дорогу из a в b, которую можно менять. Если d1[a] < d2[a], то поставим длину этой дороги равной l[i] и опять запустим две Дейкстры. Так делаем пока мы можем изменить значение хотя бы одной дороги.Если в конце у нас получилось d1[f] < d2[f], то первый может победить.Дальше повторим тоже самое, только условие d1[a] < d2[a] меняем на d1[a] ≤ d2[a]. Это нам даст, может ли первый игрок достичь ничьи.Доказательство:Будем называть ребрами только те дороги, которые Левко может менять. Причем, если мы запускаем Дейкстру из какой-то вершины, то мы учитываем все дороги. Докажем, что если существует расклад значений ребер, при котором первый игрок выигрывает, то существует такой, при котором он выигрывает и все ребра равны либо l[i], либо r[i]. Возьмем кратчайшие пути первого и второго игрока из данного расклада.Тогда если по ребру из a в b проходит только первый, то мы можем установить его значение l[i]. Доказательство: для этого ребра должно выполняться d1[a] < d2[a], потому что первому выгодно по нему проходить и он выигрывает. Это условие выполняться и после изменения значения ребра. Тогда второй либо идет по нему и проигрывает потому, что d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f] , либо не идет и тоже проигрывает потому, что расстояние первого уменьшилось, а его нет(d(x, y) — кратчайшее расстояние между x и y).Если по ребру проходит только второй, то можем поставить r[i]. Доказательство: Первый по нему проходить и так не будет, а путь второго от этого меньше не станет.Если по ребру не проходит ни один игрок поставим его равным r[i]. Доказательство: Пути игроков никак не изменяться.Если по ребру проходят оба игрока, то поставим l[i]. Доказательство: Пути обоих игроков уменьшаться на (предыдущее значение — l[i]).После каждой из этих операций если первый выигрывал, то он и продолжает выигрывать, но в конце у нас получаться все ребра равными либо l[i], либо r[i]. Рассмотрим результат выполнения алгоритма: некоторые ребра будут равны l[i], а некоторые r[i]. Назовем ребра хорошими если на них теперь стоит l[i] и плохими — если r[i].(a) Докажем, что в конце для всех хороших ребер выполняется условие d1[a] < d2[a]. Докажем от супротивного. Пусть у нас для ребра (a1, b1) выполнялось d1[a1] < d2[a1], а после нескольких итераций перестало выполняться. Пусть оно перестало выполняться, после изменения ребра (a2, b2). Тогда мы маем такие неравенства d1[a1] >  = d2[a1], d1[a2] < d2[a2]. Так как мы изменили только одно ребро и расстояние второго игрока до а1 уменьшилось, то на кратчайшем от него до а1 он идет по ребру (a2, b2).d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Получили противоречие.(b) Докажем, что в конце для всех плохих ребер выполняется условие d1[a] ≥ d2[a]. Если бы оно не выполнялось, то мы продолжили бы наш процесс.(c) Докажем, что если для какого-то ребра стало выполняться условие d1[a] < d2[a], но на этом шаге мы его не изменили(изменили другое), то это условие не может перестать выполняться. Оно доказывается аналогично (a).(d) Докажем, что если у нас какое-то подмножество хороших ребер равны l[i] и для ребра (a, b) выполняется условие, то оно не может перестать выполняться после того, как мы поставим все хорошие ребра поставить равными l[i]. Для этого просто симулируем весь процесс, применяя (c). Докажем, что при любом раскладе ребер(даже не обязательно только l[i] или r[i]) мы не можем получить ситуации, в которой для плохого ребра (a, b) выполняется условие d1[a] < d2[a].Докажем от супротивного. Пусть у нас существует такое ребро. Рассмотрит путь первого до его начала. Если на этом пути есть плохие ребра (a1, b1), то для них тоже должно выполняться условие d1[a1] < d2[a1] (Если не выполняется , то d2[a] ≤ d2[a1] + d(a1, b1) + d(b1, a) ≤ d1[a1] + d(a1, b1) + d(b1, a) = d1[a]. Противоречие.) . Возьмем первое из них. Тогда путь первого до его начала может содержать только хорошие ребра. Рассмотрим задачу, аналогичную нашей, но с финишем в вершине a1 вместо f. Плохие и хорошие ребра будут такими же, потому что они не зависят от финиша. У нас должен победить первый игрок. Изменим все ребра на l[i] и r[i] так, как мы это делали в первом пункте. Заметим, что все плохие ребра будут равными r[i], потому что первый в кратчайшем пути по них не проходит. То есть у нас получилось, что у нас только подмножество хороших ребер равны l[i] и для ребра (a1, b1) выполняется условие d1[a1] < d2[a1]. С (d) получается, что условие для этого ребра должно выполняться и после того, как мы все хорошие ребра поставим равными l[i]. А это противоречит тому, что это ребро плохое. Это значит, что при любом раскладе первому не выгодно идти через плохие ребра. Поэтому мы можем всем им поставить r[i]. Теперь l[i] мы можем поставить только подмножеству хороших ребер. Пусть для него у нас выполняется d1[F] < d2[F]. Но за свойством (d) у нас это будет выполняться и если мы все хорошие ребра поставим равными l[i]. Заметим, что у нас доказательство практически не измениться, если Левко хочет завершить игру ничьей.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 360\\s*C"
          },
          "content_length": 9841
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #210 - Codeforces - Code 1",
          "code": "Несложно доказать, что либо массив b будет удовлетворять условие, либо такого массива не существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9529",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 2000, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 2000, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 2000, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_k = n * (n +1) / 2;\n    int k = opt<int>(\"k\", max_k);\n    string s_type = opt<string>(\"s_type\", \"random\");\n\n    // Ensure k is within acceptable bounds\n    if (k < 0) k = 0;\n    if (k > max_k) k = max_k;\n\n    string s;\n    // Generate s based on s_type\n    if (s_type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n    } else if (s_type == \"all_same\") {\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (s_type == \"ascending\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 26);\n            s += c;\n        }\n    } else if (s_type == \"descending\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'z' - (i % 26);\n            s += c;\n        }\n    } else if (s_type == \"palindrome\") {\n        string half = \"\";\n        int half_length = (n + 1) / 2;\n        for (int i = 0; i < half_length; ++i) {\n            char c = rnd.next('a', 'z');\n            half += c;\n        }\n        s = half;\n        if (n % 2 == 1) half.pop_back();\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (s_type == \"min_string\") {\n        s = string(n, 'a');\n    } else if (s_type == \"max_string\") {\n        s = string(n, 'z');\n    } else {\n        // default to random\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n    }\n\n    printf(\"%d %d\\n%s\\n\", n, k, s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_k = n * (n +1) / 2;\n    int k = opt<int>(\"k\", max_k);\n    string s_type = opt<string>(\"s_type\", \"random\");\n\n    // Ensure k is within acceptable bounds\n    if (k < 0) k = 0;\n    if (k > max_k) k = max_k;\n\n    string s;\n    // Generate s based on s_type\n    if (s_type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n    } else if (s_type == \"all_same\") {\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (s_type == \"ascending\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 26);\n            s += c;\n        }\n    } else if (s_type == \"descending\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'z' - (i % 26);\n            s += c;\n        }\n    } else if (s_type == \"palindrome\") {\n        string half = \"\";\n        int half_length = (n + 1) / 2;\n        for (int i = 0; i < half_length; ++i) {\n            char c = rnd.next('a', 'z');\n            half += c;\n        }\n        s = half;\n        if (n % 2 == 1) half.pop_back();\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (s_type == \"min_string\") {\n        s = string(n, 'a');\n    } else if (s_type == \"max_string\") {\n        s = string(n, 'z');\n    } else {\n        // default to random\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n    }\n\n    printf(\"%d %d\\n%s\\n\", n, k, s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -s_type min_string\n./gen -n 1 -k 0 -s_type max_string\n\n./gen -n 2 -k 1 -s_type ascending\n./gen -n 2 -k 2 -s_type descending\n\n./gen -n 5 -k 0 -s_type all_same\n./gen -n 5 -k 10 -s_type all_same\n\n./gen -n 10 -k 5 -s_type random\n./gen -n 10 -k 10 -s_type random\n./gen -n 10 -k 20 -s_type random\n\n./gen -n 50 -k 0 -s_type min_string\n./gen -n 50 -k 1000 -s_type min_string\n./gen -n 50 -k 1000 -s_type max_string\n./gen -n 50 -s_type ascending\n\n./gen -n 100 -k 5000 -s_type descending\n./gen -n 100 -k 0 -s_type ascending\n./gen -n 100 -k 1000 -s_type all_same\n\n./gen -n 500 -k 100000 -s_type palindrome\n\n./gen -n 1000 -k 10000 -s_type random\n\n./gen -n 2000 -k 0 -s_type min_string\n./gen -n 2000 -k 2000000 -s_type max_string\n./gen -n 2000 -k 1000000 -s_type random\n\n./gen -n 2000 -k 1234567 -s_type random\n\n./gen -n 2000 -k 2000000 -s_type ascending\n./gen -n 2000 -k 0 -s_type descending\n\n./gen -n 2000 -k 2000000 -s_type all_same\n\n./gen -n 2000 -k 0 -s_type palindrome\n./gen -n 2000 -k 500000 -s_type palindrome\n\n./gen -n 1 -k 0 -s_type random\n\n./gen -n 1000 -k 500000 -s_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:11.918065",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "360/D",
      "title": "D. Левко и множества",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа n, m и p (1 ≤ n ≤ 104, 1 ≤ m ≤ 105, 2 ≤ p ≤ 109), p — простое. Во второй строке через пробел записаны числа a1, a2, ... , an (1 ≤ ai < p). В третьей строке через пробел записаны числа b1, b2, ... , bm (1 ≤ bi ≤ 109).",
      "output_spec": "Выходные данныеЕдинственное число — размер объединения множеств.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1 725Выходные данныеСкопировать3Входные данныеСкопировать1 2 722 4Выходные данныеСкопировать3Входные данныеСкопировать2 1 71 62Выходные данныеСкопировать1Входные данныеСкопировать2 1 71 65Выходные данныеСкопировать2",
      "description": "D. Левко и множества\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа n, m и p (1 ≤ n ≤ 104, 1 ≤ m ≤ 105, 2 ≤ p ≤ 109), p — простое. Во второй строке через пробел записаны числа a1, a2, ... , an (1 ≤ ai < p). В третьей строке через пробел записаны числа b1, b2, ... , bm (1 ≤ bi ≤ 109).\n\nВходные данные\n\nВыходные данныеЕдинственное число — размер объединения множеств.\n\nВыходные данные\n\nВходные данныеСкопировать1 1 725Выходные данныеСкопировать3Входные данныеСкопировать1 2 722 4Выходные данныеСкопировать3Входные данныеСкопировать2 1 71 62Выходные данныеСкопировать1Входные данныеСкопировать2 1 71 65Выходные данныеСкопировать2\n\nВходные данныеСкопировать1 1 725\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2 722 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1 71 62\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1 71 65\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Всем привет!Скоро, 10 ноября в 21.00 MSK состоится Codeforces Round #210 и его автором буду я. Это мой первый раунд на Codeforces и я очень надеюсь, что все пройдет хорошо. Спасибо Геральду Агапову (Gerald) и Виталию Аксенову(Aksenov239) за помощь в подготовке раунда.Удачи!UPD. Разбалловка в первом дивизионе: 500-1000-1500-1500-2000.Разбалловка во втором дивизионе: 500-1000-1500-2000-2500.UPD.Поздравляем победителей!Первый дивизион: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Второй дивизион: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD. Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 574
        },
        {
          "title": "Разбор Codeforces Round #210 - Codeforces",
          "content": "361A - Левко и таблицаМатрица, у которой все диагональные элементы равны k, а другие 0 удовлетворяет условие. Например для n = 4, k = 7 она будет такой:7 0 0 00 7 0 00 0 7 00 0 0 7361B - Левко и перестановкаТак, как gcd(1, m) = 1, то при n = k ответа не существует.Воспользуемся фактом, что gcd(m, m - 1) = 1 и построим такую перестановку:n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Левко и восстановление массиваНайдем для каждой позиции i такое значение b[i], что a[i] ≤ b[i]. Что бы найти эти значения, будем симулировать операции, поддерживая массив diff[i] — разница между теперешним значением i-ого элемента и его начальным значением. Если операция первого типа, то меняем нужные значения delta[i], иначе мы знаем, что a[i] + diff[i] ≤ m[i], из этого следует, что a[i] ≤ m[i] - diff[i]. Объединим все эти неравенства и мы получим массив b.Докажем, что либо b удовлетворяет условие, либо такого массива не существует. Возможны два варианта не выполнения операции второго типа: — но это невозможно из построения массива b. — но мы взяли на каждой позиции максимум, то есть мы не можем получить значение больше и чтобы при этом выполнялись все другие условия. 360B - Левко и массивСделаем бинпоиск по ответу. Чтобы проверить можно ли достичь ответа x, сделаем дп.dp[i] — это минимальное количество элементов, которые нужно изменить до i-ого, и при том i-ый элемент мы не меняем. Перебираем следующий элемент j, который мы не меняем. Тогда мы знаем, что элементы i и j мы не меняем, а все остальные между ними можем менять. Чтобы проверить можем ли мы так сделать, нужно всего лишь, чтобы выполнялось условие |aj - ai| ≤ (j - i)·xЭто так, потому что между соседними разница может быть максимум x, а между элементами i и j ровно j - i раз разница может увеличиваться на x.360C - Левко и строкиПосчитаем количество таких подстрок t, которые больше соответствующих подстрок s и начинаются в позиции i. Если t[i] < s[i], то 0. Если t[i] > s[i], то n - i. Если t[i] = s[i], то найдем ближайшую позицию j,  j > i , такую, что t[j] ≠ s[j]. Если t[j] > s[j], то нужное количество подстрок будет n - j. Если t[j] < s[j], то 0.Это мы можем переформулировать так: Если t[i] > s[i], то будет (1 + pref)·(n - i) новых подстрок, где pref означает сколько последних перед i элементов из s и t равны.Сделаем дп. dp[i][sum] — значит, что мы просмотрели i позиций и набрали sum нужных подстрок, при этом значение t и s в i-ой позиции отличаются. Будем делать ее назад. Переберем общий префикс pref этих строк и то больше или меньше t[i].Если t[i] < s[i], то dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — это посчитаем частичными сумами.Если t[i] > s[i], то dp[i][smum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Будем перебирать pref. Заметим, что sum - pref·(n - i) ≥ 0, то есть pref ≤ sum / (n - i) и pref ≤ k / (n - i). Это значит, что при нахождении значения dp[i][sum] третий цикл выполнит не больше k / (n - i) итераций. Посчитаем общее количество итераций:  =   <  k·(n + k·log  k).360D - Левко и множестваТак, как число p — простое, то должен существовать первообразный корень g по модулю p(Явно мы его не находим, пусть просто он есть). Тогда запишем каждое ai = gri. Заметим, что в i-ом множестве будут находиться все числа вида , где cj ≥ 0. Это можно записать как .Малая теорема Ферма — ap - 1 = 1 mod p. Это также значит, что ak mod p = ak mod (p - 1) mod p. Из этого следует, что может принимать все значения k·t по модулю p - 1, где t = gcd(b1, b2, ... , bm, p - 1). Заметим, что t никак не зависит от ri, поэтому мы можем сделать g = gt. Тогда все элементы с i-ого множества будут выглядить, как gri·k, где k ≥ 0. Заметим, что мы получили приктически такой же запис как и с bi в начале, сделаем то же. Заменим ri на qi, где qi = gcd(ri, p - 1). Тогда все элементы с i-ого множества будут выглядить, как gqi·k, где k ≥ 0. Это значит, что если мы запишем значения g0, g1, ..., gp - 2 в строку, то в i-ом множестве будет каждый qi-ый.Теперь чтобы найти объединение этих множеств, нам нужно применить принцип включения-исключения. Так как все числа, которые мы маем — делители p - 1, то мы можем добавлять qi по одному, поддержывая dpi — коефициэнт возле i в принцыпе включения-исключения.Нам осталось найти qi. Рассмотрим количество элементов в i-ом множестве. С одной стороны оно равно . С другой стороны это количество равно минимальному такому значению di, что aidi = 1 mod p (di — цыкл). Из того что aip - 1 = 1 mod p маем, что p - 1 делится на di. Найдем di среди делителей p - 1. Теперь .360E - Левко и играАлгоритм:Сначала будем решать задачу, может ли первый победить.Сделаем все дороги, которые можно менять, равными r[i] и запустим две Дейкстры из вершын s1 и s2. Пусть массив d1[i] — расстояное от s1 до i, d2[i] — расстояние от s2 до i. Рассмотрим дорогу из a в b, которую можно менять. Если d1[a] < d2[a], то поставим длину этой дороги равной l[i] и опять запустим две Дейкстры. Так делаем пока мы можем изменить значение хотя бы одной дороги.Если в конце у нас получилось d1[f] < d2[f], то первый может победить.Дальше повторим тоже самое, только условие d1[a] < d2[a] меняем на d1[a] ≤ d2[a]. Это нам даст, может ли первый игрок достичь ничьи.Доказательство:Будем называть ребрами только те дороги, которые Левко может менять. Причем, если мы запускаем Дейкстру из какой-то вершины, то мы учитываем все дороги. Докажем, что если существует расклад значений ребер, при котором первый игрок выигрывает, то существует такой, при котором он выигрывает и все ребра равны либо l[i], либо r[i]. Возьмем кратчайшие пути первого и второго игрока из данного расклада.Тогда если по ребру из a в b проходит только первый, то мы можем установить его значение l[i]. Доказательство: для этого ребра должно выполняться d1[a] < d2[a], потому что первому выгодно по нему проходить и он выигрывает. Это условие выполняться и после изменения значения ребра. Тогда второй либо идет по нему и проигрывает потому, что d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f] , либо не идет и тоже проигрывает потому, что расстояние первого уменьшилось, а его нет(d(x, y) — кратчайшее расстояние между x и y).Если по ребру проходит только второй, то можем поставить r[i]. Доказательство: Первый по нему проходить и так не будет, а путь второго от этого меньше не станет.Если по ребру не проходит ни один игрок поставим его равным r[i]. Доказательство: Пути игроков никак не изменяться.Если по ребру проходят оба игрока, то поставим l[i]. Доказательство: Пути обоих игроков уменьшаться на (предыдущее значение — l[i]).После каждой из этих операций если первый выигрывал, то он и продолжает выигрывать, но в конце у нас получаться все ребра равными либо l[i], либо r[i]. Рассмотрим результат выполнения алгоритма: некоторые ребра будут равны l[i], а некоторые r[i]. Назовем ребра хорошими если на них теперь стоит l[i] и плохими — если r[i].(a) Докажем, что в конце для всех хороших ребер выполняется условие d1[a] < d2[a]. Докажем от супротивного. Пусть у нас для ребра (a1, b1) выполнялось d1[a1] < d2[a1], а после нескольких итераций перестало выполняться. Пусть оно перестало выполняться, после изменения ребра (a2, b2). Тогда мы маем такие неравенства d1[a1] >  = d2[a1], d1[a2] < d2[a2]. Так как мы изменили только одно ребро и расстояние второго игрока до а1 уменьшилось, то на кратчайшем от него до а1 он идет по ребру (a2, b2).d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Получили противоречие.(b) Докажем, что в конце для всех плохих ребер выполняется условие d1[a] ≥ d2[a]. Если бы оно не выполнялось, то мы продолжили бы наш процесс.(c) Докажем, что если для какого-то ребра стало выполняться условие d1[a] < d2[a], но на этом шаге мы его не изменили(изменили другое), то это условие не может перестать выполняться. Оно доказывается аналогично (a).(d) Докажем, что если у нас какое-то подмножество хороших ребер равны l[i] и для ребра (a, b) выполняется условие, то оно не может перестать выполняться после того, как мы поставим все хорошие ребра поставить равными l[i]. Для этого просто симулируем весь процесс, применяя (c). Докажем, что при любом раскладе ребер(даже не обязательно только l[i] или r[i]) мы не можем получить ситуации, в которой для плохого ребра (a, b) выполняется условие d1[a] < d2[a].Докажем от супротивного. Пусть у нас существует такое ребро. Рассмотрит путь первого до его начала. Если на этом пути есть плохие ребра (a1, b1), то для них тоже должно выполняться условие d1[a1] < d2[a1] (Если не выполняется , то d2[a] ≤ d2[a1] + d(a1, b1) + d(b1, a) ≤ d1[a1] + d(a1, b1) + d(b1, a) = d1[a]. Противоречие.) . Возьмем первое из них. Тогда путь первого до его начала может содержать только хорошие ребра. Рассмотрим задачу, аналогичную нашей, но с финишем в вершине a1 вместо f. Плохие и хорошие ребра будут такими же, потому что они не зависят от финиша. У нас должен победить первый игрок. Изменим все ребра на l[i] и r[i] так, как мы это делали в первом пункте. Заметим, что все плохие ребра будут равными r[i], потому что первый в кратчайшем пути по них не проходит. То есть у нас получилось, что у нас только подмножество хороших ребер равны l[i] и для ребра (a1, b1) выполняется условие d1[a1] < d2[a1]. С (d) получается, что условие для этого ребра должно выполняться и после того, как мы все хорошие ребра поставим равными l[i]. А это противоречит тому, что это ребро плохое. Это значит, что при любом раскладе первому не выгодно идти через плохие ребра. Поэтому мы можем всем им поставить r[i]. Теперь l[i] мы можем поставить только подмножеству хороших ребер. Пусть для него у нас выполняется d1[F] < d2[F]. Но за свойством (d) у нас это будет выполняться и если мы все хорошие ребра поставим равными l[i]. Заметим, что у нас доказательство практически не измениться, если Левко хочет завершить игру ничьей.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 360\\s*D"
          },
          "content_length": 9841
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #210 - Codeforces - Code 1",
          "code": "Несложно доказать, что либо массив b будет удовлетворять условие, либо такого массива не существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9529",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform modular exponentiation.\nint powerMod(int a, int d, int n) {\n    int64_t result = 1;\n    int64_t base = a % n;\n\n    while (d > 0) {\n        if (d % 2 == 1) {\n            result = result * base % n;\n        }\n        base = base * base % n;\n        d >>= 1;\n    }\n    return result;\n}\n\n// Miller-Rabin Primality Test for n <= 1e9\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n\n    int bases[] = {2, 3, 5, 7, 11};\n    for (int a : bases) {\n        if (a >= n) continue;\n\n        int x = powerMod(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n\n        bool composite = true;\n        for (int r = 0; r < s - 1; r++) {\n            x = int64_t(x) * x % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) {\n            ensuref(false, \"p=%d is not a prime number\", n);\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(2, 1000000000, \"p\");\n    inf.readEoln();\n\n    ensuref(isPrime(p), \"p=%d is not a prime number\", p);\n\n    vector<int> a = inf.readInts(n, 1, p - 1, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform modular exponentiation.\nint powerMod(int a, int d, int n) {\n    int64_t result = 1;\n    int64_t base = a % n;\n\n    while (d > 0) {\n        if (d % 2 == 1) {\n            result = result * base % n;\n        }\n        base = base * base % n;\n        d >>= 1;\n    }\n    return result;\n}\n\n// Miller-Rabin Primality Test for n <= 1e9\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n\n    int bases[] = {2, 3, 5, 7, 11};\n    for (int a : bases) {\n        if (a >= n) continue;\n\n        int x = powerMod(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n\n        bool composite = true;\n        for (int r = 0; r < s - 1; r++) {\n            x = int64_t(x) * x % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) {\n            ensuref(false, \"p=%d is not a prime number\", n);\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(2, 1000000000, \"p\");\n    inf.readEoln();\n\n    ensuref(isPrime(p), \"p=%d is not a prime number\", p);\n\n    vector<int> a = inf.readInts(n, 1, p - 1, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform modular exponentiation.\nint powerMod(int a, int d, int n) {\n    int64_t result = 1;\n    int64_t base = a % n;\n\n    while (d > 0) {\n        if (d % 2 == 1) {\n            result = result * base % n;\n        }\n        base = base * base % n;\n        d >>= 1;\n    }\n    return result;\n}\n\n// Miller-Rabin Primality Test for n <= 1e9\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n\n    int bases[] = {2, 3, 5, 7, 11};\n    for (int a : bases) {\n        if (a >= n) continue;\n\n        int x = powerMod(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n\n        bool composite = true;\n        for (int r = 0; r < s - 1; r++) {\n            x = int64_t(x) * x % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) {\n            ensuref(false, \"p=%d is not a prime number\", n);\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(2, 1000000000, \"p\");\n    inf.readEoln();\n\n    ensuref(isPrime(p), \"p=%d is not a prime number\", p);\n\n    vector<int> a = inf.readInts(n, 1, p - 1, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int p = opt<int>(\"p\", 1000000007); // Default p\n    string type_arg = opt<string>(\"type\", \"random\");\n\n    vector<string> type_tokens;\n    stringstream ss(type_arg);\n    string token;\n    while (getline(ss, token, ',')) {\n        type_tokens.push_back(token);\n    }\n\n    // Flags for types\n    bool ai_same = false;\n    bool ai_one = false;\n    bool bi_same = false;\n    bool bi_one = false;\n    bool p_small = false;\n    bool p_large = false;\n\n    for (string t : type_tokens) {\n        if (t == \"ai_same\") ai_same = true;\n        else if (t == \"ai_one\") ai_one = true;\n        else if (t == \"bi_same\") bi_same = true;\n        else if (t == \"bi_one\") bi_one = true;\n        else if (t == \"p_small\") p_small = true;\n        else if (t == \"p_large\") p_large = true;\n    }\n\n    if (p_small) {\n        vector<int> small_primes = {2, 3, 5, 7, 11, 13};\n        p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n    }\n    if (p_large) {\n        p = 1000000007;\n    }\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (ai_same) {\n        int ai_value = ai_one ? 1 : rnd.next(1, p - 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_value;\n    } else {\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_one ? 1 : rnd.next(1, p - 1);\n    }\n\n    if (bi_same) {\n        int bi_value = bi_one ? 1 : rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = bi_value;\n    } else {\n        for (int i = 0; i < m; ++i)\n            b[i] = bi_one ? 1 : rnd.next(1, 1000000000);\n    }\n\n    // Output n m p\n    printf(\"%d %d %d\\n\", n, m, p);\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    // Output array b\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int p = opt<int>(\"p\", 1000000007); // Default p\n    string type_arg = opt<string>(\"type\", \"random\");\n\n    vector<string> type_tokens;\n    stringstream ss(type_arg);\n    string token;\n    while (getline(ss, token, ',')) {\n        type_tokens.push_back(token);\n    }\n\n    // Flags for types\n    bool ai_same = false;\n    bool ai_one = false;\n    bool bi_same = false;\n    bool bi_one = false;\n    bool p_small = false;\n    bool p_large = false;\n\n    for (string t : type_tokens) {\n        if (t == \"ai_same\") ai_same = true;\n        else if (t == \"ai_one\") ai_one = true;\n        else if (t == \"bi_same\") bi_same = true;\n        else if (t == \"bi_one\") bi_one = true;\n        else if (t == \"p_small\") p_small = true;\n        else if (t == \"p_large\") p_large = true;\n    }\n\n    if (p_small) {\n        vector<int> small_primes = {2, 3, 5, 7, 11, 13};\n        p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n    }\n    if (p_large) {\n        p = 1000000007;\n    }\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (ai_same) {\n        int ai_value = ai_one ? 1 : rnd.next(1, p - 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_value;\n    } else {\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_one ? 1 : rnd.next(1, p - 1);\n    }\n\n    if (bi_same) {\n        int bi_value = bi_one ? 1 : rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = bi_value;\n    } else {\n        for (int i = 0; i < m; ++i)\n            b[i] = bi_one ? 1 : rnd.next(1, 1000000000);\n    }\n\n    // Output n m p\n    printf(\"%d %d %d\\n\", n, m, p);\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    // Output array b\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m, random type\n./gen -n 1 -m 1 -p 7 -type random\n./gen -n 5 -m 5 -p 11 -type random\n\n# Maximum n and m, random type\n./gen -n 10000 -m 100000 -p 1000000007 -type random\n\n# All 'a_i' are the same random value\n./gen -n 10000 -m 100000 -p 1000000007 -type ai_same\n\n# All 'a_i' are 1\n./gen -n 10000 -m 100000 -p 1000000007 -type ai_one\n\n# All 'b_i' are the same random value\n./gen -n 10000 -m 100000 -p 1000000007 -type bi_same\n\n# All 'a_i' and 'b_i' are the same random values\n./gen -n 10000 -m 100000 -p 1000000007 -type ai_same,bi_same\n\n# All 'a_i' and 'b_i' are 1\n./gen -n 10000 -m 100000 -p 1000000007 -type ai_one,bi_one\n\n# Small prime 'p'\n./gen -n 10000 -m 100000 -type p_small\n\n# Large prime 'p'\n./gen -n 10000 -m 100000 -type p_large\n\n# Small 'n'\n./gen -n 1 -m 100000 -p 1000000007 -type random\n\n# Small 'm'\n./gen -n 10000 -m 1 -p 1000000007 -type random\n\n# Maximum values\n./gen -n 10000 -m 100000 -p 999999937 -type random\n\n# 'n' and 'm' are primes\n./gen -n 9973 -m 99991 -p 999999937 -type random\n\n# Small 'n' and small prime 'p'\n./gen -n 1 -m 100000 -type p_small\n\n# Random combinations\n./gen -n 5000 -m 50000 -p 999999937 -type random\n\n# Small 'n' with 'a_i' the same\n./gen -n 1 -m 100000 -p 1000000007 -type ai_same\n\n# Small 'm' with 'b_i' the same\n./gen -n 10000 -m 1 -p 1000000007 -type bi_same\n\n# Random with 'p = 2'\n./gen -n 5000 -m 5000 -p 2 -type random\n\n# Random with 'p' close to upper limit\n./gen -n 5000 -m 5000 -p 999999937 -type random\n\n# All 'a_i' are 1 and 'p' is small\n./gen -n 10000 -m 100000 -type p_small,ai_one\n\n# All 'a_i' and 'b_i' are 1, 'p' is small\n./gen -n 10000 -m 100000 -type p_small,ai_one,bi_one\n\n# All 'a_i' and 'b_i' are the same, 'p' is large\n./gen -n 10000 -m 100000 -type ai_same,bi_same,p_large\n\n# All 'a_i' are 1 and 'b_i' are same\n./gen -n 10000 -m 100000 -p 1000000007 -type ai_one,bi_same\n\n# Small 'n' and 'm', all 'a_i' and 'b_i' are 1\n./gen -n 1 -m 1 -p 7 -type ai_one,bi_one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:13.734989",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}